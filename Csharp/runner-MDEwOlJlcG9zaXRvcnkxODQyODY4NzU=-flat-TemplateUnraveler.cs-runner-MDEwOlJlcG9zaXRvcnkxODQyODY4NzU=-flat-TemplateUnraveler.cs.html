
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateUnraveler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  using GitHub.DistributedTask.ObjectTemplating.Tokens;
5  namespace GitHub.DistributedTask.ObjectTemplating
6  {
7      internal sealed class TemplateUnraveler
8      {
9          internal TemplateUnraveler(
10              TemplateContext context,
11              TemplateToken template,
12              Int32 removeBytes)
13          {
14              m_context = context;
15              m_memory = context.Memory;
16              MoveFirst(template, removeBytes);
17          }
18          internal Boolean AllowScalar(
19              Boolean expand,
20              out ScalarToken scalar)
21          {
22              m_memory.IncrementEvents();
23              if (expand)
24              {
25                  Unravel(expand: true);
26              }
27              if (m_current?.Value is ScalarToken scalarToken)
28              {
29                  scalar = scalarToken;
30                  m_memory.AddBytes(scalar);
31                  MoveNext();
32                  return true;
33              }
34              scalar = null;
35              return false;
36          }
37          internal Boolean AllowSequenceStart(
38              Boolean expand,
39              out SequenceToken sequence)
40          {
41              m_memory.IncrementEvents();
42              if (expand)
43              {
44                  Unravel(expand: true);
45              }
46              if (m_current is SequenceState sequenceState && sequenceState.IsStart)
47              {
48                  sequence = new SequenceToken(sequenceState.Value.FileId, sequenceState.Value.Line, sequenceState.Value.Column);
49                  m_memory.AddBytes(sequence);
50                  MoveNext();
51                  return true;
52              }
53              sequence = null;
54              return false;
55          }
56          internal Boolean AllowSequenceEnd(Boolean expand)
57          {
58              m_memory.IncrementEvents();
59              if (expand)
60              {
61                  Unravel(expand: true);
62              }
63              if (m_current is SequenceState sequenceState && sequenceState.IsEnd)
64              {
65                  MoveNext();
66                  return true;
67              }
68              return false;
69          }
70          internal Boolean AllowMappingStart(
71              Boolean expand,
72              out MappingToken mapping)
73          {
74              m_memory.IncrementEvents();
75              if (expand)
76              {
77                  Unravel(expand: true);
78              }
79              if (m_current is MappingState mappingState && mappingState.IsStart)
80              {
81                  mapping = new MappingToken(mappingState.Value.FileId, mappingState.Value.Line, mappingState.Value.Column);
82                  m_memory.AddBytes(mapping);
83                  MoveNext();
84                  return true;
85              }
86              mapping = null;
87              return false;
88          }
89          internal Boolean AllowMappingEnd(Boolean expand)
90          {
91              m_memory.IncrementEvents();
92              if (expand)
93              {
94                  Unravel(expand: true);
95              }
96              if (m_current is MappingState mappingState && mappingState.IsEnd)
97              {
98                  MoveNext();
99                  return true;
100              }
101              return false;
102          }
103          internal void ReadEnd()
104          {
105              m_memory.IncrementEvents();
106              if (m_current != null)
107              {
108                  throw new InvalidOperationException("Expected end of template object. " + DumpState());
109              }
110          }
111          internal void ReadMappingEnd()
112          {
113              if (!AllowMappingEnd(expand: false))
114              {
115                  throw new InvalidOperationException("Unexpected state while attempting to read the mapping end. " + DumpState());
116              }
117          }
118          internal void SkipSequenceItem()
119          {
120              m_memory.IncrementEvents();
121              if (!(m_current?.Parent is SequenceState ancestor))
122              {
123                  throw new InvalidOperationException("Unexpected state while attempting to skip the current sequence item. " + DumpState());
124              }
125              MoveNext(skipNestedEvents: true);
126          }
127          internal void SkipMappingKey()
128          {
129              m_memory.IncrementEvents();
130              if (!(m_current?.Parent is MappingState ancestor) || !ancestor.IsKey)
131              {
132                  throw new InvalidOperationException("Unexpected state while attempting to skip the current mapping key. " + DumpState());
133              }
134              MoveNext(skipNestedEvents: true);
135          }
136          internal void SkipMappingValue()
137          {
138              m_memory.IncrementEvents();
139              if (!(m_current?.Parent is MappingState ancestor) || ancestor.IsKey)
140              {
141                  throw new InvalidOperationException("Unexpected state while attempting to skip the current mapping value. " + DumpState());
142              }
143              MoveNext(skipNestedEvents: true);
144          }
145          private String DumpState()
146          {
147              var result = new StringBuilder();
148              if (m_current == null)
149              {
150                  result.AppendLine("State: (null)");
151              }
152              else
153              {
154                  result.AppendLine("State:");
155                  result.AppendLine();
156                  var stack = new Stack<ReaderState>();
157                  var curr = m_current;
158                  while (curr != null)
159                  {
160                      result.AppendLine(curr.ToString());
161                      curr = curr.Parent;
162                  }
163              }
164              return result.ToString();
165          }
166          private void MoveFirst(
167              TemplateToken value,
168              Int32 removeBytes)
169          {
170              if (!(value is LiteralToken) && !(value is SequenceToken) && !(value is MappingToken) && !(value is BasicExpressionToken))
171              {
172                  throw new NotSupportedException($"Unexpected type '{value?.GetType().Name}' when initializing object reader state");
173              }
174              m_memory.IncrementEvents();
175              m_current = ReaderState.CreateState(null, value, m_context, removeBytes);
176          }
177          private void MoveNext(Boolean skipNestedEvents = false)
178          {
179              m_memory.IncrementEvents();
180              if (m_current == null)
181              {
182                  return;
183              }
184              if (m_current is SequenceState sequenceState &&
185                  sequenceState.IsStart &&
186                  !skipNestedEvents)
187              {
188                  m_current = sequenceState.Next();
189              }
190              else if (m_current is MappingState mappingState &&
191                  mappingState.IsStart &&
192                  !skipNestedEvents)
193              {
194                  m_current = mappingState.Next();
195              }
196              else if (m_current.Parent is SequenceState parentSequenceState)
197              {
198                  m_current.Remove();
199                  m_current = parentSequenceState.Next();
200              }
201              else if (m_current.Parent is MappingState parentMappingState)
202              {
203                  m_current.Remove();
204                  m_current = parentMappingState.Next();
205              }
206              else if (m_current.Parent != null)
207              {
208                  m_current.Remove();
209                  m_current = m_current.Parent;
210              }
211              else
212              {
213                  m_current.Remove();
214                  m_current = null;
215              }
216              m_expanded = false;
217              Unravel(expand: false);
218          }
219          private void Unravel(Boolean expand)
220          {
221              if (m_expanded)
222              {
223                  return;
224              }
225              do
226              {
227                  if (m_current == null)
228                  {
229                      break;
230                  }
231                  else if (m_current is LiteralState literalState)
232                  {
233                      break;
234                  }
235                  else if (m_current is BasicExpressionState basicExpressionState)
236                  {
237                      if (basicExpressionState.IsStart &&
238                          m_current.Parent is SequenceState)
239                      {
240                          if (expand)
241                          {
242                              SequenceItemBasicExpression();
243                          }
244                          else
245                          {
246                              break;
247                          }
248                      }
249                      else if (basicExpressionState.IsStart &&
250                          m_current.Parent is MappingState parentMappingState &&
251                          parentMappingState.IsKey)
252                      {
253                          if (expand)
254                          {
255                              MappingKeyBasicExpression();
256                          }
257                          else
258                          {
259                              break;
260                          }
261                      }
262                      else if (basicExpressionState.IsStart &&
263                          m_current.Parent is MappingState parentMappingState2 &&
264                          !parentMappingState2.IsKey)
265                      {
266                          if (expand)
267                          {
268                              MappingValueBasicExpression();
269                          }
270                          else
271                          {
272                              break;
273                          }
274                      }
275                      else if (basicExpressionState.IsStart &&
276                          m_current.Parent is null)
277                      {
278                          if (expand)
279                          {
280                              RootBasicExpression();
281                          }
282                          else
283                          {
284                              break;
285                          }
286                      }
287                      else if (basicExpressionState.IsEnd)
288                      {
289                          EndExpression();
290                      }
291                      else
292                      {
293                          UnexpectedState();
294                      }
295                  }
296                  else if (m_current is MappingState mappingState)
297                  {
298                      if (mappingState.IsEnd &&
299                          m_current.Parent is InsertExpressionState)
300                      {
301                          m_current.Remove();
302                          m_current = m_current.Parent; 
303                      }
304                      else if (mappingState.IsStart)
305                      {
306                          break;
307                      }
308                      else if (mappingState.IsEnd)
309                      {
310                          break;
311                      }
312                      else
313                      {
314                          UnexpectedState();
315                      }
316                  }
317                  else if (m_current is SequenceState sequenceState)
318                  {
319                      if (sequenceState.IsEnd &&
320                          m_current.Parent is BasicExpressionState &&
321                          m_current.Parent.Parent is SequenceState)
322                      {
323                          m_current.Remove();
324                          m_current = m_current.Parent; 
325                      }
326                      else if (sequenceState.IsStart)
327                      {
328                          break;
329                      }
330                      else if (sequenceState.IsEnd)
331                      {
332                          break;
333                      }
334                      else
335                      {
336                          UnexpectedState();
337                      }
338                  }
339                  else if (m_current is InsertExpressionState insertExpressionState)
340                  {
341                      if (insertExpressionState.IsStart &&
342                          m_current.Parent is MappingState parentMappingState &&
343                          parentMappingState.IsKey)
344                      {
345                          if (expand)
346                          {
347                              StartMappingInsertion();
348                          }
349                          else
350                          {
351                              break;
352                          }
353                      }
354                      else if (insertExpressionState.IsEnd)
355                      {
356                          EndExpression();
357                      }
358                      else if (insertExpressionState.IsStart)
359                      {
360                          m_context.Error(insertExpressionState.Value, TemplateStrings.DirectiveNotAllowed(insertExpressionState.Value.Directive));
361                          m_current.Remove();
362                          m_current = insertExpressionState.ToStringToken();
363                      }
364                      else
365                      {
366                          UnexpectedState();
367                      }
368                  }
369                  else
370                  {
371                      UnexpectedState();
372                  }
373                  m_memory.IncrementEvents();
374              } while (true);
375              m_expanded = expand;
376          }
377          private void SequenceItemBasicExpression()
378          {
379              var expressionState = m_current as BasicExpressionState;
380              var expression = expressionState.Value;
<span onclick='openModal()' class='match'>381              TemplateToken value;
382              var removeBytes = 0;
383              try
384              {
385                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
386              }
387              catch (Exception ex)
388              {
389                  m_context.Error(expression, ex);
390                  value = null;
</span>391              }
392              if (value is SequenceToken nestedSequence)
393              {
394                  m_current = expressionState.Next(nestedSequence, isSequenceInsertion: true, removeBytes: removeBytes);
395              }
396              else if (value != null)
397              {
398                  m_current = expressionState.Next(value, removeBytes);
399              }
400              else if (value == null)
401              {
402                  expressionState.End();
403              }
404          }
405          private void MappingKeyBasicExpression()
406          {
407              var expressionState = m_current as BasicExpressionState;
408              var expression = expressionState.Value as BasicExpressionToken;
409              StringToken stringToken;
410              var removeBytes = 0;
411              try
412              {
413                  stringToken = expression.EvaluateStringToken(expressionState.Context, out removeBytes);
414              }
415              catch (Exception ex)
416              {
417                  m_context.Error(expression, ex);
418                  stringToken = null;
419              }
420              if (stringToken != null)
421              {
422                  m_current = expressionState.Next(stringToken, removeBytes);
423              }
424              else
425              {
426                  m_current.Remove();
427                  var parentMappingState = m_current.Parent as MappingState;
428                  parentMappingState.Next().Remove(); 
429                  m_current = parentMappingState.Next(); 
430              }
431          }
432          private void MappingValueBasicExpression()
433          {
434              var expressionState = m_current as BasicExpressionState;
435              var expression = expressionState.Value;
436              TemplateToken value;
437              var removeBytes = 0;
438              try
439              {
440                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
441              }
442              catch (Exception ex)
443              {
444                  m_context.Error(expression, ex);
445                  value = new StringToken(expression.FileId, expression.Line, expression.Column, String.Empty);
446              }
447              m_current = expressionState.Next(value, removeBytes);
448          }
449          private void RootBasicExpression()
450          {
451              var expressionState = m_current as BasicExpressionState;
452              var expression = expressionState.Value;
453              TemplateToken value;
454              var removeBytes = 0;
455              try
456              {
457                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
458              }
459              catch (Exception ex)
460              {
461                  m_context.Error(expression, ex);
462                  value = new StringToken(expression.FileId, expression.Line, expression.Column, String.Empty);
463              }
464              m_current = expressionState.Next(value, removeBytes);
465          }
466          private void StartMappingInsertion()
467          {
468              var expressionState = m_current as InsertExpressionState;
469              var parentMappingState = expressionState.Parent as MappingState;
470              var nestedValue = parentMappingState.Value[parentMappingState.Index].Value;
471              var nestedMapping = nestedValue as MappingToken;
472              var removeBytes = 0;
473              if (nestedMapping != null)
474              {
475              }
476              else if (nestedValue is BasicExpressionToken basicExpression)
477              {
478                  try
479                  {
480                      nestedMapping = basicExpression.EvaluateMappingToken(expressionState.Context, out removeBytes);
481                  }
482                  catch (Exception ex)
483                  {
484                      m_context.Error(basicExpression, ex);
485                      nestedMapping = null;
486                  }
487              }
488              else
489              {
490                  m_context.Error(nestedValue, TemplateStrings.ExpectedMapping());
491                  nestedMapping = null;
492              }
493              if (nestedMapping?.Count > 0)
494              {
495                  m_current = expressionState.Next(nestedMapping, removeBytes);
496              }
497              else
498              {
499                  if (removeBytes > 0)
500                  {
501                      m_memory.SubtractBytes(removeBytes);
502                  }
503                  expressionState.End();
504              }
505          }
506          private void EndExpression()
507          {
508              if (m_current.Parent == null)
509              {
510                  m_current.Remove();
511                  m_current = null;
512              }
513              else if (m_current is BasicExpressionState)
514              {
515                  if (m_current.Parent is SequenceState parentSequenceState)
516                  {
517                      m_current.Remove();
518                      m_current = parentSequenceState.Next();
519                  }
520                  else
521                  {
522                      m_current.Remove();
523                      var parentMappingState = m_current.Parent as MappingState;
524                      m_current = parentMappingState.Next();
525                  }
526              }
527              else
528              {
529                  m_current.Remove();
530                  var parentMappingState = m_current.Parent as MappingState;
531                  parentMappingState.Next().Remove(); 
532                  m_current = parentMappingState.Next();
533              }
534          }
535          private void UnexpectedState()
536          {
537              throw new InvalidOperationException("Expected state while unraveling expressions. " + DumpState());
538          }
539          private abstract class ReaderState
540          {
541              public ReaderState(
542                  ReaderState parent,
543                  TemplateToken value,
544                  TemplateContext context)
545              {
546                  Parent = parent;
547                  Value = value;
548                  Context = context;
549              }
550              public static ReaderState CreateState(
551                  ReaderState parent,
552                  TemplateToken value,
553                  TemplateContext context,
554                  Int32 removeBytes = 0)
555              {
556                  switch (value.Type)
557                  {
558                      case TokenType.Null:
559                      case TokenType.Boolean:
560                      case TokenType.Number:
561                      case TokenType.String:
562                          return new LiteralState(parent, value as LiteralToken, context, removeBytes);
563                      case TokenType.Sequence:
564                          return new SequenceState(parent, value as SequenceToken, context, removeBytes);
565                      case TokenType.Mapping:
566                          return new MappingState(parent, value as MappingToken, context, removeBytes);
567                      case TokenType.BasicExpression:
568                          return new BasicExpressionState(parent, value as BasicExpressionToken, context, removeBytes);
569                      case TokenType.InsertExpression:
570                          if (removeBytes > 0)
571                          {
572                              throw new InvalidOperationException($"Unexpected {nameof(removeBytes)}");
573                          }
574                          return new InsertExpressionState(parent, value as InsertExpressionToken, context);
575                      default:
576                          throw new NotSupportedException($"Unexpected {nameof(ReaderState)} type: {value?.GetType().Name}");
577                  }
578              }
579              public ReaderState Parent { get; }
580              public TemplateContext Context { get; protected set; }
581              public TemplateToken Value { get; }
582              public abstract void Remove();
583          }
584          private abstract class ReaderState<T> : ReaderState
585              where T : class
586          {
587              public ReaderState(
588                  ReaderState parent,
589                  TemplateToken value,
590                  TemplateContext context)
591                  : base(parent, value, context)
592              {
593              }
594              public new T Value
595              {
596                  get
597                  {
598                      if (!Object.ReferenceEquals(base.Value, m_value))
599                      {
600                          m_value = base.Value as T;
601                      }
602                      return m_value;
603                  }
604              }
605              private T m_value;
606          }
607          private sealed class LiteralState : ReaderState<LiteralToken>
608          {
609              public LiteralState(
610                  ReaderState parent,
611                  LiteralToken literal,
612                  TemplateContext context,
613                  Int32 removeBytes)
614                  : base(parent, literal, context)
615              {
616                  context.Memory.AddBytes(literal);
617                  context.Memory.IncrementDepth();
618                  m_removeBytes = removeBytes;
619              }
620              public override void Remove()
621              {
622                  Context.Memory.SubtractBytes(Value);
623                  Context.Memory.DecrementDepth();
624                  if (m_removeBytes > 0)
625                  {
626                      Context.Memory.SubtractBytes(m_removeBytes);
627                  }
628              }
629              public override String ToString()
630              {
631                  var result = new StringBuilder();
632                  result.AppendLine($"{GetType().Name}");
633                  return result.ToString();
634              }
635              private Int32 m_removeBytes;
636          }
637          private sealed class SequenceState : ReaderState<SequenceToken>
638          {
639              public SequenceState(
640                  ReaderState parent,
641                  SequenceToken sequence,
642                  TemplateContext context,
643                  Int32 removeBytes)
644                  : base(parent, sequence, context)
645              {
646                  context.Memory.AddBytes(sequence);
647                  context.Memory.IncrementDepth();
648                  m_removeBytes = removeBytes;
649              }
650              public Boolean IsStart { get; private set; } = true;
651              public Int32 Index { get; private set; }
652              public Boolean IsEnd => !IsStart && Index >= Value.Count;
653              public ReaderState Next()
654              {
655                  if (IsStart)
656                  {
657                      IsStart = false;
658                  }
659                  else
660                  {
661                      Index++;
662                  }
663                  if (!IsEnd)
664                  {
665                      return CreateState(this, Value[Index], Context);
666                  }
667                  else
668                  {
669                      return this;
670                  }
671              }
672              public ReaderState End()
673              {
674                  IsStart = false;
675                  Index = Value.Count;
676                  return this;
677              }
678              public override void Remove()
679              {
680                  Context.Memory.SubtractBytes(Value);
681                  Context.Memory.DecrementDepth();
682                  if (m_removeBytes > 0)
683                  {
684                      Context.Memory.SubtractBytes(m_removeBytes);
685                  }
686              }
687              public override String ToString()
688              {
689                  var result = new StringBuilder();
690                  result.AppendLine($"{GetType().Name}:");
691                  result.AppendLine($"  IsStart: {IsStart}");
692                  result.AppendLine($"  Index: {Index}");
693                  result.AppendLine($"  IsEnd: {IsEnd}");
694                  return result.ToString();
695              }
696              private Int32 m_removeBytes;
697          }
698          private sealed class MappingState : ReaderState<MappingToken>
699          {
700              public MappingState(
701                  ReaderState parent,
702                  MappingToken mapping,
703                  TemplateContext context,
704                  Int32 removeBytes)
705                  : base(parent, mapping, context)
706              {
707                  context.Memory.AddBytes(mapping);
708                  context.Memory.IncrementDepth();
709                  m_removeBytes = removeBytes;
710              }
711              public Boolean IsStart { get; private set; } = true;
712              public Int32 Index { get; private set; }
713              public Boolean IsKey { get; private set; }
714              public Boolean IsEnd => !IsStart && Index >= Value.Count;
715              public ReaderState Next()
716              {
717                  if (IsStart)
718                  {
719                      IsStart = false;
720                      IsKey = true;
721                  }
722                  else if (IsKey)
723                  {
724                      IsKey = false;
725                  }
726                  else
727                  {
728                      Index++;
729                      IsKey = true;
730                  }
731                  if (!IsEnd)
732                  {
733                      if (IsKey)
734                      {
735                          return CreateState(this, Value[Index].Key, Context);
736                      }
737                      else
738                      {
739                          return CreateState(this, Value[Index].Value, Context);
740                      }
741                  }
742                  else
743                  {
744                      return this;
745                  }
746              }
747              public ReaderState End()
748              {
749                  IsStart = false;
750                  Index = Value.Count;
751                  return this;
752              }
753              public override void Remove()
754              {
755                  Context.Memory.SubtractBytes(Value);
756                  Context.Memory.DecrementDepth();
757                  if (m_removeBytes > 0)
758                  {
759                      Context.Memory.SubtractBytes(m_removeBytes);
760                  }
761              }
762              public override String ToString()
763              {
764                  var result = new StringBuilder();
765                  result.AppendLine($"{GetType().Name}:");
766                  result.AppendLine($"  IsStart: {IsStart}");
767                  result.AppendLine($"  Index: {Index}");
768                  result.AppendLine($"  IsKey: {IsKey}");
769                  result.AppendLine($"  IsEnd: {IsEnd}");
770                  return result.ToString();
771              }
772              private Int32 m_removeBytes;
773          }
774          private sealed class BasicExpressionState : ReaderState<BasicExpressionToken>
775          {
776              public BasicExpressionState(
777                  ReaderState parent,
778                  BasicExpressionToken expression,
779                  TemplateContext context,
780                  Int32 removeBytes)
781                  : base(parent, expression, context)
782              {
783                  context.Memory.AddBytes(expression);
784                  context.Memory.IncrementDepth();
785                  m_removeBytes = removeBytes;
786              }
787              public Boolean IsStart { get; private set; } = true;
788              public Boolean IsEnd => !IsStart;
789              public ReaderState Next(
790                  TemplateToken value,
791                  Int32 removeBytes = 0)
792              {
793                  IsStart = false;
794                  return CreateState(this, value, Context, removeBytes);
795              }
796              public ReaderState Next(
797                  SequenceToken value,
798                  Boolean isSequenceInsertion = false,
799                  Int32 removeBytes = 0)
800              {
801                  IsStart = false;
802                  var nestedState = CreateState(this, value, Context, removeBytes);
803                  if (isSequenceInsertion)
804                  {
805                      var nestedSequenceState = nestedState as SequenceState;
806                      return nestedSequenceState.Next(); 
807                  }
808                  else
809                  {
810                      return nestedState;
811                  }
812              }
813              public ReaderState End()
814              {
815                  IsStart = false;
816                  return this;
817              }
818              public override void Remove()
819              {
820                  Context.Memory.SubtractBytes(Value);
821                  Context.Memory.DecrementDepth();
822                  if (m_removeBytes > 0)
823                  {
824                      Context.Memory.SubtractBytes(m_removeBytes);
825                  }
826              }
827              public override String ToString()
828              {
829                  var result = new StringBuilder();
830                  result.AppendLine($"{GetType().Name}:");
831                  result.AppendLine($"  IsStart: {IsStart}");
832                  return result.ToString();
833              }
834              private Int32 m_removeBytes;
835          }
836          private sealed class InsertExpressionState : ReaderState<InsertExpressionToken>
837          {
838              public InsertExpressionState(
839                  ReaderState parent,
840                  InsertExpressionToken expression,
841                  TemplateContext context)
842                  : base(parent, expression, context)
843              {
844                  Context.Memory.AddBytes(expression);
845                  Context.Memory.IncrementDepth();
846              }
847              public Boolean IsStart { get; private set; } = true;
848              public Boolean IsEnd => !IsStart;
849              public ReaderState Next(
850                  MappingToken value,
851                  Int32 removeBytes = 0)
852              {
853                  IsStart = false;
854                  var nestedState = CreateState(this, value, Context, removeBytes) as MappingState;
855                  return nestedState.Next(); 
856              }
857              public ReaderState End()
858              {
859                  IsStart = false;
860                  return this;
861              }
862              public ReaderState ToStringToken()
863              {
864                  var literal = new StringToken(Value.FileId, Value.Line, Value.Column, $"{TemplateConstants.OpenExpression} {Value.Directive} {TemplateConstants.CloseExpression}");
865                  return CreateState(Parent, literal, Context);
866              }
867              public override void Remove()
868              {
869                  Context.Memory.SubtractBytes(Value);
870                  Context.Memory.DecrementDepth();
871              }
872              public override String ToString()
873              {
874                  var result = new StringBuilder();
875                  result.AppendLine($"{GetType().Name}:");
876                  result.AppendLine($"  IsStart: {IsStart}");
877                  return result.ToString();
878              }
879          }
880          private readonly TemplateContext m_context;
881          private readonly TemplateMemory m_memory;
882          private ReaderState m_current;
883          private Boolean m_expanded;
884      }
885  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateUnraveler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  using GitHub.DistributedTask.ObjectTemplating.Tokens;
5  namespace GitHub.DistributedTask.ObjectTemplating
6  {
7      internal sealed class TemplateUnraveler
8      {
9          internal TemplateUnraveler(
10              TemplateContext context,
11              TemplateToken template,
12              Int32 removeBytes)
13          {
14              m_context = context;
15              m_memory = context.Memory;
16              MoveFirst(template, removeBytes);
17          }
18          internal Boolean AllowScalar(
19              Boolean expand,
20              out ScalarToken scalar)
21          {
22              m_memory.IncrementEvents();
23              if (expand)
24              {
25                  Unravel(expand: true);
26              }
27              if (m_current?.Value is ScalarToken scalarToken)
28              {
29                  scalar = scalarToken;
30                  m_memory.AddBytes(scalar);
31                  MoveNext();
32                  return true;
33              }
34              scalar = null;
35              return false;
36          }
37          internal Boolean AllowSequenceStart(
38              Boolean expand,
39              out SequenceToken sequence)
40          {
41              m_memory.IncrementEvents();
42              if (expand)
43              {
44                  Unravel(expand: true);
45              }
46              if (m_current is SequenceState sequenceState && sequenceState.IsStart)
47              {
48                  sequence = new SequenceToken(sequenceState.Value.FileId, sequenceState.Value.Line, sequenceState.Value.Column);
49                  m_memory.AddBytes(sequence);
50                  MoveNext();
51                  return true;
52              }
53              sequence = null;
54              return false;
55          }
56          internal Boolean AllowSequenceEnd(Boolean expand)
57          {
58              m_memory.IncrementEvents();
59              if (expand)
60              {
61                  Unravel(expand: true);
62              }
63              if (m_current is SequenceState sequenceState && sequenceState.IsEnd)
64              {
65                  MoveNext();
66                  return true;
67              }
68              return false;
69          }
70          internal Boolean AllowMappingStart(
71              Boolean expand,
72              out MappingToken mapping)
73          {
74              m_memory.IncrementEvents();
75              if (expand)
76              {
77                  Unravel(expand: true);
78              }
79              if (m_current is MappingState mappingState && mappingState.IsStart)
80              {
81                  mapping = new MappingToken(mappingState.Value.FileId, mappingState.Value.Line, mappingState.Value.Column);
82                  m_memory.AddBytes(mapping);
83                  MoveNext();
84                  return true;
85              }
86              mapping = null;
87              return false;
88          }
89          internal Boolean AllowMappingEnd(Boolean expand)
90          {
91              m_memory.IncrementEvents();
92              if (expand)
93              {
94                  Unravel(expand: true);
95              }
96              if (m_current is MappingState mappingState && mappingState.IsEnd)
97              {
98                  MoveNext();
99                  return true;
100              }
101              return false;
102          }
103          internal void ReadEnd()
104          {
105              m_memory.IncrementEvents();
106              if (m_current != null)
107              {
108                  throw new InvalidOperationException("Expected end of template object. " + DumpState());
109              }
110          }
111          internal void ReadMappingEnd()
112          {
113              if (!AllowMappingEnd(expand: false))
114              {
115                  throw new InvalidOperationException("Unexpected state while attempting to read the mapping end. " + DumpState());
116              }
117          }
118          internal void SkipSequenceItem()
119          {
120              m_memory.IncrementEvents();
121              if (!(m_current?.Parent is SequenceState ancestor))
122              {
123                  throw new InvalidOperationException("Unexpected state while attempting to skip the current sequence item. " + DumpState());
124              }
125              MoveNext(skipNestedEvents: true);
126          }
127          internal void SkipMappingKey()
128          {
129              m_memory.IncrementEvents();
130              if (!(m_current?.Parent is MappingState ancestor) || !ancestor.IsKey)
131              {
132                  throw new InvalidOperationException("Unexpected state while attempting to skip the current mapping key. " + DumpState());
133              }
134              MoveNext(skipNestedEvents: true);
135          }
136          internal void SkipMappingValue()
137          {
138              m_memory.IncrementEvents();
139              if (!(m_current?.Parent is MappingState ancestor) || ancestor.IsKey)
140              {
141                  throw new InvalidOperationException("Unexpected state while attempting to skip the current mapping value. " + DumpState());
142              }
143              MoveNext(skipNestedEvents: true);
144          }
145          private String DumpState()
146          {
147              var result = new StringBuilder();
148              if (m_current == null)
149              {
150                  result.AppendLine("State: (null)");
151              }
152              else
153              {
154                  result.AppendLine("State:");
155                  result.AppendLine();
156                  var stack = new Stack<ReaderState>();
157                  var curr = m_current;
158                  while (curr != null)
159                  {
160                      result.AppendLine(curr.ToString());
161                      curr = curr.Parent;
162                  }
163              }
164              return result.ToString();
165          }
166          private void MoveFirst(
167              TemplateToken value,
168              Int32 removeBytes)
169          {
170              if (!(value is LiteralToken) && !(value is SequenceToken) && !(value is MappingToken) && !(value is BasicExpressionToken))
171              {
172                  throw new NotSupportedException($"Unexpected type '{value?.GetType().Name}' when initializing object reader state");
173              }
174              m_memory.IncrementEvents();
175              m_current = ReaderState.CreateState(null, value, m_context, removeBytes);
176          }
177          private void MoveNext(Boolean skipNestedEvents = false)
178          {
179              m_memory.IncrementEvents();
180              if (m_current == null)
181              {
182                  return;
183              }
184              if (m_current is SequenceState sequenceState &&
185                  sequenceState.IsStart &&
186                  !skipNestedEvents)
187              {
188                  m_current = sequenceState.Next();
189              }
190              else if (m_current is MappingState mappingState &&
191                  mappingState.IsStart &&
192                  !skipNestedEvents)
193              {
194                  m_current = mappingState.Next();
195              }
196              else if (m_current.Parent is SequenceState parentSequenceState)
197              {
198                  m_current.Remove();
199                  m_current = parentSequenceState.Next();
200              }
201              else if (m_current.Parent is MappingState parentMappingState)
202              {
203                  m_current.Remove();
204                  m_current = parentMappingState.Next();
205              }
206              else if (m_current.Parent != null)
207              {
208                  m_current.Remove();
209                  m_current = m_current.Parent;
210              }
211              else
212              {
213                  m_current.Remove();
214                  m_current = null;
215              }
216              m_expanded = false;
217              Unravel(expand: false);
218          }
219          private void Unravel(Boolean expand)
220          {
221              if (m_expanded)
222              {
223                  return;
224              }
225              do
226              {
227                  if (m_current == null)
228                  {
229                      break;
230                  }
231                  else if (m_current is LiteralState literalState)
232                  {
233                      break;
234                  }
235                  else if (m_current is BasicExpressionState basicExpressionState)
236                  {
237                      if (basicExpressionState.IsStart &&
238                          m_current.Parent is SequenceState)
239                      {
240                          if (expand)
241                          {
242                              SequenceItemBasicExpression();
243                          }
244                          else
245                          {
246                              break;
247                          }
248                      }
249                      else if (basicExpressionState.IsStart &&
250                          m_current.Parent is MappingState parentMappingState &&
251                          parentMappingState.IsKey)
252                      {
253                          if (expand)
254                          {
255                              MappingKeyBasicExpression();
256                          }
257                          else
258                          {
259                              break;
260                          }
261                      }
262                      else if (basicExpressionState.IsStart &&
263                          m_current.Parent is MappingState parentMappingState2 &&
264                          !parentMappingState2.IsKey)
265                      {
266                          if (expand)
267                          {
268                              MappingValueBasicExpression();
269                          }
270                          else
271                          {
272                              break;
273                          }
274                      }
275                      else if (basicExpressionState.IsStart &&
276                          m_current.Parent is null)
277                      {
278                          if (expand)
279                          {
280                              RootBasicExpression();
281                          }
282                          else
283                          {
284                              break;
285                          }
286                      }
287                      else if (basicExpressionState.IsEnd)
288                      {
289                          EndExpression();
290                      }
291                      else
292                      {
293                          UnexpectedState();
294                      }
295                  }
296                  else if (m_current is MappingState mappingState)
297                  {
298                      if (mappingState.IsEnd &&
299                          m_current.Parent is InsertExpressionState)
300                      {
301                          m_current.Remove();
302                          m_current = m_current.Parent; 
303                      }
304                      else if (mappingState.IsStart)
305                      {
306                          break;
307                      }
308                      else if (mappingState.IsEnd)
309                      {
310                          break;
311                      }
312                      else
313                      {
314                          UnexpectedState();
315                      }
316                  }
317                  else if (m_current is SequenceState sequenceState)
318                  {
319                      if (sequenceState.IsEnd &&
320                          m_current.Parent is BasicExpressionState &&
321                          m_current.Parent.Parent is SequenceState)
322                      {
323                          m_current.Remove();
324                          m_current = m_current.Parent; 
325                      }
326                      else if (sequenceState.IsStart)
327                      {
328                          break;
329                      }
330                      else if (sequenceState.IsEnd)
331                      {
332                          break;
333                      }
334                      else
335                      {
336                          UnexpectedState();
337                      }
338                  }
339                  else if (m_current is InsertExpressionState insertExpressionState)
340                  {
341                      if (insertExpressionState.IsStart &&
342                          m_current.Parent is MappingState parentMappingState &&
343                          parentMappingState.IsKey)
344                      {
345                          if (expand)
346                          {
347                              StartMappingInsertion();
348                          }
349                          else
350                          {
351                              break;
352                          }
353                      }
354                      else if (insertExpressionState.IsEnd)
355                      {
356                          EndExpression();
357                      }
358                      else if (insertExpressionState.IsStart)
359                      {
360                          m_context.Error(insertExpressionState.Value, TemplateStrings.DirectiveNotAllowed(insertExpressionState.Value.Directive));
361                          m_current.Remove();
362                          m_current = insertExpressionState.ToStringToken();
363                      }
364                      else
365                      {
366                          UnexpectedState();
367                      }
368                  }
369                  else
370                  {
371                      UnexpectedState();
372                  }
373                  m_memory.IncrementEvents();
374              } while (true);
375              m_expanded = expand;
376          }
377          private void SequenceItemBasicExpression()
378          {
379              var expressionState = m_current as BasicExpressionState;
380              var expression = expressionState.Value;
<span onclick='openModal()' class='match'>381              TemplateToken value;
382              var removeBytes = 0;
383              try
384              {
385                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
386              }
387              catch (Exception ex)
388              {
389                  m_context.Error(expression, ex);
390                  value = null;
</span>391              }
392              if (value is SequenceToken nestedSequence)
393              {
394                  m_current = expressionState.Next(nestedSequence, isSequenceInsertion: true, removeBytes: removeBytes);
395              }
396              else if (value != null)
397              {
398                  m_current = expressionState.Next(value, removeBytes);
399              }
400              else if (value == null)
401              {
402                  expressionState.End();
403              }
404          }
405          private void MappingKeyBasicExpression()
406          {
407              var expressionState = m_current as BasicExpressionState;
408              var expression = expressionState.Value as BasicExpressionToken;
409              StringToken stringToken;
410              var removeBytes = 0;
411              try
412              {
413                  stringToken = expression.EvaluateStringToken(expressionState.Context, out removeBytes);
414              }
415              catch (Exception ex)
416              {
417                  m_context.Error(expression, ex);
418                  stringToken = null;
419              }
420              if (stringToken != null)
421              {
422                  m_current = expressionState.Next(stringToken, removeBytes);
423              }
424              else
425              {
426                  m_current.Remove();
427                  var parentMappingState = m_current.Parent as MappingState;
428                  parentMappingState.Next().Remove(); 
429                  m_current = parentMappingState.Next(); 
430              }
431          }
432          private void MappingValueBasicExpression()
433          {
434              var expressionState = m_current as BasicExpressionState;
435              var expression = expressionState.Value;
436              TemplateToken value;
437              var removeBytes = 0;
438              try
439              {
440                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
441              }
442              catch (Exception ex)
443              {
444                  m_context.Error(expression, ex);
445                  value = new StringToken(expression.FileId, expression.Line, expression.Column, String.Empty);
446              }
447              m_current = expressionState.Next(value, removeBytes);
448          }
449          private void RootBasicExpression()
450          {
451              var expressionState = m_current as BasicExpressionState;
452              var expression = expressionState.Value;
453              TemplateToken value;
454              var removeBytes = 0;
455              try
456              {
457                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
458              }
459              catch (Exception ex)
460              {
461                  m_context.Error(expression, ex);
462                  value = new StringToken(expression.FileId, expression.Line, expression.Column, String.Empty);
463              }
464              m_current = expressionState.Next(value, removeBytes);
465          }
466          private void StartMappingInsertion()
467          {
468              var expressionState = m_current as InsertExpressionState;
469              var parentMappingState = expressionState.Parent as MappingState;
470              var nestedValue = parentMappingState.Value[parentMappingState.Index].Value;
471              var nestedMapping = nestedValue as MappingToken;
472              var removeBytes = 0;
473              if (nestedMapping != null)
474              {
475              }
476              else if (nestedValue is BasicExpressionToken basicExpression)
477              {
478                  try
479                  {
480                      nestedMapping = basicExpression.EvaluateMappingToken(expressionState.Context, out removeBytes);
481                  }
482                  catch (Exception ex)
483                  {
484                      m_context.Error(basicExpression, ex);
485                      nestedMapping = null;
486                  }
487              }
488              else
489              {
490                  m_context.Error(nestedValue, TemplateStrings.ExpectedMapping());
491                  nestedMapping = null;
492              }
493              if (nestedMapping?.Count > 0)
494              {
495                  m_current = expressionState.Next(nestedMapping, removeBytes);
496              }
497              else
498              {
499                  if (removeBytes > 0)
500                  {
501                      m_memory.SubtractBytes(removeBytes);
502                  }
503                  expressionState.End();
504              }
505          }
506          private void EndExpression()
507          {
508              if (m_current.Parent == null)
509              {
510                  m_current.Remove();
511                  m_current = null;
512              }
513              else if (m_current is BasicExpressionState)
514              {
515                  if (m_current.Parent is SequenceState parentSequenceState)
516                  {
517                      m_current.Remove();
518                      m_current = parentSequenceState.Next();
519                  }
520                  else
521                  {
522                      m_current.Remove();
523                      var parentMappingState = m_current.Parent as MappingState;
524                      m_current = parentMappingState.Next();
525                  }
526              }
527              else
528              {
529                  m_current.Remove();
530                  var parentMappingState = m_current.Parent as MappingState;
531                  parentMappingState.Next().Remove(); 
532                  m_current = parentMappingState.Next();
533              }
534          }
535          private void UnexpectedState()
536          {
537              throw new InvalidOperationException("Expected state while unraveling expressions. " + DumpState());
538          }
539          private abstract class ReaderState
540          {
541              public ReaderState(
542                  ReaderState parent,
543                  TemplateToken value,
544                  TemplateContext context)
545              {
546                  Parent = parent;
547                  Value = value;
548                  Context = context;
549              }
550              public static ReaderState CreateState(
551                  ReaderState parent,
552                  TemplateToken value,
553                  TemplateContext context,
554                  Int32 removeBytes = 0)
555              {
556                  switch (value.Type)
557                  {
558                      case TokenType.Null:
559                      case TokenType.Boolean:
560                      case TokenType.Number:
561                      case TokenType.String:
562                          return new LiteralState(parent, value as LiteralToken, context, removeBytes);
563                      case TokenType.Sequence:
564                          return new SequenceState(parent, value as SequenceToken, context, removeBytes);
565                      case TokenType.Mapping:
566                          return new MappingState(parent, value as MappingToken, context, removeBytes);
567                      case TokenType.BasicExpression:
568                          return new BasicExpressionState(parent, value as BasicExpressionToken, context, removeBytes);
569                      case TokenType.InsertExpression:
570                          if (removeBytes > 0)
571                          {
572                              throw new InvalidOperationException($"Unexpected {nameof(removeBytes)}");
573                          }
574                          return new InsertExpressionState(parent, value as InsertExpressionToken, context);
575                      default:
576                          throw new NotSupportedException($"Unexpected {nameof(ReaderState)} type: {value?.GetType().Name}");
577                  }
578              }
579              public ReaderState Parent { get; }
580              public TemplateContext Context { get; protected set; }
581              public TemplateToken Value { get; }
582              public abstract void Remove();
583          }
584          private abstract class ReaderState<T> : ReaderState
585              where T : class
586          {
587              public ReaderState(
588                  ReaderState parent,
589                  TemplateToken value,
590                  TemplateContext context)
591                  : base(parent, value, context)
592              {
593              }
594              public new T Value
595              {
596                  get
597                  {
598                      if (!Object.ReferenceEquals(base.Value, m_value))
599                      {
600                          m_value = base.Value as T;
601                      }
602                      return m_value;
603                  }
604              }
605              private T m_value;
606          }
607          private sealed class LiteralState : ReaderState<LiteralToken>
608          {
609              public LiteralState(
610                  ReaderState parent,
611                  LiteralToken literal,
612                  TemplateContext context,
613                  Int32 removeBytes)
614                  : base(parent, literal, context)
615              {
616                  context.Memory.AddBytes(literal);
617                  context.Memory.IncrementDepth();
618                  m_removeBytes = removeBytes;
619              }
620              public override void Remove()
621              {
622                  Context.Memory.SubtractBytes(Value);
623                  Context.Memory.DecrementDepth();
624                  if (m_removeBytes > 0)
625                  {
626                      Context.Memory.SubtractBytes(m_removeBytes);
627                  }
628              }
629              public override String ToString()
630              {
631                  var result = new StringBuilder();
632                  result.AppendLine($"{GetType().Name}");
633                  return result.ToString();
634              }
635              private Int32 m_removeBytes;
636          }
637          private sealed class SequenceState : ReaderState<SequenceToken>
638          {
639              public SequenceState(
640                  ReaderState parent,
641                  SequenceToken sequence,
642                  TemplateContext context,
643                  Int32 removeBytes)
644                  : base(parent, sequence, context)
645              {
646                  context.Memory.AddBytes(sequence);
647                  context.Memory.IncrementDepth();
648                  m_removeBytes = removeBytes;
649              }
650              public Boolean IsStart { get; private set; } = true;
651              public Int32 Index { get; private set; }
652              public Boolean IsEnd => !IsStart && Index >= Value.Count;
653              public ReaderState Next()
654              {
655                  if (IsStart)
656                  {
657                      IsStart = false;
658                  }
659                  else
660                  {
661                      Index++;
662                  }
663                  if (!IsEnd)
664                  {
665                      return CreateState(this, Value[Index], Context);
666                  }
667                  else
668                  {
669                      return this;
670                  }
671              }
672              public ReaderState End()
673              {
674                  IsStart = false;
675                  Index = Value.Count;
676                  return this;
677              }
678              public override void Remove()
679              {
680                  Context.Memory.SubtractBytes(Value);
681                  Context.Memory.DecrementDepth();
682                  if (m_removeBytes > 0)
683                  {
684                      Context.Memory.SubtractBytes(m_removeBytes);
685                  }
686              }
687              public override String ToString()
688              {
689                  var result = new StringBuilder();
690                  result.AppendLine($"{GetType().Name}:");
691                  result.AppendLine($"  IsStart: {IsStart}");
692                  result.AppendLine($"  Index: {Index}");
693                  result.AppendLine($"  IsEnd: {IsEnd}");
694                  return result.ToString();
695              }
696              private Int32 m_removeBytes;
697          }
698          private sealed class MappingState : ReaderState<MappingToken>
699          {
700              public MappingState(
701                  ReaderState parent,
702                  MappingToken mapping,
703                  TemplateContext context,
704                  Int32 removeBytes)
705                  : base(parent, mapping, context)
706              {
707                  context.Memory.AddBytes(mapping);
708                  context.Memory.IncrementDepth();
709                  m_removeBytes = removeBytes;
710              }
711              public Boolean IsStart { get; private set; } = true;
712              public Int32 Index { get; private set; }
713              public Boolean IsKey { get; private set; }
714              public Boolean IsEnd => !IsStart && Index >= Value.Count;
715              public ReaderState Next()
716              {
717                  if (IsStart)
718                  {
719                      IsStart = false;
720                      IsKey = true;
721                  }
722                  else if (IsKey)
723                  {
724                      IsKey = false;
725                  }
726                  else
727                  {
728                      Index++;
729                      IsKey = true;
730                  }
731                  if (!IsEnd)
732                  {
733                      if (IsKey)
734                      {
735                          return CreateState(this, Value[Index].Key, Context);
736                      }
737                      else
738                      {
739                          return CreateState(this, Value[Index].Value, Context);
740                      }
741                  }
742                  else
743                  {
744                      return this;
745                  }
746              }
747              public ReaderState End()
748              {
749                  IsStart = false;
750                  Index = Value.Count;
751                  return this;
752              }
753              public override void Remove()
754              {
755                  Context.Memory.SubtractBytes(Value);
756                  Context.Memory.DecrementDepth();
757                  if (m_removeBytes > 0)
758                  {
759                      Context.Memory.SubtractBytes(m_removeBytes);
760                  }
761              }
762              public override String ToString()
763              {
764                  var result = new StringBuilder();
765                  result.AppendLine($"{GetType().Name}:");
766                  result.AppendLine($"  IsStart: {IsStart}");
767                  result.AppendLine($"  Index: {Index}");
768                  result.AppendLine($"  IsKey: {IsKey}");
769                  result.AppendLine($"  IsEnd: {IsEnd}");
770                  return result.ToString();
771              }
772              private Int32 m_removeBytes;
773          }
774          private sealed class BasicExpressionState : ReaderState<BasicExpressionToken>
775          {
776              public BasicExpressionState(
777                  ReaderState parent,
778                  BasicExpressionToken expression,
779                  TemplateContext context,
780                  Int32 removeBytes)
781                  : base(parent, expression, context)
782              {
783                  context.Memory.AddBytes(expression);
784                  context.Memory.IncrementDepth();
785                  m_removeBytes = removeBytes;
786              }
787              public Boolean IsStart { get; private set; } = true;
788              public Boolean IsEnd => !IsStart;
789              public ReaderState Next(
790                  TemplateToken value,
791                  Int32 removeBytes = 0)
792              {
793                  IsStart = false;
794                  return CreateState(this, value, Context, removeBytes);
795              }
796              public ReaderState Next(
797                  SequenceToken value,
798                  Boolean isSequenceInsertion = false,
799                  Int32 removeBytes = 0)
800              {
801                  IsStart = false;
802                  var nestedState = CreateState(this, value, Context, removeBytes);
803                  if (isSequenceInsertion)
804                  {
805                      var nestedSequenceState = nestedState as SequenceState;
806                      return nestedSequenceState.Next(); 
807                  }
808                  else
809                  {
810                      return nestedState;
811                  }
812              }
813              public ReaderState End()
814              {
815                  IsStart = false;
816                  return this;
817              }
818              public override void Remove()
819              {
820                  Context.Memory.SubtractBytes(Value);
821                  Context.Memory.DecrementDepth();
822                  if (m_removeBytes > 0)
823                  {
824                      Context.Memory.SubtractBytes(m_removeBytes);
825                  }
826              }
827              public override String ToString()
828              {
829                  var result = new StringBuilder();
830                  result.AppendLine($"{GetType().Name}:");
831                  result.AppendLine($"  IsStart: {IsStart}");
832                  return result.ToString();
833              }
834              private Int32 m_removeBytes;
835          }
836          private sealed class InsertExpressionState : ReaderState<InsertExpressionToken>
837          {
838              public InsertExpressionState(
839                  ReaderState parent,
840                  InsertExpressionToken expression,
841                  TemplateContext context)
842                  : base(parent, expression, context)
843              {
844                  Context.Memory.AddBytes(expression);
845                  Context.Memory.IncrementDepth();
846              }
847              public Boolean IsStart { get; private set; } = true;
848              public Boolean IsEnd => !IsStart;
849              public ReaderState Next(
850                  MappingToken value,
851                  Int32 removeBytes = 0)
852              {
853                  IsStart = false;
854                  var nestedState = CreateState(this, value, Context, removeBytes) as MappingState;
855                  return nestedState.Next(); 
856              }
857              public ReaderState End()
858              {
859                  IsStart = false;
860                  return this;
861              }
862              public ReaderState ToStringToken()
863              {
864                  var literal = new StringToken(Value.FileId, Value.Line, Value.Column, $"{TemplateConstants.OpenExpression} {Value.Directive} {TemplateConstants.CloseExpression}");
865                  return CreateState(Parent, literal, Context);
866              }
867              public override void Remove()
868              {
869                  Context.Memory.SubtractBytes(Value);
870                  Context.Memory.DecrementDepth();
871              }
872              public override String ToString()
873              {
874                  var result = new StringBuilder();
875                  result.AppendLine($"{GetType().Name}:");
876                  result.AppendLine($"  IsStart: {IsStart}");
877                  return result.ToString();
878              }
879          }
880          private readonly TemplateContext m_context;
881          private readonly TemplateMemory m_memory;
882          private ReaderState m_current;
883          private Boolean m_expanded;
884      }
885  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateUnraveler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateUnraveler.cs</div>
                </div>
                <div class="column column_space"><pre><code>381              TemplateToken value;
382              var removeBytes = 0;
383              try
384              {
385                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
386              }
387              catch (Exception ex)
388              {
389                  m_context.Error(expression, ex);
390                  value = null;
</pre></code></div>
                <div class="column column_space"><pre><code>381              TemplateToken value;
382              var removeBytes = 0;
383              try
384              {
385                  value = expression.EvaluateTemplateToken(expressionState.Context, out removeBytes);
386              }
387              catch (Exception ex)
388              {
389                  m_context.Error(expression, ex);
390                  value = null;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    