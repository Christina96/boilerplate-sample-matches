
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManagerL0.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.IO.Compression;
5  using System.Net;
6  using System.Net.Http;
7  using System.Runtime.CompilerServices;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.DistributedTask.Expressions2;
11  using GitHub.DistributedTask.ObjectTemplating.Tokens;
12  using GitHub.DistributedTask.Pipelines.ContextData;
13  using GitHub.DistributedTask.WebApi;
14  using GitHub.Runner.Sdk;
15  using GitHub.Runner.Worker;
16  using GitHub.Runner.Worker.Container;
17  using Moq;
18  using Moq.Protected;
19  using Xunit;
20  using Pipelines = GitHub.DistributedTask.Pipelines;
21  namespace GitHub.Runner.Common.Tests.Worker
22  {
23      public sealed class ActionManagerL0
24      {
25          private const string TestDataFolderName = "TestData";
26          private CancellationTokenSource _ecTokenSource;
27          private Mock<IConfigurationStore> _configurationStore;
28          private Mock<IDockerCommandManager> _dockerManager;
29          private Mock<IExecutionContext> _ec;
30          private Mock<IJobServer> _jobServer;
31          private Mock<ILaunchServer> _launchServer;
32          private Mock<IRunnerPluginManager> _pluginManager;
33          private TestHostContext _hc;
34          private ActionManager _actionManager;
35          private string _workFolder;
36          [Fact]
37          [Trait("Level", "L0")]
38          [Trait("Category", "Worker")]
39          public async void PrepareActions_DownloadActionFromDotCom_OnPremises_Legacy()
40          {
41              try
42              {
43                  Setup();
44                  const string ActionName = "ownerName/sample-action";
45                  var actions = new List<Pipelines.ActionStep>
46                  {
47                      new Pipelines.ActionStep()
48                      {
49                          Name = "action",
50                          Id = Guid.NewGuid(),
51                          Reference = new Pipelines.RepositoryPathReference()
52                          {
53                              Name = ActionName,
54                              Ref = "main",
55                              RepositoryType = "GitHub"
56                          }
57                      }
58                  };
59                  const string ApiUrl = "https:&bsol;&bsol;ghes.example.com/api/v3";
60                  string builtInArchiveLink = GetLinkToActionArchive(ApiUrl, ActionName, "main");
61                  string dotcomArchiveLink = GetLinkToActionArchive("https:&bsol;&bsol;api.github.com", ActionName, "main");
62                  string archiveFile = await CreateRepoArchive();
63                  using var stream = File.OpenRead(archiveFile);
64                  var mockClientHandler = new Mock<HttpClientHandler>();
65                  mockClientHandler.Protected().Setup<Task<HttpResponseMessage>>("SendAsync", ItExpr.Is<HttpRequestMessage>(m => m.RequestUri == new Uri(builtInArchiveLink)), ItExpr.IsAny<CancellationToken>())
66                      .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.NotFound));
67                  mockClientHandler.Protected().Setup<Task<HttpResponseMessage>>("SendAsync", ItExpr.Is<HttpRequestMessage>(m => m.RequestUri == new Uri(dotcomArchiveLink)), ItExpr.IsAny<CancellationToken>())
68                      .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.OK) { Content = new StreamContent(stream) });
69                  var mockHandlerFactory = new Mock<IHttpClientHandlerFactory>();
70                  mockHandlerFactory.Setup(p => p.CreateClientHandler(It.IsAny<RunnerWebProxy>())).Returns(mockClientHandler.Object);
71                  _hc.SetSingleton(mockHandlerFactory.Object);
72                  _ec.Setup(x => x.GetGitHubContext("api_url")).Returns(ApiUrl);
73                  _configurationStore.Object.GetSettings().IsHostedServer = false;
74                  await _actionManager.PrepareActionsAsync(_ec.Object, actions);
75                  var watermarkFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), ActionName, "main.completed");
76                  Assert.True(File.Exists(watermarkFile));
77                  var actionYamlFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), ActionName, "main", "action.yml");
78                  Assert.True(File.Exists(actionYamlFile));
79                  _hc.GetTrace().Info(File.ReadAllText(actionYamlFile));
80              }
81              finally
82              {
83                  Teardown();
84              }
85          }
86          [Fact]
87          [Trait("Level", "L0")]
88          [Trait("Category", "Worker")]
89          public async void PrepareActions_DownloadUnknownActionFromGraph_OnPremises_Legacy()
90          {
91              try
92              {
93                  Setup();
94                  const string ActionName = "ownerName/sample-action";
95                  var actions = new List<Pipelines.ActionStep>
96                  {
97                      new Pipelines.ActionStep()
98                      {
99                          Name = "action",
100                          Id = Guid.NewGuid(),
101                          Reference = new Pipelines.RepositoryPathReference()
102                          {
103                              Name = ActionName,
104                              Ref = "main",
105                              RepositoryType = "GitHub"
106                          }
107                      }
108                  };
109                  const string ApiUrl = "https:&bsol;&bsol;ghes.example.com/api/v3";
110                  string archiveLink = GetLinkToActionArchive(ApiUrl, ActionName, "main");
111                  string archiveFile = await CreateRepoArchive();
112                  using var stream = File.OpenRead(archiveFile);
113                  var mockClientHandler = new Mock<HttpClientHandler>();
114                  mockClientHandler.Protected().Setup<Task<HttpResponseMessage>>("SendAsync", ItExpr.IsAny<HttpRequestMessage>(), ItExpr.IsAny<CancellationToken>())
115                      .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.NotFound));
116                  var mockHandlerFactory = new Mock<IHttpClientHandlerFactory>();
117                  mockHandlerFactory.Setup(p => p.CreateClientHandler(It.IsAny<RunnerWebProxy>())).Returns(mockClientHandler.Object);
118                  _hc.SetSingleton(mockHandlerFactory.Object);
119                  _ec.Setup(x => x.GetGitHubContext("api_url")).Returns(ApiUrl);
120                  _configurationStore.Object.GetSettings().IsHostedServer = false;
121                  Func<Task> action = async () => await _actionManager.PrepareActionsAsync(_ec.Object, actions);
122                  await Assert.ThrowsAsync<ActionNotFoundException>(action);
123                  var watermarkFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), ActionName, "main.completed");
124                  Assert.False(File.Exists(watermarkFile));
125                  var actionYamlFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), ActionName, "main", "action.yml");
126                  Assert.False(File.Exists(actionYamlFile));
127              }
128              finally
129              {
130                  Teardown();
131              }
132          }
133  #if OS_LINUX
134          [Fact]
135          [Trait("Level", "L0")]
136          [Trait("Category", "Worker")]
137          public async void PrepareActions_PullImageFromDockerHub()
138          {
139              try
140              {
141                  Setup();
142                  var actionId = Guid.NewGuid();
143                  var actions = new List<Pipelines.ActionStep>
144                  {
145                      new Pipelines.ActionStep()
146                      {
147                          Name = "action",
148                          Id = actionId,
149                          Reference = new Pipelines.ContainerRegistryReference()
150                          {
151                              Image = "ubuntu:16.04"
152                          }
153                      }
154                  };
155                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
156                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
157                  Assert.Equal("ubuntu:16.04", (steps[0].Data as ContainerSetupInfo).Container.Image);
158              }
159              finally
160              {
161                  Teardown();
162              }
163          }
164  #endif
165          [Fact]
166          [Trait("Level", "L0")]
167          [Trait("Category", "Worker")]
168          public async void PrepareActions_DownloadActionFromGraph()
169          {
170              try
171              {
172                  Setup();
173                  var actionId = Guid.NewGuid();
174                  var actions = new List<Pipelines.ActionStep>
175                  {
176                      new Pipelines.ActionStep()
177                      {
178                          Name = "action",
179                          Id = actionId,
180                          Reference = new Pipelines.RepositoryPathReference()
181                          {
182                              Name = "actions/download-artifact",
183                              Ref = "master",
184                              RepositoryType = "GitHub"
185                          }
186                      }
187                  };
188                  await _actionManager.PrepareActionsAsync(_ec.Object, actions);
189                  var watermarkFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "actions/download-artifact", "master.completed");
190                  Assert.True(File.Exists(watermarkFile));
191                  var actionYamlFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "actions/download-artifact", "master", "action.yml");
192                  Assert.True(File.Exists(actionYamlFile));
193                  _hc.GetTrace().Info(File.ReadAllText(actionYamlFile));
194              }
195              finally
196              {
197                  Teardown();
198              }
199          }
200          [Fact]
201          [Trait("Level", "L0")]
202          [Trait("Category", "Worker")]
203          public async void PrepareActions_AlwaysClearActionsCache()
204          {
205              try
206              {
207                  Setup();
208                  var actionId = Guid.NewGuid();
209                  var actions = new List<Pipelines.ActionStep>();
210                  var watermarkFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "notexist/no", "notexist.completed");
211                  Directory.CreateDirectory(Path.GetDirectoryName(watermarkFile));
212                  File.WriteAllText(watermarkFile, DateTime.UtcNow.ToString());
213                  Directory.CreateDirectory(Path.Combine(Path.GetDirectoryName(watermarkFile), "notexist"));
214                  File.Copy(Path.Combine(TestUtil.GetSrcPath(), "Test", TestDataFolderName, "dockerfileaction.yml"), Path.Combine(Path.GetDirectoryName(watermarkFile), "notexist", "action.yml"));
215                  await _actionManager.PrepareActionsAsync(_ec.Object, actions);
216                  Assert.False(Directory.Exists(_hc.GetDirectory(WellKnownDirectory.Actions)));
217              }
218              finally
219              {
220                  Teardown();
221              }
222          }
223          [Fact]
224          [Trait("Level", "L0")]
225          [Trait("Category", "Worker")]
226          public async void PrepareActions_SkipDownloadActionForSelfRepo()
227          {
228              try
229              {
230                  Setup();
231                  var actionId = Guid.NewGuid();
232                  var actions = new List<Pipelines.ActionStep>
233                  {
234                      new Pipelines.ActionStep()
235                      {
236                          Name = "action",
237                          Id = actionId,
238                          Reference = new Pipelines.RepositoryPathReference()
239                          {
240                              Path = "action",
241                              RepositoryType = Pipelines.PipelineConstants.SelfAlias
242                          }
243                      }
244                  };
245                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
246                  Assert.True(steps.Count == 0);
247              }
248              finally
249              {
250                  Teardown();
251              }
252          }
253  #if OS_LINUX
254          [Fact]
255          [Trait("Level", "L0")]
256          [Trait("Category", "Worker")]
257          public async void PrepareActions_RepositoryActionWithDockerfile()
258          {
259              try
260              {
261                  Setup();
262                  var actionId = Guid.NewGuid();
263                  var actions = new List<Pipelines.ActionStep>
264                  {
265                      new Pipelines.ActionStep()
266                      {
267                          Name = "action",
268                          Id = actionId,
269                          Reference = new Pipelines.RepositoryPathReference()
270                          {
271                              Name = "TingluoHuang/runner_L0",
272                              Ref = "repositoryactionwithdockerfile",
273                              RepositoryType = "GitHub"
274                          }
275                      }
276                  };
277                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithdockerfile");
278                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
279                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
280                  Assert.Equal(actionDir, (steps[0].Data as ContainerSetupInfo).Container.WorkingDirectory);
281                  Assert.Equal(Path.Combine(actionDir, "Dockerfile"), (steps[0].Data as ContainerSetupInfo).Container.Dockerfile);
282              }
283              finally
284              {
285                  Teardown();
286              }
287          }
288          [Fact]
289          [Trait("Level", "L0")]
290          [Trait("Category", "Worker")]
291          public async void PrepareActions_RepositoryActionWithDockerfileInRelativePath()
292          {
293              try
294              {
295                  Setup();
296                  var actionId = Guid.NewGuid();
297                  var actions = new List<Pipelines.ActionStep>
298                  {
299                      new Pipelines.ActionStep()
300                      {
301                          Name = "action",
302                          Id = actionId,
303                          Reference = new Pipelines.RepositoryPathReference()
304                          {
305                              Name = "TingluoHuang/runner_L0",
306                              Ref = "repositoryactionwithdockerfileinrelativepath",
307                              Path = "images/cli",
308                              RepositoryType = "GitHub"
309                          }
310                      }
311                  };
312                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithdockerfileinrelativepath");
313                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
314                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
315                  Assert.Equal(actionDir, (steps[0].Data as ContainerSetupInfo).Container.WorkingDirectory);
316                  Assert.Equal(Path.Combine(actionDir, "images/cli", "Dockerfile"), (steps[0].Data as ContainerSetupInfo).Container.Dockerfile);
317              }
318              finally
319              {
320                  Teardown();
321              }
322          }
323          [Fact]
324          [Trait("Level", "L0")]
325          [Trait("Category", "Worker")]
326          public async void PrepareActions_RepositoryActionWithActionfile_Dockerfile()
327          {
328              try
329              {
330                  Setup();
331                  var actionId = Guid.NewGuid();
332                  var actions = new List<Pipelines.ActionStep>
333                  {
334                      new Pipelines.ActionStep()
335                      {
336                          Name = "action",
337                          Id = actionId,
338                          Reference = new Pipelines.RepositoryPathReference()
339                          {
340                              Name = "TingluoHuang/runner_L0",
341                              Ref = "repositoryactionwithdockerfileinrelativepath",
342                              RepositoryType = "GitHub"
343                          }
344                      }
345                  };
346                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithdockerfileinrelativepath");
347                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
348                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
349                  Assert.Equal(actionDir, (steps[0].Data as ContainerSetupInfo).Container.WorkingDirectory);
350                  Assert.Equal(Path.Combine(actionDir, "Dockerfile"), (steps[0].Data as ContainerSetupInfo).Container.Dockerfile);
351              }
352              finally
353              {
354                  Teardown();
355              }
356          }
357          [Fact]
358          [Trait("Level", "L0")]
359          [Trait("Category", "Worker")]
360          public async void PrepareActions_RepositoryActionWithActionfile_DockerfileRelativePath()
361          {
362              try
363              {
364                  Setup();
365                  var actionId = Guid.NewGuid();
366                  var actions = new List<Pipelines.ActionStep>
367                  {
368                      new Pipelines.ActionStep()
369                      {
370                          Name = "action",
371                          Id = actionId,
372                          Reference = new Pipelines.RepositoryPathReference()
373                          {
374                              Name = "TingluoHuang/runner_L0",
375                              Ref = "RepositoryActionWithActionfile_DockerfileRelativePath",
376                              RepositoryType = "GitHub"
377                          }
378                      }
379                  };
380                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "RepositoryActionWithActionfile_DockerfileRelativePath");
381                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
382                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
383                  Assert.Equal(actionDir, (steps[0].Data as ContainerSetupInfo).Container.WorkingDirectory);
384                  Assert.Equal(Path.Combine(actionDir, "images/Dockerfile"), (steps[0].Data as ContainerSetupInfo).Container.Dockerfile);
385              }
386              finally
387              {
388                  Teardown();
389              }
390          }
391          [Fact]
392          [Trait("Level", "L0")]
393          [Trait("Category", "Worker")]
394          public async void PrepareActions_RepositoryActionWithActionfile_DockerHubImage()
395          {
396              try
397              {
398                  Setup();
399                  var actionId = Guid.NewGuid();
400                  var actions = new List<Pipelines.ActionStep>
401                  {
402                      new Pipelines.ActionStep()
403                      {
404                          Name = "action",
405                          Id = actionId,
406                          Reference = new Pipelines.RepositoryPathReference()
407                          {
408                              Name = "TingluoHuang/runner_L0",
409                              Ref = "RepositoryActionWithActionfile_DockerHubImage",
410                              RepositoryType = "GitHub"
411                          }
412                      }
413                  };
414                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "RepositoryActionWithActionfile_DockerHubImage");
415                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
416                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
417                  Assert.Equal("ubuntu:18.04", (steps[0].Data as ContainerSetupInfo).Container.Image);
418              }
419              finally
420              {
421                  Teardown();
422              }
423          }
424          [Fact]
425          [Trait("Level", "L0")]
426          [Trait("Category", "Worker")]
427          public async void PrepareActions_RepositoryActionWithActionYamlFile_DockerHubImage()
428          {
429              try
430              {
431                  Setup();
432                  var actionId = Guid.NewGuid();
433                  var actions = new List<Pipelines.ActionStep>
434                  {
435                      new Pipelines.ActionStep()
436                      {
437                          Name = "action",
438                          Id = actionId,
439                          Reference = new Pipelines.RepositoryPathReference()
440                          {
441                              Name = "TingluoHuang/runner_L0",
442                              Ref = "RepositoryActionWithActionYamlFile_DockerHubImage",
443                              RepositoryType = "GitHub"
444                          }
445                      }
446                  };
447                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "RepositoryActionWithActionYamlFile_DockerHubImage");
448                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
449                  Assert.Equal((steps[0].Data as ContainerSetupInfo).StepIds[0], actionId);
450                  Assert.Equal("ubuntu:18.04", (steps[0].Data as ContainerSetupInfo).Container.Image);
451              }
452              finally
453              {
454                  Teardown();
455              }
456          }
457          [Fact]
458          [Trait("Level", "L0")]
459          [Trait("Category", "Worker")]
460          public async void PrepareActions_RepositoryActionWithActionfileAndDockerfile()
461          {
462              try
463              {
464                  Setup();
465                  var actionId = Guid.NewGuid();
466                  var actions = new List<Pipelines.ActionStep>
467                  {
468                      new Pipelines.ActionStep()
469                      {
470                          Name = "action",
471                          Id = actionId,
472                          Reference = new Pipelines.RepositoryPathReference()
473                          {
474                              Name = "TingluoHuang/runner_L0",
475                              Ref = "repositoryactionwithactionfileanddockerfile",
476                              RepositoryType = "GitHub"
477                          }
478                      }
479                  };
480                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithactionfileanddockerfile");
481                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
482                  Assert.Equal(actionId, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
483                  Assert.Equal(actionDir, (steps[0].Data as ContainerSetupInfo).Container.WorkingDirectory);
484                  Assert.Equal(Path.Combine(actionDir, "Dockerfile"), (steps[0].Data as ContainerSetupInfo).Container.Dockerfile);
485              }
486              finally
487              {
488                  Teardown();
489              }
490          }
491          [Fact]
492          [Trait("Level", "L0")]
493          [Trait("Category", "Worker")]
494          public async void PrepareActions_NotPullOrBuildImagesMultipleTimes()
495          {
496              try
497              {
498                  Setup();
499                  var actionId1 = Guid.NewGuid();
500                  var actionId2 = Guid.NewGuid();
501                  var actionId3 = Guid.NewGuid();
502                  var actionId4 = Guid.NewGuid();
503                  var actionId5 = Guid.NewGuid();
504                  var actionId6 = Guid.NewGuid();
505                  var actionId7 = Guid.NewGuid();
506                  var actionId8 = Guid.NewGuid();
507                  var actions = new List<Pipelines.ActionStep>
508                  {
509                      new Pipelines.ActionStep()
510                      {
511                          Name = "action",
512                          Id = actionId1,
513                          Reference = new Pipelines.ContainerRegistryReference()
514                          {
515                              Image = "ubuntu:16.04"
516                          }
517                      },
518                      new Pipelines.ActionStep()
519                      {
520                          Name = "action",
521                          Id = actionId2,
522                          Reference = new Pipelines.ContainerRegistryReference()
523                          {
524                              Image = "ubuntu:18.04"
525                          }
526                      },
527                      new Pipelines.ActionStep()
528                      {
529                          Name = "action",
530                          Id = actionId3,
531                          Reference = new Pipelines.ContainerRegistryReference()
532                          {
533                              Image = "ubuntu:18.04"
534                          }
535                      },
536                      new Pipelines.ActionStep()
537                      {
538                          Name = "action",
539                          Id = actionId4,
540                          Reference = new Pipelines.RepositoryPathReference()
541                          {
542                              Name = "TingluoHuang/runner_L0",
543                              Ref = "notpullorbuildimagesmultipletimes1",
544                              RepositoryType = "GitHub"
545                          }
546                      },
547                      new Pipelines.ActionStep()
548                      {
549                          Name = "action",
550                          Id = actionId5,
551                          Reference = new Pipelines.RepositoryPathReference()
552                          {
553                              Name = "TingluoHuang/runner_L0",
554                              Ref = "repositoryactionwithdockerfile",
555                              RepositoryType = "GitHub"
556                          }
557                      },
558                      new Pipelines.ActionStep()
559                      {
560                          Name = "action",
561                          Id = actionId6,
562                          Reference = new Pipelines.RepositoryPathReference()
563                          {
564                              Name = "TingluoHuang/runner_L0",
565                              Ref = "repositoryactionwithdockerfileinrelativepath",
566                              RepositoryType = "GitHub"
567                          }
568                      },
569                      new Pipelines.ActionStep()
570                      {
571                          Name = "action",
572                          Id = actionId7,
573                          Reference = new Pipelines.RepositoryPathReference()
574                          {
575                              Name = "TingluoHuang/runner_L0",
576                              Ref = "repositoryactionwithdockerfileinrelativepath",
577                              RepositoryType = "GitHub"
578                          }
579                      },
580                      new Pipelines.ActionStep()
581                      {
582                          Name = "action",
583                          Id = actionId8,
584                          Reference = new Pipelines.RepositoryPathReference()
585                          {
586                              Name = "TingluoHuang/runner_L0",
587                              Ref = "repositoryactionwithdockerfileinrelativepath",
588                              Path = "images/cli",
589                              RepositoryType = "GitHub"
590                          }
591                      }
592                  };
593                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
594                  Assert.Equal(actionId1, (steps[0].Data as ContainerSetupInfo).StepIds[0]);
595                  Assert.Equal("ubuntu:16.04", (steps[0].Data as ContainerSetupInfo).Container.Image);
596                  Assert.Contains(actionId2, (steps[1].Data as ContainerSetupInfo).StepIds);
597                  Assert.Contains(actionId3, (steps[1].Data as ContainerSetupInfo).StepIds);
598                  Assert.Contains(actionId4, (steps[1].Data as ContainerSetupInfo).StepIds);
599                  Assert.Equal("ubuntu:18.04", (steps[1].Data as ContainerSetupInfo).Container.Image);
600                  var actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithdockerfile");
601                  Assert.Equal(actionId5, (steps[2].Data as ContainerSetupInfo).StepIds[0]);
602                  Assert.Equal(actionDir, (steps[2].Data as ContainerSetupInfo).Container.WorkingDirectory);
603                  Assert.Equal(Path.Combine(actionDir, "Dockerfile"), (steps[2].Data as ContainerSetupInfo).Container.Dockerfile);
604                  actionDir = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang", "runner_L0", "repositoryactionwithdockerfileinrelativepath");
605                  Assert.Contains(actionId6, (steps[3].Data as ContainerSetupInfo).StepIds);
606                  Assert.Contains(actionId7, (steps[3].Data as ContainerSetupInfo).StepIds);
607                  Assert.Equal(actionDir, (steps[3].Data as ContainerSetupInfo).Container.WorkingDirectory);
608                  Assert.Equal(Path.Combine(actionDir, "Dockerfile"), (steps[3].Data as ContainerSetupInfo).Container.Dockerfile);
609                  Assert.Equal(actionId8, (steps[4].Data as ContainerSetupInfo).StepIds[0]);
610                  Assert.Equal(actionDir, (steps[4].Data as ContainerSetupInfo).Container.WorkingDirectory);
611                  Assert.Equal(Path.Combine(actionDir, "images/cli", "Dockerfile"), (steps[4].Data as ContainerSetupInfo).Container.Dockerfile);
612              }
613              finally
614              {
615                  Teardown();
616              }
617          }
618  #endif
619          [Fact]
620          [Trait("Level", "L0")]
621          [Trait("Category", "Worker")]
622          public async void PrepareActions_RepositoryActionWithActionfile_Node()
623          {
624              try
625              {
626                  Setup();
627                  var actionId = Guid.NewGuid();
628                  var actions = new List<Pipelines.ActionStep>
629                  {
630                      new Pipelines.ActionStep()
631                      {
632                          Name = "action",
633                          Id = actionId,
634                          Reference = new Pipelines.RepositoryPathReference()
635                          {
636                              Name = "actions/setup-node",
637                              Ref = "v1",
638                              RepositoryType = "GitHub"
639                          }
640                      }
641                  };
642                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
643                  Assert.True(steps.Count == 0);
644              }
645              finally
646              {
647                  Teardown();
648              }
649          }
650          [Fact]
651          [Trait("Level", "L0")]
652          [Trait("Category", "Worker")]
653          public async void PrepareActions_RepositoryActionWithInvalidWrapperActionfile_Node()
654          {
655              try
656              {
657                  Setup();
658                  var actionId = Guid.NewGuid();
659                  var actions = new List<Pipelines.ActionStep>
660                  {
661                      new Pipelines.ActionStep()
662                      {
663                          Name = "action",
664                          Id = actionId,
665                          Reference = new Pipelines.RepositoryPathReference()
666                          {
667                              Name = "TingluoHuang/runner_L0",
668                              Ref = "RepositoryActionWithInvalidWrapperActionfile_Node",
669                              RepositoryType = "GitHub"
670                          }
671                      }
672                  };
673                  try
674                  {
675                      await _actionManager.PrepareActionsAsync(_ec.Object, actions);
676                  }
677                  catch (ArgumentException)
678                  {
679                      var traceFile = Path.GetTempFileName();
680                      File.Copy(_hc.TraceFileName, traceFile, true);
681                      Assert.Contains("You are using a JavaScript Action but there is not an entry JavaScript file provided in", File.ReadAllText(traceFile));
682                  }
683              }
684              finally
685              {
686                  Teardown();
687              }
688          }
689          [Fact]
690          [Trait("Level", "L0")]
691          [Trait("Category", "Worker")]
692          public async void PrepareActions_RepositoryActionWithWrapperActionfile_PreSteps()
693          {
694              try
695              {
696                  Setup();
697                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
698                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
699                  var actionId1 = Guid.NewGuid();
700                  var actionId2 = Guid.NewGuid();
701                  _hc.GetTrace().Info(actionId1);
702                  _hc.GetTrace().Info(actionId2);
703                  var actions = new List<Pipelines.ActionStep>
704                  {
705                      new Pipelines.ActionStep()
706                      {
707                          Name = "action1",
708                          Id = actionId1,
709                          Reference = new Pipelines.RepositoryPathReference()
710                          {
711                              Name = "TingluoHuang/runner_L0",
712                              Ref = "RepositoryActionWithWrapperActionfile_Node",
713                              RepositoryType = "GitHub"
714                          }
715                      },
716                      new Pipelines.ActionStep()
717                      {
718                          Name = "action2",
719                          Id = actionId2,
720                          Reference = new Pipelines.RepositoryPathReference()
721                          {
722                              Name = "TingluoHuang/runner_L0",
723                              Ref = "RepositoryActionWithWrapperActionfile_Docker",
724                              RepositoryType = "GitHub"
725                          }
726                      }
727                  };
728                  var preResult = await _actionManager.PrepareActionsAsync(_ec.Object, actions);
729                  Assert.Equal(2, preResult.PreStepTracker.Count);
730                  Assert.NotNull(preResult.PreStepTracker[actionId1]);
731                  Assert.NotNull(preResult.PreStepTracker[actionId2]);
732              }
733              finally
734              {
735                  Teardown();
736              }
737          }
738          [Fact]
739          [Trait("Level", "L0")]
740          [Trait("Category", "Worker")]
741          public async void PrepareActions_CompositeActionWithActionfile_Node()
742          {
743              try
744              {
745                  Setup();
746                  var actionId = Guid.NewGuid();
747                  var actions = new List<Pipelines.ActionStep>
748                  {
749                      new Pipelines.ActionStep()
750                      {
751                          Name = "action",
752                          Id = actionId,
753                          Reference = new Pipelines.RepositoryPathReference()
754                          {
755                              Name = "TingluoHuang/runner_L0",
756                              Ref = "CompositeBasic",
757                              RepositoryType = "GitHub"
758                          }
759                      }
760                  };
761                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
762                  var steps = (await _actionManager.PrepareActionsAsync(_ec.Object, actions)).ContainerSetupSteps;
763                  Assert.True(steps.Count == 0);
764                  var watermarkFile = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "TingluoHuang/runner_L0", "CompositeBasic.completed");
765                  Assert.True(File.Exists(watermarkFile));
766                  var watermarkFile2 = Path.Combine(_hc.GetDirectory(WellKnownDirectory.Actions), "actions/setup-node", "v2", "action.yml");
767                  Assert.True(File.Exists(watermarkFile2));
768              }
769              finally
770              {
771                  Teardown();
772              }
773          }
774          [Fact]
775          [Trait("Level", "L0")]
776          [Trait("Category", "Worker")]
777          public async void PrepareActions_CompositeActionWithActionfile_MaxLimit()
778          {
779              try
780              {
781                  Setup();
782                  var actionId = Guid.NewGuid();
783                  var actions = new List<Pipelines.ActionStep>
784                  {
785                      new Pipelines.ActionStep()
786                      {
787                          Name = "action",
788                          Id = actionId,
789                          Reference = new Pipelines.RepositoryPathReference()
790                          {
791                              Name = "TingluoHuang/runner_L0",
792                              Ref = "CompositeLimit",
793                              RepositoryType = "GitHub"
794                          }
795                      }
796                  };
797                  Func<Task> result = async () => await _actionManager.PrepareActionsAsync(_ec.Object, actions);
798                  var exception = await Assert.ThrowsAsync<Exception>(result);
799                  Assert.Equal($"Composite action depth exceeded max depth {Constants.CompositeActionsMaxDepth}", exception.Message);
800              }
801              finally
802              {
803                  Teardown();
804              }
805          }
806          [Fact]
807          [Trait("Level", "L0")]
808          [Trait("Category", "Worker")]
809          public async void PrepareActions_CompositeActionWithActionfile_CompositePrestepNested()
810          {
811              try
812              {
813                  Setup();
814                  var actionId = Guid.NewGuid();
815                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
816                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
817                  _hc.EnqueueInstance<IActionRunner>(new Mock<IActionRunner>().Object);
818                  var actions = new List<Pipelines.ActionStep>
819                  {
820                      new Pipelines.ActionStep()
821                      {
822                          Name = "action",
823                          Id = actionId,
824                          Reference = new Pipelines.RepositoryPathReference()
825                          {
826                              Name = "TingluoHuang/runner_L0",
827                              Ref = "CompositePrestep",
828                              RepositoryType = "GitHub"
829                          }
830                      }
831                  };
832                  var result = await _actionManager.PrepareActionsAsync(_ec.Object, actions);
833                  Assert.Equal(1, result.PreStepTracker.Count);
834              }
835              finally
836              {
837                  Teardown();
838              }
839          }
840  #if OS_LINUX
841          [Fact]
842          [Trait("Level", "L0")]
843          [Trait("Category", "Worker")]
844          public async void PrepareActions_CompositeActionWithActionfile_CompositeContainerNested()
845          {
846              try
847              {
848                  Setup();
849                  var actionId = Guid.NewGuid();
850                  var actions = new List<Pipelines.ActionStep>
851                  {
852                      new Pipelines.ActionStep()
853                      {
854                          Name = "action",
855                          Id = actionId,
856                          Reference = new Pipelines.RepositoryPathReference()
857                          {
858                              Name = "TingluoHuang/runner_L0",
859                              Ref = "CompositeContainerNested",
860                              RepositoryType = "GitHub"
861                          }
862                      }
863                  };
864                  var result = await _actionManager.PrepareActionsAsync(_ec.Object, actions);
865                  Assert.Equal(2, result.ContainerSetupSteps.Count);
866              }
867              finally
868              {
869                  Teardown();
870              }
871          }
872  #endif
873          [Fact]
874          [Trait("Level", "L0")]
875          [Trait("Category", "Worker")]
876          public void LoadsContainerRegistryActionDefinition()
877          {
878              try
879              {
880                  Setup();
881                  Pipelines.ActionStep instance = new()
882                  {
883                      Id = Guid.NewGuid(),
884                      Reference = new Pipelines.ContainerRegistryReference()
885                      {
886                          Image = "ubuntu:16.04"
887                      }
888                  };
889                  _actionManager.CachedActionContainers[instance.Id] = new ContainerInfo() { ContainerImage = "ubuntu:16.04" };
890                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
891                  Assert.NotNull(definition);
892                  Assert.NotNull(definition.Data);
893                  Assert.Equal("ubuntu:16.04", (definition.Data.Execution as ContainerActionExecutionData).Image);
894                  Assert.True(string.IsNullOrEmpty((definition.Data.Execution as ContainerActionExecutionData).EntryPoint));
895                  Assert.Null((definition.Data.Execution as ContainerActionExecutionData).Arguments);
896              }
897              finally
898              {
899                  Teardown();
900              }
901          }
902          [Fact]
903          [Trait("Level", "L0")]
904          [Trait("Category", "Worker")]
905          public void LoadsScriptActionDefinition()
906          {
907              try
908              {
909                  Setup();
910                  Pipelines.ActionStep instance = new()
911                  {
912                      Id = Guid.NewGuid(),
913                      Reference = new Pipelines.ScriptReference()
914                  };
915                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
916                  Assert.NotNull(definition);
917                  Assert.NotNull(definition.Data);
918                  Assert.True(definition.Data.Execution.ExecutionType == ActionExecutionType.Script);
919              }
920              finally
921              {
922                  Teardown();
923              }
924          }
925          [Fact]
926          [Trait("Level", "L0")]
927          [Trait("Category", "Worker")]
928          public void LoadsContainerActionDefinitionDockerfile()
929          {
930              try
931              {
932                  Setup();
933                  const string Content = @"
934  # Container action
935  name: 'Hello World'
936  description: 'Greet the world and record the time'
937  author: 'GitHub'
938  inputs:
939    greeting: # id of input
940      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
941      required: true
942      default: 'Hello'
943    entryPoint: # id of input
944      description: 'optional docker entrypoint overwrite.'
945      required: false
946  outputs:
947    time: # id of output
948      description: 'The time we did the greeting'
949  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
950  color: 'green' # optional, decorates the entry in the GitHub Marketplace
951  runs:
952    using: 'docker'
953    image: 'Dockerfile'
954    args:
955    - '${{ inputs.greeting }}'
956    entrypoint: 'main.sh'
957    env:
958      Token: foo
959      Url: bar
960  ";
961                  Pipelines.ActionStep instance;
962                  string directory;
963                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
964                  _actionManager.CachedActionContainers[instance.Id] = new ContainerInfo() { ContainerImage = "image:1234" };
965                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
966                  Assert.NotNull(definition);
967                  Assert.Equal(directory, definition.Directory);
968                  Assert.NotNull(definition.Data);
969                  Assert.NotNull(definition.Data.Inputs); 
970                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
971                  foreach (var input in definition.Data.Inputs)
972                  {
973                      var name = input.Key.AssertString("key").Value;
974                      var value = input.Value.AssertScalar("value").ToString();
975                      _hc.GetTrace().Info($"Default: {name} = {value}");
976                      inputDefaults[name] = value;
977                  }
978                  Assert.Equal(2, inputDefaults.Count);
979                  Assert.True(inputDefaults.ContainsKey("greeting"));
980                  Assert.Equal("Hello", inputDefaults["greeting"]);
981                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
982                  Assert.NotNull(definition.Data.Execution); 
983                  Assert.NotNull((definition.Data.Execution as ContainerActionExecutionData)); 
984                  Assert.Equal("image:1234", (definition.Data.Execution as ContainerActionExecutionData).Image);
985                  Assert.Equal("main.sh", (definition.Data.Execution as ContainerActionExecutionData).EntryPoint);
986                  foreach (var arg in (definition.Data.Execution as ContainerActionExecutionData).Arguments)
987                  {
988                      Assert.Equal("${{ inputs.greeting }}", arg.AssertScalar("arg").ToString());
989                  }
990                  foreach (var env in (definition.Data.Execution as ContainerActionExecutionData).Environment)
991                  {
992                      var key = env.Key.AssertString("key").Value;
993                      if (key == "Token")
994                      {
995                          Assert.Equal("foo", env.Value.AssertString("value").Value);
996                      }
997                      else if (key == "Url")
998                      {
999                          Assert.Equal("bar", env.Value.AssertString("value").Value);
1000                      }
1001                      else
1002                      {
1003                          throw new NotSupportedException(key);
1004                      }
1005                  }
1006              }
1007              finally
1008              {
1009                  Teardown();
1010              }
1011          }
1012          [Fact]
1013          [Trait("Level", "L0")]
1014          [Trait("Category", "Worker")]
1015          public void LoadsContainerActionDefinitionRegistry()
1016          {
1017              try
1018              {
1019                  Setup();
1020                  const string Content = @"
1021  # Container action
1022  name: 'Hello World'
1023  description: 'Greet the world and record the time'
1024  author: 'GitHub'
1025  inputs:
1026    greeting: # id of input
1027      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1028      required: true
1029      default: 'hello'
1030    entryPoint: # id of input
1031      description: 'optional docker entrypoint overwrite.'
1032      required: false
1033  outputs:
1034    time: # id of output
1035      description: 'The time we did the greeting'
1036  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1037  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1038  runs:
1039    using: 'docker'
1040    image: 'docker:&bsol;&bsol;ubuntu:16.04'
1041    args:
1042    - '${{ inputs.greeting }}'
1043    entrypoint: 'main.sh'
1044    env:
1045      Token: foo
1046      Url: ${{inputs.greeting}}
1047  ";
1048                  Pipelines.ActionStep instance;
1049                  string directory;
1050                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1051                  _actionManager.CachedActionContainers[instance.Id] = new ContainerInfo() { ContainerImage = "ubuntu:16.04" };
1052                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1053                  Assert.NotNull(definition);
1054                  Assert.Equal(directory, definition.Directory);
1055                  Assert.NotNull(definition.Data);
1056                  Assert.NotNull(definition.Data.Inputs); 
1057                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1058                  foreach (var input in definition.Data.Inputs)
1059                  {
1060                      var name = input.Key.AssertString("key").Value;
1061                      var value = input.Value.AssertScalar("value").ToString();
1062                      _hc.GetTrace().Info($"Default: {name} = {value}");
1063                      inputDefaults[name] = value;
1064                  }
1065                  Assert.Equal(2, inputDefaults.Count);
1066                  Assert.True(inputDefaults.ContainsKey("greeting"));
1067                  Assert.Equal("hello", inputDefaults["greeting"]);
1068                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1069                  Assert.NotNull(definition.Data.Execution); 
1070                  Assert.NotNull((definition.Data.Execution as ContainerActionExecutionData));
1071                  Assert.Equal("ubuntu:16.04", (definition.Data.Execution as ContainerActionExecutionData).Image);
1072                  Assert.Equal("main.sh", (definition.Data.Execution as ContainerActionExecutionData).EntryPoint);
1073                  foreach (var arg in (definition.Data.Execution as ContainerActionExecutionData).Arguments)
1074                  {
1075                      Assert.Equal("${{ inputs.greeting }}", arg.AssertScalar("arg").ToString());
1076                  }
1077                  foreach (var env in (definition.Data.Execution as ContainerActionExecutionData).Environment)
1078                  {
1079                      var key = env.Key.AssertString("key").Value;
1080                      if (key == "Token")
1081                      {
1082                          Assert.Equal("foo", env.Value.AssertString("value").Value);
1083                      }
1084                      else if (key == "Url")
1085                      {
1086                          Assert.Equal("${{ inputs.greeting }}", env.Value.AssertScalar("value").ToString());
1087                      }
1088                      else
1089                      {
1090                          throw new NotSupportedException(key);
1091                      }
1092                  }
1093              }
1094              finally
1095              {
1096                  Teardown();
1097              }
1098          }
1099          [Fact]
1100          [Trait("Level", "L0")]
1101          [Trait("Category", "Worker")]
1102          public void LoadsNode12ActionDefinition()
1103          {
1104              try
1105              {
1106                  Setup();
1107                  const string Content = @"
1108  # Container action
1109  name: 'Hello World'
1110  description: 'Greet the world and record the time'
1111  author: 'GitHub'
1112  inputs:
1113    greeting: # id of input
1114      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1115      required: true
1116      default: 'Hello'
1117    entryPoint: # id of input
1118      description: 'optional docker entrypoint overwrite.'
1119      required: false
1120  outputs:
1121    time: # id of output
1122      description: 'The time we did the greeting'
1123  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1124  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1125  runs:
1126    using: 'node12'
1127    main: 'task.js'
1128  ";
1129                  Pipelines.ActionStep instance;
1130                  string directory;
1131                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1132                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1133                  Assert.NotNull(definition);
1134                  Assert.Equal(directory, definition.Directory);
1135                  Assert.NotNull(definition.Data);
1136                  Assert.NotNull(definition.Data.Inputs); 
1137                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1138                  foreach (var input in definition.Data.Inputs)
1139                  {
1140                      var name = input.Key.AssertString("key").Value;
1141                      var value = input.Value.AssertScalar("value").ToString();
1142                      _hc.GetTrace().Info($"Default: {name} = {value}");
1143                      inputDefaults[name] = value;
1144                  }
1145                  Assert.Equal(2, inputDefaults.Count);
1146                  Assert.True(inputDefaults.ContainsKey("greeting"));
1147                  Assert.Equal("Hello", inputDefaults["greeting"]);
1148                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1149                  Assert.NotNull(definition.Data.Execution); 
1150                  Assert.NotNull(definition.Data.Execution as NodeJSActionExecutionData);
1151                  Assert.Equal("task.js", (definition.Data.Execution as NodeJSActionExecutionData).Script);
1152                  Assert.Equal("node12", (definition.Data.Execution as NodeJSActionExecutionData).NodeVersion);
1153              }
1154              finally
1155              {
1156                  Teardown();
1157              }
1158          }
1159          [Fact]
1160          [Trait("Level", "L0")]
1161          [Trait("Category", "Worker")]
1162          public void LoadsNode16ActionDefinition()
1163          {
1164              try
1165              {
1166                  Setup();
1167                  const string Content = @"
1168  # Container action
1169  name: 'Hello World'
1170  description: 'Greet the world and record the time'
1171  author: 'GitHub'
1172  inputs:
1173    greeting: # id of input
1174      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1175      required: true
1176      default: 'Hello'
1177    entryPoint: # id of input
1178      description: 'optional docker entrypoint overwrite.'
1179      required: false
1180  outputs:
1181    time: # id of output
1182      description: 'The time we did the greeting'
1183  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1184  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1185  runs:
1186    using: 'node16'
1187    main: 'task.js'
1188  ";
1189                  Pipelines.ActionStep instance;
1190                  string directory;
1191                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1192                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1193                  Assert.NotNull(definition);
1194                  Assert.Equal(directory, definition.Directory);
1195                  Assert.NotNull(definition.Data);
1196                  Assert.NotNull(definition.Data.Inputs); 
1197                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1198                  foreach (var input in definition.Data.Inputs)
1199                  {
1200                      var name = input.Key.AssertString("key").Value;
1201                      var value = input.Value.AssertScalar("value").ToString();
1202                      _hc.GetTrace().Info($"Default: {name} = {value}");
1203                      inputDefaults[name] = value;
1204                  }
1205                  Assert.Equal(2, inputDefaults.Count);
1206                  Assert.True(inputDefaults.ContainsKey("greeting"));
1207                  Assert.Equal("Hello", inputDefaults["greeting"]);
1208                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1209                  Assert.NotNull(definition.Data.Execution); 
1210                  Assert.NotNull(definition.Data.Execution as NodeJSActionExecutionData);
1211                  Assert.Equal("task.js", (definition.Data.Execution as NodeJSActionExecutionData).Script);
1212                  Assert.Equal("node16", (definition.Data.Execution as NodeJSActionExecutionData).NodeVersion);
1213              }
1214              finally
1215              {
1216                  Teardown();
1217              }
1218          }
1219          [Fact]
1220          [Trait("Level", "L0")]
1221          [Trait("Category", "Worker")]
1222          public void LoadsNodeActionDefinitionYaml()
1223          {
1224              try
1225              {
1226                  Setup();
1227                  const string Content = @"
1228  # Container action
1229  name: 'Hello World'
1230  description: 'Greet the world and record the time'
1231  author: 'GitHub'
1232  inputs:
1233    greeting: # id of input
1234      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1235      required: true
1236      default: 'Hello'
1237    entryPoint: # id of input
1238      description: 'optional docker entrypoint overwrite.'
1239      required: false
1240  outputs:
1241    time: # id of output
1242      description: 'The time we did the greeting'
1243  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1244  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1245  runs:
1246    using: 'node12'
1247    main: 'task.js'
1248  ";
1249                  Pipelines.ActionStep instance;
1250                  string directory;
1251                  directory = Path.Combine(_workFolder, Constants.Path.ActionsDirectory, "GitHub/actions".Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), "main");
<span onclick='openModal()' class='match'>1252                  string file = Path.Combine(directory, Constants.Path.ActionManifestYamlFile);
1253                  Directory.CreateDirectory(Path.GetDirectoryName(file));
</span>1254                  File.WriteAllText(file, Content);
1255                  instance = new Pipelines.ActionStep()
1256                  {
1257                      Id = Guid.NewGuid(),
1258                      Reference = new Pipelines.RepositoryPathReference()
1259                      {
1260                          Name = "GitHub/actions",
1261                          Ref = "main",
1262                          RepositoryType = Pipelines.RepositoryTypes.GitHub
1263                      }
1264                  };
1265                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1266                  Assert.NotNull(definition);
1267                  Assert.Equal(directory, definition.Directory);
1268                  Assert.NotNull(definition.Data);
1269                  Assert.NotNull(definition.Data.Inputs); 
1270                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1271                  foreach (var input in definition.Data.Inputs)
1272                  {
1273                      var name = input.Key.AssertString("key").Value;
1274                      var value = input.Value.AssertScalar("value").ToString();
1275                      _hc.GetTrace().Info($"Default: {name} = {value}");
1276                      inputDefaults[name] = value;
1277                  }
1278                  Assert.Equal(2, inputDefaults.Count);
1279                  Assert.True(inputDefaults.ContainsKey("greeting"));
1280                  Assert.Equal("Hello", inputDefaults["greeting"]);
1281                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1282                  Assert.NotNull(definition.Data.Execution); 
1283                  Assert.NotNull((definition.Data.Execution as NodeJSActionExecutionData));
1284                  Assert.Equal("task.js", (definition.Data.Execution as NodeJSActionExecutionData).Script);
1285              }
1286              finally
1287              {
1288                  Teardown();
1289              }
1290          }
1291          [Fact]
1292          [Trait("Level", "L0")]
1293          [Trait("Category", "Worker")]
1294          public void LoadsContainerActionDefinitionDockerfile_SelfRepo()
1295          {
1296              try
1297              {
1298                  Setup();
1299                  const string Content = @"
1300  # Container action
1301  name: 'Hello World'
1302  description: 'Greet the world and record the time'
1303  author: 'GitHub'
1304  inputs:
1305    greeting: # id of input
1306      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1307      required: true
1308      default: 'Hello'
1309    entryPoint: # id of input
1310      description: 'optional docker entrypoint overwrite.'
1311      required: false
1312  outputs:
1313    time: # id of output
1314      description: 'The time we did the greeting'
1315  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1316  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1317  runs:
1318    using: 'docker'
1319    image: 'Dockerfile'
1320    args:
1321    - '${{ inputs.greeting }}'
1322    entrypoint: 'main.sh'
1323    env:
1324      Token: foo
1325      Url: bar
1326  ";
1327                  Pipelines.ActionStep instance;
1328                  string directory;
1329                  CreateSelfRepoAction(yamlContent: Content, instance: out instance, directory: out directory);
1330                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1331                  Assert.NotNull(definition);
1332                  Assert.Equal(directory, definition.Directory);
1333                  Assert.NotNull(definition.Data);
1334                  Assert.NotNull(definition.Data.Inputs); 
1335                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1336                  foreach (var input in definition.Data.Inputs)
1337                  {
1338                      var name = input.Key.AssertString("key").Value;
1339                      var value = input.Value.AssertScalar("value").ToString();
1340                      _hc.GetTrace().Info($"Default: {name} = {value}");
1341                      inputDefaults[name] = value;
1342                  }
1343                  Assert.Equal(2, inputDefaults.Count);
1344                  Assert.True(inputDefaults.ContainsKey("greeting"));
1345                  Assert.Equal("Hello", inputDefaults["greeting"]);
1346                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1347                  Assert.NotNull(definition.Data.Execution); 
1348                  Assert.NotNull((definition.Data.Execution as ContainerActionExecutionData)); 
1349                  Assert.Equal("Dockerfile", (definition.Data.Execution as ContainerActionExecutionData).Image);
1350                  Assert.Equal("main.sh", (definition.Data.Execution as ContainerActionExecutionData).EntryPoint);
1351                  foreach (var arg in (definition.Data.Execution as ContainerActionExecutionData).Arguments)
1352                  {
1353                      Assert.Equal("${{ inputs.greeting }}", arg.AssertScalar("arg").ToString());
1354                  }
1355                  foreach (var env in (definition.Data.Execution as ContainerActionExecutionData).Environment)
1356                  {
1357                      var key = env.Key.AssertString("key").Value;
1358                      if (key == "Token")
1359                      {
1360                          Assert.Equal("foo", env.Value.AssertString("value").Value);
1361                      }
1362                      else if (key == "Url")
1363                      {
1364                          Assert.Equal("bar", env.Value.AssertString("value").Value);
1365                      }
1366                      else
1367                      {
1368                          throw new NotSupportedException(key);
1369                      }
1370                  }
1371              }
1372              finally
1373              {
1374                  Teardown();
1375              }
1376          }
1377          [Fact]
1378          [Trait("Level", "L0")]
1379          [Trait("Category", "Worker")]
1380          public void LoadsContainerActionDefinitionRegistry_SelfRepo()
1381          {
1382              try
1383              {
1384                  Setup();
1385                  const string Content = @"
1386  # Container action
1387  name: 'Hello World'
1388  description: 'Greet the world and record the time'
1389  author: 'GitHub'
1390  inputs:
1391    greeting: # id of input
1392      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1393      required: true
1394      default: 'hello'
1395    entryPoint: # id of input
1396      description: 'optional docker entrypoint overwrite.'
1397      required: false
1398  outputs:
1399    time: # id of output
1400      description: 'The time we did the greeting'
1401  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1402  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1403  runs:
1404    using: 'docker'
1405    image: 'docker:&bsol;&bsol;ubuntu:16.04'
1406    args:
1407    - '${{ inputs.greeting }}'
1408    entrypoint: 'main.sh'
1409    env:
1410      Token: foo
1411      Url: ${{inputs.greeting}}
1412  ";
1413                  Pipelines.ActionStep instance;
1414                  string directory;
1415                  CreateSelfRepoAction(yamlContent: Content, instance: out instance, directory: out directory);
1416                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1417                  Assert.NotNull(definition);
1418                  Assert.Equal(directory, definition.Directory);
1419                  Assert.NotNull(definition.Data);
1420                  Assert.NotNull(definition.Data.Inputs); 
1421                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1422                  foreach (var input in definition.Data.Inputs)
1423                  {
1424                      var name = input.Key.AssertString("key").Value;
1425                      var value = input.Value.AssertScalar("value").ToString();
1426                      _hc.GetTrace().Info($"Default: {name} = {value}");
1427                      inputDefaults[name] = value;
1428                  }
1429                  Assert.Equal(2, inputDefaults.Count);
1430                  Assert.True(inputDefaults.ContainsKey("greeting"));
1431                  Assert.Equal("hello", inputDefaults["greeting"]);
1432                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1433                  Assert.NotNull(definition.Data.Execution); 
1434                  Assert.NotNull((definition.Data.Execution as ContainerActionExecutionData));
1435                  Assert.Equal("docker:&bsol;&bsol;ubuntu:16.04", (definition.Data.Execution as ContainerActionExecutionData).Image);
1436                  Assert.Equal("main.sh", (definition.Data.Execution as ContainerActionExecutionData).EntryPoint);
1437                  foreach (var arg in (definition.Data.Execution as ContainerActionExecutionData).Arguments)
1438                  {
1439                      Assert.Equal("${{ inputs.greeting }}", arg.AssertScalar("arg").ToString());
1440                  }
1441                  foreach (var env in (definition.Data.Execution as ContainerActionExecutionData).Environment)
1442                  {
1443                      var key = env.Key.AssertString("key").Value;
1444                      if (key == "Token")
1445                      {
1446                          Assert.Equal("foo", env.Value.AssertString("value").Value);
1447                      }
1448                      else if (key == "Url")
1449                      {
1450                          Assert.Equal("${{ inputs.greeting }}", env.Value.AssertScalar("value").ToString());
1451                      }
1452                      else
1453                      {
1454                          throw new NotSupportedException(key);
1455                      }
1456                  }
1457              }
1458              finally
1459              {
1460                  Teardown();
1461              }
1462          }
1463          [Fact]
1464          [Trait("Level", "L0")]
1465          [Trait("Category", "Worker")]
1466          public void LoadsNodeActionDefinition_SelfRepo()
1467          {
1468              try
1469              {
1470                  Setup();
1471                  const string Content = @"
1472  # Container action
1473  name: 'Hello World'
1474  description: 'Greet the world and record the time'
1475  author: 'GitHub'
1476  inputs:
1477    greeting: # id of input
1478      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1479      required: true
1480      default: 'Hello'
1481    entryPoint: # id of input
1482      description: 'optional docker entrypoint overwrite.'
1483      required: false
1484  outputs:
1485    time: # id of output
1486      description: 'The time we did the greeting'
1487  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1488  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1489  runs:
1490    using: 'node12'
1491    main: 'task.js'
1492  ";
1493                  Pipelines.ActionStep instance;
1494                  string directory;
1495                  CreateSelfRepoAction(yamlContent: Content, instance: out instance, directory: out directory);
1496                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1497                  Assert.NotNull(definition);
1498                  Assert.Equal(directory, definition.Directory);
1499                  Assert.NotNull(definition.Data);
1500                  Assert.NotNull(definition.Data.Inputs); 
1501                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1502                  foreach (var input in definition.Data.Inputs)
1503                  {
1504                      var name = input.Key.AssertString("key").Value;
1505                      var value = input.Value.AssertScalar("value").ToString();
1506                      _hc.GetTrace().Info($"Default: {name} = {value}");
1507                      inputDefaults[name] = value;
1508                  }
1509                  Assert.Equal(2, inputDefaults.Count);
1510                  Assert.True(inputDefaults.ContainsKey("greeting"));
1511                  Assert.Equal("Hello", inputDefaults["greeting"]);
1512                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1513                  Assert.NotNull(definition.Data.Execution); 
1514                  Assert.NotNull((definition.Data.Execution as NodeJSActionExecutionData));
1515                  Assert.Equal("task.js", (definition.Data.Execution as NodeJSActionExecutionData).Script);
1516              }
1517              finally
1518              {
1519                  Teardown();
1520              }
1521          }
1522          [Fact]
1523          [Trait("Level", "L0")]
1524          [Trait("Category", "Worker")]
1525          public void LoadsNodeActionDefinition_Cleanup()
1526          {
1527              try
1528              {
1529                  Setup();
1530                  const string Content = @"
1531  # Container action
1532  name: 'Hello World'
1533  description: 'Greet the world and record the time'
1534  author: 'GitHub'
1535  inputs:
1536    greeting: # id of input
1537      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1538      required: true
1539      default: 'Hello'
1540    entryPoint: # id of input
1541      description: 'optional docker entrypoint overwrite.'
1542      required: false
1543  outputs:
1544    time: # id of output
1545      description: 'The time we did the greeting'
1546  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1547  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1548  runs:
1549    using: 'node12'
1550    main: 'task.js'
1551    post: 'cleanup.js'
1552  ";
1553                  Pipelines.ActionStep instance;
1554                  string directory;
1555                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1556                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1557                  Assert.NotNull(definition);
1558                  Assert.Equal(directory, definition.Directory);
1559                  Assert.NotNull(definition.Data);
1560                  Assert.NotNull(definition.Data.Inputs); 
1561                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1562                  foreach (var input in definition.Data.Inputs)
1563                  {
1564                      var name = input.Key.AssertString("key").Value;
1565                      var value = input.Value.AssertScalar("value").ToString();
1566                      _hc.GetTrace().Info($"Default: {name} = {value}");
1567                      inputDefaults[name] = value;
1568                  }
1569                  Assert.Equal(2, inputDefaults.Count);
1570                  Assert.True(inputDefaults.ContainsKey("greeting"));
1571                  Assert.Equal("Hello", inputDefaults["greeting"]);
1572                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1573                  Assert.NotNull(definition.Data.Execution); 
1574                  Assert.NotNull((definition.Data.Execution as NodeJSActionExecutionData));
1575                  Assert.Equal("task.js", (definition.Data.Execution as NodeJSActionExecutionData).Script);
1576                  Assert.Equal("cleanup.js", (definition.Data.Execution as NodeJSActionExecutionData).Post);
1577              }
1578              finally
1579              {
1580                  Teardown();
1581              }
1582          }
1583          [Fact]
1584          [Trait("Level", "L0")]
1585          [Trait("Category", "Worker")]
1586          public void LoadsContainerActionDefinitionDockerfile_Cleanup()
1587          {
1588              try
1589              {
1590                  Setup();
1591                  const string Content = @"
1592  # Container action
1593  name: 'Hello World'
1594  description: 'Greet the world and record the time'
1595  author: 'GitHub'
1596  inputs:
1597    greeting: # id of input
1598      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1599      required: true
1600      default: 'Hello'
1601    entryPoint: # id of input
1602      description: 'optional docker entrypoint overwrite.'
1603      required: false
1604  outputs:
1605    time: # id of output
1606      description: 'The time we did the greeting'
1607  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1608  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1609  runs:
1610    using: 'docker'
1611    image: 'Dockerfile'
1612    args:
1613    - '${{ inputs.greeting }}'
1614    entrypoint: 'main.sh'
1615    env:
1616      Token: foo
1617      Url: bar
1618    post-entrypoint: 'cleanup.sh'
1619  ";
1620                  Pipelines.ActionStep instance;
1621                  string directory;
1622                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1623                  _actionManager.CachedActionContainers[instance.Id] = new ContainerInfo() { ContainerImage = "image:1234" };
1624                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1625                  Assert.NotNull(definition);
1626                  Assert.Equal(directory, definition.Directory);
1627                  Assert.NotNull(definition.Data);
1628                  Assert.NotNull(definition.Data.Inputs); 
1629                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1630                  foreach (var input in definition.Data.Inputs)
1631                  {
1632                      var name = input.Key.AssertString("key").Value;
1633                      var value = input.Value.AssertScalar("value").ToString();
1634                      _hc.GetTrace().Info($"Default: {name} = {value}");
1635                      inputDefaults[name] = value;
1636                  }
1637                  Assert.Equal(2, inputDefaults.Count);
1638                  Assert.True(inputDefaults.ContainsKey("greeting"));
1639                  Assert.Equal("Hello", inputDefaults["greeting"]);
1640                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1641                  Assert.NotNull(definition.Data.Execution); 
1642                  Assert.NotNull((definition.Data.Execution as ContainerActionExecutionData)); 
1643                  Assert.Equal("image:1234", (definition.Data.Execution as ContainerActionExecutionData).Image);
1644                  Assert.Equal("main.sh", (definition.Data.Execution as ContainerActionExecutionData).EntryPoint);
1645                  Assert.Equal("cleanup.sh", (definition.Data.Execution as ContainerActionExecutionData).Post);
1646                  foreach (var arg in (definition.Data.Execution as ContainerActionExecutionData).Arguments)
1647                  {
1648                      Assert.Equal("${{ inputs.greeting }}", arg.AssertScalar("arg").ToString());
1649                  }
1650                  foreach (var env in (definition.Data.Execution as ContainerActionExecutionData).Environment)
1651                  {
1652                      var key = env.Key.AssertString("key").Value;
1653                      if (key == "Token")
1654                      {
1655                          Assert.Equal("foo", env.Value.AssertString("value").Value);
1656                      }
1657                      else if (key == "Url")
1658                      {
1659                          Assert.Equal("bar", env.Value.AssertString("value").Value);
1660                      }
1661                      else
1662                      {
1663                          throw new NotSupportedException(key);
1664                      }
1665                  }
1666              }
1667              finally
1668              {
1669                  Teardown();
1670              }
1671          }
1672          [Fact]
1673          [Trait("Level", "L0")]
1674          [Trait("Category", "Worker")]
1675          public void LoadsPluginActionDefinition()
1676          {
1677              try
1678              {
1679                  Setup();
1680                  const string Content = @"
1681  name: 'Hello World'
1682  description: 'Greet the world and record the time'
1683  author: 'Test Corporation'
1684  inputs:
1685    greeting: # id of input
1686      description: 'The greeting we choose - will print ""{greeting}, World!"" on stdout'
1687      required: true
1688      default: 'Hello'
1689    entryPoint: # id of input
1690      description: 'optional docker entrypoint overwrite.'
1691      required: false
1692  outputs:
1693    time: # id of output
1694      description: 'The time we did the greeting'
1695  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1696  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1697  runs:
1698    plugin: 'someplugin'
1699  ";
1700                  Pipelines.ActionStep instance;
1701                  string directory;
1702                  CreateAction(yamlContent: Content, instance: out instance, directory: out directory);
1703                  Definition definition = _actionManager.LoadAction(_ec.Object, instance);
1704                  Assert.NotNull(definition);
1705                  Assert.Equal(directory, definition.Directory);
1706                  Assert.NotNull(definition.Data);
1707                  Assert.NotNull(definition.Data.Inputs); 
1708                  Dictionary<string, string> inputDefaults = new(StringComparer.OrdinalIgnoreCase);
1709                  foreach (var input in definition.Data.Inputs)
1710                  {
1711                      var name = input.Key.AssertString("key").Value;
1712                      var value = input.Value.AssertScalar("value").ToString();
1713                      _hc.GetTrace().Info($"Default: {name} = {value}");
1714                      inputDefaults[name] = value;
1715                  }
1716                  Assert.Equal(2, inputDefaults.Count);
1717                  Assert.True(inputDefaults.ContainsKey("greeting"));
1718                  Assert.Equal("Hello", inputDefaults["greeting"]);
1719                  Assert.True(string.IsNullOrEmpty(inputDefaults["entryPoint"]));
1720                  Assert.NotNull(definition.Data.Execution); 
1721                  Assert.NotNull((definition.Data.Execution as PluginActionExecutionData));
1722                  Assert.Equal("plugin.class, plugin", (definition.Data.Execution as PluginActionExecutionData).Plugin);
1723                  Assert.Equal("plugin.cleanup, plugin", (definition.Data.Execution as PluginActionExecutionData).Post);
1724              }
1725              finally
1726              {
1727                  Teardown();
1728              }
1729          }
1730          private void CreateAction(string yamlContent, out Pipelines.ActionStep instance, out string directory)
1731          {
1732              directory = Path.Combine(_workFolder, Constants.Path.ActionsDirectory, "GitHub/actions".Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), "main");
1733              string file = Path.Combine(directory, Constants.Path.ActionManifestYmlFile);
1734              Directory.CreateDirectory(Path.GetDirectoryName(file));
1735              File.WriteAllText(file, yamlContent);
1736              instance = new Pipelines.ActionStep()
1737              {
1738                  Id = Guid.NewGuid(),
1739                  Reference = new Pipelines.RepositoryPathReference()
1740                  {
1741                      Name = "GitHub/actions",
1742                      Ref = "main",
1743                      RepositoryType = Pipelines.RepositoryTypes.GitHub
1744                  }
1745              };
1746          }
1747          private void CreateSelfRepoAction(string yamlContent, out Pipelines.ActionStep instance, out string directory)
1748          {
1749              directory = Path.Combine(_workFolder, "actions", "actions");
1750              string file = Path.Combine(directory, Constants.Path.ActionManifestYmlFile);
1751              Directory.CreateDirectory(Path.GetDirectoryName(file));
1752              File.WriteAllText(file, yamlContent);
1753              instance = new Pipelines.ActionStep()
1754              {
1755                  Id = Guid.NewGuid(),
1756                  Reference = new Pipelines.RepositoryPathReference()
1757                  {
1758                      Name = "GitHub/actions",
1759                      Ref = "main",
1760                      RepositoryType = Pipelines.PipelineConstants.SelfAlias
1761                  }
1762              };
1763          }
1764  #if OS_WINDOWS
1765          private Task<string> CreateRepoArchive()
1766  #else
1767          private async Task<string> CreateRepoArchive()
1768  #endif
1769          {
1770              const string Content = @"
1771  # Container action
1772  name: 'Hello World'
1773  description: 'Greet the world'
1774  author: 'GitHub'
1775  icon: 'hello.svg' # vector art to display in the GitHub Marketplace
1776  color: 'green' # optional, decorates the entry in the GitHub Marketplace
1777  runs:
1778    using: 'node12'
1779    main: 'task.js'
1780  ";
1781              CreateAction(yamlContent: Content, instance: out _, directory: out string directory);
1782              var tempDir = _hc.GetDirectory(WellKnownDirectory.Temp);
1783              Directory.CreateDirectory(tempDir);
1784              var archiveFile = Path.Combine(tempDir, Path.GetRandomFileName());
1785              var trace = _hc.GetTrace();
1786  #if OS_WINDOWS
1787              ZipFile.CreateFromDirectory(directory, archiveFile, CompressionLevel.Fastest, includeBaseDirectory: true);
1788              return Task.FromResult(archiveFile);
1789  #else
1790              string tar = WhichUtil.Which("tar", require: true, trace: trace);
1791              using (var processInvoker = new ProcessInvokerWrapper())
1792              {
1793                  processInvoker.Initialize(_hc);
1794                  processInvoker.OutputDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
1795                  {
1796                      if (!string.IsNullOrEmpty(args.Data))
1797                      {
1798                          trace.Info(args.Data);
1799                      }
1800                  });
1801                  processInvoker.ErrorDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
1802                  {
1803                      if (!string.IsNullOrEmpty(args.Data))
1804                      {
1805                          trace.Error(args.Data);
1806                      }
1807                  });
1808                  string cwd = Path.GetDirectoryName(directory);
1809                  string inputDirectory = Path.GetFileName(directory);
1810                  int exitCode = await processInvoker.ExecuteAsync(_hc.GetDirectory(WellKnownDirectory.Bin), tar, $"-czf \"{archiveFile}\" -C \"{cwd}\" \"{inputDirectory}\"", null, CancellationToken.None);
1811                  if (exitCode != 0)
1812                  {
1813                      throw new NotSupportedException($"Can't use 'tar -czf' to create archive file: {archiveFile}. return code: {exitCode}.");
1814                  }
1815              }
1816              return archiveFile;
1817  #endif
1818          }
1819          private static string GetLinkToActionArchive(string apiUrl, string repository, string @ref)
1820          {
1821  #if OS_WINDOWS
1822              return $"{apiUrl}/repos/{repository}/zipball/{@ref}";
1823  #else
1824              return $"{apiUrl}/repos/{repository}/tarball/{@ref}";
1825  #endif
1826          }
1827          private void Setup([CallerMemberName] string name = "", bool enableComposite = true)
1828          {
1829              _ecTokenSource?.Dispose();
1830              _ecTokenSource = new CancellationTokenSource();
1831              _hc = new TestHostContext(this, name);
1832              _workFolder = _hc.GetDirectory(WellKnownDirectory.Work);
1833              _ec = new Mock<IExecutionContext>();
1834              _ec.Setup(x => x.Global).Returns(new GlobalContext());
1835              _ec.Setup(x => x.CancellationToken).Returns(_ecTokenSource.Token);
1836              _ec.Setup(x => x.Root).Returns(new GitHub.Runner.Worker.ExecutionContext());
1837              var variables = new Dictionary<string, VariableValue>();
1838              if (enableComposite)
1839              {
1840                  variables["DistributedTask.EnableCompositeActions"] = "true";
1841              }
1842              _ec.Object.Global.Variables = new Variables(_hc, variables);
1843              _ec.Setup(x => x.ExpressionValues).Returns(new DictionaryContextData());
1844              _ec.Setup(x => x.ExpressionFunctions).Returns(new List<IFunctionInfo>());
1845              _ec.Object.Global.FileTable = new List<String>();
1846              _ec.Object.Global.Plan = new TaskOrchestrationPlanReference();
1847              _ec.Setup(x => x.Write(It.IsAny<string>(), It.IsAny<string>())).Callback((string tag, string message) => { _hc.GetTrace().Info($"[{tag}]{message}"); });
1848              _ec.Setup(x => x.AddIssue(It.IsAny<Issue>(), It.IsAny<ExecutionContextLogOptions>())).Callback((Issue issue, ExecutionContextLogOptions logOptions) => { _hc.GetTrace().Info($"[{issue.Type}]{logOptions.LogMessageOverride ?? issue.Message}"); });
1849              _ec.Setup(x => x.GetGitHubContext("workspace")).Returns(Path.Combine(_workFolder, "actions", "actions"));
1850              _dockerManager = new Mock<IDockerCommandManager>();
1851              _dockerManager.Setup(x => x.DockerPull(_ec.Object, "ubuntu:16.04")).Returns(Task.FromResult(0));
1852              _dockerManager.Setup(x => x.DockerPull(_ec.Object, "ubuntu:100.04")).Returns(Task.FromResult(1));
1853              _dockerManager.Setup(x => x.DockerBuild(_ec.Object, It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>())).Returns(Task.FromResult(0));
1854              _jobServer = new Mock<IJobServer>();
1855              _jobServer.Setup(x => x.ResolveActionDownloadInfoAsync(It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<ActionReferenceList>(), It.IsAny<CancellationToken>()))
1856                  .Returns((Guid scopeIdentifier, string hubName, Guid planId, Guid jobId, ActionReferenceList actions, CancellationToken cancellationToken) =>
1857                  {
1858                      var result = new ActionDownloadInfoCollection { Actions = new Dictionary<string, ActionDownloadInfo>() };
1859                      foreach (var action in actions.Actions)
1860                      {
1861                          var key = $"{action.NameWithOwner}@{action.Ref}";
1862                          result.Actions[key] = new ActionDownloadInfo
1863                          {
1864                              NameWithOwner = action.NameWithOwner,
1865                              Ref = action.Ref,
1866                              TarballUrl = $"https:&bsol;&bsol;api.github.com/repos/{action.NameWithOwner}/tarball/{action.Ref}",
1867                              ZipballUrl = $"https:&bsol;&bsol;api.github.com/repos/{action.NameWithOwner}/zipball/{action.Ref}",
1868                          };
1869                      }
1870                      return Task.FromResult(result);
1871                  });
1872              _launchServer = new Mock<ILaunchServer>();
1873              _launchServer.Setup(x => x.ResolveActionsDownloadInfoAsync(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<ActionReferenceList>(), It.IsAny<CancellationToken>()))
1874                  .Returns((Guid planId, Guid jobId, ActionReferenceList actions, CancellationToken cancellationToken) =>
1875                  {
1876                      var result = new ActionDownloadInfoCollection { Actions = new Dictionary<string, ActionDownloadInfo>() };
1877                      foreach (var action in actions.Actions)
1878                      {
1879                          var key = $"{action.NameWithOwner}@{action.Ref}";
1880                          result.Actions[key] = new ActionDownloadInfo
1881                          {
1882                              NameWithOwner = action.NameWithOwner,
1883                              Ref = action.Ref,
1884                              TarballUrl = $"https:&bsol;&bsol;api.github.com/repos/{action.NameWithOwner}/tarball/{action.Ref}",
1885                              ZipballUrl = $"https:&bsol;&bsol;api.github.com/repos/{action.NameWithOwner}/zipball/{action.Ref}",
1886                          };
1887                      }
1888                      return Task.FromResult(result);
1889                  });
1890              _pluginManager = new Mock<IRunnerPluginManager>();
1891              _pluginManager.Setup(x => x.GetPluginAction(It.IsAny<string>())).Returns(new RunnerPluginActionInfo() { PluginTypeName = "plugin.class, plugin", PostPluginTypeName = "plugin.cleanup, plugin" });
1892              var actionManifest = new ActionManifestManager();
1893              actionManifest.Initialize(_hc);
1894              _hc.SetSingleton<IDockerCommandManager>(_dockerManager.Object);
1895              _hc.SetSingleton<IJobServer>(_jobServer.Object);
1896              _hc.SetSingleton<ILaunchServer>(_launchServer.Object);
1897              _hc.SetSingleton<IRunnerPluginManager>(_pluginManager.Object);
1898              _hc.SetSingleton<IActionManifestManager>(actionManifest);
1899              _hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
1900              _configurationStore = new Mock<IConfigurationStore>();
1901              _configurationStore
1902                  .Setup(x => x.GetSettings())
1903                  .Returns(
1904                      new RunnerSettings
1905                      {
1906                          WorkFolder = _workFolder
1907                      });
1908              _hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
1909              var pInvoker1 = new ProcessInvokerWrapper();
1910              pInvoker1.Initialize(_hc);
1911              var pInvoker2 = new ProcessInvokerWrapper();
1912              pInvoker2.Initialize(_hc);
1913              var pInvoker3 = new ProcessInvokerWrapper();
1914              pInvoker3.Initialize(_hc);
1915              var pInvoker4 = new ProcessInvokerWrapper();
1916              pInvoker4.Initialize(_hc);
1917              var pInvoker5 = new ProcessInvokerWrapper();
1918              pInvoker5.Initialize(_hc);
1919              _hc.EnqueueInstance<IProcessInvoker>(pInvoker1);
1920              _hc.EnqueueInstance<IProcessInvoker>(pInvoker2);
1921              _hc.EnqueueInstance<IProcessInvoker>(pInvoker3);
1922              _hc.EnqueueInstance<IProcessInvoker>(pInvoker4);
1923              _hc.EnqueueInstance<IProcessInvoker>(pInvoker5);
1924              _actionManager = new ActionManager();
1925              _actionManager.Initialize(_hc);
1926              Environment.SetEnvironmentVariable("GITHUB_ACTION_DOWNLOAD_NO_BACKOFF", "1");
1927          }
1928          private void Teardown()
1929          {
1930              _hc?.Dispose();
1931              if (!string.IsNullOrEmpty(_workFolder) && Directory.Exists(_workFolder))
1932              {
1933                  Directory.Delete(_workFolder, recursive: true);
1934              }
1935          }
1936      }
1937  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.IO.Compression;
5  using System.Linq;
6  using System.Net;
7  using System.Net.Http;
8  using System.Net.Http.Headers;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.DistributedTask.ObjectTemplating.Tokens;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Runner.Worker.Container;
17  using GitHub.Services.Common;
18  using WebApi = GitHub.DistributedTask.WebApi;
19  using Pipelines = GitHub.DistributedTask.Pipelines;
20  using PipelineTemplateConstants = GitHub.DistributedTask.Pipelines.ObjectTemplating.PipelineTemplateConstants;
21  using GitHub.DistributedTask.WebApi;
22  namespace GitHub.Runner.Worker
23  {
24      public class PrepareResult
25      {
26          public PrepareResult(List<JobExtensionRunner> containerSetupSteps, Dictionary<Guid, IActionRunner> preStepTracker)
27          {
28              this.ContainerSetupSteps = containerSetupSteps;
29              this.PreStepTracker = preStepTracker;
30          }
31          public List<JobExtensionRunner> ContainerSetupSteps { get; set; }
32          public Dictionary<Guid, IActionRunner> PreStepTracker { get; set; }
33      }
34      [ServiceLocator(Default = typeof(ActionManager))]
35      public interface IActionManager : IRunnerService
36      {
37          Dictionary<Guid, ContainerInfo> CachedActionContainers { get; }
38          Dictionary<Guid, List<Pipelines.ActionStep>> CachedEmbeddedPreSteps { get; }
39          Dictionary<Guid, List<Guid>> CachedEmbeddedStepIds { get; }
40          Dictionary<Guid, Stack<Pipelines.ActionStep>> CachedEmbeddedPostSteps { get; }
41          Task<PrepareResult> PrepareActionsAsync(IExecutionContext executionContext, IEnumerable<Pipelines.JobStep> steps, Guid rootStepId = default(Guid));
42          Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action);
43      }
44      public sealed class ActionManager : RunnerService, IActionManager
45      {
46          private const int _defaultFileStreamBufferSize = 4096;
47          private const int _defaultCopyBufferSize = 81920;
48          private const string _dotcomApiUrl = "https:&bsol;&bsol;api.github.com";
49          private readonly Dictionary<Guid, ContainerInfo> _cachedActionContainers = new();
50          public Dictionary<Guid, ContainerInfo> CachedActionContainers => _cachedActionContainers;
51          private readonly Dictionary<Guid, List<Pipelines.ActionStep>> _cachedEmbeddedPreSteps = new();
52          public Dictionary<Guid, List<Pipelines.ActionStep>> CachedEmbeddedPreSteps => _cachedEmbeddedPreSteps;
53          private readonly Dictionary<Guid, List<Guid>> _cachedEmbeddedStepIds = new();
54          public Dictionary<Guid, List<Guid>> CachedEmbeddedStepIds => _cachedEmbeddedStepIds;
55          private readonly Dictionary<Guid, Stack<Pipelines.ActionStep>> _cachedEmbeddedPostSteps = new();
56          public Dictionary<Guid, Stack<Pipelines.ActionStep>> CachedEmbeddedPostSteps => _cachedEmbeddedPostSteps;
57          public async Task<PrepareResult> PrepareActionsAsync(IExecutionContext executionContext, IEnumerable<Pipelines.JobStep> steps, Guid rootStepId = default(Guid))
58          {
59              ArgUtil.NotNull(executionContext, nameof(executionContext));
60              ArgUtil.NotNull(steps, nameof(steps));
61              var state = new PrepareActionsState
62              {
63                  ImagesToBuild = new Dictionary<string, List<Guid>>(StringComparer.OrdinalIgnoreCase),
64                  ImagesToPull = new Dictionary<string, List<Guid>>(StringComparer.OrdinalIgnoreCase),
65                  ImagesToBuildInfo = new Dictionary<string, ActionContainer>(StringComparer.OrdinalIgnoreCase),
66                  PreStepTracker = new Dictionary<Guid, IActionRunner>()
67              };
68              var containerSetupSteps = new List<JobExtensionRunner>();
69              var depth = 0;
70              if (rootStepId == default(Guid))
71              {
72                  IOUtil.DeleteDirectory(HostContext.GetDirectory(WellKnownDirectory.Actions), executionContext.CancellationToken);
73              }
74              else
75              {
76                  if (!_cachedEmbeddedStepIds.ContainsKey(rootStepId))
77                  {
78                      _cachedEmbeddedStepIds[rootStepId] = new List<Guid>();
79                      foreach (var compositeStep in steps)
80                      {
81                          var guid = Guid.NewGuid();
82                          compositeStep.Id = guid;
83                          _cachedEmbeddedStepIds[rootStepId].Add(guid);
84                      }
85                  }
86                  depth = 1;
87              }
88              IEnumerable<Pipelines.ActionStep> actions = steps.OfType<Pipelines.ActionStep>();
89              executionContext.Output("Prepare all required actions");
90              PrepareActionsState result = new PrepareActionsState();
91              try
92              {
93                  result = await PrepareActionsRecursiveAsync(executionContext, state, actions, depth, rootStepId);
94              }
95              catch (FailedToResolveActionDownloadInfoException ex)
96              {
97                  Trace.Error($"Caught exception from PrepareActionsAsync Initialization: {ex}");
98                  executionContext.InfrastructureError(ex.Message);
99                  executionContext.Result = TaskResult.Failed;
100                  throw;
101              }
102              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
103              {
104                  if (state.ImagesToPull.Count > 0)
105                  {
106                      foreach (var imageToPull in result.ImagesToPull)
107                      {
108                          Trace.Info($"{imageToPull.Value.Count} steps need to pull image '{imageToPull.Key}'");
109                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.PullActionContainerAsync,
110                                                                      condition: $"{PipelineTemplateConstants.Success}()",
111                                                                      displayName: $"Pull {imageToPull.Key}",
112                                                                      data: new ContainerSetupInfo(imageToPull.Value, imageToPull.Key)));
113                      }
114                  }
115                  if (result.ImagesToBuild.Count > 0)
116                  {
117                      foreach (var imageToBuild in result.ImagesToBuild)
118                      {
119                          var setupInfo = result.ImagesToBuildInfo[imageToBuild.Key];
120                          Trace.Info($"{imageToBuild.Value.Count} steps need to build image from '{setupInfo.Dockerfile}'");
121                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.BuildActionContainerAsync,
122                                                                      condition: $"{PipelineTemplateConstants.Success}()",
123                                                                      displayName: $"Build {setupInfo.ActionRepository}",
124                                                                      data: new ContainerSetupInfo(imageToBuild.Value, setupInfo.Dockerfile, setupInfo.WorkingDirectory)));
125                      }
126                  }
127  #if !OS_LINUX
128                  if (containerSetupSteps.Count > 0)
129                  {
130                      executionContext.Output("Container action is only supported on Linux, skip pull and build docker images.");
131                      containerSetupSteps.Clear();
132                  }
133  #endif
134              }
135              return new PrepareResult(containerSetupSteps, result.PreStepTracker);
136          }
137          private async Task<PrepareActionsState> PrepareActionsRecursiveAsync(IExecutionContext executionContext, PrepareActionsState state, IEnumerable<Pipelines.ActionStep> actions, Int32 depth = 0, Guid parentStepId = default(Guid))
138          {
139              ArgUtil.NotNull(executionContext, nameof(executionContext));
140              if (depth > Constants.CompositeActionsMaxDepth)
141              {
142                  throw new Exception($"Composite action depth exceeded max depth {Constants.CompositeActionsMaxDepth}");
143              }
144              var repositoryActions = new List<Pipelines.ActionStep>();
145              foreach (var action in actions)
146              {
147                  if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
148                  {
149                      ArgUtil.NotNull(action, nameof(action));
150                      var containerReference = action.Reference as Pipelines.ContainerRegistryReference;
151                      ArgUtil.NotNull(containerReference, nameof(containerReference));
152                      ArgUtil.NotNullOrEmpty(containerReference.Image, nameof(containerReference.Image));
153                      if (!state.ImagesToPull.ContainsKey(containerReference.Image))
154                      {
155                          state.ImagesToPull[containerReference.Image] = new List<Guid>();
156                      }
157                      Trace.Info($"Action {action.Name} ({action.Id}) needs to pull image '{containerReference.Image}'");
158                      state.ImagesToPull[containerReference.Image].Add(action.Id);
159                  }
160                  else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
161                  {
162                      repositoryActions.Add(action);
163                  }
164              }
165              if (repositoryActions.Count > 0)
166              {
167                  var downloadInfos = await GetDownloadInfoAsync(executionContext, repositoryActions);
168                  foreach (var action in repositoryActions)
169                  {
170                      var lookupKey = GetDownloadInfoLookupKey(action);
171                      if (string.IsNullOrEmpty(lookupKey))
172                      {
173                          continue;
174                      }
175                      if (!downloadInfos.TryGetValue(lookupKey, out var downloadInfo))
176                      {
177                          throw new Exception($"Missing download info for {lookupKey}");
178                      }
179                      await DownloadRepositoryActionAsync(executionContext, downloadInfo);
180                  }
181                  foreach (var action in repositoryActions)
182                  {
183                      var setupInfo = PrepareRepositoryActionAsync(executionContext, action);
184                      if (setupInfo != null && setupInfo.Container != null)
185                      {
186                          if (!string.IsNullOrEmpty(setupInfo.Container.Image))
187                          {
188                              if (!state.ImagesToPull.ContainsKey(setupInfo.Container.Image))
189                              {
190                                  state.ImagesToPull[setupInfo.Container.Image] = new List<Guid>();
191                              }
192                              Trace.Info($"Action {action.Name} ({action.Id}) from repository '{setupInfo.Container.ActionRepository}' needs to pull image '{setupInfo.Container.Image}'");
193                              state.ImagesToPull[setupInfo.Container.Image].Add(action.Id);
194                          }
195                          else
196                          {
197                              ArgUtil.NotNullOrEmpty(setupInfo.Container.ActionRepository, nameof(setupInfo.Container.ActionRepository));
198                              if (!state.ImagesToBuild.ContainsKey(setupInfo.Container.ActionRepository))
199                              {
200                                  state.ImagesToBuild[setupInfo.Container.ActionRepository] = new List<Guid>();
201                              }
202                              Trace.Info($"Action {action.Name} ({action.Id}) from repository '{setupInfo.Container.ActionRepository}' needs to build image '{setupInfo.Container.Dockerfile}'");
203                              state.ImagesToBuild[setupInfo.Container.ActionRepository].Add(action.Id);
204                              state.ImagesToBuildInfo[setupInfo.Container.ActionRepository] = setupInfo.Container;
205                          }
206                      }
207                      else if (setupInfo != null && setupInfo.Steps != null && setupInfo.Steps.Count > 0)
208                      {
209                          state = await PrepareActionsRecursiveAsync(executionContext, state, setupInfo.Steps, depth + 1, action.Id);
210                      }
211                      var repoAction = action.Reference as Pipelines.RepositoryPathReference;
212                      if (repoAction.RepositoryType != Pipelines.PipelineConstants.SelfAlias)
213                      {
214                          var definition = LoadAction(executionContext, action);
215                          if (definition.Data.Execution.HasPre)
216                          {
217                              Trace.Info($"Add 'pre' execution for {action.Id}");
218                              if (depth < 1)
219                              {
220                                  var actionRunner = HostContext.CreateService<IActionRunner>();
221                                  actionRunner.Action = action;
222                                  actionRunner.Stage = ActionRunStage.Pre;
223                                  actionRunner.Condition = definition.Data.Execution.InitCondition;
224                                  state.PreStepTracker[action.Id] = actionRunner;
225                              }
226                              else
227                              {
228                                  if (!_cachedEmbeddedPreSteps.ContainsKey(parentStepId))
229                                  {
230                                      _cachedEmbeddedPreSteps[parentStepId] = new List<Pipelines.ActionStep>();
231                                  }
232                                  var clonedAction = action.Clone() as Pipelines.ActionStep;
233                                  clonedAction.Condition = definition.Data.Execution.InitCondition;
234                                  _cachedEmbeddedPreSteps[parentStepId].Add(clonedAction);
235                              }
236                          }
237                          if (definition.Data.Execution.HasPost && depth > 0)
238                          {
239                              if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
240                              {
241                                  _cachedEmbeddedPostSteps[parentStepId] = new Stack<Pipelines.ActionStep>();
242                              }
243                              var clonedAction = action.Clone() as Pipelines.ActionStep;
244                              clonedAction.Condition = definition.Data.Execution.CleanupCondition;
245                              _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
246                          }
247                      }
248                      else if (depth > 0)
249                      {
250                          if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
251                          {
252                              _cachedEmbeddedPostSteps[parentStepId] = new Stack<Pipelines.ActionStep>();
253                          }
254                          var clonedAction = action.Clone() as Pipelines.ActionStep;
255                          _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
256                      }
257                  }
258              }
259              return state;
260          }
261          public Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action)
262          {
263              Trace.Entering();
264              ArgUtil.NotNull(action, nameof(action));
265              var definition = new Definition()
266              {
267                  Data = new ActionDefinitionData()
268              };
269              if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
270              {
271                  if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
272                  {
273                      Trace.Info("Load action that will run container through container hooks.");
274                      var containerAction = action.Reference as Pipelines.ContainerRegistryReference;
275                      definition.Data.Execution = new ContainerActionExecutionData()
276                      {
277                          Image = containerAction.Image,
278                      };
279                      Trace.Info($"Using action container image: {containerAction.Image}.");
280                  }
281                  else
282                  {
283                      Trace.Info("Load action that reference container from registry.");
284                      CachedActionContainers.TryGetValue(action.Id, out var container);
285                      ArgUtil.NotNull(container, nameof(container));
286                      definition.Data.Execution = new ContainerActionExecutionData()
287                      {
288                          Image = container.ContainerImage
289                      };
290                      Trace.Info($"Using action container image: {container.ContainerImage}.");
291                  }
292              }
293              else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
294              {
295                  string actionDirectory = null;
296                  var repoAction = action.Reference as Pipelines.RepositoryPathReference;
297                  if (string.Equals(repoAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
298                  {
299                      actionDirectory = executionContext.GetGitHubContext("workspace");
300                      if (!string.IsNullOrEmpty(repoAction.Path))
301                      {
302                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
303                      }
304                  }
305                  else
306                  {
307                      actionDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repoAction.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repoAction.Ref);
308                      if (!string.IsNullOrEmpty(repoAction.Path))
309                      {
310                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
311                      }
312                  }
313                  Trace.Info($"Load action that reference repository from '{actionDirectory}'");
314                  definition.Directory = actionDirectory;
315                  string manifestFile = Path.Combine(actionDirectory, Constants.Path.ActionManifestYmlFile);
<span onclick='openModal()' class='match'>316                  string manifestFileYaml = Path.Combine(actionDirectory, Constants.Path.ActionManifestYamlFile);
317                  string dockerFile = Path.Combine(actionDirectory, "Dockerfile");
</span>318                  string dockerFileLowerCase = Path.Combine(actionDirectory, "dockerfile");
319                  if (File.Exists(manifestFile) || File.Exists(manifestFileYaml))
320                  {
321                      var manifestManager = HostContext.GetService<IActionManifestManager>();
322                      if (File.Exists(manifestFile))
323                      {
324                          definition.Data = manifestManager.Load(executionContext, manifestFile);
325                      }
326                      else
327                      {
328                          definition.Data = manifestManager.Load(executionContext, manifestFileYaml);
329                      }
330                      Trace.Verbose($"Action friendly name: '{definition.Data.Name}'");
331                      Trace.Verbose($"Action description: '{definition.Data.Description}'");
332                      if (definition.Data.Inputs != null)
333                      {
334                          foreach (var input in definition.Data.Inputs)
335                          {
336                              Trace.Verbose($"Action input: '{input.Key.ToString()}' default to '{input.Value.ToString()}'");
337                          }
338                      }
339                      if (definition.Data.Execution.ExecutionType == ActionExecutionType.Container)
340                      {
341                          var containerAction = definition.Data.Execution as ContainerActionExecutionData;
342                          Trace.Info($"Action container Dockerfile/image: {containerAction.Image}.");
343                          if (containerAction.Arguments != null)
344                          {
345                              Trace.Info($"Action container args:  {StringUtil.ConvertToJson(containerAction.Arguments)}.");
346                          }
347                          if (containerAction.Environment != null)
348                          {
349                              Trace.Info($"Action container env: {StringUtil.ConvertToJson(containerAction.Environment)}.");
350                          }
351                          if (!string.IsNullOrEmpty(containerAction.Pre))
352                          {
353                              Trace.Info($"Action container pre entrypoint: {containerAction.Pre}.");
354                          }
355                          if (!string.IsNullOrEmpty(containerAction.EntryPoint))
356                          {
357                              Trace.Info($"Action container entrypoint: {containerAction.EntryPoint}.");
358                          }
359                          if (!string.IsNullOrEmpty(containerAction.Post))
360                          {
361                              Trace.Info($"Action container post entrypoint: {containerAction.Post}.");
362                          }
363                          if (CachedActionContainers.TryGetValue(action.Id, out var container))
364                          {
365                              Trace.Info($"Image '{containerAction.Image}' already built/pulled, use image: {container.ContainerImage}.");
366                              containerAction.Image = container.ContainerImage;
367                          }
368                      }
369                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.NodeJS)
370                      {
371                          var nodeAction = definition.Data.Execution as NodeJSActionExecutionData;
372                          Trace.Info($"Action pre node.js file: {nodeAction.Pre ?? "N/A"}.");
373                          Trace.Info($"Action node.js file: {nodeAction.Script}.");
374                          Trace.Info($"Action post node.js file: {nodeAction.Post ?? "N/A"}.");
375                      }
376                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Plugin)
377                      {
378                          var pluginAction = definition.Data.Execution as PluginActionExecutionData;
379                          var pluginManager = HostContext.GetService<IRunnerPluginManager>();
380                          var plugin = pluginManager.GetPluginAction(pluginAction.Plugin);
381                          ArgUtil.NotNull(plugin, pluginAction.Plugin);
382                          ArgUtil.NotNullOrEmpty(plugin.PluginTypeName, pluginAction.Plugin);
383                          pluginAction.Plugin = plugin.PluginTypeName;
384                          Trace.Info($"Action plugin: {plugin.PluginTypeName}.");
385                          if (!string.IsNullOrEmpty(plugin.PostPluginTypeName))
386                          {
387                              pluginAction.Post = plugin.PostPluginTypeName;
388                              Trace.Info($"Action cleanup plugin: {plugin.PluginTypeName}.");
389                          }
390                      }
391                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Composite)
392                      {
393                          var compositeAction = definition.Data.Execution as CompositeActionExecutionData;
394                          Trace.Info($"Load {compositeAction.Steps?.Count ?? 0} action steps.");
395                          Trace.Verbose($"Details: {StringUtil.ConvertToJson(compositeAction?.Steps)}");
396                          Trace.Info($"Load: {compositeAction.Outputs?.Count ?? 0} number of outputs");
397                          Trace.Info($"Details: {StringUtil.ConvertToJson(compositeAction?.Outputs)}");
398                          if (CachedEmbeddedPreSteps.TryGetValue(action.Id, out var preSteps))
399                          {
400                              compositeAction.PreSteps = preSteps;
401                          }
402                          if (CachedEmbeddedPostSteps.TryGetValue(action.Id, out var postSteps))
403                          {
404                              compositeAction.PostSteps = postSteps;
405                          }
406                          if (_cachedEmbeddedStepIds.ContainsKey(action.Id))
407                          {
408                              for (var i = 0; i < compositeAction.Steps.Count; i++)
409                              {
410                                  compositeAction.Steps[i].Id = _cachedEmbeddedStepIds[action.Id][i];
411                                  if (string.IsNullOrEmpty(executionContext.Global.Variables.Get("DistributedTask.EnableCompositeActions")) && compositeAction.Steps[i].Reference.Type != Pipelines.ActionSourceType.Script)
412                                  {
413                                      throw new Exception("`uses:` keyword is not currently supported.");
414                                  }
415                              }
416                          }
417                          else
418                          {
419                              _cachedEmbeddedStepIds[action.Id] = new List<Guid>();
420                              foreach (var compositeStep in compositeAction.Steps)
421                              {
422                                  var guid = Guid.NewGuid();
423                                  compositeStep.Id = guid;
424                                  _cachedEmbeddedStepIds[action.Id].Add(guid);
425                              }
426                          }
427                      }
428                      else
429                      {
430                          throw new NotSupportedException(definition.Data.Execution.ExecutionType.ToString());
431                      }
432                  }
433                  else if (File.Exists(dockerFile))
434                  {
435                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
436                      {
437                          definition.Data.Execution = new ContainerActionExecutionData()
438                          {
439                              Image = container.ContainerImage
440                          };
441                      }
442                      else
443                      {
444                          definition.Data.Execution = new ContainerActionExecutionData()
445                          {
446                              Image = dockerFile
447                          };
448                      }
449                  }
450                  else if (File.Exists(dockerFileLowerCase))
451                  {
452                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
453                      {
454                          definition.Data.Execution = new ContainerActionExecutionData()
455                          {
456                              Image = container.ContainerImage
457                          };
458                      }
459                      else
460                      {
461                          definition.Data.Execution = new ContainerActionExecutionData()
462                          {
463                              Image = dockerFileLowerCase
464                          };
465                      }
466                  }
467                  else
468                  {
469                      var fullPath = IOUtil.ResolvePath(actionDirectory, "."); 
470                      throw new NotSupportedException($"Can't find 'action.yml', 'action.yaml' or 'Dockerfile' under '{fullPath}'. Did you forget to run actions/checkout before running your local action?");
471                  }
472              }
473              else if (action.Reference.Type == Pipelines.ActionSourceType.Script)
474              {
475                  definition.Data.Execution = new ScriptActionExecutionData();
476                  definition.Data.Name = "Run";
477                  definition.Data.Description = "Execute a script";
478              }
479              else
480              {
481                  throw new NotSupportedException(action.Reference.Type.ToString());
482              }
483              return definition;
484          }
485          private async Task PullActionContainerAsync(IExecutionContext executionContext, object data)
486          {
487              var setupInfo = data as ContainerSetupInfo;
488              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
489              ArgUtil.NotNullOrEmpty(setupInfo.Container.Image, nameof(setupInfo.Container.Image));
490              executionContext.Output($"##[group]Pull down action image '{setupInfo.Container.Image}'");
491              var dockerManager = HostContext.GetService<IDockerCommandManager>();
492              int retryCount = 0;
493              int pullExitCode = 0;
494              while (retryCount < 3)
495              {
496                  pullExitCode = await dockerManager.DockerPull(executionContext, setupInfo.Container.Image);
497                  if (pullExitCode == 0)
498                  {
499                      break;
500                  }
501                  else
502                  {
503                      retryCount++;
504                      if (retryCount < 3)
505                      {
506                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
507                          executionContext.Warning($"Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
508                          await Task.Delay(backOff);
509                      }
510                  }
511              }
512              executionContext.Output("##[endgroup]");
513              if (retryCount == 3 && pullExitCode != 0)
514              {
515                  throw new InvalidOperationException($"Docker pull failed with exit code {pullExitCode}");
516              }
517              foreach (var stepId in setupInfo.StepIds)
518              {
519                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = setupInfo.Container.Image };
520                  Trace.Info($"Prepared docker image '{setupInfo.Container.Image}' for action {stepId} ({setupInfo.Container.Image})");
521              }
522          }
523          private async Task BuildActionContainerAsync(IExecutionContext executionContext, object data)
524          {
525              var setupInfo = data as ContainerSetupInfo;
526              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
527              ArgUtil.NotNullOrEmpty(setupInfo.Container.Dockerfile, nameof(setupInfo.Container.Dockerfile));
528              executionContext.Output($"##[group]Build container for action use: '{setupInfo.Container.Dockerfile}'.");
529              var dockerManager = HostContext.GetService<IDockerCommandManager>();
530              int retryCount = 0;
531              int buildExitCode = 0;
532              var imageName = $"{dockerManager.DockerInstanceLabel}:{Guid.NewGuid().ToString("N")}";
533              while (retryCount < 3)
534              {
535                  buildExitCode = await dockerManager.DockerBuild(
536                      executionContext,
537                      setupInfo.Container.WorkingDirectory,
538                      setupInfo.Container.Dockerfile,
539                      Directory.GetParent(setupInfo.Container.Dockerfile).FullName,
540                      imageName);
541                  if (buildExitCode == 0)
542                  {
543                      break;
544                  }
545                  else
546                  {
547                      retryCount++;
548                      if (retryCount < 3)
549                      {
550                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
551                          executionContext.Warning($"Docker build failed with exit code {buildExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
552                          await Task.Delay(backOff);
553                      }
554                  }
555              }
556              executionContext.Output("##[endgroup]");
557              if (retryCount == 3 && buildExitCode != 0)
558              {
559                  throw new InvalidOperationException($"Docker build failed with exit code {buildExitCode}");
560              }
561              foreach (var stepId in setupInfo.StepIds)
562              {
563                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = imageName };
564                  Trace.Info($"Prepared docker image '{imageName}' for action {stepId} ({setupInfo.Container.Dockerfile})");
565              }
566          }
567          private async Task<IDictionary<string, WebApi.ActionDownloadInfo>> GetDownloadInfoAsync(IExecutionContext executionContext, List<Pipelines.ActionStep> actions)
568          {
569              executionContext.Output("Getting action download info");
570              var actionReferences = actions
571                  .GroupBy(x => GetDownloadInfoLookupKey(x))
572                  .Where(x => !string.IsNullOrEmpty(x.Key))
573                  .Select(x =>
574                  {
575                      var action = x.First();
576                      var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
577                      ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
578                      return new WebApi.ActionReference
579                      {
580                          NameWithOwner = repositoryReference.Name,
581                          Ref = repositoryReference.Ref,
582                          Path = repositoryReference.Path,
583                      };
584                  })
585                  .ToList();
586              if (actionReferences.Count == 0)
587              {
588                  return new Dictionary<string, WebApi.ActionDownloadInfo>();
589              }
590              var launchServer = HostContext.GetService<ILaunchServer>();
591              var jobServer = HostContext.GetService<IJobServer>();
592              var actionDownloadInfos = default(WebApi.ActionDownloadInfoCollection);
593              for (var attempt = 1; attempt <= 3; attempt++)
594              {
595                  try
596                  {
597                      if (MessageUtil.IsRunServiceJob(executionContext.Global.Variables.Get(Constants.Variables.System.JobRequestType)))
598                      {
599                          actionDownloadInfos = await launchServer.ResolveActionsDownloadInfoAsync(executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
600                      }
601                      else
602                      {
603                          actionDownloadInfos = await jobServer.ResolveActionDownloadInfoAsync(executionContext.Global.Plan.ScopeIdentifier, executionContext.Global.Plan.PlanType, executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
604                      }
605                      break;
606                  }
607                  catch (Exception ex) when (!executionContext.CancellationToken.IsCancellationRequested) 
608                  {
609                      if (attempt < 3 && !(ex is WebApi.UnresolvableActionDownloadInfoException))
610                      {
611                          executionContext.Output($"Failed to resolve action download info. Error: {ex.Message}");
612                          executionContext.Debug(ex.ToString());
613                          if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF")))
614                          {
615                              var backoff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
616                              executionContext.Output($"Retrying in {backoff.TotalSeconds} seconds");
617                              await Task.Delay(backoff);
618                          }
619                      }
620                      else
621                      {
622                          if (ex is WebApi.UnresolvableActionDownloadInfoException)
623                          {
624                              throw;
625                          }
626                          else
627                          {
628                              throw new WebApi.FailedToResolveActionDownloadInfoException("Failed to resolve action download info.", ex);
629                          }
630                      }
631                  }
632              }
633              ArgUtil.NotNull(actionDownloadInfos, nameof(actionDownloadInfos));
634              ArgUtil.NotNull(actionDownloadInfos.Actions, nameof(actionDownloadInfos.Actions));
635              var apiUrl = GetApiUrl(executionContext);
636              var defaultAccessToken = executionContext.GetGitHubContext("token");
637              var configurationStore = HostContext.GetService<IConfigurationStore>();
638              var runnerSettings = configurationStore.GetSettings();
639              foreach (var actionDownloadInfo in actionDownloadInfos.Actions.Values)
640              {
641                  HostContext.SecretMasker.AddValue(actionDownloadInfo.Authentication?.Token);
642                  if (string.IsNullOrEmpty(actionDownloadInfo.Authentication?.Token))
643                  {
644                      actionDownloadInfo.Authentication = new WebApi.ActionDownloadAuthentication { Token = defaultAccessToken };
645                  }
646              }
647              return actionDownloadInfos.Actions;
648          }
649          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo)
650          {
651              Trace.Entering();
652              ArgUtil.NotNull(executionContext, nameof(executionContext));
653              ArgUtil.NotNull(downloadInfo, nameof(downloadInfo));
654              ArgUtil.NotNullOrEmpty(downloadInfo.NameWithOwner, nameof(downloadInfo.NameWithOwner));
655              ArgUtil.NotNullOrEmpty(downloadInfo.Ref, nameof(downloadInfo.Ref));
656              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), downloadInfo.NameWithOwner.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), downloadInfo.Ref);
657              string watermarkFile = GetWatermarkFilePath(destDirectory);
658              if (File.Exists(watermarkFile))
659              {
660                  executionContext.Debug($"Action '{downloadInfo.NameWithOwner}@{downloadInfo.Ref}' already downloaded at '{destDirectory}'.");
661                  return;
662              }
663              else
664              {
665                  IOUtil.DeleteDirectory(destDirectory, executionContext.CancellationToken);
666                  Directory.CreateDirectory(destDirectory);
667                  executionContext.Output($"Download action repository '{downloadInfo.NameWithOwner}@{downloadInfo.Ref}' (SHA:{downloadInfo.ResolvedSha})");
668              }
669              await DownloadRepositoryActionAsync(executionContext, downloadInfo, destDirectory);
670          }
671          private string GetApiUrl(IExecutionContext executionContext)
672          {
673              string apiUrl = executionContext.GetGitHubContext("api_url");
674              if (!string.IsNullOrEmpty(apiUrl))
675              {
676                  return apiUrl;
677              }
678              return _dotcomApiUrl;
679          }
680          private static string BuildLinkToActionArchive(string apiUrl, string repository, string @ref)
681          {
682  #if OS_WINDOWS
683              return $"{apiUrl}/repos/{repository}/zipball/{@ref}";
684  #else
685              return $"{apiUrl}/repos/{repository}/tarball/{@ref}";
686  #endif
687          }
688          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo, string destDirectory)
689          {
690              string tempDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), "_temp_" + Guid.NewGuid());
691              Directory.CreateDirectory(tempDirectory);
692  #if OS_WINDOWS
693              string archiveFile = Path.Combine(tempDirectory, $"{Guid.NewGuid()}.zip");
694              string link = downloadInfo?.ZipballUrl;
695  #else
696              string archiveFile = Path.Combine(tempDirectory, $"{Guid.NewGuid()}.tar.gz");
697              string link = downloadInfo?.TarballUrl;
698  #endif
699              Trace.Info($"Save archive '{link}' into {archiveFile}.");
700              try
701              {
702                  int retryCount = 0;
703                  int timeoutSeconds = 20 * 60;
704                  while (retryCount < 3)
705                  {
706                      using (var actionDownloadTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)))
707                      using (var actionDownloadCancellation = CancellationTokenSource.CreateLinkedTokenSource(actionDownloadTimeout.Token, executionContext.CancellationToken))
708                      {
709                          try
710                          {
711                              using (FileStream fs = new(archiveFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
712                              using (var httpClientHandler = HostContext.CreateHttpClientHandler())
713                              using (var httpClient = new HttpClient(httpClientHandler))
714                              {
715                                  httpClient.DefaultRequestHeaders.Authorization = CreateAuthHeader(downloadInfo.Authentication?.Token);
716                                  httpClient.DefaultRequestHeaders.UserAgent.AddRange(HostContext.UserAgents);
717                                  using (var response = await httpClient.GetAsync(link))
718                                  {
719                                      if (response.IsSuccessStatusCode)
720                                      {
721                                          using (var result = await response.Content.ReadAsStreamAsync())
722                                          {
723                                              await result.CopyToAsync(fs, _defaultCopyBufferSize, actionDownloadCancellation.Token);
724                                              await fs.FlushAsync(actionDownloadCancellation.Token);
725                                              break;
726                                          }
727                                      }
728                                      else if (response.StatusCode == HttpStatusCode.NotFound)
729                                      {
730                                          throw new ActionNotFoundException(new Uri(link));
731                                      }
732                                      else
733                                      {
734                                          response.EnsureSuccessStatusCode();
735                                      }
736                                  }
737                              }
738                          }
739                          catch (OperationCanceledException) when (executionContext.CancellationToken.IsCancellationRequested)
740                          {
741                              Trace.Info("Action download has been cancelled.");
742                              throw;
743                          }
744                          catch (ActionNotFoundException)
745                          {
746                              Trace.Info($"The action at '{link}' does not exist");
747                              throw;
748                          }
749                          catch (Exception ex) when (retryCount < 2)
750                          {
751                              retryCount++;
752                              Trace.Error($"Fail to download archive '{link}' -- Attempt: {retryCount}");
753                              Trace.Error(ex);
754                              if (actionDownloadTimeout.Token.IsCancellationRequested)
755                              {
756                                  executionContext.Warning($"Action '{link}' didn't finish download within {timeoutSeconds} seconds.");
757                              }
758                              else
759                              {
760                                  executionContext.Warning($"Failed to download action '{link}'. Error: {ex.Message}");
761                              }
762                          }
763                      }
764                      if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF")))
765                      {
766                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
767                          executionContext.Warning($"Back off {backOff.TotalSeconds} seconds before retry.");
768                          await Task.Delay(backOff);
769                      }
770                  }
771                  ArgUtil.NotNullOrEmpty(archiveFile, nameof(archiveFile));
772                  executionContext.Debug($"Download '{link}' to '{archiveFile}'");
773                  var stagingDirectory = Path.Combine(tempDirectory, "_staging");
774                  Directory.CreateDirectory(stagingDirectory);
775  #if OS_WINDOWS
776                  ZipFile.ExtractToDirectory(archiveFile, stagingDirectory);
777  #else
778                  string tar = WhichUtil.Which("tar", require: true, trace: Trace);
779                  using (var processInvoker = HostContext.CreateService<IProcessInvoker>())
780                  {
781                      processInvoker.OutputDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
782                      {
783                          if (!string.IsNullOrEmpty(args.Data))
784                          {
785                              Trace.Info(args.Data);
786                          }
787                      });
788                      processInvoker.ErrorDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
789                      {
790                          if (!string.IsNullOrEmpty(args.Data))
791                          {
792                              Trace.Error(args.Data);
793                          }
794                      });
795                      int exitCode = await processInvoker.ExecuteAsync(stagingDirectory, tar, $"-xzf \"{archiveFile}\"", null, executionContext.CancellationToken);
796                      if (exitCode != 0)
797                      {
798                          throw new NotSupportedException($"Can't use 'tar -xzf' extract archive file: {archiveFile}. return code: {exitCode}.");
799                      }
800                  }
801  #endif
802                  var subDirectories = new DirectoryInfo(stagingDirectory).GetDirectories();
803                  if (subDirectories.Length != 1)
804                  {
805                      throw new InvalidOperationException($"'{archiveFile}' contains '{subDirectories.Length}' directories");
806                  }
807                  else
808                  {
809                      executionContext.Debug($"Unwrap '{subDirectories[0].Name}' to '{destDirectory}'");
810                      IOUtil.CopyDirectory(subDirectories[0].FullName, destDirectory, executionContext.CancellationToken);
811                  }
812                  Trace.Verbose("Create watermark file indicate action download succeed.");
813                  string watermarkFile = GetWatermarkFilePath(destDirectory);
814                  File.WriteAllText(watermarkFile, DateTime.UtcNow.ToString());
815                  executionContext.Debug($"Archive '{archiveFile}' has been unzipped into '{destDirectory}'.");
816                  Trace.Info("Finished getting action repository.");
817              }
818              finally
819              {
820                  try
821                  {
822                      if (Directory.Exists(tempDirectory))
823                      {
824                          Trace.Verbose("Deleting action temp folder: {0}", tempDirectory);
825                          IOUtil.DeleteDirectory(tempDirectory, CancellationToken.None); 
826                      }
827                  }
828                  catch (Exception ex)
829                  {
830                      Trace.Warning("Failed to delete temp folder '{0}'. Exception: {1}", tempDirectory, ex);
831                  }
832              }
833          }
834          private void ConfigureAuthorizationFromContext(IExecutionContext executionContext, HttpClient httpClient)
835          {
836              var authToken = Environment.GetEnvironmentVariable("_GITHUB_ACTION_TOKEN");
837              if (string.IsNullOrEmpty(authToken))
838              {
839                  authToken = executionContext.Global.Variables.Get("PREVIEW_ACTION_TOKEN");
840              }
841              if (!string.IsNullOrEmpty(authToken))
842              {
843                  HostContext.SecretMasker.AddValue(authToken);
844                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"PAT:{authToken}"));
845                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", base64EncodingToken);
846              }
847              else
848              {
849                  var accessToken = executionContext.GetGitHubContext("token");
850                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"x-access-token:{accessToken}"));
851                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", base64EncodingToken);
852              }
853          }
854          private string GetWatermarkFilePath(string directory) => directory + ".completed";
855          private ActionSetupInfo PrepareRepositoryActionAsync(IExecutionContext executionContext, Pipelines.ActionStep repositoryAction)
856          {
857              var repositoryReference = repositoryAction.Reference as Pipelines.RepositoryPathReference;
858              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
859              {
860                  Trace.Info($"Repository action is in 'self' repository.");
861                  return null;
862              }
863              var setupInfo = new ActionSetupInfo();
864              var actionContainer = new ActionContainer();
865              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repositoryReference.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repositoryReference.Ref);
866              string actionEntryDirectory = destDirectory;
867              string dockerFileRelativePath = repositoryReference.Name;
868              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
869              if (!string.IsNullOrEmpty(repositoryReference.Path))
870              {
871                  actionEntryDirectory = Path.Combine(destDirectory, repositoryReference.Path);
872                  dockerFileRelativePath = $"{dockerFileRelativePath}/{repositoryReference.Path}";
873                  actionContainer.ActionRepository = $"{repositoryReference.Name}/{repositoryReference.Path}@{repositoryReference.Ref}";
874              }
875              else
876              {
877                  actionContainer.ActionRepository = $"{repositoryReference.Name}@{repositoryReference.Ref}";
878              }
879              var dockerFile = Path.Combine(actionEntryDirectory, "Dockerfile");
880              var dockerFileLowerCase = Path.Combine(actionEntryDirectory, "dockerfile");
881              var actionManifest = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYmlFile);
882              var actionManifestYaml = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYamlFile);
883              if (File.Exists(actionManifest) || File.Exists(actionManifestYaml))
884              {
885                  executionContext.Debug($"action.yml for action: '{actionManifest}'.");
886                  var manifestManager = HostContext.GetService<IActionManifestManager>();
887                  ActionDefinitionData actionDefinitionData = null;
888                  if (File.Exists(actionManifest))
889                  {
890                      actionDefinitionData = manifestManager.Load(executionContext, actionManifest);
891                  }
892                  else
893                  {
894                      actionDefinitionData = manifestManager.Load(executionContext, actionManifestYaml);
895                  }
896                  if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Container)
897                  {
898                      var containerAction = actionDefinitionData.Execution as ContainerActionExecutionData;
899                      if (DockerUtil.IsDockerfile(containerAction.Image))
900                      {
901                          var dockerFileFullPath = Path.Combine(actionEntryDirectory, containerAction.Image);
902                          executionContext.Debug($"Dockerfile for action: '{dockerFileFullPath}'.");
903                          actionContainer.Dockerfile = dockerFileFullPath;
904                          actionContainer.WorkingDirectory = destDirectory;
905                          setupInfo.Container = actionContainer;
906                          return setupInfo;
907                      }
908                      else if (containerAction.Image.StartsWith("docker:&bsol;&bsol;", StringComparison.OrdinalIgnoreCase))
909                      {
910                          var actionImage = containerAction.Image.Substring("docker:&bsol;&bsol;".Length);
911                          executionContext.Debug($"Container image for action: '{actionImage}'.");
912                          actionContainer.Image = actionImage;
913                          setupInfo.Container = actionContainer;
914                          return setupInfo;
915                      }
916                      else
917                      {
918                          throw new NotSupportedException($"'{containerAction.Image}' should be either '[path]/Dockerfile' or 'docker:&bsol;&bsol;image[:tag]'.");
919                      }
920                  }
921                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.NodeJS)
922                  {
923                      Trace.Info($"Action node.js file: {(actionDefinitionData.Execution as NodeJSActionExecutionData).Script}, no more preparation.");
924                      return null;
925                  }
926                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Plugin)
927                  {
928                      Trace.Info($"Action plugin: {(actionDefinitionData.Execution as PluginActionExecutionData).Plugin}, no more preparation.");
929                      return null;
930                  }
931                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Composite)
932                  {
933                      Trace.Info($"Loading Composite steps");
934                      var compositeAction = actionDefinitionData.Execution as CompositeActionExecutionData;
935                      setupInfo.Steps = compositeAction.Steps;
936                      if (!_cachedEmbeddedStepIds.ContainsKey(repositoryAction.Id))
937                      {
938                          _cachedEmbeddedStepIds[repositoryAction.Id] = new List<Guid>();
939                          foreach (var compositeStep in compositeAction.Steps)
940                          {
941                              var guid = Guid.NewGuid();
942                              compositeStep.Id = guid;
943                              _cachedEmbeddedStepIds[repositoryAction.Id].Add(guid);
944                          }
945                      }
946                      foreach (var step in compositeAction.Steps)
947                      {
948                          if (string.IsNullOrEmpty(executionContext.Global.Variables.Get("DistributedTask.EnableCompositeActions")) && step.Reference.Type != Pipelines.ActionSourceType.Script)
949                          {
950                              throw new Exception("`uses:` keyword is not currently supported.");
951                          }
952                      }
953                      return setupInfo;
954                  }
955                  else
956                  {
957                      throw new NotSupportedException(actionDefinitionData.Execution.ExecutionType.ToString());
958                  }
959              }
960              else if (File.Exists(dockerFile))
961              {
962                  executionContext.Debug($"Dockerfile for action: '{dockerFile}'.");
963                  actionContainer.Dockerfile = dockerFile;
964                  actionContainer.WorkingDirectory = destDirectory;
965                  setupInfo.Container = actionContainer;
966                  return setupInfo;
967              }
968              else if (File.Exists(dockerFileLowerCase))
969              {
970                  executionContext.Debug($"Dockerfile for action: '{dockerFileLowerCase}'.");
971                  actionContainer.Dockerfile = dockerFileLowerCase;
972                  actionContainer.WorkingDirectory = destDirectory;
973                  setupInfo.Container = actionContainer;
974                  return setupInfo;
975              }
976              else
977              {
978                  var fullPath = IOUtil.ResolvePath(actionEntryDirectory, "."); 
979                  throw new InvalidOperationException($"Can't find 'action.yml', 'action.yaml' or 'Dockerfile' under '{fullPath}'. Did you forget to run actions/checkout before running your local action?");
980              }
981          }
982          private static string GetDownloadInfoLookupKey(Pipelines.ActionStep action)
983          {
984              if (action.Reference.Type != Pipelines.ActionSourceType.Repository)
985              {
986                  return null;
987              }
988              var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
989              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
990              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
991              {
992                  return null;
993              }
994              if (!string.Equals(repositoryReference.RepositoryType, Pipelines.RepositoryTypes.GitHub, StringComparison.OrdinalIgnoreCase))
995              {
996                  throw new NotSupportedException(repositoryReference.RepositoryType);
997              }
998              ArgUtil.NotNullOrEmpty(repositoryReference.Name, nameof(repositoryReference.Name));
999              ArgUtil.NotNullOrEmpty(repositoryReference.Ref, nameof(repositoryReference.Ref));
1000              return $"{repositoryReference.Name}@{repositoryReference.Ref}";
1001          }
1002          private static string GetDownloadInfoLookupKey(WebApi.ActionDownloadInfo info)
1003          {
1004              ArgUtil.NotNullOrEmpty(info.NameWithOwner, nameof(info.NameWithOwner));
1005              ArgUtil.NotNullOrEmpty(info.Ref, nameof(info.Ref));
1006              return $"{info.NameWithOwner}@{info.Ref}";
1007          }
1008          private AuthenticationHeaderValue CreateAuthHeader(string token)
1009          {
1010              if (string.IsNullOrEmpty(token))
1011              {
1012                  return null;
1013              }
1014              var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"x-access-token:{token}"));
1015              HostContext.SecretMasker.AddValue(base64EncodingToken);
1016              return new AuthenticationHeaderValue("Basic", base64EncodingToken);
1017          }
1018      }
1019      public sealed class Definition
1020      {
1021          public ActionDefinitionData Data { get; set; }
1022          public string Directory { get; set; }
1023      }
1024      public sealed class ActionDefinitionData
1025      {
1026          public string Name { get; set; }
1027          public string Description { get; set; }
1028          public MappingToken Inputs { get; set; }
1029          public ActionExecutionData Execution { get; set; }
1030          public Dictionary<String, String> Deprecated { get; set; }
1031      }
1032      public enum ActionExecutionType
1033      {
1034          Container,
1035          NodeJS,
1036          Plugin,
1037          Script,
1038          Composite,
1039      }
1040      public sealed class ContainerActionExecutionData : ActionExecutionData
1041      {
1042          public override ActionExecutionType ExecutionType => ActionExecutionType.Container;
1043          public override bool HasPre => !string.IsNullOrEmpty(Pre);
1044          public override bool HasPost => !string.IsNullOrEmpty(Post);
1045          public string Image { get; set; }
1046          public string EntryPoint { get; set; }
1047          public SequenceToken Arguments { get; set; }
1048          public MappingToken Environment { get; set; }
1049          public string Pre { get; set; }
1050          public string Post { get; set; }
1051      }
1052      public sealed class NodeJSActionExecutionData : ActionExecutionData
1053      {
1054          public override ActionExecutionType ExecutionType => ActionExecutionType.NodeJS;
1055          public override bool HasPre => !string.IsNullOrEmpty(Pre);
1056          public override bool HasPost => !string.IsNullOrEmpty(Post);
1057          public string Script { get; set; }
1058          public string Pre { get; set; }
1059          public string Post { get; set; }
1060          public string NodeVersion { get; set; }
1061      }
1062      public sealed class PluginActionExecutionData : ActionExecutionData
1063      {
1064          public override ActionExecutionType ExecutionType => ActionExecutionType.Plugin;
1065          public override bool HasPre => false;
1066          public override bool HasPost => !string.IsNullOrEmpty(Post);
1067          public string Plugin { get; set; }
1068          public string Post { get; set; }
1069      }
1070      public sealed class ScriptActionExecutionData : ActionExecutionData
1071      {
1072          public override ActionExecutionType ExecutionType => ActionExecutionType.Script;
1073          public override bool HasPre => false;
1074          public override bool HasPost => false;
1075      }
1076      public sealed class CompositeActionExecutionData : ActionExecutionData
1077      {
1078          public override ActionExecutionType ExecutionType => ActionExecutionType.Composite;
1079          public override bool HasPre => PreSteps.Count > 0;
1080          public override bool HasPost => PostSteps.Count > 0;
1081          public List<Pipelines.ActionStep> PreSteps { get; set; }
1082          public List<Pipelines.ActionStep> Steps { get; set; }
1083          public Stack<Pipelines.ActionStep> PostSteps { get; set; }
1084          public MappingToken Outputs { get; set; }
1085      }
1086      public abstract class ActionExecutionData
1087      {
1088          private string _initCondition = $"{Constants.Expressions.Always}()";
1089          private string _cleanupCondition = $"{Constants.Expressions.Always}()";
1090          public abstract ActionExecutionType ExecutionType { get; }
1091          public abstract bool HasPre { get; }
1092          public abstract bool HasPost { get; }
1093          public string CleanupCondition
1094          {
1095              get { return _cleanupCondition; }
1096              set { _cleanupCondition = value; }
1097          }
1098          public string InitCondition
1099          {
1100              get { return _initCondition; }
1101              set { _initCondition = value; }
1102          }
1103      }
1104      public class ContainerSetupInfo
1105      {
1106          public ContainerSetupInfo(List<Guid> ids, string image)
1107          {
1108              StepIds = ids;
1109              Container = new ActionContainer()
1110              {
1111                  Image = image
1112              };
1113          }
1114          public ContainerSetupInfo(List<Guid> ids, string dockerfile, string workingDirectory)
1115          {
1116              StepIds = ids;
1117              Container = new ActionContainer()
1118              {
1119                  Dockerfile = dockerfile,
1120                  WorkingDirectory = workingDirectory
1121              };
1122          }
1123          public List<Guid> StepIds { get; set; }
1124          public ActionContainer Container { get; set; }
1125      }
1126      public class ActionContainer
1127      {
1128          public string Image { get; set; }
1129          public string Dockerfile { get; set; }
1130          public string WorkingDirectory { get; set; }
1131          public string ActionRepository { get; set; }
1132      }
1133      public class ActionSetupInfo
1134      {
1135          public ActionContainer Container { get; set; }
1136          public List<Pipelines.ActionStep> Steps { get; set; }
1137      }
1138      public class PrepareActionsState
1139      {
1140          public Dictionary<string, List<Guid>> ImagesToPull;
1141          public Dictionary<string, List<Guid>> ImagesToBuild;
1142          public Dictionary<string, ActionContainer> ImagesToBuildInfo;
1143          public Dictionary<Guid, IActionRunner> PreStepTracker;
1144      }
1145  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManagerL0.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>1252                  string file = Path.Combine(directory, Constants.Path.ActionManifestYamlFile);
1253                  Directory.CreateDirectory(Path.GetDirectoryName(file));
</pre></code></div>
                <div class="column column_space"><pre><code>316                  string manifestFileYaml = Path.Combine(actionDirectory, Constants.Path.ActionManifestYamlFile);
317                  string dockerFile = Path.Combine(actionDirectory, "Dockerfile");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    