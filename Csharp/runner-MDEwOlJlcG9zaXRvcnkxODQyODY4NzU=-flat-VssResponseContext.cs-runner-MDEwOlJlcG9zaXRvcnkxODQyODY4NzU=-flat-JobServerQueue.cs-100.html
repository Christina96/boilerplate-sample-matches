
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssResponseContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Net;
5  using System.Net.Http.Headers;
6  using System.Text.RegularExpressions;
7  using GitHub.Services.Common;
8  using Newtonsoft.Json;
9  namespace GitHub.Services.WebApi
10  {
11      public class VssResponseContext
12      {
13          internal VssResponseContext(HttpStatusCode statusCode, HttpResponseHeaders headers)
14          {
15              if (headers.Contains(Common.Internal.HttpHeaders.ActivityId))
16              {
17                  IEnumerable&lt;string&gt; values = headers.GetValues(Common.Internal.HttpHeaders.ActivityId);
18                  string activityId = values.FirstOrDefault();
19                  Guid result;
20                  Guid.TryParse(activityId, out result);
21                  ActivityId = result;
22              }
<span onclick='openModal()' class='match'>23              IEnumerable&lt;String&gt; headerValues;
24              if (headers.TryGetValues(PerformanceTimerConstants.Header, out headerValues))
25              {
26                  Timings = JsonConvert.DeserializeObject&lt;IDictionary&lt;String, PerformanceTimingGroup&gt;&gt;(headerValues.First());
</span>27              }
28              HttpStatusCode = statusCode;
29              Headers = headers;
30          }
31          public bool TryGetException(out Exception value)
32          {
33              value = Exception;
34              return Exception != null;
35          }
36          public bool TryGetErrorCode(out string value)
37          {
38              value = null;
39              if (Exception == null)
40              {
41                  return false;
42              }
43              var message = Exception.Message;
44              var match = Regex.Match(message, @&quot;(TF[0-9]+)&quot;);
45              if (match.Success)
46              {
47                  value = match.Value;
48                  return true;
49              }
50              match = Regex.Match(message, @&quot;(VSS[0-9]+)&quot;);
51              if (match.Success)
52              {
53                  value = match.Value;
54                  return true;
55              }
56              return false;
57          }
58          public HttpStatusCode HttpStatusCode { get; private set; }
59          public Guid ActivityId { get; private set; }
60          public Exception Exception { get; internal set; }
61          public IDictionary&lt;String, PerformanceTimingGroup&gt; Timings { get; private set; }
62          public HttpResponseHeaders Headers { get; private set; }
63      }
64  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobServerQueue.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.IO;
5  using System.Linq;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.DistributedTask.WebApi;
9  using GitHub.Runner.Sdk;
10  using Pipelines = GitHub.DistributedTask.Pipelines;
11  namespace GitHub.Runner.Common
12  {
13      [ServiceLocator(Default = typeof(JobServerQueue))]
14      public interface IJobServerQueue : IRunnerService, IThrottlingReporter
15      {
16          TaskCompletionSource&lt;int&gt; JobRecordUpdated { get; }
17          event EventHandler&lt;ThrottlingEventArgs&gt; JobServerQueueThrottling;
18          Task ShutdownAsync();
19          void Start(Pipelines.AgentJobRequestMessage jobRequest, bool resultServiceOnly = false);
20          void QueueWebConsoleLine(Guid stepRecordId, string line, long? lineNumber = null);
21          void QueueFileUpload(Guid timelineId, Guid timelineRecordId, string type, string name, string path, bool deleteSource);
22          void QueueResultsUpload(Guid timelineRecordId, string name, string path, string type, bool deleteSource, bool finalize, bool firstBlock, long totalLines);
23          void QueueTimelineRecordUpdate(Guid timelineId, TimelineRecord timelineRecord);
24      }
25      public sealed class JobServerQueue : RunnerService, IJobServerQueue
26      {
27          private static readonly TimeSpan _aggressiveDelayForWebConsoleLineDequeue = TimeSpan.FromMilliseconds(250);
28          private static readonly TimeSpan _delayForWebConsoleLineDequeue = TimeSpan.FromMilliseconds(500);
29          private static readonly TimeSpan _delayForTimelineUpdateDequeue = TimeSpan.FromMilliseconds(500);
30          private static readonly TimeSpan _delayForFileUploadDequeue = TimeSpan.FromMilliseconds(1000);
31          private static readonly TimeSpan _delayForResultsUploadDequeue = TimeSpan.FromMilliseconds(1000);
32          private Guid _scopeIdentifier;
33          private string _hubName;
34          private Guid _planId;
35          private Guid _jobTimelineId;
36          private Guid _jobTimelineRecordId;
37          private readonly ConcurrentQueue&lt;ConsoleLineInfo&gt; _webConsoleLineQueue = new();
38          private readonly ConcurrentQueue&lt;UploadFileInfo&gt; _fileUploadQueue = new();
39          private readonly ConcurrentQueue&lt;ResultsUploadFileInfo&gt; _resultsFileUploadQueue = new();
40          private readonly ConcurrentDictionary&lt;Guid, ConcurrentQueue&lt;TimelineRecord&gt;&gt; _timelineUpdateQueue = new();
41          private readonly List&lt;Guid&gt; _allTimelines = new();
42          private readonly Dictionary&lt;Guid, List&lt;TimelineRecord&gt;&gt; _bufferedRetryRecords = new();
43          private Task _webConsoleLineDequeueTask;
44          private Task _fileUploadDequeueTask;
45          private Task _resultsUploadDequeueTask;
46          private Task _timelineUpdateDequeueTask;
47          private IJobServer _jobServer;
48          private IResultsServer _resultsServer;
49          private Task[] _allDequeueTasks;
50          private readonly TaskCompletionSource&lt;int&gt; _jobCompletionSource = new();
51          private readonly TaskCompletionSource&lt;int&gt; _jobRecordUpdated = new();
52          private bool _queueInProcess = false;
53          private bool _resultsServiceOnly = false;
54          public TaskCompletionSource&lt;int&gt; JobRecordUpdated =&gt; _jobRecordUpdated;
55          public event EventHandler&lt;ThrottlingEventArgs&gt; JobServerQueueThrottling;
56          private int _webConsoleLineAggressiveDequeueCount = 0;
57          private const int _webConsoleLineAggressiveDequeueLimit = 4 * 60;
58          private const int _webConsoleLineQueueSizeLimit = 1024;
59          private bool _webConsoleLineAggressiveDequeue = true;
60          private bool _firstConsoleOutputs = true;
61          private bool _resultsClientInitiated = false;
62          private delegate Task ResultsFileUploadHandler(ResultsUploadFileInfo file);
63          public override void Initialize(IHostContext hostContext)
64          {
65              base.Initialize(hostContext);
66              _jobServer = hostContext.GetService&lt;IJobServer&gt;();
67              _resultsServer = hostContext.GetService&lt;IResultsServer&gt;();
68          }
69          public void Start(Pipelines.AgentJobRequestMessage jobRequest, bool resultServiceOnly = false)
70          {
71              Trace.Entering();
72              _resultsServiceOnly = resultServiceOnly;
73              var serviceEndPoint = jobRequest.Resources.Endpoints.Single(x =&gt; string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
74              if (!resultServiceOnly)
75              {
76                  _jobServer.InitializeWebsocketClient(serviceEndPoint);
77              }
78              jobRequest.Variables.TryGetValue(&quot;system.github.results_endpoint&quot;, out VariableValue resultsEndpointVariable);
79              var resultsReceiverEndpoint = resultsEndpointVariable?.Value;
80              if (serviceEndPoint?.Authorization != null &amp;&amp;
81                  serviceEndPoint.Authorization.Parameters.TryGetValue(&quot;AccessToken&quot;, out var accessToken) &amp;&amp;
82                  !string.IsNullOrEmpty(accessToken) &amp;&amp;
83                  !string.IsNullOrEmpty(resultsReceiverEndpoint))
84              {
85                  string liveConsoleFeedUrl = null;
86                  Trace.Info(&quot;Initializing results client&quot;);
87                  if (resultServiceOnly
88                      &amp;&amp; serviceEndPoint.Data.TryGetValue(&quot;FeedStreamUrl&quot;, out var feedStreamUrl)
89                      &amp;&amp; !string.IsNullOrEmpty(feedStreamUrl))
90                  {
91                      liveConsoleFeedUrl = feedStreamUrl;
92                  }
93                  _resultsServer.InitializeResultsClient(new Uri(resultsReceiverEndpoint), liveConsoleFeedUrl, accessToken);
94                  _resultsClientInitiated = true;
95              }
96              if (_queueInProcess)
97              {
98                  Trace.Info(&quot;No-opt, all queue process tasks are running.&quot;);
99                  return;
100              }
101              ArgUtil.NotNull(jobRequest, nameof(jobRequest));
102              ArgUtil.NotNull(jobRequest.Plan, nameof(jobRequest.Plan));
103              ArgUtil.NotNull(jobRequest.Timeline, nameof(jobRequest.Timeline));
104              _scopeIdentifier = jobRequest.Plan.ScopeIdentifier;
105              _hubName = jobRequest.Plan.PlanType;
106              _planId = jobRequest.Plan.PlanId;
107              _jobTimelineId = jobRequest.Timeline.Id;
108              _jobTimelineRecordId = jobRequest.JobId;
109              _timelineUpdateQueue[_jobTimelineId] = new ConcurrentQueue&lt;TimelineRecord&gt;();
110              _allTimelines.Add(_jobTimelineId);
111              Trace.Info(&quot;Start process web console line queue.&quot;);
112              _webConsoleLineDequeueTask = ProcessWebConsoleLinesQueueAsync();
113              Trace.Info(&quot;Start process file upload queue.&quot;);
114              _fileUploadDequeueTask = ProcessFilesUploadQueueAsync();
115              Trace.Info(&quot;Start results file upload queue.&quot;);
116              _resultsUploadDequeueTask = ProcessResultsUploadQueueAsync();
117              Trace.Info(&quot;Start process timeline update queue.&quot;);
118              _timelineUpdateDequeueTask = ProcessTimelinesUpdateQueueAsync();
119              _allDequeueTasks = new Task[] { _webConsoleLineDequeueTask, _fileUploadDequeueTask, _timelineUpdateDequeueTask, _resultsUploadDequeueTask };
120              _queueInProcess = true;
121          }
122          public async Task ShutdownAsync()
123          {
124              if (!_queueInProcess)
125              {
126                  Trace.Info(&quot;No-op, all queue process tasks have been stopped.&quot;);
127              }
128              Trace.Info(&quot;Fire signal to shutdown all queues.&quot;);
129              _jobCompletionSource.TrySetResult(0);
130              await Task.WhenAll(_allDequeueTasks);
131              _queueInProcess = false;
132              Trace.Info(&quot;All queue process task stopped.&quot;);
133              Trace.Verbose(&quot;Draining web console line queue.&quot;);
134              await ProcessWebConsoleLinesQueueAsync(runOnce: true);
135              Trace.Info(&quot;Web console line queue drained.&quot;);
136              Trace.Verbose(&quot;Draining file upload queue.&quot;);
137              await ProcessFilesUploadQueueAsync(runOnce: true);
138              Trace.Info(&quot;File upload queue drained.&quot;);
139              Trace.Verbose(&quot;Draining results upload queue.&quot;);
140              await ProcessResultsUploadQueueAsync(runOnce: true);
141              Trace.Info(&quot;Results upload queue drained.&quot;);
142              Trace.Verbose(&quot;Draining timeline update queue.&quot;);
143              await ProcessTimelinesUpdateQueueAsync(runOnce: true);
144              Trace.Info(&quot;Timeline update queue drained.&quot;);
145              Trace.Info($&quot;Disposing job server ...&quot;);
146              await _jobServer.DisposeAsync();
147              Trace.Info($&quot;Disposing results server ...&quot;);
148              await _resultsServer.DisposeAsync();
149              Trace.Info(&quot;All queue process tasks have been stopped, and all queues are drained.&quot;);
150          }
151          public void QueueWebConsoleLine(Guid stepRecordId, string line, long? lineNumber)
152          {
153              if (!string.IsNullOrEmpty(line) &amp;&amp; _webConsoleLineQueue.Count &lt; _webConsoleLineQueueSizeLimit)
154              {
155                  Trace.Verbose(&quot;Enqueue web console line queue: {0}&quot;, line);
156                  if (line.Length &gt; 1024)
157                  {
158                      Trace.Verbose(&quot;Web console line is more than 1024 chars, truncate to first 1024 chars&quot;);
159                      line = $&quot;{line.Substring(0, 1024)}...&quot;;
160                  }
161                  _webConsoleLineQueue.Enqueue(new ConsoleLineInfo(stepRecordId, line, lineNumber));
162              }
163          }
164          public void QueueFileUpload(Guid timelineId, Guid timelineRecordId, string type, string name, string path, bool deleteSource)
165          {
166              ArgUtil.NotEmpty(timelineId, nameof(timelineId));
167              ArgUtil.NotEmpty(timelineRecordId, nameof(timelineRecordId));
168              var newFile = new UploadFileInfo()
169              {
170                  TimelineId = timelineId,
171                  TimelineRecordId = timelineRecordId,
172                  Type = type,
173                  Name = name,
174                  Path = path,
175                  DeleteSource = deleteSource
176              };
177              Trace.Verbose(&quot;Enqueue file upload queue: file &#x27;{0}&#x27; attach to record {1}&quot;, newFile.Path, timelineRecordId);
178              _fileUploadQueue.Enqueue(newFile);
179          }
180          public void QueueResultsUpload(Guid timelineRecordId, string name, string path, string type, bool deleteSource, bool finalize, bool firstBlock, long totalLines)
181          {
182              if (!_resultsClientInitiated)
183              {
184                  Trace.Verbose(&quot;Skipping results upload&quot;);
185                  try
186                  {
187                      if (deleteSource)
188                      {
189                          File.Delete(path);
190                      }
191                  }
192                  catch (Exception ex)
193                  {
194                      Trace.Info(&quot;Catch exception during delete skipped results upload file.&quot;);
195                      Trace.Error(ex);
196                  }
197                  return;
198              }
199              var newFile = new ResultsUploadFileInfo()
200              {
201                  Name = name,
202                  Path = path,
203                  Type = type,
204                  PlanId = _planId.ToString(),
205                  JobId = _jobTimelineRecordId.ToString(),
206                  RecordId = timelineRecordId,
207                  DeleteSource = deleteSource,
208                  Finalize = finalize,
209                  FirstBlock = firstBlock,
210                  TotalLines = totalLines,
211              };
212              Trace.Verbose(&quot;Enqueue results file upload queue: file &#x27;{0}&#x27; attach to job {1} step {2}&quot;, newFile.Path, _jobTimelineRecordId, timelineRecordId);
213              _resultsFileUploadQueue.Enqueue(newFile);
214          }
215          public void QueueTimelineRecordUpdate(Guid timelineId, TimelineRecord timelineRecord)
216          {
217              ArgUtil.NotEmpty(timelineId, nameof(timelineId));
218              ArgUtil.NotNull(timelineRecord, nameof(timelineRecord));
219              ArgUtil.NotEmpty(timelineRecord.Id, nameof(timelineRecord.Id));
220              _timelineUpdateQueue.TryAdd(timelineId, new ConcurrentQueue&lt;TimelineRecord&gt;());
221              Trace.Verbose(&quot;Enqueue timeline {0} update queue: {1}&quot;, timelineId, timelineRecord.Id);
222              _timelineUpdateQueue[timelineId].Enqueue(timelineRecord.Clone());
223          }
224          public void ReportThrottling(TimeSpan delay, DateTime expiration)
225          {
226              Trace.Info($&quot;Receive server throttling report, expect delay {delay} milliseconds till {expiration}&quot;);
227              var throttlingEvent = JobServerQueueThrottling;
228              if (throttlingEvent != null)
229              {
230                  throttlingEvent(this, new ThrottlingEventArgs(delay, expiration));
231              }
232          }
233          private async Task ProcessWebConsoleLinesQueueAsync(bool runOnce = false)
234          {
235              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
236              {
237                  if (_webConsoleLineAggressiveDequeue &amp;&amp; ++_webConsoleLineAggressiveDequeueCount &gt; _webConsoleLineAggressiveDequeueLimit)
238                  {
239                      Trace.Info(&quot;Stop aggressive process web console line queue.&quot;);
240                      _webConsoleLineAggressiveDequeue = false;
241                  }
242                  Dictionary&lt;Guid, List&lt;TimelineRecordLogLine&gt;&gt; stepsConsoleLines = new();
243                  List&lt;Guid&gt; stepRecordIds = new(); 
244                  int linesCounter = 0;
245                  ConsoleLineInfo lineInfo;
246                  while (_webConsoleLineQueue.TryDequeue(out lineInfo))
247                  {
248                      if (!stepsConsoleLines.ContainsKey(lineInfo.StepRecordId))
249                      {
250                          stepsConsoleLines[lineInfo.StepRecordId] = new List&lt;TimelineRecordLogLine&gt;();
251                          stepRecordIds.Add(lineInfo.StepRecordId);
252                      }
253                      stepsConsoleLines[lineInfo.StepRecordId].Add(new TimelineRecordLogLine(lineInfo.Line, lineInfo.LineNumber));
254                      linesCounter++;
255                      if (!runOnce &amp;&amp; linesCounter &gt; 500)
256                      {
257                          break;
258                      }
259                  }
260                  foreach (var stepRecordId in stepRecordIds)
261                  {
262                      int batchCounter = 0;
263                      List&lt;List&lt;TimelineRecordLogLine&gt;&gt; batchedLines = new();
264                      foreach (var line in stepsConsoleLines[stepRecordId])
265                      {
266                          var currentBatch = batchedLines.ElementAtOrDefault(batchCounter);
267                          if (currentBatch == null)
268                          {
269                              batchedLines.Add(new List&lt;TimelineRecordLogLine&gt;());
270                              currentBatch = batchedLines.ElementAt(batchCounter);
271                          }
272                          currentBatch.Add(line);
273                          if (currentBatch.Count &gt;= 100)
274                          {
275                              batchCounter++;
276                          }
277                      }
278                      if (batchedLines.Count &gt; 0)
279                      {
280                          if (runOnce &amp;&amp; batchedLines.Count &gt; 2)
281                          {
282                              Trace.Info($&quot;Skip {batchedLines.Count - 2} batches web console lines for last run&quot;);
283                              batchedLines = batchedLines.TakeLast(2).ToList();
284                          }
285                          int errorCount = 0;
286                          foreach (var batch in batchedLines)
287                          {
288                              try
289                              {
290                                  using (var timeoutTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(60)))
291                                  {
292                                      if (_resultsServiceOnly)
293                                      {
294                                          await _resultsServer.AppendLiveConsoleFeedAsync(_scopeIdentifier, _hubName, _planId, _jobTimelineId, _jobTimelineRecordId, stepRecordId, batch.Select(logLine =&gt; logLine.Line).ToList(), batch[0].LineNumber, timeoutTokenSource.Token);
295                                      }
296                                      else
297                                      {
298                                          await _jobServer.AppendTimelineRecordFeedAsync(_scopeIdentifier, _hubName, _planId, _jobTimelineId, _jobTimelineRecordId, stepRecordId, batch.Select(logLine =&gt; logLine.Line).ToList(), batch[0].LineNumber, timeoutTokenSource.Token);
299                                      }
300                                  }
301                                  if (_firstConsoleOutputs)
302                                  {
303                                      HostContext.WritePerfCounter($&quot;WorkerJobServerQueueAppendFirstConsoleOutput_{_planId.ToString()}&quot;);
304                                      _firstConsoleOutputs = false;
305                                  }
306                              }
307                              catch (Exception ex)
308                              {
309                                  Trace.Info(&quot;Catch exception during append web console line, keep going since the process is best effort.&quot;);
310                                  Trace.Error(ex);
311                                  errorCount++;
312                              }
313                          }
314                          Trace.Info(&quot;Try to append {0} batches web console lines for record &#x27;{2}&#x27;, success rate: {1}/{0}.&quot;, batchedLines.Count, batchedLines.Count - errorCount, stepRecordId);
315                      }
316                  }
317                  if (runOnce)
318                  {
319                      break;
320                  }
321                  else
322                  {
323                      await Task.Delay(_webConsoleLineAggressiveDequeue ? _aggressiveDelayForWebConsoleLineDequeue : _delayForWebConsoleLineDequeue);
324                  }
325              }
326          }
327          private async Task ProcessFilesUploadQueueAsync(bool runOnce = false)
328          {
329              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
330              {
331                  List&lt;UploadFileInfo&gt; filesToUpload = new();
332                  UploadFileInfo dequeueFile;
333                  while (_fileUploadQueue.TryDequeue(out dequeueFile))
334                  {
335                      filesToUpload.Add(dequeueFile);
336                      if (!runOnce &amp;&amp; filesToUpload.Count &gt; 10)
337                      {
338                          break;
339                      }
340                  }
341                  if (filesToUpload.Count &gt; 0)
342                  {
343                      if (runOnce)
344                      {
345                          Trace.Info($&quot;Uploading {filesToUpload.Count} files in one shot.&quot;);
346                      }
347                      int errorCount = 0;
348                      foreach (var file in filesToUpload)
349                      {
350                          try
351                          {
352                              await UploadFile(file);
353                          }
354                          catch (Exception ex)
355                          {
356                              Trace.Info(&quot;Catch exception during log or attachment file upload, keep going since the process is best effort.&quot;);
357                              Trace.Error(ex);
358                              errorCount++;
359                          }
360                      }
361                      Trace.Info(&quot;Try to upload {0} log files or attachments, success rate: {1}/{0}.&quot;, filesToUpload.Count, filesToUpload.Count - errorCount);
362                  }
363                  if (runOnce)
364                  {
365                      break;
366                  }
367                  else
368                  {
369                      await Task.Delay(_delayForFileUploadDequeue);
370                  }
371              }
372          }
373          private async Task ProcessResultsUploadQueueAsync(bool runOnce = false)
374          {
375              Trace.Info(&quot;Starting results-based upload queue...&quot;);
376              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
377              {
378                  List&lt;ResultsUploadFileInfo&gt; filesToUpload = new();
379                  ResultsUploadFileInfo dequeueFile;
380                  while (_resultsFileUploadQueue.TryDequeue(out dequeueFile))
381                  {
382                      filesToUpload.Add(dequeueFile);
383                      if (!runOnce &amp;&amp; filesToUpload.Count &gt; 10)
384                      {
385                          break;
386                      }
387                  }
388                  if (filesToUpload.Count &gt; 0)
389                  {
390                      if (runOnce)
391                      {
392                          Trace.Info($&quot;Uploading {filesToUpload.Count} file(s) in one shot through results service.&quot;);
393                      }
394                      int errorCount = 0;
395                      foreach (var file in filesToUpload)
396                      {
397                          try
398                          {
399                              if (String.Equals(file.Type, ChecksAttachmentType.StepSummary, StringComparison.OrdinalIgnoreCase))
400                              {
401                                  await UploadSummaryFile(file);
402                              }
403                              else if (String.Equals(file.Type, CoreAttachmentType.ResultsLog, StringComparison.OrdinalIgnoreCase))
404                              {
405                                  if (file.RecordId != _jobTimelineRecordId)
406                                  {
407                                      Trace.Info($&quot;Got a step log file to send to results service.&quot;);
408                                      await UploadResultsStepLogFile(file);
409                                  }
410                                  else if (file.RecordId == _jobTimelineRecordId)
411                                  {
412                                      Trace.Info($&quot;Got a job log file to send to results service.&quot;);
413                                      await UploadResultsJobLogFile(file);
414                                  }
415                              }
416                          }
417                          catch (Exception ex)
418                          {
419                              Trace.Info(&quot;Catch exception during file upload to results, keep going since the process is best effort.&quot;);
420                              Trace.Error(ex);
421                              errorCount++;
422                              _resultsClientInitiated = false;
423                              SendResultsTelemetry(ex);
424                          }
425                      }
426                      Trace.Info(&quot;Tried to upload {0} file(s) to results, success rate: {1}/{0}.&quot;, filesToUpload.Count, filesToUpload.Count - errorCount);
427                  }
428                  if (runOnce)
429                  {
430                      break;
431                  }
432                  else
433                  {
434                      await Task.Delay(_delayForResultsUploadDequeue);
435                  }
436              }
437          }
438          private void SendResultsTelemetry(Exception ex)
439          {
440              var issue = new Issue() { Type = IssueType.Warning, Message = $&quot;Caught exception with results. {ex.Message}&quot; };
441              issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.ResultsUploadFailure;
442              var telemetryRecord = new TimelineRecord()
443              {
444                  Id = Constants.Runner.TelemetryRecordId,
445              };
446              telemetryRecord.Issues.Add(issue);
447              QueueTimelineRecordUpdate(_jobTimelineId, telemetryRecord);
448          }
449          private async Task ProcessTimelinesUpdateQueueAsync(bool runOnce = false)
450          {
451              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
452              {
453                  List&lt;PendingTimelineRecord&gt; pendingUpdates = new();
454                  foreach (var timeline in _allTimelines)
455                  {
456                      ConcurrentQueue&lt;TimelineRecord&gt; recordQueue;
457                      if (_timelineUpdateQueue.TryGetValue(timeline, out recordQueue))
458                      {
459                          List&lt;TimelineRecord&gt; records = new();
460                          TimelineRecord record;
461                          while (recordQueue.TryDequeue(out record))
462                          {
463                              records.Add(record);
464                              if (!runOnce &amp;&amp; records.Count &gt; 25)
465                              {
466                                  break;
467                              }
468                          }
469                          if (records.Count &gt; 0)
470                          {
471                              pendingUpdates.Add(new PendingTimelineRecord() { TimelineId = timeline, PendingRecords = records.ToList() });
472                          }
473                      }
474                  }
475                  bool pendingSubtimelineUpdate = false;
476                  List&lt;Exception&gt; mainTimelineRecordsUpdateErrors = new();
477                  if (pendingUpdates.Count &gt; 0)
478                  {
479                      foreach (var update in pendingUpdates)
480                      {
<span onclick='openModal()' class='match'>481                          List&lt;TimelineRecord&gt; bufferedRecords;
482                          if (_bufferedRetryRecords.TryGetValue(update.TimelineId, out bufferedRecords))
483                          {
484                              update.PendingRecords.InsertRange(0, bufferedRecords);
</span>485                          }
486                          update.PendingRecords = MergeTimelineRecords(update.PendingRecords);
487                          foreach (var detailTimeline in update.PendingRecords.Where(r =&gt; r.Details != null))
488                          {
489                              if (!_resultsServiceOnly &amp;&amp; !_allTimelines.Contains(detailTimeline.Details.Id))
490                              {
491                                  try
492                                  {
493                                      Timeline newTimeline = await _jobServer.CreateTimelineAsync(_scopeIdentifier, _hubName, _planId, detailTimeline.Details.Id, default(CancellationToken));
494                                      _allTimelines.Add(newTimeline.Id);
495                                      pendingSubtimelineUpdate = true;
496                                  }
497                                  catch (TimelineExistsException)
498                                  {
499                                      Trace.Info(&quot;Catch TimelineExistsException during timeline creation. Ignore the error since server already had this timeline.&quot;);
500                                      _allTimelines.Add(detailTimeline.Details.Id);
501                                  }
502                                  catch (Exception ex)
503                                  {
504                                      Trace.Error(ex);
505                                  }
506                              }
507                          }
508                          try
509                          {
510                              if (!_resultsServiceOnly)
511                              {
512                                  await _jobServer.UpdateTimelineRecordsAsync(_scopeIdentifier, _hubName, _planId, update.TimelineId, update.PendingRecords, default(CancellationToken));
513                              }
514                              try
515                              {
516                                  if (_resultsClientInitiated)
517                                  {
518                                      await _resultsServer.UpdateResultsWorkflowStepsAsync(_scopeIdentifier, _hubName, _planId, update.TimelineId, update.PendingRecords, default(CancellationToken));
519                                  }
520                              }
521                              catch (Exception e)
522                              {
523                                  Trace.Info(&quot;Catch exception during update steps, skip update Results.&quot;);
524                                  Trace.Error(e);
525                                  _resultsClientInitiated = false;
526                                  SendResultsTelemetry(e);
527                              }
528                              if (_bufferedRetryRecords.Remove(update.TimelineId))
529                              {
530                                  Trace.Verbose(&quot;Cleanup buffered timeline record for timeline: {0}.&quot;, update.TimelineId);
531                              }
532                              if (!_jobRecordUpdated.Task.IsCompleted &amp;&amp;
533                                  update.PendingRecords.Any(x =&gt; x.Id == _jobTimelineRecordId &amp;&amp; x.State != null))
534                              {
535                                  Trace.Info(&quot;Job timeline record has been updated for the first time.&quot;);
536                                  _jobRecordUpdated.TrySetResult(0);
537                              }
538                          }
539                          catch (Exception ex)
540                          {
541                              Trace.Info(&quot;Catch exception during update timeline records, try to update these timeline records next time.&quot;);
542                              Trace.Error(ex);
543                              _bufferedRetryRecords[update.TimelineId] = update.PendingRecords.ToList();
544                              if (update.TimelineId == _jobTimelineId)
545                              {
546                                  mainTimelineRecordsUpdateErrors.Add(ex);
547                              }
548                          }
549                      }
550                  }
551                  if (runOnce)
552                  {
553                      if (pendingSubtimelineUpdate)
554                      {
555                          continue;
556                      }
557                      else
558                      {
559                          if (mainTimelineRecordsUpdateErrors.Count &gt; 0 &amp;&amp;
560                              _bufferedRetryRecords.ContainsKey(_jobTimelineId) &amp;&amp;
561                              _bufferedRetryRecords[_jobTimelineId] != null &amp;&amp;
562                              _bufferedRetryRecords[_jobTimelineId].Any(r =&gt; r.Variables.Count &gt; 0))
563                          {
564                              Trace.Info(&quot;Fail to update timeline records with output variables. Throw exception to fail the job since output variables are critical to downstream jobs.&quot;);
565                              throw new AggregateException(&quot;Failed to publish output variables.&quot;, mainTimelineRecordsUpdateErrors);
566                          }
567                          else
568                          {
569                              break;
570                          }
571                      }
572                  }
573                  else
574                  {
575                      await Task.Delay(_delayForTimelineUpdateDequeue);
576                  }
577              }
578          }
579          private List&lt;TimelineRecord&gt; MergeTimelineRecords(List&lt;TimelineRecord&gt; timelineRecords)
580          {
581              if (timelineRecords == null || timelineRecords.Count &lt;= 1)
582              {
583                  return timelineRecords;
584              }
585              Dictionary&lt;Guid, TimelineRecord&gt; dict = new();
586              foreach (TimelineRecord rec in timelineRecords)
587              {
588                  if (rec == null)
589                  {
590                      continue;
591                  }
592                  TimelineRecord timelineRecord;
593                  if (dict.TryGetValue(rec.Id, out timelineRecord))
594                  {
595                      timelineRecord.CurrentOperation = rec.CurrentOperation ?? timelineRecord.CurrentOperation;
596                      timelineRecord.Details = rec.Details ?? timelineRecord.Details;
597                      timelineRecord.FinishTime = rec.FinishTime ?? timelineRecord.FinishTime;
598                      timelineRecord.Log = rec.Log ?? timelineRecord.Log;
599                      timelineRecord.Name = rec.Name ?? timelineRecord.Name;
600                      timelineRecord.RefName = rec.RefName ?? timelineRecord.RefName;
601                      timelineRecord.PercentComplete = rec.PercentComplete ?? timelineRecord.PercentComplete;
602                      timelineRecord.RecordType = rec.RecordType ?? timelineRecord.RecordType;
603                      timelineRecord.Result = rec.Result ?? timelineRecord.Result;
604                      timelineRecord.ResultCode = rec.ResultCode ?? timelineRecord.ResultCode;
605                      timelineRecord.StartTime = rec.StartTime ?? timelineRecord.StartTime;
606                      timelineRecord.State = rec.State ?? timelineRecord.State;
607                      timelineRecord.WorkerName = rec.WorkerName ?? timelineRecord.WorkerName;
608                      if (rec.ErrorCount &gt; 0)
609                      {
610                          timelineRecord.ErrorCount = rec.ErrorCount;
611                      }
612                      if (rec.WarningCount &gt; 0)
613                      {
614                          timelineRecord.WarningCount = rec.WarningCount;
615                      }
616                      if (rec.NoticeCount &gt; 0)
617                      {
618                          timelineRecord.NoticeCount = rec.NoticeCount;
619                      }
620                      if (rec.Issues.Count &gt; 0)
621                      {
622                          timelineRecord.Issues.Clear();
623                          timelineRecord.Issues.AddRange(rec.Issues.Select(i =&gt; i.Clone()));
624                      }
625                      if (rec.Variables.Count &gt; 0)
626                      {
627                          foreach (var variable in rec.Variables)
628                          {
629                              timelineRecord.Variables[variable.Key] = variable.Value.Clone();
630                          }
631                      }
632                  }
633                  else
634                  {
635                      dict.Add(rec.Id, rec);
636                  }
637              }
638              var mergedRecords = dict.Values.ToList();
639              Trace.Verbose(&quot;Merged Timeline records&quot;);
640              foreach (var record in mergedRecords)
641              {
642                  Trace.Verbose($&quot;    Record: t={record.RecordType}, n={record.Name}, s={record.State}, st={record.StartTime}, {record.PercentComplete}%, ft={record.FinishTime}, r={record.Result}: {record.CurrentOperation}&quot;);
643                  if (record.Issues != null)
644                  {
645                      foreach (var issue in record.Issues)
646                      {
647                          String source;
648                          issue.Data.TryGetValue(&quot;sourcepath&quot;, out source);
649                          Trace.Verbose($&quot;        Issue: c={issue.Category}, t={issue.Type}, s={source ?? string.Empty}, m={issue.Message}&quot;);
650                      }
651                  }
652                  if (record.Variables != null)
653                  {
654                      foreach (var variable in record.Variables)
655                      {
656                          Trace.Verbose($&quot;        Variable: n={variable.Key}, secret={variable.Value.IsSecret}&quot;);
657                      }
658                  }
659              }
660              return mergedRecords;
661          }
662          private async Task UploadFile(UploadFileInfo file)
663          {
664              bool uploadSucceed = false;
665              try
666              {
667                  if (!_resultsServiceOnly)
668                  {
669                      if (String.Equals(file.Type, CoreAttachmentType.Log, StringComparison.OrdinalIgnoreCase))
670                      {
671                          var taskLog = await _jobServer.CreateLogAsync(_scopeIdentifier, _hubName, _planId, new TaskLog(String.Format(@&quot;logs\{0:D}&quot;, file.TimelineRecordId)), default(CancellationToken));
672                          using (FileStream fs = File.Open(file.Path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
673                          {
674                              var logUploaded = await _jobServer.AppendLogContentAsync(_scopeIdentifier, _hubName, _planId, taskLog.Id, fs, default(CancellationToken));
675                          }
676                          var attachmentUpdataRecord = new TimelineRecord() { Id = file.TimelineRecordId, Log = taskLog };
677                          QueueTimelineRecordUpdate(file.TimelineId, attachmentUpdataRecord);
678                      }
679                      else
680                      {
681                          using (FileStream fs = File.Open(file.Path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
682                          {
683                              var result = await _jobServer.CreateAttachmentAsync(_scopeIdentifier, _hubName, _planId, file.TimelineId, file.TimelineRecordId, file.Type, file.Name, fs, default(CancellationToken));
684                          }
685                      }
686                  }
687                  uploadSucceed = true;
688              }
689              finally
690              {
691                  if (uploadSucceed &amp;&amp; file.DeleteSource)
692                  {
693                      try
694                      {
695                          File.Delete(file.Path);
696                      }
697                      catch (Exception ex)
698                      {
699                          Trace.Info(&quot;Catch exception during delete success uploaded file.&quot;);
700                          Trace.Error(ex);
701                      }
702                  }
703              }
704          }
705          private async Task UploadSummaryFile(ResultsUploadFileInfo file)
706          {
707              Trace.Info($&quot;Starting to upload summary file to results service {file.Name}, {file.Path}&quot;);
708              ResultsFileUploadHandler summaryHandler = async (file) =&gt;
709              {
710                  await _resultsServer.CreateResultsStepSummaryAsync(file.PlanId, file.JobId, file.RecordId, file.Path, CancellationToken.None);
711              };
712              await UploadResultsFile(file, summaryHandler);
713          }
714          private async Task UploadResultsStepLogFile(ResultsUploadFileInfo file)
715          {
716              Trace.Info($&quot;Starting upload of step log file to results service {file.Name}, {file.Path}&quot;);
717              ResultsFileUploadHandler stepLogHandler = async (file) =&gt;
718              {
719                  await _resultsServer.CreateResultsStepLogAsync(file.PlanId, file.JobId, file.RecordId, file.Path, file.Finalize, file.FirstBlock, file.TotalLines, CancellationToken.None);
720              };
721              await UploadResultsFile(file, stepLogHandler);
722          }
723          private async Task UploadResultsJobLogFile(ResultsUploadFileInfo file)
724          {
725              Trace.Info($&quot;Starting upload of job log file to results service {file.Name}, {file.Path}&quot;);
726              ResultsFileUploadHandler jobLogHandler = async (file) =&gt;
727              {
728                  await _resultsServer.CreateResultsJobLogAsync(file.PlanId, file.JobId, file.Path, file.Finalize, file.FirstBlock, file.TotalLines, CancellationToken.None);
729              };
730              await UploadResultsFile(file, jobLogHandler);
731          }
732          private async Task UploadResultsFile(ResultsUploadFileInfo file, ResultsFileUploadHandler uploadHandler)
733          {
734              if (!_resultsClientInitiated)
735              {
736                  return;
737              }
738              bool uploadSucceed = false;
739              try
740              {
741                  await uploadHandler(file);
742                  uploadSucceed = true;
743              }
744              finally
745              {
746                  if (uploadSucceed &amp;&amp; file.DeleteSource)
747                  {
748                      try
749                      {
750                          File.Delete(file.Path);
751                      }
752                      catch (Exception ex)
753                      {
754                          Trace.Info(&quot;Exception encountered during deletion of a temporary file that was already successfully uploaded to results.&quot;);
755                          Trace.Error(ex);
756                      }
757                  }
758              }
759          }
760      }
761      internal class PendingTimelineRecord
762      {
763          public Guid TimelineId { get; set; }
764          public List&lt;TimelineRecord&gt; PendingRecords { get; set; }
765      }
766      internal class UploadFileInfo
767      {
768          public Guid TimelineId { get; set; }
769          public Guid TimelineRecordId { get; set; }
770          public string Type { get; set; }
771          public string Name { get; set; }
772          public string Path { get; set; }
773          public bool DeleteSource { get; set; }
774      }
775      internal class ResultsUploadFileInfo
776      {
777          public string Name { get; set; }
778          public string Type { get; set; }
779          public string Path { get; set; }
780          public string PlanId { get; set; }
781          public string JobId { get; set; }
782          public Guid RecordId { get; set; }
783          public bool DeleteSource { get; set; }
784          public bool Finalize { get; set; }
785          public bool FirstBlock { get; set; }
786          public long TotalLines { get; set; }
787      }
788      internal class ConsoleLineInfo
789      {
790          public ConsoleLineInfo(Guid recordId, string line, long? lineNumber)
791          {
792              this.StepRecordId = recordId;
793              this.Line = line;
794              this.LineNumber = lineNumber;
795          }
796          public Guid StepRecordId { get; set; }
797          public string Line { get; set; }
798          public long? LineNumber { get; set; }
799      }
800  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssResponseContext.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobServerQueue.cs</div>
                </div>
                <div class="column column_space"><pre><code>23              IEnumerable&lt;String&gt; headerValues;
24              if (headers.TryGetValues(PerformanceTimerConstants.Header, out headerValues))
25              {
26                  Timings = JsonConvert.DeserializeObject&lt;IDictionary&lt;String, PerformanceTimingGroup&gt;&gt;(headerValues.First());
</pre></code></div>
                <div class="column column_space"><pre><code>481                          List&lt;TimelineRecord&gt; bufferedRecords;
482                          if (_bufferedRetryRecords.TryGetValue(update.TimelineId, out bufferedRecords))
483                          {
484                              update.PendingRecords.InsertRange(0, bufferedRecords);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    