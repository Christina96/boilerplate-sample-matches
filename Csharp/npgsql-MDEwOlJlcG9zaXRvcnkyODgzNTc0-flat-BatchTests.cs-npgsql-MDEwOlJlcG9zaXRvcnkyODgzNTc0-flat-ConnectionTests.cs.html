
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</h3>
            <pre><code>1  using Npgsql.Util;
2  using NUnit.Framework;
3  using System;
4  using System.Collections.Generic;
5  using System.Data;
6  using System.Linq;
7  using System.Threading.Tasks;
8  using static Npgsql.Tests.TestUtil;
9  namespace Npgsql.Tests;
10  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.Default)]
11  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.Default)]
12  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.SequentialAccess)]
13  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.SequentialAccess)]
14  public class BatchTests : MultiplexingTestBase
15  {
16      #region Parameters
17      [Test]
18      public async Task Named_parameters()
19      {
20          await using var conn = await OpenConnectionAsync();
21          await using var batch = new NpgsqlBatch(conn)
22          {
23              BatchCommands =
24              {
25                  new("SELECT @p") { Parameters = { new("p", 8) } },
26                  new("SELECT @p1, @p2") { Parameters = { new("p1", 9), new("p2", 10) } }
27              }
28          };
29          await using var reader = await batch.ExecuteReaderAsync(Behavior);
30          Assert.That(await reader.ReadAsync(), Is.True);
31          Assert.That(reader.FieldCount, Is.EqualTo(1));
32          Assert.That(reader[0], Is.EqualTo(8));
33          Assert.That(await reader.ReadAsync(), Is.False);
34          Assert.That(await reader.NextResultAsync(), Is.True);
35          Assert.That(reader.FieldCount, Is.EqualTo(2));
36          Assert.That(await reader.ReadAsync(), Is.True);
37          Assert.That(reader[0], Is.EqualTo(9));
38          Assert.That(reader[1], Is.EqualTo(10));
39          Assert.That(await reader.ReadAsync(), Is.False);
40          Assert.That(await reader.NextResultAsync(), Is.False);
41      }
42      [Test]
43      public async Task Positional_parameters()
44      {
45          await using var conn = await OpenConnectionAsync();
46          await using var batch = new NpgsqlBatch(conn)
47          {
48              BatchCommands =
49              {
50                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
51                  new("SELECT $1, $2") { Parameters = { new() { Value = 9 }, new() { Value = 10 } } }
52              }
53          };
54          await using var reader = await batch.ExecuteReaderAsync(Behavior);
55          Assert.That(await reader.ReadAsync(), Is.True);
56          Assert.That(reader.FieldCount, Is.EqualTo(1));
57          Assert.That(reader[0], Is.EqualTo(8));
58          Assert.That(await reader.ReadAsync(), Is.False);
59          Assert.That(await reader.NextResultAsync(), Is.True);
60          Assert.That(await reader.ReadAsync(), Is.True);
61          Assert.That(reader.FieldCount, Is.EqualTo(2));
62          Assert.That(reader[0], Is.EqualTo(9));
63          Assert.That(reader[1], Is.EqualTo(10));
64          Assert.That(await reader.ReadAsync(), Is.False);
65          Assert.That(await reader.NextResultAsync(), Is.False);
66      }
67      [Test]
68      public async Task Out_parameters_are_not_allowed()
69      {
70          await using var conn = await OpenConnectionAsync();
71          await using var batch = new NpgsqlBatch(conn)
72          {
73              BatchCommands =
74              {
75                  new("SELECT @p1")
76                  {
77                      Parameters = { new("p", 8) { Direction = ParameterDirection.InputOutput } }
78                  }
79              }
80          };
81          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
82      }
83      #endregion Parameters
84      #region NpgsqlBatchCommand
85      [Test]
86      public async Task RecordsAffected_and_Rows()
87      {
88          await using var conn = await OpenConnectionAsync();
89          var table = await CreateTempTable(conn, "name TEXT");
90          await using var batch = new NpgsqlBatch(conn)
91          {
92              BatchCommands =
93              {
94                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
95                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
96                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
97                  new($"SELECT name FROM {table}"),
98                  new($"DELETE FROM {table}")
99              }
100          };
101          await using var reader = await batch.ExecuteReaderAsync(Behavior);
102          await reader.CloseAsync();
103          var command = batch.BatchCommands[0];
104          Assert.That(command.RecordsAffected, Is.EqualTo(2));
105          Assert.That(command.Rows, Is.EqualTo(2));
106          command = batch.BatchCommands[1];
107          Assert.That(command.RecordsAffected, Is.EqualTo(1));
108          Assert.That(command.Rows, Is.EqualTo(1));
109          command = batch.BatchCommands[2];
110          Assert.That(command.RecordsAffected, Is.EqualTo(0));
111          Assert.That(command.Rows, Is.EqualTo(0));
112          command = batch.BatchCommands[3];
113          Assert.That(command.RecordsAffected, Is.EqualTo(-1));
114          Assert.That(command.Rows, Is.EqualTo(2));
115          command = batch.BatchCommands[4];
116          Assert.That(command.RecordsAffected, Is.EqualTo(2));
117          Assert.That(command.Rows, Is.EqualTo(2));
118      }
119      [Test]
120      public async Task Merge_RecordsAffected_and_Rows()
121      {
122          await using var conn = await OpenConnectionAsync();
123          MinimumPgVersion(conn, "15.0", "MERGE statement was introduced in PostgreSQL 15");
124          var table = await CreateTempTable(conn, "name TEXT");
125          await using var batch = new NpgsqlBatch(conn)
126          {
127              BatchCommands =
128              {
129                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
130                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN UPDATE SET name = 'c'"),
131                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN INSERT (name) VALUES ('b')"),
132                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN DELETE"),
133                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING")
134              }
135          };
136          await using var reader = await batch.ExecuteReaderAsync(Behavior);
137          await reader.CloseAsync();
138          var command = batch.BatchCommands[0];
139          Assert.That(command.StatementType, Is.EqualTo(StatementType.Insert));
140          Assert.That(command.RecordsAffected, Is.EqualTo(2));
141          Assert.That(command.Rows, Is.EqualTo(2));
142          command = batch.BatchCommands[1];
143          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
144          Assert.That(command.RecordsAffected, Is.EqualTo(1));
145          Assert.That(command.Rows, Is.EqualTo(1));
146          command = batch.BatchCommands[2];
147          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
148          Assert.That(command.RecordsAffected, Is.EqualTo(1));
149          Assert.That(command.Rows, Is.EqualTo(1));
150          command = batch.BatchCommands[3];
151          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
152          Assert.That(command.RecordsAffected, Is.EqualTo(1));
153          Assert.That(command.Rows, Is.EqualTo(1));
154          command = batch.BatchCommands[4];
155          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
156          Assert.That(command.RecordsAffected, Is.EqualTo(0));
157          Assert.That(command.Rows, Is.EqualTo(0));
158      }
159      [Test]
160      public async Task StatementTypes()
161      {
162          await using var conn = await OpenConnectionAsync();
163          var table = await CreateTempTable(conn, "name TEXT");
164          await using var batch = new NpgsqlBatch(conn)
165          {
166              BatchCommands =
167              {
168                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
169                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
170                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
171                  new("BEGIN"),
172                  new($"SELECT name FROM {table}"),
173                  new($"DELETE FROM {table}"),
174                  new("COMMIT")
175              }
176          };
177          await using var reader = await batch.ExecuteReaderAsync(Behavior);
178          await reader.CloseAsync();
179          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Insert));
180          Assert.That(batch.BatchCommands[1].StatementType, Is.EqualTo(StatementType.Update));
181          Assert.That(batch.BatchCommands[2].StatementType, Is.EqualTo(StatementType.Update));
182          Assert.That(batch.BatchCommands[3].StatementType, Is.EqualTo(StatementType.Other));
183          Assert.That(batch.BatchCommands[4].StatementType, Is.EqualTo(StatementType.Select));
184          Assert.That(batch.BatchCommands[5].StatementType, Is.EqualTo(StatementType.Delete));
185          Assert.That(batch.BatchCommands[6].StatementType, Is.EqualTo(StatementType.Other));
186      }
187      [Test]
188      public async Task StatementType_Call()
189      {
190          await using var conn = await OpenConnectionAsync();
191          MinimumPgVersion(conn, "11.0", "Stored procedures are supported starting with PG 11");
192          var sproc = await GetTempProcedureName(conn);
193          await conn.ExecuteNonQueryAsync($"CREATE PROCEDURE {sproc}() LANGUAGE sql AS ''");
194          await using var batch = new NpgsqlBatch(conn)
195          {
196              BatchCommands = { new($"CALL {sproc}()") }
197          };
198          await using var reader = await batch.ExecuteReaderAsync(Behavior);
199          await reader.CloseAsync();
200          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Call));
201      }
202      [Test]
203      public async Task StatementType_Merge()
204      {
205          await using var conn = await OpenConnectionAsync();
206          MinimumPgVersion(conn, "15.0", "Stored procedures are supported starting with PG 11");
207          var table = await CreateTempTable(conn, "name TEXT");
208          await using var batch = new NpgsqlBatch(conn)
209          {
210              BatchCommands = { new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING") }
211          };
212          await using var reader = await batch.ExecuteReaderAsync(Behavior);
213          await reader.CloseAsync();
214          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Merge));
215      }
216      [Test]
217      public async Task StatementOID()
218      {
219          using var conn = await OpenConnectionAsync();
220          MaximumPgVersionExclusive(conn, "12.0",
221              "Support for 'CREATE TABLE ... WITH OIDS' has been removed in 12.0. See https:&bsol;&bsol;www.postgresql.org/docs/12/release-12.html#id-1.11.6.5.4");
222          var table = await GetTempTableName(conn);
223          await conn.ExecuteNonQueryAsync($"CREATE TABLE {table} (name TEXT) WITH OIDS");
224          await using var batch = new NpgsqlBatch(conn)
225          {
226              BatchCommands =
227              {
228                  new($"INSERT INTO {table} (name) VALUES (@p1)") { Parameters = { new("p1", "foo") } },
229                  new($"UPDATE {table} SET name='b' WHERE name=@p2") { Parameters = { new("p2", "bar") } }
230              }
231          };
232          await batch.ExecuteNonQueryAsync();
233          Assert.That(batch.BatchCommands[0].OID, Is.Not.EqualTo(0));
234          Assert.That(batch.BatchCommands[1].OID, Is.EqualTo(0));
235      }
236      #endregion NpgsqlBatchCommand
237      #region Command behaviors
238      [Test]
239      public async Task SingleResult()
240      {
241          await using var conn = await OpenConnectionAsync();
242          await using var batch = new NpgsqlBatch(conn)
243          {
244              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
245          };
246          var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleResult | Behavior);
247          Assert.That(reader.Read(), Is.True);
248          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
249          Assert.That(reader.NextResult(), Is.False);
250      }
251      [Test]
252      public async Task SingleRow()
253      {
254          await using var conn = await OpenConnectionAsync();
255          await using var batch = new NpgsqlBatch(conn)
256          {
257              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
258          };
259          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleRow | Behavior);
260          Assert.That(reader.Read(), Is.True);
261          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
262          Assert.That(reader.Read(), Is.False);
263          Assert.That(reader.NextResult(), Is.False);
264      }
265      [Test]
266      public async Task SchemaOnly_GetFieldType()
267      {
268          await using var conn = await OpenConnectionAsync();
269          await using var batch = new NpgsqlBatch(conn)
270          {
271              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
272          };
273          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
274          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
275          Assert.That(await reader.NextResultAsync(), Is.True);
276          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(string)));
277          Assert.That(await reader.NextResultAsync(), Is.False);
278      }
279      [Test]
280      public async Task SchemaOnly_returns_no_data()
281      {
282          await using var conn = await OpenConnectionAsync();
283          await using var batch = new NpgsqlBatch(conn)
284          {
285              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
286          };
287          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
288          Assert.That(reader.Read(), Is.False);
289          Assert.That(await reader.NextResultAsync(), Is.True);
290          Assert.That(reader.Read(), Is.False);
291          Assert.That(await reader.NextResultAsync(), Is.False);
292      }
293      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/693")]
294      public async Task CloseConnection()
295      {
296          await using var conn = await OpenConnectionAsync();
297          await using var batch = new NpgsqlBatch(conn)
298          {
299              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
300          };
301          await using (var reader = await batch.ExecuteReaderAsync(CommandBehavior.CloseConnection | Behavior))
302              while (reader.Read()) {}
303          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
304      }
305      #endregion Command behaviors
306      #region Error barriers
307      [Test]
308      public async Task Batch_with_error_at_start([Values] bool withErrorBarriers)
309      {
310          await using var conn = await OpenConnectionAsync();
311          var table = await CreateTempTable(conn, "id INT");
312          await using var batch = new NpgsqlBatch(conn)
313          {
314              BatchCommands =
315              {
316                  new("INVALID SQL"),
317                  new($"INSERT INTO {table} (id) VALUES (8)")
318              },
319              EnableErrorBarriers = withErrorBarriers
320          };
321          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
322          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
323          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
324              ? Is.EqualTo(1)
325              : Is.EqualTo(0));
326      }
327      [Test]
328      public async Task Batch_with_error_at_end([Values] bool withErrorBarriers)
329      {
330          await using var conn = await OpenConnectionAsync();
331          var table = await CreateTempTable(conn, "id INT");
332          await using var batch = new NpgsqlBatch(conn)
333          {
334              BatchCommands =
335              {
336                  new($"INSERT INTO {table} (id) VALUES (8)"),
337                  new("INVALID SQL")
338              },
339              EnableErrorBarriers = withErrorBarriers
340          };
341          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
342          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
343          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
344              ? Is.EqualTo(1)
345              : Is.EqualTo(0));
346      }
347      [Test]
348      public async Task Batch_with_multiple_errors([Values] bool withErrorBarriers)
349      {
350          await using var conn = await OpenConnectionAsync();
351          var table = await CreateTempTable(conn, "id INT");
352          await using var batch = new NpgsqlBatch(conn)
353          {
354              BatchCommands =
355              {
356                  new($"INSERT INTO {table} (id) VALUES (8)"),
357                  new("INVALID SQL"),
358                  new($"INSERT INTO {table} (id) VALUES (9)"),
359                  new("INVALID SQL"),
360                  new($"INSERT INTO {table} (id) VALUES (10)")
361              },
362              EnableErrorBarriers = withErrorBarriers
363          };
364          if (withErrorBarriers)
365          {
366              var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
367              var aggregateException = (AggregateException)exception.InnerException!;
368              Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[1]));
369              Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[3]));
370              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(3));
371          }
372          else
373          {
374              var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
375              Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
376              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(0));
377          }
378          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
379      }
380      [Test]
381      public async Task Batch_close_dispose_reader_with_multiple_errors([Values] bool withErrorBarriers, [Values] bool dispose)
382      {
383          await using var dataSource = CreateDataSource();
384          await using var conn = await dataSource.OpenConnectionAsync();
385          var table = await CreateTempTable(conn, "id INT");
386          await using var batch = new NpgsqlBatch(conn)
387          {
388              BatchCommands =
389              {
390                  new("SELECT NULL WHERE 1=0"),
391                  new($"INSERT INTO {table} (id) VALUES (8)"),
392                  new("INVALID SQL"),
393                  new($"INSERT INTO {table} (id) VALUES (9)"),
394                  new("INVALID SQL"),
395                  new($"INSERT INTO {table} (id) VALUES (10)")
396              },
397              EnableErrorBarriers = withErrorBarriers
398          };
399          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
400          {
401              if (withErrorBarriers)
402              {
403                  var exception = Assert.ThrowsAsync<NpgsqlException>(async () =>
404                  {
405                      if (dispose)
406                          await reader.DisposeAsync();
407                      else
408                          await reader.CloseAsync();
409                  })!;
410                  var aggregateException = (AggregateException)exception.InnerException!;
411                  Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[2]));
412                  Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[4]));
413              }
414              else
415              {
416                  var exception = Assert.ThrowsAsync<PostgresException>(async () =>
417                  {
418                      if (dispose)
419                          await reader.DisposeAsync();
420                      else
421                          await reader.CloseAsync();
422                  })!;
423                  Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[2]));
424              }
425              Assert.That(reader.State, Is.EqualTo(dispose ? ReaderState.Disposed : ReaderState.Closed));
426          }
427          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
428      }
429      [Test]
430      public async Task Batch_with_result_sets_and_error([Values] bool withErrorBarriers)
431      {
432          await using var conn = await OpenConnectionAsync();
433          var table = await CreateTempTable(conn, "id INT");
434          await using var batch = new NpgsqlBatch(conn)
435          {
436              BatchCommands =
437              {
438                  new($"INSERT INTO {table} (id) VALUES (9)"),
439                  new("SELECT 1"),
440                  new("INVALID SQL"),
441                  new($"INSERT INTO {table} (id) VALUES (9)"),
442                  new("SELECT 2")
443              },
444              EnableErrorBarriers = withErrorBarriers
445          };
446          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
447          {
448              Assert.That(await reader.ReadAsync(), Is.True);
449              Assert.That(reader[0], Is.EqualTo(1));
450              Assert.That(await reader.ReadAsync(), Is.False);
451              Assert.That(async () => await reader.NextResultAsync(), Throws.Exception.TypeOf<PostgresException>());
452              Assert.That(reader.State, Is.EqualTo(ReaderState.Consumed));
453              Assert.That(await reader.ReadAsync(), Is.False);
454              Assert.That(await reader.NextResultAsync(), Is.False);
455          }
456          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
457              ? Is.EqualTo(2)
458              : Is.EqualTo(0));
459      }
460      [Test]
461      public async Task Error_with_AppendErrorBarrier()
462      {
463          await using var conn = await OpenConnectionAsync();
464          var table = await CreateTempTable(conn, "id INT");
465          await using var batch = new NpgsqlBatch(conn)
466          {
467              BatchCommands =
468              {
469                  new($"INSERT INTO {table} (id) VALUES (8)"),
470                  new("INVALID SQL") { AppendErrorBarrier = true },
471                  new($"INSERT INTO {table} (id) VALUES (9)")
472              }
473          };
474          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
475          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
476          Assert.That(await conn.ExecuteScalarAsync($"SELECT id FROM {table} ORDER BY id"), Is.EqualTo(9));
477      }
478      [Test]
479      public async Task AppendErrorBarrier_on_last_command([Values] bool enabled)
480      {
481          await using var conn = await OpenConnectionAsync();
482          var table = await CreateTempTable(conn, "id INT");
483          await using var batch = new NpgsqlBatch(conn)
484          {
485              BatchCommands =
486              {
487                  new($"INSERT INTO {table} (id) VALUES (8)"),
488                  new($"INSERT INTO {table} (id) VALUES (9)") { AppendErrorBarrier = enabled }
489              },
490              EnableErrorBarriers = true
491          };
492          Assert.That(await batch.ExecuteNonQueryAsync(), Is.EqualTo(2));
493      }
494      [Test]
495      public async Task Error_barriers_with_SchemaOnly()
496      {
497          await using var conn = await OpenConnectionAsync();
498          await using var batch = new NpgsqlBatch(conn)
499          {
500              BatchCommands =
501              {
502                  new("SELECT 1"),
503                  new("SELECT 'foo'")
504              },
505              EnableErrorBarriers = true
506          };
507          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
508          var columnSchema = await reader.GetColumnSchemaAsync();
509          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(int)));
510          Assert.That(await reader.NextResultAsync(), Is.True);
511          columnSchema = await reader.GetColumnSchemaAsync();
512          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(string)));
513      }
514      #endregion Error barriers
515      #region Miscellaneous
516      [Test]
517      public async Task Single_batch_command()
518      {
519          await using var conn = await OpenConnectionAsync();
520          await using var batch = new NpgsqlBatch(conn)
521          {
522              BatchCommands = { new("SELECT 8") }
523          };
524          await using var reader = await batch.ExecuteReaderAsync(Behavior);
525          Assert.That(await reader.ReadAsync(), Is.True);
526          Assert.That(reader.FieldCount, Is.EqualTo(1));
527          Assert.That(reader[0], Is.EqualTo(8));
528          Assert.That(await reader.ReadAsync(), Is.False);
529          Assert.That(await reader.NextResultAsync(), Is.False);
530      }
531      [Test]
532      public async Task Empty_batch()
533      {
534          await using var conn = await OpenConnectionAsync();
535          await using var batch = new NpgsqlBatch(conn);
536          await using var reader = await batch.ExecuteReaderAsync(Behavior);
537          Assert.That(await reader.ReadAsync(), Is.False);
538          Assert.That(await reader.NextResultAsync(), Is.False);
539      }
540      [Test]
541      public async Task Semicolon_is_not_allowed()
542      {
543          await using var conn = await OpenConnectionAsync();
544          await using var batch = new NpgsqlBatch(conn)
545          {
546              BatchCommands = { new("SELECT 1; SELECT 2") }
547          };
548          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
549      }
550      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
551      public async Task NpgsqlException_references_BatchCommand_with_single_command()
552      {
553          await using var conn = await OpenConnectionAsync();
554          var function = await GetTempFunctionName(conn);
555          await conn.ExecuteNonQueryAsync($@"
556  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
557     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
558  LANGUAGE 'plpgsql'");
559          var batch = conn.CreateBatch();
560          batch.BatchCommands.Add(new($"SELECT {function}()"));
561          var e = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
562          Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
563          batch.Dispose();
564          var cmd2 = conn.CreateBatch();
565          Assert.AreNotSame(cmd2, batch);
566      }
567      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
568      public async Task NpgsqlException_references_BatchCommand_with_multiple_commands()
569      {
570          await using var conn = await OpenConnectionAsync();
571          var function = await GetTempFunctionName(conn);
572          await conn.ExecuteNonQueryAsync($@"
573  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
574     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
575  LANGUAGE 'plpgsql'");
576          var batch = conn.CreateBatch();
577          batch.BatchCommands.Add(new("SELECT 1"));
578          batch.BatchCommands.Add(new($"SELECT {function}()"));
579          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
580          {
581              var e = Assert.ThrowsAsync<PostgresException>(async () => await reader.NextResultAsync())!;
582              Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
583          }
584          batch.Dispose();
585          var cmd2 = conn.CreateBatch();
586          Assert.AreNotSame(cmd2, batch);
587      }
588      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4202")]
589      public async Task ExecuteScalar_without_parameters()
590      {
591          await using var conn = await OpenConnectionAsync();
592          var batch = new NpgsqlBatch(conn) { BatchCommands = { new("SELECT 1") } };
593          Assert.That(await batch.ExecuteScalarAsync(), Is.EqualTo(1));
594      }
595      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4264")]
596      public async Task Batch_with_auto_prepare_reuse()
597      {
598          await using var dataSource = CreateDataSource(csb => csb.MaxAutoPrepare = 20);
599          await using var conn = await dataSource.OpenConnectionAsync();
600          var tempTableName = await CreateTempTable(conn, "id int");
601          await using var batch = new NpgsqlBatch(conn);
602          for (var i = 0; i < 2; ++i)
603          {
604              for (var j = 0; j < 10; ++j)
605              {
606                  batch.BatchCommands.Add(new NpgsqlBatchCommand($"DELETE FROM {tempTableName} WHERE 1=0"));
607              }
608              await batch.ExecuteNonQueryAsync();
609              batch.BatchCommands.Clear();
610          }
611      }
612      #endregion Miscellaneous
613      #region Logging
614      [Test]
615      public async Task Log_ExecuteScalar_single_statement_without_parameters()
616      {
617          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
618          await using var conn = await dataSource.OpenConnectionAsync();
619          await using var cmd = new NpgsqlBatch(conn)
620          {
621              BatchCommands = { new("SELECT 1") }
622          };
623          using (listLoggerProvider.Record())
624          {
625              await cmd.ExecuteScalarAsync();
626          }
627          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
628          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains("SELECT 1"));
629          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT 1");
630          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
631          if (!IsMultiplexing)
632              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
633      }
634      [Test]
635      public async Task Log_ExecuteScalar_multiple_statements_with_parameters()
636      {
637          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using var batch = new NpgsqlBatch(conn)
640          {
641              BatchCommands =
642              {
643                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
644                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
645              }
646          };
647          using (listLoggerProvider.Record())
648          {
649              await batch.ExecuteScalarAsync();
650          }
651          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
652          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[(SELECT $1, System.Object[]), (SELECT $1, 9, System.Object[])]"));
653          AssertLoggingStateDoesNotContain(executingCommandEvent, "CommandText");
654          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
655          if (!IsMultiplexing)
656              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
657          var batchCommands = (IList<(string CommandText, object[] Parameters)>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
658          Assert.That(batchCommands.Count, Is.EqualTo(2));
659          Assert.That(batchCommands[0].CommandText, Is.EqualTo("SELECT $1"));
660          Assert.That(batchCommands[0].Parameters[0], Is.EqualTo(8));
661          Assert.That(batchCommands[1].CommandText, Is.EqualTo("SELECT $1, 9"));
662          Assert.That(batchCommands[1].Parameters[0], Is.EqualTo(9));
663      }
664      [Test]
665      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
666      {
667          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
668          await using var conn = await dataSource.OpenConnectionAsync();
669          await using var batch = new NpgsqlBatch(conn)
670          {
671              BatchCommands =
672              {
673                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
674                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
675              }
676          };
<span onclick='openModal()' class='match'>677          using (listLoggerProvider.Record())
678          {
679              await batch.ExecuteScalarAsync();
680          }
</span>681          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
682          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[SELECT $1, SELECT $1, 9]"));
683          var batchCommands = (IList<string>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
684          Assert.That(batchCommands.Count, Is.EqualTo(2));
685          Assert.That(batchCommands[0], Is.EqualTo("SELECT $1"));
686          Assert.That(batchCommands[1], Is.EqualTo("SELECT $1, 9"));
687      }
688      #endregion Logging
689      #region Initialization / setup / teardown
690      readonly bool IsSequential;
691      readonly CommandBehavior Behavior;
692      public BatchTests(MultiplexingMode multiplexingMode, CommandBehavior behavior) : base(multiplexingMode)
693      {
694          Behavior = behavior;
695          IsSequential = (Behavior & CommandBehavior.SequentialAccess) != 0;
696      }
697      #endregion
698  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Data;
4  using System.Diagnostics;
5  using System.IO;
6  using System.Linq;
7  using System.Net;
8  using System.Net.Security;
9  using System.Runtime.InteropServices;
10  using System.Security.Cryptography.X509Certificates;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using Npgsql.Internal;
15  using Npgsql.PostgresTypes;
16  using Npgsql.Properties;
17  using Npgsql.Util;
18  using NpgsqlTypes;
19  using NUnit.Framework;
20  using static Npgsql.Tests.TestUtil;
21  namespace Npgsql.Tests;
22  public class ConnectionTests : MultiplexingTestBase
23  {
24      [Test, Description("Makes sure the connection goes through the proper state lifecycle")]
25      public async Task Basic_lifecycle()
26      {
27          await using var conn = CreateConnection();
28          var eventOpen = false;
29          var eventClosed = false;
30          conn.StateChange += (s, e) =>
31          {
32              if (e.OriginalState == ConnectionState.Closed &&
33                  e.CurrentState == ConnectionState.Open)
34                  eventOpen = true;
35              if (e.OriginalState == ConnectionState.Open &&
36                  e.CurrentState == ConnectionState.Closed)
37                  eventClosed = true;
38          };
39          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
40          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
41          await conn.OpenAsync();
42          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
43          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
44          Assert.That(eventOpen, Is.True);
45          await using (var cmd = new NpgsqlCommand("SELECT 1", conn))
46          await using (var reader = await cmd.ExecuteReaderAsync())
47          {
48              await reader.ReadAsync();
49              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
50              Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
51          }
52          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
53          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
54          await conn.CloseAsync();
55          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
56          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
57          Assert.That(eventClosed, Is.True);
58      }
59      [Test, Description("Makes sure the connection goes through the proper state lifecycle")]
60      public async Task Broken_lifecycle([Values] bool openFromClose)
61      {
62          if (IsMultiplexing)
63              return;
64          await using var dataSource = CreateDataSource();
65          await using var conn = dataSource.CreateConnection();
66          var eventOpen = false;
67          var eventClosed = false;
68          conn.StateChange += (s, e) =>
69          {
70              if (e.OriginalState == ConnectionState.Closed &&
71                  e.CurrentState == ConnectionState.Open)
72                  eventOpen = true;
73              if (e.OriginalState == ConnectionState.Open &&
74                  e.CurrentState == ConnectionState.Closed)
75                  eventClosed = true;
76          };
77          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
78          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
79          await conn.OpenAsync();
80          await using var transaction = await conn.BeginTransactionAsync();
81          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
82          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
83          Assert.That(eventOpen, Is.True);
84          var sleep = conn.ExecuteNonQueryAsync("SELECT pg_sleep(5)");
85          await Task.Delay(1000);
86          await using (var killingConn = await OpenConnectionAsync())
87              killingConn.ExecuteNonQuery($"SELECT pg_terminate_backend({conn.ProcessID})");
88          Assert.ThrowsAsync<PostgresException>(() => sleep);
89          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
90          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
91          Assert.That(eventClosed, Is.True);
92          Assert.That(conn.Connector is null);
93          Assert.AreEqual(0, conn.NpgsqlDataSource.Statistics.Total);
94          if (openFromClose)
95          {
96              await conn.CloseAsync();
97              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
98              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
99              Assert.That(eventClosed, Is.True);
100          }
101          Assert.DoesNotThrowAsync(conn.OpenAsync);
102          Assert.AreEqual(1, await conn.ExecuteScalarAsync("SELECT 1"));
103          Assert.AreEqual(1, conn.NpgsqlDataSource.Statistics.Total);
104          Assert.DoesNotThrowAsync(conn.CloseAsync);
105      }
106      [Test]
107      [Platform(Exclude = "MacOsX", Reason = "Flaky on MacOS")]
108      public async Task Break_while_open()
109      {
110          if (IsMultiplexing)
111              return;
112          await using var dataSource = CreateDataSource();
113          await using var conn = await dataSource.OpenConnectionAsync();
114          using (var conn2 = await OpenConnectionAsync())
115              conn2.ExecuteNonQuery($"SELECT pg_terminate_backend({conn.ProcessID})");
116          using (var cmd = CreateSleepCommand(conn, 10))
117              Assert.That(() => cmd.ExecuteNonQuery(), Throws.Exception
118                  .AssignableTo<NpgsqlException>());
119          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
120          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
121      }
122      #region Connection Errors
123  #if IGNORE
124      [Test]
125      [TestCase(true)]
126      [TestCase(false)]
127      public async Task Connection_refused(bool pooled)
128      {
129          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
130          using (var conn = new NpgsqlConnection(csb)) {
131              Assert.That(() => conn.Open(), Throws.Exception
132                  .TypeOf<SocketException>()
133                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
134              );
135              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
136          }
137      }
138      [Test]
139      [TestCase(true)]
140      [TestCase(false)]
141      public async Task Connection_refused_async(bool pooled)
142      {
143          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
144          using (var conn = new NpgsqlConnection(csb))
145          {
146              Assert.That(async () => await conn.OpenAsync(), Throws.Exception
147                  .TypeOf<SocketException>()
148                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
149              );
150              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
151          }
152      }
153  #endif
154      [Test]
155      [Ignore("Fails in a non-determinstic manner and only on the build server... investigate...")]
156      public void Invalid_Username()
157      {
158          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
159          {
160              Username = "unknown", Pooling = false
161          }.ToString();
162          using var conn = new NpgsqlConnection(connString);
163          Assert.That(conn.Open, Throws.Exception
164              .TypeOf<PostgresException>()
165              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidPassword)
166          );
167          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
168      }
169      [Test]
170      public void Bad_database()
171      {
172          using var dataSource = CreateDataSource(csb => csb.Database = "does_not_exist");
173          using var conn = dataSource.CreateConnection();
174          Assert.That(() => conn.Open(),
175              Throws.Exception.TypeOf<PostgresException>()
176                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidCatalogName)
177          );
178      }
179      [Test, Description("Tests that mandatory connection string parameters are indeed mandatory")]
180      public void Mandatory_connection_string_params()
181          => Assert.Throws<ArgumentException>(() =>
182              new NpgsqlConnection("User ID=npgsql_tests;Password=npgsql_tests;Database=npgsql_tests"));
183      [Test, Description("Reuses the same connection instance for a failed connection, then a successful one")]
184      public async Task Fail_connect_then_succeed([Values] bool pooling)
185      {
186          if (IsMultiplexing && !pooling) 
187              return;
188          var dbName = GetUniqueIdentifier(nameof(Fail_connect_then_succeed));
189          await using var conn1 = await OpenConnectionAsync();
190          await conn1.ExecuteNonQueryAsync($"DROP DATABASE IF EXISTS \"{dbName}\"");
191          try
192          {
193              await using var dataSource = CreateDataSource(csb =>
194              {
195                  csb.Database = dbName;
196                  csb.Pooling = pooling;
197              });
198              await using var conn2 = dataSource.CreateConnection();
199              var pgEx = Assert.ThrowsAsync<PostgresException>(conn2.OpenAsync)!;
200              Assert.That(pgEx.SqlState, Is.EqualTo(PostgresErrorCodes.InvalidCatalogName)); 
201              Assert.That(conn2.FullState, Is.EqualTo(ConnectionState.Closed));
202              await conn1.ExecuteNonQueryAsync($"CREATE DATABASE \"{dbName}\" TEMPLATE template0");
203              Assert.DoesNotThrowAsync(conn2.OpenAsync);
204              Assert.DoesNotThrowAsync(conn2.CloseAsync);
205          }
206          finally
207          {
208              await conn1.ExecuteNonQueryAsync($"DROP DATABASE IF EXISTS \"{dbName}\"");
209          }
210      }
211      [Test]
212      public void Open_timeout_unknown_ip([Values(true, false)] bool async)
213      {
214          const int timeoutSeconds = 2;
215          var unknownIp = Environment.GetEnvironmentVariable("NPGSQL_UNKNOWN_IP");
216          if (unknownIp is null)
217          {
218              Assert.Ignore("NPGSQL_UNKNOWN_IP isn't defined and is required for connection timeout tests");
219              return;
220          }
221          using var dataSource = CreateDataSource(csb =>
222          {
223              csb.Host = unknownIp;
224              csb.Timeout = timeoutSeconds;
225          });
226          using var conn = dataSource.CreateConnection();
227          var sw = Stopwatch.StartNew();
228          if (async)
229          {
230              Assert.That(async () => await conn.OpenAsync(), Throws.Exception
231                  .TypeOf<NpgsqlException>()
232                  .With.InnerException.TypeOf<TimeoutException>());
233          }
234          else
235          {
236              Assert.That(() => conn.Open(), Throws.Exception
237                  .TypeOf<NpgsqlException>()
238                  .With.InnerException.TypeOf<TimeoutException>());
239          }
240          Assert.That(sw.Elapsed.TotalMilliseconds, Is.GreaterThanOrEqualTo(timeoutSeconds * 1000 - 100),
241              $"Timeout was supposed to happen after {timeoutSeconds} seconds, but fired after {sw.Elapsed.TotalSeconds}");
242          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
243      }
244      [Test]
245      public void Connect_timeout_cancel()
246      {
247          var unknownIp = Environment.GetEnvironmentVariable("NPGSQL_UNKNOWN_IP");
248          if (unknownIp is null)
249          {
250              Assert.Ignore("NPGSQL_UNKNOWN_IP isn't defined and is required for connection cancellation tests");
251              return;
252          }
253          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
254          {
255              Host = unknownIp,
256              Pooling = false,
257              Timeout = 30
258          }.ToString();
259          using var conn = new NpgsqlConnection(connString);
260          var cts = new CancellationTokenSource(1000);
261          Assert.That(async () => await conn.OpenAsync(cts.Token), Throws.Exception.TypeOf<OperationCanceledException>());
262          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
263      }
264      #endregion
265      #region Client Encoding
266      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1065")]
267      public async Task Client_encoding_is_UTF8_by_default()
268      {
269          using var conn = await OpenConnectionAsync();
270          Assert.That(await conn.ExecuteScalarAsync("SHOW client_encoding"), Is.EqualTo("UTF8"));
271      }
272      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1065")]
273      [NonParallelizable] 
274      public async Task Client_encoding_env_var()
275      {
276          using (var testConn = await OpenConnectionAsync())
277              Assert.That(await testConn.ExecuteScalarAsync("SHOW client_encoding"), Is.Not.EqualTo("SQL_ASCII"));
278          using var _ = SetEnvironmentVariable("PGCLIENTENCODING", "SQL_ASCII");
279          await using var dataSource = CreateDataSource();
280          await using var conn = await dataSource.OpenConnectionAsync();
281          Assert.That(await conn.ExecuteScalarAsync("SHOW client_encoding"), Is.EqualTo("SQL_ASCII"));
282      }
283      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1065")]
284      public async Task Client_encoding_connection_param()
285      {
286          using (var conn = await OpenConnectionAsync())
287              Assert.That(await conn.ExecuteScalarAsync("SHOW client_encoding"), Is.Not.EqualTo("SQL_ASCII"));
288          await using var dataSource = CreateDataSource(csb => csb.ClientEncoding = "SQL_ASCII");
289          using (var conn = await dataSource.OpenConnectionAsync())
290              Assert.That(await conn.ExecuteScalarAsync("SHOW client_encoding"), Is.EqualTo("SQL_ASCII"));
291      }
292      #endregion Client Encoding
293      #region Timezone
294      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1634")]
295      [NonParallelizable] 
296      public async Task Timezone_env_var()
297      {
298          string newTimezone;
299          using (var conn1 = await OpenConnectionAsync())
300          {
301              newTimezone = (string?)await conn1.ExecuteScalarAsync("SHOW TIMEZONE") == "Africa/Bamako"
302                  ? "Africa/Lagos"
303                  : "Africa/Bamako";
304          }
305          using var _ = SetEnvironmentVariable("PGTZ", newTimezone);
306          await using var dataSource = CreateDataSource();
307          using var conn2 = await dataSource.OpenConnectionAsync();
308          Assert.That(await conn2.ExecuteScalarAsync("SHOW TIMEZONE"), Is.EqualTo(newTimezone));
309      }
310      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1634")]
311      public async Task Timezone_connection_param()
312      {
313          string newTimezone;
314          using (var conn = await OpenConnectionAsync())
315          {
316              newTimezone = (string?)await conn.ExecuteScalarAsync("SHOW TIMEZONE") == "Africa/Bamako"
317                  ? "Africa/Lagos"
318                  : "Africa/Bamako";
319          }
320          await using var dataSource = CreateDataSource(csb => csb.Timezone = newTimezone);
321          using (var conn = await dataSource.OpenConnectionAsync())
322              Assert.That(await conn.ExecuteScalarAsync("SHOW TIMEZONE"), Is.EqualTo(newTimezone));
323      }
324      #endregion Timezone
325      #region ConnectionString - Host
326      [TestCase("127.0.0.1", ExpectedResult = new [] { "127.0.0.1:5432" })]
327      [TestCase("127.0.0.1:5432", ExpectedResult = new [] { "127.0.0.1:5432" })]
328      [TestCase("::1", ExpectedResult = new [] { "::1:5432" })]
329      [TestCase("[::1]", ExpectedResult = new [] { "[::1]:5432" })]
330      [TestCase("[::1]:5432", ExpectedResult = new [] { "[::1]:5432" })]
331      [TestCase("localhost", ExpectedResult = new [] { "localhost:5432" })]
332      [TestCase("localhost:5432", ExpectedResult = new [] { "localhost:5432" })]
333      [TestCase("127.0.0.1,127.0.0.1:5432,::1,[::1],[::1]:5432,localhost,localhost:5432",
334          ExpectedResult = new []
335          {
336              "127.0.0.1:5432",
337              "127.0.0.1:5432",
338              "::1:5432",
339              "[::1]:5432",
340              "[::1]:5432",
341              "localhost:5432",
342              "localhost:5432"
343          })]
344      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3802")]
345      public string[] ConnectionString_Host(string host)
346      {
347          var dataSourceBuilder = new NpgsqlDataSourceBuilder
348          {
349              ConnectionStringBuilder = { Host = host }
350          };
351          using var dataSource = dataSourceBuilder.BuildMultiHost();
352          return dataSource.Pools.Select(ds => $"{ds.Settings.Host}:{ds.Settings.Port}").ToArray()!;
353      }
354      #endregion ConnectionString - Host
355      [Test]
356      public async Task Unix_domain_socket()
357      {
358          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
359          {
360              if (Environment.OSVersion.Version.Major < 10 || Environment.OSVersion.Version.Build < 17093)
361                  Assert.Ignore("Unix-domain sockets support was introduced in Windows build 17093");
362              using var versionConnection = await OpenConnectionAsync();
363              MinimumPgVersion(versionConnection, "13.0", "Unix-domain sockets support on Windows was introduced in PostgreSQL 13");
364          }
365          var port = new NpgsqlConnectionStringBuilder(ConnectionString).Port;
366          var candidateDirectories = new[] { "/var/run/postgresql", "/tmp", Environment.GetEnvironmentVariable("TMP") ?? "C:\\" };
367          var dir = candidateDirectories.FirstOrDefault(d => File.Exists(Path.Combine(d, $".s.PGSQL.{port}")));
368          if (dir == null)
369          {
370              IgnoreExceptOnBuildServer("No PostgreSQL unix domain socket was found");
371              return;
372          }
373          try
374          {
375              await using var dataSource = CreateDataSource(csb => csb.Host = dir);
376              await using var conn = await dataSource.OpenConnectionAsync();
377              await using var tx = await conn.BeginTransactionAsync();
378              Assert.That(await conn.ExecuteScalarAsync("SELECT 1", tx), Is.EqualTo(1));
379              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(dir, $".s.PGSQL.{port}")));
380          }
381          catch (Exception ex)
382          {
383              IgnoreExceptOnBuildServer($"Connection via unix domain socket failed: {ex}");
384          }
385      }
386      [Test]
387      [Platform(Exclude = "MacOsX", Reason = "Fails only on mac, needs to be investigated")]
388      public async Task Unix_abstract_domain_socket()
389      {
390          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
391          {
392              Assert.Ignore("Abstract unix-domain sockets are not supported on windows");
393          }
394          using var versionConnection = await OpenConnectionAsync();
395          MinimumPgVersion(versionConnection, "14.0", "Abstract unix-domain sockets support was introduced in PostgreSQL 14");
396          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
397          {
398              Host = "@/npgsql_unix"
399          };
400          try
401          {
402              await using var dataSource = CreateDataSource(csb.ToString());
403              await using var conn = await dataSource.OpenConnectionAsync();
404              await using var tx = await conn.BeginTransactionAsync();
405              Assert.That(await conn.ExecuteScalarAsync("SELECT 1", tx), Is.EqualTo(1));
406              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(csb.Host, $".s.PGSQL.{csb.Port}")));
407          }
408          catch (Exception ex)
409          {
410              IgnoreExceptOnBuildServer($"Connection via abstract unix domain socket failed: {ex}");
411          }
412      }
413      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/903")]
414      public void DataSource_property()
415      {
416          using var conn = new NpgsqlConnection();
417          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
418          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
419          conn.ConnectionString = csb.ConnectionString;
420          Assert.That(conn.DataSource, Is.EqualTo($"tcp:&bsol;&bsol;{csb.Host}:{csb.Port}"));
421          if (IsMultiplexing)
422              return;
423          csb.Host = "127.0.0.1, 127.0.0.2";
424          conn.ConnectionString = csb.ConnectionString;
425          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
426      }
427      #region Server version
428      [Test]
429      public async Task PostgreSqlVersion_ServerVersion()
430      {
431          await using var c = new NpgsqlConnection(ConnectionString);
432          Assert.That(() => c.PostgreSqlVersion, Throws.InvalidOperationException
433              .With.Message.EqualTo("Connection is not open"));
434          Assert.That(() => c.ServerVersion, Throws.InvalidOperationException
435              .With.Message.EqualTo("Connection is not open"));
436          await c.OpenAsync();
437          var backendVersionString = (string)(await c.ExecuteScalarAsync("SHOW server_version"))!;
438          Assert.That(backendVersionString, Is.EqualTo(c.ServerVersion));
439          Assert.That(backendVersionString, Does.Contain(
440              new[] { "rc", "beta", "devel" }.Any(x => backendVersionString.Contains(x))
441                  ? c.PostgreSqlVersion.Major.ToString()
442                  : c.PostgreSqlVersion.ToString()));
443      }
444      [TestCase("X13.0")]
445      [TestCase("13.")]
446      [TestCase("13.1.")]
447      [TestCase("13.1.1.")]
448      [TestCase("13.1.1.1.")]
449      [TestCase("13.1.1.1.1")]
450      public void ParseVersion_fails(string versionString)
451          => Assert.That(() => TestDbInfo.ParseServerVersion(versionString), Throws.Exception);
452      [TestCase("13.3", ExpectedResult = "13.3")]
453      [TestCase("13.3X", ExpectedResult = "13.3")]
454      [TestCase("9.6.4", ExpectedResult = "9.6.4")]
455      [TestCase("9.6.4X", ExpectedResult = "9.6.4")]
456      [TestCase("9.5alpha2", ExpectedResult = "9.5")]
457      [TestCase("9.5alpha2X", ExpectedResult = "9.5")]
458      [TestCase("9.5devel", ExpectedResult = "9.5")]
459      [TestCase("9.5develX", ExpectedResult = "9.5")]
460      [TestCase("9.5deveX", ExpectedResult = "9.5")]
461      [TestCase("9.4beta3", ExpectedResult = "9.4")]
462      [TestCase("9.4rc1", ExpectedResult = "9.4")]
463      [TestCase("9.4rc1X", ExpectedResult = "9.4")]
464      [TestCase("13devel", ExpectedResult = "13.0")]
465      [TestCase("13beta1", ExpectedResult = "13.0")]
466      [TestCase("13", ExpectedResult = "13.0")]
467      [TestCase("13X", ExpectedResult = "13.0")]
468      [TestCase("13alpha1", ExpectedResult = "13.0")]
469      [TestCase("13alpha", ExpectedResult = "13.0")]
470      [TestCase("13alphX", ExpectedResult = "13.0")]
471      [TestCase("13beta", ExpectedResult = "13.0")]
472      [TestCase("13betX", ExpectedResult = "13.0")]
473      [TestCase("13rc1", ExpectedResult = "13.0")]
474      [TestCase("13rc", ExpectedResult = "13.0")]
475      [TestCase("13rX", ExpectedResult = "13.0")]
476      [TestCase("99999.99999.99999.99999", ExpectedResult = "99999.99999.99999.99999")]
477      [TestCase("99999.99999.99999.99999X", ExpectedResult = "99999.99999.99999.99999")]
478      [TestCase("99999.99999.99999.99999devel", ExpectedResult = "99999.99999.99999.99999")]
479      [TestCase("99999.99999.99999.99999alpha99999", ExpectedResult = "99999.99999.99999.99999")]
480      [TestCase("99999.99999.99999alpha99999", ExpectedResult = "99999.99999.99999")]
481      [TestCase("99999.99999.99999.99999beta99999", ExpectedResult = "99999.99999.99999.99999")]
482      [TestCase("99999.99999.99999beta99999", ExpectedResult = "99999.99999.99999")]
483      [TestCase("99999.99999.99999.99999rc99999", ExpectedResult = "99999.99999.99999.99999")]
484      [TestCase("99999.99999.99999rc99999", ExpectedResult = "99999.99999.99999")]
485      public string ParseVersion_succeeds(string versionString)
486          => TestDbInfo.ParseServerVersion(versionString).ToString();
487      class TestDbInfo : NpgsqlDatabaseInfo
488      {
489          public TestDbInfo(string host, int port, string databaseName, Version version) : base(host, port, databaseName, version)
490              => throw new NotImplementedException();
491          protected override IEnumerable<PostgresType> GetTypes()
492              => throw new NotImplementedException();
493          public new static Version ParseServerVersion(string versionString)
494              => NpgsqlDatabaseInfo.ParseServerVersion(versionString);
495      }
496      #endregion Server version
497      [Test]
498      public void Setting_connection_string_while_open_throws()
499      {
500          using var conn = new NpgsqlConnection();
501          conn.ConnectionString = ConnectionString;
502          conn.Open();
503          Assert.That(() => conn.ConnectionString = "", Throws.Exception.TypeOf<InvalidOperationException>());
504      }
505      [Test]
506      public void Empty_constructor()
507      {
508          var conn = new NpgsqlConnection();
509          Assert.That(conn.ConnectionTimeout, Is.EqualTo(NpgsqlConnectionStringBuilder.DefaultTimeout));
510          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
511          Assert.That(() => conn.Open(), Throws.Exception.TypeOf<InvalidOperationException>());
512      }
513      [Test]
514      public void Constructor_with_null_connection_string()
515      {
516          var conn = new NpgsqlConnection(null);
517          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
518          Assert.That(() => conn.Open(), Throws.Exception.TypeOf<InvalidOperationException>());
519      }
520      [Test]
521      public void Constructor_with_empty_connection_string()
522      {
523          var conn = new NpgsqlConnection("");
524          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
525          Assert.That(() => conn.Open(), Throws.Exception.TypeOf<InvalidOperationException>());
526      }
527      [Test]
528      public void Set_connection_string_to_null()
529      {
530          var conn = new NpgsqlConnection(ConnectionString);
531          conn.ConnectionString = null;
532          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
533          Assert.That(conn.Settings.Host, Is.Null);
534          Assert.That(() => conn.Open(), Throws.Exception.TypeOf<InvalidOperationException>());
535      }
536      [Test]
537      public void Set_connection_string_to_empty()
538      {
539          var conn = new NpgsqlConnection(ConnectionString);
540          conn.ConnectionString = "";
541          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
542          Assert.That(conn.Settings.Host, Is.Null);
543          Assert.That(() => conn.Open(), Throws.Exception.TypeOf<InvalidOperationException>());
544      }
545      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/703")]
546      public async Task No_database_defaults_to_username()
547      {
548          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Database = null };
549          using var conn = new NpgsqlConnection(csb.ToString());
550          Assert.That(conn.Database, Is.EqualTo(csb.Username));
551          conn.Open();
552          Assert.That(await conn.ExecuteScalarAsync("SELECT current_database()"), Is.EqualTo(csb.Username));
553          Assert.That(conn.Database, Is.EqualTo(csb.Username));
554      }
555      [Test, Description("Breaks a connector while it's in the pool, with a keepalive and without")]
556      [Platform(Exclude = "MacOsX", Reason = "Fails only on mac, needs to be investigated")]
557      [TestCase(false, TestName = nameof(Break_connector_in_pool) + "_without_keep_alive")]
558      [TestCase(true, TestName = nameof(Break_connector_in_pool) + "_with_keep_alive")]
559      public async Task Break_connector_in_pool(bool keepAlive)
560      {
561          if (IsMultiplexing)
562              Assert.Ignore("Multiplexing, hanging");
563          var dataSourceBuilder = CreateDataSourceBuilder();
564          dataSourceBuilder.ConnectionStringBuilder.MaxPoolSize = 1;
565          if (keepAlive)
566              dataSourceBuilder.ConnectionStringBuilder.KeepAlive = 1;
567          await using var dataSource = dataSourceBuilder.Build();
568          await using var conn = await dataSource.OpenConnectionAsync();
569          var connector = conn.Connector;
570          Assert.That(connector, Is.Not.Null);
571          await conn.CloseAsync();
572          await using (var conn2 = await OpenConnectionAsync())
573              await conn2.ExecuteNonQueryAsync($"SELECT pg_terminate_backend({connector!.BackendProcessId})");
574          await Task.Delay(3000);
575          await conn.OpenAsync();
576          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
577          if (keepAlive)
578          {
579              Assert.That(conn.Connector, Is.Not.SameAs(connector));
580              Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
581          }
582          else
583          {
584              Assert.That(conn.Connector, Is.SameAs(connector));
585              Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Throws.Exception
586                  .AssignableTo<NpgsqlException>());
587          }
588      }
589      [Test]
590      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4603")]
591      public async Task Reload_types_keepalive_concurrent()
592      {
593          if (IsMultiplexing)
594              Assert.Ignore("Multiplexing doesn't support keepalive");
595          await using var dataSource = CreateDataSource(csb => csb.KeepAlive = 1);
596          await using var conn = await dataSource.OpenConnectionAsync();
597          var startTimestamp = Stopwatch.GetTimestamp();
598          while (GetElapsedTime(startTimestamp).TotalSeconds < 2)
599              Assert.DoesNotThrow(conn.ReloadTypes);
600          static TimeSpan GetElapsedTime(long startingTimestamp) =>
601              new((long)((Stopwatch.GetTimestamp() - startingTimestamp) * ((double)10000000 / Stopwatch.Frequency)));
602      }
603      #region ChangeDatabase
604      [Test]
605      public async Task ChangeDatabase()
606      {
607          using var conn = await OpenConnectionAsync();
608          conn.ChangeDatabase("template1");
609          using var cmd = new NpgsqlCommand("select current_database()", conn);
610          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo("template1"));
611      }
612      [Test]
613      public async Task ChangeDatabase_does_not_affect_other_connections()
614      {
615          using var conn1 = new NpgsqlConnection(ConnectionString);
616          using var conn2 = new NpgsqlConnection(ConnectionString);
617          conn1.Open();
618          conn1.ChangeDatabase("template1");
619          Assert.That(await conn1.ExecuteScalarAsync("SELECT current_database()"), Is.EqualTo("template1"));
620          conn2.Open();
621          Assert.That(await conn2.ExecuteScalarAsync("SELECT current_database()"), Is.Not.EqualTo(conn1.Database));
622      }
623      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1331")]
624      public void ChangeDatabase_connection_on_closed_connection_throws()
625      {
626          using var conn = new NpgsqlConnection(ConnectionString);
627          Assert.That(() => conn.ChangeDatabase("template1"), Throws.Exception
628              .TypeOf<InvalidOperationException>()
629              .With.Message.EqualTo("Connection is not open"));
630      }
631      #endregion
632      [Test, Description("Tests closing a connector while a reader is open")]
633      public async Task Close_during_read([Values(PooledOrNot.Pooled, PooledOrNot.Unpooled)] PooledOrNot pooled)
634      {
635          if (IsMultiplexing && pooled == PooledOrNot.Unpooled)
636              return; 
637          await using var dataSource = CreateDataSource(csb => csb.Pooling = pooled == PooledOrNot.Pooled);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using (var cmd = new NpgsqlCommand("SELECT 1", conn))
640          await using (var reader = await cmd.ExecuteReaderAsync())
641          {
642              reader.Read();
643              conn.Close();
644              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
645              Assert.That(reader.IsClosed);
646          }
647          conn.Open();
648          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
649          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
650      }
651      [Test]
652      public async Task Search_path()
653      {
654          await using var dataSource = CreateDataSource(csb => csb.SearchPath = "foo");
655          await using var conn = await dataSource.OpenConnectionAsync();
656          Assert.That(await conn.ExecuteScalarAsync("SHOW search_path"), Contains.Substring("foo"));
657      }
658      [Test]
659      public async Task Set_options()
660      {
661          await using var dataSource = CreateDataSource(csb =>
662              csb.Options =
663                  "-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing");
664          await using var conn = await dataSource.OpenConnectionAsync();
665          Assert.That(await conn.ExecuteScalarAsync("SHOW default_transaction_isolation"), Is.EqualTo("serializable"));
666          Assert.That(await conn.ExecuteScalarAsync("SHOW default_transaction_deferrable"), Is.EqualTo("on"));
667          Assert.That(await conn.ExecuteScalarAsync("SHOW foo.bar"), Is.EqualTo("My Famous\\Thing"));
668      }
669      [Test]
670      public async Task Connector_not_initialized_exception()
671      {
672          var command = new NpgsqlCommand();
673          command.CommandText = @"SELECT 123";
674          for (var i = 0; i < 2; i++)
675          {
676              await using var connection = await OpenConnectionAsync();
677              command.Connection = connection;
678              await using var tx = await connection.BeginTransactionAsync();
679              await command.ExecuteScalarAsync();
680              await tx.CommitAsync();
681          }
682      }
683      [Test]
684      public void Bug1011001()
685      {
686          var csb1 = new NpgsqlConnectionStringBuilder(@"Server=server;Port=5432;User Id=user;Password=passwor;Database=database;");
687          var cs1 = csb1.ToString();
688          var csb2 = new NpgsqlConnectionStringBuilder(cs1);
689          var cs2 = csb2.ToString();
690          Assert.IsTrue(cs1 == cs2);
691      }
692      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/pull/164")]
693      public void Connection_State_is_Closed_when_disposed()
694      {
695          var c = new NpgsqlConnection();
696          c.Dispose();
697          Assert.AreEqual(ConnectionState.Closed, c.State);
698      }
699      [Test]
700      public void Change_ApplicationName_with_connection_string_builder()
701      {
702          var builder = new NpgsqlConnectionStringBuilder();
703          builder.ApplicationName = "test";
704      }
705      [Test, Description("Makes sure notices are probably received and emitted as events")]
706      public async Task Notice()
707      {
708          await using var dataSource = CreateDataSource(csb => csb.Options = "-c lc_messages=en_US.UTF-8");
709          await using var conn = await dataSource.OpenConnectionAsync();
710          var function = await GetTempFunctionName(conn);
711          await conn.ExecuteNonQueryAsync($@"
712  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
713  'BEGIN RAISE NOTICE ''testnotice''; END;'
714  LANGUAGE 'plpgsql'");
715          var mre = new ManualResetEvent(false);
716          PostgresNotice? notice = null;
717          NoticeEventHandler action = (sender, args) =>
718          {
719              notice = args.Notice;
720              mre.Set();
721          };
722          conn.Notice += action;
723          try
724          {
725              await conn.ExecuteNonQueryAsync($"SELECT {function}()::TEXT");
726              mre.WaitOne(5000);
727              Assert.That(notice, Is.Not.Null, "No notice was emitted");
728              Assert.That(notice!.MessageText, Is.EqualTo("testnotice"));
729              Assert.That(notice.Severity, Is.EqualTo("NOTICE"));
730          }
731          finally
732          {
733              conn.Notice -= action;
734          }
735      }
736      [Test, Description("Makes sure that concurrent use of the connection throws an exception")]
737      public async Task Concurrent_use_throws()
738      {
739          if (IsMultiplexing)
740              Assert.Ignore("Multiplexing: fails");
741          using var conn = await OpenConnectionAsync();
742          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
743          using (await cmd.ExecuteReaderAsync())
744              Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 2"),
745                  Throws.Exception.TypeOf<NpgsqlOperationInProgressException>()
746                      .With.Property(nameof(NpgsqlOperationInProgressException.CommandInProgress)).SameAs(cmd));
747          await conn.ExecuteNonQueryAsync("CREATE TEMP TABLE foo (bar INT)");
748          using (conn.BeginBinaryImport("COPY foo (bar) FROM STDIN BINARY"))
749          {
750              Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 2"),
751                  Throws.Exception.TypeOf<NpgsqlOperationInProgressException>()
752                      .With.Message.Contains("Copy"));
753          }
754      }
755      #region PersistSecurityInfo
756      [Test]
757      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/783")]
758      public void PersistSecurityInfo_is_true([Values(true, false)] bool pooling)
759      {
760          if (IsMultiplexing && !pooling)
761              return;
762          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
763          {
764              PersistSecurityInfo = true,
765              Pooling = pooling
766          }.ToString();
767          using var conn = new NpgsqlConnection(connString);
768          var passwd = new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password;
769          Assert.That(passwd, Is.Not.Null);
770          conn.Open();
771          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.EqualTo(passwd));
772      }
773      [Test]
774      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/783")]
775      public void No_password_without_PersistSecurityInfo([Values(true, false)] bool pooling)
776      {
777          if (IsMultiplexing && !pooling)
778              return;
779          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
780          {
781              Pooling = pooling
782          }.ToString();
783          using var conn = new NpgsqlConnection(connString);
784          var csb = new NpgsqlConnectionStringBuilder(conn.ConnectionString);
785          Assert.That(csb.PersistSecurityInfo, Is.False);
786          Assert.That(csb.Password, Is.Not.Null);
787          conn.Open();
788          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.Null);
789      }
790      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2725")]
791      public void Clone_with_PersistSecurityInfo()
792      {
793          var builder = new NpgsqlConnectionStringBuilder(ConnectionString)
794          {
795              PersistSecurityInfo = true
796          };
797          using var _ = CreateTempPool(builder, out var connStringWithPersist);
798          using var connWithPersist = new NpgsqlConnection(connStringWithPersist);
799          builder.PersistSecurityInfo = false;
800          var connStringWithoutPersist = builder.ToString();
801          using var clonedWithoutPersist = connWithPersist.CloneWith(connStringWithoutPersist);
802          clonedWithoutPersist.Open();
803          Assert.That(clonedWithoutPersist.ConnectionString, Does.Not.Contain("Password="));
804          using var clonedConn = clonedWithoutPersist.CloneWith(connStringWithPersist);
805          clonedConn.Open();
806          Assert.That(clonedConn.ConnectionString, Does.Not.Contain("Password="));
807      }
808      [Test]
809      public async Task CloneWith_and_data_source_with_password()
810      {
811          var dataSourceBuilder = new NpgsqlDataSourceBuilder(ConnectionString);
812          var password = dataSourceBuilder.ConnectionStringBuilder.Password!;
813          dataSourceBuilder.ConnectionStringBuilder.Password = null;
814          await using var dataSource = dataSourceBuilder.Build();
815          await using var connection = dataSource.CreateConnection();
816          dataSource.Password = password;
817          using var _ = CreateTempPool(new NpgsqlConnectionStringBuilder(ConnectionString) { Password = null }, out var tempConnectionString);
818          await using var clonedConnection = connection.CloneWith(tempConnectionString);
819          await clonedConnection.OpenAsync();
820      }
821      [Test]
822      public async Task CloneWith_and_data_source_with_auth_callbacks()
823      {
824          var (userCertificateValidationCallbackCalled, clientCertificatesCallbackCalled) = (false, false);
825          var dataSourceBuilder = CreateDataSourceBuilder();
826          dataSourceBuilder.UseUserCertificateValidationCallback(UserCertificateValidationCallback);
827          dataSourceBuilder.UseClientCertificatesCallback(ClientCertificatesCallback);
828          await using var dataSource = dataSourceBuilder.Build();
829          await using var connection = dataSource.CreateConnection();
830          using var _ = CreateTempPool(ConnectionString, out var tempConnectionString);
831          await using var clonedConnection = connection.CloneWith(tempConnectionString);
832          clonedConnection.UserCertificateValidationCallback!(null!, null, null, SslPolicyErrors.None);
833          Assert.True(userCertificateValidationCallbackCalled);
834          clonedConnection.ProvideClientCertificatesCallback!(null!);
835          Assert.True(clientCertificatesCallbackCalled);
836          bool UserCertificateValidationCallback(object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors errors)
837              => userCertificateValidationCallbackCalled = true;
838          void ClientCertificatesCallback(X509CertificateCollection certs)
839              => clientCertificatesCallbackCalled = true;
840      }
841      #endregion PersistSecurityInfo
842      [Test]
843      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/743")]
844      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/783")]
845      public void Clone()
846      {
847          using var pool = CreateTempPool(ConnectionString, out var connectionString);
848          using var conn = new NpgsqlConnection(connectionString);
849          ProvideClientCertificatesCallback callback1 = certificates => { };
850          conn.ProvideClientCertificatesCallback = callback1;
851          RemoteCertificateValidationCallback callback2 = (sender, certificate, chain, errors) => true;
852          conn.UserCertificateValidationCallback = callback2;
853          conn.Open();
854          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
855          using var conn2 = (NpgsqlConnection)((ICloneable)conn).Clone();
856          Assert.That(conn2.ConnectionString, Is.EqualTo(conn.ConnectionString));
857          Assert.That(conn2.ProvideClientCertificatesCallback, Is.SameAs(callback1));
858          Assert.That(conn2.UserCertificateValidationCallback, Is.SameAs(callback2));
859          conn2.Open();
860          Assert.That(async () => await conn2.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
861      }
862      [Test]
863      public async Task Clone_with_data_source()
864      {
865          await using var connection = await SharedDataSource.OpenConnectionAsync();
866          await using var clonedConnection = (NpgsqlConnection)((ICloneable)connection).Clone();
867          Assert.That(clonedConnection.NpgsqlDataSource, Is.SameAs(SharedDataSource));
868          Assert.DoesNotThrowAsync(() => clonedConnection.OpenAsync());
869      }
870      [Test]
871      public async Task DatabaseInfo_is_shared()
872      {
873          if (IsMultiplexing)
874              return;
875          await using var dataSource = CreateDataSource();
876          await using var conn1 = await dataSource.OpenConnectionAsync();
877          conn1.ReloadTypes();
878          await using var conn2 = await dataSource.OpenConnectionAsync();
879          Assert.That(conn1.Connector!.DatabaseInfo, Is.SameAs(conn2.Connector!.DatabaseInfo));
880      }
881      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/736")]
882      public async Task ManyOpenClose()
883      {
884          await using var dataSource = CreateDataSource();
885          for (var i = 0; i < 255; i++)
886          {
887              await using var conn = await dataSource.OpenConnectionAsync();
888          }
889          await using (var conn = dataSource.CreateConnection())
890          {
891              await conn.OpenAsync();
892          }
893          await using (var conn = dataSource.CreateConnection())
894          {
895              await conn.OpenAsync();
896              Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
897          }
898      }
899      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/736")]
900      public async Task Many_open_close_with_transaction()
901      {
902          await using var dataSource = CreateDataSource();
903          for (var i = 0; i < 255; i++)
904          {
905              await using var conn = await dataSource.OpenConnectionAsync();
906              await conn.BeginTransactionAsync();
907          }
908          await using (var conn = await dataSource.OpenConnectionAsync())
909              Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
910      }
911      [Test]
912      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/927")]
913      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/736")]
914      [Ignore("Fails when running the entire test suite but not on its own...")]
915      public async Task Rollback_on_close()
916      {
917          await using var dataSource = CreateDataSource();
918          int processId;
919          await using (var conn = await dataSource.OpenConnectionAsync())
920          {
921              processId = conn.Connector!.BackendProcessId;
922              await conn.BeginTransactionAsync();
923              await conn.ExecuteNonQueryAsync("SELECT 1");
924              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.InTransactionBlock));
925          }
926          await using (var conn = await dataSource.OpenConnectionAsync())
927          {
928              Assert.That(conn.Connector!.BackendProcessId, Is.EqualTo(processId));
929              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.Idle));
930          }
931      }
932      [Test, Description("Tests an exception happening when sending the Terminate message while closing a ready connector")]
933      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/777")]
934      public async Task Exception_during_close()
935      {
936          if (IsMultiplexing)
937              return;
938          await using var dataSource = CreateDataSource(csb => csb.Pooling = false);
939          await using var conn = await dataSource.OpenConnectionAsync();
940          var connectorId = conn.ProcessID;
941          using (var conn2 = await OpenConnectionAsync())
942              await conn2.ExecuteNonQueryAsync($"SELECT pg_terminate_backend({connectorId})");
943          conn.Close();
944      }
945      [Test, Description("Some pseudo-PG database don't support pg_type loading, we have a minimal DatabaseInfo for this")]
946      public async Task NoTypeLoading()
947      {
948          await using var dataSource = CreateDataSource(csb => csb.ServerCompatibilityMode = ServerCompatibilityMode.NoTypeLoading);
949          await using var conn = await dataSource.OpenConnectionAsync();
950          Assert.That(await conn.ExecuteScalarAsync("SELECT 8"), Is.EqualTo(8));
951          Assert.That(await conn.ExecuteScalarAsync("SELECT 'foo'"), Is.EqualTo("foo"));
952          Assert.That(await conn.ExecuteScalarAsync("SELECT TRUE"), Is.EqualTo(true));
953          Assert.That(await conn.ExecuteScalarAsync("SELECT INET '192.168.1.1'"), Is.EqualTo(IPAddress.Parse("192.168.1.1")));
954          Assert.That(await conn.ExecuteScalarAsync("SELECT '{1,2,3}'::int[]"), Is.EqualTo(new[] { 1, 2, 3 }));
955          Assert.That(await conn.ExecuteScalarAsync("SELECT '[1,10)'::int4range"), Is.EqualTo(new NpgsqlRange<int>(1, true, 10, false)));
956          if (conn.PostgreSqlVersion >= new Version(14, 0))
957          {
958              var multirangeArray = (NpgsqlRange<int>[])(await conn.ExecuteScalarAsync("SELECT '{[3,7), (8,]}'::int4multirange"))!;
959              Assert.That(multirangeArray.Length, Is.EqualTo(2));
960              Assert.That(multirangeArray[0], Is.EqualTo(new NpgsqlRange<int>(3, true, false, 7, false, false)));
961              Assert.That(multirangeArray[1], Is.EqualTo(new NpgsqlRange<int>(9, true, false, 0, false, true)));
962          }
963          else
964          {
965              using var cmd = new NpgsqlCommand("SELECT $1", conn)
966              {
967                  Parameters = { new() { Value = DBNull.Value, NpgsqlDbType = NpgsqlDbType.IntegerMultirange } }
968              };
969              Assert.That(async () => await cmd.ExecuteScalarAsync(),
970                  Throws.Exception.TypeOf<NpgsqlException>()
971                      .With.Message.EqualTo("The NpgsqlDbType 'IntegerMultirange' isn't present in your database. You may need to install an extension or upgrade to a newer version."));
972          }
973      }
974      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1158")]
975      public async Task Table_named_record()
976      {
977          if (IsMultiplexing)
978              Assert.Ignore("Multiplexing, ReloadTypes");
979          using var conn = await OpenConnectionAsync();
980          await conn.ExecuteNonQueryAsync(@"
981  DROP TABLE IF EXISTS record;
982  CREATE TABLE record ()");
983          try
984          {
985              conn.ReloadTypes();
986              Assert.That(await conn.ExecuteScalarAsync("SELECT COUNT(*) FROM record"), Is.Zero);
987          }
988          finally
989          {
990              await conn.ExecuteNonQueryAsync("DROP TABLE record");
991          }
992      }
993      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/392")]
994      [NonParallelizable]
995      [Platform(Exclude = "MacOsX", Reason = "Flaky in CI on Mac")]
996      public async Task Non_UTF8_Encoding()
997      {
998          Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
999          await using var adminConn = await OpenConnectionAsync();
1000          await adminConn.ExecuteNonQueryAsync("DROP DATABASE IF EXISTS sqlascii");
1001          await adminConn.ExecuteNonQueryAsync(
1002              adminConn.PostgreSqlVersion >= new Version(15, 0)
1003                  ? "CREATE DATABASE sqlascii ENCODING 'sql_ascii' LOCALE_PROVIDER libc TEMPLATE template0"
1004                  : "CREATE DATABASE sqlascii ENCODING 'sql_ascii' TEMPLATE template0");
1005          try
1006          {
1007              await using var goodDataSource = CreateDataSource(csb =>
1008              {
1009                  csb.Database = "sqlascii";
1010                  csb.Encoding = "windows-1252";
1011                  csb.ClientEncoding = "sql-ascii";
1012              });
1013              await using (var conn = await goodDataSource.OpenConnectionAsync())
1014              {
1015                  const string value = "éàç";
1016                  await conn.ExecuteNonQueryAsync("CREATE TABLE foo (bar TEXT)");
1017                  await conn.ExecuteNonQueryAsync($"INSERT INTO foo (bar) VALUES ('{value}')");
1018                  await using var cmd = conn.CreateCommand();
1019                  cmd.CommandText = "SELECT * FROM foo";
1020                  await using var reader = await cmd.ExecuteReaderAsync();
1021                  Assert.IsTrue(await reader.ReadAsync());
1022                  using (var textReader = await reader.GetTextReaderAsync(0))
1023                      Assert.That(textReader.ReadToEnd(), Is.EqualTo(value));
1024                  Assert.That(reader.GetString(0), Is.EqualTo(value));
1025              }
1026              await using var badDataSource = CreateDataSource(csb => csb.Database = "sqlascii");
1027              await using (var conn = await badDataSource.OpenConnectionAsync())
1028              {
1029                  Assert.That(async () => await conn.ExecuteScalarAsync("SELECT * FROM foo"),
1030                      Throws.Exception.TypeOf<PostgresException>()
1031                          .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.CharacterNotInRepertoire)
1032                          .Or.TypeOf<DecoderFallbackException>()
1033                  );
1034              }
1035          }
1036          finally
1037          {
1038              await adminConn.ExecuteNonQueryAsync("DROP DATABASE IF EXISTS sqlascii");
1039          }
1040      }
1041      [Test]
1042      public async Task Oversize_buffer()
1043      {
1044          if (IsMultiplexing)
1045              return;
1046          await using var dataSource = CreateDataSource();
1047          await using var conn = await dataSource.OpenConnectionAsync();
1048          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
1049          Assert.That(conn.Connector!.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1050          var bigString1 = new string('x', conn.Connector.ReadBuffer.Size + 1);
1051          using (var cmd = new NpgsqlCommand($"SELECT '{bigString1}'", conn))
1052          using (var reader = await cmd.ExecuteReaderAsync())
1053          {
1054              reader.Read();
1055              Assert.That(reader.GetString(0), Is.EqualTo(bigString1));
1056          }
1057          var size1 = conn.Connector.ReadBuffer.Size;
1058          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(csb.ReadBufferSize));
1059          var bigString2 = new string('x', conn.Connector.ReadBuffer.Size + 1);
1060          using (var cmd = new NpgsqlCommand($"SELECT '{bigString2}'", conn))
1061          using (var reader = await cmd.ExecuteReaderAsync())
1062          {
1063              reader.Read();
1064              Assert.That(reader.GetString(0), Is.EqualTo(bigString2));
1065          }
1066          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(size1));
1067          var processId = conn.ProcessID;
1068          conn.Close();
1069          conn.Open();
1070          Assert.That(conn.ProcessID, Is.EqualTo(processId));
1071          Assert.That(conn.Connector.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1072      }
1073      #region Keepalive
1074      [Test, Explicit, Description("Turns on TCP keepalive and sleeps forever, good for wiresharking")]
1075      public async Task TcpKeepaliveTime()
1076      {
1077          await using var dataSource = CreateDataSource(csb => csb.TcpKeepAliveTime = 2);
1078          using (await dataSource.OpenConnectionAsync())
1079              Thread.Sleep(Timeout.Infinite);
1080      }
1081      [Test, Explicit, Description("Turns on TCP keepalive and sleeps forever, good for wiresharking")]
1082      public async Task TcpKeepalive()
1083      {
1084          await using var dataSource = CreateDataSource(csb => csb.TcpKeepAlive = true);
1085          await using (await dataSource.OpenConnectionAsync())
1086              Thread.Sleep(Timeout.Infinite);
1087      }
1088      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3511")]
1089      public async Task Keepalive_with_failed_transaction()
1090      {
1091          if (IsMultiplexing)
1092              return;
1093          await using var dataSource = CreateDataSource(csb => csb.KeepAlive = 1);
1094          await using var conn = await dataSource.OpenConnectionAsync();
1095          await using var tx = await conn.BeginTransactionAsync();
1096          Assert.ThrowsAsync<PostgresException>(async () => await conn.ExecuteScalarAsync("SELECT non_existent_table"));
1097          Thread.Sleep(3000);
1098          await tx.RollbackAsync();
1099          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1100      }
1101      #endregion Keepalive
1102      [Test]
1103      public async Task Change_parameter()
1104      {
1105          if (IsMultiplexing)
1106              return;
1107          using var conn = await OpenConnectionAsync();
1108          var defaultApplicationName = conn.PostgresParameters["application_name"];
1109          await conn.ExecuteNonQueryAsync("SET application_name = 'some_test_value'");
1110          Assert.That(conn.PostgresParameters["application_name"], Is.EqualTo("some_test_value"));
1111          await conn.ExecuteNonQueryAsync("SET application_name = 'some_test_value2'");
1112          Assert.That(conn.PostgresParameters["application_name"], Is.EqualTo("some_test_value2"));
1113          await conn.ExecuteNonQueryAsync($"SET application_name = '{defaultApplicationName}'");
1114          Assert.That(conn.PostgresParameters["application_name"], Is.EqualTo(defaultApplicationName));
1115      }
1116      [Test]
1117      [NonParallelizable] 
1118      public async Task Connect_OptionsFromEnvironment_Succeeds()
1119      {
1120          using (SetEnvironmentVariable("PGOPTIONS", "-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing"))
1121          {
1122              await using var dataSource = CreateDataSource();
1123              await using var conn = await dataSource.OpenConnectionAsync();
1124              Assert.That(await conn.ExecuteScalarAsync("SHOW default_transaction_isolation"), Is.EqualTo("serializable"));
1125              Assert.That(await conn.ExecuteScalarAsync("SHOW default_transaction_deferrable"), Is.EqualTo("on"));
1126              Assert.That(await conn.ExecuteScalarAsync("SHOW foo.bar"), Is.EqualTo("My Famous\\Thing"));
1127          }
1128      }
1129      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3030")]
1130      [TestCase(true, TestName = "NoResetOnClose")]
1131      [TestCase(false, TestName = "NoNoResetOnClose")]
1132      public async Task NoResetOnClose(bool noResetOnClose)
1133      {
1134          var originalApplicationName = new NpgsqlConnectionStringBuilder(ConnectionString).ApplicationName ?? "";
1135          await using var dataSource = CreateDataSource(csb =>
1136          {
1137              csb.MaxPoolSize = 1;
1138              csb.NoResetOnClose = noResetOnClose;
1139          });
1140          await using var conn = await dataSource.OpenConnectionAsync();
1141          await conn.ExecuteNonQueryAsync("SET application_name = 'modified'");
1142          await conn.CloseAsync();
1143          await conn.OpenAsync();
1144          Assert.That(await conn.ExecuteScalarAsync("SHOW application_name"), Is.EqualTo(
1145              noResetOnClose || IsMultiplexing
1146                  ? "modified"
1147                  : originalApplicationName));
1148      }
1149      #region Physical connection initialization
1150      [Test]
1151      public async Task PhysicalConnectionInitializer_sync()
1152      {
1153          if (IsMultiplexing) 
1154              return;
1155          await using var adminConn = await OpenConnectionAsync();
1156          var table = await CreateTempTable(adminConn, "ID INTEGER");
1157          var dataSourceBuilder = CreateDataSourceBuilder();
1158          dataSourceBuilder.UsePhysicalConnectionInitializer(
1159              conn => conn.ExecuteNonQuery($"INSERT INTO {table} VALUES (1)"),
1160              _ => throw new NotSupportedException());
1161          await using var dataSource = dataSourceBuilder.Build();
1162          await using (var conn = dataSource.OpenConnection())
1163          {
1164              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM \"{table}\""), Is.EqualTo(1));
1165          }
1166          await using (var conn = dataSource.OpenConnection())
1167          {
1168              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM \"{table}\""), Is.EqualTo(1));
1169          }
1170      }
1171      [Test]
1172      public async Task PhysicalConnectionInitializer_async()
1173      {
1174          if (IsMultiplexing)
1175              return;
1176          await using var adminConn = await OpenConnectionAsync();
1177          var table = await CreateTempTable(adminConn, "ID INTEGER");
1178          var dataSourceBuilder = CreateDataSourceBuilder();
1179          dataSourceBuilder.UsePhysicalConnectionInitializer(
1180              _ => throw new NotSupportedException(),
1181              async conn => await conn.ExecuteNonQueryAsync($"INSERT INTO {table} VALUES (1)"));
1182          await using var dataSource = dataSourceBuilder.Build();
1183          await using (var conn = await dataSource.OpenConnectionAsync())
1184          {
1185              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM \"{table}\""), Is.EqualTo(1));
1186          }
1187          await using (var conn = await dataSource.OpenConnectionAsync())
1188          {
1189              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM \"{table}\""), Is.EqualTo(1));
1190          }
1191      }
1192      [Test]
1193      public async Task PhysicalConnectionInitializer_sync_with_break()
1194      {
1195          if (IsMultiplexing) 
1196              return;
1197          var dataSourceBuilder = CreateDataSourceBuilder();
1198          dataSourceBuilder.UsePhysicalConnectionInitializer(
1199              conn =>
1200              {
1201                  using (var conn2 = OpenConnection())
1202                      conn2.ExecuteNonQuery($"SELECT pg_terminate_backend({conn.ProcessID})");
1203                  conn.ExecuteScalar("SELECT 1");
1204              },
1205              _ => throw new NotSupportedException());
1206          await using var dataSource = dataSourceBuilder.Build();
1207          Assert.That(() => dataSource.OpenConnection(), Throws.Exception.InstanceOf<NpgsqlException>());
1208          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1209      }
1210      [Test]
1211      public async Task PhysicalConnectionInitializer_async_with_break()
1212      {
1213          var dataSourceBuilder = CreateDataSourceBuilder();
1214          dataSourceBuilder.UsePhysicalConnectionInitializer(
1215              _ => throw new NotSupportedException(),
1216              async conn =>
1217              {
1218                  await using (var conn2 = await OpenConnectionAsync())
1219                      await conn2.ExecuteNonQueryAsync($"SELECT pg_terminate_backend({conn.ProcessID})");
1220                  await conn.ExecuteScalarAsync("SELECT 1");
1221              });
1222          await using var dataSource = dataSourceBuilder.Build();
1223          Assert.That(async () => await dataSource.OpenConnectionAsync(), Throws.Exception.InstanceOf<NpgsqlException>());
1224          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1225      }
1226      [Test]
1227      public async Task PhysicalConnectionInitializer_async_throws_on_second_open()
1228      {
1229          var count = 0;
1230          var dataSourceBuilder = CreateDataSourceBuilder();
1231          dataSourceBuilder.UsePhysicalConnectionInitializer(
1232              _ => throw new NotSupportedException(),
1233              _ =>
1234              {
1235                  if (++count == 1)
1236                      return Task.CompletedTask;
1237                  throw new Exception("INTENTIONAL FAILURE");
1238              });
1239          await using var dataSource = dataSourceBuilder.Build();
1240          await using var conn1 = dataSource.CreateConnection();
1241          Assert.DoesNotThrowAsync(async () => await conn1.OpenAsync());
1242          await using var tx = await conn1.BeginTransactionAsync();
1243          await using var conn2 = dataSource.CreateConnection();
1244          Exception exception;
1245          if (IsMultiplexing)
1246          {
1247              await conn2.OpenAsync();
1248              exception = Assert.ThrowsAsync<Exception>(async () => await conn2.BeginTransactionAsync())!;
1249          }
1250          else
1251              exception = Assert.ThrowsAsync<Exception>(async () => await conn2.OpenAsync())!;
1252          Assert.That(exception.Message, Is.EqualTo("INTENTIONAL FAILURE"));
1253      }
1254      [Test]
1255      public async Task PhysicalConnectionInitializer_disposes_connection()
1256      {
1257          NpgsqlConnection? initializerConnection = null;
1258          var dataSourceBuilder = CreateDataSourceBuilder();
1259          dataSourceBuilder.UsePhysicalConnectionInitializer(
1260              _ => throw new NotSupportedException(),
1261              conn =>
1262              {
1263                  initializerConnection = conn;
1264                  return Task.CompletedTask;
1265              });
1266          await using var dataSource = dataSourceBuilder.Build();
1267          await using var conn = await dataSource.OpenConnectionAsync();
1268          Assert.That(initializerConnection, Is.Not.Null);
1269          Assert.That(conn, Is.Not.SameAs(initializerConnection));
1270          Assert.That(() => initializerConnection!.Open(), Throws.Exception.TypeOf<ObjectDisposedException>());
1271      }
1272      #endregion Physical connection initialization
1273      [Test]
1274      [NonParallelizable] 
1275      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4425")]
1276      public async Task Breaking_connection_while_loading_database_info()
1277      {
1278          if (IsMultiplexing)
1279              return;
1280          await using var dataSource = CreateDataSource();
1281          await using var firstConn = dataSource.CreateConnection();
1282          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1283          try
1284          {
1285              Assert.ThrowsAsync<IOException>(firstConn.OpenAsync);
1286          }
1287          finally
1288          {
1289              NpgsqlDatabaseInfo.ResetFactories();
1290          }
1291          await firstConn.OpenAsync();
1292          await using var secondConn = await dataSource.OpenConnectionAsync();
1293          await secondConn.CloseAsync();
1294          await firstConn.ReloadTypesAsync();
1295          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1296          try
1297          {
1298              Assert.DoesNotThrowAsync(secondConn.OpenAsync);
1299          }
1300          finally
1301          {
1302              NpgsqlDatabaseInfo.ResetFactories();
1303          }
1304      }
1305      class BreakingDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
1306      {
1307          public Task<NpgsqlDatabaseInfo?> Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
1308              => throw conn.Break(new IOException());
1309      }
1310      #region Logging tests
1311      [Test]
1312      public async Task Log_Open_Close_pooled()
1313      {
1314          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1315          await using var conn = dataSource.CreateConnection();
1316          await conn.OpenAsync();
1317          await conn.CloseAsync();
1318          int processId, port;
1319          string host, database;
<span onclick='openModal()' class='match'>1320          using (listLoggerProvider.Record())
1321          {
1322              await conn.OpenAsync();
1323              var tx = await conn.BeginTransactionAsync();
</span>1324              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1325              await tx.CommitAsync();
1326              await conn.CloseAsync();
1327          }
1328          var openingConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.OpeningConnection);
1329          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1330          AssertLoggingStateContains(openingConnectionEvent, "Host", host);
1331          AssertLoggingStateContains(openingConnectionEvent, "Port", port);
1332          AssertLoggingStateContains(openingConnectionEvent, "Database", database);
1333          var openedConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.OpenedConnection);
1334          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1335          AssertLoggingStateContains(openedConnectionEvent, "Host", host);
1336          AssertLoggingStateContains(openedConnectionEvent, "Port", port);
1337          AssertLoggingStateContains(openedConnectionEvent, "Database", database);
1338          var closingConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.ClosingConnection);
1339          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1340          AssertLoggingStateContains(closingConnectionEvent, "Host", host);
1341          AssertLoggingStateContains(closingConnectionEvent, "Port", port);
1342          AssertLoggingStateContains(closingConnectionEvent, "Database", database);
1343          var closedConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.ClosedConnection);
1344          AssertLoggingConnectionString(conn, closedConnectionEvent.State);
1345          AssertLoggingStateContains(closedConnectionEvent, "Host", host);
1346          AssertLoggingStateContains(closedConnectionEvent, "Port", port);
1347          AssertLoggingStateContains(closedConnectionEvent, "Database", database);
1348          if (!IsMultiplexing)
1349          {
1350              AssertLoggingStateContains(openedConnectionEvent, "ConnectorId", processId);
1351              AssertLoggingStateContains(closingConnectionEvent, "ConnectorId", processId);
1352              AssertLoggingStateContains(closedConnectionEvent, "ConnectorId", processId);
1353          }
1354          var ids = new[]
1355          {
1356              NpgsqlEventId.OpeningPhysicalConnection,
1357              NpgsqlEventId.OpenedPhysicalConnection,
1358              NpgsqlEventId.ClosingPhysicalConnection,
1359              NpgsqlEventId.ClosedPhysicalConnection
1360          };
1361          foreach (var id in ids)
1362              Assert.That(listLoggerProvider.Log.Count(l => l.Id == id), Is.Zero);
1363      }
1364      [Test]
1365      public async Task Log_Open_Close_physical()
1366      {
1367          if (IsMultiplexing)
1368              return;
1369          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Pooling = false };
1370          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, csb.ToString());
1371          await using var conn = dataSource.CreateConnection();
1372          int processId, port;
1373          string host, database;
1374          using (listLoggerProvider.Record())
1375          {
1376              await conn.OpenAsync();
1377              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1378              await conn.CloseAsync();
1379          }
1380          var openingConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.OpeningPhysicalConnection);
1381          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1382          AssertLoggingStateContains(openingConnectionEvent, "Host", host);
1383          AssertLoggingStateContains(openingConnectionEvent, "Port", port);
1384          AssertLoggingStateContains(openingConnectionEvent, "Database", database);
1385          var openedConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.OpenedPhysicalConnection);
1386          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1387          AssertLoggingStateContains(openedConnectionEvent, "ConnectorId", processId);
1388          AssertLoggingStateContains(openingConnectionEvent, "Host", host);
1389          AssertLoggingStateContains(openingConnectionEvent, "Port", port);
1390          AssertLoggingStateContains(openingConnectionEvent, "Database", database);
1391          AssertLoggingStateContains(openedConnectionEvent, "DurationMs");
1392          var closingConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.ClosingPhysicalConnection);
1393          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1394          AssertLoggingStateContains(closingConnectionEvent, "ConnectorId", processId);
1395          AssertLoggingStateContains(closingConnectionEvent, "Host", host);
1396          AssertLoggingStateContains(closingConnectionEvent, "Port", port);
1397          AssertLoggingStateContains(closingConnectionEvent, "Database", database);
1398          var closededConnectionEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.ClosedPhysicalConnection);
1399          AssertLoggingConnectionString(conn, closededConnectionEvent.State);
1400          AssertLoggingStateContains(closededConnectionEvent, "ConnectorId", processId);
1401          AssertLoggingStateContains(closededConnectionEvent, "Host", host);
1402          AssertLoggingStateContains(closededConnectionEvent, "Port", port);
1403          AssertLoggingStateContains(closededConnectionEvent, "Database", database);
1404      }
1405      void AssertLoggingConnectionString(NpgsqlConnection connection, object? logState)
1406      {
1407          var keyValuePairs = (IEnumerable<KeyValuePair<string, object?>>)logState!;
1408          var connectionString = keyValuePairs.Single(kvp => kvp.Key == "ConnectionString").Value;
1409          Assert.That(connectionString, Is.EqualTo(connection.ConnectionString));
1410          Assert.That(connectionString, Does.Not.Contain("Password"));
1411      }
1412      #endregion Logging tests
1413      public ConnectionTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1414  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>677          using (listLoggerProvider.Record())
678          {
679              await batch.ExecuteScalarAsync();
680          }
</pre></code></div>
                <div class="column column_space"><pre><code>1320          using (listLoggerProvider.Record())
1321          {
1322              await conn.OpenAsync();
1323              var tx = await conn.BeginTransactionAsync();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    