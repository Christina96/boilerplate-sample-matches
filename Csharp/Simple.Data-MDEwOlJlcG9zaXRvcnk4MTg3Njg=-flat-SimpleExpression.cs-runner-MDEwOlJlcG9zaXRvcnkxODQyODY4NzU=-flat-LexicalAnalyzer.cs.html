
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.766478342749529%, Tokens: 10</h2>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-SimpleExpression.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Generic;
4  using System.Linq;
5  using System.Linq.Expressions;
6  using System.Text;
7  namespace Simple.Data
8  {
9      public class SimpleExpression
10      {
11          public static readonly SimpleExpression Empty = new SimpleEmptyExpression();
12          private readonly object _leftOperand;
13          private readonly object _rightOperand;
14          private readonly SimpleExpressionType _type;
15          public SimpleExpression(object leftOperand, object rightOperand, SimpleExpressionType type)
16          {
17              _leftOperand = leftOperand;
18              _type = type;
19              _rightOperand = rightOperand;
20          }
21          public object LeftOperand
22          {
23              get { return _leftOperand; }
24          }
25          public SimpleExpressionType Type
26          {
27              get { return _type; }
28          }
29          public object RightOperand
30          {
31              get { return _rightOperand; }
32          }
33          public IEnumerable<object> GetValues()
34          {
35              return GetValues(_leftOperand).Concat(GetValues(_rightOperand));
36          }
37          public IEnumerable<T> GetOperandsOfType<T>()
38          {
39              return GetOperandsOfType<T>(_leftOperand).Concat(GetOperandsOfType<T>(_rightOperand));
40          }
41          private IEnumerable<T> GetOperandsOfType<T>(object operand)
42          {
43              var expression = operand as SimpleExpression;
44              if (expression != null)
45              {
46                  return expression.GetOperandsOfType<T>();
47              }
<span onclick='openModal()' class='match'>48              if (operand is T)
49              {
50                  return Yield(operand).Cast<T>();
51              }
52              return Enumerable.Empty<T>();
53          }
54          private static IEnumerable<object> GetValues(object operand)
55          {
</span>56              if (ReferenceEquals(operand, null)) return Yield(null);
57              if (CommonTypes.Contains(operand.GetType())) return Yield(operand);
58              if (operand is SimpleReference)
59              {
60                  return Enumerable.Empty<object>();
61              }
62              var expression = operand as SimpleExpression;
63              if (expression != null)
64              {
65                  return expression.GetValues();
66              }
67              var function = operand as SimpleFunction;
68              if (function != null)
69              {
70                  return function.Args;
71              }
72              return Yield(operand);
73          }
74          private static IEnumerable<object> Yield(object value)
75          {
76              yield return value;
77          }
78          public static SimpleExpression operator &(SimpleExpression left, SimpleExpression right)
79          {
80              if (left == Empty) return right;
81              if (right == Empty) return left;
82              return new SimpleExpression(left, right, SimpleExpressionType.And);
83          }
84          public static SimpleExpression operator |(SimpleExpression left, SimpleExpression right)
85          {
86              if (left == Empty) return right;
87              if (right == Empty) return left;
88              return new SimpleExpression(left, right, SimpleExpressionType.Or);
89          }
90          public static bool operator true(SimpleExpression foo)
91          {
92              return false;
93          }
94          public static bool operator false(SimpleExpression foo)
95          {
96              return false;
97          }
98      }
99  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LexicalAnalyzer.cs</h3>
            <pre><code>1  using GitHub.DistributedTask.Expressions2.Sdk;
2  using System;
3  using System.Collections.Generic;
4  using System.Globalization;
5  using System.Linq;
6  using System.Text;
7  namespace GitHub.DistributedTask.Expressions2.Tokens
8  {
9      internal sealed class LexicalAnalyzer
10      {
11          public LexicalAnalyzer(String expression)
12          {
13              m_expression = expression;
14          }
15          public IEnumerable<Token> UnclosedTokens => m_unclosedTokens;
16          public Boolean TryGetNextToken(ref Token token)
17          {
18              while (m_index < m_expression.Length && Char.IsWhiteSpace(m_expression[m_index]))
19              {
20                  m_index++;
21              }
22              if (m_index >= m_expression.Length)
23              {
24                  token = null;
25                  return false;
26              }
27              var c = m_expression[m_index];
28              switch (c)
29              {
30                  case ExpressionConstants.StartGroup:    
31                      if (m_lastToken?.Kind == TokenKind.Function)
32                      {
33                          token = CreateToken(TokenKind.StartParameters, c, m_index++);
34                      }
35                      else
36                      {
37                          token = CreateToken(TokenKind.StartGroup, c, m_index++);
38                      }
39                      break;
40                  case ExpressionConstants.StartIndex:    
41                      token = CreateToken(TokenKind.StartIndex, c, m_index++);
42                      break;
43                  case ExpressionConstants.EndGroup:      
44                      if (m_unclosedTokens.FirstOrDefault()?.Kind == TokenKind.StartParameters) 
45                      {
46                          token = CreateToken(TokenKind.EndParameters, c, m_index++);
47                      }
48                      else
49                      {
50                          token = CreateToken(TokenKind.EndGroup, c, m_index++);
51                      }
52                      break;
53                  case ExpressionConstants.EndIndex:      
54                      token = CreateToken(TokenKind.EndIndex, c, m_index++);
55                      break;
56                  case ExpressionConstants.Separator:     
57                      token = CreateToken(TokenKind.Separator, c, m_index++);
58                      break;
59                  case ExpressionConstants.Wildcard:      
60                      token = CreateToken(TokenKind.Wildcard, c, m_index++);
61                      break;
62                  case '\'':
63                      token = ReadStringToken();
64                      break;
65                  case '!':   
66                  case '>':   
67                  case '<':   
68                  case '=':   
69                  case '&':   
70                  case '|':   
71                      token = ReadOperator();
72                      break;
73                  default:
74                      if (c == '.')
75                      {
76                          if (m_lastToken == null ||
77                              m_lastToken.Kind == TokenKind.Separator ||          
78                              m_lastToken.Kind == TokenKind.StartGroup ||         
79                              m_lastToken.Kind == TokenKind.StartIndex ||         
80                              m_lastToken.Kind == TokenKind.StartParameters ||    
81                              m_lastToken.Kind == TokenKind.LogicalOperator)      
82                          {
83                              token = ReadNumberToken();
84                          }
85                          else
86                          {
87                              token = CreateToken(TokenKind.Dereference, c, m_index++);
88                          }
89                      }
90                      else if (c == '-' || c == '+' || (c >= '0' && c <= '9'))
91                      {
92                          token = ReadNumberToken();
93                      }
94                      else
95                      {
96                          token = ReadKeywordToken();
97                      }
98                      break;
99              }
100              m_lastToken = token;
101              return true;
102          }
103          private Token ReadNumberToken()
104          {
105              var startIndex = m_index;
106              do
107              {
108                  m_index++;
109              }
110              while (m_index < m_expression.Length && (!TestTokenBoundary(m_expression[m_index]) || m_expression[m_index] == '.'));
111              var length = m_index - startIndex;
112              var str = m_expression.Substring(startIndex, length);
113              var d = ExpressionUtility.ParseNumber(str);
114              if (Double.IsNaN(d))
115              {
116                  return CreateToken(TokenKind.Unexpected, str, startIndex);
117              }
118              return CreateToken(TokenKind.Number, str, startIndex, d);
119          }
120          private Token ReadKeywordToken()
121          {
122              var startIndex = m_index;
123              m_index++; 
124              while (m_index < m_expression.Length && !TestTokenBoundary(m_expression[m_index]))
125              {
126                  m_index++;
127              }
128              var length = m_index - startIndex;
129              var str = m_expression.Substring(startIndex, length);
130              if (ExpressionUtility.IsLegalKeyword(str))
131              {
132                  if (m_lastToken != null && m_lastToken.Kind == TokenKind.Dereference)
133                  {
134                      return CreateToken(TokenKind.PropertyName, str, startIndex);
135                  }
136                  if (str.Equals(ExpressionConstants.Null, StringComparison.Ordinal))
137                  {
138                      return CreateToken(TokenKind.Null, str, startIndex);
139                  }
140                  else if (str.Equals(ExpressionConstants.True, StringComparison.Ordinal))
141                  {
142                      return CreateToken(TokenKind.Boolean, str, startIndex, true);
143                  }
144                  else if (str.Equals(ExpressionConstants.False, StringComparison.Ordinal))
145                  {
146                      return CreateToken(TokenKind.Boolean, str, startIndex, false);
147                  }
148                  else if (str.Equals(ExpressionConstants.NaN, StringComparison.Ordinal))
149                  {
150                      return CreateToken(TokenKind.Number, str, startIndex, Double.NaN);
151                  }
152                  else if (str.Equals(ExpressionConstants.Infinity, StringComparison.Ordinal))
153                  {
154                      return CreateToken(TokenKind.Number, str, startIndex, Double.PositiveInfinity);
155                  }
156                  var tempIndex = m_index;
157                  while (tempIndex < m_expression.Length && Char.IsWhiteSpace(m_expression[tempIndex]))
158                  {
159                      tempIndex++;
160                  }
161                  if (tempIndex < m_expression.Length && m_expression[tempIndex] == ExpressionConstants.StartGroup)   
162                  {
163                      return CreateToken(TokenKind.Function, str, startIndex);
164                  }
165                  else
166                  {
167                      return CreateToken(TokenKind.NamedValue, str, startIndex);
168                  }
169              }
170              else
171              {
172                  return CreateToken(TokenKind.Unexpected, str, startIndex);
173              }
174          }
175          private Token ReadStringToken()
176          {
177              var startIndex = m_index;
178              var c = default(Char);
179              var closed = false;
180              var str = new StringBuilder();
181              m_index++; 
182              while (m_index < m_expression.Length)
183              {
184                  c = m_expression[m_index++];
185                  if (c == '\'')
186                  {
187                      if (m_index >= m_expression.Length || m_expression[m_index] != '\'')
188                      {
189                          closed = true;
190                          break;
191                      }
192                      m_index++;
193                  }
194                  str.Append(c);
195              }
196              var length = m_index - startIndex;
197              var rawValue = m_expression.Substring(startIndex, length);
<span onclick='openModal()' class='match'>198              if (closed)
199              {
200                  return CreateToken(TokenKind.String, rawValue, startIndex, str.ToString());
201              }
202              return CreateToken(TokenKind.Unexpected, rawValue, startIndex);
203          }
204          private Token ReadOperator()
205          {
</span>206              var startIndex = m_index;
207              var raw = default(String);
208              m_index++;
209              if (m_index < m_expression.Length)
210              {
211                  m_index++;
212                  raw = m_expression.Substring(startIndex, 2);
213                  switch (raw)
214                  {
215                      case ExpressionConstants.NotEqual:
216                      case ExpressionConstants.GreaterThanOrEqual:
217                      case ExpressionConstants.LessThanOrEqual:
218                      case ExpressionConstants.Equal:
219                      case ExpressionConstants.And:
220                      case ExpressionConstants.Or:
221                          return CreateToken(TokenKind.LogicalOperator, raw, startIndex);
222                  }
223                  m_index--;
224              }
225              raw = m_expression.Substring(startIndex, 1);
226              switch (raw)
227              {
228                  case ExpressionConstants.Not:
229                  case ExpressionConstants.GreaterThan:
230                  case ExpressionConstants.LessThan:
231                      return CreateToken(TokenKind.LogicalOperator, raw, startIndex);
232              }
233              while (m_index < m_expression.Length && !TestTokenBoundary(m_expression[m_index]))
234              {
235                  m_index++;
236              }
237              var length = m_index - startIndex;
238              raw = m_expression.Substring(startIndex, length);
239              return CreateToken(TokenKind.Unexpected, raw, startIndex);
240          }
241          private static Boolean TestTokenBoundary(Char c)
242          {
243              switch (c)
244              {
245                  case ExpressionConstants.StartGroup:    
246                  case ExpressionConstants.StartIndex:    
247                  case ExpressionConstants.EndGroup:      
248                  case ExpressionConstants.EndIndex:      
249                  case ExpressionConstants.Separator:     
250                  case ExpressionConstants.Dereference:   
251                  case '!': 
252                  case '>': 
253                  case '<': 
254                  case '=': 
255                  case '&': 
256                  case '|': 
257                      return true;
258                  default:
259                      return char.IsWhiteSpace(c);
260              }
261          }
262          private Token CreateToken(
263              TokenKind kind,
264              Char rawValue,
265              Int32 index,
266              Object parsedValue = null)
267          {
268              return CreateToken(kind, rawValue.ToString(), index, parsedValue);
269          }
270          private Token CreateToken(
271              TokenKind kind,
272              String rawValue,
273              Int32 index,
274              Object parsedValue = null)
275          {
276              var legal = false;
277              switch (kind)
278              {
279                  case TokenKind.StartGroup:      
280                      legal = CheckLastToken(null, TokenKind.Separator, TokenKind.StartGroup, TokenKind.StartParameters, TokenKind.StartIndex, TokenKind.LogicalOperator);
281                      break;
282                  case TokenKind.StartIndex:      
283                      legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.PropertyName, TokenKind.NamedValue);
284                      break;
285                  case TokenKind.StartParameters: 
286                      legal = CheckLastToken(TokenKind.Function);
287                      break;
288                  case TokenKind.EndGroup:        
289                      legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.Null, TokenKind.Boolean, TokenKind.Number, TokenKind.String, TokenKind.PropertyName, TokenKind.NamedValue);
290                      break;
291                  case TokenKind.EndIndex:        
292                      legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.Null, TokenKind.Boolean, TokenKind.Number, TokenKind.String, TokenKind.PropertyName, TokenKind.NamedValue);
293                      break;
294                  case TokenKind.EndParameters:   
295                      legal = CheckLastToken(TokenKind.StartParameters, TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.Null, TokenKind.Boolean, TokenKind.Number, TokenKind.String, TokenKind.PropertyName, TokenKind.NamedValue);
296                      break;
297                  case TokenKind.Separator:       
298                      legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.Null, TokenKind.Boolean, TokenKind.Number, TokenKind.String, TokenKind.PropertyName, TokenKind.NamedValue);
299                      break;
300                  case TokenKind.Dereference:     
301                      legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.PropertyName, TokenKind.NamedValue);
302                      break;
303                  case TokenKind.Wildcard:        
304                      legal = CheckLastToken(TokenKind.StartIndex, TokenKind.Dereference);
305                      break;
306                  case TokenKind.LogicalOperator: 
307                      switch (rawValue)
308                      {
309                          case ExpressionConstants.Not:
310                              legal = CheckLastToken(null, TokenKind.Separator, TokenKind.StartGroup, TokenKind.StartParameters, TokenKind.StartIndex, TokenKind.LogicalOperator);
311                              break;
312                          default:
313                              legal = CheckLastToken(TokenKind.EndGroup, TokenKind.EndParameters, TokenKind.EndIndex, TokenKind.Wildcard, TokenKind.Null, TokenKind.Boolean, TokenKind.Number, TokenKind.String, TokenKind.PropertyName, TokenKind.NamedValue);
314                              break;
315                      }
316                      break;
317                  case TokenKind.Null:
318                  case TokenKind.Boolean:
319                  case TokenKind.Number:
320                  case TokenKind.String:
321                      legal = CheckLastToken(null, TokenKind.Separator, TokenKind.StartIndex, TokenKind.StartGroup, TokenKind.StartParameters, TokenKind.LogicalOperator);
322                      break;
323                  case TokenKind.PropertyName:
324                      legal = CheckLastToken(TokenKind.Dereference);
325                      break;
326                  case TokenKind.Function:
327                      legal = CheckLastToken(null, TokenKind.Separator, TokenKind.StartIndex, TokenKind.StartGroup, TokenKind.StartParameters, TokenKind.LogicalOperator);
328                      break;
329                  case TokenKind.NamedValue:
330                      legal = CheckLastToken(null, TokenKind.Separator, TokenKind.StartIndex, TokenKind.StartGroup, TokenKind.StartParameters, TokenKind.LogicalOperator);
331                      break;
332              }
333              if (!legal)
334              {
335                  return new Token(TokenKind.Unexpected, rawValue, index);
336              }
337              var token = new Token(kind, rawValue, index, parsedValue);
338              switch (kind)
339              {
340                  case TokenKind.StartGroup:      
341                  case TokenKind.StartIndex:      
342                  case TokenKind.StartParameters: 
343                      m_unclosedTokens.Push(token);
344                      break;
345                  case TokenKind.EndGroup:        
346                      if (m_unclosedTokens.FirstOrDefault()?.Kind != TokenKind.StartGroup)
347                      {
348                          return new Token(TokenKind.Unexpected, rawValue, index);
349                      }
350                      m_unclosedTokens.Pop();
351                      break;
352                  case TokenKind.EndIndex:        
353                      if (m_unclosedTokens.FirstOrDefault()?.Kind != TokenKind.StartIndex)
354                      {
355                          return new Token(TokenKind.Unexpected, rawValue, index);
356                      }
357                      m_unclosedTokens.Pop();
358                      break;
359                  case TokenKind.EndParameters:   
360                      if (m_unclosedTokens.FirstOrDefault()?.Kind != TokenKind.StartParameters)
361                      {
362                          return new Token(TokenKind.Unexpected, rawValue, index);
363                      }
364                      m_unclosedTokens.Pop();
365                      break;
366                  case TokenKind.Separator:       
367                      if (m_unclosedTokens.FirstOrDefault()?.Kind != TokenKind.StartParameters)
368                      {
369                          return new Token(TokenKind.Unexpected, rawValue, index);
370                      }
371                      break;
372              }
373              return token;
374          }
375          private Boolean CheckLastToken(params TokenKind?[] allowed)
376          {
377              var lastKind = m_lastToken?.Kind;
378              foreach (var kind in allowed)
379              {
380                  if (kind == lastKind)
381                  {
382                      return true;
383                  }
384              }
385              return false;
386          }
387          private readonly String m_expression; 
388          private readonly Stack<Token> m_unclosedTokens = new Stack<Token>(); 
389          private Int32 m_index; 
390          private Token m_lastToken;
391      }
392  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-SimpleExpression.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LexicalAnalyzer.cs</div>
                <div class="column column_space"><pre><code>48              if (operand is T)
49              {
50                  return Yield(operand).Cast<T>();
51              }
52              return Enumerable.Empty<T>();
53          }
54          private static IEnumerable<object> GetValues(object operand)
55          {
</pre></code></div>
                <div class="column column_space"><pre><code>198              if (closed)
199              {
200                  return CreateToken(TokenKind.String, rawValue, startIndex, str.ToString());
201              }
202              return CreateToken(TokenKind.Unexpected, rawValue, startIndex);
203          }
204          private Token ReadOperator()
205          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    