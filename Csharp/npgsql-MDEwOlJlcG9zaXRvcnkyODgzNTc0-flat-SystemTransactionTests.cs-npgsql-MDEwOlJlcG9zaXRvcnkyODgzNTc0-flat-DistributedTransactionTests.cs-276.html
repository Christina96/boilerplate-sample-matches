
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTransactionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading;
4  using System.Transactions;
5  using NUnit.Framework;
6  using static Npgsql.Tests.TestUtil;
7  namespace Npgsql.Tests;
8  public class SystemTransactionTests : TestBase
9  {
10      [Test, Description(&quot;Single connection enlisting explicitly, committing&quot;)]
11      public void Explicit_enlist()
12      {
13          var dataSource = EnlistOffDataSource;
14          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
15          using var conn = dataSource.OpenConnection();
16          using (var scope = new TransactionScope())
17          {
18              conn.EnlistTransaction(Transaction.Current);
19              Assert.That(conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
20              AssertNoDistributedIdentifier();
21              AssertNoPreparedTransactions();
22              scope.Complete();
23          }
24          AssertNoDistributedIdentifier();
25          AssertNoPreparedTransactions();
26          using (var tx = conn.BeginTransaction())
27          {
28              Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(1), &quot;Unexpected data count&quot;);
29              tx.Rollback();
30          }
31      }
32      [Test, Description(&quot;Single connection enlisting implicitly, committing&quot;)]
33      public void Implicit_enlist()
34      {
35          var dataSource = EnlistOnDataSource;
36          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
37          using var conn = dataSource.CreateConnection();
38          using (var scope = new TransactionScope())
39          {
40              conn.Open();
41              Assert.That(conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
42              AssertNoDistributedIdentifier();
43              AssertNoPreparedTransactions();
44              scope.Complete();
45          }
46          using (var tx = conn.BeginTransaction())
47          {
48              Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(1), &quot;Unexpected data count&quot;);
49              tx.Rollback();
50          }
51      }
52      [Test]
53      public void Enlist_Off()
54      {
55          var dataSource = EnlistOffDataSource;
56          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
57          using (new TransactionScope())
58          using (var conn1 = dataSource.OpenConnection())
59          using (var conn2 = dataSource.OpenConnection())
60          {
61              Assert.That(conn1.EnlistedTransaction, Is.Null);
62              Assert.That(conn1.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
63              Assert.That(conn2.ExecuteScalar($&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(1), &quot;Unexpected data count&quot;);
64          }
65          using (var conn3 = dataSource.OpenConnection())
66          {
67              Assert.That(conn3.ExecuteScalar($&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(1), &quot;Insert unexpectedly rollback-ed&quot;);
68          }
69      }
70      [Test, Description(&quot;Single connection enlisting explicitly, rollback&quot;)]
71      public void Rollback_explicit_enlist()
72      {
73          using var dataSource = CreateDataSource();
74          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
75          using var conn = dataSource.OpenConnection();
76          using (new TransactionScope())
77          {
78              conn.EnlistTransaction(Transaction.Current);
79              Assert.That(conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
80          }
81          AssertNoDistributedIdentifier();
82          AssertNoPreparedTransactions();
83          using (var tx = conn.BeginTransaction())
84          {
85              Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(0), &quot;Unexpected data count&quot;);
86              tx.Rollback();
87          }
88      }
89      [Test, Description(&quot;Single connection enlisting implicitly, rollback&quot;)]
90      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2408&quot;)]
91      public void Rollback_implicit_enlist([Values(true, false)] bool pooling)
92      {
93          using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = pooling);
94          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
95          using (new TransactionScope())
96          using (var conn = dataSource.OpenConnection())
97          {
98              Assert.That(conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
99              AssertNoDistributedIdentifier();
100              AssertNoPreparedTransactions();
101          }
102          AssertNumberOfRows(0, tableName);
103      }
104      [Test]
105      public void Two_consecutive_connections()
106      {
107          var dataSource = EnlistOnDataSource;
108          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
109          using (var scope = new TransactionScope())
110          {
111              using (var conn1 = dataSource.OpenConnection())
112              {
113                  Assert.That(conn1.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test1&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected first insert rowcount&quot;);
114              }
115              using (var conn2 = dataSource.OpenConnection())
116              {
117                  Assert.That(conn2.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test2&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected second insert rowcount&quot;);
118              }
119              AssertNoDistributedIdentifier();
120              AssertNoPreparedTransactions();
121              scope.Complete();
122          }
123          AssertNumberOfRows(2, tableName);
124      }
125      [Test]
126      public void Close_connection()
127      {
128          using var dataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
129          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
130          using (var scope = new TransactionScope())
131          using (var conn = dataSource.OpenConnection())
132          {
133              Assert.That(conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected insert rowcount&quot;);
134              conn.Close();
135              AssertNoDistributedIdentifier();
136              AssertNoPreparedTransactions();
137              scope.Complete();
138          }
139          AssertNumberOfRows(1, tableName);
140          Assert.That(dataSource.Statistics.Idle, Is.EqualTo(1));
141      }
142      [Test]
143      public void Enlist_to_two_transactions()
144      {
145          var dataSource = EnlistOffDataSource;
146          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
147          using var conn = dataSource.OpenConnection();
148          var ctx = new CommittableTransaction();
149          conn.EnlistTransaction(ctx);
150          Assert.That(() =&gt; conn.EnlistTransaction(new CommittableTransaction()), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
151          ctx.Rollback();
152          using var tx = conn.BeginTransaction();
153          Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(0));
154          tx.Rollback();
155      }
156      [Test]
157      public void Enlist_twice_to_same_transaction()
158      {
159          var dataSource = EnlistOffDataSource;
160          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
161          using var conn = dataSource.OpenConnection();
162          var ctx = new CommittableTransaction();
163          conn.EnlistTransaction(ctx);
164          conn.EnlistTransaction(ctx);
165          ctx.Rollback();
166          using var tx = conn.BeginTransaction();
167          Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(0));
168          tx.Rollback();
169      }
170      [Test]
171      public void Scope_after_scope()
172      {
173          var dataSource = EnlistOffDataSource;
174          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
175          using var conn = dataSource.OpenConnection();
176          using (new TransactionScope())
177              conn.EnlistTransaction(Transaction.Current);
178          using (new TransactionScope())
179              conn.EnlistTransaction(Transaction.Current);
180          using (var tx = conn.BeginTransaction())
181          {
182              Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(0));
183              tx.Rollback();
184          }
185      }
186      [Test]
187      public void Reuse_connection()
188      {
189          using var dataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
190          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
191          using (var scope = new TransactionScope())
192          using (var conn = dataSource.CreateConnection())
193          {
194              conn.Open();
195              var processId = conn.ProcessID;
196              conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test1&#x27;)&quot;);
197              conn.Close();
198              conn.Open();
199              Assert.That(conn.ProcessID, Is.EqualTo(processId));
200              conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test2&#x27;)&quot;);
201              conn.Close();
202              scope.Complete();
203          }
204          AssertNumberOfRows(2, tableName);
205      }
206      [Test]
207      public void Reuse_connection_rollback()
208      {
209          using var dataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
210          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
211          using (new TransactionScope())
212          using (var conn = dataSource.CreateConnection())
213          {
214              conn.Open();
215              var processId = conn.ProcessID;
216              conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test1&#x27;)&quot;);
217              conn.Close();
218              conn.Open();
219              Assert.That(conn.ProcessID, Is.EqualTo(processId));
220              conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test2&#x27;)&quot;);
221              conn.Close();
222          }
223          AssertNumberOfRows(0, tableName);
224      }
225      [Test, Ignore(&quot;Timeout doesn&#x27;t seem to fire on .NET Core / Linux&quot;)]
226      public void Timeout_triggers_rollback_while_busy()
227      {
228          var dataSource = EnlistOffDataSource;
229          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
230          using (var conn = dataSource.OpenConnection())
231          {
232              using (new TransactionScope(TransactionScopeOption.Required, TimeSpan.FromSeconds(1)))
233              {
234                  conn.EnlistTransaction(Transaction.Current);
235                  Assert.That(() =&gt; CreateSleepCommand(conn, 5).ExecuteNonQuery(),
236                      Throws.Exception.TypeOf&lt;PostgresException&gt;()
237                          .With.Property(nameof(PostgresException.SqlState))
238                          .EqualTo(PostgresErrorCodes.QueryCanceled));
239              }
240          }
241          AssertNumberOfRows(0, tableName);
242      }
243      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1579&quot;)]
244      public void Schema_connection_should_not_enlist()
245      {
246          var dataSource = EnlistOnDataSource;
247          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
248          using var tran = new TransactionScope();
249          using var conn = dataSource.OpenConnection();
250          using var cmd = new NpgsqlCommand($&quot;SELECT * FROM {tableName}&quot;, conn);
251          using var reader = cmd.ExecuteReader(CommandBehavior.KeyInfo);
252          reader.GetColumnSchema();
253          AssertNoDistributedIdentifier();
254          AssertNoPreparedTransactions();
255          tran.Complete();
256      }
257      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1737&quot;)]
258      public void Single_unpooled_connection()
259      {
260          using var dataSource = CreateDataSource(csb =&gt;
261          {
262              csb.Pooling = false;
263              csb.Enlist = true;
264          });
265          using var scope = new TransactionScope();
266          using (var conn = dataSource.OpenConnection())
267          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
268              cmd.ExecuteNonQuery();
269          scope.Complete();
270      }
271      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4963&quot;)]
272      public void Single_unpooled_closed_connection()
273      {
274          using var dataSource = CreateDataSource(csb =&gt;
275          {
276              csb.Pooling = false;
277              csb.Enlist = true;
278          });
279          using (var scope = new TransactionScope())
280          using (var conn = dataSource.OpenConnection())
281          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
282          {
283              cmd.ExecuteNonQuery();
284              conn.Close();
285              Assert.That(dataSource.Statistics.Total, Is.EqualTo(1));
286              scope.Complete();
287          }
288          Assert.That(dataSource.Statistics.Total, Is.EqualTo(0));
289      }
290      [Test]
291      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3863&quot;)]
292      public void Break_connector_while_in_transaction_scope_with_rollback([Values] bool pooling)
293      {
294          using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = pooling);
295          using var scope = new TransactionScope();
296          var conn = dataSource.OpenConnection();
297          conn.ExecuteNonQuery(&quot;SELECT 1&quot;);
298          conn.Connector!.Break(new Exception(nameof(Break_connector_while_in_transaction_scope_with_rollback)));
299      }
300      [Test]
301      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3863&quot;)]
302      public void Break_connector_while_in_transaction_scope_with_commit([Values] bool pooling)
303      {
304          using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = pooling);
305          var ex = Assert.Throws&lt;TransactionInDoubtException&gt;(() =&gt;
306          {
307              using var scope = new TransactionScope();
308              var conn = dataSource.OpenConnection();
309              conn.ExecuteNonQuery(&quot;SELECT 1&quot;);
310              conn.Connector!.Break(new Exception(nameof(Break_connector_while_in_transaction_scope_with_commit)));
311              scope.Complete();
312          })!;
313          Assert.That(ex.InnerException, Is.TypeOf&lt;ObjectDisposedException&gt;());
314          Assert.That(ex.InnerException!.InnerException, Is.TypeOf&lt;Exception&gt;());
315          Assert.That(ex.InnerException!.InnerException!.Message, Is.EqualTo(nameof(Break_connector_while_in_transaction_scope_with_commit)));
316      }
317      [Test]
318      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4085&quot;)]
319      public void Open_connection_with_enlist_and_aborted_TransactionScope()
320      {
321          var dataSource = EnlistOnDataSource;
322          for (var i = 0; i &lt; 2; i++)
323          {
324              using var outerScope = new TransactionScope();
325              try
326              {
327                  using var innerScope = new TransactionScope();
328                  throw new Exception(&quot;Random exception to abort the transaction scope&quot;);
329              }
330              catch (Exception)
331              {
332              }
333              var ex = Assert.Throws&lt;TransactionException&gt;(() =&gt; dataSource.OpenConnection())!;
334              Assert.That(ex.Message, Is.EqualTo(&quot;The operation is not valid for the state of the transaction.&quot;));
335          }
336      }
337      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1594&quot;)]
338      public void Bug1594()
339      {
340          var dataSource = EnlistOnDataSource;
341          var tableName = CreateTempTable(dataSource, &quot;name TEXT&quot;);
342          using var outerScope = new TransactionScope();
343          using (var conn = dataSource.OpenConnection())
344          using (var innerScope1 = new TransactionScope())
345          {
346              conn.ExecuteNonQuery(@$&quot;INSERT INTO {tableName} (name) VALUES (&#x27;test1&#x27;)&quot;);
347              innerScope1.Complete();
348          }
349          using (dataSource.OpenConnection())
350          using (new TransactionScope())
351          {
352          }
353      }
354      #region Utilities
355      void AssertNoPreparedTransactions()
356          =&gt; Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), &quot;Prepared transactions found&quot;);
357      int GetNumberOfPreparedTransactions()
358      {
359          var dataSource = EnlistOffDataSource;
360          using var conn = dataSource.OpenConnection();
361          using var cmd = new NpgsqlCommand(&quot;SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database&quot;, conn);
362          cmd.Parameters.Add(new NpgsqlParameter(&quot;database&quot;, conn.Database));
363          return (int)(long)cmd.ExecuteScalar()!;
364      }
365      void AssertNumberOfRows(int expected, string tableName)
366      {
367          using var conn = OpenConnection();
368          Assert.That(conn.ExecuteScalar(@$&quot;SELECT COUNT(*) FROM {tableName}&quot;), Is.EqualTo(expected), &quot;Unexpected data count&quot;);
369      }
370      static void AssertNoDistributedIdentifier()
371          =&gt; Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), &quot;Distributed identifier found&quot;);
372      #endregion Utilities
373      #region Setup
374      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
375      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
376      [OneTimeSetUp]
377      public void OneTimeSetUp()
378      {
379          EnlistOnDataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
<span onclick='openModal()' class='match'>380          EnlistOffDataSource = CreateDataSource(csb =&gt; csb.Enlist = false);
381      }
382      [OneTimeTearDown]
383      public void OnTimeTearDown()
384      {
385          EnlistOnDataSource?.Dispose();
386          EnlistOnDataSource = null!;
387          EnlistOffDataSource?.Dispose();
388          EnlistOffDataSource = null!;
389      }
390      internal static string CreateTempTable(NpgsqlDataSource dataSource, string columns)
</span>391      {
392          var tableName = &quot;temp_table&quot; + Interlocked.Increment(ref _tempTableCounter);
393          dataSource.ExecuteNonQuery(@$&quot;
394  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
395  DROP TABLE IF EXISTS {tableName} CASCADE;
396  COMMIT;
397  CREATE TABLE {tableName} ({columns})&quot;);
398          return tableName;
399      }
400      #endregion
401  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</h3>
            <pre><code>1  #if NET7_0_OR_GREATER
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Runtime.InteropServices;
6  using System.Text;
7  using System.Threading;
8  using System.Transactions;
9  using NUnit.Framework;
10  using static Npgsql.Tests.TestUtil;
11  namespace Npgsql.Tests;
12  [NonParallelizable]
13  public class DistributedTransactionTests : TestBase
14  {
15      [Test]
16      public void Two_connections_rollback_implicit_enlistment()
17      {
18          using var adminConn = OpenConnection();
19          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
20          var dataSource = EnlistOnDataSource;
21          using (new TransactionScope())
22          using (var conn1 = dataSource.OpenConnection())
23          using (var conn2 = dataSource.OpenConnection())
24          {
25              conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
26              conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
27          }
28          Retry(() =&gt;
29          {
30              AssertNoDistributedIdentifier();
31              AssertNoPreparedTransactions();
32              AssertNumberOfRows(adminConn, table, 0);
33          });
34      }
35      [Test]
36      public void Two_connections_rollback_explicit_enlistment()
37      {
38          using var adminConn = OpenConnection();
39          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
40          var dataSource = EnlistOffDataSource;
41          using (var conn1 = dataSource.OpenConnection())
42          using (var conn2 = dataSource.OpenConnection())
43          using (new TransactionScope())
44          {
45              conn1.EnlistTransaction(Transaction.Current);
46              conn2.EnlistTransaction(Transaction.Current);
47              Assert.That(conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected first insert rowcount&quot;);
48              Assert.That(conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected second insert rowcount&quot;);
49          }
50          Retry(() =&gt;
51          {
52              AssertNoDistributedIdentifier();
53              AssertNoPreparedTransactions();
54              AssertNumberOfRows(adminConn, table, 0);
55          });
56      }
57      [Test]
58      public void Two_connections_commit()
59      {
60          using var adminConn = OpenConnection();
61          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
62          var dataSource = EnlistOnDataSource;
63          using (var scope = new TransactionScope())
64          using (var conn1 = dataSource.OpenConnection())
65          using (var conn2 = dataSource.OpenConnection())
66          {
67              conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
68              conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
69              scope.Complete();
70          }
71          Retry(() =&gt;
72          {
73              AssertNoDistributedIdentifier();
74              AssertNoPreparedTransactions();
75              AssertNumberOfRows(adminConn, table, 2);
76          });
77      }
78      [Test]
79      public void Two_connections_with_failure()
80      {
81          using var dataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
82          using var adminConn = dataSource.OpenConnection();
83          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
84          using var scope = new TransactionScope();
85          using var conn1 = dataSource.OpenConnection();
86          using var conn2 = dataSource.OpenConnection();
87          conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
88          conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
89          conn1.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn2.ProcessID})&quot;);
90          scope.Complete();
91          Assert.That(() =&gt; scope.Dispose(), Throws.Exception.TypeOf&lt;TransactionAbortedException&gt;());
92          AssertNoDistributedIdentifier();
93          AssertNoPreparedTransactions();
94          AssertNumberOfRows(adminConn, table, 0);
95      }
96      [Test(Description = &quot;Transaction race, bool distributed&quot;)]
97      [Explicit(&quot;Fails on Appveyor (https:&amp;bsol;&amp;bsol;ci.appveyor.com/project/roji/npgsql/build/3.3.0-250)&quot;)]
98      public void Transaction_race([Values(false, true)] bool distributed)
99      {
100          using var adminConn = OpenConnection();
101          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
102          var dataSource = EnlistOnDataSource;
103          for (var i = 1; i &lt;= 100; i++)
104          {
105              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
106              try
107              {
108                  using (var tx = new TransactionScope())
109                  using (var conn1 = dataSource.OpenConnection())
110                  {
111                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
112                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
113                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
114                      if (distributed)
115                      {
116                          EnlistResource.EscalateToDistributed(eventQueue);
117                          AssertHasDistributedIdentifier();
118                      }
119                      else
120                      {
121                          EnlistResource.EnlistVolatile(eventQueue);
122                          AssertNoDistributedIdentifier();
123                      }
124                      tx.Complete();
125                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope completed&quot;));
126                  }
127                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
128                  AssertNoDistributedIdentifier();
129                  if (distributed)
130                  {
131                      const int maxLoop = 20;
132                      for (var j = 0; j &lt; maxLoop; j++)
133                      {
134                          Thread.Sleep(10);
135                          try
136                          {
137                              AssertNumberOfRows(adminConn, table, i);
138                              break;
139                          }
140                          catch
141                          {
142                              if (j == maxLoop - 1)
143                                  throw;
144                          }
145                      }
146                  }
147                  else
148                      AssertNumberOfRows(adminConn, table, i);
149              }
150              catch (Exception ex)
151              {
152                  Assert.Fail(
153                      @&quot;Failed at iteration {0}.
154  Events:
155  {1}
156  Exception {2}&quot;,
157                      i, FormatEventQueue(eventQueue), ex);
158              }
159          }
160      }
161      [Test(Description = &quot;Connection reuse race after transaction, bool distributed&quot;), Explicit]
162      public void Connection_reuse_race_after_transaction([Values(false, true)] bool distributed)
163      {
164          using var adminConn = OpenConnection();
165          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
166          var dataSource = EnlistOffDataSource;
167          for (var i = 1; i &lt;= 100; i++)
168          {
169              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
170              try
171              {
172                  using var conn1 = dataSource.OpenConnection();
173                  using (var scope = new TransactionScope())
174                  {
175                      conn1.EnlistTransaction(Transaction.Current);
176                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
177                      if (distributed)
178                      {
179                          EnlistResource.EscalateToDistributed(eventQueue);
180                          AssertHasDistributedIdentifier();
181                      }
182                      else
183                      {
184                          EnlistResource.EnlistVolatile(eventQueue);
185                          AssertNoDistributedIdentifier();
186                      }
187                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
188                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
189                      scope.Complete();
190                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope completed&quot;));
191                  }
192                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
193                  Assert.DoesNotThrow(() =&gt; conn1.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;));
194              }
195              catch (Exception ex)
196              {
197                  Assert.Fail(
198                      @&quot;Failed at iteration {0}.
199  Events:
200  {1}
201  Exception {2}&quot;,
202                      i, FormatEventQueue(eventQueue), ex);
203              }
204          }
205      }
206      [Test(Description = &quot;Connection reuse race after rollback, bool distributed&quot;), Explicit(&quot;Currently failing.&quot;)]
207      public void Connection_reuse_race_after_rollback([Values(false, true)] bool distributed)
208      {
209          using var adminConn = OpenConnection();
210          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
211          var dataSource = EnlistOffDataSource;
212          for (var i = 1; i &lt;= 100; i++)
213          {
214              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
215              try
216              {
217                  using var conn1 = dataSource.OpenConnection();
218                  using (new TransactionScope())
219                  {
220                      conn1.EnlistTransaction(Transaction.Current);
221                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
222                      if (distributed)
223                      {
224                          EnlistResource.EscalateToDistributed(eventQueue);
225                          AssertHasDistributedIdentifier();
226                      }
227                      else
228                      {
229                          EnlistResource.EnlistVolatile(eventQueue);
230                          AssertNoDistributedIdentifier();
231                      }
232                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
233                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
234                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope not completed&quot;));
235                  }
236                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
237                  conn1.EnlistTransaction(null);
238                  eventQueue.Enqueue(new TransactionEvent(&quot;Connection enlisted with null&quot;));
239                  Assert.DoesNotThrow(() =&gt; conn1.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;));
240              }
241              catch (Exception ex)
242              {
243                  Assert.Fail(
244                      @&quot;Failed at iteration {0}.
245  Events:
246  {1}
247  Exception {2}&quot;,
248                      i, FormatEventQueue(eventQueue), ex);
249              }
250          }
251      }
252      [Test(Description = &quot;Connection reuse race chaining transactions, bool distributed&quot;)]
253      [Explicit]
254      public void Connection_reuse_race_chaining_transaction([Values(false, true)] bool distributed)
255      {
256          using var adminConn = OpenConnection();
257          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
258          var dataSource = EnlistOffDataSource;
259          for (var i = 1; i &lt;= 100; i++)
260          {
261              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
262              try
263              {
264                  using var conn1 = dataSource.OpenConnection();
265                  using (var scope = new TransactionScope())
266                  {
267                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope started&quot;));
268                      conn1.EnlistTransaction(Transaction.Current);
269                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope, connection enlisted&quot;));
270                      if (distributed)
271                      {
272                          EnlistResource.EscalateToDistributed(eventQueue);
273                          AssertHasDistributedIdentifier();
274                      }
275                      else
276                      {
277                          EnlistResource.EnlistVolatile(eventQueue);
278                          AssertNoDistributedIdentifier();
279                      }
280                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
281                      eventQueue.Enqueue(new TransactionEvent(&quot;First insert done&quot;));
282                      scope.Complete();
283                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope completed&quot;));
284                  }
285                  eventQueue.Enqueue(new TransactionEvent(&quot;First scope disposed&quot;));
286                  using (var scope = new TransactionScope())
287                  {
288                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope started&quot;));
289                      conn1.EnlistTransaction(Transaction.Current);
290                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope, connection enlisted&quot;));
291                      if (distributed)
292                      {
293                          EnlistResource.EscalateToDistributed(eventQueue);
294                          AssertHasDistributedIdentifier();
295                      }
296                      else
297                      {
298                          EnlistResource.EnlistVolatile(eventQueue);
299                          AssertNoDistributedIdentifier();
300                      }
301                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
302                      eventQueue.Enqueue(new TransactionEvent(&quot;Second insert done&quot;));
303                      scope.Complete();
304                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope completed&quot;));
305                  }
306                  eventQueue.Enqueue(new TransactionEvent(&quot;Second scope disposed&quot;));
307              }
308              catch (Exception ex)
309              {
310                  Assert.Fail(
311                      @&quot;Failed at iteration {0}.
312  Events:
313  {1}
314  Exception {2}&quot;,
315                      i, FormatEventQueue(eventQueue), ex);
316              }
317          }
318      }
319      #region Utilities
320      static void Retry(Action action)
321      {
322          const int Retries = 50;
323          for (var i = 0; i &lt; Retries; i++)
324          {
325              try
326              {
327                  action();
328                  return;
329              }
330              catch (AssertionException)
331              {
332                  if (i == Retries - 1)
333                  {
334                      throw;
335                  }
336                  Thread.Sleep(100);
337              }
338          }
339      }
340      void AssertNoPreparedTransactions()
341          =&gt; Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), &quot;Prepared transactions found&quot;);
342      int GetNumberOfPreparedTransactions()
343      {
344          var dataSource = EnlistOffDataSource;
345          using (var conn = dataSource.OpenConnection())
346          using (var cmd = new NpgsqlCommand(&quot;SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database&quot;, conn))
347          {
348              cmd.Parameters.Add(new NpgsqlParameter(&quot;database&quot;, conn.Database));
349              return (int)(long)cmd.ExecuteScalar()!;
350          }
351      }
352      void AssertNumberOfRows(NpgsqlConnection connection, string table, int expected)
353          =&gt; Assert.That(connection.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(expected), &quot;Unexpected data count&quot;);
354      static void AssertNoDistributedIdentifier()
355          =&gt; Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), &quot;Distributed identifier found&quot;);
356      static void AssertHasDistributedIdentifier()
357          =&gt; Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.Not.EqualTo(Guid.Empty), &quot;Distributed identifier not found&quot;);
358      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
359      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
360      static string FormatEventQueue(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
361      {
362          eventQueue.Enqueue(new TransactionEvent(@&quot;-------------
363  Start formatting event queue, going to sleep a bit for late events
364  -------------&quot;));
365          Thread.Sleep(20);
366          var eventsMessage = new StringBuilder();
367          foreach (var evt in eventQueue)
368          {
369              eventsMessage.AppendLine(evt.Message);
370          }
371          return eventsMessage.ToString();
372      }
373      public class EnlistResource : IEnlistmentNotification
374      {
375          public static int Counter { get; set; }
376          readonly bool _shouldRollBack;
377          readonly string _name;
378          readonly ConcurrentQueue&lt;TransactionEvent&gt;? _eventQueue;
379          public static void EnlistVolatile(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
380              =&gt; EnlistVolatile(false, eventQueue);
381          public static void EnlistVolatile(bool shouldRollBack = false, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue = null)
382              =&gt; Enlist(false, shouldRollBack, eventQueue);
383          public static void EscalateToDistributed(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
384              =&gt; EscalateToDistributed(false, eventQueue);
385          public static void EscalateToDistributed(bool shouldRollBack = false, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue = null)
386              =&gt; Enlist(true, shouldRollBack, eventQueue);
387          static void Enlist(bool durable, bool shouldRollBack, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue)
388          {
389              Counter++;
390              var name = $&quot;{(durable ? &quot;Durable&quot; : &quot;Volatile&quot;)} resource {Counter}&quot;;
391              var resource = new EnlistResource(shouldRollBack, name, eventQueue);
392              if (durable)
393                  Transaction.Current!.EnlistDurable(Guid.NewGuid(), resource, EnlistmentOptions.None);
394              else
395                  Transaction.Current!.EnlistVolatile(resource, EnlistmentOptions.None);
396              Transaction.Current.TransactionCompleted += resource.Current_TransactionCompleted!;
397              eventQueue?.Enqueue(new TransactionEvent(name + &quot;: enlisted&quot;));
398          }
399          EnlistResource(bool shouldRollBack, string name, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue)
400          {
401              _shouldRollBack = shouldRollBack;
402              _name = name;
403              _eventQueue = eventQueue;
404          }
405          public void Prepare(PreparingEnlistment preparingEnlistment)
406          {
407              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase start&quot;));
408              Thread.Sleep(1);
409              if (_shouldRollBack)
410              {
411                  _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase, calling rollback-ed&quot;));
412                  preparingEnlistment.ForceRollback();
413              }
414              else
415              {
416                  _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase, calling prepared&quot;));
417                  preparingEnlistment.Prepared();
418              }
419              Thread.Sleep(1);
420              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase end&quot;));
421          }
422          public void Commit(Enlistment enlistment)
423          {
424              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase start&quot;));
425              Thread.Sleep(1);
426              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase, calling done&quot;));
427              enlistment.Done();
428              Thread.Sleep(1);
429              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase end&quot;));
430          }
431          public void Rollback(Enlistment enlistment)
432          {
433              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase start&quot;));
434              Thread.Sleep(1);
435              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase, calling done&quot;));
436              enlistment.Done();
437              Thread.Sleep(1);
438              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase end&quot;));
439          }
440          public void InDoubt(Enlistment enlistment)
441          {
442              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase start&quot;));
443              Thread.Sleep(1);
444              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase, calling done&quot;));
445              enlistment.Done();
446              Thread.Sleep(1);
447              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase end&quot;));
448          }
449          void Current_TransactionCompleted(object sender, TransactionEventArgs e)
450          {
451              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed start&quot;));
452              Thread.Sleep(1);
453              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed middle&quot;));
454              Thread.Sleep(1);
455              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed end&quot;));
456          }
457      }
458      public class TransactionEvent
459      {
460          public TransactionEvent(string message)
461              =&gt; Message = $&quot;{message} (TId {Thread.CurrentThread.ManagedThreadId})&quot;;
462          public string Message { get; }
463      }
464      #endregion Utilities
465      #region Setup
466      [OneTimeSetUp]
467      public void OneTimeSetUp()
468      {
469          if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
470          {
471              Assert.Ignore(&quot;Distributed transactions are only supported on Windows&quot;);
472              return;
473          }
474          using var connection = OpenConnection();
475          if (int.Parse((string)connection.ExecuteScalar(&quot;SHOW max_prepared_transactions&quot;)!) == 0)
476          {
477              IgnoreExceptOnBuildServer(&quot;max_prepared_transactions is set to 0 in your postgresql.conf&quot;);
478              return;
479          }
480          var lingeringTransactions = new List&lt;string&gt;();
481          using (var cmd = new NpgsqlCommand(&quot;SELECT gid FROM pg_prepared_xacts WHERE database=@database&quot;, connection))
482          {
483              cmd.Parameters.AddWithValue(&quot;database&quot;, new NpgsqlConnectionStringBuilder(ConnectionString).Database!);
484              using var reader = cmd.ExecuteReader();
485              while (reader.Read())
486                  lingeringTransactions.Add(reader.GetString(0));
487          }
488          foreach (var xactGid in lingeringTransactions)
489              connection.ExecuteNonQuery($&quot;ROLLBACK PREPARED &#x27;{xactGid}&#x27;&quot;);
490          EnlistOnDataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
<span onclick='openModal()' class='match'>491          EnlistOffDataSource = CreateDataSource(csb =&gt; csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
</span>502      public void SetUp()
503          =&gt; EnlistResource.Counter = 0;
504      internal static string CreateTempTable(NpgsqlConnection conn, string columns)
505      {
506          var tableName = &quot;temp_table&quot; + Interlocked.Increment(ref _tempTableCounter);
507          conn.ExecuteNonQuery(@$&quot;
508  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
509  DROP TABLE IF EXISTS {tableName} CASCADE;
510  COMMIT;
511  CREATE TABLE {tableName} ({columns})&quot;);
512          return tableName;
513      }
514      #endregion
515  }
516  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTransactionTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>380          EnlistOffDataSource = CreateDataSource(csb =&gt; csb.Enlist = false);
381      }
382      [OneTimeTearDown]
383      public void OnTimeTearDown()
384      {
385          EnlistOnDataSource?.Dispose();
386          EnlistOnDataSource = null!;
387          EnlistOffDataSource?.Dispose();
388          EnlistOffDataSource = null!;
389      }
390      internal static string CreateTempTable(NpgsqlDataSource dataSource, string columns)
</pre></code></div>
                <div class="column column_space"><pre><code>491          EnlistOffDataSource = CreateDataSource(csb =&gt; csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    