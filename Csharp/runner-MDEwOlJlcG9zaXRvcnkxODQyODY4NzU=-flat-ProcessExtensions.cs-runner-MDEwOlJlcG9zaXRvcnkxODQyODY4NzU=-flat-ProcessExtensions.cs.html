
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessExtensions.cs</h3>
            <pre><code>1  using GitHub.Runner.Common.Util;
2  using GitHub.Runner.Sdk;
3  using System;
4  using System.Collections.Concurrent;
5  using System.Collections.Generic;
6  using System.ComponentModel;
7  using System.Diagnostics;
8  using System.IO;
9  using System.Linq;
10  using System.Runtime.InteropServices;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  namespace GitHub.Runner.Common
15  {
16  #if OS_WINDOWS
17      public static class WindowsProcessExtensions
18      {
19          public static string GetEnvironmentVariable(this Process process, IHostContext hostContext, string variable)
20          {
21              var trace = hostContext.GetTrace(nameof(WindowsProcessExtensions));
22              Dictionary<string, string> environmentVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
23              IntPtr processHandle = process.SafeHandle.DangerousGetHandle();
24              IntPtr environmentBlockAddress;
25              if (Environment.Is64BitOperatingSystem)
26              {
27                  PROCESS_BASIC_INFORMATION64 pbi = new PROCESS_BASIC_INFORMATION64();
28                  int returnLength = 0;
29                  int status = NtQueryInformationProcess64(processHandle, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, Marshal.SizeOf(pbi), ref returnLength);
30                  if (status != 0)
31                  {
32                      throw new Win32Exception(Marshal.GetLastWin32Error());
33                  }
34                  bool wow64;
35                  if (!IsWow64Process(processHandle, out wow64))
36                  {
37                      throw new Win32Exception(Marshal.GetLastWin32Error());
38                  }
39                  if (!wow64)
40                  {
41                      IntPtr UserProcessParameterAddress = ReadIntPtr64(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x20);
42                      environmentBlockAddress = ReadIntPtr64(processHandle, UserProcessParameterAddress + 0x80);
43                  }
44                  else
45                  {
46                      IntPtr UserProcessParameterAddress = ReadIntPtr32(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x1010);
47                      environmentBlockAddress = ReadIntPtr32(processHandle, UserProcessParameterAddress + 0x48);
48                  }
49              }
50              else
51              {
52                  PROCESS_BASIC_INFORMATION32 pbi = new PROCESS_BASIC_INFORMATION32();
53                  int returnLength = 0;
54                  int status = NtQueryInformationProcess32(processHandle, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, Marshal.SizeOf(pbi), ref returnLength);
55                  if (status != 0)
56                  {
57                      throw new Win32Exception(Marshal.GetLastWin32Error());
58                  }
59                  IntPtr UserProcessParameterAddress = ReadIntPtr32(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x10);
60                  environmentBlockAddress = ReadIntPtr32(processHandle, UserProcessParameterAddress + 0x48);
61              }
62              MEMORY_BASIC_INFORMATION memInfo = new MEMORY_BASIC_INFORMATION();
63              if (VirtualQueryEx(processHandle, environmentBlockAddress, ref memInfo, Marshal.SizeOf(memInfo)) == 0)
64              {
65                  throw new Win32Exception(Marshal.GetLastWin32Error());
66              }
67              Int64 dataSize = memInfo.RegionSize.ToInt64() - (environmentBlockAddress.ToInt64() - memInfo.BaseAddress.ToInt64());
68              byte[] envData = new byte[dataSize];
69              IntPtr res_len = IntPtr.Zero;
70              if (!ReadProcessMemory(processHandle, environmentBlockAddress, envData, new IntPtr(dataSize), ref res_len))
71              {
72                  throw new Win32Exception(Marshal.GetLastWin32Error());
73              }
74              if (res_len.ToInt64() != dataSize)
75              {
76                  throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
77              }
78              string environmentVariableString;
79              Int64 environmentVariableBytesLength = 0;
80              if (envData[0] != 0 && envData[1] == 0)
81              {
82                  for (Int64 index = 0; index < dataSize; index++)
83                  {
84                      if (environmentVariableBytesLength == 0 &&
85                          envData[index] == 0 &&
86                          index + 3 < dataSize &&
87                          envData[index + 1] == 0 &&
88                          envData[index + 2] == 0 &&
89                          envData[index + 3] == 0)
90                      {
91                          environmentVariableBytesLength = index + 3;
92                      }
93                      else if (environmentVariableBytesLength != 0)
94                      {
95                          envData[index] = 0;
96                      }
97                  }
98                  if (environmentVariableBytesLength == 0)
99                  {
100                      throw new ArgumentException(nameof(environmentVariableBytesLength));
101                  }
102                  environmentVariableString = Encoding.Unicode.GetString(envData);
103              }
104              else if (envData[0] != 0 && envData[1] != 0)
105              {
106                  for (Int64 index = 0; index < dataSize; index++)
107                  {
108                      if (environmentVariableBytesLength == 0 &&
109                          envData[index] == 0 &&
110                          index + 1 < dataSize &&
111                          envData[index + 1] == 0)
112                      {
113                          environmentVariableBytesLength = index + 1;
114                      }
115                      else if (environmentVariableBytesLength != 0)
116                      {
117                          envData[index] = 0;
118                      }
119                  }
120                  if (environmentVariableBytesLength == 0)
121                  {
122                      throw new ArgumentException(nameof(environmentVariableBytesLength));
123                  }
124                  environmentVariableString = Encoding.Default.GetString(envData);
125              }
126              else
127              {
128                  throw new ArgumentException(nameof(envData));
129              }
130              foreach (var envString in environmentVariableString.Split("\0", StringSplitOptions.RemoveEmptyEntries))
131              {
132                  string[] env = envString.Split("=", 2);
133                  if (!string.IsNullOrEmpty(env[0]))
134                  {
<span onclick='openModal()' class='match'>135                      environmentVariables[env[0]] = env[1];
136                      trace.Verbose($"PID:{process.Id} ({env[0]}={env[1]})");
137                  }
138              }
139              if (environmentVariables.TryGetValue(variable, out string envVariable))
</span>140              {
141                  return envVariable;
142              }
143              else
144              {
145                  return null;
146              }
147          }
148          private static IntPtr ReadIntPtr32(IntPtr hProcess, IntPtr ptr)
149          {
150              IntPtr readPtr = IntPtr.Zero;
151              IntPtr data = Marshal.AllocHGlobal(sizeof(Int32));
152              try
153              {
154                  IntPtr res_len = IntPtr.Zero;
155                  if (!ReadProcessMemory(hProcess, ptr, data, new IntPtr(sizeof(Int32)), ref res_len))
156                  {
157                      throw new Win32Exception(Marshal.GetLastWin32Error());
158                  }
159                  if (res_len.ToInt32() != sizeof(Int32))
160                  {
161                      throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
162                  }
163                  readPtr = new IntPtr(Marshal.ReadInt32(data));
164              }
165              finally
166              {
167                  Marshal.FreeHGlobal(data);
168              }
169              return readPtr;
170          }
171          private static IntPtr ReadIntPtr64(IntPtr hProcess, IntPtr ptr)
172          {
173              IntPtr readPtr = IntPtr.Zero;
174              IntPtr data = Marshal.AllocHGlobal(IntPtr.Size);
175              try
176              {
177                  IntPtr res_len = IntPtr.Zero;
178                  if (!ReadProcessMemory(hProcess, ptr, data, new IntPtr(sizeof(Int64)), ref res_len))
179                  {
180                      throw new Win32Exception(Marshal.GetLastWin32Error());
181                  }
182                  if (res_len.ToInt32() != IntPtr.Size)
183                  {
184                      throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
185                  }
186                  readPtr = Marshal.ReadIntPtr(data);
187              }
188              finally
189              {
190                  Marshal.FreeHGlobal(data);
191              }
192              return readPtr;
193          }
194          private enum PROCESSINFOCLASS : int
195          {
196              ProcessBasicInformation = 0
197          };
198          [StructLayout(LayoutKind.Sequential)]
199          private struct MEMORY_BASIC_INFORMATION
200          {
201              public IntPtr BaseAddress;
202              public IntPtr AllocationBase;
203              public int AllocationProtect;
204              public IntPtr RegionSize;
205              public int State;
206              public int Protect;
207              public int Type;
208          }
209          [StructLayout(LayoutKind.Sequential)]
210          private struct PROCESS_BASIC_INFORMATION64
211          {
212              public long ExitStatus;
213              public long PebBaseAddress;
214              public long AffinityMask;
215              public long BasePriority;
216              public long UniqueProcessId;
217              public long InheritedFromUniqueProcessId;
218          };
219          [StructLayout(LayoutKind.Sequential)]
220          private struct PROCESS_BASIC_INFORMATION32
221          {
222              public int ExitStatus;
223              public int PebBaseAddress;
224              public int AffinityMask;
225              public int BasePriority;
226              public int UniqueProcessId;
227              public int InheritedFromUniqueProcessId;
228          };
229          [DllImport("ntdll.dll", SetLastError = true, EntryPoint = "NtQueryInformationProcess")]
230          private static extern int NtQueryInformationProcess64(IntPtr processHandle, PROCESSINFOCLASS processInformationClass, ref PROCESS_BASIC_INFORMATION64 processInformation, int processInformationLength, ref int returnLength);
231          [DllImport("ntdll.dll", SetLastError = true, EntryPoint = "NtQueryInformationProcess")]
232          private static extern int NtQueryInformationProcess32(IntPtr processHandle, PROCESSINFOCLASS processInformationClass, ref PROCESS_BASIC_INFORMATION32 processInformation, int processInformationLength, ref int returnLength);
233          [DllImport("kernel32.dll", SetLastError = true)]
234          private static extern bool IsWow64Process(IntPtr processHandle, out bool wow64Process);
235          [DllImport("kernel32.dll", SetLastError = true)]
236          private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, IntPtr dwSize, ref IntPtr lpNumberOfBytesRead);
237          [DllImport("kernel32.dll", SetLastError = true)]
238          private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, IntPtr dwSize, ref IntPtr lpNumberOfBytesRead);
239          [DllImport("kernel32.dll")]
240          private static extern int VirtualQueryEx(IntPtr processHandle, IntPtr baseAddress, ref MEMORY_BASIC_INFORMATION memoryInformation, int memoryInformationLength);
241      }
242  #else
243      public static class LinuxProcessExtensions
244      {
245          public static string GetEnvironmentVariable(this Process process, IHostContext hostContext, string variable)
246          {
247              var trace = hostContext.GetTrace(nameof(LinuxProcessExtensions));
248              Dictionary<string, string> env = new();
249              if (Directory.Exists("/proc"))
250              {
251                  string envFile = $"/proc/{process.Id}/environ";
252                  trace.Info($"Read env from {envFile}");
253                  string envContent = File.ReadAllText(envFile);
254                  if (!string.IsNullOrEmpty(envContent))
255                  {
256                      var envList = envContent.Split('\0', StringSplitOptions.RemoveEmptyEntries);
257                      foreach (var envStr in envList)
258                      {
259                          var keyValuePair = envStr.Split('=', 2);
260                          if (keyValuePair.Length == 2)
261                          {
262                              env[keyValuePair[0]] = keyValuePair[1];
263                              trace.Verbose($"PID:{process.Id} ({keyValuePair[0]}={keyValuePair[1]})");
264                          }
265                      }
266                  }
267              }
268              else
269              {
270                  trace.Info($"Read env from output of `ps e -p {process.Id} -o command`");
271                  List<string> psOut = new();
272                  object outputLock = new();
273                  using (var p = hostContext.CreateService<IProcessInvoker>())
274                  {
275                      p.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs stdout)
276                      {
277                          if (!string.IsNullOrEmpty(stdout.Data))
278                          {
279                              lock (outputLock)
280                              {
281                                  psOut.Add(stdout.Data);
282                              }
283                          }
284                      };
285                      p.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs stderr)
286                      {
287                          if (!string.IsNullOrEmpty(stderr.Data))
288                          {
289                              lock (outputLock)
290                              {
291                                  trace.Error(stderr.Data);
292                              }
293                          }
294                      };
295                      int exitCode = p.ExecuteAsync(workingDirectory: hostContext.GetDirectory(WellKnownDirectory.Root),
296                                                    fileName: "ps",
297                                                    arguments: $"e -p {process.Id} -o command",
298                                                    environment: null,
299                                                    cancellationToken: CancellationToken.None).GetAwaiter().GetResult();
300                      if (exitCode == 0)
301                      {
302                          trace.Info($"Successfully dump environment variables for {process.Id}");
303                          if (psOut.Count > 0)
304                          {
305                              string psOutputString = string.Join(" ", psOut);
306                              trace.Verbose($"ps output: '{psOutputString}'");
307                              int varStartIndex = psOutputString.IndexOf(variable, StringComparison.Ordinal);
308                              if (varStartIndex >= 0)
309                              {
310                                  string rightPart = psOutputString.Substring(varStartIndex + variable.Length + 1);
311                                  if (rightPart.IndexOf(' ') > 0)
312                                  {
313                                      string value = rightPart.Substring(0, rightPart.IndexOf(' '));
314                                      env[variable] = value;
315                                  }
316                                  else
317                                  {
318                                      env[variable] = rightPart;
319                                  }
320                                  trace.Verbose($"PID:{process.Id} ({variable}={env[variable]})");
321                              }
322                          }
323                      }
324                  }
325              }
326              if (env.TryGetValue(variable, out string envVariable))
327              {
328                  return envVariable;
329              }
330              else
331              {
332                  return null;
333              }
334          }
335      }
336  #endif
337  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessExtensions.cs</h3>
            <pre><code>1  using GitHub.Runner.Common.Util;
2  using GitHub.Runner.Sdk;
3  using System;
4  using System.Collections.Concurrent;
5  using System.Collections.Generic;
6  using System.ComponentModel;
7  using System.Diagnostics;
8  using System.IO;
9  using System.Linq;
10  using System.Runtime.InteropServices;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  namespace GitHub.Runner.Common
15  {
16  #if OS_WINDOWS
17      public static class WindowsProcessExtensions
18      {
19          public static string GetEnvironmentVariable(this Process process, IHostContext hostContext, string variable)
20          {
21              var trace = hostContext.GetTrace(nameof(WindowsProcessExtensions));
22              Dictionary<string, string> environmentVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
23              IntPtr processHandle = process.SafeHandle.DangerousGetHandle();
24              IntPtr environmentBlockAddress;
25              if (Environment.Is64BitOperatingSystem)
26              {
27                  PROCESS_BASIC_INFORMATION64 pbi = new PROCESS_BASIC_INFORMATION64();
28                  int returnLength = 0;
29                  int status = NtQueryInformationProcess64(processHandle, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, Marshal.SizeOf(pbi), ref returnLength);
30                  if (status != 0)
31                  {
32                      throw new Win32Exception(Marshal.GetLastWin32Error());
33                  }
34                  bool wow64;
35                  if (!IsWow64Process(processHandle, out wow64))
36                  {
37                      throw new Win32Exception(Marshal.GetLastWin32Error());
38                  }
39                  if (!wow64)
40                  {
41                      IntPtr UserProcessParameterAddress = ReadIntPtr64(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x20);
42                      environmentBlockAddress = ReadIntPtr64(processHandle, UserProcessParameterAddress + 0x80);
43                  }
44                  else
45                  {
46                      IntPtr UserProcessParameterAddress = ReadIntPtr32(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x1010);
47                      environmentBlockAddress = ReadIntPtr32(processHandle, UserProcessParameterAddress + 0x48);
48                  }
49              }
50              else
51              {
52                  PROCESS_BASIC_INFORMATION32 pbi = new PROCESS_BASIC_INFORMATION32();
53                  int returnLength = 0;
54                  int status = NtQueryInformationProcess32(processHandle, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, Marshal.SizeOf(pbi), ref returnLength);
55                  if (status != 0)
56                  {
57                      throw new Win32Exception(Marshal.GetLastWin32Error());
58                  }
59                  IntPtr UserProcessParameterAddress = ReadIntPtr32(processHandle, new IntPtr(pbi.PebBaseAddress) + 0x10);
60                  environmentBlockAddress = ReadIntPtr32(processHandle, UserProcessParameterAddress + 0x48);
61              }
62              MEMORY_BASIC_INFORMATION memInfo = new MEMORY_BASIC_INFORMATION();
63              if (VirtualQueryEx(processHandle, environmentBlockAddress, ref memInfo, Marshal.SizeOf(memInfo)) == 0)
64              {
65                  throw new Win32Exception(Marshal.GetLastWin32Error());
66              }
67              Int64 dataSize = memInfo.RegionSize.ToInt64() - (environmentBlockAddress.ToInt64() - memInfo.BaseAddress.ToInt64());
68              byte[] envData = new byte[dataSize];
69              IntPtr res_len = IntPtr.Zero;
70              if (!ReadProcessMemory(processHandle, environmentBlockAddress, envData, new IntPtr(dataSize), ref res_len))
71              {
72                  throw new Win32Exception(Marshal.GetLastWin32Error());
73              }
74              if (res_len.ToInt64() != dataSize)
75              {
76                  throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
77              }
78              string environmentVariableString;
79              Int64 environmentVariableBytesLength = 0;
80              if (envData[0] != 0 && envData[1] == 0)
81              {
82                  for (Int64 index = 0; index < dataSize; index++)
83                  {
84                      if (environmentVariableBytesLength == 0 &&
85                          envData[index] == 0 &&
86                          index + 3 < dataSize &&
87                          envData[index + 1] == 0 &&
88                          envData[index + 2] == 0 &&
89                          envData[index + 3] == 0)
90                      {
91                          environmentVariableBytesLength = index + 3;
92                      }
93                      else if (environmentVariableBytesLength != 0)
94                      {
95                          envData[index] = 0;
96                      }
97                  }
98                  if (environmentVariableBytesLength == 0)
99                  {
100                      throw new ArgumentException(nameof(environmentVariableBytesLength));
101                  }
102                  environmentVariableString = Encoding.Unicode.GetString(envData);
103              }
104              else if (envData[0] != 0 && envData[1] != 0)
105              {
106                  for (Int64 index = 0; index < dataSize; index++)
107                  {
108                      if (environmentVariableBytesLength == 0 &&
109                          envData[index] == 0 &&
110                          index + 1 < dataSize &&
111                          envData[index + 1] == 0)
112                      {
113                          environmentVariableBytesLength = index + 1;
114                      }
115                      else if (environmentVariableBytesLength != 0)
116                      {
117                          envData[index] = 0;
118                      }
119                  }
120                  if (environmentVariableBytesLength == 0)
121                  {
122                      throw new ArgumentException(nameof(environmentVariableBytesLength));
123                  }
124                  environmentVariableString = Encoding.Default.GetString(envData);
125              }
126              else
127              {
128                  throw new ArgumentException(nameof(envData));
129              }
130              foreach (var envString in environmentVariableString.Split("\0", StringSplitOptions.RemoveEmptyEntries))
131              {
132                  string[] env = envString.Split("=", 2);
133                  if (!string.IsNullOrEmpty(env[0]))
134                  {
<span onclick='openModal()' class='match'>135                      environmentVariables[env[0]] = env[1];
136                      trace.Verbose($"PID:{process.Id} ({env[0]}={env[1]})");
137                  }
138              }
139              if (environmentVariables.TryGetValue(variable, out string envVariable))
</span>140              {
141                  return envVariable;
142              }
143              else
144              {
145                  return null;
146              }
147          }
148          private static IntPtr ReadIntPtr32(IntPtr hProcess, IntPtr ptr)
149          {
150              IntPtr readPtr = IntPtr.Zero;
151              IntPtr data = Marshal.AllocHGlobal(sizeof(Int32));
152              try
153              {
154                  IntPtr res_len = IntPtr.Zero;
155                  if (!ReadProcessMemory(hProcess, ptr, data, new IntPtr(sizeof(Int32)), ref res_len))
156                  {
157                      throw new Win32Exception(Marshal.GetLastWin32Error());
158                  }
159                  if (res_len.ToInt32() != sizeof(Int32))
160                  {
161                      throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
162                  }
163                  readPtr = new IntPtr(Marshal.ReadInt32(data));
164              }
165              finally
166              {
167                  Marshal.FreeHGlobal(data);
168              }
169              return readPtr;
170          }
171          private static IntPtr ReadIntPtr64(IntPtr hProcess, IntPtr ptr)
172          {
173              IntPtr readPtr = IntPtr.Zero;
174              IntPtr data = Marshal.AllocHGlobal(IntPtr.Size);
175              try
176              {
177                  IntPtr res_len = IntPtr.Zero;
178                  if (!ReadProcessMemory(hProcess, ptr, data, new IntPtr(sizeof(Int64)), ref res_len))
179                  {
180                      throw new Win32Exception(Marshal.GetLastWin32Error());
181                  }
182                  if (res_len.ToInt32() != IntPtr.Size)
183                  {
184                      throw new ArgumentOutOfRangeException(nameof(ReadProcessMemory));
185                  }
186                  readPtr = Marshal.ReadIntPtr(data);
187              }
188              finally
189              {
190                  Marshal.FreeHGlobal(data);
191              }
192              return readPtr;
193          }
194          private enum PROCESSINFOCLASS : int
195          {
196              ProcessBasicInformation = 0
197          };
198          [StructLayout(LayoutKind.Sequential)]
199          private struct MEMORY_BASIC_INFORMATION
200          {
201              public IntPtr BaseAddress;
202              public IntPtr AllocationBase;
203              public int AllocationProtect;
204              public IntPtr RegionSize;
205              public int State;
206              public int Protect;
207              public int Type;
208          }
209          [StructLayout(LayoutKind.Sequential)]
210          private struct PROCESS_BASIC_INFORMATION64
211          {
212              public long ExitStatus;
213              public long PebBaseAddress;
214              public long AffinityMask;
215              public long BasePriority;
216              public long UniqueProcessId;
217              public long InheritedFromUniqueProcessId;
218          };
219          [StructLayout(LayoutKind.Sequential)]
220          private struct PROCESS_BASIC_INFORMATION32
221          {
222              public int ExitStatus;
223              public int PebBaseAddress;
224              public int AffinityMask;
225              public int BasePriority;
226              public int UniqueProcessId;
227              public int InheritedFromUniqueProcessId;
228          };
229          [DllImport("ntdll.dll", SetLastError = true, EntryPoint = "NtQueryInformationProcess")]
230          private static extern int NtQueryInformationProcess64(IntPtr processHandle, PROCESSINFOCLASS processInformationClass, ref PROCESS_BASIC_INFORMATION64 processInformation, int processInformationLength, ref int returnLength);
231          [DllImport("ntdll.dll", SetLastError = true, EntryPoint = "NtQueryInformationProcess")]
232          private static extern int NtQueryInformationProcess32(IntPtr processHandle, PROCESSINFOCLASS processInformationClass, ref PROCESS_BASIC_INFORMATION32 processInformation, int processInformationLength, ref int returnLength);
233          [DllImport("kernel32.dll", SetLastError = true)]
234          private static extern bool IsWow64Process(IntPtr processHandle, out bool wow64Process);
235          [DllImport("kernel32.dll", SetLastError = true)]
236          private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, IntPtr dwSize, ref IntPtr lpNumberOfBytesRead);
237          [DllImport("kernel32.dll", SetLastError = true)]
238          private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, IntPtr dwSize, ref IntPtr lpNumberOfBytesRead);
239          [DllImport("kernel32.dll")]
240          private static extern int VirtualQueryEx(IntPtr processHandle, IntPtr baseAddress, ref MEMORY_BASIC_INFORMATION memoryInformation, int memoryInformationLength);
241      }
242  #else
243      public static class LinuxProcessExtensions
244      {
245          public static string GetEnvironmentVariable(this Process process, IHostContext hostContext, string variable)
246          {
247              var trace = hostContext.GetTrace(nameof(LinuxProcessExtensions));
248              Dictionary<string, string> env = new();
249              if (Directory.Exists("/proc"))
250              {
251                  string envFile = $"/proc/{process.Id}/environ";
252                  trace.Info($"Read env from {envFile}");
253                  string envContent = File.ReadAllText(envFile);
254                  if (!string.IsNullOrEmpty(envContent))
255                  {
256                      var envList = envContent.Split('\0', StringSplitOptions.RemoveEmptyEntries);
257                      foreach (var envStr in envList)
258                      {
259                          var keyValuePair = envStr.Split('=', 2);
260                          if (keyValuePair.Length == 2)
261                          {
262                              env[keyValuePair[0]] = keyValuePair[1];
263                              trace.Verbose($"PID:{process.Id} ({keyValuePair[0]}={keyValuePair[1]})");
264                          }
265                      }
266                  }
267              }
268              else
269              {
270                  trace.Info($"Read env from output of `ps e -p {process.Id} -o command`");
271                  List<string> psOut = new();
272                  object outputLock = new();
273                  using (var p = hostContext.CreateService<IProcessInvoker>())
274                  {
275                      p.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs stdout)
276                      {
277                          if (!string.IsNullOrEmpty(stdout.Data))
278                          {
279                              lock (outputLock)
280                              {
281                                  psOut.Add(stdout.Data);
282                              }
283                          }
284                      };
285                      p.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs stderr)
286                      {
287                          if (!string.IsNullOrEmpty(stderr.Data))
288                          {
289                              lock (outputLock)
290                              {
291                                  trace.Error(stderr.Data);
292                              }
293                          }
294                      };
295                      int exitCode = p.ExecuteAsync(workingDirectory: hostContext.GetDirectory(WellKnownDirectory.Root),
296                                                    fileName: "ps",
297                                                    arguments: $"e -p {process.Id} -o command",
298                                                    environment: null,
299                                                    cancellationToken: CancellationToken.None).GetAwaiter().GetResult();
300                      if (exitCode == 0)
301                      {
302                          trace.Info($"Successfully dump environment variables for {process.Id}");
303                          if (psOut.Count > 0)
304                          {
305                              string psOutputString = string.Join(" ", psOut);
306                              trace.Verbose($"ps output: '{psOutputString}'");
307                              int varStartIndex = psOutputString.IndexOf(variable, StringComparison.Ordinal);
308                              if (varStartIndex >= 0)
309                              {
310                                  string rightPart = psOutputString.Substring(varStartIndex + variable.Length + 1);
311                                  if (rightPart.IndexOf(' ') > 0)
312                                  {
313                                      string value = rightPart.Substring(0, rightPart.IndexOf(' '));
314                                      env[variable] = value;
315                                  }
316                                  else
317                                  {
318                                      env[variable] = rightPart;
319                                  }
320                                  trace.Verbose($"PID:{process.Id} ({variable}={env[variable]})");
321                              }
322                          }
323                      }
324                  }
325              }
326              if (env.TryGetValue(variable, out string envVariable))
327              {
328                  return envVariable;
329              }
330              else
331              {
332                  return null;
333              }
334          }
335      }
336  #endif
337  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessExtensions.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessExtensions.cs</div>
                </div>
                <div class="column column_space"><pre><code>135                      environmentVariables[env[0]] = env[1];
136                      trace.Verbose($"PID:{process.Id} ({env[0]}={env[1]})");
137                  }
138              }
139              if (environmentVariables.TryGetValue(variable, out string envVariable))
</pre></code></div>
                <div class="column column_space"><pre><code>135                      environmentVariables[env[0]] = env[1];
136                      trace.Verbose($"PID:{process.Id} ({env[0]}={env[1]})");
137                  }
138              }
139              if (environmentVariables.TryGetValue(variable, out string envVariable))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    