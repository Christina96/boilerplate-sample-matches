
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenManager_146.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using DG.Tweening.Core.Enums;
4  using DG.Tweening.Plugins.Options;
5  using UnityEngine;
6  namespace DG.Tweening.Core
7  {
8      internal static class TweenManager
9      {
10          const int _DefaultMaxTweeners = 200;
11          const int _DefaultMaxSequences = 50;
12          const string _MaxTweensReached = "Max Tweens reached: capacity has automatically been increased from #0 to #1. Use DOTween.SetTweensCapacity to set it manually at startup";
13          const float _EpsilonVsTimeCheck = 0.000001f;
14          internal static bool isUnityEditor;
15          internal static bool isDebugBuild;
16          internal static int maxActive = _DefaultMaxTweeners + _DefaultMaxSequences; 
17          internal static int maxTweeners = _DefaultMaxTweeners; 
18          internal static int maxSequences = _DefaultMaxSequences; 
19          internal static bool hasActiveTweens, hasActiveDefaultTweens, hasActiveLateTweens, hasActiveFixedTweens, hasActiveManualTweens;
20          internal static int totActiveTweens, totActiveDefaultTweens, totActiveLateTweens, totActiveFixedTweens, totActiveManualTweens;
21          internal static int totActiveTweeners, totActiveSequences;
22          internal static int totPooledTweeners, totPooledSequences;
23          internal static int totTweeners, totSequences; 
24          internal static bool isUpdateLoop; 
25          internal static Tween[] _activeTweens = new Tween[_DefaultMaxTweeners + _DefaultMaxSequences]; 
26          static Tween[] _pooledTweeners = new Tween[_DefaultMaxTweeners];
27          static readonly Stack<Tween> _PooledSequences = new Stack<Tween>();
28          static readonly List<Tween> _KillList = new List<Tween>(_DefaultMaxTweeners + _DefaultMaxSequences);
29          static readonly Dictionary<Tween,TweenLink> _TweenLinks = new Dictionary<Tween, TweenLink>(_DefaultMaxTweeners + _DefaultMaxSequences);
30          static int _totTweenLinks; 
31          static int _maxActiveLookupId = -1; 
32          static bool _requiresActiveReorganization; 
33          static int _reorganizeFromId = -1; 
34          static int _minPooledTweenerId = -1; 
35          static int _maxPooledTweenerId = -1; 
36          static bool _despawnAllCalledFromUpdateLoopCallback;
37  #if DEBUG
38          public static int updateLoopCount;
39  #endif
40          #region Static Constructor
41          static TweenManager()
42          {
43              isUnityEditor = Application.isEditor;
44  #if DEBUG
45              isDebugBuild = true;
46  #endif
47          }
48          #endregion
49          #region Main
50          internal static TweenerCore<T1,T2,TPlugOptions> GetTweener<T1,T2,TPlugOptions>()
51              where TPlugOptions : struct, IPlugOptions
52          {
53              TweenerCore<T1,T2,TPlugOptions> t;
54              if (totPooledTweeners > 0) {
55                  Type typeofT1 = typeof(T1);
56                  Type typeofT2 = typeof(T2);
57                  Type typeofTPlugOptions = typeof(TPlugOptions);
58                  for (int i = _maxPooledTweenerId; i > _minPooledTweenerId - 1; --i) {
59                      Tween tween = _pooledTweeners[i];
60                      if (tween != null && tween.typeofT1 == typeofT1 && tween.typeofT2 == typeofT2 && tween.typeofTPlugOptions == typeofTPlugOptions) {
61                          t = (TweenerCore<T1, T2, TPlugOptions>)tween;
62                          AddActiveTween(t);
63                          _pooledTweeners[i] = null;
64                          if (_maxPooledTweenerId != _minPooledTweenerId) {
65                              if (i == _maxPooledTweenerId) _maxPooledTweenerId--;
66                              else if (i == _minPooledTweenerId) _minPooledTweenerId++;
67                          }
68                          totPooledTweeners--;
69                          return t;
70                      }
71                  }
72                  if (totTweeners >= maxTweeners) {
73                      _pooledTweeners[_maxPooledTweenerId] = null;
74                      _maxPooledTweenerId--;
75                      totPooledTweeners--;
76                      totTweeners--;
77                  }
78              } else {
79                  if (totTweeners >= maxTweeners - 1) {
80                      int prevMaxTweeners = maxTweeners;
81                      int prevMaxSequences = maxSequences;
82                      IncreaseCapacities(CapacityIncreaseMode.TweenersOnly);
83                      if (Debugger.logPriority >= 1) Debugger.LogWarning(_MaxTweensReached
84                          .Replace("#0", prevMaxTweeners + "/" + prevMaxSequences)
85                          .Replace("#1", maxTweeners + "/" + maxSequences)
86                      );
87                  }
88              }
89              t = new TweenerCore<T1,T2,TPlugOptions>();
90              totTweeners++;
91              AddActiveTween(t);
92              return t;
93          }
94          internal static Sequence GetSequence()
95          {
96              Sequence s;
97              if (totPooledSequences > 0) {
98                  s = (Sequence)_PooledSequences.Pop();
99                  AddActiveTween(s);
100                  totPooledSequences--;
101                  return s;
102              }
103              if (totSequences >= maxSequences - 1) {
104                  int prevMaxTweeners = maxTweeners;
105                  int prevMaxSequences = maxSequences;
106                  IncreaseCapacities(CapacityIncreaseMode.SequencesOnly);
107                  if (Debugger.logPriority >= 1) Debugger.LogWarning(_MaxTweensReached
108                      .Replace("#0", prevMaxTweeners + "/" + prevMaxSequences)
109                          .Replace("#1", maxTweeners + "/" + maxSequences)
110                  );
111              }
112              s = new Sequence();
113              totSequences++;
114              AddActiveTween(s);
115              return s;
116          }
117          internal static void SetUpdateType(Tween t, UpdateType updateType, bool isIndependentUpdate)
118          {
119              if (!t.active || t.updateType == updateType) {
120                  t.updateType = updateType;
121                  t.isIndependentUpdate = isIndependentUpdate;
122                  return;
123              }
124              if (t.updateType == UpdateType.Normal) {
125                  totActiveDefaultTweens--;
126                  hasActiveDefaultTweens = totActiveDefaultTweens > 0;
127              } else {
128                  switch (t.updateType) {
129                  case UpdateType.Fixed:
130                      totActiveFixedTweens--;
131                      hasActiveFixedTweens = totActiveFixedTweens > 0;
132                      break;
133                  case UpdateType.Late:
134                      totActiveLateTweens--;
135                      hasActiveLateTweens = totActiveLateTweens > 0;
136                      break;
137                  default: 
138                      totActiveManualTweens--;
139                      hasActiveManualTweens = totActiveManualTweens > 0;
140                      break;
141                  }
142              }
143              t.updateType = updateType;
144              t.isIndependentUpdate = isIndependentUpdate;
145              if (updateType == UpdateType.Normal) {
146                  totActiveDefaultTweens++;
147                  hasActiveDefaultTweens = true;
148              } else {
149                  switch (updateType) {
150                  case UpdateType.Fixed:
151                      totActiveFixedTweens++;
152                      hasActiveFixedTweens = true;
153                      break;
154                  case UpdateType.Late:
155                      totActiveLateTweens++;
156                      hasActiveLateTweens = true;
157                      break;
158                  default: 
159                      totActiveManualTweens++;
160                      hasActiveManualTweens = true;
161                      break;
162                  }
163              }
164          }
165          internal static void AddActiveTweenToSequence(Tween t)
166          {
167              RemoveActiveTween(t);
168          }
169          internal static int DespawnAll()
170          {
171              int totDespawned = totActiveTweens;
172              for (int i = 0; i < _maxActiveLookupId + 1; ++i) {
173                  Tween t = _activeTweens[i];
174                  if (t != null) Despawn(t, false);
175              }
176              ClearTweenArray(_activeTweens);
177              hasActiveTweens = hasActiveDefaultTweens = hasActiveLateTweens = hasActiveFixedTweens = hasActiveManualTweens = false;
178              totActiveTweens = totActiveDefaultTweens = totActiveLateTweens = totActiveFixedTweens = totActiveManualTweens = 0;
179              totActiveTweeners = totActiveSequences = 0;
180              _maxActiveLookupId = _reorganizeFromId = -1;
181              _requiresActiveReorganization = false;
182              _TweenLinks.Clear();
183              _totTweenLinks = 0;
184              if (isUpdateLoop) _despawnAllCalledFromUpdateLoopCallback = true;
185              return totDespawned;
186          }
187          internal static void Despawn(Tween t, bool modifyActiveLists = true)
188          {
189              if (t.onKill != null) Tween.OnTweenCallback(t.onKill, t);
190              if (modifyActiveLists) {
191                  RemoveActiveTween(t);
192              }
193              if (t.isRecyclable) {
194                  switch (t.tweenType) {
195                  case TweenType.Sequence:
196                      _PooledSequences.Push(t);
197                      totPooledSequences++;
198                      Sequence s = (Sequence)t;
199                      int len = s.sequencedTweens.Count;
200                      for (int i = 0; i < len; ++i) Despawn(s.sequencedTweens[i], false);
201                      break;
202                  case TweenType.Tweener:
203                      if (_maxPooledTweenerId == -1) {
204                          _maxPooledTweenerId = maxTweeners - 1;
205                          _minPooledTweenerId = maxTweeners - 1;
206                      }
207                      if (_maxPooledTweenerId < maxTweeners - 1) {
208                          _pooledTweeners[_maxPooledTweenerId + 1] = t;
209                          _maxPooledTweenerId++;
210                          if (_minPooledTweenerId > _maxPooledTweenerId) _minPooledTweenerId = _maxPooledTweenerId;
211                      } else {
212                          for (int i = _maxPooledTweenerId; i > -1; --i) {
213                              if (_pooledTweeners[i] != null) continue;
214                              _pooledTweeners[i] = t;
215                              if (i < _minPooledTweenerId) _minPooledTweenerId = i;
216                              if (_maxPooledTweenerId < _minPooledTweenerId) _maxPooledTweenerId = _minPooledTweenerId;
217                              break;
218                          }
219                      }
220                      totPooledTweeners++;
221                      break;
222                  }
223              } else {
224                  switch (t.tweenType) {
225                  case TweenType.Sequence:
226                      totSequences--;
227                      Sequence s = (Sequence)t;
228                      int len = s.sequencedTweens.Count;
229                      for (int i = 0; i < len; ++i) Despawn(s.sequencedTweens[i], false);
230                      break;
231                  case TweenType.Tweener:
232                      totTweeners--;
233                      break;
234                  }
235              }
236              t.active = false;
237              t.Reset();
238          }
239          internal static void PurgeAll(bool isApplicationQuitting)
240          {
241              if (!isApplicationQuitting) {
242                  for (int i = 0; i < maxActive; ++i) {
243                      Tween t = _activeTweens[i];
244                      if (t != null && t.active) {
245                          t.active = false;
246                          if (t.onKill != null) Tween.OnTweenCallback(t.onKill, t);
247                      }
248                  }
249              }
250              ClearTweenArray(_activeTweens);
251              hasActiveTweens = hasActiveDefaultTweens = hasActiveLateTweens = hasActiveFixedTweens = hasActiveManualTweens = false;
252              totActiveTweens = totActiveDefaultTweens = totActiveLateTweens = totActiveFixedTweens = totActiveManualTweens = 0;
253              totActiveTweeners = totActiveSequences = 0;
254              _maxActiveLookupId = _reorganizeFromId = -1;
255              _requiresActiveReorganization = false;
256              PurgePools();
257              ResetCapacities();
258              totTweeners = totSequences = 0;
259          }
260          internal static void PurgePools()
261          {
262              totTweeners -= totPooledTweeners;
263              totSequences -= totPooledSequences;
264              ClearTweenArray(_pooledTweeners);
265              _PooledSequences.Clear();
266              totPooledTweeners = totPooledSequences = 0;
267              _minPooledTweenerId = _maxPooledTweenerId = -1;
268          }
269          internal static void AddTweenLink(Tween t, TweenLink tweenLink)
270          {
271              _totTweenLinks++;
272              if (_TweenLinks.ContainsKey(t)) _TweenLinks[t] = tweenLink;
273              else _TweenLinks.Add(t, tweenLink);
274              if (tweenLink.lastSeenActive) {
275                  switch (tweenLink.behaviour) {
276                  case LinkBehaviour.PauseOnDisablePlayOnEnable:
277                  case LinkBehaviour.PauseOnDisableRestartOnEnable:
278                  case LinkBehaviour.PlayOnEnable:
279                  case LinkBehaviour.RestartOnEnable:
280                      Play(t);
281                      break;
282                  }
283              } else {
284                  switch (tweenLink.behaviour) {
285                  case LinkBehaviour.PauseOnDisable:
286                  case LinkBehaviour.PauseOnDisablePlayOnEnable:
287                  case LinkBehaviour.PauseOnDisableRestartOnEnable:
288                      Pause(t);
289                      break;
290                  }
291              }
292          }
293          static void RemoveTweenLink(Tween t)
294          {
295              if (!_TweenLinks.ContainsKey(t)) return;
296              _TweenLinks.Remove(t);
297              _totTweenLinks--;
298          }
299          internal static void ResetCapacities()
300          {
301              SetCapacities(_DefaultMaxTweeners, _DefaultMaxSequences);
302          }
303          internal static void SetCapacities(int tweenersCapacity, int sequencesCapacity)
304          {
305              if (tweenersCapacity < sequencesCapacity) tweenersCapacity = sequencesCapacity;
306              maxActive = tweenersCapacity + sequencesCapacity;
307              maxTweeners = tweenersCapacity;
308              maxSequences = sequencesCapacity;
309              Array.Resize(ref _activeTweens, maxActive);
310              Array.Resize(ref _pooledTweeners, tweenersCapacity);
311              _KillList.Capacity = maxActive;
312          }
313          internal static int Validate()
314          {
315              if (_requiresActiveReorganization) ReorganizeActiveTweens();
316              int totInvalid = 0;
317              for (int i = 0; i < _maxActiveLookupId + 1; ++i) {
318                  Tween t = _activeTweens[i];
319                  if (!t.Validate()) {
320                      totInvalid++;
321                      MarkForKilling(t);
322                  }
323              }
324              if (totInvalid > 0) {
325                  DespawnActiveTweens(_KillList);
326                  _KillList.Clear();
327              }
328              return totInvalid;
329          }
330          internal static void Update(UpdateType updateType, float deltaTime, float independentTime)
331          {
332              if (_requiresActiveReorganization) ReorganizeActiveTweens();
333              isUpdateLoop = true;
334  #if DEBUG
335              updateLoopCount++;
336              VerifyActiveTweensList();
337  #endif
338              bool willKill = false;
339              int len = _maxActiveLookupId + 1; 
340              for (int i = 0; i < len; ++i) {
341                  Tween t = _activeTweens[i];
342                  if (t == null || t.updateType != updateType) continue; 
343                  if (Update(t, deltaTime, independentTime, false)) willKill = true;
344              }
345              if (willKill) {
346                  if (_despawnAllCalledFromUpdateLoopCallback) {
347                      _despawnAllCalledFromUpdateLoopCallback = false;
348                  } else {
349                      DespawnActiveTweens(_KillList);
350                  }
351                  _KillList.Clear();
352              }
353              isUpdateLoop = false;
354          }
355          internal static bool Update(Tween t, float deltaTime, float independentTime, bool isSingleTweenManualUpdate)
356          {
357              if (_totTweenLinks > 0) EvaluateTweenLink(t); 
358              if (!t.active) {
359                  MarkForKilling(t, isSingleTweenManualUpdate);
360                  return true;
361              }
362              if (!t.isPlaying) return false;
363              t.creationLocked = true; 
364              float tDeltaTime = (t.isIndependentUpdate ? independentTime : deltaTime) * t.timeScale;
365              if (tDeltaTime < _EpsilonVsTimeCheck && tDeltaTime > -_EpsilonVsTimeCheck) return false; 
366              if (!t.delayComplete) {
367                  tDeltaTime = t.UpdateDelay(t.elapsedDelay + tDeltaTime);
368                  if (tDeltaTime <= -1) {
369                      MarkForKilling(t, isSingleTweenManualUpdate);
370                      return true;
371                  }
372                  if (tDeltaTime <= 0) return false;
373                  if (t.playedOnce && t.onPlay != null) {
374                      Tween.OnTweenCallback(t.onPlay, t);
375                  }
376              }
377              if (!t.startupDone) {
378                  if (!t.Startup()) {
379                      MarkForKilling(t, isSingleTweenManualUpdate);
380                      return true;
381                  }
382              }
383              float toPosition = t.position;
384              bool wasEndPosition = toPosition >= t.duration;
385              int toCompletedLoops = t.completedLoops;
386              if (t.duration <= 0) {
387                  toPosition = 0;
388                  toCompletedLoops = t.loops == -1 ? t.completedLoops + 1 : t.loops;
389              } else {
390                  if (t.isBackwards) {
391                      toPosition -= tDeltaTime;
392                      while (toPosition < 0 && toCompletedLoops > -1) {
393                          toPosition += t.duration;
394                          toCompletedLoops--;
395                      }
396                      if (toCompletedLoops < 0 || wasEndPosition && toCompletedLoops < 1) {
397                          toPosition = 0;
398                          toCompletedLoops = wasEndPosition ? 1 : 0;
399                      }
400                  } else {
401                      toPosition += tDeltaTime;
402                      while (toPosition >= t.duration && (t.loops == -1 || toCompletedLoops < t.loops)) {
403                          toPosition -= t.duration;
404                          toCompletedLoops++;
405                      }
406                  }
407                  if (wasEndPosition) toCompletedLoops--;
408                  if (t.loops != -1 && toCompletedLoops >= t.loops) toPosition = t.duration;
409              }
410              bool needsKilling = Tween.DoGoto(t, toPosition, toCompletedLoops, UpdateMode.Update);
411              if (needsKilling) {
412                  MarkForKilling(t, isSingleTweenManualUpdate);
413                  return true;
414              }
415              return false;
416          }
417          internal static int FilteredOperation(OperationType operationType, FilterType filterType, object id, bool optionalBool, float optionalFloat, object optionalObj = null, object[] optionalArray = null)
418          {
419              int totInvolved = 0;
420              bool hasDespawned = false;
421              int optionalArrayLen = optionalArray == null ? 0 : optionalArray.Length;
422              bool useStringId = false;
423              string stringId = null;
424              bool useIntId = false;
425              int intId = 0;
426              switch (filterType) {
427              case FilterType.TargetOrId:
428              case FilterType.TargetAndId:
429                  if (id is string) {
430                      useStringId = true;
431                      stringId = (string)id;
432                  } else if (id is int) {
433                      useIntId = true;
434                      intId = (int)id;
435                  }
436                  break;
437              }
438              for (int i = _maxActiveLookupId; i > -1; --i) {
439                  Tween t = _activeTweens[i];
440                  if (t == null || !t.active) continue;
441                  bool isFilterCompliant = false;
442                  switch (filterType) {
443                  case FilterType.All:
444                      isFilterCompliant = true;
445                      break;
446                  case FilterType.TargetOrId:
447                      if (useStringId) isFilterCompliant = t.stringId != null && t.stringId == stringId;
448                      else if (useIntId) isFilterCompliant = t.intId == intId;
449                      else isFilterCompliant = t.id != null && id.Equals(t.id) || t.target != null && id.Equals(t.target);
450                      break;
451                  case FilterType.TargetAndId:
452                      if (useStringId) isFilterCompliant = t.target != null && t.stringId == stringId && optionalObj != null && optionalObj.Equals(t.target);
453                      else if (useIntId) isFilterCompliant = t.target != null && t.intId == intId && optionalObj != null && optionalObj.Equals(t.target);
454                      else isFilterCompliant = t.id != null && t.target != null && optionalObj != null && id.Equals(t.id) && optionalObj.Equals(t.target);
455                      break;
456                  case FilterType.AllExceptTargetsOrIds:
457                      isFilterCompliant = true;
458                      for (int c = 0; c < optionalArrayLen; ++c) {
459                          object objId = optionalArray[c];
460                          if (objId is string) {
461                              useStringId = true;
462                              stringId = (string)objId;
463                          } else if (objId is int) {
464                              useIntId = true;
465                              intId = (int)objId;
466                          }
467                          if (useStringId && t.stringId == stringId) {
468                              isFilterCompliant = false;
469                              break;
470                          } else if (useIntId && t.intId == intId) {
471                              isFilterCompliant = false;
472                              break;
473                          } else if (t.id != null && objId.Equals(t.id) || t.target != null && objId.Equals(t.target)) {
474                              isFilterCompliant = false;
475                              break;
476                          }
477                      }
478                      break;
479                  }
480                  if (isFilterCompliant) {
481                      switch (operationType) {
482                      case OperationType.Despawn:
483                          totInvolved++;
484                          t.active = false; 
485                          if (isUpdateLoop) break; 
486                          Despawn(t, false);
487                          hasDespawned = true;
488                          _KillList.Add(t);
489                          break;
490                      case OperationType.Complete:
491                          bool hasAutoKill = t.autoKill;
492                          if (!t.startupDone) ForceInit(t); 
493                          if (Complete(t, false, optionalFloat > 0 ? UpdateMode.Update : UpdateMode.Goto)) {
494                              totInvolved += !optionalBool ? 1 : hasAutoKill ? 1 : 0;
495                              if (hasAutoKill) {
496                                  if (isUpdateLoop) t.active = false; 
497                                  else {
498                                      hasDespawned = true;
499                                      _KillList.Add(t);
500                                  }
501                              }
502                          }
503                          break;
504                      case OperationType.Flip:
505                          if (Flip(t)) totInvolved++;
506                          break;
507                      case OperationType.Goto:
508                          if (!t.startupDone) ForceInit(t); 
509                          Goto(t, optionalFloat, optionalBool);
510                          totInvolved++;
511                          break;
512                      case OperationType.Pause:
513                          if (Pause(t)) totInvolved++;
514                          break;
515                      case OperationType.Play:
516                          if (Play(t)) totInvolved++;
517                          break;
518                      case OperationType.PlayBackwards:
519                          if (PlayBackwards(t)) totInvolved++;
520                          break;
521                      case OperationType.PlayForward:
522                          if (PlayForward(t)) totInvolved++;
523                          break;
524                      case OperationType.Restart:
525                          if (Restart(t, optionalBool, optionalFloat)) totInvolved++;
526                          break;
527                      case OperationType.Rewind:
528                          if (Rewind(t, optionalBool)) totInvolved++;
529                          break;
530                      case OperationType.SmoothRewind:
531                          if (SmoothRewind(t)) totInvolved++;
532                          break;
533                      case OperationType.TogglePause:
534                          if (TogglePause(t)) totInvolved++;
535                          break;
536                      case OperationType.IsTweening:
537                          if ((!t.isComplete || !t.autoKill) && (!optionalBool || t.isPlaying)) totInvolved++;
538                          break;
539                      }
540                  }
541              }
542              if (hasDespawned) {
543                  int count = _KillList.Count - 1;
544                  for (int i = count; i > -1; --i) {
545                      Tween t = _KillList[i];
546                      if (t.activeId != -1) RemoveActiveTween(t);
547                  }
548                  _KillList.Clear();
549              }
550              return totInvolved;
551          }
552          #endregion
553          #region Play Operations
554          internal static bool Complete(Tween t, bool modifyActiveLists = true, UpdateMode updateMode = UpdateMode.Goto)
555          {
556              if (t.loops == -1) return false;
557              if (!t.isComplete) {
558                  Tween.DoGoto(t, t.duration, t.loops, updateMode);
559                  t.isPlaying = false;
560                  if (t.autoKill && t.active) {
561                      if (isUpdateLoop) t.active = false; 
562                      else Despawn(t, modifyActiveLists);
563                  }
564                  return true;
565              }
566              return false;
567          }
568          internal static bool Flip(Tween t)
569          {
570              t.isBackwards = !t.isBackwards;
571              return true;
572          }
573          internal static void ForceInit(Tween t, bool isSequenced = false)
574          {
575              if (t.startupDone) return;
576              if (!t.Startup() && !isSequenced) {
577                  if (isUpdateLoop) t.active = false; 
578                  else RemoveActiveTween(t);
579              }
580          }
581          internal static bool Goto(Tween t, float to, bool andPlay = false, UpdateMode updateMode = UpdateMode.Goto)
582          {
583              bool wasPlaying = t.isPlaying;
584              t.isPlaying = andPlay;
585              t.delayComplete = true;
586              t.elapsedDelay = t.delay;
587              int toCompletedLoops = t.duration <= 0 ? 1 : Mathf.FloorToInt(to / t.duration); 
588              float toPosition = to % t.duration;
589              if (t.loops != -1 && toCompletedLoops >= t.loops) {
590                  toCompletedLoops = t.loops;
591                  toPosition = t.duration;
592              } else if (toPosition >= t.duration) toPosition = 0;
593              bool needsKilling = Tween.DoGoto(t, toPosition, toCompletedLoops, updateMode);
594              if (!andPlay && wasPlaying && !needsKilling && t.onPause != null) Tween.OnTweenCallback(t.onPause, t);
595              return needsKilling;
596          }
597          internal static bool Pause(Tween t)
598          {
599              if (t.isPlaying) {
600                  t.isPlaying = false;
601                  if (t.onPause != null) Tween.OnTweenCallback(t.onPause, t);
602                  return true;
603              }
604              return false;
605          }
606          internal static bool Play(Tween t)
607          {
608              if (!t.isPlaying && (!t.isBackwards && !t.isComplete || t.isBackwards && (t.completedLoops > 0 || t.position > 0))) {
609                  t.isPlaying = true;
610                  if (t.playedOnce && t.delayComplete && t.onPlay != null) {
611                      Tween.OnTweenCallback(t.onPlay, t);
612                  }
613                  return true;
614              }
615              return false;
616          }
617          internal static bool PlayBackwards(Tween t)
618          {
619              if (t.completedLoops == 0 && t.position <= 0) {
620                  ManageOnRewindCallbackWhenAlreadyRewinded(t, true);
621                  t.isBackwards = true;
622                  t.isPlaying = false;
623                  return false;
624              }
625              if (!t.isBackwards) {
626                  t.isBackwards = true;
627                  Play(t);
628                  return true;
629              }
630              return Play(t);
631          }
632          internal static bool PlayForward(Tween t)
633          {
634              if (t.isComplete) {
<span onclick='openModal()' class='match'>635                  t.isBackwards = false;
636                  t.isPlaying = false;
637                  return false;
</span>638              }
639              if (t.isBackwards) {
640                  t.isBackwards = false;
641                  Play(t);
642                  return true;
643              }
644              return Play(t);
645          }
646          internal static bool Restart(Tween t, bool includeDelay = true, float changeDelayTo = -1)
647          {
648              bool wasPaused = !t.isPlaying;
649              t.isBackwards = false;
650              if (changeDelayTo >= 0 && t.tweenType == TweenType.Tweener) t.delay = changeDelayTo;
651              Rewind(t, includeDelay);
652              t.isPlaying = true;
653              if (wasPaused && t.playedOnce && t.delayComplete && t.onPlay != null) {
654                  Tween.OnTweenCallback(t.onPlay, t);
655              }
656              return true;
657          }
658          internal static bool Rewind(Tween t, bool includeDelay = true)
659          {
660              bool wasPlaying = t.isPlaying; 
661              t.isPlaying = false;
662              bool rewinded = false;
663              if (t.delay > 0) {
664                  if (includeDelay) {
665                      rewinded = t.delay > 0 && t.elapsedDelay > 0;
666                      t.elapsedDelay = 0;
667                      t.delayComplete = false;
668                  } else {
669                      rewinded = t.elapsedDelay < t.delay;
670                      t.elapsedDelay = t.delay;
671                      t.delayComplete = true;
672                  }
673              }
674              if (t.position > 0 || t.completedLoops > 0 || !t.startupDone) {
675                  rewinded = true;
676                  bool needsKilling = Tween.DoGoto(t, 0, 0, UpdateMode.Goto);
677                  if (!needsKilling && wasPlaying && t.onPause != null) Tween.OnTweenCallback(t.onPause, t);
678              } else {
679                  ManageOnRewindCallbackWhenAlreadyRewinded(t, false);
680              }
681              return rewinded;
682          }
683          internal static bool SmoothRewind(Tween t)
684          {
685              bool rewinded = false;
686              if (t.delay > 0) {
687                  rewinded = t.elapsedDelay < t.delay;
688                  t.elapsedDelay = t.delay;
689                  t.delayComplete = true;
690              }
691              if (t.position > 0 || t.completedLoops > 0 || !t.startupDone) {
692                  rewinded = true;
693                  if (t.loopType == LoopType.Incremental) t.PlayBackwards();
694                  else {
695                      t.Goto(t.ElapsedDirectionalPercentage() * t.duration);
696                      t.PlayBackwards();
697                  }
698              } else {
699                  t.isPlaying = false;
700                  ManageOnRewindCallbackWhenAlreadyRewinded(t, true);
701              }
702              return rewinded;
703          }
704          internal static bool TogglePause(Tween t)
705          {
706              if (t.isPlaying) return Pause(t);
707              return Play(t);
708          }
709          #endregion
710          #region Info Getters
711          internal static int TotalPooledTweens()
712          {
713              return totPooledTweeners + totPooledSequences;
714          }
715          internal static int TotalPlayingTweens()
716          {
717              if (!hasActiveTweens) return 0;
718              if (_requiresActiveReorganization) ReorganizeActiveTweens();
719              int tot = 0;
720              for (int i = 0; i < _maxActiveLookupId + 1; ++i) {
721                  Tween t = _activeTweens[i];
722                  if (t != null && t.isPlaying) tot++;
723              }
724              return tot;
725          }
726          internal static int TotalTweensById(object id, bool playingOnly)
727          {
728              if (_requiresActiveReorganization) ReorganizeActiveTweens();
729              if (totActiveTweens <= 0) return 0;
730              return DoGetTweensById(id, playingOnly, false, null);
731          }
732          internal static List<Tween> GetActiveTweens(bool playing, List<Tween> fillableList = null)
733          {
734              if (_requiresActiveReorganization) ReorganizeActiveTweens();
735              if (totActiveTweens <= 0) return null;
736              int len = totActiveTweens;
737              if (fillableList == null) fillableList = new List<Tween>(len);
738              for (int i = 0; i < len; ++i) {
739                  Tween t = _activeTweens[i];
740                  if (t.isPlaying == playing) fillableList.Add(t);
741              }
742              if (fillableList.Count > 0) return fillableList;
743              return null;
744          }
745          internal static List<Tween> GetTweensById(object id, bool playingOnly, List<Tween> fillableList = null)
746          {
747              if (_requiresActiveReorganization) ReorganizeActiveTweens();
748              if (totActiveTweens <= 0) return null;
749              if (fillableList == null) fillableList = new List<Tween>(totActiveTweens);
750              DoGetTweensById(id, playingOnly, true, fillableList);
751              return fillableList.Count > 0 ? fillableList : null;
752          }
753          static int DoGetTweensById(object id, bool playingOnly, bool addToList, List<Tween> fillableList)
754          {
755              int result = 0;
756              bool useStringId = false;
757              string stringId = null;
758              bool useIntId = false;
759              int intId = 0;
760              if (id is string) {
761                  useStringId = true;
762                  stringId = (string)id;
763              } else if (id is int) {
764                  useIntId = true;
765                  intId = (int)id;
766              }
767              int len = totActiveTweens;
768              for (int i = 0; i < len; ++i) {
769                  Tween t = _activeTweens[i];
770                  if (t == null) continue;
771                  if (useStringId) {
772                      if (t.stringId == null || t.stringId != stringId) continue;
773                  } else if (useIntId) {
774                      if (t.intId != intId) continue;
775                  } else if (t.id == null || !Equals(id, t.id)) continue;
776                  if (!playingOnly || t.isPlaying) {
777                      result++;
778                      if (addToList) fillableList.Add(t);
779                  }
780              }
781              return result;
782          }
783          internal static List<Tween> GetTweensByTarget(object target, bool playingOnly, List<Tween> fillableList = null)
784          {
785              if (_requiresActiveReorganization) ReorganizeActiveTweens();
786              if (totActiveTweens <= 0) return null;
787              int len = totActiveTweens;
788              if (fillableList == null) fillableList = new List<Tween>(len);
789              for (int i = 0; i < len; ++i) {
790                  Tween t = _activeTweens[i];
791                  if (t.target != target) continue;
792                  if (!playingOnly || t.isPlaying) fillableList.Add(t);
793              }
794              if (fillableList.Count > 0) return fillableList;
795              return null;
796          }
797          #endregion
798          #region Private Methods
799          static void MarkForKilling(Tween t, bool isSingleTweenManualUpdate = false)
800          {
801              if (isSingleTweenManualUpdate && !isUpdateLoop) {
802                  Despawn(t);
803              } else {
804                  t.active = false;
805                  _KillList.Add(t);
806              }
807          }
808          static void EvaluateTweenLink(Tween t)
809          {
810              TweenLink tLink;
811              if (!_TweenLinks.TryGetValue(t, out tLink)) return;
812              if (tLink.target == null) {
813                  t.active = false; 
814              } else {
815                  bool goActive = tLink.target.activeInHierarchy;
816                  bool justEnabled = !tLink.lastSeenActive && goActive;
817                  bool justDisabled = tLink.lastSeenActive && !goActive;
818                  tLink.lastSeenActive = goActive;
819                  switch (tLink.behaviour) {
820                  case LinkBehaviour.KillOnDisable:
821                      if (!goActive) t.active = false; 
822                      break;
823                  case LinkBehaviour.CompleteAndKillOnDisable:
824                      if (goActive) break;
825                      if (!t.isComplete) t.Complete();
826                      t.active = false; 
827                      break;
828                  case LinkBehaviour.RewindAndKillOnDisable:
829                      if (goActive) break;
830                      t.Rewind(false);
831                      t.active = false; 
832                      break;
833                  case LinkBehaviour.CompleteOnDisable:
834                      if (justDisabled && !t.isComplete) t.Complete();
835                      break;
836                  case LinkBehaviour.RewindOnDisable:
837                      if (justDisabled) t.Rewind(false);
838                      break;
839                  case LinkBehaviour.PauseOnDisable:
840                      if (justDisabled && t.isPlaying) Pause(t);
841                      break;
842                  case LinkBehaviour.PauseOnDisablePlayOnEnable:
843                      if (justDisabled) Pause(t);
844                      else if (justEnabled) Play(t);
845                      break;
846                  case LinkBehaviour.PauseOnDisableRestartOnEnable:
847                      if (justDisabled) Pause(t);
848                      else if (justEnabled) Restart(t);
849                      break;
850                  case LinkBehaviour.PlayOnEnable:
851                      if (justEnabled) Play(t);
852                      break;
853                  case LinkBehaviour.RestartOnEnable:
854                      if (justEnabled) Restart(t);
855                      break;
856                  }
857              }
858          }
859          static void AddActiveTween(Tween t)
860          {
861              if (_requiresActiveReorganization) ReorganizeActiveTweens();
862              if (totActiveTweens < 0) {
863                  Debugger.LogAddActiveTweenError("totActiveTweens < 0", t);
864                  totActiveTweens = 0;
865              }
866              t.active = true;
867              t.updateType = DOTween.defaultUpdateType;
868              t.isIndependentUpdate = DOTween.defaultTimeScaleIndependent;
869              t.activeId = _maxActiveLookupId = totActiveTweens;
870              _activeTweens[totActiveTweens] = t;
871              if (t.updateType == UpdateType.Normal) {
872                  totActiveDefaultTweens++;
873                  hasActiveDefaultTweens = true;
874              } else {
875                  switch (t.updateType) {
876                  case UpdateType.Fixed:
877                      totActiveFixedTweens++;
878                      hasActiveFixedTweens = true;
879                      break;
880                  case UpdateType.Late:
881                      totActiveLateTweens++;
882                      hasActiveLateTweens = true;
883                      break;
884                  default:
885                      totActiveManualTweens++;
886                      hasActiveManualTweens = true;
887                      break;
888                  }
889              }
890              totActiveTweens++;
891              if (t.tweenType == TweenType.Tweener) totActiveTweeners++;
892              else totActiveSequences++;
893              hasActiveTweens = true;
894          }
895          static void ReorganizeActiveTweens()
896          {
897              if (totActiveTweens <= 0) {
898                  _maxActiveLookupId = -1;
899                  _requiresActiveReorganization = false;
900                  _reorganizeFromId = -1;
901                  return;
902              } else if (_reorganizeFromId == _maxActiveLookupId) {
903                  _maxActiveLookupId--;
904                  _requiresActiveReorganization = false;
905                  _reorganizeFromId = -1;
906                  return;
907              }
908              int shift = 1;
909              int len = _maxActiveLookupId + 1;
910              _maxActiveLookupId = _reorganizeFromId - 1;
911              for (int i = _reorganizeFromId + 1; i < len; ++i) {
912                  Tween t = _activeTweens[i];
913                  if (t == null) {
914                      shift++;
915                      continue;
916                  }
917                  t.activeId = _maxActiveLookupId = i - shift;
918                  _activeTweens[i - shift] = t;
919                  _activeTweens[i] = null;
920              }
921              _requiresActiveReorganization = false;
922              _reorganizeFromId = -1;
923          }
924          static void DespawnActiveTweens(List<Tween> tweens)
925          {
926              int count = tweens.Count - 1;
927              for (int i = count; i > -1; --i) Despawn(tweens[i]);
928          }
929          static void RemoveActiveTween(Tween t)
930          {
931              int index = t.activeId;
932              if (_totTweenLinks > 0) RemoveTweenLink(t);
933              t.activeId = -1;
934              _requiresActiveReorganization = true;
935              if (_reorganizeFromId == -1 || _reorganizeFromId > index) _reorganizeFromId = index;
936              _activeTweens[index] = null;
937              if (t.updateType == UpdateType.Normal) {
938                  if (totActiveDefaultTweens > 0) {
939                      totActiveDefaultTweens--;
940                      hasActiveDefaultTweens = totActiveDefaultTweens > 0;
941                  } else {
942                      Debugger.LogRemoveActiveTweenError("totActiveDefaultTweens < 0", t);
943                  }
944              } else {
945                  switch (t.updateType) {
946                  case UpdateType.Fixed:
947                      if (totActiveFixedTweens > 0) {
948                          totActiveFixedTweens--;
949                          hasActiveFixedTweens = totActiveFixedTweens > 0;
950                      } else {
951                          Debugger.LogRemoveActiveTweenError("totActiveFixedTweens < 0", t);
952                      }
953                      break;
954                  case UpdateType.Late:
955                      if (totActiveLateTweens > 0) {
956                          totActiveLateTweens--;
957                          hasActiveLateTweens = totActiveLateTweens > 0;
958                      } else {
959                          Debugger.LogRemoveActiveTweenError("totActiveLateTweens < 0", t);
960                      }
961                      break;
962                  default:
963                      if (totActiveManualTweens > 0) {
964                          totActiveManualTweens--;
965                          hasActiveManualTweens = totActiveManualTweens > 0;
966                      } else {
967                          Debugger.LogRemoveActiveTweenError("totActiveManualTweens < 0", t);
968                      }
969                      break;
970                  }
971              }
972              totActiveTweens--;
973              hasActiveTweens = totActiveTweens > 0;
974              if (t.tweenType == TweenType.Tweener) totActiveTweeners--;
975              else totActiveSequences--;
976              if (totActiveTweens < 0) {
977                  totActiveTweens = 0;
978                  Debugger.LogRemoveActiveTweenError("totActiveTweens < 0", t);
979              }
980              if (totActiveTweeners < 0) {
981                  totActiveTweeners = 0;
982                  Debugger.LogRemoveActiveTweenError("totActiveTweeners < 0", t);
983              }
984              if (totActiveSequences < 0) {
985                  totActiveSequences = 0;
986                  Debugger.LogRemoveActiveTweenError("totActiveSequences < 0", t);
987              }
988          }
989          static void ClearTweenArray(Tween[] tweens)
990          {
991              int len = tweens.Length;
992              for (int i = 0; i < len; i++) tweens[i] = null;
993          }
994          static void IncreaseCapacities(CapacityIncreaseMode increaseMode)
995          {
996              int killAdd = 0;
997              int increaseTweenersBy = Mathf.Max((int)(maxTweeners * 1.5f), _DefaultMaxTweeners);
998              int increaseSequencesBy = Mathf.Max((int)(maxSequences * 1.5f), _DefaultMaxSequences);
999              switch (increaseMode) {
1000              case CapacityIncreaseMode.TweenersOnly:
1001                  killAdd += increaseTweenersBy;
1002                  maxTweeners += increaseTweenersBy;
1003                  Array.Resize(ref _pooledTweeners, maxTweeners);
1004                  break;
1005              case CapacityIncreaseMode.SequencesOnly:
1006                  killAdd += increaseSequencesBy;
1007                  maxSequences += increaseSequencesBy;
1008                  break;
1009              default:
1010                  killAdd += increaseTweenersBy + increaseSequencesBy;
1011                  maxTweeners += increaseTweenersBy;
1012                  maxSequences += increaseSequencesBy;
1013                  Array.Resize(ref _pooledTweeners, maxTweeners);
1014                  break;
1015              }
1016              maxActive = maxTweeners + maxSequences;
1017              Array.Resize(ref _activeTweens, maxActive);
1018              if (killAdd > 0) _KillList.Capacity += killAdd;
1019          }
1020          #region Helpers
1021          static void ManageOnRewindCallbackWhenAlreadyRewinded(Tween t, bool isPlayBackwardsOrSmoothRewind)
1022          {
1023              if (t.onRewind == null) return;
1024              if (isPlayBackwardsOrSmoothRewind) {
1025                  if (DOTween.rewindCallbackMode == RewindCallbackMode.FireAlways) t.onRewind();
1026              } else {
1027                  if (DOTween.rewindCallbackMode != RewindCallbackMode.FireIfPositionChanged) t.onRewind();
1028              }
1029          }
1030          #endregion
1031          #endregion
1032          #region Debug Methods
1033  #if DEBUG
1034          static void VerifyActiveTweensList()
1035          {
1036              int nullTweensWithinLookup = 0, inactiveTweensWithinLookup = 0, activeTweensAfterNull = 0;
1037              List<int> activeTweensAfterNullIds = new List<int>();
1038              for (int i = 0; i < _maxActiveLookupId + 1; ++i) {
1039                  Tween t = _activeTweens[i];
1040                  if (t == null) nullTweensWithinLookup++;
1041                  else if (!t.active) inactiveTweensWithinLookup++;
1042              }
1043              int len = _activeTweens.Length;
1044              int firstNullIndex = -1;
1045              for (int i = 0; i < len; ++i) {
1046                  if (firstNullIndex == -1 && _activeTweens[i] == null) firstNullIndex = i;
1047                  else if (firstNullIndex > -1 && _activeTweens[i] != null) {
1048                      activeTweensAfterNull++;
1049                      activeTweensAfterNullIds.Add(i);
1050                  }
1051              }
1052              if (nullTweensWithinLookup > 0 || inactiveTweensWithinLookup > 0 || activeTweensAfterNull > 0) {
1053                  string s = "VerifyActiveTweensList WARNING:";
1054                  if (isUpdateLoop) s += " - UPDATE LOOP (" + updateLoopCount + ")";
1055                  if (nullTweensWithinLookup > 0) s += " - NULL Tweens Within Lookup (" + nullTweensWithinLookup + ")";
1056                  if (inactiveTweensWithinLookup > 0) s += " - Inactive Tweens Within Lookup (" + inactiveTweensWithinLookup + ")";
1057                  if (activeTweensAfterNull > 0) {
1058                      string indexes = "";
1059                      len = activeTweensAfterNullIds.Count;
1060                      for (int i = 0; i < len; ++i) {
1061                          if (i > 0) indexes += ",";
1062                          indexes += activeTweensAfterNullIds[i];
1063                      }
1064                      s += " - Active tweens after NULL ones (" + (firstNullIndex - 1) + "/" + activeTweensAfterNull + "[" + indexes + "]" + ")";
1065                  }
1066                  Debug.LogWarning(s);
1067              }
1068          }
1069  #endif
1070          #endregion
1071          #region Internal Classes
1072          internal enum CapacityIncreaseMode
1073          {
1074              TweenersAndSequences,
1075              TweenersOnly,
1076              SequencesOnly
1077          }
1078          #endregion
1079      }
1080  }
</code></pre>
        </div>
        <div class="column">
            <h3>EarTrumpet-MDEwOlJlcG9zaXRvcnkzODkxOTcwMg==-flat-ActionsCategoryViewModel.cs</h3>
            <pre><code>1  using EarTrumpet.Extensions;
2  using EarTrumpet.UI.Helpers;
3  using EarTrumpet.UI.ViewModels;
4  using EarTrumpet.Actions.DataModel.Serialization;
5  using System;
6  using System.Collections.ObjectModel;
7  using System.Linq;
8  namespace EarTrumpet.Actions.ViewModel
9  {
10      public class ActionsCategoryViewModel : SettingsCategoryViewModel
11      {
12          public ActionsCategoryViewModel()
13              : base(Properties.Resources.MyActionsText, "\xE950", Properties.Resources.AddonDescriptionText, EarTrumpetActionsAddon.Current.Manifest.Id, new ObservableCollection<SettingsPageViewModel>())
14          {
15              var actions = EarTrumpetActionsAddon.Current.Actions;
16              EarTrumpetActionsAddon.Current.Actions = EarTrumpetActionsAddon.Current.Actions;
17              Pages.AddRange(actions.Select(a => new EarTrumpetActionViewModel(this, a)));
18              Pages.Add(new ImportExportPageViewModel(this));
19              Toolbar = new ToolbarItemViewModel[] { new ToolbarItemViewModel{
20                  Command = new RelayCommand(() =>
21                  {
22                      var vm = new EarTrumpetActionViewModel(this, new EarTrumpetAction { DisplayName = Properties.Resources.NewActionText });
<span onclick='openModal()' class='match'>23                      vm.IsWorkSaved = false;
24                      vm.IsPersisted = false;
25                      vm.PropertyChanged += (_, e) =>
</span>26                      {
27                          if (e.PropertyName == nameof(vm.IsSelected) &&
28                              vm.IsSelected && !Pages.Contains(vm))
29                          {
30                              Pages.Insert(0, vm);
31                          }
32                      };
33                      Selected = vm;
34                  }),
35                  DisplayName = Properties.Resources.NewActionText,
36                  Glyph = "\xE948",
37                  GlyphFontSize = 15,
38              } };
39              if (Pages.Count == 2)
40              {
41                  Toolbar[0].Command.Execute(null);
42              }
43          }
44          internal void ReloadSavedPages()
45          {
46              foreach (var item in Pages.Where(p => p is EarTrumpetActionViewModel).ToList())
47              {
48                  Pages.Remove(item);
49              }
50              Pages.InsertRange(0, new System.Collections.ObjectModel.ObservableCollection<SettingsPageViewModel>(EarTrumpetActionsAddon.Current.Actions.Select(a => new EarTrumpetActionViewModel(this, a))));
51              Selected = Pages[0];
52          }
53          public void Delete(EarTrumpetActionViewModel earTrumpetActionViewModel, bool promptOverride = false)
54          {
55              Action doRemove = () =>
56              {
57                  var actions = EarTrumpetActionsAddon.Current.Actions.ToList();
58                  if (actions.Any(a => a.Id == earTrumpetActionViewModel.Id))
59                  {
60                      actions.Remove(item => item.Id == earTrumpetActionViewModel.Id);
61                  }
62                  EarTrumpetActionsAddon.Current.Actions = actions.ToArray();
63                  if (Pages.Any(a => a == earTrumpetActionViewModel))
64                  {
65                      Pages.Remove(earTrumpetActionViewModel);
66                  }
67              };
68              if (earTrumpetActionViewModel.IsPersisted && !promptOverride)
69              {
70                  _parent.ShowDialog(Properties.Resources.DeleteActionDialogTitle, Properties.Resources.DeleteActionDialogText,
71                      Properties.Resources.DeleteActionDialogYesText, Properties.Resources.DeleteActionDialogNoText, doRemove, () => { });
72              }
73              else
74              {
75                  doRemove();
76              }
77          }
78          public void Save(EarTrumpetActionViewModel earTrumpetActionViewModel)
79          {
80              var actions = EarTrumpetActionsAddon.Current.Actions.ToList();
81              if (actions.Any(a => a.Id == earTrumpetActionViewModel.Id))
82              {
83                  actions.Remove(item => item.Id == earTrumpetActionViewModel.Id);
84              }
85              actions.Insert(0, earTrumpetActionViewModel.GetAction());
86              EarTrumpetActionsAddon.Current.Actions = actions.ToArray();
87              earTrumpetActionViewModel.IsWorkSaved = true;
88              if (Pages.Any(a => a == earTrumpetActionViewModel))
89              {
90                  Pages.Remove(earTrumpetActionViewModel);
91              }
92              Pages.Insert(0, earTrumpetActionViewModel);
93              Selected = Pages[0];
94          }
95          public void CompleteNavigation(NavigationCookie cookie)
96          {
97              _parent.CompleteNavigation(cookie);
98          }
99      }
100  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenManager_146.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from EarTrumpet-MDEwOlJlcG9zaXRvcnkzODkxOTcwMg==-flat-ActionsCategoryViewModel.cs</div>
                </div>
                <div class="column column_space"><pre><code>635                  t.isBackwards = false;
636                  t.isPlaying = false;
637                  return false;
</pre></code></div>
                <div class="column column_space"><pre><code>23                      vm.IsWorkSaved = false;
24                      vm.IsPersisted = false;
25                      vm.PropertyChanged += (_, e) =>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    