
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobRunner.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net.Http;
6  using System.Net.Http.Headers;
7  using System.Text;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines;
12  using GitHub.DistributedTask.WebApi;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Services.Common;
17  using GitHub.Services.WebApi;
18  using Pipelines = GitHub.DistributedTask.Pipelines;
19  namespace GitHub.Runner.Worker
20  {
21      [ServiceLocator(Default = typeof(JobRunner))]
22      public interface IJobRunner : IRunnerService
23      {
24          Task<TaskResult> RunAsync(AgentJobRequestMessage message, CancellationToken jobRequestCancellationToken);
25      }
26      public sealed class JobRunner : RunnerService, IJobRunner
27      {
28          private IJobServerQueue _jobServerQueue;
29          private RunnerSettings _runnerSettings;
30          private ITempDirectoryManager _tempDirectoryManager;
31          public async Task<TaskResult> RunAsync(AgentJobRequestMessage message, CancellationToken jobRequestCancellationToken)
32          {
33              Trace.Entering();
34              ArgUtil.NotNull(message, nameof(message));
35              ArgUtil.NotNull(message.Resources, nameof(message.Resources));
36              ArgUtil.NotNull(message.Variables, nameof(message.Variables));
37              ArgUtil.NotNull(message.Steps, nameof(message.Steps));
38              Trace.Info("Job ID {0}", message.JobId);
39              DateTime jobStartTimeUtc = DateTime.UtcNow;
40              IRunnerService server = null;
41              if (message.Variables.TryGetValue(Constants.Variables.System.OrchestrationId, out VariableValue orchestrationId) &&
42                  !string.IsNullOrEmpty(orchestrationId.Value))
43              {
44                  HostContext.UserAgents.Add(new ProductInfoHeaderValue("OrchestrationId", orchestrationId.Value));
45              }
46              ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
47              if (MessageUtil.IsRunServiceJob(message.MessageType))
48              {
49                  var runServer = HostContext.GetService<IRunServer>();
50                  VssCredentials jobServerCredential = VssUtil.GetVssCredential(systemConnection);
51                  await runServer.ConnectAsync(systemConnection.Url, jobServerCredential);
52                  server = runServer;
53                  message.Variables.TryGetValue("system.github.launch_endpoint", out VariableValue launchEndpointVariable);
54                  var launchReceiverEndpoint = launchEndpointVariable?.Value;
55                  if (systemConnection?.Authorization != null &&
56                      systemConnection.Authorization.Parameters.TryGetValue("AccessToken", out var accessToken) &&
57                      !string.IsNullOrEmpty(accessToken) &&
58                      !string.IsNullOrEmpty(launchReceiverEndpoint))
59                  {
60                      Trace.Info("Initializing launch client");
61                      var launchServer = HostContext.GetService<ILaunchServer>();
62                      launchServer.InitializeLaunchClient(new Uri(launchReceiverEndpoint), accessToken);
63                  }
64                  _jobServerQueue = HostContext.GetService<IJobServerQueue>();
65                  _jobServerQueue.Start(message, resultServiceOnly: true);
66              }
67              else
68              {
69                  var jobServer = HostContext.GetService<IJobServer>();
70                  VssCredentials jobServerCredential = VssUtil.GetVssCredential(systemConnection);
71                  Uri jobServerUrl = systemConnection.Url;
72                  Trace.Info($"Creating job server with URL: {jobServerUrl}");
73                  _jobServerQueue = HostContext.GetService<IJobServerQueue>();
74                  VssConnection jobConnection = VssUtil.CreateConnection(jobServerUrl, jobServerCredential, new DelegatingHandler[] { new ThrottlingReportHandler(_jobServerQueue) });
75                  await jobServer.ConnectAsync(jobConnection);
76                  _jobServerQueue.Start(message);
77                  server = jobServer;
78              }
79              HostContext.WritePerfCounter($"WorkerJobServerQueueStarted_{message.RequestId.ToString()}");
80              IExecutionContext jobContext = null;
81              CancellationTokenRegistration? runnerShutdownRegistration = null;
82              try
83              {
84                  jobContext = HostContext.CreateService<IExecutionContext>();
85                  jobContext.InitializeJob(message, jobRequestCancellationToken);
86                  Trace.Info("Starting the job execution context.");
87                  jobContext.Start();
88                  jobContext.Debug($"Starting: {message.JobDisplayName}");
89                  runnerShutdownRegistration = HostContext.RunnerShutdownToken.Register(() =>
90                  {
91                      string errorMessage;
92                      switch (HostContext.RunnerShutdownReason)
93                      {
94                          case ShutdownReason.UserCancelled:
95                              errorMessage = "The runner has received a shutdown signal. This can happen when the runner service is stopped, or a manually started runner is canceled.";
96                              break;
97                          case ShutdownReason.OperatingSystemShutdown:
98                              errorMessage = $"Operating system is shutting down for computer '{Environment.MachineName}'";
99                              break;
100                          default:
101                              throw new ArgumentException(HostContext.RunnerShutdownReason.ToString(), nameof(HostContext.RunnerShutdownReason));
102                      }
103                      var issue = new Issue() { Type = IssueType.Error, Message = errorMessage };
104                      jobContext.AddIssue(issue, ExecutionContextLogOptions.Default);
105                  });
106                  string workDirectory = HostContext.GetDirectory(WellKnownDirectory.Work);
107                  Trace.Info($"Validating directory permissions for: '{workDirectory}'");
108                  try
109                  {
110                      Directory.CreateDirectory(workDirectory);
111                      IOUtil.ValidateExecutePermission(workDirectory);
112                  }
113                  catch (Exception ex)
114                  {
115                      Trace.Error(ex);
116                      jobContext.Error(ex);
117                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
118                  }
119                  if (jobContext.Global.WriteDebug)
120                  {
121                      jobContext.SetRunnerContext("debug", "1");
122                  }
123                  jobContext.SetRunnerContext("os", VarUtil.OS);
124                  jobContext.SetRunnerContext("arch", VarUtil.OSArchitecture);
125                  _runnerSettings = HostContext.GetService<IConfigurationStore>().GetSettings();
126                  jobContext.SetRunnerContext("name", _runnerSettings.AgentName);
127                  if (jobContext.Global.Variables.TryGetValue(WellKnownDistributedTaskVariables.RunnerEnvironment, out var runnerEnvironment))
128                  {
129                      jobContext.SetRunnerContext("environment", runnerEnvironment);
130                  }
131                  string toolsDirectory = HostContext.GetDirectory(WellKnownDirectory.Tools);
132                  Directory.CreateDirectory(toolsDirectory);
133                  jobContext.SetRunnerContext("tool_cache", toolsDirectory);
134                  _tempDirectoryManager = HostContext.GetService<ITempDirectoryManager>();
135                  _tempDirectoryManager.InitializeTempDirectory(jobContext);
136                  Trace.Info("Getting job extension.");
137                  IJobExtension jobExtension = HostContext.CreateService<IJobExtension>();
138                  List<IStep> jobSteps = null;
139                  try
140                  {
141                      Trace.Info("Initialize job. Getting all job steps.");
142                      jobSteps = await jobExtension.InitializeJob(jobContext, message);
143                  }
144                  catch (OperationCanceledException ex) when (jobContext.CancellationToken.IsCancellationRequested)
145                  {
146                      Trace.Error($"Job is cancelled during initialize.");
147                      Trace.Error($"Caught exception: {ex}");
148                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Canceled);
149                  }
150                  catch (Exception ex)
151                  {
152                      Trace.Error($"Job initialize failed.");
153                      Trace.Error($"Caught exception from {nameof(jobExtension.InitializeJob)}: {ex}");
154                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
155                  }
156                  Trace.Info($"Total job steps: {jobSteps.Count}.");
157                  Trace.Verbose($"Job steps: '{string.Join(", ", jobSteps.Select(x => x.DisplayName))}'");
158                  HostContext.WritePerfCounter($"WorkerJobInitialized_{message.RequestId.ToString()}");
159                  if (systemConnection.Data.TryGetValue("GenerateIdTokenUrl", out var generateIdTokenUrl) &&
160                      !string.IsNullOrEmpty(generateIdTokenUrl))
161                  {
162                      Trace.Info($"Waiting for job to be marked as started.");
163                      await Task.WhenAny(_jobServerQueue.JobRecordUpdated.Task, Task.Delay(1000));
164                  }
165                  Trace.Info("Run all job steps.");
166                  var stepsRunner = HostContext.GetService<IStepsRunner>();
167                  try
168                  {
169                      foreach (var step in jobSteps)
170                      {
171                          jobContext.JobSteps.Enqueue(step);
172                      }
173                      await stepsRunner.RunAsync(jobContext);
174                  }
175                  catch (Exception ex)
176                  {
177                      Trace.Error($"Caught exception from job steps {nameof(StepsRunner)}: {ex}");
178                      jobContext.Error(ex);
179                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
180                  }
181                  finally
182                  {
183                      Trace.Info("Finalize job.");
184                      jobExtension.FinalizeJob(jobContext, message, jobStartTimeUtc);
185                  }
186                  Trace.Info($"Job result after all job steps finish: {jobContext.Result ?? TaskResult.Succeeded}");
187                  Trace.Info("Completing the job execution context.");
188                  return await CompleteJobAsync(server, jobContext, message);
189              }
190              finally
191              {
192                  if (runnerShutdownRegistration != null)
193                  {
194                      runnerShutdownRegistration.Value.Dispose();
195                      runnerShutdownRegistration = null;
196                  }
197                  await ShutdownQueue(throwOnFailure: false);
198              }
199          }
200          private async Task<TaskResult> CompleteJobAsync(IRunnerService server, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
201          {
202              if (server is IRunServer runServer)
203              {
204                  return await CompleteJobAsync(runServer, jobContext, message, taskResult);
205              }
206              else if (server is IJobServer jobServer)
207              {
208                  return await CompleteJobAsync(jobServer, jobContext, message, taskResult);
209              }
210              else
211              {
212                  throw new NotSupportedException();
213              }
214          }
215          private async Task<TaskResult> CompleteJobAsync(IRunServer runServer, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
216          {
217              jobContext.Debug($"Finishing: {message.JobDisplayName}");
218              TaskResult result = jobContext.Complete(taskResult);
219              if (jobContext.Global.Variables.TryGetValue("Node12ActionsWarnings", out var node12Warnings))
220              {
221                  var actions = string.Join(", ", StringUtil.ConvertFromJson<HashSet<string>>(node12Warnings));
222                  jobContext.Warning(string.Format(Constants.Runner.Node12DetectedAfterEndOfLife, actions));
223              }
224              _tempDirectoryManager?.CleanupTempDirectory();
225              LoadFromTelemetryFile(jobContext.Global.JobTelemetry);
226              MaskTelemetrySecrets(jobContext.Global.JobTelemetry);
227              string environmentUrl = null;
228              if (jobContext.ActionsEnvironment?.Url is StringToken urlStringToken)
229              {
230                  environmentUrl = urlStringToken.Value;
231              }
232              Trace.Info($"Raising job completed against run service");
233              var completeJobRetryLimit = 5;
234              var exceptions = new List<Exception>();
235              while (completeJobRetryLimit-- > 0)
236              {
237                  try
238                  {
239                      await runServer.CompleteJobAsync(message.Plan.PlanId, message.JobId, result, jobContext.JobOutputs, jobContext.Global.StepsResult, jobContext.Global.JobAnnotations, environmentUrl, default);
240                      return result;
241                  }
242                  catch (Exception ex)
243                  {
244                      Trace.Error($"Catch exception while attempting to complete job {message.JobId}, job request {message.RequestId}.");
245                      Trace.Error(ex);
246                      exceptions.Add(ex);
247                  }
248                  await Task.Delay(TimeSpan.FromSeconds(5));
249              }
250              throw new AggregateException(exceptions);
251          }
252          private async Task<TaskResult> CompleteJobAsync(IJobServer jobServer, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
253          {
254              jobContext.Debug($"Finishing: {message.JobDisplayName}");
255              TaskResult result = jobContext.Complete(taskResult);
256              if (_runnerSettings.DisableUpdate == true)
257              {
258                  try
259                  {
<span onclick='openModal()' class='match'>260                      var currentVersion = new PackageVersion(BuildConstants.RunnerPackage.Version);
261                      ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
</span>262                      VssCredentials serverCredential = VssUtil.GetVssCredential(systemConnection);
263                      var runnerServer = HostContext.GetService<IRunnerServer>();
264                      await runnerServer.ConnectAsync(systemConnection.Url, serverCredential);
265                      var serverPackages = await runnerServer.GetPackagesAsync("agent", BuildConstants.RunnerPackage.PackageName, 5, includeToken: false, cancellationToken: CancellationToken.None);
266                      if (serverPackages.Count > 0)
267                      {
268                          serverPackages = serverPackages.OrderByDescending(x => x.Version).ToList();
269                          Trace.Info($"Newer packages {StringUtil.ConvertToJson(serverPackages.Select(x => x.Version.ToString()))}");
270                          var warnOnFailedJob = false; 
271                          var warnOnOldRunnerVersion = false; 
272                          if (serverPackages.Any(x => x.Version.CompareTo(currentVersion) > 0))
273                          {
274                              Trace.Info($"Current runner version {currentVersion} is behind the latest runner version {serverPackages[0].Version}.");
275                              warnOnFailedJob = true;
276                          }
277                          if (serverPackages.Where(x => x.Version.Major == currentVersion.Major && x.Version.Minor > currentVersion.Minor).Count() > 1)
278                          {
279                              Trace.Info($"Current runner version {currentVersion} is way behind the latest runner version {serverPackages[0].Version}.");
280                              warnOnOldRunnerVersion = true;
281                          }
282                          if (result == TaskResult.Failed && warnOnFailedJob)
283                          {
284                              jobContext.Warning($"This job failure may be caused by using an out of date self-hosted runner. You are currently using runner version {currentVersion}. Please update to the latest version {serverPackages[0].Version}");
285                          }
286                          else if (warnOnOldRunnerVersion)
287                          {
288                              jobContext.Warning($"This self-hosted runner is currently using runner version {currentVersion}. This version is out of date. Please update to the latest version {serverPackages[0].Version}");
289                          }
290                      }
291                  }
292                  catch (Exception ex)
293                  {
294                      Trace.Error($"Caught exception during runner version check: {ex}");
295                  }
296              }
297              if (jobContext.Global.Variables.TryGetValue("Node12ActionsWarnings", out var node12Warnings))
298              {
299                  var actions = string.Join(", ", StringUtil.ConvertFromJson<HashSet<string>>(node12Warnings));
300                  jobContext.Warning(string.Format(Constants.Runner.Node12DetectedAfterEndOfLife, actions));
301              }
302              try
303              {
304                  await ShutdownQueue(throwOnFailure: true);
305              }
306              catch (Exception ex)
307              {
308                  Trace.Error($"Caught exception from {nameof(JobServerQueue)}.{nameof(_jobServerQueue.ShutdownAsync)}");
309                  Trace.Error("This indicate a failure during publish output variables. Fail the job to prevent unexpected job outputs.");
310                  Trace.Error(ex);
311                  result = TaskResultUtil.MergeTaskResults(result, TaskResult.Failed);
312              }
313              _tempDirectoryManager?.CleanupTempDirectory();
314              if (!jobContext.Global.Features.HasFlag(PlanFeatures.JobCompletedPlanEvent))
315              {
316                  Trace.Info($"Skip raise job completed event call from worker because Plan version is {message.Plan.Version}");
317                  return result;
318              }
319              LoadFromTelemetryFile(jobContext.Global.JobTelemetry);
320              MaskTelemetrySecrets(jobContext.Global.JobTelemetry);
321              Trace.Info($"Raising job completed event");
322              var jobCompletedEvent = new JobCompletedEvent(message.RequestId, message.JobId, result, jobContext.JobOutputs, jobContext.ActionsEnvironment, jobContext.Global.StepsTelemetry, jobContext.Global.JobTelemetry);
323              var completeJobRetryLimit = 5;
324              var exceptions = new List<Exception>();
325              while (completeJobRetryLimit-- > 0)
326              {
327                  try
328                  {
329                      await jobServer.RaisePlanEventAsync(message.Plan.ScopeIdentifier, message.Plan.PlanType, message.Plan.PlanId, jobCompletedEvent, default(CancellationToken));
330                      return result;
331                  }
332                  catch (TaskOrchestrationPlanNotFoundException ex)
333                  {
334                      Trace.Error($"TaskOrchestrationPlanNotFoundException received, while attempting to raise JobCompletedEvent for job {message.JobId}.");
335                      Trace.Error(ex);
336                      return TaskResult.Failed;
337                  }
338                  catch (TaskOrchestrationPlanSecurityException ex)
339                  {
340                      Trace.Error($"TaskOrchestrationPlanSecurityException received, while attempting to raise JobCompletedEvent for job {message.JobId}.");
341                      Trace.Error(ex);
342                      return TaskResult.Failed;
343                  }
344                  catch (TaskOrchestrationPlanTerminatedException ex)
345                  {
346                      Trace.Error($"TaskOrchestrationPlanTerminatedException received, while attempting to raise JobCompletedEvent for job {message.JobId}.");
347                      Trace.Error(ex);
348                      return TaskResult.Failed;
349                  }
350                  catch (Exception ex)
351                  {
352                      Trace.Error($"Catch exception while attempting to raise JobCompletedEvent for job {message.JobId}, job request {message.RequestId}.");
353                      Trace.Error(ex);
354                      exceptions.Add(ex);
355                  }
356                  await Task.Delay(TimeSpan.FromSeconds(5));
357              }
358              throw new AggregateException(exceptions);
359          }
360          private void MaskTelemetrySecrets(List<JobTelemetry> jobTelemetry)
361          {
362              foreach (var telemetryItem in jobTelemetry)
363              {
364                  telemetryItem.Message = HostContext.SecretMasker.MaskSecrets(telemetryItem.Message);
365              }
366          }
367          private void LoadFromTelemetryFile(List<JobTelemetry> jobTelemetry)
368          {
369              try
370              {
371                  var telemetryFilePath = HostContext.GetConfigFile(WellKnownConfigFile.Telemetry);
372                  if (File.Exists(telemetryFilePath))
373                  {
374                      var telemetryData = File.ReadAllText(telemetryFilePath, Encoding.UTF8);
375                      var telemetry = new JobTelemetry
376                      {
377                          Message = $"Runner File Telemetry:\n{telemetryData}",
378                          Type = JobTelemetryType.General
379                      };
380                      jobTelemetry.Add(telemetry);
381                      IOUtil.DeleteFile(telemetryFilePath);
382                  }
383              }
384              catch (Exception e)
385              {
386                  Trace.Error("Error when trying to load telemetry from telemetry file");
387                  Trace.Error(e);
388              }
389          }
390          private async Task ShutdownQueue(bool throwOnFailure)
391          {
392              if (_jobServerQueue != null)
393              {
394                  try
395                  {
396                      Trace.Info("Shutting down the job server queue.");
397                      await _jobServerQueue.ShutdownAsync();
398                  }
399                  catch (Exception ex) when (!throwOnFailure)
400                  {
401                      Trace.Error($"Caught exception from {nameof(JobServerQueue)}.{nameof(_jobServerQueue.ShutdownAsync)}");
402                      Trace.Error(ex);
403                  }
404                  finally
405                  {
406                      _jobServerQueue = null; 
407                  }
408              }
409          }
410      }
411  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-CookieConsentTests.cs</h3>
            <pre><code>1  using System;
2  using System.IO;
3  using System.Threading.Tasks;
4  using Microsoft.AspNetCore.Builder;
5  using Microsoft.AspNetCore.Hosting;
6  using Microsoft.AspNetCore.Http;
7  using Microsoft.AspNetCore.Http.Features;
8  using Microsoft.AspNetCore.TestHost;
9  using Microsoft.Extensions.DependencyInjection;
10  using Microsoft.Net.Http.Headers;
11  using Xunit;
12  namespace Microsoft.AspNetCore.CookiePolicy.Test
13  {
14      public class CookieConsentTests
15      {
16          [Fact]
17          public async Task ConsentChecksOffByDefault()
18          {
19              var httpContext = await RunTestAsync(options => { }, requestContext => { }, context =>
20              {
21                  var feature = context.Features.Get<ITrackingConsentFeature>();
22                  Assert.False(feature.IsConsentNeeded);
23                  Assert.False(feature.HasConsent);
24                  Assert.True(feature.CanTrack);
25                  context.Response.Cookies.Append("Test", "Value");
26                  return Task.CompletedTask;
27              });
28              Assert.Equal("Test=Value; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
29          }
30          [Fact]
31          public async Task ConsentEnabledForTemplateScenario()
32          {
33              var httpContext = await RunTestAsync(options =>
34              {
35                  options.CheckConsentNeeded = context => true;
36              },
37              requestContext => { }, context =>
38              {
39                  var feature = context.Features.Get<ITrackingConsentFeature>();
40                  Assert.True(feature.IsConsentNeeded);
41                  Assert.False(feature.HasConsent);
42                  Assert.False(feature.CanTrack);
43                  context.Response.Cookies.Append("Test", "Value");
44                  return Task.CompletedTask;
45              });
46              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
47          }
48          [Fact]
49          public async Task NonEssentialCookiesWithOptionsExcluded()
50          {
51              var httpContext = await RunTestAsync(options =>
52              {
53                  options.CheckConsentNeeded = context => true;
54              },
55              requestContext => { }, context =>
56              {
57                  var feature = context.Features.Get<ITrackingConsentFeature>();
58                  Assert.True(feature.IsConsentNeeded);
59                  Assert.False(feature.HasConsent);
60                  Assert.False(feature.CanTrack);
61                  context.Response.Cookies.Append("Test", "Value", new CookieOptions() { IsEssential = false });
62                  return Task.CompletedTask;
63              });
64              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
65          }
66          [Fact]
67          public async Task NonEssentialCookiesCanBeAllowedViaOnAppendCookie()
68          {
69              var httpContext = await RunTestAsync(options =>
70              {
71                  options.CheckConsentNeeded = context => true;
72                  options.OnAppendCookie = context =>
73                  {
74                      Assert.True(context.IsConsentNeeded);
75                      Assert.False(context.HasConsent);
76                      Assert.False(context.IssueCookie);
77                      context.IssueCookie = true;
78                  };
79              },
80              requestContext => { }, context =>
81              {
82                  var feature = context.Features.Get<ITrackingConsentFeature>();
83                  Assert.True(feature.IsConsentNeeded);
84                  Assert.False(feature.HasConsent);
85                  Assert.False(feature.CanTrack);
86                  context.Response.Cookies.Append("Test", "Value", new CookieOptions() { IsEssential = false });
87                  return Task.CompletedTask;
88              });
89              Assert.Equal("Test=Value; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
90          }
91          [Fact]
92          public async Task NeedsConsentDoesNotPreventEssentialCookies()
93          {
94              var httpContext = await RunTestAsync(options =>
95              {
96                  options.CheckConsentNeeded = context => true;
97              },
98              requestContext => { }, context =>
99              {
100                  var feature = context.Features.Get<ITrackingConsentFeature>();
101                  Assert.True(feature.IsConsentNeeded);
102                  Assert.False(feature.HasConsent);
103                  Assert.False(feature.CanTrack);
104                  context.Response.Cookies.Append("Test", "Value", new CookieOptions() { IsEssential = true });
105                  return Task.CompletedTask;
106              });
107              Assert.Equal("Test=Value; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
108          }
109          [Fact]
110          public async Task EssentialCookiesCanBeExcludedByOnAppendCookie()
111          {
112              var httpContext = await RunTestAsync(options =>
113              {
114                  options.CheckConsentNeeded = context => true;
115                  options.OnAppendCookie = context =>
116                  {
117                      Assert.True(context.IsConsentNeeded);
118                      Assert.True(context.HasConsent);
119                      Assert.True(context.IssueCookie);
120                      context.IssueCookie = false;
121                  };
122              },
123              requestContext =>
124              {
125                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
126              },
127              context =>
128              {
129                  var feature = context.Features.Get<ITrackingConsentFeature>();
130                  Assert.True(feature.IsConsentNeeded);
131                  Assert.True(feature.HasConsent);
132                  Assert.True(feature.CanTrack);
133                  context.Response.Cookies.Append("Test", "Value", new CookieOptions() { IsEssential = true });
134                  return Task.CompletedTask;
135              });
136              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
137          }
138          [Fact]
139          public async Task HasConsentReadsRequestCookie()
140          {
141              var httpContext = await RunTestAsync(options =>
142              {
143                  options.CheckConsentNeeded = context => true;
144              },
145              requestContext =>
146              {
147                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
148              },
149              context =>
150              {
151                  var feature = context.Features.Get<ITrackingConsentFeature>();
152                  Assert.True(feature.IsConsentNeeded);
153                  Assert.True(feature.HasConsent);
154                  Assert.True(feature.CanTrack);
155                  context.Response.Cookies.Append("Test", "Value");
156                  return Task.CompletedTask;
157              });
158              Assert.Equal("Test=Value; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
159          }
160          [Fact]
161          public async Task HasConsentIgnoresInvalidRequestCookie()
162          {
163              var httpContext = await RunTestAsync(options =>
164              {
165                  options.CheckConsentNeeded = context => true;
166              },
167              requestContext =>
168              {
169                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=IAmATeapot";
170              },
171              context =>
172              {
173                  var feature = context.Features.Get<ITrackingConsentFeature>();
174                  Assert.True(feature.IsConsentNeeded);
175                  Assert.False(feature.HasConsent);
176                  Assert.False(feature.CanTrack);
177                  context.Response.Cookies.Append("Test", "Value");
178                  return Task.CompletedTask;
179              });
180              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
181          }
182          [Fact]
183          public async Task GrantConsentSetsCookie()
184          {
185              var httpContext = await RunTestAsync(options =>
186              {
187                  options.CheckConsentNeeded = context => true;
188              },
189              requestContext => { },
190              context =>
191              {
192                  var feature = context.Features.Get<ITrackingConsentFeature>();
193                  Assert.True(feature.IsConsentNeeded);
194                  Assert.False(feature.HasConsent);
195                  Assert.False(feature.CanTrack);
196                  feature.GrantConsent();
197                  Assert.True(feature.IsConsentNeeded);
198                  Assert.True(feature.HasConsent);
199                  Assert.True(feature.CanTrack);
200                  context.Response.Cookies.Append("Test", "Value");
201                  return Task.CompletedTask;
202              });
203              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
204              Assert.Equal(2, cookies.Count);
205              var consentCookie = cookies[0];
206              Assert.Equal(".AspNet.Consent", consentCookie.Name);
207              Assert.Equal("yes", consentCookie.Value);
208              Assert.True(consentCookie.Expires.HasValue);
209              Assert.True(consentCookie.Expires.Value > DateTimeOffset.Now + TimeSpan.FromDays(364));
210              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
211              Assert.NotNull(consentCookie.Expires);
212              var testCookie = cookies[1];
213              Assert.Equal("Test", testCookie.Name);
214              Assert.Equal("Value", testCookie.Value);
215              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
216              Assert.Null(testCookie.Expires);
217          }
218          [Fact]
219          public async Task GrantConsentAppliesPolicyToConsentCookie()
220          {
221              var httpContext = await RunTestAsync(options =>
222              {
223                  options.CheckConsentNeeded = context => true;
224                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
225                  options.OnAppendCookie = context =>
226                  {
227                      Assert.Equal(".AspNet.Consent", context.CookieName);
228                      Assert.Equal("yes", context.CookieValue);
229                      Assert.Equal(Http.SameSiteMode.Strict, context.CookieOptions.SameSite);
230                      context.CookieName += "1";
231                      context.CookieValue += "1";
232                  };
233              },
234              requestContext => { },
235              context =>
236              {
237                  var feature = context.Features.Get<ITrackingConsentFeature>();
238                  Assert.True(feature.IsConsentNeeded);
239                  Assert.False(feature.HasConsent);
240                  Assert.False(feature.CanTrack);
241                  feature.GrantConsent();
242                  Assert.True(feature.IsConsentNeeded);
243                  Assert.True(feature.HasConsent);
244                  Assert.True(feature.CanTrack);
245                  return Task.CompletedTask;
246              });
247              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
248              Assert.Equal(1, cookies.Count);
249              var consentCookie = cookies[0];
250              Assert.Equal(".AspNet.Consent1", consentCookie.Name);
251              Assert.Equal("yes1", consentCookie.Value);
252              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
253              Assert.NotNull(consentCookie.Expires);
254          }
255          [Fact]
256          public async Task GrantConsentWhenAlreadyHasItDoesNotSetCookie()
257          {
258              var httpContext = await RunTestAsync(options =>
259              {
260                  options.CheckConsentNeeded = context => true;
261              },
262              requestContext =>
263              {
264                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
265              },
266              context =>
267              {
268                  var feature = context.Features.Get<ITrackingConsentFeature>();
269                  Assert.True(feature.IsConsentNeeded);
270                  Assert.True(feature.HasConsent);
271                  Assert.True(feature.CanTrack);
272                  feature.GrantConsent();
273                  Assert.True(feature.IsConsentNeeded);
274                  Assert.True(feature.HasConsent);
275                  Assert.True(feature.CanTrack);
276                  context.Response.Cookies.Append("Test", "Value");
277                  return Task.CompletedTask;
278              });
279              Assert.Equal("Test=Value; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
280          }
281          [Fact]
282          public async Task GrantConsentAfterResponseStartsSetsHasConsentButDoesNotSetCookie()
283          {
284              var httpContext = await RunTestAsync(options =>
285              {
286                  options.CheckConsentNeeded = context => true;
287              },
288              requestContext => { },
289              async context =>
290              {
291                  var feature = context.Features.Get<ITrackingConsentFeature>();
292                  Assert.True(feature.IsConsentNeeded);
293                  Assert.False(feature.HasConsent);
294                  Assert.False(feature.CanTrack);
295                  await context.Response.WriteAsync("Started.");
296                  feature.GrantConsent();
297                  Assert.True(feature.IsConsentNeeded);
298                  Assert.True(feature.HasConsent);
299                  Assert.True(feature.CanTrack);
300                  Assert.Throws<InvalidOperationException>(() => context.Response.Cookies.Append("Test", "Value"));
301                  await context.Response.WriteAsync("Granted.");
302              });
<span onclick='openModal()' class='match'>303              var reader = new StreamReader(httpContext.Response.Body);
304              Assert.Equal("Started.Granted.", await reader.ReadToEndAsync());
</span>305              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
306          }
307          [Fact]
308          public async Task WithdrawConsentWhenNotHasConsentNoOps()
309          {
310              var httpContext = await RunTestAsync(options =>
311              {
312                  options.CheckConsentNeeded = context => true;
313              },
314              requestContext => { },
315              context =>
316              {
317                  var feature = context.Features.Get<ITrackingConsentFeature>();
318                  Assert.True(feature.IsConsentNeeded);
319                  Assert.False(feature.HasConsent);
320                  Assert.False(feature.CanTrack);
321                  feature.WithdrawConsent();
322                  Assert.True(feature.IsConsentNeeded);
323                  Assert.False(feature.HasConsent);
324                  Assert.False(feature.CanTrack);
325                  context.Response.Cookies.Append("Test", "Value");
326                  return Task.CompletedTask;
327              });
328              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
329          }
330          [Fact]
331          public async Task WithdrawConsentDeletesCookie()
332          {
333              var httpContext = await RunTestAsync(options =>
334              {
335                  options.CheckConsentNeeded = context => true;
336              },
337              requestContext =>
338              {
339                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
340              },
341              context =>
342              {
343                  var feature = context.Features.Get<ITrackingConsentFeature>();
344                  Assert.True(feature.IsConsentNeeded);
345                  Assert.True(feature.HasConsent);
346                  Assert.True(feature.CanTrack);
347                  context.Response.Cookies.Append("Test", "Value1");
348                  feature.WithdrawConsent();
349                  Assert.True(feature.IsConsentNeeded);
350                  Assert.False(feature.HasConsent);
351                  Assert.False(feature.CanTrack);
352                  context.Response.Cookies.Append("Test", "Value2");
353                  return Task.CompletedTask;
354              });
355              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
356              Assert.Equal(2, cookies.Count);
357              var testCookie = cookies[0];
358              Assert.Equal("Test", testCookie.Name);
359              Assert.Equal("Value1", testCookie.Value);
360              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
361              Assert.Null(testCookie.Expires);
362              var consentCookie = cookies[1];
363              Assert.Equal(".AspNet.Consent", consentCookie.Name);
364              Assert.Equal("", consentCookie.Value);
365              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
366              Assert.NotNull(consentCookie.Expires);
367          }
368          [Fact]
369          public async Task WithdrawConsentAppliesPolicyToDeleteCookie()
370          {
371              var httpContext = await RunTestAsync(options =>
372              {
373                  options.CheckConsentNeeded = context => true;
374                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
375                  options.OnDeleteCookie = context =>
376                  {
377                      Assert.Equal(".AspNet.Consent", context.CookieName);
378                      context.CookieName += "1";
379                  };
380              },
381              requestContext =>
382              {
383                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
384              },
385              context =>
386              {
387                  var feature = context.Features.Get<ITrackingConsentFeature>();
388                  Assert.True(feature.IsConsentNeeded);
389                  Assert.True(feature.HasConsent);
390                  Assert.True(feature.CanTrack);
391                  feature.WithdrawConsent();
392                  Assert.True(feature.IsConsentNeeded);
393                  Assert.False(feature.HasConsent);
394                  Assert.False(feature.CanTrack);
395                  return Task.CompletedTask;
396              });
397              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
398              Assert.Equal(1, cookies.Count);
399              var consentCookie = cookies[0];
400              Assert.Equal(".AspNet.Consent1", consentCookie.Name);
401              Assert.Equal("", consentCookie.Value);
402              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
403              Assert.NotNull(consentCookie.Expires);
404          }
405          [Fact]
406          public async Task WithdrawConsentAfterResponseHasStartedDoesNotDeleteCookie()
407          {
408              var httpContext = await RunTestAsync(options =>
409              {
410                  options.CheckConsentNeeded = context => true;
411              },
412              requestContext =>
413              {
414                  requestContext.Request.Headers[HeaderNames.Cookie] = ".AspNet.Consent=yes";
415              },
416              async context =>
417              {
418                  var feature = context.Features.Get<ITrackingConsentFeature>();
419                  Assert.True(feature.IsConsentNeeded);
420                  Assert.True(feature.HasConsent);
421                  Assert.True(feature.CanTrack);
422                  context.Response.Cookies.Append("Test", "Value1");
423                  await context.Response.WriteAsync("Started.");
424                  feature.WithdrawConsent();
425                  Assert.True(feature.IsConsentNeeded);
426                  Assert.False(feature.HasConsent);
427                  Assert.False(feature.CanTrack);
428                  context.Response.Cookies.Append("Test", "Value2");
429                  await context.Response.WriteAsync("Withdrawn.");
430              });
431              var reader = new StreamReader(httpContext.Response.Body);
432              Assert.Equal("Started.Withdrawn.", await reader.ReadToEndAsync());
433              Assert.Equal("Test=Value1; path=/; samesite=lax", httpContext.Response.Headers[HeaderNames.SetCookie]);
434          }
435          [Fact]
436          public async Task DeleteCookieDoesNotRequireConsent()
437          {
438              var httpContext = await RunTestAsync(options =>
439              {
440                  options.CheckConsentNeeded = context => true;
441              },
442              requestContext => { },
443              context =>
444              {
445                  var feature = context.Features.Get<ITrackingConsentFeature>();
446                  Assert.True(feature.IsConsentNeeded);
447                  Assert.False(feature.HasConsent);
448                  Assert.False(feature.CanTrack);
449                  context.Response.Cookies.Delete("Test");
450                  return Task.CompletedTask;
451              });
452              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
453              Assert.Equal(1, cookies.Count);
454              var testCookie = cookies[0];
455              Assert.Equal("Test", testCookie.Name);
456              Assert.Equal("", testCookie.Value);
457              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
458              Assert.NotNull(testCookie.Expires);
459          }
460          [Fact]
461          public async Task OnDeleteCookieCanSuppressCookie()
462          {
463              var httpContext = await RunTestAsync(options =>
464              {
465                  options.CheckConsentNeeded = context => true;
466                  options.OnDeleteCookie = context =>
467                  {
468                      Assert.True(context.IsConsentNeeded);
469                      Assert.False(context.HasConsent);
470                      Assert.True(context.IssueCookie);
471                      context.IssueCookie = false;
472                  };
473              },
474              requestContext => { },
475              context =>
476              {
477                  var feature = context.Features.Get<ITrackingConsentFeature>();
478                  Assert.True(feature.IsConsentNeeded);
479                  Assert.False(feature.HasConsent);
480                  Assert.False(feature.CanTrack);
481                  context.Response.Cookies.Delete("Test");
482                  return Task.CompletedTask;
483              });
484              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
485          }
486          [Fact]
487          public async Task CreateConsentCookieMatchesGrantConsentCookie()
488          {
489              var httpContext = await RunTestAsync(options =>
490              {
491                  options.CheckConsentNeeded = context => true;
492              },
493              requestContext => { },
494              context =>
495              {
496                  var feature = context.Features.Get<ITrackingConsentFeature>();
497                  Assert.True(feature.IsConsentNeeded);
498                  Assert.False(feature.HasConsent);
499                  Assert.False(feature.CanTrack);
500                  feature.GrantConsent();
501                  Assert.True(feature.IsConsentNeeded);
502                  Assert.True(feature.HasConsent);
503                  Assert.True(feature.CanTrack);
504                  var cookie = feature.CreateConsentCookie();
505                  context.Response.Headers["ManualCookie"] = cookie;
506                  return Task.CompletedTask;
507              });
508              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
509              Assert.Equal(1, cookies.Count);
510              var consentCookie = cookies[0];
511              Assert.Equal(".AspNet.Consent", consentCookie.Name);
512              Assert.Equal("yes", consentCookie.Value);
513              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
514              Assert.NotNull(consentCookie.Expires);
515              cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers["ManualCookie"]);
516              Assert.Equal(1, cookies.Count);
517              var manualCookie = cookies[0];
518              Assert.Equal(consentCookie.Name, manualCookie.Name);
519              Assert.Equal(consentCookie.Value, manualCookie.Value);
520              Assert.Equal(consentCookie.SameSite, manualCookie.SameSite);
521              Assert.NotNull(manualCookie.Expires); 
522          }
523          [Fact]
524          public async Task CreateConsentCookieAppliesPolicy()
525          {
526              var httpContext = await RunTestAsync(options =>
527              {
528                  options.CheckConsentNeeded = context => true;
529                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
530                  options.OnAppendCookie = context =>
531                  {
532                      Assert.Equal(".AspNet.Consent", context.CookieName);
533                      Assert.Equal("yes", context.CookieValue);
534                      Assert.Equal(Http.SameSiteMode.Strict, context.CookieOptions.SameSite);
535                      context.CookieName += "1";
536                      context.CookieValue += "1";
537                  };
538              },
539              requestContext => { },
540              context =>
541              {
542                  var feature = context.Features.Get<ITrackingConsentFeature>();
543                  Assert.True(feature.IsConsentNeeded);
544                  Assert.False(feature.HasConsent);
545                  Assert.False(feature.CanTrack);
546                  feature.GrantConsent();
547                  Assert.True(feature.IsConsentNeeded);
548                  Assert.True(feature.HasConsent);
549                  Assert.True(feature.CanTrack);
550                  var cookie = feature.CreateConsentCookie();
551                  context.Response.Headers["ManualCookie"] = cookie;
552                  return Task.CompletedTask;
553              });
554              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
555              Assert.Equal(1, cookies.Count);
556              var consentCookie = cookies[0];
557              Assert.Equal(".AspNet.Consent1", consentCookie.Name);
558              Assert.Equal("yes1", consentCookie.Value);
559              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
560              Assert.NotNull(consentCookie.Expires);
561              cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers["ManualCookie"]);
562              Assert.Equal(1, cookies.Count);
563              var manualCookie = cookies[0];
564              Assert.Equal(consentCookie.Name, manualCookie.Name);
565              Assert.Equal(consentCookie.Value, manualCookie.Value);
566              Assert.Equal(consentCookie.SameSite, manualCookie.SameSite);
567              Assert.NotNull(manualCookie.Expires); 
568          }
569          private Task<HttpContext> RunTestAsync(Action<CookiePolicyOptions> configureOptions, Action<HttpContext> configureRequest, RequestDelegate handleRequest)
570          {
571              var builder = new WebHostBuilder()
572                  .ConfigureServices(services =>
573                  {
574                      services.Configure(configureOptions);
575                  })
576                  .Configure(app =>
577                  {
578                      app.UseCookiePolicy();
579                      app.Run(handleRequest);
580                  });
581              var server = new TestServer(builder);
582              return server.SendAsync(configureRequest);
583          }
584      }
585  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobRunner.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-CookieConsentTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>260                      var currentVersion = new PackageVersion(BuildConstants.RunnerPackage.Version);
261                      ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
</pre></code></div>
                <div class="column column_space"><pre><code>303              var reader = new StreamReader(httpContext.Response.Body);
304              Assert.Equal("Started.Granted.", await reader.ReadToEndAsync());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    