<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ScalarTestCase.java &amp; SnapshotRestoreIntegrationTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ScalarTestCase.java &amp; SnapshotRestoreIntegrationTest.java
      </h3>
<h1 align="center">
        14.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ScalarTestCase.java (28.205128%)<th>SnapshotRestoreIntegrationTest.java (9.40171%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-69)<td><a href="#" name="0">(34-80)</a><td align="center"><font color="#ff0000">42</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(119-133)<td><a href="#" name="1">(137-145)</a><td align="center"><font color="#610000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(250-258)<td><a href="#" name="2">(807-812)</a><td align="center"><font color="#480000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(154-156)<td><a href="#" name="3">(236-237)</a><td align="center"><font color="#3c0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(140-145)<td><a href="#" name="4">(368-374)</a><td align="center"><font color="#3c0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(220-237)<td><a href="#" name="5">(229-232)</a><td align="center"><font color="#360000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScalarTestCase.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.expression.scalar;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.analyze.relations.AnalyzedRelation;
4 import io.crate.analyze.relations.DocTableRelation;
5 import io.crate.common.collections.Lists2;
6 import io.crate.data.Input;
7 import io.crate.data.Row;
8 import io.crate.execution.engine.collect.CollectExpression;
9 import io.crate.expression.InputFactory;
10 import io.crate.expression.symbol.Function;
11 import io.crate.expression.symbol.InputColumn;
12 import io.crate.expression.symbol.Literal;
13 import io.crate.expression.symbol.ParameterBinder;
14 import io.crate.expression.symbol.RefReplacer;
15 import io.crate.expression.symbol.Symbol;
16 import io.crate.metadata.CoordinatorTxnCtx;
17 import io.crate.metadata.FunctionImplementation;
18 import io.crate.metadata.RelationName;
19 import io.crate.metadata.Scalar;
20 import io.crate.metadata.SearchPath;
21 import io.crate.metadata.TransactionContext;
22 import io.crate.metadata.doc.DocSchemaInfo;
23 import io.crate.metadata.doc.DocTableInfo;
24 import io.crate.metadata.settings.SessionSettings;
25 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
26 import io.crate.testing.SQLExecutor;
27 import io.crate.testing.SqlExpressions;
28 import io.crate.types.DataType;
29 import org.hamcrest.Matcher;
30 import org.hamcrest.Matchers;
31 import org.junit.Before;
32 import java.util.Arrays;
33 import java.util.LinkedList;
34 import java.util.List;
35 import java.util.Locale;
36 import java.util.Map;
37 import static org.hamcrest.Matchers.instanceOf;
38 import static org.hamcrest.Matchers.not;
39 import static org.hamcrest.Matchers.nullValue;
40 import static org.hamcrest.core.Is.is;
41 public abstract class ScalarTestCase extends CrateDummyClusterServiceUnitTest {
42     protected SqlExpressions sqlExpressions;
43     protected Map&lt;RelationName, AnalyzedRelation&gt; tableSources;
44     protected TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext()</b></font>;
45     private InputFactory inputFactory;
46     protected static SessionSettings DUMMY_SESSION_INFO = new SessionSettings(
47         "dummyUser",
48         SearchPath.createSearchPathFrom("dummySchema"));
49     @Before
50     public void prepareFunctions() {
51         String createTableStmt =
52             "create table doc.users (" +
53             "  id int," +
54             "  name text," +
55             "  tags array(text)," +
56             "  age int," +
57             "  a int," +
58             "  ip ip," +
59             "  c char," +
60             "  x bigint," +
61             "  shape geo_shape," +
62             "  timestamp_tz timestamp with time zone," +
63             "  timestamp timestamp without time zone," +
64             "  timezone text," +
65             "  interval text," +
66             "  time_format text," +
67             "  long_array array(bigint)," +
68             "  int_array array(int)," +
69             "  short_array array(short)," +
70             "  double_array array(double precision)," +
71             "  regex_pattern text," +
72             "  geoshape geo_shape," +
73             "  geopoint geo_point," +
74             "  geostring text," +
75             "  is_awesome boolean," +
76             "  double_val double precision," +
77             "  float_val real," +
78             "  short_val smallint," +
79             "  obj object," +
80             "  obj_ignored object(ignored)" +
81             ")";
82         DocTableInfo tableInfo = SQLExecutor.tableInfo(
83             new RelationName(DocSchemaInfo.NAME, "users"),
84             createTableStmt,
85             clusterService);
86         DocTableRelation tableRelation = new DocTableRelation(tableInfo);
87 <a name="1"></a>        tableSources = Map.of(tableInfo.ident(), tableRelation);
88         sqlExpressions = new SqlExpressions(tableSources);
89         inputFactory = new InputFactory(sqlExpressions.nodeCtx);
90     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
91     public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol) {
92         assertNormalize(functionExpression, expectedSymbol, true);
93     }
94     public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol, boolean evaluate) {
95         sqlExpressions.context</b></font>().allowEagerNormalize(false);
96         Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
97         if (functionSymbol instanceof Literal) {
98             assertThat(functionSymbol, expectedSymbol);
99 <a name="4"></a>            return;
100         }
101         Function function = (Function) functionSymbol;
102         FunctionImplementation impl = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
103         assertThat("Function implementation not found using full qualified lookup", impl, Matchers.notNullValue());
104         Symbol normalized = sqlExpressions.normalize(function);
105         assertThat(
106             String.format</b></font>(Locale.ENGLISH, "expected &lt;%s&gt; to normalize to %s", functionExpression, expectedSymbol),
107             normalized,
108             expectedSymbol);
109         if (evaluate &amp;&amp; normalized instanceof Input &amp;&amp; allArgsAreInputs(function.arguments())) {
110             Input[] inputs = new Input[function.arguments().size()];
111 <a name="3"></a>            for (int i = 0; i &lt; inputs.length; i++) {
112                 inputs[i] = ((Input) function.arguments().get(i));
113             }
114             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Object expectedValue = ((Input) normalized).value();
115             assertThat(((Scalar) impl).evaluate(txnCtx, null, inputs), is(expectedValue));
116             assertThat(((Scalar) impl).compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, inputs), is</b></font>(expectedValue));
117         }
118     }
119     @SuppressWarnings("unchecked")
120     public &lt;T&gt; void assertEvaluate(String functionExpression, Matcher&lt;T&gt; expectedValue, Literal&lt;?&gt;... literals) {
121         if (expectedValue == null) {
122             expectedValue = (Matcher&lt;T&gt;) nullValue();
123         }
124         sqlExpressions.context().allowEagerNormalize(true);
125         Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
126         functionSymbol = sqlExpressions.normalize(functionSymbol);
127         if (functionSymbol instanceof Literal) {
128             Object value = ((Literal) functionSymbol).value();
129             assertThat((T) value, expectedValue);
130             return;
131         }
132         LinkedList&lt;Literal&lt;?&gt;&gt; unusedLiterals = new LinkedList&lt;&gt;(Arrays.asList(literals));
133         Function function = (Function) RefReplacer.replaceRefs(functionSymbol, r -&gt; {
134             if (unusedLiterals.isEmpty()) {
135                 throw new IllegalArgumentException("No value literal for reference=" + r + ", please add more literals");
136             }
137             Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
138             return literal;
139         });
140         if(unusedLiterals.size() == literals.length) {
141             function = (Function) ParameterBinder.bindParameters(function, p -&gt; {
142                 if (unusedLiterals.isEmpty()) {
143                     throw new IllegalArgumentException("No value literal for parameter=" + p + ", please add more literals");
144                 }
145                 Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
146                 return literal;
147             });
148         }
149         Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
150         assertThat("Function implementation not found using full qualified lookup", scalar, Matchers.notNullValue());
151         AssertMax1ValueCallInput[] arguments = new AssertMax1ValueCallInput[function.arguments().size()];
152         InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = inputFactory.ctxForInputColumns(txnCtx);
153         for (int i = 0; i &lt; function.arguments().size(); i++) {
154             Symbol arg = function.arguments().get(i);
155             Input&lt;?&gt; input = ctx.add(arg);
156             arguments[i] = new AssertMax1ValueCallInput(input);
157         }
158         Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, (Input[]) arguments);
159         assertThat((T) actualValue, expectedValue);
160         for (AssertMax1ValueCallInput argument : arguments) {
161 <a name="5"></a>            argument.calls = 0;
162         }
163         actualValue = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>scalar.evaluate(txnCtx, sqlExpressions.nodeCtx, arguments);
164         assertThat((T) actualValue, expectedValue);
165     }
166     public void assertEvaluate(String functionExpression, Object expectedValue, Literal&lt;?&gt;... literals) {</b></font>
167         if (expectedValue == null) {
168             assertEvaluate(functionExpression, nullValue(), literals);
169         } else {
170             assertEvaluate(functionExpression, is(expectedValue), literals);
171         }
172     }
173     public void assertCompile(String functionExpression, java.util.function.Function&lt;Scalar, Matcher&lt;Scalar&gt;&gt; matcher) {
174         Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
175 <a name="2"></a>        functionSymbol = sqlExpressions.normalize(functionSymbol);
176         assertThat("function expression was normalized, compile would not be hit", functionSymbol, not(instanceOf(Literal.class)));
177         Function function = (Function) functionSymbol;
178         Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>txnCtx.sessionSettings().searchPath());
179         assertThat("Function implementation not found using full qualified lookup", scalar, Matchers.notNullValue());
180         Scalar compiled = scalar.compile(function.arguments());
181         assertThat(compiled, matcher.apply(scalar));
182     }
183     private static b</b></font>oolean allArgsAreInputs(List&lt;Symbol&gt; arguments) {
184         for (Symbol argument : arguments) {
185             if (!(argument instanceof Input)) {
186                 return false;
187             }
188         }
189         return true;
190     }
191     protected FunctionImplementation getFunction(String functionName, DataType... argTypes) {
192         return getFunction(functionName, Arrays.asList(argTypes));
193     }
194     protected FunctionImplementation getFunction(String functionName, List&lt;DataType&gt; argTypes) {
195         return sqlExpressions.nodeCtx.functions().get(
196             null, functionName, Lists2.map(argTypes, t -&gt; new InputColumn(0, t)), SearchPath.pathWithPGCatalogAndDoc());
197     }
198     private static class AssertMax1ValueCallInput implements Input {
199         private final Input delegate;
200         int calls = 0;
201         AssertMax1ValueCallInput(Input delegate) {
202             this.delegate = delegate;
203         }
204         @Override
205         public Object value() {
206             calls++;
207             if (calls == 1) {
208                 return delegate.value();
209             }
210             throw new AssertionError("Input.value() should only be called once");
211         }
212         @Override
213         public String toString() {
214             return delegate.toString();
215         }
216     }
217 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SnapshotRestoreIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.integrationtests;
2 import io.crate.common.unit.TimeValue;
3 import io.crate.expression.udf.UserDefinedFunctionService;
4 import io.crate.testing.SQLResponse;
5 import org.apache.lucene.util.SetOnce;
6 import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;
7 import org.elasticsearch.cluster.SnapshotsInProgress;
8 import org.elasticsearch.cluster.metadata.IndexMetadata;
9 <a name="0"></a>import org.elasticsearch.common.collect.ImmutableOpenMap;
10 import org.elasticsearch.common.settings.Settings;
11 import org.elasticsearch.plugins.Plugin;
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.repositories.ESBlobStoreTestCase;
13 import org.elasticsearch.repositories.RepositoriesService;
14 import org.elasticsearch.repositories.Repository;
15 import org.elasticsearch.repositories.RepositoryData;
16 import org.elasticsearch.snapshots.Snapshot;
17 import org.elasticsearch.snapshots.SnapshotId;
18 import org.elasticsearch.snapshots.SnapshotInfo;
19 import org.elasticsearch.snapshots.SnapshotState;
20 import org.elasticsearch.test.MockKeywordPlugin;
21 import org.elasticsearch.threadpool.ThreadPool;
22 import org.junit.After;
23 import org.junit.Before;
24 import org.junit.ClassRule;
25 import org.junit.Test;
26 import org.junit.rules.TemporaryFolder;
27 import java.io.File;
28 import java.io.IOException;
29 import java.nio.file.Files;
30 import java.nio.file.StandardOpenOption;
31 import java.util.ArrayList;
32 import java.util.Collection;
33 import java.util.List;
34 import java.util.Locale;
35 import java.util.Map;
36 import java.util.concurrent.CompletableFuture;
37 import java.util.concurrent.CountDownLatch;
38 import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
39 import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
40 import static io.crate.testing.Asserts.assertThrowsMatches;
41 import static io.crate.testing.SQLErrorMatcher.isSQLError;
42 import static io.crate.testing.TestingHelpers.printedTable;
43 import static io.netty.handler.codec.http.HttpResponseStatus.CONFLICT;
44 import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;
45 import static io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;
46 import static org.hamcrest.Matchers.containsString;
47 import static org.hamcrest.Matchers.equalTo;
48 import static org.hamcrest.Matchers.is;
49 import static org.hamcrest.Matchers.lessThanOrEqualTo;
50 public class SnapshotRestoreIntegrationTest extends SQLIntegrationTestCase {
51     private static final String REPOSITORY_NAME = "my_repo";
52     private static final String SNAPSHOT_NAME = "my_snapshot";
53     @ClassRule</b></font>
54     public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();
55     private File defaultRepositoryLocation;
56     @Override
57     protected Settings nodeSettings(int nodeOrdinal) {
58         return Settings.builder().put(super.nodeSettings(nodeOrdinal))
59             .put("path.repo", TEMPORARY_FOLDER.getRoot().getAbsolutePath())
60             .build();
61     }
62     @Override
63     protected Collection&lt;Class&lt;? extends Plugin&gt;&gt; nodePlugins() {
64         var plugins = new ArrayList&lt;&gt;(super.nodePlugins());
65         plugins.add(MockKeywordPlugin.class);
66         return plugins;
67     }
68     @Override
69     @Before
70     public void setUp() throws Exception {
71         super.setUp();
72         defaultRepositoryLocation = TEMPORARY_FOLDER.newFolder();
73         execute("CREATE REPOSITORY " + REPOSITORY_NAME + " TYPE \"fs\" with (location=?, compress=True)",
74             new Object[]{defaultRepositoryLocation.getAbsolutePath()});
75         assertThat(response.rowCount(), is(1L));
76         execute(
77             "CREATE REPOSITORY my_repo_ro TYPE \"fs\" with (location=?, compress=true, readonly=true)",
78             new Object[]{defaultRepositoryLocation.getAbsolutePath()}
79         );
80         var dummyLang = new UserDefinedFunctionsIntegrationTest.DummyLang();
81         Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
82         for (UserDefinedFunctionService udfService : udfServices) {
83             udfService.registerLanguage(dummyLang);
84         }
85     }
86     @After
87     public void cleanUp() {
88         var stmts = List.of(
89             "REVOKE ALL FROM my_user",
90             "DROP ANALYZER a1",
91             "DROP FUNCTION custom(string)"
92         );
93         for (var stmt : stmts) {
94             try {
95                 execute(stmt);
96             } catch (Exception e) {
97             }
98         }
99 <a name="1"></a>        execute("DROP USER IF EXISTS my_user");
100         execute("DROP VIEW IF EXISTS my_view");
101         execute("DROP TABLE IF EXISTS my_table");
102     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
103     private void createTableAndSnapshot(String tableName, String snapshotName) {
104         createTableAndSnapshot(tableName, snapshotName, false);
105     }
106     private void createTableAndSnapshot(String tableName, String snapshotName, boolean partitioned) {
107         createTable(tableName, partitioned);
108         createSnapshot</b></font>(snapshotName, tableName);
109     }
110     private void createTable(String tableName, boolean partitioned) {
111         execute("CREATE TABLE " + tableName + " (" +
112                 "  id long primary key, " +
113                 "  name string, " +
114                 "  date timestamp with time zone " + (partitioned ? "primary key," : ",") +
115                 "  ft string index using fulltext with (analyzer='default')" +
116                 ") " + (partitioned ? "partitioned by (date) " : "") +
117                 "clustered into 1 shards with (number_of_replicas=0)");
118         execute("INSERT INTO " + tableName + " (id, name, date, ft) VALUES (?, ?, ?, ?)", new Object[][]{
119             {1L, "foo", "1970-01-01", "The quick brown fox jumps over the lazy dog."},
120             {2L, "bar", "2015-10-27T11:29:00+01:00", "Morgenstund hat Gold im Mund."},
121             {3L, "baz", "1989-11-09", "Reden ist Schweigen. Silber ist Gold."},
122         });
123         execute("REFRESH TABLE " + tableName);
124     }
125     private void createSnapshot(String snapshotName, String... tables) {
126         execute("CREATE SNAPSHOT " + REPOSITORY_NAME + "." + snapshotName + " TABLE " + String.join(", ", tables) +
127                 " WITH (wait_for_completion=true)");
128         assertThat(response.rowCount(), is(1L));
129     }
130     private static String snapshotName() {
131         return String.format(Locale.ENGLISH, "%s.%s", REPOSITORY_NAME, SNAPSHOT_NAME);
132     }
133     @Test
134     public void testDropSnapshot() throws Exception {
135         String snapshotName = "my_snap_1";
136         createTableAndSnapshot("my_table", snapshotName);
137         execute("drop snapshot " + REPOSITORY_NAME + "." + snapshotName);
138         assertThat(response.rowCount(), is(1L));
139         execute("select * from sys.snapshots where name = ?", new Object[]{snapshotName});
140         assertThat(response.rowCount(), is(0L));
141         assertAllRepoSnapshotFilesAreDeleted(defaultRepositoryLocation);
142     }
143     @Test
144     public void testDropUnknownSnapshot() throws Exception {
145         String snapshot = "unknown_snap";
146         assertThrowsMatches(() -&gt; execute("drop snapshot " + REPOSITORY_NAME + "." + snapshot),
147                      isSQLError(is(String.format(Locale.ENGLISH, "Snapshot '%s.%s' unknown", REPOSITORY_NAME, snapshot)),
148                                 INTERNAL_ERROR,
149                                 NOT_FOUND,
150                                 4048));
151     }
152     @Test
153     public void testDropSnapshotUnknownRepository() throws Exception {
154         String repository = "unknown_repo";
155         String snapshot = "unknown_snap";
156         assertThrowsMatches(() -&gt; execute("drop snapshot " + repository + "." + snapshot),
157                      isSQLError(is(String.format(Locale.ENGLISH, "Repository '%s' unknown", repository)),
158                                 INTERNAL_ERROR,
159                                 NOT_FOUND,
160                                 4047));
161     }
162     @Test
163     public void testCreateSnapshot() throws Exception {
164         createTable("backmeup", false);
165         execute("CREATE SNAPSHOT " + snapshotName() + " TABLE backmeup WITH (wait_for_completion=true)");
166         assertThat(response.rowCount(), is(1L));
167         execute("select name, \"repository\", concrete_indices, state from sys.snapshots order by 2");
168         assertThat(printedTable(response.rows()),
169                    is(String.format(
170                 "my_snapshot| my_repo| [%s.backmeup]| SUCCESS\n" +
171                 "my_snapshot| my_repo_ro| [%s.backmeup]| SUCCESS\n",
172                 sqlExecutor.getCurrentSchema(),
173                 sqlExecutor.getCurrentSchema())));
174     }
175     @Test
176     public void testCreateSnapshotWithoutWaitForCompletion() throws Exception {
177 <a name="5"></a>                execute("CREATE SNAPSHOT my_repo.snapshot_no_wait ALL WITH (wait_for_completion=false)");
178         assertThat(response.rowCount(), is(1L));
179         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waitForCompletion(REPOSITORY_NAME, "snapshot_no_wait", TimeValue.timeValueSeconds(20));
180     }
181     private SnapshotInfo waitForCompletion(String repository, String snapshotName, TimeValue timeout) throws InterruptedException {</b></font>
182 <a name="3"></a>        long start = System.currentTimeMillis();
183         Snapshot snapshot = new Snapshot(repository, new SnapshotId(repository, snapshotName));
184         while (System.currentTimeMillis() - start &lt; timeout.millis()) {
185             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;SnapshotInfo&gt; snapshotInfos = client().admin().cluster().prepareGetSnapshots(repository).setSnapshots(snapshotName).get().getSnapshots();
186             assertThat(snapshotInfos.size</b></font>(), equalTo(1));
187             if (snapshotInfos.get(0).state().completed()) {
188                 ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();
189                 SnapshotsInProgress snapshotsInProgress = stateResponse.getState().custom(SnapshotsInProgress.TYPE);
190                 if (snapshotsInProgress == null || snapshotsInProgress.snapshot(snapshot) == null) {
191                     return snapshotInfos.get(0);
192                 }
193             }
194             Thread.sleep(100);
195         }
196         fail("Timeout waiting for snapshot completion!");
197         return null;
198     }
199     @Test
200     public void testCreateSnapshotFromPartition() throws Exception {
201         createTable("custom.backmeup", true);
202         execute("CREATE SNAPSHOT " + snapshotName() +
203                 " TABLE custom.backmeup PARTITION (date='1970-01-01')  WITH (wait_for_completion=true)");
204         assertThat(response.rowCount(), is(1L));
205         execute("select name, \"repository\", concrete_indices, tables, state from sys.snapshots order by 2");
206         assertThat(printedTable(response.rows()),
207                    is("my_snapshot| my_repo| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n" +
208                "my_snapshot| my_repo_ro| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n"));
209     }
210     @Test
211     public void testCreateSnapshotAllBlobsExcluded() throws Exception {
212         execute("CREATE TABLE t1 (id INTEGER, name STRING)");
213         execute("CREATE BLOB TABLE b1");
214         ensureYellow();
215         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
216         assertThat(response.rowCount(), is(1L));
217         execute("select concrete_indices from sys.snapshots");
218         assertThat(response.rows()[0][0], is(List.of(getFqn("t1"))));
219     }
220     @Test
221     public void testCreateExistingSnapshot() throws Exception {
222         createTable("backmeup", randomBoolean());
223         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
224         assertThat(response.rowCount(), is(1L));
225         assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)"),
226                      isSQLError(containsString("Invalid snapshot name [my_snapshot], snapshot with the same name already exists"),
227                                 INTERNAL_ERROR,
228                                 CONFLICT,
229                                 4099));
230     }
231     @Test
232     public void testCreateSnapshotUnknownRepo() throws Exception {
233         assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT unknown_repo.my_snapshot ALL WITH (wait_for_completion=true)"),
234                      isSQLError(is("Repository 'unknown_repo' unknown"),
235                                 INTERNAL_ERROR,
236                                 NOT_FOUND,
237                                 4047));
238     }
239     @Test
240     public void testInvalidSnapshotName() throws Exception {
241         assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT my_repo.\"MY_UPPER_SNAPSHOT\" ALL WITH (wait_for_completion=true)"),
242                      isSQLError(containsString("Invalid snapshot name [MY_UPPER_SNAPSHOT], must be lowercase"),
243                                 INTERNAL_ERROR,
244                                 CONFLICT,
245                                 4099));
246     }
247     @Test
248     public void testSnapshotWithMetadataDoesNotDeleteExistingStuff() throws Exception {
249         createTable("my_other", true);
250         execute("CREATE SNAPSHOT " + snapshotName() + " TABLE my_other with (wait_for_completion=true)");
251         execute("alter table my_other add column x double");
252         waitForMappingUpdateOnAll("my_other", "x");
253         execute("delete from my_other");
254         execute("CREATE TABLE survivor (bla string, blubb float) partitioned by (blubb) with (number_of_replicas=0)");
255         ensureYellow();
256         execute("insert into survivor (bla, blubb) values (?, ?)", new Object[][]{
257             {"foo", 1.2},
258             {"bar", 1.4},
259             {"baz", 1.2}
260         });
261         execute("refresh table survivor");
262         execute("restore snapshot " + snapshotName() + " ALL with (wait_for_completion=true)");
263         execute("select * from survivor order by bla");
264         assertThat(printedTable(response.rows()), is(
265             "bar| 1.4\n" +
266             "baz| 1.2\n" +
267             "foo| 1.2\n"));
268     }
269     @Test
270     public void testSnapshotWithMetadataConcurrentlyModified() throws Exception {
271         int shards = randomFrom(1, 3, 5);
272         int replicas = randomIntBetween(2, 10);
273         long documents = randomLongBetween(2, 100);
274         execute("CREATE TABLE test (" +
275                 "  id long primary key)" +
276                 "clustered into " + shards + " shards with (column_policy = 'dynamic', number_of_replicas=" + replicas +
277                 ")");
278         ensureYellow();
279         CompletableFuture&lt;SQLResponse&gt; createSnapshot = null;
280         for (var i = 0; i &lt; documents; i++) {
281             execute("INSERT INTO test (id, field_" + i + ") VALUES (?, ?)", new Object[][]{{i, "value_" + i},});
282             execute("REFRESH TABLE test");
283             if (createSnapshot == null) {
284                 createSnapshot = sqlExecutor.execute(
285                     "CREATE SNAPSHOT " + snapshotName() + " TABLE test with (wait_for_completion=true)", null);
286             }
287         }
288         if (createSnapshot != null) {
289             createSnapshot.get();
290         }
291 <a name="4"></a>        execute("DROP table test");
292         execute("select state from sys.snapshots where name=?", new Object[]{SNAPSHOT_NAME});
293         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(response.rows()[0][0], is("SUCCESS"));
294         execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (wait_for_completion=true)");
295         waitNoPendingTasksOnAll();
296         SnapshotsInProgress finalSnapshotsInProgress = clusterService</b></font>().state().custom(SnapshotsInProgress.TYPE);
297         assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -&gt; entry.state().completed() == false));
298         ImmutableOpenMap&lt;String, IndexMetadata&gt; state = clusterService().state().metadata().indices();
299         IndexMetadata indexMetadata = state.values().iterator().next().value;
300         int sizeOfProperties = ((Map&lt;?, ?&gt;) indexMetadata.mapping().sourceAsMap().get("properties")).size();
301         execute("select count(*) from test");
302         assertThat(
303             "Documents were restored but the restored index mapping was older than some documents and misses some of their fields",
304             (Long)response.rows()[0][0], lessThanOrEqualTo((long) sizeOfProperties));
305     }
306     @Test
307     public void testRestoreSnapshotAll() throws Exception {
308         createTableAndSnapshot("my_table", SNAPSHOT_NAME);
309         execute("drop table my_table");
310         execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (" +
311                 "ignore_unavailable=false, " +
312                 "wait_for_completion=true)");
313         ensureGreen();
314         execute("select * from my_table order by id");
315         assertThat(response.rowCount(), is(3L));
316     }
317     @Test
318     public void testRestoreSnapshotSinglePartition() throws Exception {
319         createTableAndSnapshot("my_parted_table", SNAPSHOT_NAME, true);
320         waitNoPendingTasksOnAll();
321         execute("delete from my_parted_table");
322         waitNoPendingTasksOnAll();
323         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_table PARTITION (date='1970-01-01') with (" +
324                 "ignore_unavailable=false, " +
325                 "wait_for_completion=true)");
326         execute("select date from my_parted_table");
327         assertThat(printedTable(response.rows()), is("0\n"));
328     }
329     @Test
330     public void testRestoreSinglePartitionSnapshotIntoDroppedPartition() throws Exception {
331         createTable("parted_table", true);
332         execute("CREATE SNAPSHOT " + snapshotName() +
333                 " TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)");
334         execute("delete from parted_table where date=0");
335         waitNoPendingTasksOnAll();
336         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE parted_table PARTITION (date=0) with (" +
337                 "ignore_unavailable=false, " +
338                 "wait_for_completion=true)");
339         execute("select date from parted_table order by id");
340         assertThat(printedTable(response.rows()), is("0\n1445941740000\n626572800000\n"));
341     }
342     @Test
343     public void testRestoreSinglePartitionSnapshotIntoDroppedTable() throws Exception {
344         createTable("parted_table", true);
345         execute("CREATE SNAPSHOT " + snapshotName() +
346                 " TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)");
347         execute("drop table parted_table");
348         waitNoPendingTasksOnAll();
349         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE parted_table PARTITION (date=0) with (" +
350                 "ignore_unavailable=false, " +
351                 "wait_for_completion=true)");
352         execute("select date from parted_table order by id");
353         assertThat(printedTable(response.rows()), is("0\n"));
354     }
355     @Test
356     public void testRestoreFullPartedTableSnapshotSinglePartitionIntoDroppedTable() throws Exception {
357         createTableAndSnapshot("my_parted_table", SNAPSHOT_NAME, true);
358         execute("drop table my_parted_table");
359         waitNoPendingTasksOnAll();
360         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_table PARTITION (date=0) with (" +
361                 "ignore_unavailable=false, " +
362                 "wait_for_completion=true)");
363         execute("select date from my_parted_table");
364         assertThat(printedTable(response.rows()), is("0\n"));
365     }
366     @Test
367     public void testRestoreSnapshotIgnoreUnavailable() throws Exception {
368         createTableAndSnapshot("my_table", SNAPSHOT_NAME, true);
369         execute("drop table my_table");
370         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table, not_my_table with (" +
371                 "ignore_unavailable=true, " +
372                 "wait_for_completion=true)");
373         execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?",
374             new Object[]{sqlExecutor.getCurrentSchema()});
375         assertThat(printedTable(response.rows()), is(getFqn("my_table") + "\n"));
376     }
377     @Test
378     public void testRestoreOnlyOneTable() throws Exception {
379         createTable("my_table_1", false);
380         createTable("my_table_2", false);
381         createSnapshot(SNAPSHOT_NAME, "my_table_1", "my_table_2");
382         waitNoPendingTasksOnAll();
383         execute("drop table my_table_1");
384         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_1 with (" +
385                 "wait_for_completion=true)");
386         execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ? order by 1",
387             new Object[]{sqlExecutor.getCurrentSchema()});
388         assertThat(printedTable(response.rows()), is(getFqn("my_table_1") + "\n" + getFqn("my_table_2") + "\n"));
389     }
390     @Test
391     public void test_parallel_restore_operations() throws Exception {
392         createTable("my_table_1", false);
393         createTable("my_table_2", false);
394         createSnapshot(SNAPSHOT_NAME, "my_table_1", "my_table_2");
395         waitNoPendingTasksOnAll();
396         execute("drop table my_table_1");
397         execute("drop table my_table_2");
398         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_1 with (" +
399                 "wait_for_completion=false)");
400         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_2 with (" +
401                 "wait_for_completion=false)");
402         assertBusy(() -&gt; {
403             execute(
404                 "select table_name from information_schema.tables where table_schema = ? order by 1",
405                 new Object[] { sqlExecutor.getCurrentSchema() }
406             );
407             assertThat(printedTable(response.rows()), is(
408                 "my_table_1\n" +
409                 "my_table_2\n"
410             ));
411         });
412     }
413     @Test
414     public void testRestoreOnlyOnePartitionedTable() throws Exception {
415         createTable("my_parted_1", true);
416         createTable("my_parted_2", true);
417         createSnapshot(SNAPSHOT_NAME, "my_parted_1", "my_parted_2");
418         execute("drop table my_parted_1");
419         execute("drop table my_parted_2");
420         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_1 with (" +
421                 "wait_for_completion=true)");
422         execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
423         assertThat(printedTable(response.rows()), is(getFqn("my_parted_1") + "\n"));
424     }
425     @Test
426     public void testRestoreEmptyPartitionedTableUsingALL() throws Exception {
427         execute("create table employees(section integer, name string) partitioned by (section)");
428         ensureYellow();
429         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
430         execute("drop table employees");
431         ensureYellow();
432         execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (wait_for_completion=true)");
433         ensureYellow();
434         execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
435         assertThat(printedTable(response.rows()), is(getFqn("employees") + "\n"));
436     }
437     @Test
438     public void testRestoreEmptyPartitionedTable() throws Exception {
439         execute("create table employees(section integer, name string) partitioned by (section)");
440         ensureYellow();
441         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
442         execute("drop table employees");
443         ensureYellow();
444         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE employees with (wait_for_completion=true)");
445         ensureYellow();
446         execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
447         assertThat(printedTable(response.rows()), is(getFqn("employees") + "\n"));
448     }
449     @Test
450     public void testResolveUnknownTableFromSnapshot() throws Exception {
451         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
452         ensureYellow();
453         assertThrowsMatches(() -&gt; execute(
454             "RESTORE SNAPSHOT " + snapshotName() + " TABLE employees with (wait_for_completion=true)"),
455                      isSQLError(is(String.format("[%s..partitioned.employees.] template not found", sqlExecutor.getCurrentSchema())),
456                         INTERNAL_ERROR,
457                         INTERNAL_SERVER_ERROR,
458                         5000)
459         );
460     }
461     @Test
462     public void test_cannot_create_snapshot_in_read_only_repo() {
463         assertThrowsMatches(() -&gt; execute("create snapshot my_repo_ro.s1 ALL WITH (wait_for_completion=true)"),
464                      isSQLError(containsString("cannot create snapshot in a readonly repository"),
465                                 INTERNAL_ERROR,
466                                 INTERNAL_SERVER_ERROR,
467                                 5000));
468     }
469     public void test_snapshot_with_corrupted_shard_index_file() throws Exception {
470         execute("CREATE TABLE t1 (x int)");
471         var numberOfDocs = randomLongBetween(0, 10);
472         for (int i = 0; i &lt; numberOfDocs; i++) {
473             execute("INSERT INTO t1 (x) VALUES (?)", new Object[]{randomInt()});
474         }
475         execute("REFRESH TABLE t1");
476         var snapShotName1 = "s1";
477         var fullSnapShotName1 =  REPOSITORY_NAME + "." + snapShotName1;
478         execute("CREATE SNAPSHOT " + fullSnapShotName1 + " ALL WITH (wait_for_completion=true)");
479         var repositoryData = getRepositoryData();
480         var indexIds = repositoryData.getIndices();
481         assertThat(indexIds.size(), equalTo(1));
482         var corruptedIndex = indexIds.entrySet().iterator().next().getValue();
483         var shardIndexFile = defaultRepositoryLocation.toPath().resolve("indices")
484             .resolve(corruptedIndex.getId()).resolve("0")
485             .resolve("index-" + repositoryData.shardGenerations().getShardGen(corruptedIndex, 0));
486         try (var outChan = Files.newByteChannel(shardIndexFile, StandardOpenOption.WRITE)) {
487             outChan.truncate(randomInt(10));
488         }
489         assertSnapShotState(snapShotName1, SnapshotState.SUCCESS);
490         execute("drop table t1");
491         execute("RESTORE SNAPSHOT " +  fullSnapShotName1 + " TABLE t1 with (wait_for_completion=true)");
492         ensureYellow();
493         execute("SELECT COUNT(*) FROM t1");
494         assertThat(response.rows()[0][0], is(numberOfDocs));
495         var numberOfAdditionalDocs = randomLongBetween(0, 10);
496         for (int i = 0; i &lt; numberOfAdditionalDocs; i++) {
497             execute("INSERT INTO t1 (x) VALUES (?)", new Object[]{randomInt()});
498         }
499         execute("REFRESH TABLE t1");
500         var snapShotName2 = "s2";
501         var fullSnapShotName2 = REPOSITORY_NAME + ".s2";
502         execute("CREATE SNAPSHOT " + fullSnapShotName2 + " ALL WITH (wait_for_completion=true)");
503         assertSnapShotState(snapShotName2, SnapshotState.PARTIAL);
504     }
505     @Test
506     public void test_restore_all_restores_complete_state() throws Exception {
507         createSnapshotWithTablesAndMetadata();
508         execute("RESTORE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
509         waitNoPendingTasksOnAll();
510         execute("select table_name from information_schema.tables where table_name = 'my_table'");
511         assertThat(printedTable(response.rows()), is("my_table\n"));
512         execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
513         assertThat(printedTable(response.rows()), is("my_view\n"));
514         execute("select name from sys.users where name = 'my_user'");
515         assertThat(printedTable(response.rows()), is("my_user\n"));
516         execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
517         assertThat(printedTable(response.rows()), is("DQL\n"));
518         execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
519                 " routine_name IN ('a1', 'custom') ORDER BY 1");
520         assertThat(printedTable(response.rows()), is("a1| ANALYZER\n" +
521                                                      "custom| FUNCTION\n"));
522     }
523     @Test
524     public void test_restore_all_tables_only() throws Exception {
525         createTable("t2", true);
526         createSnapshotWithTablesAndMetadata();
527         execute("drop table t2");
528         execute("RESTORE SNAPSHOT " + snapshotName() + " TABLES WITH (wait_for_completion=true)");
529         waitNoPendingTasksOnAll();
530         execute("select table_name from information_schema.tables where table_schema = ? order by 1",
531                 $(sqlExecutor.getCurrentSchema()));
532         assertThat(printedTable(response.rows()), is("my_table\n" +
533                                                      "t2\n"));
534     }
535     @Test
536     public void test_restore_metadata_only_does_not_restore_tables() throws Exception {
537         createSnapshotWithTablesAndMetadata();
538         execute("RESTORE SNAPSHOT " + snapshotName() + " METADATA WITH (wait_for_completion=true)");
539         waitNoPendingTasksOnAll();
540         execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
541         assertThat(printedTable(response.rows()), is("my_view\n"));
542         execute("SELECT name FROM sys.users WHERE name = 'my_user'");
543         assertThat(printedTable(response.rows()), is("my_user\n"));
544         execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
545         assertThat(printedTable(response.rows()), is("DQL\n"));
546         execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
547                 " routine_name IN ('a1', 'custom') ORDER BY 1");
548         assertThat(printedTable(response.rows()), is("a1| ANALYZER\n" +
549                                                      "custom| FUNCTION\n"));
550         execute("SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'");
551         assertThat(response.rowCount(), is(0L));
552     }
553     @Test
554     public void test_restore_analyzers_only() throws Exception {
555         createSnapshotWithTablesAndMetadata();
556         execute("RESTORE SNAPSHOT " + snapshotName() + " ANALYZERS WITH (wait_for_completion=true)");
557         waitNoPendingTasksOnAll();
558         execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
559                 " routine_name IN ('a1', 'custom') ORDER BY 1");
560         assertThat(printedTable(response.rows()), is("a1| ANALYZER\n"));
561         execute("SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'");
562         assertThat(response.rowCount(), is(0L));
563         execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
564         assertThat(response.rowCount(), is(0L));
565         execute("SELECT name FROM sys.users WHERE name = 'my_user'");
566         assertThat(response.rowCount(), is(0L));
567         execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
568         assertThat(response.rowCount(), is(0L));
569     }
570     @Test
571     public void test_restore_custom_metadata_only() throws Exception {
572         createSnapshotWithTablesAndMetadata();
573         execute("RESTORE SNAPSHOT " + snapshotName() + " USERS WITH (wait_for_completion=true)");
574         waitNoPendingTasksOnAll();
575         execute("SELECT name FROM sys.users WHERE name = 'my_user'");
576         assertThat(printedTable(response.rows()), is("my_user\n"));
577     }
578     @Test
579     public void test_create_snapshot_tables_does_not_store_global_state() {
580         createTable("custom.t1", false);
581         execute("CREATE USER my_user");
582         execute("CREATE SNAPSHOT " + snapshotName() + " TABLE custom.t1 WITH (wait_for_completion=true)");
583         execute("DROP TABLE custom.t1");
584         execute("DROP USER my_user");
585         execute("RESTORE SNAPSHOT " + snapshotName() + " ALL");
586         execute("SELECT table_name FROM information_schema.tables WHERE table_name = 't1'");
587         assertThat(response.rowCount(), is(1L));
588         execute("SELECT name FROM sys.users WHERE name = 'my_user'");
589         assertThat(response.rowCount(), is(0L));
590     }
591     private void createSnapshotWithTablesAndMetadata() throws Exception {
592         createTable("my_table", false);
593         execute("CREATE USER my_user");
594         execute("GRANT DQL TO my_user");
595         execute("CREATE VIEW my_view AS SELECT * FROM my_table LIMIT 1");
596         execute("CREATE FUNCTION custom(string) RETURNS STRING LANGUAGE dummy_lang AS '42'");
597         execute("CREATE ANALYZER a1 (TOKENIZER keyword)");
598         execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
599         assertThat(response.rowCount(), is(1L));
600         waitNoPendingTasksOnAll();
601         execute("REVOKE ALL FROM my_user");
602         execute("DROP USER my_user");
603         execute("DROP VIEW my_view");
604         execute("DROP TABLE my_table");
605         execute("DROP ANALYZER a1");
606         execute("DROP FUNCTION custom(string)");
607     }
608     private void assertSnapShotState(String snapShotName, SnapshotState state) {
609         execute(
610             "SELECT state, array_length(concrete_indices, 1) FROM sys.snapshots where name = ? and repository = ?",
611             new Object[]{snapShotName, REPOSITORY_NAME});
612         assertThat(response.rows()[0][0], is(state.name()));
613         assertThat(response.rows()[0][1], is(1));
614     }
615 <a name="2"></a>
616     private static void assertAllRepoSnapshotFilesAreDeleted(File location) throws IOException {
617         //Make sure the file location does not consist of any .dat file
618         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Files.walk(location.toPath())
619             .filter(Files::isRegularFile)
620             .forEach(x -&gt; assertThat(x.getFileName().endsWith(".dat"), is(false)));
621     }
622     private Repositor</b></font>yData getRepositoryData() throws Exception {
623         RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName());
624         Repository repository = service.repository(REPOSITORY_NAME);
625         ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, internalCluster().getMasterName());
626         final SetOnce&lt;RepositoryData&gt; repositoryData = new SetOnce&lt;&gt;();
627         final CountDownLatch latch = new CountDownLatch(1);
628         threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -&gt; {
629             repositoryData.set(ESBlobStoreTestCase.getRepositoryData(repository));
630             latch.countDown();
631         });
632         latch.await();
633         return repositoryData.get();
634     }
635 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
