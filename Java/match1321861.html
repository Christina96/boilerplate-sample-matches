<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ScalarTestCase.java & SnapshotRestoreIntegrationTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ScalarTestCase.java & SnapshotRestoreIntegrationTest.java
      </h3>
      <h1 align="center">
        14.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ScalarTestCase.java (28.205128%)<TH>SnapshotRestoreIntegrationTest.java (9.40171%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#0',2,'match1321861-1.html#0',3)" NAME="0">(24-69)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#0',2,'match1321861-1.html#0',3)" NAME="0">(34-80)</A><TD ALIGN=center><FONT COLOR="#ff0000">42</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#1',2,'match1321861-1.html#1',3)" NAME="1">(119-133)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#1',2,'match1321861-1.html#1',3)" NAME="1">(137-145)</A><TD ALIGN=center><FONT COLOR="#610000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#2',2,'match1321861-1.html#2',3)" NAME="2">(250-258)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#2',2,'match1321861-1.html#2',3)" NAME="2">(807-812)</A><TD ALIGN=center><FONT COLOR="#480000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#3',2,'match1321861-1.html#3',3)" NAME="3">(154-156)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#3',2,'match1321861-1.html#3',3)" NAME="3">(236-237)</A><TD ALIGN=center><FONT COLOR="#3c0000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#4',2,'match1321861-1.html#4',3)" NAME="4">(140-145)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#4',2,'match1321861-1.html#4',3)" NAME="4">(368-374)</A><TD ALIGN=center><FONT COLOR="#3c0000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1321861-0.html#5',2,'match1321861-1.html#5',3)" NAME="5">(220-237)<TD><A HREF="javascript:ZweiFrames('match1321861-0.html#5',2,'match1321861-1.html#5',3)" NAME="5">(229-232)</A><TD ALIGN=center><FONT COLOR="#360000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScalarTestCase.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.expression.scalar;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1321861-1.html#0',3,'match1321861-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.analyze.relations.AnalyzedRelation;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.common.collections.Lists2;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.execution.engine.collect.CollectExpression;
import io.crate.expression.InputFactory;
import io.crate.expression.symbol.Function;
import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.ParameterBinder;
import io.crate.expression.symbol.RefReplacer;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.FunctionImplementation;
import io.crate.metadata.RelationName;
import io.crate.metadata.Scalar;
import io.crate.metadata.SearchPath;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.doc.DocSchemaInfo;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.metadata.settings.SessionSettings;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.testing.SqlExpressions;
import io.crate.types.DataType;
import org.hamcrest.Matcher;
import org.hamcrest.Matchers;
import org.junit.Before;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.core.Is.is;

public abstract class ScalarTestCase extends CrateDummyClusterServiceUnitTest {

    protected SqlExpressions sqlExpressions;
    protected Map&lt;RelationName, AnalyzedRelation&gt; tableSources;
    protected TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext()</B></FONT>;
    private InputFactory inputFactory;

    protected static SessionSettings DUMMY_SESSION_INFO = new SessionSettings(
        &quot;dummyUser&quot;,
        SearchPath.createSearchPathFrom(&quot;dummySchema&quot;));

    @Before
    public void prepareFunctions() {
        String createTableStmt =
            &quot;create table doc.users (&quot; +
            &quot;  id int,&quot; +
            &quot;  name text,&quot; +
            &quot;  tags array(text),&quot; +
            &quot;  age int,&quot; +
            &quot;  a int,&quot; +
            &quot;  ip ip,&quot; +
            &quot;  c char,&quot; +
            &quot;  x bigint,&quot; +
            &quot;  shape geo_shape,&quot; +
            &quot;  timestamp_tz timestamp with time zone,&quot; +
            &quot;  timestamp timestamp without time zone,&quot; +
            &quot;  timezone text,&quot; +
            &quot;  interval text,&quot; +
            &quot;  time_format text,&quot; +
            &quot;  long_array array(bigint),&quot; +
            &quot;  int_array array(int),&quot; +
            &quot;  short_array array(short),&quot; +
            &quot;  double_array array(double precision),&quot; +
            &quot;  regex_pattern text,&quot; +
            &quot;  geoshape geo_shape,&quot; +
            &quot;  geopoint geo_point,&quot; +
            &quot;  geostring text,&quot; +
            &quot;  is_awesome boolean,&quot; +
            &quot;  double_val double precision,&quot; +
            &quot;  float_val real,&quot; +
            &quot;  short_val smallint,&quot; +
            &quot;  obj object,&quot; +
            &quot;  obj_ignored object(ignored)&quot; +
            &quot;)&quot;;

        DocTableInfo tableInfo = SQLExecutor.tableInfo(
            new RelationName(DocSchemaInfo.NAME, &quot;users&quot;),
            createTableStmt,
            clusterService);

        DocTableRelation tableRelation = new DocTableRelation(tableInfo);
<A NAME="1"></A>        tableSources = Map.of(tableInfo.ident(), tableRelation);
        sqlExpressions = new SqlExpressions(tableSources);
        inputFactory = new InputFactory(sqlExpressions.nodeCtx);
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1321861-1.html#1',3,'match1321861-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    /**
     * Assert that the functionExpression normalizes to the expectedSymbol
     * &lt;p&gt;
     * If the result of normalize is a Literal and all arguments were Literals evaluate is also called and
     * compared to the result of normalize - the resulting value of normalize must match evaluate.
     */
    public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol) {
        assertNormalize(functionExpression, expectedSymbol, true);
    }

    public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol, boolean evaluate) {
        // Explicit normalization happens further below
        sqlExpressions.context</B></FONT>().allowEagerNormalize(false);
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
        if (functionSymbol instanceof Literal) {
            assertThat(functionSymbol, expectedSymbol);
<A NAME="4"></A>            return;
        }
        Function function = (Function) functionSymbol;
        FunctionImplementation impl = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1321861-1.html#4',3,'match1321861-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
        assertThat(&quot;Function implementation not found using full qualified lookup&quot;, impl, Matchers.notNullValue());

        Symbol normalized = sqlExpressions.normalize(function);
        assertThat(
            String.format</B></FONT>(Locale.ENGLISH, &quot;expected &lt;%s&gt; to normalize to %s&quot;, functionExpression, expectedSymbol),
            normalized,
            expectedSymbol);

        if (evaluate &amp;&amp; normalized instanceof Input &amp;&amp; allArgsAreInputs(function.arguments())) {
            Input[] inputs = new Input[function.arguments().size()];
<A NAME="3"></A>            for (int i = 0; i &lt; inputs.length; i++) {
                inputs[i] = ((Input) function.arguments().get(i));
            }
            <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1321861-1.html#3',3,'match1321861-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Object expectedValue = ((Input) normalized).value();
            assertThat(((Scalar) impl).evaluate(txnCtx, null, inputs), is(expectedValue));
            assertThat(((Scalar) impl).compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, inputs), is</B></FONT>(expectedValue));
        }
    }

    /**
     * asserts that the given functionExpression matches the given matcher.
     * If the functionExpression contains references the inputs will be used in the order the references appear.
     * &lt;p&gt;
     * E.g.
     * &lt;code&gt;
     * assertEvaluate(&quot;foo(name, age)&quot;, anyOf(&quot;expectedValue1&quot;, &quot;expectedValue2&quot;), inputForName, inputForAge)
     * &lt;/code&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; void assertEvaluate(String functionExpression, Matcher&lt;T&gt; expectedValue, Literal&lt;?&gt;... literals) {
        if (expectedValue == null) {
            expectedValue = (Matcher&lt;T&gt;) nullValue();
        }
        sqlExpressions.context().allowEagerNormalize(true);
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
        functionSymbol = sqlExpressions.normalize(functionSymbol);
        if (functionSymbol instanceof Literal) {
            Object value = ((Literal) functionSymbol).value();
            assertThat((T) value, expectedValue);
            return;
        }
        LinkedList&lt;Literal&lt;?&gt;&gt; unusedLiterals = new LinkedList&lt;&gt;(Arrays.asList(literals));
        Function function = (Function) RefReplacer.replaceRefs(functionSymbol, r -&gt; {
            if (unusedLiterals.isEmpty()) {
                throw new IllegalArgumentException(&quot;No value literal for reference=&quot; + r + &quot;, please add more literals&quot;);
            }
            Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
            return literal;
        });
        if(unusedLiterals.size() == literals.length) {
            // Currently it's supposed that literals will be either references or parameters.
            // One of replaceRefs and bindParameters does nothing and doesn't consume unusedLiterals.
            function = (Function) ParameterBinder.bindParameters(function, p -&gt; {
                if (unusedLiterals.isEmpty()) {
                    throw new IllegalArgumentException(&quot;No value literal for parameter=&quot; + p + &quot;, please add more literals&quot;);
                }
                Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
                return literal;
            });
        }

        Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
        assertThat(&quot;Function implementation not found using full qualified lookup&quot;, scalar, Matchers.notNullValue());

        AssertMax1ValueCallInput[] arguments = new AssertMax1ValueCallInput[function.arguments().size()];
        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = inputFactory.ctxForInputColumns(txnCtx);
        for (int i = 0; i &lt; function.arguments().size(); i++) {
            Symbol arg = function.arguments().get(i);
            Input&lt;?&gt; input = ctx.add(arg);
            arguments[i] = new AssertMax1ValueCallInput(input);
        }
        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, (Input[]) arguments);
        assertThat((T) actualValue, expectedValue);

        // Reset calls
        for (AssertMax1ValueCallInput argument : arguments) {
<A NAME="5"></A>            argument.calls = 0;
        }

        actualValue = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1321861-1.html#5',3,'match1321861-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>scalar.evaluate(txnCtx, sqlExpressions.nodeCtx, arguments);
        assertThat((T) actualValue, expectedValue);
    }

    /**
     * asserts that the given functionExpression evaluates to the expectedValue.
     * If the functionExpression contains references the inputs will be used in the order the references appear.
     * &lt;p&gt;
     * E.g.
     * &lt;code&gt;
     * assertEvaluate(&quot;foo(name, age)&quot;, &quot;expectedValue&quot;, inputForName, inputForAge)
     * &lt;/code&gt;
     * or
     * &lt;code&gt;
     * assertEvaluate(&quot;foo('literalName', age)&quot;, &quot;expectedValue&quot;, inputForAge)
     * &lt;/code&gt;
     */
    public void assertEvaluate(String functionExpression, Object expectedValue, Literal&lt;?&gt;... literals) {</B></FONT>
        if (expectedValue == null) {
            assertEvaluate(functionExpression, nullValue(), literals);
        } else {
            assertEvaluate(functionExpression, is(expectedValue), literals);
        }
    }

    public void assertCompile(String functionExpression, java.util.function.Function&lt;Scalar, Matcher&lt;Scalar&gt;&gt; matcher) {
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
<A NAME="2"></A>        functionSymbol = sqlExpressions.normalize(functionSymbol);
        assertThat(&quot;function expression was normalized, compile would not be hit&quot;, functionSymbol, not(instanceOf(Literal.class)));
        Function function = (Function) functionSymbol;
        Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1321861-1.html#2',3,'match1321861-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>txnCtx.sessionSettings().searchPath());
        assertThat(&quot;Function implementation not found using full qualified lookup&quot;, scalar, Matchers.notNullValue());

        Scalar compiled = scalar.compile(function.arguments());
        assertThat(compiled, matcher.apply(scalar));
    }


    private static b</B></FONT>oolean allArgsAreInputs(List&lt;Symbol&gt; arguments) {
        for (Symbol argument : arguments) {
            if (!(argument instanceof Input)) {
                return false;
            }
        }
        return true;
    }

    protected FunctionImplementation getFunction(String functionName, DataType... argTypes) {
        return getFunction(functionName, Arrays.asList(argTypes));
    }

    protected FunctionImplementation getFunction(String functionName, List&lt;DataType&gt; argTypes) {
        return sqlExpressions.nodeCtx.functions().get(
            null, functionName, Lists2.map(argTypes, t -&gt; new InputColumn(0, t)), SearchPath.pathWithPGCatalogAndDoc());
    }

    private static class AssertMax1ValueCallInput implements Input {
        private final Input delegate;
        int calls = 0;

        AssertMax1ValueCallInput(Input delegate) {
            this.delegate = delegate;
        }

        @Override
        public Object value() {
            calls++;
            if (calls == 1) {
                return delegate.value();
            }
            throw new AssertionError(&quot;Input.value() should only be called once&quot;);
        }

        @Override
        public String toString() {
            return delegate.toString();
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SnapshotRestoreIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.integrationtests;

import io.crate.common.unit.TimeValue;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.testing.SQLResponse;
import org.apache.lucene.util.SetOnce;
import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;
import org.elasticsearch.cluster.SnapshotsInProgress;
import org.elasticsearch.cluster.metadata.IndexMetadata;
<A NAME="0"></A>import org.elasticsearch.common.collect.ImmutableOpenMap;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.plugins.Plugin;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#0',2,'match1321861-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.elasticsearch.repositories.ESBlobStoreTestCase;
import org.elasticsearch.repositories.RepositoriesService;
import org.elasticsearch.repositories.Repository;
import org.elasticsearch.repositories.RepositoryData;
import org.elasticsearch.snapshots.Snapshot;
import org.elasticsearch.snapshots.SnapshotId;
import org.elasticsearch.snapshots.SnapshotInfo;
import org.elasticsearch.snapshots.SnapshotState;
import org.elasticsearch.test.MockKeywordPlugin;
import org.elasticsearch.threadpool.ThreadPool;
import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;

import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.SQLErrorMatcher.isSQLError;
import static io.crate.testing.TestingHelpers.printedTable;
import static io.netty.handler.codec.http.HttpResponseStatus.CONFLICT;
import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;
import static io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.lessThanOrEqualTo;

public class SnapshotRestoreIntegrationTest extends SQLIntegrationTestCase {

    private static final String REPOSITORY_NAME = &quot;my_repo&quot;;
    private static final String SNAPSHOT_NAME = &quot;my_snapshot&quot;;

    @ClassRule</B></FONT>
    public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();

    private File defaultRepositoryLocation;

    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        return Settings.builder().put(super.nodeSettings(nodeOrdinal))
            .put(&quot;path.repo&quot;, TEMPORARY_FOLDER.getRoot().getAbsolutePath())
            .build();
    }

    @Override
    protected Collection&lt;Class&lt;? extends Plugin&gt;&gt; nodePlugins() {
        var plugins = new ArrayList&lt;&gt;(super.nodePlugins());
        plugins.add(MockKeywordPlugin.class);
        return plugins;
    }

    @Override
    @Before
    public void setUp() throws Exception {
        super.setUp();
        defaultRepositoryLocation = TEMPORARY_FOLDER.newFolder();
        execute(&quot;CREATE REPOSITORY &quot; + REPOSITORY_NAME + &quot; TYPE \&quot;fs\&quot; with (location=?, compress=True)&quot;,
            new Object[]{defaultRepositoryLocation.getAbsolutePath()});
        assertThat(response.rowCount(), is(1L));
        execute(
            &quot;CREATE REPOSITORY my_repo_ro TYPE \&quot;fs\&quot; with (location=?, compress=true, readonly=true)&quot;,
            new Object[]{defaultRepositoryLocation.getAbsolutePath()}
        );

        var dummyLang = new UserDefinedFunctionsIntegrationTest.DummyLang();
        Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
        for (UserDefinedFunctionService udfService : udfServices) {
            udfService.registerLanguage(dummyLang);
        }
    }

    @After
    public void cleanUp() {
        var stmts = List.of(
            &quot;REVOKE ALL FROM my_user&quot;,
            &quot;DROP ANALYZER a1&quot;,
            &quot;DROP FUNCTION custom(string)&quot;
        );
        for (var stmt : stmts) {
            try {
                execute(stmt);
            } catch (Exception e) {
                // pass, exception may raise cause entity does not exist
            }
        }

<A NAME="1"></A>        execute(&quot;DROP USER IF EXISTS my_user&quot;);
        execute(&quot;DROP VIEW IF EXISTS my_view&quot;);
        execute(&quot;DROP TABLE IF EXISTS my_table&quot;);
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#1',2,'match1321861-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void createTableAndSnapshot(String tableName, String snapshotName) {
        createTableAndSnapshot(tableName, snapshotName, false);
    }

    private void createTableAndSnapshot(String tableName, String snapshotName, boolean partitioned) {
        createTable(tableName, partitioned);
        createSnapshot</B></FONT>(snapshotName, tableName);
    }

    private void createTable(String tableName, boolean partitioned) {
        execute(&quot;CREATE TABLE &quot; + tableName + &quot; (&quot; +
                &quot;  id long primary key, &quot; +
                &quot;  name string, &quot; +
                &quot;  date timestamp with time zone &quot; + (partitioned ? &quot;primary key,&quot; : &quot;,&quot;) +
                &quot;  ft string index using fulltext with (analyzer='default')&quot; +
                &quot;) &quot; + (partitioned ? &quot;partitioned by (date) &quot; : &quot;&quot;) +
                &quot;clustered into 1 shards with (number_of_replicas=0)&quot;);
        execute(&quot;INSERT INTO &quot; + tableName + &quot; (id, name, date, ft) VALUES (?, ?, ?, ?)&quot;, new Object[][]{
            {1L, &quot;foo&quot;, &quot;1970-01-01&quot;, &quot;The quick brown fox jumps over the lazy dog.&quot;},
            {2L, &quot;bar&quot;, &quot;2015-10-27T11:29:00+01:00&quot;, &quot;Morgenstund hat Gold im Mund.&quot;},
            {3L, &quot;baz&quot;, &quot;1989-11-09&quot;, &quot;Reden ist Schweigen. Silber ist Gold.&quot;},
        });
        execute(&quot;REFRESH TABLE &quot; + tableName);
    }

    private void createSnapshot(String snapshotName, String... tables) {
        execute(&quot;CREATE SNAPSHOT &quot; + REPOSITORY_NAME + &quot;.&quot; + snapshotName + &quot; TABLE &quot; + String.join(&quot;, &quot;, tables) +
                &quot; WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));
    }

    private static String snapshotName() {
        return String.format(Locale.ENGLISH, &quot;%s.%s&quot;, REPOSITORY_NAME, SNAPSHOT_NAME);
    }

    @Test
    public void testDropSnapshot() throws Exception {
        String snapshotName = &quot;my_snap_1&quot;;
        createTableAndSnapshot(&quot;my_table&quot;, snapshotName);

        execute(&quot;drop snapshot &quot; + REPOSITORY_NAME + &quot;.&quot; + snapshotName);
        assertThat(response.rowCount(), is(1L));

        execute(&quot;select * from sys.snapshots where name = ?&quot;, new Object[]{snapshotName});
        assertThat(response.rowCount(), is(0L));
        assertAllRepoSnapshotFilesAreDeleted(defaultRepositoryLocation);
    }

    @Test
    public void testDropUnknownSnapshot() throws Exception {
        String snapshot = &quot;unknown_snap&quot;;
        assertThrowsMatches(() -&gt; execute(&quot;drop snapshot &quot; + REPOSITORY_NAME + &quot;.&quot; + snapshot),
                     isSQLError(is(String.format(Locale.ENGLISH, &quot;Snapshot '%s.%s' unknown&quot;, REPOSITORY_NAME, snapshot)),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4048));
    }

    @Test
    public void testDropSnapshotUnknownRepository() throws Exception {
        String repository = &quot;unknown_repo&quot;;
        String snapshot = &quot;unknown_snap&quot;;
        assertThrowsMatches(() -&gt; execute(&quot;drop snapshot &quot; + repository + &quot;.&quot; + snapshot),
                     isSQLError(is(String.format(Locale.ENGLISH, &quot;Repository '%s' unknown&quot;, repository)),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4047));
    }

    @Test
    public void testCreateSnapshot() throws Exception {
        createTable(&quot;backmeup&quot;, false);
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; TABLE backmeup WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));

        execute(&quot;select name, \&quot;repository\&quot;, concrete_indices, state from sys.snapshots order by 2&quot;);
        assertThat(printedTable(response.rows()),
                   is(String.format(
                &quot;my_snapshot| my_repo| [%s.backmeup]| SUCCESS\n&quot; +
                // shows up twice because both repos have the same data path
                &quot;my_snapshot| my_repo_ro| [%s.backmeup]| SUCCESS\n&quot;,
                sqlExecutor.getCurrentSchema(),
                sqlExecutor.getCurrentSchema())));
    }

    @Test
    public void testCreateSnapshotWithoutWaitForCompletion() throws Exception {
<A NAME="5"></A>        // this test just verifies that no exception is thrown if wait_for_completion is false
        execute(&quot;CREATE SNAPSHOT my_repo.snapshot_no_wait ALL WITH (wait_for_completion=false)&quot;);
        assertThat(response.rowCount(), is(1L));
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#5',2,'match1321861-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>waitForCompletion(REPOSITORY_NAME, &quot;snapshot_no_wait&quot;, TimeValue.timeValueSeconds(20));
    }

    private SnapshotInfo waitForCompletion(String repository, String snapshotName, TimeValue timeout) throws InterruptedException {</B></FONT>
<A NAME="3"></A>        long start = System.currentTimeMillis();
        Snapshot snapshot = new Snapshot(repository, new SnapshotId(repository, snapshotName));
        while (System.currentTimeMillis() - start &lt; timeout.millis()) {
            <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#3',2,'match1321861-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>List&lt;SnapshotInfo&gt; snapshotInfos = client().admin().cluster().prepareGetSnapshots(repository).setSnapshots(snapshotName).get().getSnapshots();
            assertThat(snapshotInfos.size</B></FONT>(), equalTo(1));
            if (snapshotInfos.get(0).state().completed()) {
                // Make sure that snapshot clean up operations are finished
                ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();
                SnapshotsInProgress snapshotsInProgress = stateResponse.getState().custom(SnapshotsInProgress.TYPE);
                if (snapshotsInProgress == null || snapshotsInProgress.snapshot(snapshot) == null) {
                    return snapshotInfos.get(0);
                }
            }
            Thread.sleep(100);
        }
        fail(&quot;Timeout waiting for snapshot completion!&quot;);
        return null;
    }

    @Test
    public void testCreateSnapshotFromPartition() throws Exception {
        createTable(&quot;custom.backmeup&quot;, true);

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() +
                &quot; TABLE custom.backmeup PARTITION (date='1970-01-01')  WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));

        execute(&quot;select name, \&quot;repository\&quot;, concrete_indices, tables, state from sys.snapshots order by 2&quot;);
        assertThat(printedTable(response.rows()),
                   is(&quot;my_snapshot| my_repo| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n&quot; +
               // shows up twice because the repos have the same fs path.
               &quot;my_snapshot| my_repo_ro| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n&quot;));
    }

    @Test
    public void testCreateSnapshotAllBlobsExcluded() throws Exception {
        execute(&quot;CREATE TABLE t1 (id INTEGER, name STRING)&quot;);
        execute(&quot;CREATE BLOB TABLE b1&quot;);
        ensureYellow();
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));

        execute(&quot;select concrete_indices from sys.snapshots&quot;);
        assertThat(response.rows()[0][0], is(List.of(getFqn(&quot;t1&quot;))));
    }

    @Test
    public void testCreateExistingSnapshot() throws Exception {
        createTable(&quot;backmeup&quot;, randomBoolean());

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));
        assertThrowsMatches(() -&gt; execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;),
                     isSQLError(containsString(&quot;Invalid snapshot name [my_snapshot], snapshot with the same name already exists&quot;),
                                INTERNAL_ERROR,
                                CONFLICT,
                                4099));
    }

    @Test
    public void testCreateSnapshotUnknownRepo() throws Exception {
        assertThrowsMatches(() -&gt; execute(&quot;CREATE SNAPSHOT unknown_repo.my_snapshot ALL WITH (wait_for_completion=true)&quot;),
                     isSQLError(is(&quot;Repository 'unknown_repo' unknown&quot;),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4047));
    }

    @Test
    public void testInvalidSnapshotName() throws Exception {
        assertThrowsMatches(() -&gt; execute(&quot;CREATE SNAPSHOT my_repo.\&quot;MY_UPPER_SNAPSHOT\&quot; ALL WITH (wait_for_completion=true)&quot;),
                     isSQLError(containsString(&quot;Invalid snapshot name [MY_UPPER_SNAPSHOT], must be lowercase&quot;),
                                INTERNAL_ERROR,
                                CONFLICT,
                                4099));
    }

    @Test
    public void testSnapshotWithMetadataDoesNotDeleteExistingStuff() throws Exception {
        createTable(&quot;my_other&quot;, true);
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_other with (wait_for_completion=true)&quot;);

        execute(&quot;alter table my_other add column x double&quot;);
        waitForMappingUpdateOnAll(&quot;my_other&quot;, &quot;x&quot;);
        execute(&quot;delete from my_other&quot;);

        execute(&quot;CREATE TABLE survivor (bla string, blubb float) partitioned by (blubb) with (number_of_replicas=0)&quot;);
        ensureYellow();
        execute(&quot;insert into survivor (bla, blubb) values (?, ?)&quot;, new Object[][]{
            {&quot;foo&quot;, 1.2},
            {&quot;bar&quot;, 1.4},
            {&quot;baz&quot;, 1.2}
        });
        execute(&quot;refresh table survivor&quot;);

        execute(&quot;restore snapshot &quot; + snapshotName() + &quot; ALL with (wait_for_completion=true)&quot;);

        execute(&quot;select * from survivor order by bla&quot;);
        assertThat(printedTable(response.rows()), is(
            &quot;bar| 1.4\n&quot; +
            &quot;baz| 1.2\n&quot; +
            &quot;foo| 1.2\n&quot;));
    }

    @Test
    public void testSnapshotWithMetadataConcurrentlyModified() throws Exception {
        int shards = randomFrom(1, 3, 5);
        int replicas = randomIntBetween(2, 10);
        long documents = randomLongBetween(2, 100);

        execute(&quot;CREATE TABLE test (&quot; +
                &quot;  id long primary key)&quot; +
                &quot;clustered into &quot; + shards + &quot; shards with (column_policy = 'dynamic', number_of_replicas=&quot; + replicas +
                &quot;)&quot;);

        ensureYellow();

        CompletableFuture&lt;SQLResponse&gt; createSnapshot = null;
        // Insert data with dynamic column creation so we trigger a dynamic mapping update for each of them
        for (var i = 0; i &lt; documents; i++) {
            execute(&quot;INSERT INTO test (id, field_&quot; + i + &quot;) VALUES (?, ?)&quot;, new Object[][]{{i, &quot;value_&quot; + i},});
            execute(&quot;REFRESH TABLE test&quot;);
            if (createSnapshot == null) {
                createSnapshot = sqlExecutor.execute(
                    &quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; TABLE test with (wait_for_completion=true)&quot;, null);
            }
        }

        if (createSnapshot != null) {
            createSnapshot.get();
        }

<A NAME="4"></A>        execute(&quot;DROP table test&quot;);

        execute(&quot;select state from sys.snapshots where name=?&quot;, new Object[]{SNAPSHOT_NAME});
        <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#4',2,'match1321861-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(response.rows()[0][0], is(&quot;SUCCESS&quot;));

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ALL with (wait_for_completion=true)&quot;);

        waitNoPendingTasksOnAll();

        SnapshotsInProgress finalSnapshotsInProgress = clusterService</B></FONT>().state().custom(SnapshotsInProgress.TYPE);
        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -&gt; entry.state().completed() == false));

        ImmutableOpenMap&lt;String, IndexMetadata&gt; state = clusterService().state().metadata().indices();
        IndexMetadata indexMetadata = state.values().iterator().next().value;
        int sizeOfProperties = ((Map&lt;?, ?&gt;) indexMetadata.mapping().sourceAsMap().get(&quot;properties&quot;)).size();

        execute(&quot;select count(*) from test&quot;);

        assertThat(
            &quot;Documents were restored but the restored index mapping was older than some documents and misses some of their fields&quot;,
            (Long)response.rows()[0][0], lessThanOrEqualTo((long) sizeOfProperties));
    }

    @Test
    public void testRestoreSnapshotAll() throws Exception {
        createTableAndSnapshot(&quot;my_table&quot;, SNAPSHOT_NAME);

        execute(&quot;drop table my_table&quot;);

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ALL with (&quot; +
                &quot;ignore_unavailable=false, &quot; +
                &quot;wait_for_completion=true)&quot;);
        ensureGreen();
        execute(&quot;select * from my_table order by id&quot;);
        assertThat(response.rowCount(), is(3L));
    }

    @Test
    public void testRestoreSnapshotSinglePartition() throws Exception {
        createTableAndSnapshot(&quot;my_parted_table&quot;, SNAPSHOT_NAME, true);
        waitNoPendingTasksOnAll();

        execute(&quot;delete from my_parted_table&quot;);
        waitNoPendingTasksOnAll();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_parted_table PARTITION (date='1970-01-01') with (&quot; +
                &quot;ignore_unavailable=false, &quot; +
                &quot;wait_for_completion=true)&quot;);

        execute(&quot;select date from my_parted_table&quot;);
        assertThat(printedTable(response.rows()), is(&quot;0\n&quot;));
    }

    @Test
    public void testRestoreSinglePartitionSnapshotIntoDroppedPartition() throws Exception {
        createTable(&quot;parted_table&quot;, true);
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() +
                &quot; TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)&quot;);
        execute(&quot;delete from parted_table where date=0&quot;);
        waitNoPendingTasksOnAll();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE parted_table PARTITION (date=0) with (&quot; +
                &quot;ignore_unavailable=false, &quot; +
                &quot;wait_for_completion=true)&quot;);
        execute(&quot;select date from parted_table order by id&quot;);
        assertThat(printedTable(response.rows()), is(&quot;0\n1445941740000\n626572800000\n&quot;));
    }

    @Test
    public void testRestoreSinglePartitionSnapshotIntoDroppedTable() throws Exception {
        createTable(&quot;parted_table&quot;, true);
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() +
                &quot; TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)&quot;);
        execute(&quot;drop table parted_table&quot;);
        waitNoPendingTasksOnAll();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE parted_table PARTITION (date=0) with (&quot; +
                &quot;ignore_unavailable=false, &quot; +
                &quot;wait_for_completion=true)&quot;);
        execute(&quot;select date from parted_table order by id&quot;);
        assertThat(printedTable(response.rows()), is(&quot;0\n&quot;));
    }

    @Test
    public void testRestoreFullPartedTableSnapshotSinglePartitionIntoDroppedTable() throws Exception {
        createTableAndSnapshot(&quot;my_parted_table&quot;, SNAPSHOT_NAME, true);

        execute(&quot;drop table my_parted_table&quot;);
        waitNoPendingTasksOnAll();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_parted_table PARTITION (date=0) with (&quot; +
                &quot;ignore_unavailable=false, &quot; +
                &quot;wait_for_completion=true)&quot;);

        execute(&quot;select date from my_parted_table&quot;);
        assertThat(printedTable(response.rows()), is(&quot;0\n&quot;));
    }

    @Test
    public void testRestoreSnapshotIgnoreUnavailable() throws Exception {
        createTableAndSnapshot(&quot;my_table&quot;, SNAPSHOT_NAME, true);

        execute(&quot;drop table my_table&quot;);

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_table, not_my_table with (&quot; +
                &quot;ignore_unavailable=true, &quot; +
                &quot;wait_for_completion=true)&quot;);
        execute(&quot;select table_schema || '.' || table_name from information_schema.tables where table_schema = ?&quot;,
            new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn(&quot;my_table&quot;) + &quot;\n&quot;));
    }

    @Test
    public void testRestoreOnlyOneTable() throws Exception {
        createTable(&quot;my_table_1&quot;, false);
        createTable(&quot;my_table_2&quot;, false);
        createSnapshot(SNAPSHOT_NAME, &quot;my_table_1&quot;, &quot;my_table_2&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;drop table my_table_1&quot;);

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_table_1 with (&quot; +
                &quot;wait_for_completion=true)&quot;);

        execute(&quot;select table_schema || '.' || table_name from information_schema.tables where table_schema = ? order by 1&quot;,
            new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn(&quot;my_table_1&quot;) + &quot;\n&quot; + getFqn(&quot;my_table_2&quot;) + &quot;\n&quot;));
    }

    @Test
    public void test_parallel_restore_operations() throws Exception {
        createTable(&quot;my_table_1&quot;, false);
        createTable(&quot;my_table_2&quot;, false);
        createSnapshot(SNAPSHOT_NAME, &quot;my_table_1&quot;, &quot;my_table_2&quot;);
        waitNoPendingTasksOnAll();
        execute(&quot;drop table my_table_1&quot;);
        execute(&quot;drop table my_table_2&quot;);

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_table_1 with (&quot; +
                &quot;wait_for_completion=false)&quot;);
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_table_2 with (&quot; +
                &quot;wait_for_completion=false)&quot;);

        assertBusy(() -&gt; {
            execute(
                &quot;select table_name from information_schema.tables where table_schema = ? order by 1&quot;,
                new Object[] { sqlExecutor.getCurrentSchema() }
            );
            assertThat(printedTable(response.rows()), is(
                &quot;my_table_1\n&quot; +
                &quot;my_table_2\n&quot;
            ));
        });
    }

    /**
     * Test to restore a concrete partitioned table.
     * &lt;p&gt;
     * This requires a patch in ES in order to restore templates when concrete tables are passed as an restore argument:
     * https://github.com/crate/elasticsearch/commit/3c14e74a3e50ea7d890f436db72ff18c2953ebc4
     */
    @Test
    public void testRestoreOnlyOnePartitionedTable() throws Exception {
        createTable(&quot;my_parted_1&quot;, true);
        createTable(&quot;my_parted_2&quot;, true);
        createSnapshot(SNAPSHOT_NAME, &quot;my_parted_1&quot;, &quot;my_parted_2&quot;);

        execute(&quot;drop table my_parted_1&quot;);
        execute(&quot;drop table my_parted_2&quot;);

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE my_parted_1 with (&quot; +
                &quot;wait_for_completion=true)&quot;);

        execute(&quot;select table_schema || '.' || table_name from information_schema.tables where table_schema = ?&quot;, new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn(&quot;my_parted_1&quot;) + &quot;\n&quot;));
    }

    @Test
    public void testRestoreEmptyPartitionedTableUsingALL() throws Exception {
        execute(&quot;create table employees(section integer, name string) partitioned by (section)&quot;);
        ensureYellow();

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        execute(&quot;drop table employees&quot;);
        ensureYellow();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ALL with (wait_for_completion=true)&quot;);
        ensureYellow();

        execute(&quot;select table_schema || '.' || table_name from information_schema.tables where table_schema = ?&quot;, new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn(&quot;employees&quot;) + &quot;\n&quot;));
    }

    @Test
    public void testRestoreEmptyPartitionedTable() throws Exception {
        execute(&quot;create table employees(section integer, name string) partitioned by (section)&quot;);
        ensureYellow();

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        execute(&quot;drop table employees&quot;);
        ensureYellow();
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE employees with (wait_for_completion=true)&quot;);
        ensureYellow();

        execute(&quot;select table_schema || '.' || table_name from information_schema.tables where table_schema = ?&quot;, new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn(&quot;employees&quot;) + &quot;\n&quot;));
    }

    @Test
    public void testResolveUnknownTableFromSnapshot() throws Exception {
        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        ensureYellow();

        assertThrowsMatches(() -&gt; execute(
            &quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLE employees with (wait_for_completion=true)&quot;),
                     isSQLError(is(String.format(&quot;[%s..partitioned.employees.] template not found&quot;, sqlExecutor.getCurrentSchema())),
                        INTERNAL_ERROR,
                        INTERNAL_SERVER_ERROR,
                        5000)
        );
    }

    @Test
    public void test_cannot_create_snapshot_in_read_only_repo() {
        assertThrowsMatches(() -&gt; execute(&quot;create snapshot my_repo_ro.s1 ALL WITH (wait_for_completion=true)&quot;),
                     isSQLError(containsString(&quot;cannot create snapshot in a readonly repository&quot;),
                                INTERNAL_ERROR,
                                INTERNAL_SERVER_ERROR,
                                5000));
    }

    public void test_snapshot_with_corrupted_shard_index_file() throws Exception {
        execute(&quot;CREATE TABLE t1 (x int)&quot;);
        var numberOfDocs = randomLongBetween(0, 10);
        for (int i = 0; i &lt; numberOfDocs; i++) {
            execute(&quot;INSERT INTO t1 (x) VALUES (?)&quot;, new Object[]{randomInt()});
        }
        execute(&quot;REFRESH TABLE t1&quot;);

        var snapShotName1 = &quot;s1&quot;;
        var fullSnapShotName1 =  REPOSITORY_NAME + &quot;.&quot; + snapShotName1;
        execute(&quot;CREATE SNAPSHOT &quot; + fullSnapShotName1 + &quot; ALL WITH (wait_for_completion=true)&quot;);

        var repositoryData = getRepositoryData();
        var indexIds = repositoryData.getIndices();
        assertThat(indexIds.size(), equalTo(1));

        var corruptedIndex = indexIds.entrySet().iterator().next().getValue();
        var shardIndexFile = defaultRepositoryLocation.toPath().resolve(&quot;indices&quot;)
            .resolve(corruptedIndex.getId()).resolve(&quot;0&quot;)
            .resolve(&quot;index-&quot; + repositoryData.shardGenerations().getShardGen(corruptedIndex, 0));

        // Truncating shard index file
        try (var outChan = Files.newByteChannel(shardIndexFile, StandardOpenOption.WRITE)) {
            outChan.truncate(randomInt(10));
        }

        assertSnapShotState(snapShotName1, SnapshotState.SUCCESS);

        execute(&quot;drop table t1&quot;);
        execute(&quot;RESTORE SNAPSHOT &quot; +  fullSnapShotName1 + &quot; TABLE t1 with (wait_for_completion=true)&quot;);
        ensureYellow();

        execute(&quot;SELECT COUNT(*) FROM t1&quot;);
        assertThat(response.rows()[0][0], is(numberOfDocs));

        var numberOfAdditionalDocs = randomLongBetween(0, 10);
        for (int i = 0; i &lt; numberOfAdditionalDocs; i++) {
            execute(&quot;INSERT INTO t1 (x) VALUES (?)&quot;, new Object[]{randomInt()});
        }
        execute(&quot;REFRESH TABLE t1&quot;);

        var snapShotName2 = &quot;s2&quot;;
        var fullSnapShotName2 = REPOSITORY_NAME + &quot;.s2&quot;;

        execute(&quot;CREATE SNAPSHOT &quot; + fullSnapShotName2 + &quot; ALL WITH (wait_for_completion=true)&quot;);
        assertSnapShotState(snapShotName2, SnapshotState.PARTIAL);
    }

    @Test
    public void test_restore_all_restores_complete_state() throws Exception {
        createSnapshotWithTablesAndMetadata();

        // restore ALL
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;select table_name from information_schema.tables where table_name = 'my_table'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_table\n&quot;));

        execute(&quot;SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_view\n&quot;));

        execute(&quot;select name from sys.users where name = 'my_user'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_user\n&quot;));

        execute(&quot;SELECT type FROM sys.privileges WHERE grantee = 'my_user'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;DQL\n&quot;));

        execute(&quot;SELECT routine_name, routine_type FROM information_schema.routines WHERE&quot; +
                &quot; routine_name IN ('a1', 'custom') ORDER BY 1&quot;);
        assertThat(printedTable(response.rows()), is(&quot;a1| ANALYZER\n&quot; +
                                                     &quot;custom| FUNCTION\n&quot;));
    }

    @Test
    public void test_restore_all_tables_only() throws Exception {
        createTable(&quot;t2&quot;, true);
        createSnapshotWithTablesAndMetadata();
        execute(&quot;drop table t2&quot;);

        // restore all tables
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; TABLES WITH (wait_for_completion=true)&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;select table_name from information_schema.tables where table_schema = ? order by 1&quot;,
                $(sqlExecutor.getCurrentSchema()));
        assertThat(printedTable(response.rows()), is(&quot;my_table\n&quot; +
                                                     &quot;t2\n&quot;));
    }

    @Test
    public void test_restore_metadata_only_does_not_restore_tables() throws Exception {
        createSnapshotWithTablesAndMetadata();

        // restore METADATA only
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; METADATA WITH (wait_for_completion=true)&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_view\n&quot;));

        execute(&quot;SELECT name FROM sys.users WHERE name = 'my_user'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_user\n&quot;));

        execute(&quot;SELECT type FROM sys.privileges WHERE grantee = 'my_user'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;DQL\n&quot;));

        execute(&quot;SELECT routine_name, routine_type FROM information_schema.routines WHERE&quot; +
                &quot; routine_name IN ('a1', 'custom') ORDER BY 1&quot;);
        assertThat(printedTable(response.rows()), is(&quot;a1| ANALYZER\n&quot; +
                                                     &quot;custom| FUNCTION\n&quot;));

        // NO tables must be restored
        execute(&quot;SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'&quot;);
        assertThat(response.rowCount(), is(0L));

    }

    /**
     * Restoring ANALYZERS will result in restoring analyzer settings out of the global settings
     */
    @Test
    public void test_restore_analyzers_only() throws Exception {
        createSnapshotWithTablesAndMetadata();

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ANALYZERS WITH (wait_for_completion=true)&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;SELECT routine_name, routine_type FROM information_schema.routines WHERE&quot; +
                &quot; routine_name IN ('a1', 'custom') ORDER BY 1&quot;);
        assertThat(printedTable(response.rows()), is(&quot;a1| ANALYZER\n&quot;));

        // All other MUST NOT be restored
        execute(&quot;SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'&quot;);
        assertThat(response.rowCount(), is(0L));

        execute(&quot;SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'&quot;);
        assertThat(response.rowCount(), is(0L));

        execute(&quot;SELECT name FROM sys.users WHERE name = 'my_user'&quot;);
        assertThat(response.rowCount(), is(0L));

        execute(&quot;SELECT type FROM sys.privileges WHERE grantee = 'my_user'&quot;);
        assertThat(response.rowCount(), is(0L));
    }

    /**
     * Restoring USERS will result in restoring custom metadata only and NO global settings.
     * This test a regression which resulted in restoring the custom metadata only if global settings
     * were also marked to be restored.
     */
    @Test
    public void test_restore_custom_metadata_only() throws Exception {
        createSnapshotWithTablesAndMetadata();

        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; USERS WITH (wait_for_completion=true)&quot;);
        waitNoPendingTasksOnAll();

        execute(&quot;SELECT name FROM sys.users WHERE name = 'my_user'&quot;);
        assertThat(printedTable(response.rows()), is(&quot;my_user\n&quot;));
    }

    @Test
    public void test_create_snapshot_tables_does_not_store_global_state() {
        createTable(&quot;custom.t1&quot;, false);
        execute(&quot;CREATE USER my_user&quot;);

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; TABLE custom.t1 WITH (wait_for_completion=true)&quot;);

        execute(&quot;DROP TABLE custom.t1&quot;);
        execute(&quot;DROP USER my_user&quot;);

        // restore everything from the snapshot to validate that it only contains the table
        execute(&quot;RESTORE SNAPSHOT &quot; + snapshotName() + &quot; ALL&quot;);

        execute(&quot;SELECT table_name FROM information_schema.tables WHERE table_name = 't1'&quot;);
        assertThat(response.rowCount(), is(1L));

        execute(&quot;SELECT name FROM sys.users WHERE name = 'my_user'&quot;);
        assertThat(response.rowCount(), is(0L));
    }

    private void createSnapshotWithTablesAndMetadata() throws Exception {
        createTable(&quot;my_table&quot;, false);
        // creates custom metadata
        execute(&quot;CREATE USER my_user&quot;);
        execute(&quot;GRANT DQL TO my_user&quot;);
        execute(&quot;CREATE VIEW my_view AS SELECT * FROM my_table LIMIT 1&quot;);
        execute(&quot;CREATE FUNCTION custom(string) RETURNS STRING LANGUAGE dummy_lang AS '42'&quot;);
        // creates persistent cluster settings
        execute(&quot;CREATE ANALYZER a1 (TOKENIZER keyword)&quot;);

        execute(&quot;CREATE SNAPSHOT &quot; + snapshotName() + &quot; ALL WITH (wait_for_completion=true)&quot;);
        assertThat(response.rowCount(), is(1L));
        waitNoPendingTasksOnAll();

        // drop all created
        execute(&quot;REVOKE ALL FROM my_user&quot;);
        execute(&quot;DROP USER my_user&quot;);
        execute(&quot;DROP VIEW my_view&quot;);
        execute(&quot;DROP TABLE my_table&quot;);
        execute(&quot;DROP ANALYZER a1&quot;);
        execute(&quot;DROP FUNCTION custom(string)&quot;);
    }

    private void assertSnapShotState(String snapShotName, SnapshotState state) {
        execute(
            &quot;SELECT state, array_length(concrete_indices, 1) FROM sys.snapshots where name = ? and repository = ?&quot;,
            new Object[]{snapShotName, REPOSITORY_NAME});

        assertThat(response.rows()[0][0], is(state.name()));
        assertThat(response.rows()[0][1], is(1));
    }
<A NAME="2"></A>
    private static void assertAllRepoSnapshotFilesAreDeleted(File location) throws IOException {
        //Make sure the file location does not consist of any .dat file
        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1321861-0.html#2',2,'match1321861-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Files.walk(location.toPath())
            .filter(Files::isRegularFile)
            .forEach(x -&gt; assertThat(x.getFileName().endsWith(&quot;.dat&quot;), is(false)));
    }

    private Repositor</B></FONT>yData getRepositoryData() throws Exception {
        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName());
        Repository repository = service.repository(REPOSITORY_NAME);
        ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, internalCluster().getMasterName());
        final SetOnce&lt;RepositoryData&gt; repositoryData = new SetOnce&lt;&gt;();
        final CountDownLatch latch = new CountDownLatch(1);
        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -&gt; {
            repositoryData.set(ESBlobStoreTestCase.getRepositoryData(repository));
            latch.countDown();
        });
        latch.await();
        return repositoryData.get();
    }
}
</PRE>
</div>
  </div>
</body>
</html>
