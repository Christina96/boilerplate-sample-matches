<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ScalarTestCase.java &amp; SnapshotRestoreIntegrationTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ScalarTestCase.java &amp; SnapshotRestoreIntegrationTest.java
      </h3>
<h1 align="center">
        14.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ScalarTestCase.java (28.205128%)<th>SnapshotRestoreIntegrationTest.java (9.40171%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-69)<td><a href="#" name="0">(34-80)</a><td align="center"><font color="#ff0000">42</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(119-133)<td><a href="#" name="1">(137-145)</a><td align="center"><font color="#610000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(250-258)<td><a href="#" name="2">(807-812)</a><td align="center"><font color="#480000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(154-156)<td><a href="#" name="3">(236-237)</a><td align="center"><font color="#3c0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(140-145)<td><a href="#" name="4">(368-374)</a><td align="center"><font color="#3c0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(220-237)<td><a href="#" name="5">(229-232)</a><td align="center"><font color="#360000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScalarTestCase.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<a name="0"></a>
package io.crate.expression.scalar;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.analyze.relations.AnalyzedRelation;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.common.collections.Lists2;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.execution.engine.collect.CollectExpression;
import io.crate.expression.InputFactory;
import io.crate.expression.symbol.Function;
import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.ParameterBinder;
import io.crate.expression.symbol.RefReplacer;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.FunctionImplementation;
import io.crate.metadata.RelationName;
import io.crate.metadata.Scalar;
import io.crate.metadata.SearchPath;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.doc.DocSchemaInfo;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.metadata.settings.SessionSettings;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.testing.SqlExpressions;
import io.crate.types.DataType;
import org.hamcrest.Matcher;
import org.hamcrest.Matchers;
import org.junit.Before;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.core.Is.is;

public abstract class ScalarTestCase extends CrateDummyClusterServiceUnitTest {

    protected SqlExpressions sqlExpressions;
    protected Map&lt;RelationName, AnalyzedRelation&gt; tableSources;
    protected TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext()</b></font>;
    private InputFactory inputFactory;

    protected static SessionSettings DUMMY_SESSION_INFO = new SessionSettings(
        "dummyUser",
        SearchPath.createSearchPathFrom("dummySchema"));

    @Before
    public void prepareFunctions() {
        String createTableStmt =
            "create table doc.users (" +
            "  id int," +
            "  name text," +
            "  tags array(text)," +
            "  age int," +
            "  a int," +
            "  ip ip," +
            "  c char," +
            "  x bigint," +
            "  shape geo_shape," +
            "  timestamp_tz timestamp with time zone," +
            "  timestamp timestamp without time zone," +
            "  timezone text," +
            "  interval text," +
            "  time_format text," +
            "  long_array array(bigint)," +
            "  int_array array(int)," +
            "  short_array array(short)," +
            "  double_array array(double precision)," +
            "  regex_pattern text," +
            "  geoshape geo_shape," +
            "  geopoint geo_point," +
            "  geostring text," +
            "  is_awesome boolean," +
            "  double_val double precision," +
            "  float_val real," +
            "  short_val smallint," +
            "  obj object," +
            "  obj_ignored object(ignored)" +
            ")";

        DocTableInfo tableInfo = SQLExecutor.tableInfo(
            new RelationName(DocSchemaInfo.NAME, "users"),
            createTableStmt,
            clusterService);

        DocTableRelation tableRelation = new DocTableRelation(tableInfo);
<a name="1"></a>        tableSources = Map.of(tableInfo.ident(), tableRelation);
        sqlExpressions = new SqlExpressions(tableSources);
        inputFactory = new InputFactory(sqlExpressions.nodeCtx);
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    /**
     * Assert that the functionExpression normalizes to the expectedSymbol
     * &lt;p&gt;
     * If the result of normalize is a Literal and all arguments were Literals evaluate is also called and
     * compared to the result of normalize - the resulting value of normalize must match evaluate.
     */
    public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol) {
        assertNormalize(functionExpression, expectedSymbol, true);
    }

    public void assertNormalize(String functionExpression, Matcher&lt;? super Symbol&gt; expectedSymbol, boolean evaluate) {
        // Explicit normalization happens further below
        sqlExpressions.context</b></font>().allowEagerNormalize(false);
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
        if (functionSymbol instanceof Literal) {
            assertThat(functionSymbol, expectedSymbol);
<a name="4"></a>            return;
        }
        Function function = (Function) functionSymbol;
        FunctionImplementation impl = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
        assertThat("Function implementation not found using full qualified lookup", impl, Matchers.notNullValue());

        Symbol normalized = sqlExpressions.normalize(function);
        assertThat(
            String.format</b></font>(Locale.ENGLISH, "expected &lt;%s&gt; to normalize to %s", functionExpression, expectedSymbol),
            normalized,
            expectedSymbol);

        if (evaluate &amp;&amp; normalized instanceof Input &amp;&amp; allArgsAreInputs(function.arguments())) {
            Input[] inputs = new Input[function.arguments().size()];
<a name="3"></a>            for (int i = 0; i &lt; inputs.length; i++) {
                inputs[i] = ((Input) function.arguments().get(i));
            }
            <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Object expectedValue = ((Input) normalized).value();
            assertThat(((Scalar) impl).evaluate(txnCtx, null, inputs), is(expectedValue));
            assertThat(((Scalar) impl).compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, inputs), is</b></font>(expectedValue));
        }
    }

    /**
     * asserts that the given functionExpression matches the given matcher.
     * If the functionExpression contains references the inputs will be used in the order the references appear.
     * &lt;p&gt;
     * E.g.
     * &lt;code&gt;
     * assertEvaluate("foo(name, age)", anyOf("expectedValue1", "expectedValue2"), inputForName, inputForAge)
     * &lt;/code&gt;
     */
    @SuppressWarnings("unchecked")
    public &lt;T&gt; void assertEvaluate(String functionExpression, Matcher&lt;T&gt; expectedValue, Literal&lt;?&gt;... literals) {
        if (expectedValue == null) {
            expectedValue = (Matcher&lt;T&gt;) nullValue();
        }
        sqlExpressions.context().allowEagerNormalize(true);
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
        functionSymbol = sqlExpressions.normalize(functionSymbol);
        if (functionSymbol instanceof Literal) {
            Object value = ((Literal) functionSymbol).value();
            assertThat((T) value, expectedValue);
            return;
        }
        LinkedList&lt;Literal&lt;?&gt;&gt; unusedLiterals = new LinkedList&lt;&gt;(Arrays.asList(literals));
        Function function = (Function) RefReplacer.replaceRefs(functionSymbol, r -&gt; {
            if (unusedLiterals.isEmpty()) {
                throw new IllegalArgumentException("No value literal for reference=" + r + ", please add more literals");
            }
            Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
            return literal;
        });
        if(unusedLiterals.size() == literals.length) {
            // Currently it's supposed that literals will be either references or parameters.
            // One of replaceRefs and bindParameters does nothing and doesn't consume unusedLiterals.
            function = (Function) ParameterBinder.bindParameters(function, p -&gt; {
                if (unusedLiterals.isEmpty()) {
                    throw new IllegalArgumentException("No value literal for parameter=" + p + ", please add more literals");
                }
                Literal&lt;?&gt; literal = unusedLiterals.pollFirst(); //Can be null.
                return literal;
            });
        }

        Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, txnCtx.sessionSettings().searchPath());
        assertThat("Function implementation not found using full qualified lookup", scalar, Matchers.notNullValue());

        AssertMax1ValueCallInput[] arguments = new AssertMax1ValueCallInput[function.arguments().size()];
        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = inputFactory.ctxForInputColumns(txnCtx);
        for (int i = 0; i &lt; function.arguments().size(); i++) {
            Symbol arg = function.arguments().get(i);
            Input&lt;?&gt; input = ctx.add(arg);
            arguments[i] = new AssertMax1ValueCallInput(input);
        }
        Object actualValue = scalar.compile(function.arguments()).evaluate(txnCtx, sqlExpressions.nodeCtx, (Input[]) arguments);
        assertThat((T) actualValue, expectedValue);

        // Reset calls
        for (AssertMax1ValueCallInput argument : arguments) {
<a name="5"></a>            argument.calls = 0;
        }

        actualValue = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>scalar.evaluate(txnCtx, sqlExpressions.nodeCtx, arguments);
        assertThat((T) actualValue, expectedValue);
    }

    /**
     * asserts that the given functionExpression evaluates to the expectedValue.
     * If the functionExpression contains references the inputs will be used in the order the references appear.
     * &lt;p&gt;
     * E.g.
     * &lt;code&gt;
     * assertEvaluate("foo(name, age)", "expectedValue", inputForName, inputForAge)
     * &lt;/code&gt;
     * or
     * &lt;code&gt;
     * assertEvaluate("foo('literalName', age)", "expectedValue", inputForAge)
     * &lt;/code&gt;
     */
    public void assertEvaluate(String functionExpression, Object expectedValue, Literal&lt;?&gt;... literals) {</b></font>
        if (expectedValue == null) {
            assertEvaluate(functionExpression, nullValue(), literals);
        } else {
            assertEvaluate(functionExpression, is(expectedValue), literals);
        }
    }

    public void assertCompile(String functionExpression, java.util.function.Function&lt;Scalar, Matcher&lt;Scalar&gt;&gt; matcher) {
        Symbol functionSymbol = sqlExpressions.asSymbol(functionExpression);
<a name="2"></a>        functionSymbol = sqlExpressions.normalize(functionSymbol);
        assertThat("function expression was normalized, compile would not be hit", functionSymbol, not(instanceOf(Literal.class)));
        Function function = (Function) functionSymbol;
        Scalar scalar = (Scalar) sqlExpressions.nodeCtx.functions().getQualified(function, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>txnCtx.sessionSettings().searchPath());
        assertThat("Function implementation not found using full qualified lookup", scalar, Matchers.notNullValue());

        Scalar compiled = scalar.compile(function.arguments());
        assertThat(compiled, matcher.apply(scalar));
    }


    private static b</b></font>oolean allArgsAreInputs(List&lt;Symbol&gt; arguments) {
        for (Symbol argument : arguments) {
            if (!(argument instanceof Input)) {
                return false;
            }
        }
        return true;
    }

    protected FunctionImplementation getFunction(String functionName, DataType... argTypes) {
        return getFunction(functionName, Arrays.asList(argTypes));
    }

    protected FunctionImplementation getFunction(String functionName, List&lt;DataType&gt; argTypes) {
        return sqlExpressions.nodeCtx.functions().get(
            null, functionName, Lists2.map(argTypes, t -&gt; new InputColumn(0, t)), SearchPath.pathWithPGCatalogAndDoc());
    }

    private static class AssertMax1ValueCallInput implements Input {
        private final Input delegate;
        int calls = 0;

        AssertMax1ValueCallInput(Input delegate) {
            this.delegate = delegate;
        }

        @Override
        public Object value() {
            calls++;
            if (calls == 1) {
                return delegate.value();
            }
            throw new AssertionError("Input.value() should only be called once");
        }

        @Override
        public String toString() {
            return delegate.toString();
        }
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SnapshotRestoreIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.integrationtests;

import io.crate.common.unit.TimeValue;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.testing.SQLResponse;
import org.apache.lucene.util.SetOnce;
import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;
import org.elasticsearch.cluster.SnapshotsInProgress;
import org.elasticsearch.cluster.metadata.IndexMetadata;
<a name="0"></a>import org.elasticsearch.common.collect.ImmutableOpenMap;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.plugins.Plugin;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.repositories.ESBlobStoreTestCase;
import org.elasticsearch.repositories.RepositoriesService;
import org.elasticsearch.repositories.Repository;
import org.elasticsearch.repositories.RepositoryData;
import org.elasticsearch.snapshots.Snapshot;
import org.elasticsearch.snapshots.SnapshotId;
import org.elasticsearch.snapshots.SnapshotInfo;
import org.elasticsearch.snapshots.SnapshotState;
import org.elasticsearch.test.MockKeywordPlugin;
import org.elasticsearch.threadpool.ThreadPool;
import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;

import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.SQLErrorMatcher.isSQLError;
import static io.crate.testing.TestingHelpers.printedTable;
import static io.netty.handler.codec.http.HttpResponseStatus.CONFLICT;
import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;
import static io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.lessThanOrEqualTo;

public class SnapshotRestoreIntegrationTest extends SQLIntegrationTestCase {

    private static final String REPOSITORY_NAME = "my_repo";
    private static final String SNAPSHOT_NAME = "my_snapshot";

    @ClassRule</b></font>
    public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();

    private File defaultRepositoryLocation;

    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        return Settings.builder().put(super.nodeSettings(nodeOrdinal))
            .put("path.repo", TEMPORARY_FOLDER.getRoot().getAbsolutePath())
            .build();
    }

    @Override
    protected Collection&lt;Class&lt;? extends Plugin&gt;&gt; nodePlugins() {
        var plugins = new ArrayList&lt;&gt;(super.nodePlugins());
        plugins.add(MockKeywordPlugin.class);
        return plugins;
    }

    @Override
    @Before
    public void setUp() throws Exception {
        super.setUp();
        defaultRepositoryLocation = TEMPORARY_FOLDER.newFolder();
        execute("CREATE REPOSITORY " + REPOSITORY_NAME + " TYPE \"fs\" with (location=?, compress=True)",
            new Object[]{defaultRepositoryLocation.getAbsolutePath()});
        assertThat(response.rowCount(), is(1L));
        execute(
            "CREATE REPOSITORY my_repo_ro TYPE \"fs\" with (location=?, compress=true, readonly=true)",
            new Object[]{defaultRepositoryLocation.getAbsolutePath()}
        );

        var dummyLang = new UserDefinedFunctionsIntegrationTest.DummyLang();
        Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
        for (UserDefinedFunctionService udfService : udfServices) {
            udfService.registerLanguage(dummyLang);
        }
    }

    @After
    public void cleanUp() {
        var stmts = List.of(
            "REVOKE ALL FROM my_user",
            "DROP ANALYZER a1",
            "DROP FUNCTION custom(string)"
        );
        for (var stmt : stmts) {
            try {
                execute(stmt);
            } catch (Exception e) {
                // pass, exception may raise cause entity does not exist
            }
        }

<a name="1"></a>        execute("DROP USER IF EXISTS my_user");
        execute("DROP VIEW IF EXISTS my_view");
        execute("DROP TABLE IF EXISTS my_table");
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    private void createTableAndSnapshot(String tableName, String snapshotName) {
        createTableAndSnapshot(tableName, snapshotName, false);
    }

    private void createTableAndSnapshot(String tableName, String snapshotName, boolean partitioned) {
        createTable(tableName, partitioned);
        createSnapshot</b></font>(snapshotName, tableName);
    }

    private void createTable(String tableName, boolean partitioned) {
        execute("CREATE TABLE " + tableName + " (" +
                "  id long primary key, " +
                "  name string, " +
                "  date timestamp with time zone " + (partitioned ? "primary key," : ",") +
                "  ft string index using fulltext with (analyzer='default')" +
                ") " + (partitioned ? "partitioned by (date) " : "") +
                "clustered into 1 shards with (number_of_replicas=0)");
        execute("INSERT INTO " + tableName + " (id, name, date, ft) VALUES (?, ?, ?, ?)", new Object[][]{
            {1L, "foo", "1970-01-01", "The quick brown fox jumps over the lazy dog."},
            {2L, "bar", "2015-10-27T11:29:00+01:00", "Morgenstund hat Gold im Mund."},
            {3L, "baz", "1989-11-09", "Reden ist Schweigen. Silber ist Gold."},
        });
        execute("REFRESH TABLE " + tableName);
    }

    private void createSnapshot(String snapshotName, String... tables) {
        execute("CREATE SNAPSHOT " + REPOSITORY_NAME + "." + snapshotName + " TABLE " + String.join(", ", tables) +
                " WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));
    }

    private static String snapshotName() {
        return String.format(Locale.ENGLISH, "%s.%s", REPOSITORY_NAME, SNAPSHOT_NAME);
    }

    @Test
    public void testDropSnapshot() throws Exception {
        String snapshotName = "my_snap_1";
        createTableAndSnapshot("my_table", snapshotName);

        execute("drop snapshot " + REPOSITORY_NAME + "." + snapshotName);
        assertThat(response.rowCount(), is(1L));

        execute("select * from sys.snapshots where name = ?", new Object[]{snapshotName});
        assertThat(response.rowCount(), is(0L));
        assertAllRepoSnapshotFilesAreDeleted(defaultRepositoryLocation);
    }

    @Test
    public void testDropUnknownSnapshot() throws Exception {
        String snapshot = "unknown_snap";
        assertThrowsMatches(() -&gt; execute("drop snapshot " + REPOSITORY_NAME + "." + snapshot),
                     isSQLError(is(String.format(Locale.ENGLISH, "Snapshot '%s.%s' unknown", REPOSITORY_NAME, snapshot)),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4048));
    }

    @Test
    public void testDropSnapshotUnknownRepository() throws Exception {
        String repository = "unknown_repo";
        String snapshot = "unknown_snap";
        assertThrowsMatches(() -&gt; execute("drop snapshot " + repository + "." + snapshot),
                     isSQLError(is(String.format(Locale.ENGLISH, "Repository '%s' unknown", repository)),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4047));
    }

    @Test
    public void testCreateSnapshot() throws Exception {
        createTable("backmeup", false);
        execute("CREATE SNAPSHOT " + snapshotName() + " TABLE backmeup WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));

        execute("select name, \"repository\", concrete_indices, state from sys.snapshots order by 2");
        assertThat(printedTable(response.rows()),
                   is(String.format(
                "my_snapshot| my_repo| [%s.backmeup]| SUCCESS\n" +
                // shows up twice because both repos have the same data path
                "my_snapshot| my_repo_ro| [%s.backmeup]| SUCCESS\n",
                sqlExecutor.getCurrentSchema(),
                sqlExecutor.getCurrentSchema())));
    }

    @Test
    public void testCreateSnapshotWithoutWaitForCompletion() throws Exception {
<a name="5"></a>        // this test just verifies that no exception is thrown if wait_for_completion is false
        execute("CREATE SNAPSHOT my_repo.snapshot_no_wait ALL WITH (wait_for_completion=false)");
        assertThat(response.rowCount(), is(1L));
        <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waitForCompletion(REPOSITORY_NAME, "snapshot_no_wait", TimeValue.timeValueSeconds(20));
    }

    private SnapshotInfo waitForCompletion(String repository, String snapshotName, TimeValue timeout) throws InterruptedException {</b></font>
<a name="3"></a>        long start = System.currentTimeMillis();
        Snapshot snapshot = new Snapshot(repository, new SnapshotId(repository, snapshotName));
        while (System.currentTimeMillis() - start &lt; timeout.millis()) {
            <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;SnapshotInfo&gt; snapshotInfos = client().admin().cluster().prepareGetSnapshots(repository).setSnapshots(snapshotName).get().getSnapshots();
            assertThat(snapshotInfos.size</b></font>(), equalTo(1));
            if (snapshotInfos.get(0).state().completed()) {
                // Make sure that snapshot clean up operations are finished
                ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();
                SnapshotsInProgress snapshotsInProgress = stateResponse.getState().custom(SnapshotsInProgress.TYPE);
                if (snapshotsInProgress == null || snapshotsInProgress.snapshot(snapshot) == null) {
                    return snapshotInfos.get(0);
                }
            }
            Thread.sleep(100);
        }
        fail("Timeout waiting for snapshot completion!");
        return null;
    }

    @Test
    public void testCreateSnapshotFromPartition() throws Exception {
        createTable("custom.backmeup", true);

        execute("CREATE SNAPSHOT " + snapshotName() +
                " TABLE custom.backmeup PARTITION (date='1970-01-01')  WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));

        execute("select name, \"repository\", concrete_indices, tables, state from sys.snapshots order by 2");
        assertThat(printedTable(response.rows()),
                   is("my_snapshot| my_repo| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n" +
               // shows up twice because the repos have the same fs path.
               "my_snapshot| my_repo_ro| [custom..partitioned.backmeup.04130]| [custom.backmeup]| SUCCESS\n"));
    }

    @Test
    public void testCreateSnapshotAllBlobsExcluded() throws Exception {
        execute("CREATE TABLE t1 (id INTEGER, name STRING)");
        execute("CREATE BLOB TABLE b1");
        ensureYellow();
        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));

        execute("select concrete_indices from sys.snapshots");
        assertThat(response.rows()[0][0], is(List.of(getFqn("t1"))));
    }

    @Test
    public void testCreateExistingSnapshot() throws Exception {
        createTable("backmeup", randomBoolean());

        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));
        assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)"),
                     isSQLError(containsString("Invalid snapshot name [my_snapshot], snapshot with the same name already exists"),
                                INTERNAL_ERROR,
                                CONFLICT,
                                4099));
    }

    @Test
    public void testCreateSnapshotUnknownRepo() throws Exception {
        assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT unknown_repo.my_snapshot ALL WITH (wait_for_completion=true)"),
                     isSQLError(is("Repository 'unknown_repo' unknown"),
                                INTERNAL_ERROR,
                                NOT_FOUND,
                                4047));
    }

    @Test
    public void testInvalidSnapshotName() throws Exception {
        assertThrowsMatches(() -&gt; execute("CREATE SNAPSHOT my_repo.\"MY_UPPER_SNAPSHOT\" ALL WITH (wait_for_completion=true)"),
                     isSQLError(containsString("Invalid snapshot name [MY_UPPER_SNAPSHOT], must be lowercase"),
                                INTERNAL_ERROR,
                                CONFLICT,
                                4099));
    }

    @Test
    public void testSnapshotWithMetadataDoesNotDeleteExistingStuff() throws Exception {
        createTable("my_other", true);
        execute("CREATE SNAPSHOT " + snapshotName() + " TABLE my_other with (wait_for_completion=true)");

        execute("alter table my_other add column x double");
        waitForMappingUpdateOnAll("my_other", "x");
        execute("delete from my_other");

        execute("CREATE TABLE survivor (bla string, blubb float) partitioned by (blubb) with (number_of_replicas=0)");
        ensureYellow();
        execute("insert into survivor (bla, blubb) values (?, ?)", new Object[][]{
            {"foo", 1.2},
            {"bar", 1.4},
            {"baz", 1.2}
        });
        execute("refresh table survivor");

        execute("restore snapshot " + snapshotName() + " ALL with (wait_for_completion=true)");

        execute("select * from survivor order by bla");
        assertThat(printedTable(response.rows()), is(
            "bar| 1.4\n" +
            "baz| 1.2\n" +
            "foo| 1.2\n"));
    }

    @Test
    public void testSnapshotWithMetadataConcurrentlyModified() throws Exception {
        int shards = randomFrom(1, 3, 5);
        int replicas = randomIntBetween(2, 10);
        long documents = randomLongBetween(2, 100);

        execute("CREATE TABLE test (" +
                "  id long primary key)" +
                "clustered into " + shards + " shards with (column_policy = 'dynamic', number_of_replicas=" + replicas +
                ")");

        ensureYellow();

        CompletableFuture&lt;SQLResponse&gt; createSnapshot = null;
        // Insert data with dynamic column creation so we trigger a dynamic mapping update for each of them
        for (var i = 0; i &lt; documents; i++) {
            execute("INSERT INTO test (id, field_" + i + ") VALUES (?, ?)", new Object[][]{{i, "value_" + i},});
            execute("REFRESH TABLE test");
            if (createSnapshot == null) {
                createSnapshot = sqlExecutor.execute(
                    "CREATE SNAPSHOT " + snapshotName() + " TABLE test with (wait_for_completion=true)", null);
            }
        }

        if (createSnapshot != null) {
            createSnapshot.get();
        }

<a name="4"></a>        execute("DROP table test");

        execute("select state from sys.snapshots where name=?", new Object[]{SNAPSHOT_NAME});
        <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(response.rows()[0][0], is("SUCCESS"));

        execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (wait_for_completion=true)");

        waitNoPendingTasksOnAll();

        SnapshotsInProgress finalSnapshotsInProgress = clusterService</b></font>().state().custom(SnapshotsInProgress.TYPE);
        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -&gt; entry.state().completed() == false));

        ImmutableOpenMap&lt;String, IndexMetadata&gt; state = clusterService().state().metadata().indices();
        IndexMetadata indexMetadata = state.values().iterator().next().value;
        int sizeOfProperties = ((Map&lt;?, ?&gt;) indexMetadata.mapping().sourceAsMap().get("properties")).size();

        execute("select count(*) from test");

        assertThat(
            "Documents were restored but the restored index mapping was older than some documents and misses some of their fields",
            (Long)response.rows()[0][0], lessThanOrEqualTo((long) sizeOfProperties));
    }

    @Test
    public void testRestoreSnapshotAll() throws Exception {
        createTableAndSnapshot("my_table", SNAPSHOT_NAME);

        execute("drop table my_table");

        execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (" +
                "ignore_unavailable=false, " +
                "wait_for_completion=true)");
        ensureGreen();
        execute("select * from my_table order by id");
        assertThat(response.rowCount(), is(3L));
    }

    @Test
    public void testRestoreSnapshotSinglePartition() throws Exception {
        createTableAndSnapshot("my_parted_table", SNAPSHOT_NAME, true);
        waitNoPendingTasksOnAll();

        execute("delete from my_parted_table");
        waitNoPendingTasksOnAll();
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_table PARTITION (date='1970-01-01') with (" +
                "ignore_unavailable=false, " +
                "wait_for_completion=true)");

        execute("select date from my_parted_table");
        assertThat(printedTable(response.rows()), is("0\n"));
    }

    @Test
    public void testRestoreSinglePartitionSnapshotIntoDroppedPartition() throws Exception {
        createTable("parted_table", true);
        execute("CREATE SNAPSHOT " + snapshotName() +
                " TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)");
        execute("delete from parted_table where date=0");
        waitNoPendingTasksOnAll();
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE parted_table PARTITION (date=0) with (" +
                "ignore_unavailable=false, " +
                "wait_for_completion=true)");
        execute("select date from parted_table order by id");
        assertThat(printedTable(response.rows()), is("0\n1445941740000\n626572800000\n"));
    }

    @Test
    public void testRestoreSinglePartitionSnapshotIntoDroppedTable() throws Exception {
        createTable("parted_table", true);
        execute("CREATE SNAPSHOT " + snapshotName() +
                " TABLE parted_table PARTITION (date=0) WITH (wait_for_completion=true)");
        execute("drop table parted_table");
        waitNoPendingTasksOnAll();
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE parted_table PARTITION (date=0) with (" +
                "ignore_unavailable=false, " +
                "wait_for_completion=true)");
        execute("select date from parted_table order by id");
        assertThat(printedTable(response.rows()), is("0\n"));
    }

    @Test
    public void testRestoreFullPartedTableSnapshotSinglePartitionIntoDroppedTable() throws Exception {
        createTableAndSnapshot("my_parted_table", SNAPSHOT_NAME, true);

        execute("drop table my_parted_table");
        waitNoPendingTasksOnAll();
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_table PARTITION (date=0) with (" +
                "ignore_unavailable=false, " +
                "wait_for_completion=true)");

        execute("select date from my_parted_table");
        assertThat(printedTable(response.rows()), is("0\n"));
    }

    @Test
    public void testRestoreSnapshotIgnoreUnavailable() throws Exception {
        createTableAndSnapshot("my_table", SNAPSHOT_NAME, true);

        execute("drop table my_table");

        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table, not_my_table with (" +
                "ignore_unavailable=true, " +
                "wait_for_completion=true)");
        execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?",
            new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn("my_table") + "\n"));
    }

    @Test
    public void testRestoreOnlyOneTable() throws Exception {
        createTable("my_table_1", false);
        createTable("my_table_2", false);
        createSnapshot(SNAPSHOT_NAME, "my_table_1", "my_table_2");
        waitNoPendingTasksOnAll();

        execute("drop table my_table_1");

        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_1 with (" +
                "wait_for_completion=true)");

        execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ? order by 1",
            new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn("my_table_1") + "\n" + getFqn("my_table_2") + "\n"));
    }

    @Test
    public void test_parallel_restore_operations() throws Exception {
        createTable("my_table_1", false);
        createTable("my_table_2", false);
        createSnapshot(SNAPSHOT_NAME, "my_table_1", "my_table_2");
        waitNoPendingTasksOnAll();
        execute("drop table my_table_1");
        execute("drop table my_table_2");

        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_1 with (" +
                "wait_for_completion=false)");
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_table_2 with (" +
                "wait_for_completion=false)");

        assertBusy(() -&gt; {
            execute(
                "select table_name from information_schema.tables where table_schema = ? order by 1",
                new Object[] { sqlExecutor.getCurrentSchema() }
            );
            assertThat(printedTable(response.rows()), is(
                "my_table_1\n" +
                "my_table_2\n"
            ));
        });
    }

    /**
     * Test to restore a concrete partitioned table.
     * &lt;p&gt;
     * This requires a patch in ES in order to restore templates when concrete tables are passed as an restore argument:
     * https://github.com/crate/elasticsearch/commit/3c14e74a3e50ea7d890f436db72ff18c2953ebc4
     */
    @Test
    public void testRestoreOnlyOnePartitionedTable() throws Exception {
        createTable("my_parted_1", true);
        createTable("my_parted_2", true);
        createSnapshot(SNAPSHOT_NAME, "my_parted_1", "my_parted_2");

        execute("drop table my_parted_1");
        execute("drop table my_parted_2");

        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE my_parted_1 with (" +
                "wait_for_completion=true)");

        execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn("my_parted_1") + "\n"));
    }

    @Test
    public void testRestoreEmptyPartitionedTableUsingALL() throws Exception {
        execute("create table employees(section integer, name string) partitioned by (section)");
        ensureYellow();

        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        execute("drop table employees");
        ensureYellow();
        execute("RESTORE SNAPSHOT " + snapshotName() + " ALL with (wait_for_completion=true)");
        ensureYellow();

        execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn("employees") + "\n"));
    }

    @Test
    public void testRestoreEmptyPartitionedTable() throws Exception {
        execute("create table employees(section integer, name string) partitioned by (section)");
        ensureYellow();

        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        execute("drop table employees");
        ensureYellow();
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLE employees with (wait_for_completion=true)");
        ensureYellow();

        execute("select table_schema || '.' || table_name from information_schema.tables where table_schema = ?", new Object[]{sqlExecutor.getCurrentSchema()});
        assertThat(printedTable(response.rows()), is(getFqn("employees") + "\n"));
    }

    @Test
    public void testResolveUnknownTableFromSnapshot() throws Exception {
        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        ensureYellow();

        assertThrowsMatches(() -&gt; execute(
            "RESTORE SNAPSHOT " + snapshotName() + " TABLE employees with (wait_for_completion=true)"),
                     isSQLError(is(String.format("[%s..partitioned.employees.] template not found", sqlExecutor.getCurrentSchema())),
                        INTERNAL_ERROR,
                        INTERNAL_SERVER_ERROR,
                        5000)
        );
    }

    @Test
    public void test_cannot_create_snapshot_in_read_only_repo() {
        assertThrowsMatches(() -&gt; execute("create snapshot my_repo_ro.s1 ALL WITH (wait_for_completion=true)"),
                     isSQLError(containsString("cannot create snapshot in a readonly repository"),
                                INTERNAL_ERROR,
                                INTERNAL_SERVER_ERROR,
                                5000));
    }

    public void test_snapshot_with_corrupted_shard_index_file() throws Exception {
        execute("CREATE TABLE t1 (x int)");
        var numberOfDocs = randomLongBetween(0, 10);
        for (int i = 0; i &lt; numberOfDocs; i++) {
            execute("INSERT INTO t1 (x) VALUES (?)", new Object[]{randomInt()});
        }
        execute("REFRESH TABLE t1");

        var snapShotName1 = "s1";
        var fullSnapShotName1 =  REPOSITORY_NAME + "." + snapShotName1;
        execute("CREATE SNAPSHOT " + fullSnapShotName1 + " ALL WITH (wait_for_completion=true)");

        var repositoryData = getRepositoryData();
        var indexIds = repositoryData.getIndices();
        assertThat(indexIds.size(), equalTo(1));

        var corruptedIndex = indexIds.entrySet().iterator().next().getValue();
        var shardIndexFile = defaultRepositoryLocation.toPath().resolve("indices")
            .resolve(corruptedIndex.getId()).resolve("0")
            .resolve("index-" + repositoryData.shardGenerations().getShardGen(corruptedIndex, 0));

        // Truncating shard index file
        try (var outChan = Files.newByteChannel(shardIndexFile, StandardOpenOption.WRITE)) {
            outChan.truncate(randomInt(10));
        }

        assertSnapShotState(snapShotName1, SnapshotState.SUCCESS);

        execute("drop table t1");
        execute("RESTORE SNAPSHOT " +  fullSnapShotName1 + " TABLE t1 with (wait_for_completion=true)");
        ensureYellow();

        execute("SELECT COUNT(*) FROM t1");
        assertThat(response.rows()[0][0], is(numberOfDocs));

        var numberOfAdditionalDocs = randomLongBetween(0, 10);
        for (int i = 0; i &lt; numberOfAdditionalDocs; i++) {
            execute("INSERT INTO t1 (x) VALUES (?)", new Object[]{randomInt()});
        }
        execute("REFRESH TABLE t1");

        var snapShotName2 = "s2";
        var fullSnapShotName2 = REPOSITORY_NAME + ".s2";

        execute("CREATE SNAPSHOT " + fullSnapShotName2 + " ALL WITH (wait_for_completion=true)");
        assertSnapShotState(snapShotName2, SnapshotState.PARTIAL);
    }

    @Test
    public void test_restore_all_restores_complete_state() throws Exception {
        createSnapshotWithTablesAndMetadata();

        // restore ALL
        execute("RESTORE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        waitNoPendingTasksOnAll();

        execute("select table_name from information_schema.tables where table_name = 'my_table'");
        assertThat(printedTable(response.rows()), is("my_table\n"));

        execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
        assertThat(printedTable(response.rows()), is("my_view\n"));

        execute("select name from sys.users where name = 'my_user'");
        assertThat(printedTable(response.rows()), is("my_user\n"));

        execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
        assertThat(printedTable(response.rows()), is("DQL\n"));

        execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
                " routine_name IN ('a1', 'custom') ORDER BY 1");
        assertThat(printedTable(response.rows()), is("a1| ANALYZER\n" +
                                                     "custom| FUNCTION\n"));
    }

    @Test
    public void test_restore_all_tables_only() throws Exception {
        createTable("t2", true);
        createSnapshotWithTablesAndMetadata();
        execute("drop table t2");

        // restore all tables
        execute("RESTORE SNAPSHOT " + snapshotName() + " TABLES WITH (wait_for_completion=true)");
        waitNoPendingTasksOnAll();

        execute("select table_name from information_schema.tables where table_schema = ? order by 1",
                $(sqlExecutor.getCurrentSchema()));
        assertThat(printedTable(response.rows()), is("my_table\n" +
                                                     "t2\n"));
    }

    @Test
    public void test_restore_metadata_only_does_not_restore_tables() throws Exception {
        createSnapshotWithTablesAndMetadata();

        // restore METADATA only
        execute("RESTORE SNAPSHOT " + snapshotName() + " METADATA WITH (wait_for_completion=true)");
        waitNoPendingTasksOnAll();

        execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
        assertThat(printedTable(response.rows()), is("my_view\n"));

        execute("SELECT name FROM sys.users WHERE name = 'my_user'");
        assertThat(printedTable(response.rows()), is("my_user\n"));

        execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
        assertThat(printedTable(response.rows()), is("DQL\n"));

        execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
                " routine_name IN ('a1', 'custom') ORDER BY 1");
        assertThat(printedTable(response.rows()), is("a1| ANALYZER\n" +
                                                     "custom| FUNCTION\n"));

        // NO tables must be restored
        execute("SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'");
        assertThat(response.rowCount(), is(0L));

    }

    /**
     * Restoring ANALYZERS will result in restoring analyzer settings out of the global settings
     */
    @Test
    public void test_restore_analyzers_only() throws Exception {
        createSnapshotWithTablesAndMetadata();

        execute("RESTORE SNAPSHOT " + snapshotName() + " ANALYZERS WITH (wait_for_completion=true)");
        waitNoPendingTasksOnAll();

        execute("SELECT routine_name, routine_type FROM information_schema.routines WHERE" +
                " routine_name IN ('a1', 'custom') ORDER BY 1");
        assertThat(printedTable(response.rows()), is("a1| ANALYZER\n"));

        // All other MUST NOT be restored
        execute("SELECT table_name FROM information_schema.tables WHERE table_name = 'my_table'");
        assertThat(response.rowCount(), is(0L));

        execute("SELECT table_name FROM information_schema.views WHERE table_name = 'my_view'");
        assertThat(response.rowCount(), is(0L));

        execute("SELECT name FROM sys.users WHERE name = 'my_user'");
        assertThat(response.rowCount(), is(0L));

        execute("SELECT type FROM sys.privileges WHERE grantee = 'my_user'");
        assertThat(response.rowCount(), is(0L));
    }

    /**
     * Restoring USERS will result in restoring custom metadata only and NO global settings.
     * This test a regression which resulted in restoring the custom metadata only if global settings
     * were also marked to be restored.
     */
    @Test
    public void test_restore_custom_metadata_only() throws Exception {
        createSnapshotWithTablesAndMetadata();

        execute("RESTORE SNAPSHOT " + snapshotName() + " USERS WITH (wait_for_completion=true)");
        waitNoPendingTasksOnAll();

        execute("SELECT name FROM sys.users WHERE name = 'my_user'");
        assertThat(printedTable(response.rows()), is("my_user\n"));
    }

    @Test
    public void test_create_snapshot_tables_does_not_store_global_state() {
        createTable("custom.t1", false);
        execute("CREATE USER my_user");

        execute("CREATE SNAPSHOT " + snapshotName() + " TABLE custom.t1 WITH (wait_for_completion=true)");

        execute("DROP TABLE custom.t1");
        execute("DROP USER my_user");

        // restore everything from the snapshot to validate that it only contains the table
        execute("RESTORE SNAPSHOT " + snapshotName() + " ALL");

        execute("SELECT table_name FROM information_schema.tables WHERE table_name = 't1'");
        assertThat(response.rowCount(), is(1L));

        execute("SELECT name FROM sys.users WHERE name = 'my_user'");
        assertThat(response.rowCount(), is(0L));
    }

    private void createSnapshotWithTablesAndMetadata() throws Exception {
        createTable("my_table", false);
        // creates custom metadata
        execute("CREATE USER my_user");
        execute("GRANT DQL TO my_user");
        execute("CREATE VIEW my_view AS SELECT * FROM my_table LIMIT 1");
        execute("CREATE FUNCTION custom(string) RETURNS STRING LANGUAGE dummy_lang AS '42'");
        // creates persistent cluster settings
        execute("CREATE ANALYZER a1 (TOKENIZER keyword)");

        execute("CREATE SNAPSHOT " + snapshotName() + " ALL WITH (wait_for_completion=true)");
        assertThat(response.rowCount(), is(1L));
        waitNoPendingTasksOnAll();

        // drop all created
        execute("REVOKE ALL FROM my_user");
        execute("DROP USER my_user");
        execute("DROP VIEW my_view");
        execute("DROP TABLE my_table");
        execute("DROP ANALYZER a1");
        execute("DROP FUNCTION custom(string)");
    }

    private void assertSnapShotState(String snapShotName, SnapshotState state) {
        execute(
            "SELECT state, array_length(concrete_indices, 1) FROM sys.snapshots where name = ? and repository = ?",
            new Object[]{snapShotName, REPOSITORY_NAME});

        assertThat(response.rows()[0][0], is(state.name()));
        assertThat(response.rows()[0][1], is(1));
    }
<a name="2"></a>
    private static void assertAllRepoSnapshotFilesAreDeleted(File location) throws IOException {
        //Make sure the file location does not consist of any .dat file
        <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Files.walk(location.toPath())
            .filter(Files::isRegularFile)
            .forEach(x -&gt; assertThat(x.getFileName().endsWith(".dat"), is(false)));
    }

    private Repositor</b></font>yData getRepositoryData() throws Exception {
        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName());
        Repository repository = service.repository(REPOSITORY_NAME);
        ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, internalCluster().getMasterName());
        final SetOnce&lt;RepositoryData&gt; repositoryData = new SetOnce&lt;&gt;();
        final CountDownLatch latch = new CountDownLatch(1);
        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -&gt; {
            repositoryData.set(ESBlobStoreTestCase.getRepositoryData(repository));
            latch.countDown();
        });
        latch.await();
        return repositoryData.get();
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
