
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-JDK14LoggerAdapter.java</h3>
            <pre><code>1  package org.slf4j.impl;
2  import java.util.logging.Level;
3  import java.util.logging.LogRecord;
4  import org.slf4j.Logger;
5  import org.slf4j.Marker;
6  import org.slf4j.event.EventConstants;
7  import org.slf4j.event.LoggingEvent;
8  import org.slf4j.helpers.FormattingTuple;
9  import org.slf4j.helpers.MarkerIgnoringBase;
10  import org.slf4j.helpers.MessageFormatter;
11  import org.slf4j.spi.LocationAwareLogger;
12  public final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {
13      private static final long serialVersionUID = -8053026990503422791L;
14      transient final java.util.logging.Logger logger;
15      JDK14LoggerAdapter(java.util.logging.Logger logger) {
16          this.logger = logger;
17          this.name = logger.getName();
18      }
19      public boolean isTraceEnabled() {
20          return logger.isLoggable(Level.FINEST);
21      }
22      public void trace(String msg) {
23          if (logger.isLoggable(Level.FINEST)) {
24              log(SELF, Level.FINEST, msg, null);
25          }
26      }
27      public void trace(String format, Object arg) {
28          if (logger.isLoggable(Level.FINEST)) {
29              FormattingTuple ft = MessageFormatter.format(format, arg);
30              log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
31          }
32      }
33      public void trace(String format, Object arg1, Object arg2) {
34          if (logger.isLoggable(Level.FINEST)) {
35              FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
36              log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
37          }
38      }
39      public void trace(String format, Object... argArray) {
40          if (logger.isLoggable(Level.FINEST)) {
41              FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
42              log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
43          }
44      }
45      public void trace(String msg, Throwable t) {
46          if (logger.isLoggable(Level.FINEST)) {
47              log(SELF, Level.FINEST, msg, t);
48          }
49      }
50      public boolean isDebugEnabled() {
51          return logger.isLoggable(Level.FINE);
52      }
53      public void debug(String msg) {
54          if (logger.isLoggable(Level.FINE)) {
55              log(SELF, Level.FINE, msg, null);
56          }
57      }
58      public void debug(String format, Object arg) {
59          if (logger.isLoggable(Level.FINE)) {
60              FormattingTuple ft = MessageFormatter.format(format, arg);
61              log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
62          }
63      }
64      public void debug(String format, Object arg1, Object arg2) {
65          if (logger.isLoggable(Level.FINE)) {
66              FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
67              log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
68          }
69      }
70      public void debug(String format, Object... argArray) {
71          if (logger.isLoggable(Level.FINE)) {
72              FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
73              log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
74          }
75      }
76      public void debug(String msg, Throwable t) {
77          if (logger.isLoggable(Level.FINE)) {
78              log(SELF, Level.FINE, msg, t);
79          }
80      }
81      public boolean isInfoEnabled() {
82          return logger.isLoggable(Level.INFO);
83      }
84      public void info(String msg) {
85          if (logger.isLoggable(Level.INFO)) {
86              log(SELF, Level.INFO, msg, null);
87          }
88      }
89      public void info(String format, Object arg) {
90          if (logger.isLoggable(Level.INFO)) {
91              FormattingTuple ft = MessageFormatter.format(format, arg);
92              log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
93          }
94      }
95      public void info(String format, Object arg1, Object arg2) {
96          if (logger.isLoggable(Level.INFO)) {
97              FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
98              log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
99          }
100      }
101      public void info(String format, Object... argArray) {
102          if (logger.isLoggable(Level.INFO)) {
103              FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
104              log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
105          }
106      }
107      public void info(String msg, Throwable t) {
108          if (logger.isLoggable(Level.INFO)) {
109              log(SELF, Level.INFO, msg, t);
110          }
111      }
112      public boolean isWarnEnabled() {
113          return logger.isLoggable(Level.WARNING);
114      }
115      public void warn(String msg) {
116          if (logger.isLoggable(Level.WARNING)) {
117              log(SELF, Level.WARNING, msg, null);
118          }
119      }
120      public void warn(String format, Object arg) {
121          if (logger.isLoggable(Level.WARNING)) {
122              FormattingTuple ft = MessageFormatter.format(format, arg);
123              log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
124          }
125      }
126      public void warn(String format, Object arg1, Object arg2) {
127          if (logger.isLoggable(Level.WARNING)) {
128              FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
129              log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
130          }
131      }
132      public void warn(String format, Object... argArray) {
133          if (logger.isLoggable(Level.WARNING)) {
134              FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
135              log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
136          }
137      }
138      public void warn(String msg, Throwable t) {
139          if (logger.isLoggable(Level.WARNING)) {
140              log(SELF, Level.WARNING, msg, t);
141          }
142      }
143      public boolean isErrorEnabled() {
144          return logger.isLoggable(Level.SEVERE);
145      }
146      public void error(String msg) {
147          if (logger.isLoggable(Level.SEVERE)) {
148              log(SELF, Level.SEVERE, msg, null);
149          }
150      }
151      public void error(String format, Object arg) {
152          if (logger.isLoggable(Level.SEVERE)) {
153              FormattingTuple ft = MessageFormatter.format(format, arg);
154              log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
155          }
156      }
157      public void error(String format, Object arg1, Object arg2) {
158          if (logger.isLoggable(Level.SEVERE)) {
159              FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
160              log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
161          }
162      }
163      public void error(String format, Object... arguments) {
164          if (logger.isLoggable(Level.SEVERE)) {
165              FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);
166              log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
167          }
168      }
169      public void error(String msg, Throwable t) {
170          if (logger.isLoggable(Level.SEVERE)) {
171              log(SELF, Level.SEVERE, msg, t);
172          }
173      }
174      private void log(String callerFQCN, Level level, String msg, Throwable t) {
175          LogRecord record = new LogRecord(level, msg);
176          record.setLoggerName(getName());
177          record.setThrown(t);
178          fillCallerData(callerFQCN, record);
179          logger.log(record);
180      }
181      static String SELF = JDK14LoggerAdapter.class.getName();
182      static String SUPER = MarkerIgnoringBase.class.getName();
183      private static final boolean FILL_CALLER_DATA = Boolean.getBoolean( "net.md_5.bungee.slf4j-caller-data" );
184      final private void fillCallerData(String callerFQCN, LogRecord record) {
185          if ( !FILL_CALLER_DATA )
186          {
187              return;
188          }
189          StackTraceElement[] steArray = new Throwable().getStackTrace();
190          int selfIndex = -1;
191          for (int i = 0; i < steArray.length; i++) {
192              final String className = steArray[i].getClassName();
193              if (className.equals(callerFQCN) || className.equals(SUPER)) {
194                  selfIndex = i;
195                  break;
196              }
197          }
198          int found = -1;
199          for (int i = selfIndex + 1; i < steArray.length; i++) {
200              final String className = steArray[i].getClassName();
201              if (!(className.equals(callerFQCN) || className.equals(SUPER))) {
202                  found = i;
203                  break;
204              }
205          }
206          if (found != -1) {
207              StackTraceElement ste = steArray[found];
208              record.setSourceClassName(ste.getClassName());
209              record.setSourceMethodName(ste.getMethodName());
210          }
211      }
212      public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {
213          Level julLevel = slf4jLevelIntToJULLevel(level);
214          if (logger.isLoggable(julLevel)) {
215              log(callerFQCN, julLevel, message, t);
216          }
217      }
218      private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {
219          Level julLevel;
220          switch (slf4jLevelInt) {
221          case LocationAwareLogger.TRACE_INT:
222              julLevel = Level.FINEST;
223              break;
224          case LocationAwareLogger.DEBUG_INT:
225              julLevel = Level.FINE;
226              break;
227          case LocationAwareLogger.INFO_INT:
228              julLevel = Level.INFO;
229              break;
230          case LocationAwareLogger.WARN_INT:
231              julLevel = Level.WARNING;
232              break;
233          case LocationAwareLogger.ERROR_INT:
234              julLevel = Level.SEVERE;
235              break;
236          default:
237              throw new IllegalStateException("Level number " + slf4jLevelInt + " is not recognized.");
238          }
239          return julLevel;
240      }
241      public void log(LoggingEvent event) {
242          Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());
243          if (logger.isLoggable(julLevel)) {
244              LogRecord record = eventToRecord(event, julLevel);
245              logger.log(record);
246          }
247      }
248      private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {
249          String format = event.getMessage();
250          Object[] arguments = event.getArgumentArray();
251          FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);
252          if (ft.getThrowable() != null && event.getThrowable() != null) {
253              throw new IllegalArgumentException("both last element in argument array and last argument are of type Throwable");
254          }
255          Throwable t = event.getThrowable();
256          if (ft.getThrowable() != null) {
257              t = ft.getThrowable();
258              throw new IllegalStateException("fix above code");
<span onclick='openModal()' class='match'>259          }
260          LogRecord record = new LogRecord(julLevel, ft.getMessage());
261          record.setLoggerName(event.getLoggerName());
</span>262          record.setMillis(event.getTimeStamp());
263          record.setSourceClassName(EventConstants.NA_SUBST);
264          record.setSourceMethodName(EventConstants.NA_SUBST);
265          record.setThrown(t);
266          return record;
267      }
268  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DownstreamBridge.java</h3>
            <pre><code>1  package net.md_5.bungee.connection;
2  import com.google.common.base.Function;
3  import com.google.common.base.Preconditions;
4  import com.google.common.collect.Lists;
5  import com.google.common.io.ByteArrayDataOutput;
6  import com.google.common.io.ByteStreams;
7  import com.mojang.brigadier.arguments.StringArgumentType;
8  import com.mojang.brigadier.builder.LiteralArgumentBuilder;
9  import com.mojang.brigadier.builder.RequiredArgumentBuilder;
10  import com.mojang.brigadier.context.StringRange;
11  import com.mojang.brigadier.suggestion.Suggestion;
12  import com.mojang.brigadier.suggestion.Suggestions;
13  import com.mojang.brigadier.tree.CommandNode;
14  import io.netty.buffer.ByteBuf;
15  import io.netty.buffer.ByteBufAllocator;
16  import io.netty.buffer.Unpooled;
17  import io.netty.channel.unix.DomainSocketAddress;
18  import java.io.DataInput;
19  import java.net.InetSocketAddress;
20  import java.util.ArrayList;
21  import java.util.List;
22  import java.util.Map;
23  import lombok.RequiredArgsConstructor;
24  import net.md_5.bungee.ServerConnection;
25  import net.md_5.bungee.ServerConnection.KeepAliveData;
26  import net.md_5.bungee.UserConnection;
27  import net.md_5.bungee.Util;
28  import net.md_5.bungee.api.ProxyServer;
29  import net.md_5.bungee.api.chat.BaseComponent;
30  import net.md_5.bungee.api.chat.TextComponent;
31  import net.md_5.bungee.api.config.ServerInfo;
32  import net.md_5.bungee.api.connection.ProxiedPlayer;
33  import net.md_5.bungee.api.connection.Server;
34  import net.md_5.bungee.api.event.PluginMessageEvent;
35  import net.md_5.bungee.api.event.ServerConnectEvent;
36  import net.md_5.bungee.api.event.ServerDisconnectEvent;
37  import net.md_5.bungee.api.event.ServerKickEvent;
38  import net.md_5.bungee.api.event.TabCompleteResponseEvent;
39  import net.md_5.bungee.api.plugin.Command;
40  import net.md_5.bungee.api.score.Objective;
41  import net.md_5.bungee.api.score.Position;
42  import net.md_5.bungee.api.score.Score;
43  import net.md_5.bungee.api.score.Scoreboard;
44  import net.md_5.bungee.api.score.Team;
45  import net.md_5.bungee.chat.ComponentSerializer;
46  import net.md_5.bungee.entitymap.EntityMap;
47  import net.md_5.bungee.netty.ChannelWrapper;
48  import net.md_5.bungee.netty.PacketHandler;
49  import net.md_5.bungee.protocol.DefinedPacket;
50  import net.md_5.bungee.protocol.PacketWrapper;
51  import net.md_5.bungee.protocol.ProtocolConstants;
52  import net.md_5.bungee.protocol.packet.BossBar;
53  import net.md_5.bungee.protocol.packet.Commands;
54  import net.md_5.bungee.protocol.packet.KeepAlive;
55  import net.md_5.bungee.protocol.packet.Kick;
56  import net.md_5.bungee.protocol.packet.PlayerListItem;
57  import net.md_5.bungee.protocol.packet.PlayerListItemRemove;
58  import net.md_5.bungee.protocol.packet.PlayerListItemUpdate;
59  import net.md_5.bungee.protocol.packet.PluginMessage;
60  import net.md_5.bungee.protocol.packet.Respawn;
61  import net.md_5.bungee.protocol.packet.ScoreboardDisplay;
62  import net.md_5.bungee.protocol.packet.ScoreboardObjective;
63  import net.md_5.bungee.protocol.packet.ScoreboardScore;
64  import net.md_5.bungee.protocol.packet.ServerData;
65  import net.md_5.bungee.protocol.packet.SetCompression;
66  import net.md_5.bungee.protocol.packet.TabCompleteResponse;
67  import net.md_5.bungee.tab.TabList;
68  @RequiredArgsConstructor
69  public class DownstreamBridge extends PacketHandler
70  {
71      private static final com.mojang.brigadier.Command DUMMY_COMMAND = (context) ->
72      {
73          return 0;
74      };
75      private final ProxyServer bungee;
76      private final UserConnection con;
77      private final ServerConnection server;
78      @Override
79      public void exception(Throwable t) throws Exception
80      {
81          if ( server.isObsolete() )
82          {
83              return;
84          }
85          ServerInfo def = con.updateAndGetNextServer( server.getInfo() );
86          if ( def != null )
87          {
88              server.setObsolete( true );
89              con.connectNow( def, ServerConnectEvent.Reason.SERVER_DOWN_REDIRECT );
90              con.sendMessage( bungee.getTranslation( "server_went_down" ) );
91          } else
92          {
93              con.disconnect( Util.exception( t ) );
94          }
95      }
96      @Override
97      public void disconnected(ChannelWrapper channel) throws Exception
98      {
99          server.getInfo().removePlayer( con );
100          if ( bungee.getReconnectHandler() != null )
101          {
102              bungee.getReconnectHandler().setServer( con );
103          }
104          if ( !server.isObsolete() )
105          {
106              con.disconnect( bungee.getTranslation( "lost_connection" ) );
<span onclick='openModal()' class='match'>107          }
108          ServerDisconnectEvent serverDisconnectEvent = new ServerDisconnectEvent( con, server.getInfo() );
109          bungee.getPluginManager().callEvent( serverDisconnectEvent );
</span>110      }
111      @Override
112      public boolean shouldHandle(PacketWrapper packet) throws Exception
113      {
114          return !server.isObsolete();
115      }
116      @Override
117      public void handle(PacketWrapper packet) throws Exception
118      {
119          EntityMap rewrite = con.getEntityRewrite();
120          if ( rewrite != null )
121          {
122              rewrite.rewriteClientbound( packet.buf, con.getServerEntityId(), con.getClientEntityId(), con.getPendingConnection().getVersion() );
123          }
124          con.sendPacket( packet );
125      }
126      @Override
127      public void handle(KeepAlive alive) throws Exception
128      {
129          int timeout = bungee.getConfig().getTimeout();
130          if ( timeout <= 0 || server.getKeepAlives().size() < timeout / 50 ) 
131          {
132              server.getKeepAlives().add( new KeepAliveData( alive.getRandomId(), System.currentTimeMillis() ) );
133          }
134      }
135      @Override
136      public void handle(PlayerListItem playerList) throws Exception
137      {
138          con.getTabListHandler().onUpdate( TabList.rewrite( playerList ) );
139          throw CancelSendSignal.INSTANCE; 
140      }
141      @Override
142      public void handle(PlayerListItemRemove playerList) throws Exception
143      {
144          con.getTabListHandler().onUpdate( TabList.rewrite( playerList ) );
145          throw CancelSendSignal.INSTANCE; 
146      }
147      @Override
148      public void handle(PlayerListItemUpdate playerList) throws Exception
149      {
150          con.getTabListHandler().onUpdate( TabList.rewrite( playerList ) );
151          throw CancelSendSignal.INSTANCE; 
152      }
153      @Override
154      public void handle(ScoreboardObjective objective) throws Exception
155      {
156          Scoreboard serverScoreboard = con.getServerSentScoreboard();
157          switch ( objective.getAction() )
158          {
159              case 0:
160                  serverScoreboard.addObjective( new Objective( objective.getName(), objective.getValue(), objective.getType().toString() ) );
161                  break;
162              case 1:
163                  serverScoreboard.removeObjective( objective.getName() );
164                  break;
165              case 2:
166                  Objective oldObjective = serverScoreboard.getObjective( objective.getName() );
167                  if ( oldObjective != null )
168                  {
169                      oldObjective.setValue( objective.getValue() );
170                      oldObjective.setType( objective.getType().toString() );
171                  }
172                  break;
173              default:
174                  throw new IllegalArgumentException( "Unknown objective action: " + objective.getAction() );
175          }
176      }
177      @Override
178      public void handle(ScoreboardScore score) throws Exception
179      {
180          Scoreboard serverScoreboard = con.getServerSentScoreboard();
181          switch ( score.getAction() )
182          {
183              case 0:
184                  Score s = new Score( score.getItemName(), score.getScoreName(), score.getValue() );
185                  serverScoreboard.removeScore( score.getItemName() );
186                  serverScoreboard.addScore( s );
187                  break;
188              case 1:
189                  serverScoreboard.removeScore( score.getItemName() );
190                  break;
191              default:
192                  throw new IllegalArgumentException( "Unknown scoreboard action: " + score.getAction() );
193          }
194      }
195      @Override
196      public void handle(ScoreboardDisplay displayScoreboard) throws Exception
197      {
198          Scoreboard serverScoreboard = con.getServerSentScoreboard();
199          serverScoreboard.setName( displayScoreboard.getName() );
200          serverScoreboard.setPosition( Position.values()[displayScoreboard.getPosition()] );
201      }
202      @Override
203      public void handle(net.md_5.bungee.protocol.packet.Team team) throws Exception
204      {
205          Scoreboard serverScoreboard = con.getServerSentScoreboard();
206          if ( team.getMode() == 1 )
207          {
208              serverScoreboard.removeTeam( team.getName() );
209              return;
210          }
211          Team t;
212          if ( team.getMode() == 0 )
213          {
214              t = new Team( team.getName() );
215              serverScoreboard.addTeam( t );
216          } else
217          {
218              t = serverScoreboard.getTeam( team.getName() );
219          }
220          if ( t != null )
221          {
222              if ( team.getMode() == 0 || team.getMode() == 2 )
223              {
224                  t.setDisplayName( team.getDisplayName() );
225                  t.setPrefix( team.getPrefix() );
226                  t.setSuffix( team.getSuffix() );
227                  t.setFriendlyFire( team.getFriendlyFire() );
228                  t.setNameTagVisibility( team.getNameTagVisibility() );
229                  t.setCollisionRule( team.getCollisionRule() );
230                  t.setColor( team.getColor() );
231              }
232              if ( team.getPlayers() != null )
233              {
234                  for ( String s : team.getPlayers() )
235                  {
236                      if ( team.getMode() == 0 || team.getMode() == 3 )
237                      {
238                          t.addPlayer( s );
239                      } else if ( team.getMode() == 4 )
240                      {
241                          t.removePlayer( s );
242                      }
243                  }
244              }
245          }
246      }
247      @Override
248      @SuppressWarnings("checkstyle:avoidnestedblocks")
249      public void handle(PluginMessage pluginMessage) throws Exception
250      {
251          DataInput in = pluginMessage.getStream();
252          PluginMessageEvent event = new PluginMessageEvent( server, con, pluginMessage.getTag(), pluginMessage.getData().clone() );
253          if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
254          {
255              throw CancelSendSignal.INSTANCE;
256          }
257          if ( pluginMessage.getTag().equals( con.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_13 ? "minecraft:brand" : "MC|Brand" ) )
258          {
259              ByteBuf brand = Unpooled.wrappedBuffer( pluginMessage.getData() );
260              String serverBrand = DefinedPacket.readString( brand );
261              brand.release();
262              Preconditions.checkState( !serverBrand.contains( bungee.getName() ), "Cannot connect proxy to itself!" );
263              brand = ByteBufAllocator.DEFAULT.heapBuffer();
264              DefinedPacket.writeString( bungee.getName() + " (" + bungee.getVersion() + ")" + " <- " + serverBrand, brand );
265              pluginMessage.setData( DefinedPacket.toArray( brand ) );
266              brand.release();
267              con.unsafe().sendPacket( pluginMessage );
268              throw CancelSendSignal.INSTANCE;
269          }
270          if ( pluginMessage.getTag().equals( "BungeeCord" ) )
271          {
272              ByteArrayDataOutput out = ByteStreams.newDataOutput();
273              String subChannel = in.readUTF();
274              switch ( subChannel )
275              {
276                  case "ForwardToPlayer":
277                  {
278                      ProxiedPlayer target = bungee.getPlayer( in.readUTF() );
279                      if ( target != null )
280                      {
281                          String channel = in.readUTF();
282                          short len = in.readShort();
283                          byte[] data = new byte[ len ];
284                          in.readFully( data );
285                          out.writeUTF( channel );
286                          out.writeShort( data.length );
287                          out.write( data );
288                          byte[] payload = out.toByteArray();
289                          target.getServer().sendData( "BungeeCord", payload );
290                      }
291                      out = null;
292                      break;
293                  }
294                  case "Forward":
295                  {
296                      String target = in.readUTF();
297                      String channel = in.readUTF();
298                      short len = in.readShort();
299                      byte[] data = new byte[ len ];
300                      in.readFully( data );
301                      out.writeUTF( channel );
302                      out.writeShort( data.length );
303                      out.write( data );
304                      byte[] payload = out.toByteArray();
305                      out = null;
306                      switch ( target )
307                      {
308                          case "ALL":
309                              for ( ServerInfo server : bungee.getServers().values() )
310                              {
311                                  if ( server != this.server.getInfo() )
312                                  {
313                                      server.sendData( "BungeeCord", payload );
314                                  }
315                              }
316                              break;
317                          case "ONLINE":
318                              for ( ServerInfo server : bungee.getServers().values() )
319                              {
320                                  if ( server != this.server.getInfo() )
321                                  {
322                                      server.sendData( "BungeeCord", payload, false );
323                                  }
324                              }
325                              break;
326                          default:
327                              ServerInfo server = bungee.getServerInfo( target );
328                              if ( server != null )
329                              {
330                                  server.sendData( "BungeeCord", payload );
331                              }
332                              break;
333                      }
334                      break;
335                  }
336                  case "Connect":
337                  {
338                      ServerInfo server = bungee.getServerInfo( in.readUTF() );
339                      if ( server != null )
340                      {
341                          con.connect( server, ServerConnectEvent.Reason.PLUGIN_MESSAGE );
342                      }
343                      break;
344                  }
345                  case "ConnectOther":
346                  {
347                      ProxiedPlayer player = bungee.getPlayer( in.readUTF() );
348                      if ( player != null )
349                      {
350                          ServerInfo server = bungee.getServerInfo( in.readUTF() );
351                          if ( server != null )
352                          {
353                              player.connect( server );
354                          }
355                      }
356                      break;
357                  }
358                  case "GetPlayerServer":
359                  {
360                      String name = in.readUTF();
361                      ProxiedPlayer player = bungee.getPlayer( name );
362                      out.writeUTF( "GetPlayerServer" );
363                      out.writeUTF( name );
364                      if ( player == null )
365                      {
366                          out.writeUTF( "" );
367                          break;
368                      }
369                      Server srv = player.getServer();
370                      if ( srv == null )
371                      {
372                          out.writeUTF( "" );
373                      } else
374                      {
375                          out.writeUTF( srv.getInfo().getName() );
376                      }
377                      break;
378                  }
379                  case "IP":
380                      out.writeUTF( "IP" );
381                      if ( con.getSocketAddress() instanceof InetSocketAddress )
382                      {
383                          out.writeUTF( con.getAddress().getHostString() );
384                          out.writeInt( con.getAddress().getPort() );
385                      } else
386                      {
387                          out.writeUTF( "unix:&bsol;&bsol;" + ( (DomainSocketAddress) con.getSocketAddress() ).path() );
388                          out.writeInt( 0 );
389                      }
390                      break;
391                  case "IPOther":
392                  {
393                      ProxiedPlayer player = bungee.getPlayer( in.readUTF() );
394                      if ( player != null )
395                      {
396                          out.writeUTF( "IPOther" );
397                          out.writeUTF( player.getName() );
398                          if ( player.getSocketAddress() instanceof InetSocketAddress )
399                          {
400                              InetSocketAddress address = (InetSocketAddress) player.getSocketAddress();
401                              out.writeUTF( address.getHostString() );
402                              out.writeInt( address.getPort() );
403                          } else
404                          {
405                              out.writeUTF( "unix:&bsol;&bsol;" + ( (DomainSocketAddress) player.getSocketAddress() ).path() );
406                              out.writeInt( 0 );
407                          }
408                      }
409                      break;
410                  }
411                  case "PlayerCount":
412                  {
413                      String target = in.readUTF();
414                      out.writeUTF( "PlayerCount" );
415                      if ( target.equals( "ALL" ) )
416                      {
417                          out.writeUTF( "ALL" );
418                          out.writeInt( bungee.getOnlineCount() );
419                      } else
420                      {
421                          ServerInfo server = bungee.getServerInfo( target );
422                          if ( server != null )
423                          {
424                              out.writeUTF( server.getName() );
425                              out.writeInt( server.getPlayers().size() );
426                          }
427                      }
428                      break;
429                  }
430                  case "PlayerList":
431                  {
432                      String target = in.readUTF();
433                      out.writeUTF( "PlayerList" );
434                      if ( target.equals( "ALL" ) )
435                      {
436                          out.writeUTF( "ALL" );
437                          out.writeUTF( Util.csv( bungee.getPlayers() ) );
438                      } else
439                      {
440                          ServerInfo server = bungee.getServerInfo( target );
441                          if ( server != null )
442                          {
443                              out.writeUTF( server.getName() );
444                              out.writeUTF( Util.csv( server.getPlayers() ) );
445                          }
446                      }
447                      break;
448                  }
449                  case "GetServers":
450                  {
451                      out.writeUTF( "GetServers" );
452                      out.writeUTF( Util.csv( bungee.getServers().keySet() ) );
453                      break;
454                  }
455                  case "Message":
456                  {
457                      String target = in.readUTF();
458                      String message = in.readUTF();
459                      if ( target.equals( "ALL" ) )
460                      {
461                          for ( ProxiedPlayer player : bungee.getPlayers() )
462                          {
463                              player.sendMessage( message );
464                          }
465                      } else
466                      {
467                          ProxiedPlayer player = bungee.getPlayer( target );
468                          if ( player != null )
469                          {
470                              player.sendMessage( message );
471                          }
472                      }
473                      break;
474                  }
475                  case "MessageRaw":
476                  {
477                      String target = in.readUTF();
478                      BaseComponent[] message = ComponentSerializer.parse( in.readUTF() );
479                      if ( target.equals( "ALL" ) )
480                      {
481                          for ( ProxiedPlayer player : bungee.getPlayers() )
482                          {
483                              player.sendMessage( message );
484                          }
485                      } else
486                      {
487                          ProxiedPlayer player = bungee.getPlayer( target );
488                          if ( player != null )
489                          {
490                              player.sendMessage( message );
491                          }
492                      }
493                      break;
494                  }
495                  case "GetServer":
496                  {
497                      out.writeUTF( "GetServer" );
498                      out.writeUTF( server.getInfo().getName() );
499                      break;
500                  }
501                  case "UUID":
502                  {
503                      out.writeUTF( "UUID" );
504                      out.writeUTF( con.getUUID() );
505                      break;
506                  }
507                  case "UUIDOther":
508                  {
509                      ProxiedPlayer player = bungee.getPlayer( in.readUTF() );
510                      if ( player != null )
511                      {
512                          out.writeUTF( "UUIDOther" );
513                          out.writeUTF( player.getName() );
514                          out.writeUTF( player.getUUID() );
515                      }
516                      break;
517                  }
518                  case "ServerIP":
519                  {
520                      ServerInfo info = bungee.getServerInfo( in.readUTF() );
521                      if ( info != null && !info.getAddress().isUnresolved() )
522                      {
523                          out.writeUTF( "ServerIP" );
524                          out.writeUTF( info.getName() );
525                          out.writeUTF( info.getAddress().getAddress().getHostAddress() );
526                          out.writeShort( info.getAddress().getPort() );
527                      }
528                      break;
529                  }
530                  case "KickPlayer":
531                  {
532                      ProxiedPlayer player = bungee.getPlayer( in.readUTF() );
533                      if ( player != null )
534                      {
535                          String kickReason = in.readUTF();
536                          player.disconnect( new TextComponent( kickReason ) );
537                      }
538                      break;
539                  }
540                  case "KickPlayerRaw":
541                  {
542                      ProxiedPlayer player = bungee.getPlayer( in.readUTF() );
543                      if ( player != null )
544                      {
545                          BaseComponent[] kickReason = ComponentSerializer.parse( in.readUTF() );
546                          player.disconnect( kickReason );
547                      }
548                      break;
549                  }
550              }
551              if ( out != null )
552              {
553                  byte[] b = out.toByteArray();
554                  if ( b.length != 0 )
555                  {
556                      server.sendData( "BungeeCord", b );
557                  }
558              }
559              throw CancelSendSignal.INSTANCE;
560          }
561      }
562      @Override
563      public void handle(Kick kick) throws Exception
564      {
565          ServerInfo def = con.updateAndGetNextServer( server.getInfo() );
566          ServerKickEvent event = bungee.getPluginManager().callEvent( new ServerKickEvent( con, server.getInfo(), ComponentSerializer.parse( kick.getMessage() ), def, ServerKickEvent.State.CONNECTED ) );
567          if ( event.isCancelled() && event.getCancelServer() != null )
568          {
569              con.connectNow( event.getCancelServer(), ServerConnectEvent.Reason.KICK_REDIRECT );
570          } else
571          {
572              con.disconnect0( event.getKickReasonComponent() ); 
573          }
574          server.setObsolete( true );
575          throw CancelSendSignal.INSTANCE;
576      }
577      @Override
578      public void handle(SetCompression setCompression) throws Exception
579      {
580          server.getCh().setCompressionThreshold( setCompression.getThreshold() );
581      }
582      @Override
583      public void handle(TabCompleteResponse tabCompleteResponse) throws Exception
584      {
585          List<String> commands = tabCompleteResponse.getCommands();
586          if ( commands == null )
587          {
588              commands = Lists.transform( tabCompleteResponse.getSuggestions().getList(), new Function<Suggestion, String>()
589              {
590                  @Override
591                  public String apply(Suggestion input)
592                  {
593                      return input.getText();
594                  }
595              } );
596          }
597          TabCompleteResponseEvent tabCompleteResponseEvent = new TabCompleteResponseEvent( server, con, new ArrayList<>( commands ) );
598          if ( !bungee.getPluginManager().callEvent( tabCompleteResponseEvent ).isCancelled() )
599          {
600              if ( !commands.equals( tabCompleteResponseEvent.getSuggestions() ) )
601              {
602                  if ( tabCompleteResponse.getCommands() != null )
603                  {
604                      tabCompleteResponse.setCommands( tabCompleteResponseEvent.getSuggestions() );
605                  } else
606                  {
607                      final StringRange range = tabCompleteResponse.getSuggestions().getRange();
608                      tabCompleteResponse.setSuggestions( new Suggestions( range, Lists.transform( tabCompleteResponseEvent.getSuggestions(), new Function<String, Suggestion>()
609                      {
610                          @Override
611                          public Suggestion apply(String input)
612                          {
613                              return new Suggestion( range, input );
614                          }
615                      } ) ) );
616                  }
617              }
618              con.unsafe().sendPacket( tabCompleteResponse );
619          }
620          throw CancelSendSignal.INSTANCE;
621      }
622      @Override
623      public void handle(BossBar bossBar)
624      {
625          switch ( bossBar.getAction() )
626          {
627              case 0:
628                  con.getSentBossBars().add( bossBar.getUuid() );
629                  break;
630              case 1:
631                  con.getSentBossBars().remove( bossBar.getUuid() );
632                  break;
633          }
634      }
635      @Override
636      public void handle(Respawn respawn)
637      {
638          con.setDimension( respawn.getDimension() );
639      }
640      @Override
641      public void handle(Commands commands) throws Exception
642      {
643          boolean modified = false;
644          for ( Map.Entry<String, Command> command : bungee.getPluginManager().getCommands() )
645          {
646              if ( !bungee.getDisabledCommands().contains( command.getKey() ) && commands.getRoot().getChild( command.getKey() ) == null && command.getValue().hasPermission( con ) )
647              {
648                  CommandNode dummy = LiteralArgumentBuilder.literal( command.getKey() ).executes( DUMMY_COMMAND )
649                          .then( RequiredArgumentBuilder.argument( "args", StringArgumentType.greedyString() )
650                                  .suggests( Commands.SuggestionRegistry.ASK_SERVER ).executes( DUMMY_COMMAND ) )
651                          .build();
652                  commands.getRoot().addChild( dummy );
653                  modified = true;
654              }
655          }
656          if ( modified )
657          {
658              con.unsafe().sendPacket( commands );
659              throw CancelSendSignal.INSTANCE;
660          }
661      }
662      @Override
663      public void handle(ServerData serverData) throws Exception
664      {
665          throw CancelSendSignal.INSTANCE;
666      }
667      @Override
668      public String toString()
669      {
670          return "[" + con.getName() + "] <-> DownstreamBridge <-> [" + server.getInfo().getName() + "]";
671      }
672  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-JDK14LoggerAdapter.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DownstreamBridge.java</div>
                </div>
                <div class="column column_space"><pre><code>259          }
260          LogRecord record = new LogRecord(julLevel, ft.getMessage());
261          record.setLoggerName(event.getLoggerName());
</pre></code></div>
                <div class="column column_space"><pre><code>107          }
108          ServerDisconnectEvent serverDisconnectEvent = new ServerDisconnectEvent( con, server.getInfo() );
109          bungee.getPluginManager().callEvent( serverDisconnectEvent );
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    