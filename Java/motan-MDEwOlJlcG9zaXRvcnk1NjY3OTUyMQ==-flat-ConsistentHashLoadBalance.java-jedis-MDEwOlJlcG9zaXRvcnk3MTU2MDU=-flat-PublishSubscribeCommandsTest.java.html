
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6178010471204187%, Tokens: 10</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ConsistentHashLoadBalance.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.cluster.loadbalance;
2  import java.util.ArrayList;
3  import java.util.Arrays;
4  import java.util.Collections;
5  import java.util.List;
6  import com.weibo.api.motan.common.MotanConstants;
7  import com.weibo.api.motan.core.extension.SpiMeta;
8  import com.weibo.api.motan.rpc.Referer;
9  import com.weibo.api.motan.rpc.Request;
10  import com.weibo.api.motan.util.MathUtil;
</span>11  @SpiMeta(name = "consistent")
12  public class ConsistentHashLoadBalance<T> extends AbstractLoadBalance<T> {
13      private List<Referer<T>> consistentHashReferers;
14      @Override
15      public void onRefresh(List<Referer<T>> referers) {
16          super.onRefresh(referers);
17          List<Referer<T>> copyReferers = new ArrayList<Referer<T>>(referers);
18          List<Referer<T>> tempRefers = new ArrayList<Referer<T>>();
19          for (int i = 0; i < MotanConstants.DEFAULT_CONSISTENT_HASH_BASE_LOOP; i++) {
20              Collections.shuffle(copyReferers);
21              for (Referer<T> ref : copyReferers) {
22                  tempRefers.add(ref);
23              }
24          }
25          consistentHashReferers = tempRefers;
26      }
27      @Override
28      protected Referer<T> doSelect(Request request) {
29          int hash = getHash(request);
30          Referer<T> ref;
31          for (int i = 0; i < getReferers().size(); i++) {
32              ref = consistentHashReferers.get((hash + i) % consistentHashReferers.size());
33              if (ref.isAvailable()) {
34                  return ref;
35              }
36          }
37          return null;
38      }
39      @Override
40      protected void doSelectToHolder(Request request, List<Referer<T>> refersHolder) {
41          List<Referer<T>> referers = getReferers();
42          int hash = getHash(request);
43          for (int i = 0; i < referers.size(); i++) {
44              Referer<T> ref = consistentHashReferers.get((hash + i) % consistentHashReferers.size());
45              if (ref.isAvailable()) {
46                  refersHolder.add(ref);
47              }
48          }
49      }
50      private int getHash(Request request) {
51          int hashcode;
52          if (request.getArguments() == null || request.getArguments().length == 0) {
53              hashcode = request.hashCode();
54          } else {
55              hashcode = Arrays.hashCode(request.getArguments());
56          }
57          return MathUtil.getNonNegative(hashcode);
58      }
59  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-PublishSubscribeCommandsTest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis.commands.jedis;
2  import static org.hamcrest.MatcherAssert.assertThat;
3  import static org.hamcrest.Matchers.hasItems;
4  import static org.junit.Assert.assertArrayEquals;
5  import static org.junit.Assert.assertEquals;
6  import static org.junit.Assert.fail;
7  import java.io.IOException;
8  import java.net.UnknownHostException;
9  import java.util.ArrayList;
10  import java.util.Collections;
</span>11  import java.util.HashMap;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.concurrent.CountDownLatch;
15  import java.util.concurrent.atomic.AtomicBoolean;
16  import org.junit.Test;
17  import redis.clients.jedis.BinaryJedisPubSub;
18  import redis.clients.jedis.Jedis;
19  import redis.clients.jedis.JedisPubSub;
20  import redis.clients.jedis.exceptions.JedisException;
21  import redis.clients.jedis.util.SafeEncoder;
22  public class PublishSubscribeCommandsTest extends JedisCommandsTestBase {
23    private void publishOne(final String channel, final String message) {
24      Thread t = new Thread(new Runnable() {
25        public void run() {
26          try {
27            Jedis j = createJedis();
28            j.publish(channel, message);
29            j.disconnect();
30          } catch (Exception ex) {
31          }
32        }
33      });
34      t.start();
35    }
36    @Test
37    public void subscribe() throws InterruptedException {
38      jedis.subscribe(new JedisPubSub() {
39        public void onMessage(String channel, String message) {
40          assertEquals("foo", channel);
41          assertEquals("exit", message);
42          unsubscribe();
43        }
44        public void onSubscribe(String channel, int subscribedChannels) {
45          assertEquals("foo", channel);
46          assertEquals(1, subscribedChannels);
47          publishOne("foo", "exit");
48        }
49        public void onUnsubscribe(String channel, int subscribedChannels) {
50          assertEquals("foo", channel);
51          assertEquals(0, subscribedChannels);
52        }
53      }, "foo");
54    }
55    @Test
56    public void pubSubChannels() {
57      jedis.subscribe(new JedisPubSub() {
58        private int count = 0;
59        @Override
60        public void onSubscribe(String channel, int subscribedChannels) {
61          count++;
62          if (count == 3) {
63            Jedis otherJedis = createJedis();
64            List<String> activeChannels = otherJedis.pubsubChannels();
65            assertThat(activeChannels, hasItems("testchan1", "testchan2", "testchan3"));
66            unsubscribe();
67          }
68        }
69      }, "testchan1", "testchan2", "testchan3");
70    }
71    @Test
72    public void pubSubChannelsWithPattern() {
73      jedis.subscribe(new JedisPubSub() {
74        private int count = 0;
75        @Override
76        public void onSubscribe(String channel, int subscribedChannels) {
77          count++;
78          if (count == 3) {
79            Jedis otherJedis = createJedis();
80            List<String> activeChannels = otherJedis.pubsubChannels("test*");
81            assertThat(activeChannels, hasItems("testchan1", "testchan2", "testchan3"));
82            unsubscribe();
83          }
84        }
85      }, "testchan1", "testchan2", "testchan3");
86    }
87    @Test
88    public void pubSubChannelWithPingPong() throws InterruptedException {
89      final CountDownLatch latchUnsubscribed = new CountDownLatch(1);
90      final CountDownLatch latchReceivedPong = new CountDownLatch(1);
91      jedis.subscribe(new JedisPubSub() {
92        @Override
93        public void onSubscribe(String channel, int subscribedChannels) {
94          publishOne("testchan1", "hello");
95        }
96        @Override
97        public void onMessage(String channel, String message) {
98          this.ping();
99        }
100        @Override
101        public void onPong(String pattern) {
102          latchReceivedPong.countDown();
103          unsubscribe();
104        }
105        @Override
106        public void onUnsubscribe(String channel, int subscribedChannels) {
107          latchUnsubscribed.countDown();
108        }
109      }, "testchan1");
110      assertEquals(0L, latchReceivedPong.getCount());
111      assertEquals(0L, latchUnsubscribed.getCount());
112    }
113    @Test
114    public void pubSubChannelWithPingPongWithArgument() throws InterruptedException {
115      final CountDownLatch latchUnsubscribed = new CountDownLatch(1);
116      final CountDownLatch latchReceivedPong = new CountDownLatch(1);
117      final List<String> pongPatterns = new ArrayList<>();
118      jedis.subscribe(new JedisPubSub() {
119        @Override
120        public void onSubscribe(String channel, int subscribedChannels) {
121          publishOne("testchan1", "hello");
122        }
123        @Override
124        public void onMessage(String channel, String message) {
125          this.ping("hi!");
126        }
127        @Override
128        public void onPong(String pattern) {
129          pongPatterns.add(pattern);
130          latchReceivedPong.countDown();
131          unsubscribe();
132        }
133        @Override
134        public void onUnsubscribe(String channel, int subscribedChannels) {
135          latchUnsubscribed.countDown();
136        }
137      }, "testchan1");
138      assertEquals(0L, latchReceivedPong.getCount());
139      assertEquals(0L, latchUnsubscribed.getCount());
140      assertEquals(Collections.singletonList("hi!"), pongPatterns);
141    }
142    @Test
143    public void pubSubNumPat() {
144      jedis.psubscribe(new JedisPubSub() {
145        private int count = 0;
146        @Override
147        public void onPSubscribe(String pattern, int subscribedChannels) {
148          count++;
149          if (count == 3) {
150            Jedis otherJedis = createJedis();
151            Long numPatterns = otherJedis.pubsubNumPat();
152            assertEquals(Long.valueOf(2l), numPatterns);
153            punsubscribe();
154          }
155        }
156      }, "test*", "test*", "chan*");
157    }
158    @Test
159    public void pubSubNumSub() {
160      final Map<String, Long> expectedNumSub = new HashMap<>();
161      expectedNumSub.put("testchannel2", 1L);
162      expectedNumSub.put("testchannel1", 1L);
163      jedis.subscribe(new JedisPubSub() {
164        private int count = 0;
165        @Override
166        public void onSubscribe(String channel, int subscribedChannels) {
167          count++;
168          if (count == 2) {
169            Jedis otherJedis = createJedis();
170            Map<String, Long> numSub = otherJedis.pubsubNumSub("testchannel1", "testchannel2");
171            assertEquals(expectedNumSub, numSub);
172            unsubscribe();
173          }
174        }
175      }, "testchannel1", "testchannel2");
176    }
177    @Test
178    public void subscribeMany() throws UnknownHostException, IOException, InterruptedException {
179      jedis.subscribe(new JedisPubSub() {
180        public void onMessage(String channel, String message) {
181          unsubscribe(channel);
182        }
183        public void onSubscribe(String channel, int subscribedChannels) {
184          publishOne(channel, "exit");
185        }
186      }, "foo", "bar");
187    }
188    @Test
189    public void psubscribe() throws UnknownHostException, IOException, InterruptedException {
190      jedis.psubscribe(new JedisPubSub() {
191        public void onPSubscribe(String pattern, int subscribedChannels) {
192          assertEquals("foo.*", pattern);
193          assertEquals(1, subscribedChannels);
194          publishOne("foo.bar", "exit");
195        }
196        public void onPUnsubscribe(String pattern, int subscribedChannels) {
197          assertEquals("foo.*", pattern);
198          assertEquals(0, subscribedChannels);
199        }
200        public void onPMessage(String pattern, String channel, String message) {
201          assertEquals("foo.*", pattern);
202          assertEquals("foo.bar", channel);
203          assertEquals("exit", message);
204          punsubscribe();
205        }
206      }, "foo.*");
207    }
208    @Test
209    public void psubscribeMany() throws UnknownHostException, IOException, InterruptedException {
210      jedis.psubscribe(new JedisPubSub() {
211        public void onPSubscribe(String pattern, int subscribedChannels) {
212          publishOne(pattern.replace("*", "123"), "exit");
213        }
214        public void onPMessage(String pattern, String channel, String message) {
215          punsubscribe(pattern);
216        }
217      }, "foo.*", "bar.*");
218    }
219    @Test
220    public void subscribeLazily() throws UnknownHostException, IOException, InterruptedException {
221      final JedisPubSub pubsub = new JedisPubSub() {
222        public void onMessage(String channel, String message) {
223          unsubscribe(channel);
224        }
225        public void onSubscribe(String channel, int subscribedChannels) {
226          publishOne(channel, "exit");
227          if (!channel.equals("bar")) {
228            this.subscribe("bar");
229            this.psubscribe("bar.*");
230          }
231        }
232        public void onPSubscribe(String pattern, int subscribedChannels) {
233          publishOne(pattern.replace("*", "123"), "exit");
234        }
235        public void onPMessage(String pattern, String channel, String message) {
236          punsubscribe(pattern);
237        }
238      };
239      jedis.subscribe(pubsub, "foo");
240    }
241    @Test
242    public void binarySubscribe() throws UnknownHostException, IOException, InterruptedException {
243      jedis.subscribe(new BinaryJedisPubSub() {
244        public void onMessage(byte[] channel, byte[] message) {
245          assertArrayEquals(SafeEncoder.encode("foo"), channel);
246          assertArrayEquals(SafeEncoder.encode("exit"), message);
247          unsubscribe();
248        }
249        public void onSubscribe(byte[] channel, int subscribedChannels) {
250          assertArrayEquals(SafeEncoder.encode("foo"), channel);
251          assertEquals(1, subscribedChannels);
252          publishOne(SafeEncoder.encode(channel), "exit");
253        }
254        public void onUnsubscribe(byte[] channel, int subscribedChannels) {
255          assertArrayEquals(SafeEncoder.encode("foo"), channel);
256          assertEquals(0, subscribedChannels);
257        }
258      }, SafeEncoder.encode("foo"));
259    }
260    @Test
261    public void binarySubscribeMany() throws UnknownHostException, IOException, InterruptedException {
262      jedis.subscribe(new BinaryJedisPubSub() {
263        public void onMessage(byte[] channel, byte[] message) {
264          unsubscribe(channel);
265        }
266        public void onSubscribe(byte[] channel, int subscribedChannels) {
267          publishOne(SafeEncoder.encode(channel), "exit");
268        }
269      }, SafeEncoder.encode("foo"), SafeEncoder.encode("bar"));
270    }
271    @Test
272    public void binaryPsubscribe() throws UnknownHostException, IOException, InterruptedException {
273      jedis.psubscribe(new BinaryJedisPubSub() {
274        public void onPSubscribe(byte[] pattern, int subscribedChannels) {
275          assertArrayEquals(SafeEncoder.encode("foo.*"), pattern);
276          assertEquals(1, subscribedChannels);
277          publishOne(SafeEncoder.encode(pattern).replace("*", "bar"), "exit");
278        }
279        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {
280          assertArrayEquals(SafeEncoder.encode("foo.*"), pattern);
281          assertEquals(0, subscribedChannels);
282        }
283        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {
284          assertArrayEquals(SafeEncoder.encode("foo.*"), pattern);
285          assertArrayEquals(SafeEncoder.encode("foo.bar"), channel);
286          assertArrayEquals(SafeEncoder.encode("exit"), message);
287          punsubscribe();
288        }
289      }, SafeEncoder.encode("foo.*"));
290    }
291    @Test
292    public void binaryPsubscribeMany() throws UnknownHostException, IOException, InterruptedException {
293      jedis.psubscribe(new BinaryJedisPubSub() {
294        public void onPSubscribe(byte[] pattern, int subscribedChannels) {
295          publishOne(SafeEncoder.encode(pattern).replace("*", "123"), "exit");
296        }
297        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {
298          punsubscribe(pattern);
299        }
300      }, SafeEncoder.encode("foo.*"), SafeEncoder.encode("bar.*"));
301    }
302    @Test
303    public void binaryPubSubChannelWithPingPong() throws InterruptedException {
304      final CountDownLatch latchUnsubscribed = new CountDownLatch(1);
305      final CountDownLatch latchReceivedPong = new CountDownLatch(1);
306      jedis.subscribe(new BinaryJedisPubSub() {
307        @Override
308        public void onSubscribe(byte[] channel, int subscribedChannels) {
309          publishOne("testchan1", "hello");
310        }
311        @Override
312        public void onMessage(byte[] channel, byte[] message) {
313          this.ping();
314        }
315        @Override
316        public void onPong(byte[] pattern) {
317          latchReceivedPong.countDown();
318          unsubscribe();
319        }
320        @Override
321        public void onUnsubscribe(byte[] channel, int subscribedChannels) {
322          latchUnsubscribed.countDown();
323        }
324      }, SafeEncoder.encode("testchan1"));
325      assertEquals(0L, latchReceivedPong.getCount());
326      assertEquals(0L, latchUnsubscribed.getCount());
327    }
328    @Test
329    public void binaryPubSubChannelWithPingPongWithArgument() throws InterruptedException {
330      final CountDownLatch latchUnsubscribed = new CountDownLatch(1);
331      final CountDownLatch latchReceivedPong = new CountDownLatch(1);
332      final List<byte[]> pongPatterns = new ArrayList<>();
333      final byte[] pingMessage = SafeEncoder.encode("hi!");
334      jedis.subscribe(new BinaryJedisPubSub() {
335        @Override
336        public void onSubscribe(byte[] channel, int subscribedChannels) {
337          publishOne("testchan1", "hello");
338        }
339        @Override
340        public void onMessage(byte[] channel, byte[] message) {
341          this.ping(pingMessage);
342        }
343        @Override
344        public void onPong(byte[] pattern) {
345          pongPatterns.add(pattern);
346          latchReceivedPong.countDown();
347          unsubscribe();
348        }
349        @Override
350        public void onUnsubscribe(byte[] channel, int subscribedChannels) {
351          latchUnsubscribed.countDown();
352        }
353      }, SafeEncoder.encode("testchan1"));
354      assertEquals(0L, latchReceivedPong.getCount());
355      assertEquals(0L, latchUnsubscribed.getCount());
356      assertArrayEquals(pingMessage, pongPatterns.get(0));
357    }
358    @Test
359    public void binarySubscribeLazily() throws UnknownHostException, IOException,
360        InterruptedException {
361      final BinaryJedisPubSub pubsub = new BinaryJedisPubSub() {
362        public void onMessage(byte[] channel, byte[] message) {
363          unsubscribe(channel);
364        }
365        public void onSubscribe(byte[] channel, int subscribedChannels) {
366          publishOne(SafeEncoder.encode(channel), "exit");
367          if (!SafeEncoder.encode(channel).equals("bar")) {
368            this.subscribe(SafeEncoder.encode("bar"));
369            this.psubscribe(SafeEncoder.encode("bar.*"));
370          }
371        }
372        public void onPSubscribe(byte[] pattern, int subscribedChannels) {
373          publishOne(SafeEncoder.encode(pattern).replace("*", "123"), "exit");
374        }
375        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {
376          punsubscribe(pattern);
377        }
378      };
379      jedis.subscribe(pubsub, SafeEncoder.encode("foo"));
380    }
381    @Test(expected = JedisException.class)
382    public void unsubscribeWhenNotSusbscribed() throws InterruptedException {
383      JedisPubSub pubsub = new JedisPubSub() {
384      };
385      pubsub.unsubscribe();
386    }
387    @Test(expected = JedisException.class)
388    public void handleClientOutputBufferLimitForSubscribeTooSlow() throws InterruptedException {
389      final Jedis j = createJedis();
390      final AtomicBoolean exit = new AtomicBoolean(false);
391      final Thread t = new Thread(new Runnable() {
392        public void run() {
393          try {
394            String veryLargeString = makeLargeString(10485760);
395            for (int i = 0; i < 10 && !exit.get(); i++) {
396              j.publish("foo", veryLargeString);
397            }
398            j.disconnect();
399          } catch (Exception ex) {
400          }
401        }
402      });
403      t.start();
404      try {
405        jedis.subscribe(new JedisPubSub() {
406          public void onMessage(String channel, String message) {
407            try {
408              Thread.sleep(100);
409            } catch (Exception e) {
410              try {
411                t.join();
412              } catch (InterruptedException e1) {
413              }
414              fail(e.getMessage());
415            }
416          }
417        }, "foo");
418      } finally {
419        exit.set(true);
420        if (t.isAlive()) {
421          t.join();
422        }
423      }
424    }
425    private String makeLargeString(int size) {
426      StringBuffer sb = new StringBuffer();
427      for (int i = 0; i < size; i++)
428        sb.append((char) ('a' + i % 26));
429      return sb.toString();
430    }
431  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ConsistentHashLoadBalance.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-PublishSubscribeCommandsTest.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.cluster.loadbalance;
2  import java.util.ArrayList;
3  import java.util.Arrays;
4  import java.util.Collections;
5  import java.util.List;
6  import com.weibo.api.motan.common.MotanConstants;
7  import com.weibo.api.motan.core.extension.SpiMeta;
8  import com.weibo.api.motan.rpc.Referer;
9  import com.weibo.api.motan.rpc.Request;
10  import com.weibo.api.motan.util.MathUtil;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis.commands.jedis;
2  import static org.hamcrest.MatcherAssert.assertThat;
3  import static org.hamcrest.Matchers.hasItems;
4  import static org.junit.Assert.assertArrayEquals;
5  import static org.junit.Assert.assertEquals;
6  import static org.junit.Assert.fail;
7  import java.io.IOException;
8  import java.net.UnknownHostException;
9  import java.util.ArrayList;
10  import java.util.Collections;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    