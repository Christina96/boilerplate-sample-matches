<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractBytesReferenceTestCase.java &amp; IndexShard.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractBytesReferenceTestCase.java &amp; IndexShard.java
      </h3>
<h1 align="center">
        10.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractBytesReferenceTestCase.java (23.773266%)<th>IndexShard.java (6.671415%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-49)<td><a href="#" name="0">(137-165)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(219-225)<td><a href="#" name="1">(1588-1598)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(55-60)<td><a href="#" name="2">(2232-2244)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(514-521)<td><a href="#" name="3">(1447-1455)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(292-297)<td><a href="#" name="4">(781-793)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(550-555)<td><a href="#" name="5">(2152-2163)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(187-196)<td><a href="#" name="6">(2396-2400)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(602-606)<td><a href="#" name="7">(1988-1992)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(379-384)<td><a href="#" name="8">(1520-1524)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(135-140)<td><a href="#" name="9">(1897-1901)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(101-107)<td><a href="#" name="10">(2302-2304)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(625-631)<td><a href="#" name="11">(1776-1787)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(616-620)<td><a href="#" name="12">(1613-1618)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(578-582)<td><a href="#" name="13">(1369-1383)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(574-578)<td><a href="#" name="14">(796-803)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(565-570)<td><a href="#" name="15">(277-279)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(542-545)<td><a href="#" name="16">(1020-1029)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(536-541)<td><a href="#" name="17">(2462-2465)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(484-491)<td><a href="#" name="18">(2895-2901)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(451-457)<td><a href="#" name="19">(2669-2673)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(309-314)<td><a href="#" name="20">(1484-1490)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(275-280)<td><a href="#" name="21">(1056-1070)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(270-275)<td><a href="#" name="22">(754-757)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(263-268)<td><a href="#" name="23">(770-778)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(238-246)<td><a href="#" name="24">(2135-2142)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(144-149)<td><a href="#" name="25">(1039-1048)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(114-123)<td><a href="#" name="26">(2483-2486)</a><td align="center"><font color="#5b0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractBytesReferenceTestCase.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.common.bytes;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.apache.lucene.util.BytesRef;
4 import org.apache.lucene.util.BytesRefBuilder;
5 import org.apache.lucene.util.BytesRefIterator;
6 import org.elasticsearch.common.breaker.CircuitBreaker;
7 import org.elasticsearch.common.io.stream.BytesStreamOutput;
8 import org.elasticsearch.common.io.stream.ReleasableBytesStreamOutput;
9 import org.elasticsearch.common.io.stream.StreamInput;
10 import org.elasticsearch.common.util.BigArrays;
11 import org.elasticsearch.common.util.ByteArray;
12 import org.elasticsearch.common.util.PageCacheRecycler;
13 import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
14 import org.elasticsearch.test.ESTestCase;
15 import java.io.EOFException;
16 import java.io.IOException;
17 import java.nio.ByteBuffer;
18 import java.nio.ByteOrder;
19 import java.nio.IntBuffer;
20 import java.util.ArrayList;
21 import java.util.Arrays;
22 import java.util.HashMap;
23 import java.util.List;
24 import java.util.Map;
25 public abstract class AbstractBytesReferenceTestCase extends ESTestCase {
26     protected static final int PAGE_SIZE = PageCacheRecycler.BYTE_PAGE_SIZE;
27     protected final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), CircuitBreaker.REQUEST)</b></font>;
28     public void testGet() throws IOException {
29 <a name="2"></a>        int length = randomIntBetween(1, PAGE_SIZE * 3);
30         BytesReference pbr = newBytesReference(length);
31         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int sliceOffset = randomIntBetween(0, length / 2);
32         int sliceLength = Math.max(1, length - sliceOffset - 1);
33         BytesReference slice = pbr.slice(sliceOffset, sliceLength);
34         assertEquals(pbr.get(sliceOffset), slice.get(0));
35         assertEquals(pbr.get(sliceOffset + sliceLength - 1), slice.get(sliceLength - 1));
36         final int probes = randomIntBetween(20, 100)</b></font>;
37         BytesReference copy = new BytesArray(pbr.toBytesRef(), true);
38         for (int i = 0; i &lt; probes; i++) {
39             int index = randomIntBetween(0, copy.length() - 1);
40             assertEquals(pbr.get(index), copy.get(index));
41             index = randomIntBetween(sliceOffset, sliceOffset + sliceLength - 1);
42             assertEquals(pbr.get(index), slice.get(index - sliceOffset));
43         }
44     }
45     public void testLength() throws IOException {
46         int[] sizes = {0, randomInt(PAGE_SIZE), PAGE_SIZE, randomInt(PAGE_SIZE * 3)};
47         for (int i = 0; i &lt; sizes.length; i++) {
48             BytesReference pbr = newBytesReference(sizes[i]);
49             assertEquals(sizes[i], pbr.length());
50         }
51     }
52     public void testSlice() throws IOException {
53         for (int length : new int[] {0, 1, randomIntBetween(2, PAGE_SIZE), randomIntBetween(PAGE_SIZE + 1, 3 * PAGE_SIZE)}) {
54             BytesReference pbr = newBytesReference(length);
55             int sliceOffset = randomIntBetween(0, length / 2);
56             int sliceLength = Math.max(0, length - sliceOffset - 1);
57             BytesReference slice = pbr.slice(sliceOffset, sliceLength);
58             assertEquals(sliceLength, slice.length());
59             for (int i = 0; i &lt; sliceLength; i++) {
60                 assertEquals(pbr.get(i+sliceOffset), slice.get(i));
61             }
62             BytesRef singlePageOrNull = getSinglePageOrNull(slice);
63             if (singlePageOrNull != null) {
64                 assertEquals(sliceLength, singlePageOrNull.length);
65             }
66         }
67     }
68 <a name="10"></a>    public void testStreamInput() throws IOException {
69         int length = randomIntBetween(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));
70         BytesReference pbr = newBytesReference(length);
71         StreamInput si = <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pbr.streamInput();
72         assertNotNull(si);
73         assertEquals(pbr.get(0), si.readByte());
74         assertEquals(pbr.get(1), si.readByte());
75         assertEquals(pbr.get</b></font>(2), si.readByte());
76         si.reset();
77 <a name="26"></a>
78         byte[] origBuf = new byte[length];
79         <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>random().nextBytes(origBuf);
80         byte[] targetBuf = Arrays.copyOf(origBuf, origBuf.length);
81         si.readBytes(targetBuf, 0, 0);
82         assertEquals(origBuf[0], targetBuf[0]);
83         si.reset();
84         int bytesToRead = randomIntBetween</b></font>(1, length / 2);
85         for (int i = 0; i &lt; bytesToRead; i++) {
86             int b = si.read();
87             assertEquals(pbr.get(i) &amp; 0xff, b);
88         }
89         si.reset();
90         si.readFully(targetBuf);
91 <a name="9"></a>        assertArrayEquals(BytesReference.toBytes(pbr), targetBuf);
92         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
93             si.readByte();
94             fail("expected EOF");
95         } catch (EOFException | IndexOutOfBoundsException eof) {
96         }</b></font>
97 <a name="25"></a>
98         si.reset();
99         <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>expectThrows(IndexOutOfBoundsException.class, () -&gt;
100             si.readBytes(targetBuf, 0, length * 2));
101     }
102     public void testStreamInputMarkAndReset() throws IOException {
103         int length = randomIntBetween(10, scaledRandomIntBetween</b></font>(PAGE_SIZE * 2, PAGE_SIZE * 20));
104         BytesReference pbr = newBytesReference(length);
105         StreamInput si = pbr.streamInput();
106         assertNotNull(si);
107         StreamInput wrap = StreamInput.wrap(BytesReference.toBytes(pbr));
108         while(wrap.available() &gt; 0) {
109             if (rarely()) {
110                 wrap.mark(Integer.MAX_VALUE);
111                 si.mark(Integer.MAX_VALUE);
112             } else if (rarely()) {
113                 wrap.reset();
114                 si.reset();
115             }
116             assertEquals(si.readByte(), wrap.readByte());
117             assertEquals(si.available(), wrap.available());
118         }
119     }
120     public void testStreamInputBulkReadWithOffset() throws IOException {
121         final int length = randomIntBetween(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));
122         BytesReference pbr = newBytesReference(length);
123         StreamInput si = pbr.streamInput();
124         assertNotNull(si);
125         int offset = randomIntBetween(1, length / 2);
126         for (int i = 0; i &lt; offset; i++) {
127             assertEquals(si.available(), length - i);
128             assertEquals(pbr.get(i), si.readByte());
129         }
130 <a name="6"></a>        byte[] pbrBytesWithOffset = Arrays.copyOfRange(BytesReference.toBytes(pbr), offset, length);
131         byte[] targetBytes = new byte[pbrBytesWithOffset.length];
132         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>random().nextBytes(targetBytes);
133         si.readFully(targetBytes);
134         assertArrayEquals(pbrBytesWithOffset, targetBytes);
135         assertEquals(si.available(), 0);
136     }
137     public void testRandomReads() throws IOException {
138         int length = randomIntBetween</b></font>(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));
139         BytesReference pbr = newBytesReference(length);
140         StreamInput streamInput = pbr.streamInput();
141         BytesRefBuilder target = new BytesRefBuilder();
142         while (target.length() &lt; pbr.length()) {
143             switch (randomIntBetween(0, 10)) {
144                 case 6:
145                 case 5:
146                     target.append(new BytesRef(new byte[]{streamInput.readByte()}));
147                     break;
148                 case 4:
149                 case 3:
150                     BytesRef bytesRef = streamInput.readBytesRef(scaledRandomIntBetween(1, pbr.length() - target.length()));
151                     target.append(bytesRef);
152                     break;
153                 default:
154                     byte[] buffer = new byte[scaledRandomIntBetween(1, pbr.length() - target.length())];
155                     int offset = scaledRandomIntBetween(0, buffer.length - 1);
156                     int read = streamInput.read(buffer, offset, buffer.length - offset);
157                     target.append(new BytesRef(buffer, offset, read));
158 <a name="1"></a>                    break;
159             }
160         }
161         assertEquals(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pbr.length(), target.length());
162         BytesRef targetBytes = target.get();
163         assertArrayEquals(BytesReference.toBytes(pbr), Arrays.copyOfRange(targetBytes.bytes, targetBytes.offset, targetBytes.length));
164     }
165     public void testSliceStreamInput() throws IOException {
166         int length = randomIntBetween</b></font>(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));
167         BytesReference pbr = newBytesReference(length);
168         int sliceOffset = randomIntBetween(1, length / 2);
169         int sliceLength = length - sliceOffset;
170         BytesReference slice = pbr.slice(sliceOffset, sliceLength);
171         StreamInput sliceInput = slice.streamInput();
172         assertEquals(sliceInput.available(), sliceLength);
173 <a name="24"></a>                assertEquals(slice.get(0), sliceInput.readByte());
174         assertEquals(slice.get(1), sliceInput.readByte());
175         <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(slice.get(2), sliceInput.readByte());
176         assertEquals(sliceInput.available(), sliceLength - 3);
177         sliceInput.reset();
178         assertEquals(sliceInput.available(), sliceLength);
179         byte[] sliceBytes = new byte[sliceLength]</b></font>;
180         sliceInput.readFully(sliceBytes);
181         assertEquals(sliceInput.available(), 0);
182         byte[] pbrSliceBytes = Arrays.copyOfRange(BytesReference.toBytes(pbr), sliceOffset, length);
183         assertArrayEquals(pbrSliceBytes, sliceBytes);
184         byte[] sliceToBytes = BytesReference.toBytes(slice);
185         assertEquals(sliceBytes.length, sliceToBytes.length);
186         assertArrayEquals(sliceBytes, sliceToBytes);
187         sliceInput.reset();
188 <a name="23"></a>        assertEquals(sliceInput.available(), sliceLength);
189         byte[] buffer = new byte[sliceLength + scaledRandomIntBetween(1, 100)];
190         int offset = scaledRandomIntBetween(0, Math.max(1, buffer.length - sliceLength - 1));
191         int read = <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sliceInput.read(buffer, offset, sliceLength / 2);
192         assertEquals(sliceInput.available(), sliceLength - read);
193         sliceInput.read(buffer, offset + read, sliceLength - read);
194         assertArrayEquals(sliceBytes, Arrays.copyOfRange(buffer, offset, offset + sliceLength));
195 <a name="22"></a>        assertEquals(sliceInput.available(), 0);
196     }</b></font>
197     public void testWriteToOutputStream() throws IOException <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
198         int length = randomIntBetween(10, PAGE_SIZE * 4);
199 <a name="21"></a>        BytesReference pbr = newBytesReference(length);
200         BytesStreamOutput out = new BytesStreamOutput();
201         pbr.writeTo(out);
202         assertEquals</b></font>(pbr.length(), <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>out.size());
203         assertArrayEquals(BytesReference.toBytes(pbr), BytesReference.toBytes(out.bytes()));
204         out.close();
205     }
206     public void testInp</b></font>utStreamSkip() throws IOException {
207         int length = randomIntBetween(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));
208         BytesReference pbr = newBytesReference(length);
209         final int iters = randomIntBetween(5, 50);
210         for (int i = 0; i &lt; iters; i++) {
211             try (StreamInput input = pbr.streamInput()) {
212                 final int offset = randomIntBetween(0, length-1);
213                 assertEquals(offset, input.skip(offset));
214                 assertEquals(pbr.get(offset), input.readByte());
215 <a name="4"></a>                if (offset == length - 1) {
216                     continue;                 }
217                 final int nextOffset = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>randomIntBetween(offset, length-2);
218                 assertEquals(nextOffset - offset, input.skip(nextOffset - offset));
219                 assertEquals(pbr.get(nextOffset+1), input.readByte());                 assertEquals(length - (nextOffset+2), input.skip(Long.MAX_VALUE));
220                 assertEquals(0, input.skip(randomIntBetween(0, Integer.MAX_VALUE)));
221             }</b></font>
222         }
223     }
224     public void testSliceWriteToOutputStream() throws IOException {
225         int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 5));
226         BytesReference pbr = newBytesReference(length);
227         int sliceOffset = randomIntBetween(1, length / 2);
228         int sliceLength = length - sliceOffset;
229 <a name="20"></a>        BytesReference slice = pbr.slice(sliceOffset, sliceLength);
230         BytesStreamOutput sliceOut = new BytesStreamOutput(sliceLength);
231         slice.writeTo(sliceOut);
232         assertEquals(slice.length(), <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sliceOut.size());
233         assertArrayEquals(BytesReference.toBytes(slice), BytesReference.toBytes(sliceOut.bytes()));
234         sliceOut.close();
235     }
236     public void</b></font> testToBytes() throws IOException {
237         int[] sizes = {0, randomInt(PAGE_SIZE), PAGE_SIZE, randomIntBetween(2, PAGE_SIZE * randomIntBetween(2, 5))};
238         for (int i = 0; i &lt; sizes.length; i++) {
239             BytesReference pbr = newBytesReference(sizes[i]);
240             byte[] bytes = BytesReference.toBytes(pbr);
241             assertEquals(sizes[i], bytes.length);
242             for (int j = 0; j  &lt; bytes.length; j++) {
243                 assertEquals(bytes[j], pbr.get(j));
244             }
245         }
246     }
247     public void testToBytesRefSharedPage() throws IOException {
248         int length = randomIntBetween(10, PAGE_SIZE);
249         BytesReference pbr = newBytesReference(length);
250         BytesArray ba = new BytesArray(pbr.toBytesRef());
251         BytesArray ba2 = new BytesArray(pbr.toBytesRef());
252         assertNotNull(ba);
253         assertNotNull(ba2);
254         assertEquals(pbr.length(), ba.length());
255         assertEquals(ba.length(), ba2.length());
256         assertSame(ba.array(), ba2.array());
257     }
258     public void testToBytesRefMaterializedPages() throws IOException {
259         int length = 0;
260         while ((length % PAGE_SIZE) == 0) {
261             length = randomIntBetween(PAGE_SIZE, PAGE_SIZE * randomIntBetween(2, 5));
262         }
263         BytesReference pbr = newBytesReference(length);
264         BytesArray ba = new BytesArray(pbr.toBytesRef());
265         BytesArray ba2 = new BytesArray(pbr.toBytesRef());
266         assertNotNull(ba);
267         assertNotNull(ba2);
268         assertEquals(pbr.length(), ba.length());
269         assertEquals(ba.length(), ba2.length());
270     }
271     public void testCopyBytesRefSharesBytes() throws IOException {
272         int length = randomIntBetween(10, PAGE_SIZE);
273         BytesReference pbr = newBytesReference(length);
274         BytesArray ba = new BytesArray(pbr.toBytesRef(), true);
275         BytesArray ba2 = new BytesArray(pbr.toBytesRef(), true);
276         assertNotNull(ba);
277         assertNotSame(ba, ba2);
278         assertNotSame(ba.array(), ba2.array());
279     }
280     public void testSliceCopyBytesRef() throws IOException {
281         int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
282         BytesReference pbr = newBytesReference(length);
283         int sliceOffset = randomIntBetween(0, pbr.length());
284         int sliceLength = randomIntBetween(0, pbr.length() - sliceOffset);
285         BytesReference slice = pbr.slice(sliceOffset, sliceLength);
286         BytesArray ba1 = new BytesArray(slice.toBytesRef(), true);
287         BytesArray ba2 = new BytesArray(slice.toBytesRef(), true);
288         assertNotNull(ba1);
289         assertNotNull(ba2);
290 <a name="8"></a>        assertNotSame(ba1.array(), ba2.array());
291         assertArrayEquals(BytesReference.toBytes(slice), ba1.array());
292         assertArrayEquals(BytesReference.toBytes(slice), ba2.array());
293         assertArrayEquals(<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ba1.array(), ba2.array());
294     }
295     public void testEmptyToBytesRefIterator() throws IOException {
296         BytesReference pbr = newBytesReference(0);
297         assertNull(pbr.iterator().next</b></font>());
298     }
299     public void testIterator() throws IOException {
300         int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
301         BytesReference pbr = newBytesReference(length);
302         BytesRefIterator iterator = pbr.iterator();
303         BytesRef ref;
304         BytesRefBuilder builder = new BytesRefBuilder();
305         while((ref = iterator.next()) != null) {
306             builder.append(ref);
307         }
308         assertArrayEquals(BytesReference.toBytes(pbr), BytesRef.deepCopyOf(builder.toBytesRef()).bytes);
309     }
310     public void testSliceIterator() throws IOException {
311         int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
312         BytesReference pbr = newBytesReference(length);
313         int sliceOffset = randomIntBetween(0, pbr.length());
314         int sliceLength = randomIntBetween(0, pbr.length() - sliceOffset);
315         BytesReference slice = pbr.slice(sliceOffset, sliceLength);
316         BytesRefIterator iterator = slice.iterator();
317         BytesRef ref = null;
318         BytesRefBuilder builder = new BytesRefBuilder();
319         while((ref = iterator.next()) != null) {
320             builder.append(ref);
321         }
322         assertArrayEquals(BytesReference.toBytes(slice), BytesRef.deepCopyOf(builder.toBytesRef()).bytes);
323     }
324     public void testIteratorRandom() throws IOException {
325         int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
326         BytesReference pbr = newBytesReference(length);
327         if (randomBoolean()) {
328             int sliceOffset = randomIntBetween(0, pbr.length());
329             int sliceLength = randomIntBetween(0, pbr.length() - sliceOffset);
330             pbr = pbr.slice(sliceOffset, sliceLength);
331         }
332         if (randomBoolean()) {
333             pbr = new BytesArray(pbr.toBytesRef());
334         }
335         BytesRefIterator iterator = pbr.iterator();
336         BytesRef ref = null;
337         BytesRefBuilder builder = new BytesRefBuilder();
338         while((ref = iterator.next()) != null) {
339             builder.append(ref);
340         }
341         assertArrayEquals(BytesReference.toBytes(pbr), BytesRef.deepCopyOf(builder.toBytesRef()).bytes);
342     }
343     public void testArrayOffset() throws IOException {
344         int length = randomInt(PAGE_SIZE * randomIntBetween(2, 5));
345         BytesReference pbr = newBytesReference(length);
346         BytesRef singlePageOrNull = getSinglePageOrNull(pbr);
347         if (singlePageOrNull != null) {
348             assertEquals(0, singlePageOrNull.offset);
349         }
350     }
351     public void testSliceArrayOffset() throws IOException {
352         int length = randomIntBetween(1, PAGE_SIZE * randomIntBetween(2, 5));
353         BytesReference pbr = newBytesReferenceWithOffsetOfZero(length);
354         int sliceOffset = randomIntBetween(0, pbr.length() - 1); <a name="19"></a>        int sliceLength = randomIntBetween(1, pbr.length() - sliceOffset);
355         BytesReference slice = pbr.slice(sliceOffset, sliceLength);
356         BytesRef singlePageOrNull = getSinglePageOrNull(slice);
357         if (singlePageOrNull != null) <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
358             if (getSinglePageOrNull(pbr) == null) {
359                 assertEquals(sliceOffset % PAGE_SIZE, singlePageOrNull.offset);
360             } else {
361                 assertEquals</b></font>(sliceOffset, singlePageOrNull.offset);
362             }
363         }
364     }
365     public void testToUtf8() throws IOException {
366         BytesReference pbr = newBytesReference(0);
367         assertEquals("", pbr.utf8ToString());
368     }
369     public void testToBytesRef() throws IOException {
370         int length = randomIntBetween(0, PAGE_SIZE);
371         BytesReference pbr = newBytesReference(length);
372         BytesRef ref = pbr.toBytesRef();
373         assertNotNull(ref);
374         assertEquals(pbr.length(), ref.length);
375     }
376     public void testSliceToBytesRef() throws IOException {
377         int length = randomIntBetween(0, PAGE_SIZE);
378         BytesReference pbr = newBytesReferenceWithOffsetOfZero(length);
379 <a name="18"></a>        int sliceOffset = randomIntBetween(0, pbr.length());
380         int sliceLength = randomIntBetween(0, pbr.length() - sliceOffset);
381         BytesRef sliceRef = <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pbr.slice(sliceOffset, sliceLength).toBytesRef();
382         if (sliceLength == 0 &amp;&amp; sliceOffset != sliceRef.offset) {
383             assertEquals(0, sliceRef.offset);
384         } else {
385             assertEquals</b></font>(sliceOffset, sliceRef.offset);
386         }
387         assertEquals(sliceLength, sliceRef.length);
388     }
389     public void testHashCode() throws IOException {
390         BytesReference pbr = newBytesReference(0);
391         assertEquals(Arrays.hashCode(BytesRef.EMPTY_BYTES), pbr.hashCode());
392         pbr = newBytesReference(randomIntBetween(0, PAGE_SIZE * randomIntBetween(2, 5)));
393         int jdkHash = Arrays.hashCode(BytesReference.toBytes(pbr));
394         int pbrHash = pbr.hashCode();
395         assertEquals(jdkHash, pbrHash);
396         int sliceFrom = randomIntBetween(0, pbr.length());
397         int sliceLength = randomIntBetween(0, pbr.length() - sliceFrom);
398         BytesReference slice = pbr.slice(sliceFrom, sliceLength);
399 <a name="3"></a>        int sliceJdkHash = Arrays.hashCode(BytesReference.toBytes(slice));
400         int sliceHash = slice.hashCode();
401         assertEquals(sliceJdkHash, sliceHash);
402     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
403     public void testEquals() throws IOException {
404         BytesReference bytesReference = newBytesReference(randomIntBetween(100, PAGE_SIZE * randomIntBetween(2, 5)));
405         BytesReference copy = bytesReference.slice(0, bytesReference.length());
406         assertEquals</b></font>(copy, bytesReference);
407         int sliceFrom = randomIntBetween(0, bytesReference.length());
408         int sliceLength = randomIntBetween(0, bytesReference.length() - sliceFrom);
409         assertEquals(copy.slice(sliceFrom, sliceLength), bytesReference.slice(sliceFrom, sliceLength));
410         BytesRef bytesRef = BytesRef.deepCopyOf(copy.toBytesRef());
411         assertEquals(new BytesArray(bytesRef), copy);
412         int offsetToFlip = randomIntBetween(0, bytesRef.length - 1);
413         int value = ~Byte.toUnsignedInt(bytesRef.bytes[bytesRef.offset+offsetToFlip]);
414         bytesRef.bytes[bytesRef.offset+offsetToFlip] = (byte)value;
415         assertNotEquals(new BytesArray(bytesRef), copy);
416 <a name="17"></a>    }
417     public void testSliceEquals() {
418         <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int length = randomIntBetween(100, PAGE_SIZE * randomIntBetween(2, 5));
419         ByteArray ba1 = bigarrays.newByteArray(length, false);
420         BytesReference pbr = new PagedBytesReference(ba1, length);
421 <a name="16"></a>
422         int sliceFrom = randomIntBetween</b></font>(0, pbr.length());
423         int sliceLength = <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>randomIntBetween(0, pbr.length() - sliceFrom);
424         BytesReference slice1 = pbr.slice(sliceFrom, sliceLength);
425         BytesReference slice2 = pbr.slice(sliceFrom, sliceLength);
426         assertArrayEquals(BytesReference.toBytes(slice1), BytesReference.toBytes</b></font>(slice2));
427 <a name="5"></a>                if (sliceLength &gt; 0) {
428             BytesReference slice3 = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pbr.slice(sliceFrom, sliceLength / 2);
429             assertFalse(Arrays.equals(BytesReference.toBytes(slice1), BytesReference.toBytes(slice3)));
430         }
431     }
432     protected abstract BytesReference newBytesReference(int length</b></font>) throws IOException;
433     protected abstract BytesReference newBytesReferenceWithOffsetOfZero(int length) throws IOException;
434     public void testCompareTo() throws IOException {
435         final int iters = randomIntBetween(5, 10);
436         for (int i = 0; i &lt; iters; i++) {
437 <a name="15"></a>            int length = randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
438             BytesReference bytesReference = newBytesReference(length);
439             assertTrue(bytesReference.compareTo(new BytesArray("")) &gt; 0);
440             assertTrue(<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new BytesArray("").compareTo(bytesReference) &lt; 0);
441             assertEquals(0, bytesReference.compareTo(bytesReference));
442             int sliceFrom = randomIntBetween(0, bytesReference.length());
443             int sliceLength = randomIntBetween(0, bytesReference.length</b></font>() - sliceFrom);
444 <a name="14"></a>            BytesReference slice = bytesReference.slice(sliceFrom, sliceLength);
445             assertEquals(bytesReference.toBytesRef().compareTo(slice.toBytesRef()),
446                 new BytesArray(<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>bytesReference.toBytesRef(), true).compareTo(new BytesArray(slice.toBytesRef(), true)));
447 <a name="13"></a>
448             assertEquals(bytesReference.toBytesRef().compareTo(slice.toBytesRef()),
449                 bytesReference.compareTo(slice));
450             assertEquals</b></font>(<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>slice.toBytesRef().compareTo(bytesReference.toBytesRef()),
451                 slice.compareTo(bytesReference));
452             assertEquals(0, slice.compareTo(new BytesArray(slice.toBytesRef())));
453             assertEquals(0, new BytesArray(slice.toBytesRef()).compareTo</b></font>(slice));
454             final int crazyLength = length + randomIntBetween(10, PAGE_SIZE * randomIntBetween(2, 8));
455             ReleasableBytesStreamOutput crazyStream = new ReleasableBytesStreamOutput(length, bigarrays);
456             final int offset = randomIntBetween(0, crazyLength - length);
457             for (int j = 0; j &lt; offset; j++) {
458                 crazyStream.writeByte((byte) random().nextInt(1 &lt;&lt; 8));
459             }
460             bytesReference.writeTo(crazyStream);
461             for (int j = crazyStream.size(); j &lt; crazyLength; j++) {
462                 crazyStream.writeByte((byte) random().nextInt(1 &lt;&lt; 8));
463             }
464             BytesReference crazyReference = crazyStream.bytes();
465             assertFalse(crazyReference.compareTo(bytesReference) == 0);
466             assertEquals(0, crazyReference.slice(offset, length).compareTo(
467                 bytesReference));
468 <a name="7"></a>            assertEquals(0, bytesReference.compareTo(
469                 crazyReference.slice(offset, length)));
470         }
471     <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
472     public static BytesRef getSinglePageOrNull(BytesReference ref) throws IOException {
473         if (ref.length() &gt; 0) {
474             BytesRefIterator iterator = ref.iterator</b></font>();
475             BytesRef next = iterator.next();
476             BytesRef retVal = next.clone();
477             if (iterator.next() == null) {
478                 return retVal;
479             }
480         } else {
481 <a name="12"></a>            return new BytesRef();
482         }
483         return null;
484     <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
485     public static int getNumPages(BytesReference ref) throws IOException {
486         int num = 0;
487         if (ref.length() &gt; 0) {</b></font>
488             BytesRefIterator iterator = ref.iterator();
489 <a name="11"></a>            while(iterator.next() != null) {
490                 num++;
491             }
492         <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
493         return num;
494     }
495     public void testBasicEquals() {
496         final int len = randomIntBetween</b></font>(0, randomBoolean() ? 10: 100000);
497         final int offset1 = randomInt(5);
498         final byte[] array1 = new byte[offset1 + len + randomInt(5)];
499         random().nextBytes(array1);
500         final int offset2 = randomInt(offset1);
501         final byte[] array2 = Arrays.copyOfRange(array1, offset1 - offset2, array1.length);
502         final BytesArray b1 = new BytesArray(array1, offset1, len);
503         final BytesArray b2 = new BytesArray(array2, offset2, len);
504         assertEquals(b1, b2);
505         assertEquals(Arrays.hashCode(BytesReference.toBytes(b1)), b1.hashCode());
506         assertEquals(Arrays.hashCode(BytesReference.toBytes(b2)), b2.hashCode());
507         assertEquals(b1, b1);
508         assertEquals(b2, b2);
509         if (len &gt; 0) {
510             BytesArray differentLen = new BytesArray(array1, offset1, randomInt(len - 1));
511             assertNotEquals(b1, differentLen);
512             array1[offset1 + randomInt(len - 1)] += 13;
513             assertNotEquals(b1, b2);
514         }
515     }
516     public void testGetInt() throws IOException {
517         final int count = randomIntBetween(1, 10);
518         final BytesReference bytesReference = newBytesReference(count * Integer.BYTES);
519         final BytesRef bytesRef = bytesReference.toBytesRef();
520         final IntBuffer intBuffer =
521             ByteBuffer.wrap(bytesRef.bytes, bytesRef.offset, bytesRef.length).order(ByteOrder.BIG_ENDIAN).asIntBuffer();
522         for (int i = 0; i &lt; count; ++i) {
523             assertEquals(intBuffer.get(i), bytesReference.getInt(i * Integer.BYTES));
524         }
525     }
526     public void testIndexOf() throws IOException {
527         final int size = randomIntBetween(0, 100);
528         final BytesReference bytesReference = newBytesReference(size);
529         final Map&lt;Byte, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
530         for (int i = 0; i &lt; size; ++i) {
531             final byte value = bytesReference.get(i);
532             map.computeIfAbsent(value, v -&gt; new ArrayList&lt;&gt;()).add(i);
533         }
534         map.forEach((value, positions) -&gt; {
535             for (int i = 0; i &lt; positions.size(); i++) {
536                 final int pos = positions.get(i);
537                 final int from = i == 0 ? randomIntBetween(0, pos) : positions.get(i - 1) + 1;
538                 assertEquals(bytesReference.indexOf(value, from), pos);
539             }
540         });
541         final byte missing = randomValueOtherThanMany(map::containsKey, ESTestCase::randomByte);
542         assertEquals(-1, bytesReference.indexOf(missing, randomIntBetween(0, Math.max(0, size - 1))));
543     }
544 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IndexShard.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.index.shard;
2 import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_SEQ_NO;
3 import java.io.Closeable;
4 import java.io.IOException;
5 import java.io.PrintStream;
6 import java.nio.channels.ClosedByInterruptException;
7 import java.nio.charset.StandardCharsets;
8 import java.util.ArrayList;
9 import java.util.Collections;
10 import java.util.EnumSet;
11 import java.util.HashSet;
12 import java.util.List;
13 import java.util.Locale;
14 import java.util.Map;
15 import java.util.Objects;
16 import java.util.Optional;
17 import java.util.Set;
18 import java.util.concurrent.CopyOnWriteArrayList;
19 import java.util.concurrent.CountDownLatch;
20 import java.util.concurrent.TimeUnit;
21 import java.util.concurrent.TimeoutException;
22 import java.util.concurrent.atomic.AtomicBoolean;
23 import java.util.concurrent.atomic.AtomicLong;
24 import java.util.concurrent.atomic.AtomicReference;
25 import java.util.function.BiConsumer;
26 import java.util.function.Consumer;
27 import java.util.function.Function;
28 import java.util.function.LongSupplier;
29 import java.util.stream.Collectors;
30 import java.util.stream.StreamSupport;
31 import javax.annotation.Nullable;
32 import com.carrotsearch.hppc.ObjectLongMap;
33 import org.apache.logging.log4j.Logger;
34 import org.apache.logging.log4j.message.ParameterizedMessage;
35 import org.apache.lucene.index.CheckIndex;
36 import org.apache.lucene.index.IndexCommit;
37 import org.apache.lucene.index.SegmentInfos;
38 import org.apache.lucene.index.Term;
39 import org.apache.lucene.search.Query;
40 import org.apache.lucene.search.QueryCachingPolicy;
41 import org.apache.lucene.search.ReferenceManager;
42 import org.apache.lucene.search.UsageTrackingQueryCachingPolicy;
43 import org.apache.lucene.store.AlreadyClosedException;
44 import org.apache.lucene.util.SetOnce;
45 import org.apache.lucene.util.ThreadInterruptedException;
46 import org.elasticsearch.Assertions;
47 import org.elasticsearch.ElasticsearchException;
48 import org.elasticsearch.ExceptionsHelper;
49 import org.elasticsearch.Version;
50 import org.elasticsearch.action.ActionListener;
51 import org.elasticsearch.action.ActionRunnable;
52 import org.elasticsearch.action.admin.indices.flush.FlushRequest;
53 import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;
54 import org.elasticsearch.action.admin.indices.upgrade.post.UpgradeRequest;
55 import org.elasticsearch.action.support.replication.ReplicationResponse;
56 import org.elasticsearch.cluster.metadata.IndexMetadata;
57 import org.elasticsearch.cluster.metadata.MappingMetadata;
58 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
59 import org.elasticsearch.cluster.routing.RecoverySource;
60 import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;
61 import org.elasticsearch.cluster.routing.ShardRouting;
62 import org.elasticsearch.common.CheckedConsumer;
63 import org.elasticsearch.common.CheckedRunnable;
64 import org.elasticsearch.common.io.stream.BytesStreamOutput;
65 import org.elasticsearch.common.lease.Releasable;
66 import org.elasticsearch.common.lucene.Lucene;
67 import org.elasticsearch.common.metrics.CounterMetric;
68 import org.elasticsearch.common.metrics.MeanMetric;
69 import org.elasticsearch.common.settings.Settings;
70 import org.elasticsearch.common.unit.ByteSizeValue;
71 import org.elasticsearch.common.util.BigArrays;
72 import org.elasticsearch.common.util.concurrent.AbstractRunnable;
73 import org.elasticsearch.common.util.concurrent.AsyncIOProcessor;
74 import org.elasticsearch.common.util.concurrent.RunOnce;
75 import org.elasticsearch.common.xcontent.XContentHelper;
76 import org.elasticsearch.gateway.WriteStateException;
77 import org.elasticsearch.index.Index;
78 import org.elasticsearch.index.IndexModule;
79 import org.elasticsearch.index.IndexNotFoundException;
80 import org.elasticsearch.index.IndexService;
81 import org.elasticsearch.index.IndexSettings;
82 import org.elasticsearch.index.VersionType;
83 import org.elasticsearch.index.cache.IndexCache;
84 import org.elasticsearch.index.codec.CodecService;
85 import org.elasticsearch.index.engine.CommitStats;
86 import org.elasticsearch.index.engine.Engine;
87 import org.elasticsearch.index.engine.EngineConfig;
88 import org.elasticsearch.index.engine.EngineException;
89 import org.elasticsearch.index.engine.EngineFactory;
90 import org.elasticsearch.index.engine.ReadOnlyEngine;
91 import org.elasticsearch.index.engine.RefreshFailedEngineException;
92 import org.elasticsearch.index.engine.SafeCommitInfo;
93 import org.elasticsearch.index.engine.Segment;
94 import org.elasticsearch.index.mapper.DocumentMapper;
95 import org.elasticsearch.index.mapper.IdFieldMapper;
96 import org.elasticsearch.index.mapper.MapperService;
97 import org.elasticsearch.index.mapper.Mapping;
98 import org.elasticsearch.index.mapper.ParsedDocument;
99 import org.elasticsearch.index.mapper.RootObjectMapper;
100 import org.elasticsearch.index.mapper.SourceToParse;
101 import org.elasticsearch.index.mapper.Uid;
102 import org.elasticsearch.index.recovery.RecoveryStats;
103 import org.elasticsearch.index.seqno.ReplicationTracker;
104 import org.elasticsearch.index.seqno.RetentionLease;
105 import org.elasticsearch.index.seqno.RetentionLeaseStats;
106 import org.elasticsearch.index.seqno.RetentionLeaseSyncer;
107 import org.elasticsearch.index.seqno.RetentionLeases;
108 import org.elasticsearch.index.seqno.SeqNoStats;
109 import org.elasticsearch.index.seqno.SequenceNumbers;
110 <a name="0"></a>import org.elasticsearch.index.shard.PrimaryReplicaSyncer.ResyncTask;
111 import org.elasticsearch.index.store.Store;
112 import org.elasticsearch.index.store.Store.MetadataSnapshot;
113 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.index.store.StoreFileMetadata;
114 import org.elasticsearch.index.store.StoreStats;
115 import org.elasticsearch.index.translog.Translog;
116 import org.elasticsearch.index.translog.TranslogConfig;
117 import org.elasticsearch.index.translog.TranslogStats;
118 import org.elasticsearch.indices.IndexingMemoryController;
119 import org.elasticsearch.indices.IndicesService;
120 import org.elasticsearch.indices.breaker.CircuitBreakerService;
121 import org.elasticsearch.indices.cluster.IndicesClusterStateService;
122 import org.elasticsearch.indices.recovery.PeerRecoveryTargetService;
123 import org.elasticsearch.indices.recovery.RecoveryFailedException;
124 import org.elasticsearch.indices.recovery.RecoveryState;
125 import org.elasticsearch.indices.recovery.RecoveryTarget;
126 import org.elasticsearch.repositories.RepositoriesService;
127 import org.elasticsearch.repositories.Repository;
128 import org.elasticsearch.rest.RestStatus;
129 import org.elasticsearch.threadpool.ThreadPool;
130 import io.crate.common.Booleans;
131 import io.crate.common.collections.Tuple;
132 import io.crate.common.io.IOUtils;
133 import io.crate.common.unit.TimeValue;
134 import io.crate.exceptions.Exceptions;
135 public class IndexShard extends AbstractIndexShardComponent implements IndicesClusterStateService.Shard {
136     public static final long RETAIN_ALL = -1;
137     private final ThreadPool threadPool</b></font>;
138     private final MapperService mapperService;
139     private final IndexCache indexCache;
140     private final Store store;
141     private final Object mutex = new Object();
142     private final String checkIndexOnStartup;
143     private final CodecService codecService;
144     private final TranslogConfig translogConfig;
145     private final IndexEventListener indexEventListener;
146     private final QueryCachingPolicy cachingPolicy;
147     final CircuitBreakerService circuitBreakerService;
148     private final GlobalCheckpointListeners globalCheckpointListeners;
149     private final ReplicationTracker replicationTracker;
150     protected volatile ShardRouting shardRouting;
151     protected volatile IndexShardState state;
152     private final Object postRecoveryMutex = new Object();
153     protected volatile long pendingPrimaryTerm;     private final Object engineMutex = new Object();     private final AtomicReference&lt;Engine&gt; currentEngineReference = new AtomicReference&lt;&gt;();
154     final EngineFactory engineFactory;
155     private final IndexingOperationListener indexingOperationListeners;
156     private final Runnable globalCheckpointSyncer;
157     private final RetentionLeaseSyncer retentionLeaseSyncer;
158     Runnable getGlobalCheckpointSyncer() {
159         return globalCheckpointSyncer;
160     }
161     public RetentionLeaseSyncer getRetentionLeaseSyncer() {
162         return retentionLeaseSyncer;
163     }
164     @Nullable
165     private volatile RecoveryState recoveryState;
166     private final RecoveryStats recoveryStats = new RecoveryStats();
167     private final MeanMetric refreshMetric = new MeanMetric();
168     private final MeanMetric flushMetric = new MeanMetric();
169     private final CounterMetric periodicFlushMetric = new CounterMetric();
170     private final ShardEventListener shardEventListener = new ShardEventListener();
171     private final ShardPath path;
172     private final IndexShardOperationPermits indexShardOperationPermits;
173     private static final EnumSet&lt;IndexShardState&gt; READ_ALLOWED_STATES = EnumSet.of(IndexShardState.STARTED, IndexShardState.POST_RECOVERY);
174     private static final EnumSet&lt;IndexShardState&gt; WRITE_ALLOWED_STATES = EnumSet.of(IndexShardState.RECOVERING, IndexShardState.POST_RECOVERY, IndexShardState.STARTED);
175     private final AtomicBoolean active = new AtomicBoolean();
176     private final RefreshListeners refreshListeners;
177     private final AtomicLong lastSearcherAccess = new AtomicLong();
178     private final AtomicReference&lt;Translog.Location&gt; pendingRefreshLocation = new AtomicReference&lt;&gt;();
179     private final RefreshPendingLocationListener refreshPendingLocationListener;
180     private volatile boolean useRetentionLeasesInPeerRecovery;
181     public IndexShard(
182             ShardRouting shardRouting,
183             IndexSettings indexSettings,
184             ShardPath path,
185             Store store,
186             IndexCache indexCache,
187             MapperService mapperService,
188             @Nullable EngineFactory engineFactory,
189             IndexEventListener indexEventListener,
190             ThreadPool threadPool,
191             BigArrays bigArrays,
192             List&lt;IndexingOperationListener&gt; listeners,
193             Runnable globalCheckpointSyncer,
194             RetentionLeaseSyncer retentionLeaseSyncer,
195             CircuitBreakerService circuitBreakerService) throws IOException {
196         super(shardRouting.shardId(), indexSettings);
197         assert shardRouting.initializing();
198         this.shardRouting = shardRouting;
199         final Settings settings = indexSettings.getSettings();
200         this.codecService = new CodecService(mapperService, logger);
201         Objects.requireNonNull(store, "Store must be provided to the index shard");
202         this.engineFactory = Objects.requireNonNull(engineFactory);
203         this.store = store;
204         this.indexEventListener = indexEventListener;
205         this.threadPool = threadPool;
206         this.mapperService = mapperService;
207         this.indexCache = indexCache;
208         this.indexingOperationListeners = new IndexingOperationListener.CompositeListener(listeners, logger);
209         this.globalCheckpointSyncer = globalCheckpointSyncer;
210         this.retentionLeaseSyncer = retentionLeaseSyncer;
211         state = IndexShardState.CREATED;
212         this.path = path;
213         this.circuitBreakerService = circuitBreakerService;
214 <a name="15"></a>        logger.debug("state: [CREATED]");
215         this.checkIndexOnStartup = indexSettings.getValue(IndexSettings.INDEX_CHECK_ON_STARTUP);
216         this.translogConfig = <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new TranslogConfig(shardId, shardPath().resolveTranslog(), indexSettings, bigArrays);
217         final String aId = shardRouting.allocationId().getId();
218         final long primaryTerm = indexSettings.getIndexMetadata</b></font>().primaryTerm(shardId.id());
219         this.pendingPrimaryTerm = primaryTerm;
220         this.globalCheckpointListeners = new GlobalCheckpointListeners(
221             shardId,
222             threadPool.executor(ThreadPool.Names.LISTENER),
223             threadPool.scheduler(),
224             logger
225         );
226         this.replicationTracker = new ReplicationTracker(
227             shardId,
228             aId,
229             indexSettings,
230             primaryTerm,
231             UNASSIGNED_SEQ_NO,
232             globalCheckpointListeners::globalCheckpointUpdated,
233             threadPool::absoluteTimeInMillis,
234             (retentionLeases, listener) -&gt; retentionLeaseSyncer.sync(shardId, aId, getPendingPrimaryTerm(), retentionLeases, listener),
235             this::getSafeCommitInfo);
236         if (IndexModule.INDEX_QUERY_CACHE_EVERYTHING_SETTING.get(settings)) {
237             cachingPolicy = new QueryCachingPolicy() {
238                 @Override
239                 public void onUse(Query query) {
240                 }
241                 @Override
242                 public boolean shouldCache(Query query) {
243                     return true;
244                 }
245             };
246         } else {
247             cachingPolicy = new UsageTrackingQueryCachingPolicy();
248         }
249         indexShardOperationPermits = new IndexShardOperationPermits(shardId, logger, threadPool);
250         refreshListeners = buildRefreshListeners();
251         lastSearcherAccess.set(threadPool.relativeTimeInMillis());
252         persistMetadata(path, indexSettings, shardRouting, null, logger);
253         this.useRetentionLeasesInPeerRecovery = replicationTracker.hasAllPeerRecoveryRetentionLeases();
254         this.refreshPendingLocationListener = new RefreshPendingLocationListener();
255     }
256     public ThreadPool getThreadPool() {
257         return this.threadPool;
258     }
259     public Store store() {
260         return this.store;
261     }
262     public MapperService mapperService() {
263         return mapperService;
264     }
265     public long getPendingPrimaryTerm() {
266         return this.pendingPrimaryTerm;
267     }
268     public long getOperationPrimaryTerm() {
269         return replicationTracker.getOperationPrimaryTerm();
270     }
271     @Override
272     public ShardRouting routingEntry() {
273         return this.shardRouting;
274     }
275     @Override
276     public void updateShardState(final ShardRouting newRouting,
277                                  final long newPrimaryTerm,
278                                  final BiConsumer&lt;IndexShard, ActionListener&lt;ResyncTask&gt;&gt; primaryReplicaSyncer,
279                                  final long applyingClusterStateVersion,
280                                  final Set&lt;String&gt; inSyncAllocationIds,
281                                  final IndexShardRoutingTable routingTable) throws IOException {
282         final ShardRouting currentRouting;
283         synchronized (mutex) {
284             currentRouting = this.shardRouting;
285             assert currentRouting != null : "shardRouting must not be null";
286             if (!newRouting.shardId().equals(shardId())) {
287                 throw new IllegalArgumentException("Trying to set a routing entry with shardId " + newRouting.shardId() + " on a shard with shardId " + shardId());
288             }
289             if (newRouting.isSameAllocation(currentRouting) == false) {
290                 throw new IllegalArgumentException("Trying to set a routing entry with a different allocation. Current " + currentRouting + ", new " + newRouting);
291             }
292             if (currentRouting.primary() &amp;&amp; newRouting.primary() == false) {
293                 throw new IllegalArgumentException("illegal state: trying to move shard from primary mode to replica mode. Current "
294                     + currentRouting + ", new " + newRouting);
295             }
296             if (newRouting.primary()) {
297                 replicationTracker.updateFromMaster(applyingClusterStateVersion, inSyncAllocationIds, routingTable);
298             }
299             if (state == IndexShardState.POST_RECOVERY &amp;&amp; newRouting.active()) {
300                 assert currentRouting.active() == false : "we are in POST_RECOVERY, but our shard routing is active " + currentRouting;
301                 assert currentRouting.isRelocationTarget() == false || currentRouting.primary() == false ||
302                        replicationTracker.isPrimaryMode() :
303                     "a primary relocation is completed by the master, but primary mode is not active " + currentRouting;
304                 changeState(IndexShardState.STARTED, "global state is [" + newRouting.state() + "]");
305             } else if (currentRouting.primary() &amp;&amp; currentRouting.relocating() &amp;&amp; replicationTracker.isRelocated() &amp;&amp;
306                 (newRouting.relocating() == false || newRouting.equalsIgnoringMetadata(currentRouting) == false)) {
307                 throw new IndexShardRelocatedException(shardId(), "Shard is marked as relocated, cannot safely move to state " + newRouting.state());
308             }
309             assert newRouting.active() == false || state == IndexShardState.STARTED || state == IndexShardState.CLOSED :
310                 "routing is active, but local shard state isn't. routing: " + newRouting + ", local state: " + state;
311             persistMetadata(path, indexSettings, newRouting, currentRouting, logger);
312             final CountDownLatch shardStateUpdated = new CountDownLatch(1);
313             if (newRouting.primary()) {
314                 if (newPrimaryTerm == pendingPrimaryTerm) {
315                     if (currentRouting.initializing() &amp;&amp; newRouting.active()) {
316                         if (currentRouting.isRelocationTarget() == false) {
317                             replicationTracker.activatePrimaryMode(getLocalCheckpoint());
318                         }
319                     }
320                 } else {
321                     assert currentRouting.primary() == false : "term is only increased as part of primary promotion";
322                     assert newRouting.initializing() == false :
323                         "a started primary shard should never update its term; "
324                             + "shard " + newRouting + ", "
325                             + "current term [" + pendingPrimaryTerm + "], "
326                             + "new term [" + newPrimaryTerm + "]";
327                     assert newPrimaryTerm &gt; pendingPrimaryTerm :
328                         "primary terms can only go up; current term [" + pendingPrimaryTerm + "], new term [" + newPrimaryTerm + "]";
329                     boolean resyncStarted = primaryReplicaResyncInProgress.compareAndSet(false, true);
330                     if (resyncStarted == false) {
331                         throw new IllegalStateException("cannot start resync while it's already in progress");
332                     }
333                     bumpPrimaryTerm(newPrimaryTerm,
334                         () -&gt; {
335                             shardStateUpdated.await();
336                             assert pendingPrimaryTerm == newPrimaryTerm :
337                                 "shard term changed on primary. expected [" + newPrimaryTerm + "] but was [" + pendingPrimaryTerm + "]" +
338                                 ", current routing: " + currentRouting + ", new routing: " + newRouting;
339                             assert getOperationPrimaryTerm() == newPrimaryTerm;
340                             try {
341                                 replicationTracker.activatePrimaryMode(getLocalCheckpoint());
342                                 ensurePeerRecoveryRetentionLeasesExist();
343                                 final Engine engine = getEngine();
344                                 engine.restoreLocalHistoryFromTranslog((resettingEngine, snapshot) -&gt;
345                                     runTranslogRecovery(resettingEngine, snapshot, Engine.Operation.Origin.LOCAL_RESET, () -&gt; {}));
346                                 if (indexSettings.getIndexVersionCreated().onOrBefore(Version.V_3_0_1)) {
347                                     engine.flush(false, true);
348                                 }
349                                 engine.rollTranslogGeneration();
350                                 engine.fillSeqNoGaps(newPrimaryTerm);
351                                 replicationTracker.updateLocalCheckpoint(currentRouting.allocationId().getId(), getLocalCheckpoint());
352                                 primaryReplicaSyncer.accept(this, new ActionListener&lt;ResyncTask&gt;() {
353                                     @Override
354                                     public void onResponse(ResyncTask resyncTask) {
355                                         logger.info("primary-replica resync completed with {} operations",
356                                             resyncTask.getResyncedOperations());
357                                         boolean resyncCompleted = primaryReplicaResyncInProgress.compareAndSet(true, false);
358                                         assert resyncCompleted : "primary-replica resync finished but was not started";
359                                     }
360                                     @Override
361                                     public void onFailure(Exception e) {
362                                         boolean resyncCompleted = primaryReplicaResyncInProgress.compareAndSet(true, false);
363                                         assert resyncCompleted : "primary-replica resync finished but was not started";
364                                         if (state == IndexShardState.CLOSED) {
365                                         } else {
366                                             failShard("exception during primary-replica resync", e);
367                                         }
368                                     }
369                                 });
370                             } catch (final AlreadyClosedException e) {
371                             }
372                         }, null);
373                 }
374             }
375             this.shardRouting = newRouting;
376             assert this.shardRouting.primary() == false ||
377                 this.shardRouting.started() == false ||                 this.indexShardOperationPermits.isBlocked() ||                 this.replicationTracker.isPrimaryMode()
378                 : "a started primary with non-pending operation term must be in primary mode " + this.shardRouting;
379             shardStateUpdated.countDown();
380         }
381         if (currentRouting.active() == false &amp;&amp; newRouting.active()) {
382             indexEventListener.afterIndexShardStarted(this);
383         }
384         if (newRouting.equals(currentRouting) == false) {
385             indexEventListener.shardRoutingChanged(this, currentRouting, newRouting);
386         }
387         if (indexSettings.isSoftDeleteEnabled() &amp;&amp; useRetentionLeasesInPeerRecovery == false) {
388             final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases();
389             final Set&lt;ShardRouting&gt; shardRoutings = new HashSet&lt;&gt;(routingTable.getShards());
390             shardRoutings.addAll(routingTable.assignedShards());             if (shardRoutings.stream().allMatch(
391                 shr -&gt; shr.assignedToNode() &amp;&amp; retentionLeases.contains(ReplicationTracker.getPeerRecoveryRetentionLeaseId(shr)))) {
392                 useRetentionLeasesInPeerRecovery = true;
393                 turnOffTranslogRetention();
394             }
395         }
396     }
397     public IndexShardState markAsRecovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,
398         IndexShardRelocatedException, IndexShardRecoveringException, IndexShardClosedException {
399         synchronized (mutex) {
400             if (state == IndexShardState.CLOSED) {
401                 throw new IndexShardClosedException(shardId);
402             }
403             if (state == IndexShardState.STARTED) {
404                 throw new IndexShardStartedException(shardId);
405             }
406             if (state == IndexShardState.RECOVERING) {
407                 throw new IndexShardRecoveringException(shardId);
408             }
409             if (state == IndexShardState.POST_RECOVERY) {
410                 throw new IndexShardRecoveringException(shardId);
411             }
412             this.recoveryState = recoveryState;
413             return changeState(IndexShardState.RECOVERING, reason);
414         }
415     }
416     private final AtomicBoolean primaryReplicaResyncInProgress = new AtomicBoolean();
417     public void relocated(final String targetAllocationId,
418                           final Consumer&lt;ReplicationTracker.PrimaryContext&gt; consumer) throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {
419         assert shardRouting.primary() : "only primaries can be marked as relocated: " + shardRouting;
420         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {
421             indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -&gt; {
422                 forceRefreshes.close();
423                 assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :
424                         "in-flight operations in progress while moving shard state to relocated";
425                 verifyRelocatingState();
426                 final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);
427                 try {
428                     consumer.accept(primaryContext);
429                     synchronized (mutex) {
430                         verifyRelocatingState();
431                         replicationTracker.completeRelocationHandoff();                     }
432                 } catch (final Exception e) {
433                     try {
434                         replicationTracker.abortRelocationHandoff();
435                     } catch (final Exception inner) {
436                         e.addSuppressed(inner);
437                     }
438                     throw e;
439                 }
440             });
441         } catch (TimeoutException e) {
442             logger.warn("timed out waiting for relocation hand-off to complete");
443             failShard("timed out waiting for relocation hand-off to complete", null);
444             throw new IndexShardClosedException(shardId(), "timed out waiting for relocation hand-off to complete");
445         }
446     }
447     private void verifyRelocatingState() {
448         if (state != IndexShardState.STARTED) {
449             throw new IndexShardNotStartedException(shardId, state);
450         }
451         if (shardRouting.relocating() == false) {
452             throw new IllegalIndexShardStateException(shardId, IndexShardState.STARTED,
453                 ": shard is no longer relocating " + shardRouting);
454         }
455         if (primaryReplicaResyncInProgress.get()) {
456             throw new IllegalIndexShardStateException(shardId, IndexShardState.STARTED,
457                 ": primary relocation is forbidden while primary-replica resync is in progress " + shardRouting);
458         }
459     }
460     @Override
461     public IndexShardState state() {
462         return state;
463     }
464     private IndexShardState changeState(IndexShardState newState, String reason) {
465         assert Thread.holdsLock(mutex);
466         logger.debug("state: [{}]-&gt;[{}], reason [{}]", state, newState, reason);
467         IndexShardState previousState = state;
468         state = newState;
469         this.indexEventListener.indexShardStateChanged(this, previousState, newState, reason);
470         return previousState;
471     }
472     public Engine.IndexResult applyIndexOperationOnPrimary(long version,
473                                                            VersionType versionType,
474                                                            SourceToParse sourceToParse,
475                                                            long ifSeqNo,
476                                                            long ifPrimaryTerm,
477                                                            long autoGeneratedTimestamp,
478                                                            boolean isRetry) throws IOException {
479         assert versionType.validateVersionForWrites(version);
480         return applyIndexOperation(
481             getEngine(),
482             UNASSIGNED_SEQ_NO,
483             getOperationPrimaryTerm(),
484             version,
485             versionType,
486             ifSeqNo,
487             ifPrimaryTerm,
488             autoGeneratedTimestamp,
489             isRetry,
490             Engine.Operation.Origin.PRIMARY,
491             sourceToParse
492         );
493     }
494     public Engine.IndexResult applyIndexOperationOnReplica(long seqNo,
495                                                            long opPrimaryTerm,
496                                                            long version,
497                                                            long autoGeneratedTimeStamp,
498                                                            boolean isRetry,
499                                                            SourceToParse sourceToParse) throws IOException {
500         return applyIndexOperation(
501             getEngine(),
502             seqNo,
503             opPrimaryTerm,
504             version,
505             null,
506             UNASSIGNED_SEQ_NO,
507             0,
508             autoGeneratedTimeStamp,
509             isRetry,
510             Engine.Operation.Origin.REPLICA,
511             sourceToParse
512         );
513     }
514     private Engine.IndexResult applyIndexOperation(Engine engine,
515                                                    long seqNo,
516                                                    long opPrimaryTerm,
517                                                    long version,
518                                                    @Nullable VersionType versionType,
519                                                    long ifSeqNo,
520                                                    long ifPrimaryTerm,
521                                                    long autoGeneratedTimeStamp,
522                                                    boolean isRetry,
523                                                    Engine.Operation.Origin origin,
524                                                    SourceToParse sourceToParse) throws IOException {
525         assert opPrimaryTerm &lt;= getOperationPrimaryTerm()
526                 : "op term [ " + opPrimaryTerm + " ] &gt; shard term [" + getOperationPrimaryTerm() + "]";
527         ensureWriteAllowed(origin);
528         Engine.Index operation;
529         try {
530             operation = prepareIndex(
531                 mapperService.documentMapper(),
532                 sourceToParse,
533                 seqNo,
534                 opPrimaryTerm,
535                 version,
536                 versionType,
537                 origin,
538                 autoGeneratedTimeStamp,
539                 isRetry,
540                 ifSeqNo,
541                 ifPrimaryTerm
542             );
543             Mapping update = operation.parsedDoc().dynamicMappingsUpdate();
544             if (update != null) {
545                 return new Engine.IndexResult(update);
546             }
547         } catch (Exception e) {
548             verifyNotClosed(e);
549             return new Engine.IndexResult(e, version, opPrimaryTerm, seqNo);
550         }
551         return index(engine, operation);
552     }
553     public static Engine.Index prepareIndex(DocumentMapper docMapper,
554                                             SourceToParse source,
555                                             long seqNo,
556                                             long primaryTerm,
557                                             long version,
558                                             VersionType versionType,
559                                             Engine.Operation.Origin origin,
560 <a name="22"></a>                                            long autoGeneratedIdTimestamp,
561                                             boolean isRetry,
562                                             long ifSeqNo,
563                                             long ifPrimaryTerm) <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
564         long startTime = System.nanoTime();
565         ParsedDocument doc = docMapper.parse(source);
566         Term uid = new Term(IdFieldMapper.NAME, Uid.encodeId(doc.id</b></font>()));
567         return new Engine.Index(uid, doc, seqNo, primaryTerm, version, versionType, origin, startTime, autoGeneratedIdTimestamp, isRetry,
568                                 ifSeqNo, ifPrimaryTerm);
569     }
570     private Engine.IndexResult index(Engine engine, Engine.Index index) throws IOException {
571         active.set(true);
572         final Engine.IndexResult result;
573         index = indexingOperationListeners.preIndex(shardId, index);
574         boolean traceEnabled = logger.isTraceEnabled();
575 <a name="23"></a>        try {
576             if (traceEnabled) {
577                 <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>logger.trace(
578                     "index [{}] seq# [{}] allocation-id [{}] primaryTerm [{}] operationPrimaryTerm [{}] origin [{}]",
579                     index.id(),
580                     index.seqNo(),
581                     routingEntry().allocationId(),
582                     index.primaryTerm(),
583                     getOperationPrimaryTerm(),
584                     index.origin());
585 <a name="4"></a>            }</b></font>
586             result = engine.index(index);
587             if (traceEnabled) {
588                 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>logger.trace(
589                     "index-done [{}] seq# [{}] allocation-id [{}] primaryTerm [{}] operationPrimaryTerm [{}] origin [{}] " +
590                     "result-seq# [{}] result-term [{}] failure [{}]",
591                     index.id(),
592                     index.seqNo(),
593                     routingEntry().allocationId(),
594                     index.primaryTerm(),
595                     getOperationPrimaryTerm(),
596                     index.origin(),
597                     result.getSeqNo(),
598                     result.getTerm(),
599                     result.getFailure());
600 <a name="14"></a>            }</b></font>
601         } catch (Exception e) {
602             if (traceEnabled) {
603                 <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>logger.trace(new ParameterizedMessage(
604                     "index-fail [{}] seq# [{}] allocation-id [{}] primaryTerm [{}] operationPrimaryTerm [{}] origin [{}]",
605                     index.id(),
606                     index.seqNo(),
607                     routingEntry().allocationId(),
608                     index.primaryTerm(),
609                     getOperationPrimaryTerm(),
610                     index.origin</b></font>()
611                 ), e);
612             }
613             indexingOperationListeners.postIndex(shardId, index, e);
614             throw e;
615         }
616         indexingOperationListeners.postIndex(shardId, index, result);
617         return result;
618     }
619     public Engine.NoOpResult markSeqNoAsNoop(long seqNo, long opPrimaryTerm, String reason) throws IOException {
620         return markSeqNoAsNoop(getEngine(), seqNo, opPrimaryTerm, reason, Engine.Operation.Origin.REPLICA);
621     }
622     private Engine.NoOpResult markSeqNoAsNoop(Engine engine, long seqNo, long opPrimaryTerm, String reason,
623                                               Engine.Operation.Origin origin) throws IOException {
624         assert opPrimaryTerm &lt;= getOperationPrimaryTerm()
625                 : "op term [ " + opPrimaryTerm + " ] &gt; shard term [" + getOperationPrimaryTerm() + "]";
626         long startTime = System.nanoTime();
627         ensureWriteAllowed(origin);
628         final Engine.NoOp noOp = new Engine.NoOp(seqNo, opPrimaryTerm, origin, startTime, reason);
629         return noOp(engine, noOp);
630     }
631     private Engine.NoOpResult noOp(Engine engine, Engine.NoOp noOp) throws IOException {
632         active.set(true);
633         if (logger.isTraceEnabled()) {
634             logger.trace("noop (seq# [{}])", noOp.seqNo());
635         }
636         return engine.noOp(noOp);
637     }
638     public Engine.IndexResult getFailedIndexResult(Exception e, long version) {
639         return new Engine.IndexResult(e, version);
640     }
641     public Engine.DeleteResult applyDeleteOperationOnPrimary(long version,
642                                                              String id,
643                                                              VersionType versionType,
644                                                              long ifSeqNo,
645                                                              long ifPrimaryTerm) throws IOException {
646         return applyDeleteOperation(
647             getEngine(),
648             UNASSIGNED_SEQ_NO,
649             getOperationPrimaryTerm(),
650             version,
651             id,
652             versionType,
653             ifSeqNo,
654             ifPrimaryTerm,
655             Engine.Operation.Origin.PRIMARY
656         );
657     }
658     public Engine.DeleteResult applyDeleteOperationOnReplica(long seqNo,
659                                                              long opPrimaryTerm,
660                                                              long version,
661                                                              String id) throws IOException {
662         return applyDeleteOperation(
663             getEngine(),
664             seqNo,
665             opPrimaryTerm,
666             version,
667             id,
668             null,
669             UNASSIGNED_SEQ_NO,
670             0,
671             Engine.Operation.Origin.REPLICA
672         );
673     }
674     private Engine.DeleteResult applyDeleteOperation(Engine engine,
675                                                      long seqNo,
676                                                      long opPrimaryTerm,
677                                                      long version,
678                                                      String id,
679                                                      @Nullable VersionType versionType,
680                                                      long ifSeqNo,
681                                                      long ifPrimaryTerm,
682                                                      Engine.Operation.Origin origin) throws IOException {
683         assert opPrimaryTerm &lt;= getOperationPrimaryTerm()
684                 : "op term [ " + opPrimaryTerm + " ] &gt; shard term [" + getOperationPrimaryTerm() + "]";
685         ensureWriteAllowed(origin);
686         final Term uid = new Term(IdFieldMapper.NAME, Uid.encodeId(id));
687         final Engine.Delete delete = prepareDelete(
688             id,
689             uid,
690             seqNo,
691             opPrimaryTerm,
692             version,
693             versionType,
694             origin,
695             ifSeqNo,
696             ifPrimaryTerm
697         );
698         return delete(engine, delete);
699     }
700     private Engine.Delete prepareDelete(String id,
701                                         Term uid,
702                                         long seqNo,
703                                         long primaryTerm,
704                                         long version,
705                                         VersionType versionType,
706                                         Engine.Operation.Origin origin,
707                                         long ifSeqNo,
708                                         long ifPrimaryTerm) {
709         long startTime = System.nanoTime();
710         return new Engine.Delete(
711             id,
712             uid,
713             seqNo,
714             primaryTerm,
715             version,
716             versionType,
717             origin,
718             startTime,
719             ifSeqNo,
720             ifPrimaryTerm
721         );
722     }
723     private Engine.DeleteResult delete(Engine engine, Engine.Delete delete) throws IOException {
724         active.set(true);
725         final Engine.DeleteResult result;
726         delete = indexingOperationListeners.preDelete(shardId, delete);
727         try {
728             if (logger.isTraceEnabled()) {
729                 logger.trace("delete [{}] (seq no [{}])", delete.uid().text(), delete.seqNo());
730             }
731             result = engine.delete(delete);
732         } catch (Exception e) {
733             indexingOperationListeners.postDelete(shardId, delete, e);
734             throw e;
735         }
736         indexingOperationListeners.postDelete(shardId, delete, result);
737         return result;
738     }
739     public Engine.GetResult get(Engine.Get get) {
740         readAllowed();
741         return getEngine().get(get, this::acquireSearcher);
742     }
743     public void refresh(String source) {
744         verifyNotClosed();
745         if (logger.isTraceEnabled()) {
746             logger.trace("refresh with source [{}]", source);
747         }
748         getEngine().refresh(source);
749     }
750     public long getWritingBytes() {
751         Engine engine = getEngineOrNull();
752         if (engine == null) {
753             return 0;
754         }
755         return engine.getWritingBytes();
756     }
757     public DocsStats docStats() {
758         readAllowed();
759         return getEngine().docStats();
760     }
761     public CommitStats commitStats() {
762         return getEngine().commitStats();
763     }
764     public SeqNoStats seqNoStats() {
765         return getEngine().getSeqNoStats(replicationTracker.getGlobalCheckpoint());
766     }
767     public TranslogStats translogStats() {
768         return getEngine().getTranslogStats();
769     }
770     public StoreStats storeStats() {
771         try {
772             final RecoveryState recoveryState = this.recoveryState;
773             final long bytesStillToRecover = recoveryState == null ? -1L : recoveryState.getIndex().bytesStillToRecover();
774             return store.stats(bytesStillToRecover == -1 ? StoreStats.UNKNOWN_RESERVED_BYTES : bytesStillToRecover);
775         } catch (IOException e) {
776             failShard("Failing shard because of exception during storeStats", e);
777             throw new ElasticsearchException("io exception while building 'store stats'", e);
778         }
779     }
780     public Engine.SyncedFlushResult syncFlush(String syncId, Engine.CommitId expectedCommitId) {
781         verifyNotClosed();
782         logger.trace("trying to sync flush. sync id [{}]. expected commit id [{}]]", syncId, expectedCommitId);
783         return getEngine().syncFlush(syncId, expectedCommitId);
784     }
785 <a name="16"></a>    public Engine.CommitId flush(FlushRequest request) {
786         final boolean waitIfOngoing = request.waitIfOngoing();
787         final boolean force = request.force();
788         <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>logger.trace("flush with {}", request);
789         verifyNotClosed();
790         final long time = System.nanoTime();
791         final Engine.CommitId commitId = getEngine().flush(force, waitIfOngoing);
792         flushMetric.inc(System.nanoTime</b></font>() - time);
793         return commitId;
794     }
795     public void trimTranslog() {
796         verifyNotClosed();
797         final Engine engine = <font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>getEngine();
798         engine.trimUnreferencedTranslogFiles();
799     }
800     public void rollTranslogGeneration() {
801         final Engine engine = getEngine();
802         engine.rollTranslogGeneration</b></font>();
803     }
804     public void forceMerge(ForceMergeRequest forceMerge) throws IOException {
805         verifyActive();
806 <a name="21"></a>        if (logger.isTraceEnabled()) {
807             logger.trace("force merge with {}", forceMerge);
808         }
809         Engine engine = <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>getEngine();
810         engine.forceMerge(
811             forceMerge.flush(),
812             forceMerge.maxNumSegments(),
813             forceMerge.onlyExpungeDeletes(),
814             false,
815             false,
816             forceMerge.forceMergeUUID()
817         );
818     }
819     public </b></font>org.apache.lucene.util.Version upgrade(UpgradeRequest upgrade) throws IOException {
820         verifyActive();
821         if (logger.isTraceEnabled()) {
822             logger.trace("upgrade with {}", upgrade);
823         }
824         org.apache.lucene.util.Version previousVersion = minimumCompatibleVersion();
825         final Engine engine = getEngine();
826         engine.forceMerge(
827             true,              Integer.MAX_VALUE,             false,
828             true,
829             upgrade.upgradeOnlyAncientSegments(),
830             null
831         );
832         org.apache.lucene.util.Version version = minimumCompatibleVersion();
833         if (logger.isTraceEnabled()) {
834             logger.trace("upgraded segments for {} from version {} to version {}", shardId, previousVersion, version);
835         }
836         return version;
837     }
838     public org.apache.lucene.util.Version minimumCompatibleVersion() {
839         org.apache.lucene.util.Version luceneVersion = null;
840         for (Segment segment : getEngine().segments(false)) {
841             if (luceneVersion == null || luceneVersion.onOrAfter(segment.getVersion())) {
842                 luceneVersion = segment.getVersion();
843             }
844         }
845         return luceneVersion == null ? indexSettings.getIndexVersionCreated().luceneVersion : luceneVersion;
846     }
847     public Engine.IndexCommitRef acquireLastIndexCommit(boolean flushFirst) throws EngineException {
848         final IndexShardState state = this.state;         if (state == IndexShardState.STARTED || state == IndexShardState.CLOSED) {
849             return getEngine().acquireLastIndexCommit(flushFirst);
850         } else {
851             throw new IllegalIndexShardStateException(shardId, state, "snapshot is not allowed");
852         }
853     }
854     public Engine.IndexCommitRef acquireSafeIndexCommit() throws EngineException {
855         final IndexShardState state = this.state;         if (state == IndexShardState.STARTED || state == IndexShardState.CLOSED) {
856             return getEngine().acquireSafeIndexCommit();
857         } else {
858             throw new IllegalIndexShardStateException(shardId, state, "snapshot is not allowed");
859         }
860     }
861     public Store.MetadataSnapshot snapshotStoreMetadata() throws IOException {
862         assert Thread.holdsLock(mutex) == false : "snapshotting store metadata under mutex";
863         Engine.IndexCommitRef indexCommit = null;
864         store.incRef();
865         try {
866             synchronized (engineMutex) {
867                 final Engine engine = getEngineOrNull();
868                 if (engine != null) {
869                     indexCommit = engine.acquireLastIndexCommit(false);
870                 }
871                 if (indexCommit == null) {
872                     return store.getMetadata(null, true);
873                 }
874             }
875             return store.getMetadata(indexCommit.getIndexCommit());
876         } finally {
877             store.decRef();
878             IOUtils.close(indexCommit);
879         }
880     }
881     public void failShard(String reason, @Nullable Exception e) {
882         getEngine().failEngine(reason, e);
883     }
884     public Engine.Searcher acquireSearcher(String source) {
885         return acquireSearcher(source, Engine.SearcherScope.EXTERNAL);
886     }
887     private void markSearcherAccessed() {
888         lastSearcherAccess.lazySet(threadPool.relativeTimeInMillis());
889     }
890     private Engine.Searcher acquireSearcher(String source, Engine.SearcherScope scope) {
891         readAllowed();
892         markSearcherAccessed();
893         return getEngine().acquireSearcher(source, scope);
894     }
895     public void close(String reason, boolean flushEngine) throws IOException {
896         synchronized (engineMutex) {
897             try {
898                 synchronized (mutex) {
899                     changeState(IndexShardState.CLOSED, reason);
900                 }
901             } finally {
902                 final Engine engine = this.currentEngineReference.getAndSet(null);
903                 try {
904                     if (engine != null &amp;&amp; flushEngine) {
905                         engine.flushAndClose();
906                     }
907                 } finally {
908                     IOUtils.close(engine, globalCheckpointListeners, refreshListeners);
909                     indexShardOperationPermits.close();
910                 }
911             }
912         }
913     }
914     public void postRecovery(String reason) throws IndexShardStartedException, IndexShardRelocatedException, IndexShardClosedException {
915         synchronized (postRecoveryMutex) {
916             getEngine().refresh("post_recovery");
917             synchronized (mutex) {
918                 if (state == IndexShardState.CLOSED) {
919                     throw new IndexShardClosedException(shardId);
920                 }
921                 if (state == IndexShardState.STARTED) {
922                     throw new IndexShardStartedException(shardId);
923                 }
924                 recoveryState.setStage(RecoveryState.Stage.DONE);
925                 changeState(IndexShardState.POST_RECOVERY, reason);
926             }
927         }
928     }
929     public void prepareForIndexRecovery() {
930         if (state != IndexShardState.RECOVERING) {
931             throw new IndexShardNotRecoveringException(shardId, state);
932         }
933         recoveryState.setStage(RecoveryState.Stage.INDEX);
934         assert currentEngineReference.get() == null;
935     }
936     public long recoverLocallyUpToGlobalCheckpoint() {
937         assert Thread.holdsLock(mutex) == false : "recover locally under mutex";
938         if (state != IndexShardState.RECOVERING) {
939             throw new IndexShardNotRecoveringException(shardId, state);
940         }
941         assert recoveryState.getStage() == RecoveryState.Stage.INDEX : "unexpected recovery stage [" + recoveryState.getStage() + "]";
942         assert routingEntry().recoverySource().getType() == RecoverySource.Type.PEER : "not a peer recovery [" + routingEntry() + "]";
943         final Optional&lt;SequenceNumbers.CommitInfo&gt; safeCommit;
944         final long globalCheckpoint;
945         try {
946             final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);
947             globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);
948             safeCommit = store.findSafeIndexCommit(globalCheckpoint);
949         } catch (org.apache.lucene.index.IndexNotFoundException e) {
950             logger.trace("skip local recovery as no index commit found");
951             return UNASSIGNED_SEQ_NO;
952         } catch (Exception e) {
953             logger.debug("skip local recovery as failed to find the safe commit", e);
954             return UNASSIGNED_SEQ_NO;
955         }
956         try {
957             maybeCheckIndex();             recoveryState.setStage(RecoveryState.Stage.TRANSLOG);
958             if (safeCommit.isPresent() == false) {
959                 assert globalCheckpoint == UNASSIGNED_SEQ_NO || indexSettings.getIndexVersionCreated().before(Version.V_3_2_0) :
960                     "global checkpoint [" + globalCheckpoint + "] [ created version [" + indexSettings.getIndexVersionCreated() + "]";
961                 logger.trace("skip local recovery as no safe commit found");
962                 return UNASSIGNED_SEQ_NO;
963             }
964             assert safeCommit.get().localCheckpoint &lt;= globalCheckpoint : safeCommit.get().localCheckpoint + " &gt; " + globalCheckpoint;
965             if (safeCommit.get().localCheckpoint == globalCheckpoint) {
966                 logger.trace("skip local recovery as the safe commit is up to date; safe commit {} global checkpoint {}",
967                     safeCommit.get(), globalCheckpoint);
968                 recoveryState.getTranslog().totalLocal(0);
969                 return globalCheckpoint + 1;
970             }
971             if (indexSettings.getIndexMetadata().getState() == IndexMetadata.State.CLOSE ||
972                 IndexMetadata.INDEX_BLOCKS_WRITE_SETTING.get(indexSettings.getSettings())) {
973                 logger.trace("skip local recovery as the index was closed or not allowed to write; safe commit {} global checkpoint {}",
974                     safeCommit.get(), globalCheckpoint);
975                 recoveryState.getTranslog().totalLocal(0);
976                 return safeCommit.get().localCheckpoint + 1;
977             }
978             try {
979                 final Engine.TranslogRecoveryRunner translogRecoveryRunner = (engine, snapshot) -&gt; {
980                     recoveryState.getTranslog().totalLocal(snapshot.totalOperations());
981                     final int recoveredOps = runTranslogRecovery(engine, snapshot, Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY,
982                         recoveryState.getTranslog()::incrementRecoveredOperations);
983                     recoveryState.getTranslog().totalLocal(recoveredOps);                     return recoveredOps;
984                 };
985                 innerOpenEngineAndTranslog(() -&gt; globalCheckpoint);
986                 getEngine().recoverFromTranslog(translogRecoveryRunner, globalCheckpoint);
987                 logger.trace("shard locally recovered up to {}", getEngine().getSeqNoStats(globalCheckpoint));
988             } finally {
989                 synchronized (engineMutex) {
990                     IOUtils.close(currentEngineReference.getAndSet(null));
991                 }
992             }
993         } catch (Exception e) {
994             logger.debug(new ParameterizedMessage("failed to recover shard locally up to global checkpoint {}", globalCheckpoint), e);
995             return UNASSIGNED_SEQ_NO;
996         }
997         try {
998             final Optional&lt;SequenceNumbers.CommitInfo&gt; newSafeCommit = store.findSafeIndexCommit(globalCheckpoint);
999             assert newSafeCommit.isPresent() : "no safe commit found after local recovery";
1000             return newSafeCommit.get().localCheckpoint + 1;
1001         } catch (Exception e) {
1002             logger.debug(new ParameterizedMessage(
1003                 "failed to find the safe commit after recovering shard locally up to global checkpoint {}", globalCheckpoint), e);
1004             return UNASSIGNED_SEQ_NO;
1005         }
1006     }
1007     public void trimOperationOfPreviousPrimaryTerms(long aboveSeqNo) {
1008         getEngine().trimOperationsFromTranslog(getOperationPrimaryTerm(), aboveSeqNo);
1009     }
1010     public long getMaxSeenAutoIdTimestamp() {
1011         return getEngine().getMaxSeenAutoIdTimestamp();
1012     }
1013     public void updateMaxUnsafeAutoIdTimestamp(long maxSeenAutoIdTimestampFromPrimary) {
1014         getEngine().updateMaxUnsafeAutoIdTimestamp(maxSeenAutoIdTimestampFromPrimary);
1015     }
1016     public Engine.Result applyTranslogOperation(Translog.Operation operation, Engine.Operation.Origin origin) throws IOException {
1017         return applyTranslogOperation(getEngine(), operation, origin);
1018     }
1019     private Engine.Result applyTranslogOperation(Engine engine, Translog.Operation operation,
1020                                                  Engine.Operation.Origin origin) throws IOException {
1021         final VersionType versionType = (origin == Engine.Operation.Origin.PRIMARY) ? VersionType.EXTERNAL : null;
1022         final Engine.Result result;
1023         switch (operation.opType()) {
1024             case INDEX:
1025 <a name="13"></a>                final Translog.Index index = (Translog.Index) operation;
1026                 result = <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>applyIndexOperation(
1027                     engine,
1028                     index.seqNo(),
1029                     index.primaryTerm(),
1030                     index.version(),
1031                     versionType,
1032                     UNASSIGNED_SEQ_NO,
1033                     0,
1034                     index.getAutoGeneratedIdTimestamp(),
1035                     true,
1036                     origin,
1037                     new SourceToParse(
1038                         shardId.getIndexName(),
1039                         index.id(),
1040                         index.source</b></font>(),
1041                         XContentHelper.xContentType(index.source()), index.routing())
1042                 );
1043                 break;
1044             case DELETE:
1045                 final Translog.Delete delete = (Translog.Delete) operation;
1046                 result = applyDeleteOperation(
1047                     engine,
1048                     delete.seqNo(),
1049                     delete.primaryTerm(),
1050                     delete.version(),
1051                     delete.id(),
1052                     versionType,
1053                     UNASSIGNED_SEQ_NO,
1054                     0,
1055                     origin
1056                 );
1057                 break;
1058             case NO_OP:
1059                 final Translog.NoOp noOp = (Translog.NoOp) operation;
1060                 result = markSeqNoAsNoop(engine, noOp.seqNo(), noOp.primaryTerm(), noOp.reason(), origin);
1061                 break;
1062             default:
1063                 throw new IllegalStateException("No operation defined for [" + operation + "]");
1064         }
1065         return result;
1066     }
1067     int runTranslogRecovery(Engine engine, Translog.Snapshot snapshot, Engine.Operation.Origin origin,
1068                             Runnable onOperationRecovered) throws IOException {
1069         int opsRecovered = 0;
1070         Translog.Operation operation;
1071         while ((operation = snapshot.next()) != null) {
1072             try {
1073                 logger.trace("[translog] recover op {}", operation);
1074                 Engine.Result result = applyTranslogOperation(engine, operation, origin);
1075                 switch (result.getResultType()) {
1076                     case FAILURE:
1077                         throw result.getFailure();
1078                     case MAPPING_UPDATE_REQUIRED:
1079                         throw new IllegalArgumentException("unexpected mapping update: " + result.getRequiredMappingUpdate());
1080                     case SUCCESS:
1081                         break;
1082                     default:
1083                         throw new AssertionError("Unknown result type [" + result.getResultType() + "]");
1084                 }
1085                 opsRecovered++;
1086                 onOperationRecovered.run();
1087             } catch (Exception e) {
1088                 if (origin == Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY &amp;&amp; ExceptionsHelper.status(e) == RestStatus.BAD_REQUEST) {
1089                     logger.info("ignoring recovery of a corrupt translog entry", e);
1090                 } else {
1091                     throw Exceptions.toRuntimeException(e);
1092                 }
1093 <a name="3"></a>            }
1094         }
1095         return opsRecovered;
1096     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1097     private void loadGlobalCheckpointToReplicationTracker() throws IOException {
1098         final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);
1099         final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);
1100         replicationTracker.updateGlobalCheckpointOnReplica</b></font>(globalCheckpoint, "read from translog checkpoint");
1101     }
1102     public void openEngineAndRecoverFromTranslog() throws IOException {
1103         assert recoveryState.getStage() == RecoveryState.Stage.INDEX : "unexpected recovery stage [" + recoveryState.getStage() + "]";
1104         maybeCheckIndex();
1105         recoveryState.setStage(RecoveryState.Stage.TRANSLOG);
1106         final RecoveryState.Translog translogRecoveryStats = recoveryState.getTranslog();
1107         final Engine.TranslogRecoveryRunner translogRecoveryRunner = (engine, snapshot) -&gt; {
1108             translogRecoveryStats.totalOperations(snapshot.totalOperations());
1109             translogRecoveryStats.totalOperationsOnStart(snapshot.totalOperations());
1110             return runTranslogRecovery(engine, snapshot, Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY,
1111                 translogRecoveryStats::incrementRecoveredOperations);
1112         };
1113         loadGlobalCheckpointToReplicationTracker();
1114         innerOpenEngineAndTranslog(replicationTracker);
1115         getEngine().recoverFromTranslog(translogRecoveryRunner, Long.MAX_VALUE);
1116     }
1117     public void openEngineAndSkipTranslogRecovery() throws IOException {
1118         assert routingEntry().recoverySource().getType() == RecoverySource.Type.PEER : "not a peer recovery [" + routingEntry() + "]";
1119         assert <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>recoveryState.getStage() == RecoveryState.Stage.TRANSLOG : "unexpected recovery stage [" + recoveryState.getStage() + "]";
1120         loadGlobalCheckpointToReplicationTracker();
1121         innerOpenEngineAndTranslog(replicationTracker);
1122         getEngine().skipTranslogRecovery();
1123     }
1124     private void innerOpenEngi</b></font>neAndTranslog(LongSupplier globalCheckpointSupplier) throws IOException {
1125         assert Thread.holdsLock(mutex) == false : "opening engine under mutex";
1126         if (state != IndexShardState.RECOVERING) {
1127             throw new IndexShardNotRecoveringException(shardId, state);
1128         }
1129         final EngineConfig config = newEngineConfig(globalCheckpointSupplier);
1130         config.setEnableGcDeletes(false);
1131         updateRetentionLeasesOnReplica(loadRetentionLeases());
1132         assert recoveryState.getRecoverySource().expectEmptyRetentionLeases() == false || getRetentionLeases().leases().isEmpty()
1133             : "expected empty set of retention leases with recovery source [" + recoveryState.getRecoverySource()
1134             + "] but got " + getRetentionLeases();
1135         synchronized (engineMutex) {
1136             assert currentEngineReference.get() == null : "engine is running";
1137             verifyNotClosed();
1138             final Engine newEngine = engineFactory.newReadWriteEngine(config);
1139             onNewEngine(newEngine);
1140             currentEngineReference.set(newEngine);
1141             active.set(true);
1142         }
1143 <a name="8"></a>                onSettingsChanged();
1144         assert assertSequenceNumbersInCommit();
1145         assert <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>recoveryState.getStage() == RecoveryState.Stage.TRANSLOG : "TRANSLOG stage expected but was: " + recoveryState.getStage();
1146     }
1147     private boolean assertSequenceNumbersInCommit() throws IOException {
1148         final Map&lt;String, String&gt; userData = SegmentInfos.readLatestCommit(store.directory</b></font>()).getUserData();
1149         assert userData.containsKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY) : "commit point doesn't contains a local checkpoint";
1150         assert userData.containsKey(SequenceNumbers.MAX_SEQ_NO) : "commit point doesn't contains a maximum sequence number";
1151         assert userData.containsKey(Engine.HISTORY_UUID_KEY) : "commit point doesn't contains a history uuid";
1152         assert userData.get(Engine.HISTORY_UUID_KEY).equals(getHistoryUUID()) : "commit point history uuid ["
1153             + userData.get(Engine.HISTORY_UUID_KEY) + "] is different than engine [" + getHistoryUUID() + "]";
1154         assert userData.containsKey(Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID) :
1155             "opening index which was created post 5.5.0 but " + Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID
1156                 + " is not found in commit";
1157         return true;
1158     }
1159     private void onNewEngine(Engine newEngine) {
1160         assert Thread.holdsLock(engineMutex);
1161         refreshListeners.setCurrentRefreshLocationSupplier(newEngine::getTranslogLastWriteLocation);
1162     }
1163     public void performRecoveryRestart() throws IOException {
1164         assert Thread.holdsLock(mutex) == false : "restart recovery under mutex";
1165         synchronized (engineMutex) {
1166             assert refreshListeners.pendingCount() == 0 : "we can't restart with pending listeners";
1167             IOUtils.close(currentEngineReference.getAndSet(null));
1168             resetRecoveryStage();
1169         }
1170     }
1171     public void resetRecoveryStage() {
1172         assert routingEntry().recoverySource().getType() == RecoverySource.Type.PEER : "not a peer recovery [" + routingEntry() + "]";
1173         assert currentEngineReference.get() == null;
1174         if (state != IndexShardState.RECOVERING) {
1175             throw new IndexShardNotRecoveringException(shardId, state);
1176         }
1177         recoveryState().setStage(RecoveryState.Stage.INIT);
1178     }
1179     public RecoveryStats recoveryStats() {
1180         return recoveryStats;
1181     }
1182     @Override
1183     public RecoveryState recoveryState() {
1184         return this.recoveryState;
1185     }
1186     public void finalizeRecovery() {
1187         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>recoveryState().setStage(RecoveryState.Stage.FINALIZE);
1188         Engine engine = getEngine();
1189         engine.refresh("recovery_finalization");
1190         engine.config().setEnableGcDeletes(true);
1191     }
1192     public boolean ignoreRecoveryAttempt() {
1193         IndexShardState state = state</b></font>();         return state == IndexShardState.POST_RECOVERY || state == IndexShardState.RECOVERING || state == IndexShardState.STARTED ||
1194             state == IndexShardState.CLOSED;
1195     }
1196     public void readAllowed() throws IllegalIndexShardStateException {
1197         IndexShardState state = this.state;         if (READ_ALLOWED_STATES.contains(state) == false) {
1198             throw new IllegalIndexShardStateException(shardId, state, "operations only allowed when shard state is one of " + READ_ALLOWED_STATES.toString());
1199         }
1200     }
1201 <a name="12"></a>        public boolean isReadAllowed() {
1202         return READ_ALLOWED_STATES.contains(state);
1203     <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1204     private void ensureWriteAllowed(Engine.Operation.Origin origin) throws IllegalIndexShardStateException {
1205         IndexShardState state = this.state; 
1206         if (origin.isRecovery()) {</b></font>
1207             if (state != IndexShardState.RECOVERING) {
1208                 throw new IllegalIndexShardStateException(shardId, state, "operation only allowed when recovering, origin [" + origin + "]");
1209             }
1210         } else {
1211             if (origin == Engine.Operation.Origin.PRIMARY) {
1212                 assert assertPrimaryMode();
1213             } else if (origin == Engine.Operation.Origin.REPLICA) {
1214                 assert assertReplicationTarget();
1215             } else {
1216                 assert origin == Engine.Operation.Origin.LOCAL_RESET;
1217                 assert getActiveOperationsCount() == OPERATIONS_BLOCKED
1218                     : "locally resetting without blocking operations, active operations are [" + getActiveOperations() + "]";
1219             }
1220             if (WRITE_ALLOWED_STATES.contains(state) == false) {
1221                 throw new IllegalIndexShardStateException(shardId, state, "operation only allowed when shard state is one of " + WRITE_ALLOWED_STATES + ", origin [" + origin + "]");
1222             }
1223         }
1224     }
1225     private boolean assertPrimaryMode() {
1226         assert shardRouting.primary() &amp;&amp; replicationTracker.isPrimaryMode() : "shard " + shardRouting + " is not a primary shard in primary mode";
1227         return true;
1228     }
1229     private boolean assertReplicationTarget() {
1230         assert replicationTracker.isPrimaryMode() == false : "shard " + shardRouting + " in primary mode cannot be a replication target";
1231         return true;
1232     }
1233     private void verifyNotClosed() throws IllegalIndexShardStateException {
1234         verifyNotClosed(null);
1235     }
1236     private void verifyNotClosed(Exception suppressed) throws IllegalIndexShardStateException {
1237         IndexShardState state = this.state;         if (state == IndexShardState.CLOSED) {
1238             final IllegalIndexShardStateException exc = new IndexShardClosedException(shardId, "operation only allowed when not closed");
1239             if (suppressed != null) {
1240                 exc.addSuppressed(suppressed);
1241             }
1242             throw exc;
1243         }
1244     }
1245     protected final void verifyActive() throws IllegalIndexShardStateException {
1246         IndexShardState state = this.state;         if (state != IndexShardState.STARTED) {
1247             throw new IllegalIndexShardStateException(shardId, state, "operation only allowed when shard is active");
1248         }
1249     }
1250     public long getIndexBufferRAMBytesUsed() {
1251         Engine engine = getEngineOrNull();
1252         if (engine == null) {
1253             return 0;
1254         }
1255         try {
1256             return engine.getIndexBufferRAMBytesUsed();
1257         } catch (AlreadyClosedException ex) {
1258             return 0;
1259         }
1260     }
1261     public void addShardFailureCallback(Consumer&lt;ShardFailure&gt; onShardFailure) {
1262         this.shardEventListener.delegates.add(onShardFailure);
1263     }
1264     public void checkIdle(long inactiveTimeNS) {
1265         Engine engineOrNull = getEngineOrNull();
1266         if (engineOrNull != null &amp;&amp; System.nanoTime() - engineOrNull.getLastWriteNanos() &gt;= inactiveTimeNS) {
1267             boolean wasActive = active.getAndSet(false);
1268             if (wasActive) {
1269                 logger.debug("shard is now inactive");
1270                 try {
1271                     indexEventListener.onShardInactive(this);
1272                 } catch (Exception e) {
1273                     logger.warn("failed to notify index event listener", e);
1274                 }
1275             }
1276         }
1277     }
1278     public boolean isActive() {
1279         return active.get();
1280     }
1281     public ShardPath shardPath() {
1282         return path;
1283     }
1284     public void recoverFromLocalShards(Consumer&lt;MappingMetadata&gt; mappingUpdateConsumer,
1285                                        List&lt;IndexShard&gt; localShards,
1286                                        ActionListener&lt;Boolean&gt; listener) throws IOException {
1287         assert shardRouting.primary() : "recover from local shards only makes sense if the shard is a primary shard";
1288         assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS : "invalid recovery type: " + recoveryState.getRecoverySource();
1289         final List&lt;LocalShardSnapshot&gt; snapshots = new ArrayList&lt;&gt;();
1290         final ActionListener&lt;Boolean&gt; recoveryListener = ActionListener.runBefore(listener, () -&gt; IOUtils.close(snapshots));
1291         boolean success = false;
1292         try {
1293             for (IndexShard shard : localShards) {
1294                 snapshots.add(new LocalShardSnapshot(shard));
1295             }
1296             assert shardRouting.primary() : "recover from local shards only makes sense if the shard is a primary shard";
1297             StoreRecovery storeRecovery = new StoreRecovery(shardId, logger);
1298             storeRecovery.recoverFromLocalShards(mappingUpdateConsumer, this, snapshots, recoveryListener);
1299             success = true;
1300         } finally {
1301             if (success == false) {
1302                 IOUtils.close(snapshots);
1303             }
1304         }
1305     }
1306     public void recoverFromStore(ActionListener&lt;Boolean&gt; listener) {
1307         assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";
1308         assert shardRouting.initializing() : "can only start recovery on initializing shard";
1309         StoreRecovery storeRecovery = new StoreRecovery(shardId, logger);
1310         storeRecovery.recoverFromStore(this, listener);
1311     }
1312     public void restoreFromRepository(Repository repository, ActionListener&lt;Boolean&gt; listener) {
1313         try {
1314             assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";
1315             assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.SNAPSHOT : "invalid recovery type: " +
1316                 recoveryState.getRecoverySource();
1317             StoreRecovery storeRecovery = new StoreRecovery(shardId, logger);
1318             storeRecovery.recoverFromRepository(this, repository, listener);
1319         } catch (Exception e) {
1320             listener.onFailure(e);
1321         }
1322     }
1323     boolean shouldPeriodicallyFlush() {
1324         final Engine engine = getEngineOrNull();
1325         if (engine != null) {
1326             try {
1327                 return engine.shouldPeriodicallyFlush();
1328 <a name="11"></a>            } catch (final AlreadyClosedException e) {
1329             }
1330         <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1331         return false;
1332     }
1333     boolean shouldRollTranslogGeneration() {
1334         final Engine engine = getEngineOrNull</b></font>();
1335         if (engine != null) {
1336             try {
1337                 return engine.shouldRollTranslogGeneration();
1338             } catch (final AlreadyClosedException e) {
1339             }
1340         }
1341         return false;
1342     }
1343     public void onSettingsChanged() {
1344         Engine engineOrNull = getEngineOrNull();
1345         if (engineOrNull != null) {
1346             final boolean disableTranslogRetention = indexSettings.isSoftDeleteEnabled() &amp;&amp; useRetentionLeasesInPeerRecovery;
1347             engineOrNull.onSettingsChanged(
1348                 disableTranslogRetention ? TimeValue.MINUS_ONE : indexSettings.getTranslogRetentionAge(),
1349                 disableTranslogRetention ? new ByteSizeValue(-1) : indexSettings.getTranslogRetentionSize(),
1350                 indexSettings.getSoftDeleteRetentionOperations()
1351             );
1352         }
1353     }
1354     private void turnOffTranslogRetention() {
1355         logger.debug("turn off the translog retention for the replication group {} " +
1356             "as it starts using retention leases exclusively in peer recoveries", shardId);
1357         threadPool.generic().execute(new AbstractRunnable() {
1358             @Override
1359             public void onFailure(Exception e) {
1360                 if (state != IndexShardState.CLOSED) {
1361                     logger.warn("failed to turn off translog retention", e);
1362                 }
1363             }
1364             @Override
1365             protected void doRun() {
1366                 onSettingsChanged();
1367                 trimTranslog();
1368             }
1369         });
1370     }
1371     public Closeable acquireHistoryRetentionLock(Engine.HistorySource source) {
1372         return getEngine().acquireHistoryRetentionLock(source);
1373     }
1374     public int estimateNumberOfHistoryOperations(String reason, Engine.HistorySource source, long startingSeqNo) throws IOException {
1375         return getEngine().estimateNumberOfHistoryOperations(reason, source, mapperService, startingSeqNo);
1376     }
1377     public Translog.Snapshot getHistoryOperations(String reason, Engine.HistorySource source, long startingSeqNo) throws IOException {
1378         return getEngine().readHistoryOperations(reason, source, mapperService, startingSeqNo);
1379     }
1380     public boolean hasCompleteHistoryOperations(String reason, Engine.HistorySource source, long startingSeqNo) throws IOException {
1381         return getEngine().hasCompleteOperationHistory(reason, source, mapperService, startingSeqNo);
1382     }
1383     public long getMinRetainedSeqNo() {
1384         return getEngine().getMinRetainedSeqNo();
1385     }
1386     public Translog.Snapshot newChangesSnapshot(String source, long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {
1387         return getEngine().newChangesSnapshot(source, mapperService, fromSeqNo, toSeqNo, requiredFullRange);
1388     }
1389     public List&lt;Segment&gt; segments(boolean verbose) {
1390         return getEngine().segments(verbose);
1391     }
1392     public String getHistoryUUID() {
1393         return getEngine().getHistoryUUID();
1394     }
1395     public IndexEventListener getIndexEventListener() {
1396         return indexEventListener;
1397 <a name="9"></a>    }
1398     public void activateThrottling() {
1399         <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1400             getEngine().activateThrottling();
1401         } catch (AlreadyClosedException ex) {
1402         }</b></font>
1403     }
1404     public void deactivateThrottling() {
1405         try {
1406             getEngine().deactivateThrottling();
1407         } catch (AlreadyClosedException ex) {
1408         }
1409     }
1410     private void handleRefreshException(Exception e) {
1411         if (e instanceof AlreadyClosedException) {
1412         } else if (e instanceof RefreshFailedEngineException) {
1413             RefreshFailedEngineException rfee = (RefreshFailedEngineException) e;
1414             if (rfee.getCause() instanceof InterruptedException) {
1415             } else if (rfee.getCause() instanceof ClosedByInterruptException) {
1416             } else if (rfee.getCause() instanceof ThreadInterruptedException) {
1417             } else {
1418                 if (state != IndexShardState.CLOSED) {
1419                     logger.warn("Failed to perform engine refresh", e);
1420                 }
1421             }
1422         } else {
1423             if (state != IndexShardState.CLOSED) {
1424                 logger.warn("Failed to perform engine refresh", e);
1425             }
1426         }
1427     }
1428     public void writeIndexingBuffer() {
1429         try {
1430             Engine engine = getEngine();
1431             engine.writeIndexingBuffer();
1432         } catch (Exception e) {
1433             handleRefreshException(e);
1434         }
1435     }
1436     public void updateLocalCheckpointForShard(final String allocationId, final long checkpoint) {
1437         assert assertPrimaryMode();
1438         verifyNotClosed();
1439         replicationTracker.updateLocalCheckpoint(allocationId, checkpoint);
1440     }
1441     public void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {
1442         assert assertPrimaryMode();
1443         verifyNotClosed();
1444         replicationTracker.updateGlobalCheckpointForShard(allocationId, globalCheckpoint);
1445     }
1446     public void addGlobalCheckpointListener(
1447             final long waitingForGlobalCheckpoint,
1448 <a name="7"></a>            final GlobalCheckpointListeners.GlobalCheckpointListener listener,
1449             final TimeValue timeout) {
1450         this.globalCheckpointListeners.add(waitingForGlobalCheckpoint, listener, timeout);
1451     <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1452     private void ensureSoftDeletesEnabled(String feature) {
1453         if (indexSettings.isSoftDeleteEnabled() == false) {
1454             String message = feature + " requires soft deletes but " + indexSettings.getIndex</b></font>() + " does not have soft deletes enabled";
1455             assert false : message;
1456             throw new IllegalStateException(message);
1457         }
1458     }
1459     public RetentionLeases getRetentionLeases() {
1460         return getRetentionLeases(false).v2();
1461     }
1462     public Tuple&lt;Boolean, RetentionLeases&gt; getRetentionLeases(final boolean expireLeases) {
1463         assert expireLeases == false || assertPrimaryMode();
1464         verifyNotClosed();
1465         return replicationTracker.getRetentionLeases(expireLeases);
1466     }
1467     public RetentionLeaseStats getRetentionLeaseStats() {
1468         verifyNotClosed();
1469         return new RetentionLeaseStats(getRetentionLeases());
1470     }
1471     public RetentionLease addRetentionLease(
1472             final String id,
1473             final long retainingSequenceNumber,
1474             final String source,
1475             final ActionListener&lt;ReplicationResponse&gt; listener) {
1476         Objects.requireNonNull(listener);
1477         assert assertPrimaryMode();
1478         verifyNotClosed();
1479         ensureSoftDeletesEnabled("retention leases");
1480         try (Closeable ignore = acquireHistoryRetentionLock(Engine.HistorySource.INDEX)) {
1481             final long actualRetainingSequenceNumber =
1482                 retainingSequenceNumber == RETAIN_ALL ? getMinRetainedSeqNo() : retainingSequenceNumber;
1483             return replicationTracker.addRetentionLease(id, actualRetainingSequenceNumber, source, listener);
1484         } catch (final IOException e) {
1485             throw new AssertionError(e);
1486         }
1487     }
1488     public RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {
1489         assert assertPrimaryMode();
1490         verifyNotClosed();
1491         ensureSoftDeletesEnabled("retention leases");
1492         try (Closeable ignore = acquireHistoryRetentionLock(Engine.HistorySource.INDEX)) {
1493             final long actualRetainingSequenceNumber =
1494                     retainingSequenceNumber == RETAIN_ALL ? getMinRetainedSeqNo() : retainingSequenceNumber;
1495             return replicationTracker.renewRetentionLease(id, actualRetainingSequenceNumber, source);
1496         } catch (final IOException e) {
1497             throw new AssertionError(e);
1498         }
1499     }
1500     public void removeRetentionLease(final String id, final ActionListener&lt;ReplicationResponse&gt; listener) {
1501         Objects.requireNonNull(listener);
1502         assert assertPrimaryMode();
1503         verifyNotClosed();
1504         ensureSoftDeletesEnabled("retention leases");
1505         replicationTracker.removeRetentionLease(id, listener);
1506     }
1507     public void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {
1508         assert assertReplicationTarget();
1509         verifyNotClosed();
1510         replicationTracker.updateRetentionLeasesOnReplica(retentionLeases);
1511     }
1512     public RetentionLeases loadRetentionLeases() throws IOException {
1513         verifyNotClosed();
1514         return replicationTracker.loadRetentionLeases(path.getShardStatePath());
1515     }
1516     public void persistRetentionLeases() throws WriteStateException {
1517         verifyNotClosed();
1518         replicationTracker.persistRetentionLeases(path.getShardStatePath());
1519     }
1520     public boolean assertRetentionLeasesPersisted() throws IOException {
1521         return replicationTracker.assertRetentionLeasesPersisted(path.getShardStatePath());
1522     }
1523     public void syncRetentionLeases() {
1524         assert assertPrimaryMode();
1525         verifyNotClosed();
1526 <a name="24"></a>        replicationTracker.renewPeerRecoveryRetentionLeases();
1527         final Tuple&lt;Boolean, RetentionLeases&gt; retentionLeases = getRetentionLeases(true);
1528         if (retentionLeases.v1()) {
1529             <font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>logger.trace("syncing retention leases [{}] after expiration check", retentionLeases.v2());
1530             retentionLeaseSyncer.sync(
1531                 shardId,
1532                 shardRouting.allocationId().getId(),
1533                 getPendingPrimaryTerm(),
1534                 retentionLeases.v2(),
1535                 ActionListener.wrap(
1536                     r -&gt; {},</b></font>
1537                     e -&gt; logger.warn(
1538                         new ParameterizedMessage(
1539                             "failed to sync retention leases [{}] after expiration check", retentionLeases),
1540                         e
1541                     )
1542                 )
1543 <a name="5"></a>            );
1544         } else {
1545             logger.trace("background syncing retention leases [{}] after expiration check", retentionLeases.v2());
1546             <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>retentionLeaseSyncer.backgroundSync(
1547                 shardId, shardRouting.allocationId().getId(), getPendingPrimaryTerm(), retentionLeases.v2());
1548         }
1549     }
1550     public void initiateTracking(final String allocationId</b></font>) {
1551         assert assertPrimaryMode();
1552         replicationTracker.initiateTracking(allocationId);
1553     }
1554     public void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {
1555         assert assertPrimaryMode();
1556         replicationTracker.markAllocationIdAsInSync(allocationId, localCheckpoint);
1557     }
1558     public long getLocalCheckpoint() {
1559         return getEngine().getPersistedLocalCheckpoint();
1560     }
1561     public long getLastKnownGlobalCheckpoint() {
1562         return replicationTracker.getGlobalCheckpoint();
1563     }
1564     public long getLastSyncedGlobalCheckpoint() {
1565         return getEngine().getLastSyncedGlobalCheckpoint();
1566     }
1567     public ObjectLongMap&lt;String&gt; getInSyncGlobalCheckpoints() {
1568         assert assertPrimaryMode();
1569         verifyNotClosed();
1570         return replicationTracker.getInSyncGlobalCheckpoints();
1571     }
1572     public void maybeSyncGlobalCheckpoint(final String reason) {
1573         verifyNotClosed();
1574         assert shardRouting.primary() : "only call maybeSyncGlobalCheckpoint on primary shard";
1575         if (replicationTracker.isPrimaryMode() == false) {
1576             return;
1577         }
1578         assert assertPrimaryMode();
1579 <a name="2"></a>        final SeqNoStats stats = getEngine().getSeqNoStats(replicationTracker.getGlobalCheckpoint());
1580         final boolean asyncDurability = indexSettings().getTranslogDurability() == Translog.Durability.ASYNC;
1581         if (stats.getMaxSeqNo() == stats.getGlobalCheckpoint() || asyncDurability) {
1582             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final ObjectLongMap&lt;String&gt; globalCheckpoints = getInSyncGlobalCheckpoints();
1583             final long globalCheckpoint = replicationTracker.getGlobalCheckpoint();
1584             final boolean syncNeeded =
1585                 (asyncDurability &amp;&amp; (stats.getGlobalCheckpoint() &lt; stats.getMaxSeqNo() || replicationTracker.pendingInSync()))
1586                     || StreamSupport
1587                             .stream(globalCheckpoints.values().spliterator(), false)
1588                             .anyMatch(v -&gt; v.value </b></font>&lt; globalCheckpoint);
1589             if (syncNeeded &amp;&amp; indexSettings.getIndexMetadata().getState() == IndexMetadata.State.OPEN) {
1590                 logger.trace("syncing global checkpoint for [{}]", reason);
1591                 globalCheckpointSyncer.run();
1592             }
1593         }
1594     }
1595     public ReplicationGroup getReplicationGroup() {
1596         assert assertPrimaryMode();
1597         verifyNotClosed();
1598         return replicationTracker.getReplicationGroup();
1599     }
1600     public void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {
1601         assert assertReplicationTarget();
1602         final long localCheckpoint = getLocalCheckpoint();
1603         if (globalCheckpoint &gt; localCheckpoint) {
1604             assert state() != IndexShardState.POST_RECOVERY &amp;&amp; state() != IndexShardState.STARTED :
1605                 "supposedly in-sync shard copy received a global checkpoint [" + globalCheckpoint + "] " +
1606                     "that is higher than its local checkpoint [" + localCheckpoint + "]";
1607             return;
1608         }
1609         replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, reason);
1610     }
1611     public void activateWithPrimaryContext(final ReplicationTracker.PrimaryContext primaryContext) {
1612         assert shardRouting.primary() &amp;&amp; shardRouting.isRelocationTarget() :
1613 <a name="10"></a>            "only primary relocation target can update allocation IDs from primary context: " + shardRouting;
1614         assert primaryContext.getCheckpointStates().containsKey(routingEntry().allocationId().getId()) :
1615             "primary context [" + primaryContext + "] does not contain relocation target [" + routingEntry() + "]";
1616         assert <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>getLocalCheckpoint() == primaryContext.getCheckpointStates().get(routingEntry().allocationId().getId())
1617             .getLocalCheckpoint() || indexSettings().getTranslogDurability() == Translog.Durability.ASYNC :
1618             "local checkpoint [" + getLocalCheckpoint</b></font>() + "] does not match checkpoint from primary context [" + primaryContext + "]";
1619         synchronized (mutex) {
1620             replicationTracker.activateWithPrimaryContext(primaryContext);         }
1621         ensurePeerRecoveryRetentionLeasesExist();
1622     }
1623     private void ensurePeerRecoveryRetentionLeasesExist() {
1624         threadPool.generic().execute(() -&gt; replicationTracker.createMissingPeerRecoveryRetentionLeases(ActionListener.wrap(
1625             r -&gt; logger.trace("created missing peer recovery retention leases"),
1626             e -&gt; logger.debug("failed creating missing peer recovery retention leases", e))));
1627     }
1628     public boolean pendingInSync() {
1629         assert assertPrimaryMode();
1630         return replicationTracker.pendingInSync();
1631     }
1632     public void maybeCheckIndex() {
1633         recoveryState.setStage(RecoveryState.Stage.VERIFY_INDEX);
1634         if (Booleans.isTrue(checkIndexOnStartup) || "checksum".equals(checkIndexOnStartup)) {
1635             try {
1636                 checkIndex();
1637             } catch (IOException ex) {
1638                 throw new RecoveryFailedException(recoveryState, "check index failed", ex);
1639             }
1640         }
1641     }
1642     void checkIndex() throws IOException {
1643         if (store.tryIncRef()) {
1644             try {
1645                 doCheckIndex();
1646             } catch (IOException e) {
1647                 store.markStoreCorrupted(e);
1648                 throw e;
1649             } finally {
1650                 store.decRef();
1651             }
1652         }
1653     }
1654     private void doCheckIndex() throws IOException {
1655         final long timeNS = System.nanoTime();
1656         if (!Lucene.indexExists(store.directory())) {
1657             return;
1658         }
1659         BytesStreamOutput os = new BytesStreamOutput();
1660         PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name());
1661         if ("checksum".equals(checkIndexOnStartup)) {
1662             IOException corrupt = null;
1663             MetadataSnapshot metadata = snapshotStoreMetadata();
1664             for (Map.Entry&lt;String, StoreFileMetadata&gt; entry : metadata.asMap().entrySet()) {
1665                 try {
1666                     Store.checkIntegrity(entry.getValue(), store.directory());
1667                     out.println("checksum passed: " + entry.getKey());
1668                 } catch (IOException exc) {
1669                     out.println("checksum failed: " + entry.getKey());
1670                     exc.printStackTrace(out);
1671                     corrupt = exc;
1672                 }
1673             }
1674             out.flush();
1675             if (corrupt != null) {
1676                 logger.warn("check index [failure]\n{}", os.bytes().utf8ToString());
1677                 throw corrupt;
1678             }
1679         } else {
1680             final CheckIndex.Status status = store.checkIndex(out);
1681             out.flush();
1682             if (!status.clean) {
1683                 if (state == IndexShardState.CLOSED) {
1684                     return;
1685                 }
1686                 logger.warn("check index [failure]\n{}", os.bytes().utf8ToString());
1687                 throw new IOException("index check failure");
1688             }
1689         }
1690         if (logger.isDebugEnabled()) {
1691 <a name="6"></a>            logger.debug("check index [success]\n{}", os.bytes().utf8ToString());
1692         }
1693         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>recoveryState.getVerifyIndex().checkIndexTime(Math.max(0, TimeValue.nsecToMSec(System.nanoTime() - timeNS)));
1694     }
1695     Engine getEngine() {
1696         Engine engine = getEngineOrNull</b></font>();
1697         if (engine == null) {
1698             throw new AlreadyClosedException("engine is closed");
1699         }
1700         return engine;
1701     }
1702     protected Engine getEngineOrNull() {
1703         return this.currentEngineReference.get();
1704     }
1705     public void startRecovery(RecoveryState recoveryState,
1706                               PeerRecoveryTargetService recoveryTargetService,
1707                               PeerRecoveryTargetService.RecoveryListener recoveryListener,
1708                               RepositoriesService repositoriesService,
1709                               Consumer&lt;MappingMetadata&gt; mappingUpdateConsumer,
1710                               IndicesService indicesService) {
1711         assert recoveryState.getRecoverySource().equals(shardRouting.recoverySource());
1712         switch (recoveryState.getRecoverySource().getType()) {
1713             case EMPTY_STORE:
1714             case EXISTING_STORE:
1715                 executeRecovery("from store", recoveryState, recoveryListener, this::recoverFromStore);
1716                 break;
1717             case PEER:
1718                 try {
1719                     markAsRecovering("from " + recoveryState.getSourceNode(), recoveryState);
1720                     recoveryTargetService.startRecovery(this, recoveryState.getSourceNode(), recoveryListener);
1721                 } catch (Exception e) {
1722                     failShard("corrupted preexisting index", e);
1723                     recoveryListener.onRecoveryFailure(recoveryState, new RecoveryFailedException(recoveryState, null, e), true);
1724                 }
1725                 break;
1726             case SNAPSHOT:
1727                 final String repo = ((SnapshotRecoverySource) recoveryState.getRecoverySource()).snapshot().getRepository();
1728                 executeRecovery(
1729                     "from snapshot",
1730                     recoveryState,
1731                     recoveryListener,
1732                     l -&gt; restoreFromRepository(repositoriesService.repository(repo), l)
1733 <a name="17"></a>                );
1734                 break;
1735             case LOCAL_SHARDS:
1736                 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final IndexMetadata indexMetadata = indexSettings().getIndexMetadata();
1737                 final Index resizeSourceIndex = indexMetadata.getResizeSourceIndex();
1738                 final List&lt;IndexShard&gt; startedShards = new ArrayList&lt;&gt;();
1739                 final IndexService sourceIndexService = indicesService.indexService</b></font>(resizeSourceIndex);
1740                 final Set&lt;ShardId&gt; requiredShards;
1741                 final int numShards;
1742                 if (sourceIndexService != null) {
1743                     requiredShards = IndexMetadata.selectRecoverFromShards(shardId().id(),
1744                                                                            sourceIndexService.getMetadata(), indexMetadata.getNumberOfShards());
1745                     for (IndexShard shard : sourceIndexService) {
1746                         if (shard.state() == IndexShardState.STARTED &amp;&amp; requiredShards.contains(shard.shardId())) {
1747                             startedShards.add(shard);
1748                         }
1749                     }
1750                     numShards = requiredShards.size();
1751                 } else {
1752                     numShards = -1;
1753                     requiredShards = Collections.emptySet();
1754 <a name="26"></a>                }
1755                 if (numShards == startedShards.size()) {
1756                     assert <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>requiredShards.isEmpty() == false;
1757                     executeRecovery("from local shards", recoveryState, recoveryListener,
1758                         l -&gt; recoverFromLocalShards(mappingUpdateConsumer,
1759                             startedShards.stream().filter((s) -&gt; requiredShards.contains</b></font>(s.shardId())).collect(Collectors.toList()), l));
1760                 } else {
1761                     final RuntimeException e;
1762                     if (numShards == -1) {
1763                         e = new IndexNotFoundException(resizeSourceIndex);
1764                     } else {
1765                         e = new IllegalStateException("not all required shards of index " + resizeSourceIndex
1766                             + " are started yet, expected " + numShards + " found " + startedShards.size() + " can't recover shard "
1767                             + shardId());
1768                     }
1769                     throw e;
1770                 }
1771                 break;
1772             default:
1773                 throw new IllegalArgumentException("Unknown recovery source " + recoveryState.getRecoverySource());
1774         }
1775     }
1776     private void executeRecovery(String reason,
1777                                  RecoveryState recoveryState,
1778                                  PeerRecoveryTargetService.RecoveryListener recoveryListener,
1779                                  CheckedConsumer&lt;ActionListener&lt;Boolean&gt;, Exception&gt; action) {
1780         markAsRecovering(reason, recoveryState);         threadPool.generic().execute(ActionRunnable.wrap(ActionListener.wrap(
1781             r -&gt; {
1782                 if (r) {
1783                     recoveryListener.onRecoveryDone(recoveryState);
1784                 }
1785             },
1786             e -&gt; recoveryListener.onRecoveryFailure(recoveryState, new RecoveryFailedException(recoveryState, null, e), true)), action));
1787     }
1788     public boolean isRelocatedPrimary() {
1789         assert shardRouting.primary() : "only call isRelocatedPrimary on primary shard";
1790         return replicationTracker.isRelocated();
1791     }
1792     public RetentionLease addPeerRecoveryRetentionLease(String nodeId, long globalCheckpoint,
1793                                                         ActionListener&lt;ReplicationResponse&gt; listener) {
1794         assert assertPrimaryMode();
1795         assert indexSettings.getIndexVersionCreated().before(Version.V_4_3_0) || indexSettings.isSoftDeleteEnabled() == false;
1796         return replicationTracker.addPeerRecoveryRetentionLease(nodeId, globalCheckpoint, listener);
1797     }
1798     public RetentionLease cloneLocalPeerRecoveryRetentionLease(String nodeId, ActionListener&lt;ReplicationResponse&gt; listener) {
1799         assert assertPrimaryMode();
1800         return replicationTracker.cloneLocalPeerRecoveryRetentionLease(nodeId, listener);
1801     }
1802     public void removePeerRecoveryRetentionLease(String nodeId, ActionListener&lt;ReplicationResponse&gt; listener) {
1803         assert assertPrimaryMode();
1804         replicationTracker.removePeerRecoveryRetentionLease(nodeId, listener);
1805     }
1806     public List&lt;RetentionLease&gt; getPeerRecoveryRetentionLeases() {
1807         return replicationTracker.getPeerRecoveryRetentionLeases();
1808     }
1809     public boolean useRetentionLeasesInPeerRecovery() {
1810         return useRetentionLeasesInPeerRecovery;
1811     }
1812     private SafeCommitInfo getSafeCommitInfo() {
1813         final Engine engine = getEngineOrNull();
1814         return engine == null ? SafeCommitInfo.EMPTY : engine.getSafeCommitInfo();
1815     }
1816     class ShardEventListener implements Engine.EventListener {
1817         private final CopyOnWriteArrayList&lt;Consumer&lt;ShardFailure&gt;&gt; delegates = new CopyOnWriteArrayList&lt;&gt;();
1818         @Override
1819         public void onFailedEngine(String reason, @Nullable Exception failure) {
1820             final ShardFailure shardFailure = new ShardFailure(shardRouting, reason, failure);
1821             for (Consumer&lt;ShardFailure&gt; listener : delegates) {
1822                 try {
1823                     listener.accept(shardFailure);
1824                 } catch (Exception inner) {
1825                     inner.addSuppressed(failure);
1826                     logger.warn("exception while notifying engine failure", inner);
1827                 }
1828             }
1829         }
1830     }
1831     private static void persistMetadata(
1832             final ShardPath shardPath,
1833             final IndexSettings indexSettings,
1834             final ShardRouting newRouting,
1835             final @Nullable ShardRouting currentRouting,
1836             final Logger logger) throws IOException {
1837         assert newRouting != null : "newRouting must not be null";
1838         final ShardId shardId = newRouting.shardId();
1839         if (currentRouting == null
1840             || currentRouting.primary() != newRouting.primary()
1841             || currentRouting.allocationId().equals(newRouting.allocationId()) == false) {
1842             assert currentRouting == null || currentRouting.isSameAllocation(newRouting);
1843             final String writeReason;
1844             if (currentRouting == null) {
1845                 writeReason = "initial state with allocation id [" + newRouting.allocationId() + "]";
1846             } else {
1847                 writeReason = "routing changed from " + currentRouting + " to " + newRouting;
1848             }
1849             logger.trace("{} writing shard state, reason [{}]", shardId, writeReason);
1850             final ShardStateMetadata newShardStateMetadata =
1851                     new ShardStateMetadata(newRouting.primary(), indexSettings.getUUID(), newRouting.allocationId());
1852             ShardStateMetadata.FORMAT.write(newShardStateMetadata, shardPath.getShardStatePath());
1853         } else {
1854             logger.trace("{} skip writing shard state, has been written before", shardId);
1855         }
1856     }
1857     private EngineConfig newEngineConfig(LongSupplier globalCheckpointSupplier) {
1858         return new EngineConfig(
1859             shardId,
1860             shardRouting.allocationId().getId(),
1861             threadPool,
1862             indexSettings,
1863             store,
1864             indexSettings.getMergePolicy(),
1865             mapperService == null ? null : mapperService.indexAnalyzer(),
1866             codecService,
1867             shardEventListener,
1868             indexCache == null ? null : indexCache.query(),
1869             cachingPolicy,
1870             translogConfig,
1871             IndexingMemoryController.SHARD_INACTIVE_TIME_SETTING.get(indexSettings.getSettings()),
1872             List.of(refreshListeners, refreshPendingLocationListener),
1873             Collections.singletonList(new RefreshMetricUpdater(refreshMetric)),
1874             circuitBreakerService,
1875             globalCheckpointSupplier,
1876             replicationTracker::getRetentionLeases,
1877             this::getOperationPrimaryTerm,
1878             tombstoneDocSupplier()
1879         );
1880     }
1881     public void acquirePrimaryOperationPermit(ActionListener&lt;Releasable&gt; onPermitAcquired, String executorOnDelay, Object debugInfo) {
1882         verifyNotClosed();
1883         assert shardRouting.primary() : "acquirePrimaryOperationPermit should only be called on primary shard: " + shardRouting;
1884         indexShardOperationPermits.acquire(wrapPrimaryOperationPermitListener(onPermitAcquired), executorOnDelay, false, debugInfo);
1885     }
1886     public void acquireAllPrimaryOperationsPermits(final ActionListener&lt;Releasable&gt; onPermitAcquired, final TimeValue timeout) {
1887         verifyNotClosed();
1888         assert shardRouting.primary() : "acquireAllPrimaryOperationsPermits should only be called on primary shard: " + shardRouting;
1889         asyncBlockOperations(wrapPrimaryOperationPermitListener(onPermitAcquired), timeout.duration(), timeout.timeUnit());
1890     }
1891 <a name="19"></a>    private ActionListener&lt;Releasable&gt; wrapPrimaryOperationPermitListener(final ActionListener&lt;Releasable&gt; listener) {
1892         return ActionListener.delegateFailure(
1893             listener,
1894             (l, r) -&gt; <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1895                 if (replicationTracker.isPrimaryMode()) {
1896                     l.onResponse(r);
1897                 } else {
1898                     r.close</b></font>();
1899                     l.onFailure(new ShardNotInPrimaryModeException(shardId, state));
1900                 }
1901             }
1902         );
1903     }
1904     private void asyncBlockOperations(ActionListener&lt;Releasable&gt; onPermitAcquired, long timeout, TimeUnit timeUnit) {
1905         final Releasable forceRefreshes = refreshListeners.forceRefreshes();
1906         final ActionListener&lt;Releasable&gt; wrappedListener = ActionListener.wrap(
1907             r -&gt; {
1908                 forceRefreshes.close();
1909                 onPermitAcquired.onResponse(r);
1910             },
1911             e -&gt; {
1912                 forceRefreshes.close();
1913                 onPermitAcquired.onFailure(e);
1914             }
1915         );
1916         try {
1917             indexShardOperationPermits.asyncBlockOperations(wrappedListener, timeout, timeUnit);
1918         } catch (Exception e) {
1919             forceRefreshes.close();
1920             throw e;
1921         }
1922     }
1923     public void runUnderPrimaryPermit(
1924             final Runnable runnable,
1925             final Consumer&lt;Exception&gt; onFailure,
1926             final String executorOnDelay,
1927             final Object debugInfo) {
1928         verifyNotClosed();
1929         assert shardRouting.primary() : "runUnderPrimaryPermit should only be called on primary shard but was " + shardRouting;
1930         final ActionListener&lt;Releasable&gt; onPermitAcquired = ActionListener.wrap(
1931             releasable -&gt; {
1932                 try (Releasable ignore = releasable) {
1933                     runnable.run();
1934                 }
1935             },
1936             onFailure);
1937         acquirePrimaryOperationPermit(onPermitAcquired, executorOnDelay, debugInfo);
1938     }
1939     private &lt;E extends Exception&gt; void bumpPrimaryTerm(long newPrimaryTerm,
1940                                                        final CheckedRunnable&lt;E&gt; onBlocked,
1941                                                        @Nullable ActionListener&lt;Releasable&gt; combineWithAction) {
1942         assert Thread.holdsLock(mutex);
1943         assert newPrimaryTerm &gt; pendingPrimaryTerm || (newPrimaryTerm &gt;= pendingPrimaryTerm &amp;&amp; combineWithAction != null);
1944         assert getOperationPrimaryTerm() &lt;= pendingPrimaryTerm;
1945         final CountDownLatch termUpdated = new CountDownLatch(1);
1946         asyncBlockOperations(new ActionListener&lt;Releasable&gt;() {
1947             @Override
1948             public void onFailure(final Exception e) {
1949                 try {
1950                     innerFail(e);
1951                 } finally {
1952                     if (combineWithAction != null) {
1953                         combineWithAction.onFailure(e);
1954                     }
1955                 }
1956             }
1957             private void innerFail(final Exception e) {
1958                 try {
1959                     failShard("exception during primary term transition", e);
1960                 } catch (AlreadyClosedException ace) {
1961                 }
1962             }
1963             @Override
1964             public void onResponse(final Releasable releasable) {
1965                 final RunOnce releaseOnce = new RunOnce(releasable::close);
1966                 try {
1967                     assert getOperationPrimaryTerm() &lt;= pendingPrimaryTerm;
1968                     termUpdated.await();
1969                     if (getOperationPrimaryTerm() &lt; newPrimaryTerm) {
1970                         replicationTracker.setOperationPrimaryTerm(newPrimaryTerm);
1971                         onBlocked.run();
1972                     }
1973                 } catch (final Exception e) {
1974                     if (combineWithAction == null) {
1975                         releaseOnce.run();
1976                     }
1977                     innerFail(e);
1978                 } finally {
1979                     if (combineWithAction != null) {
1980                         combineWithAction.onResponse(releasable);
1981                     } else {
1982                         releaseOnce.run();
1983                     }
1984                 }
1985             }
1986         }, 30, TimeUnit.MINUTES);
1987         pendingPrimaryTerm = newPrimaryTerm;
1988         termUpdated.countDown();
1989     }
1990     public void acquireReplicaOperationPermit(final long opPrimaryTerm,
1991                                               final long globalCheckpoint,
1992                                               final long maxSeqNoOfUpdatesOrDeletes,
1993                                               final ActionListener&lt;Releasable&gt; onPermitAcquired,
1994                                               final String executorOnDelay,
1995                                               final Object debugInfo) {
1996         innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, onPermitAcquired, false,
1997             (listener) -&gt; indexShardOperationPermits.acquire(listener, executorOnDelay, true, debugInfo));
1998     }
1999     public void acquireAllReplicaOperationsPermits(final long opPrimaryTerm,
2000                                                    final long globalCheckpoint,
2001                                                    final long maxSeqNoOfUpdatesOrDeletes,
2002                                                    final ActionListener&lt;Releasable&gt; onPermitAcquired,
2003                                                    final TimeValue timeout) {
2004         innerAcquireReplicaOperationPermit(
2005             opPrimaryTerm,
2006             globalCheckpoint,
2007             maxSeqNoOfUpdatesOrDeletes,
2008             onPermitAcquired,
2009             true,
2010             (listener) -&gt; asyncBlockOperations(listener, timeout.duration(), timeout.timeUnit())
2011         );
2012     }
2013     private void innerAcquireReplicaOperationPermit(final long opPrimaryTerm,
2014                                                     final long globalCheckpoint,
2015                                                     final long maxSeqNoOfUpdatesOrDeletes,
2016                                                     final ActionListener&lt;Releasable&gt; onPermitAcquired,
2017                                                     final boolean allowCombineOperationWithPrimaryTermUpdate,
2018                                                     final Consumer&lt;ActionListener&lt;Releasable&gt;&gt; operationExecutor) {
2019         verifyNotClosed();
2020         final ActionListener&lt;Releasable&gt; operationListener = ActionListener.delegateFailure(
2021             onPermitAcquired,
2022             (delegatedListener, releasable) -&gt; {
2023                 if (opPrimaryTerm &lt; getOperationPrimaryTerm()) {
2024                     releasable.close();
2025                     final String message = String.format(
2026                         Locale.ROOT,
2027                         "%s operation primary term [%d] is too old (current [%d])",
2028                         shardId,
2029                         opPrimaryTerm,
2030                         getOperationPrimaryTerm());
2031                     delegatedListener.onFailure(new IllegalStateException(message));
2032                 } else {
2033                     assert assertReplicationTarget();
2034                     try {
2035                         updateGlobalCheckpointOnReplica(globalCheckpoint, "operation");
2036                         advanceMaxSeqNoOfUpdatesOrDeletes(maxSeqNoOfUpdatesOrDeletes);
2037                     } catch (Exception e) {
2038                         releasable.close();
2039                         delegatedListener.onFailure(e);
2040                         return;
2041                     }
2042                     delegatedListener.onResponse(releasable);
2043                 }
2044             }
2045         );
2046         if (requirePrimaryTermUpdate(opPrimaryTerm, allowCombineOperationWithPrimaryTermUpdate)) {
2047             synchronized (mutex) {
2048                 if (requirePrimaryTermUpdate(opPrimaryTerm, allowCombineOperationWithPrimaryTermUpdate)) {
2049                     final IndexShardState shardState = state();
2050                     if (shardState != IndexShardState.POST_RECOVERY &amp;&amp;
2051                         shardState != IndexShardState.STARTED) {
2052                         throw new IndexShardNotStartedException(shardId, shardState);
2053                     }
2054 <a name="18"></a>                    bumpPrimaryTerm(opPrimaryTerm, () -&gt; {
2055                         updateGlobalCheckpointOnReplica(globalCheckpoint, "primary term transition");
2056                         final long currentGlobalCheckpoint = getLastKnownGlobalCheckpoint();
2057                         final long maxSeqNo = <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>seqNoStats().getMaxSeqNo();
2058                         logger.info("detected new primary with primary term [{}], global checkpoint [{}], max_seq_no [{}]",
2059                             opPrimaryTerm, currentGlobalCheckpoint, maxSeqNo);
2060                         if (currentGlobalCheckpoint &lt; maxSeqNo) {
2061                             resetEngineToGlobalCheckpoint();
2062                         } else {
2063                             getEngine().rollTranslogGeneration</b></font>();
2064                         }
2065                     }, allowCombineOperationWithPrimaryTermUpdate ? operationListener : null);
2066                     if (allowCombineOperationWithPrimaryTermUpdate) {
2067                         logger.debug("operation execution has been combined with primary term update");
2068                         return;
2069                     }
2070                 }
2071             }
2072         }
2073         assert opPrimaryTerm &lt;= pendingPrimaryTerm
2074             : "operation primary term [" + opPrimaryTerm + "] should be at most [" + pendingPrimaryTerm + "]";
2075         operationExecutor.accept(operationListener);
2076     }
2077     private boolean requirePrimaryTermUpdate(final long opPrimaryTerm, final boolean allPermits) {
2078         return (opPrimaryTerm &gt; pendingPrimaryTerm) || (allPermits &amp;&amp; opPrimaryTerm &gt; getOperationPrimaryTerm());
2079     }
2080     public static final int OPERATIONS_BLOCKED = -1;
2081     public int getActiveOperationsCount() {
2082         return indexShardOperationPermits.getActiveOperationsCount();
2083     }
2084     public List&lt;String&gt; getActiveOperations() {
2085         return indexShardOperationPermits.getActiveOperations();
2086     }
2087     private final AsyncIOProcessor&lt;Translog.Location&gt; translogSyncProcessor = new AsyncIOProcessor&lt;Translog.Location&gt;(logger, 1024) {
2088         @Override
2089         protected void write(List&lt;Tuple&lt;Translog.Location, Consumer&lt;Exception&gt;&gt;&gt; candidates) throws IOException {
2090             try {
2091                 getEngine().ensureTranslogSynced(candidates.stream().map(Tuple::v1));
2092             } catch (AlreadyClosedException ex) {
2093             } catch (IOException ex) {                 logger.debug("failed to sync translog", ex);
2094                 throw ex;
2095             }
2096         }
2097     };
2098     public final void sync(Translog.Location location, Consumer&lt;Exception&gt; syncListener) {
2099         verifyNotClosed();
2100         translogSyncProcessor.put(location, syncListener);
2101     }
2102     public void sync() throws IOException {
2103         verifyNotClosed();
2104         getEngine().syncTranslog();
2105     }
2106     public boolean isSyncNeeded() {
2107         return getEngine().isTranslogSyncNeeded();
2108     }
2109     public Translog.Durability getTranslogDurability() {
2110         return indexSettings.getTranslogDurability();
2111     }
2112     private final AtomicBoolean flushOrRollRunning = new AtomicBoolean();
2113     public void afterWriteOperation() {
2114         if (shouldPeriodicallyFlush() || shouldRollTranslogGeneration()) {
2115             if (flushOrRollRunning.compareAndSet(false, true)) {
2116                 if (shouldPeriodicallyFlush()) {
2117                     logger.debug("submitting async flush request");
2118                     final AbstractRunnable flush = new AbstractRunnable() {
2119                         @Override
2120                         public void onFailure(final Exception e) {
2121                             if (state != IndexShardState.CLOSED) {
2122                                 logger.warn("failed to flush index", e);
2123                             }
2124                         }
2125                         @Override
2126                         protected void doRun() throws IOException {
2127                             flush(new FlushRequest());
2128                             periodicFlushMetric.inc();
2129                         }
2130                         @Override
2131                         public void onAfter() {
2132                             flushOrRollRunning.compareAndSet(true, false);
2133                             afterWriteOperation();
2134                         }
2135                     };
2136                     threadPool.executor(ThreadPool.Names.FLUSH).execute(flush);
2137                 } else if (shouldRollTranslogGeneration()) {
2138                     logger.debug("submitting async roll translog generation request");
2139                     final AbstractRunnable roll = new AbstractRunnable() {
2140                         @Override
2141                         public void onFailure(final Exception e) {
2142                             if (state != IndexShardState.CLOSED) {
2143                                 logger.warn("failed to roll translog generation", e);
2144                             }
2145                         }
2146                         @Override
2147                         protected void doRun() throws Exception {
2148                             rollTranslogGeneration();
2149                         }
2150                         @Override
2151                         public void onAfter() {
2152                             flushOrRollRunning.compareAndSet(true, false);
2153                             afterWriteOperation();
2154                         }
2155                     };
2156                     threadPool.executor(ThreadPool.Names.FLUSH).execute(roll);
2157                 } else {
2158                     flushOrRollRunning.compareAndSet(true, false);
2159                 }
2160             }
2161         }
2162     }
2163     private RefreshListeners buildRefreshListeners() {
2164         return new RefreshListeners(
2165             indexSettings::getMaxRefreshListeners,
2166             () -&gt; refresh("too_many_listeners"),
2167             threadPool.executor(ThreadPool.Names.LISTENER)::execute,
2168             logger
2169         );
2170     }
2171     public static final class ShardFailure {
2172         public final ShardRouting routing;
2173         public final String reason;
2174         @Nullable
2175         public final Exception cause;
2176         public ShardFailure(ShardRouting routing, String reason, @Nullable Exception cause) {
2177             this.routing = routing;
2178             this.reason = reason;
2179             this.cause = cause;
2180         }
2181     }
2182     EngineFactory getEngineFactory() {
2183         return engineFactory;
2184     }
2185     ReplicationTracker getReplicationTracker() {
2186         return replicationTracker;
2187     }
2188     public boolean scheduledRefresh() {
2189         verifyNotClosed();
2190         boolean listenerNeedsRefresh = refreshListeners.refreshNeeded();
2191         if (isReadAllowed() &amp;&amp; (listenerNeedsRefresh || getEngine().refreshNeeded())) {
2192             if (listenerNeedsRefresh == false                 &amp;&amp; isSearchIdle()
2193                 &amp;&amp; indexSettings.isExplicitRefresh() == false
2194                 &amp;&amp; active.get()) {                 final Engine engine = getEngine();
2195                 engine.maybePruneDeletes();                 setRefreshPending(engine);
2196                 return false;
2197             } else {
2198                 if (logger.isTraceEnabled()) {
2199                     logger.trace("refresh with source [schedule]");
2200                 }
2201                 return getEngine().maybeRefresh("schedule");
2202             }
2203         }
2204         final Engine engine = getEngine();
2205         engine.maybePruneDeletes();         return false;
2206     }
2207     public final boolean isSearchIdle() {
2208         return (threadPool.relativeTimeInMillis() - lastSearcherAccess.get()) &gt;= indexSettings.getSearchIdleAfter().getMillis();
2209     }
2210     final long getLastSearcherAccess() {
2211         return lastSearcherAccess.get();
2212     }
2213     public final boolean hasRefreshPending() {
2214         return pendingRefreshLocation.get() != null;
2215     }
2216     private void setRefreshPending(Engine engine) {
2217         final Translog.Location lastWriteLocation = engine.getTranslogLastWriteLocation();
2218         pendingRefreshLocation.updateAndGet(curr -&gt; {
2219             if (curr == null || curr.compareTo(lastWriteLocation) &lt;= 0) {
2220                 return lastWriteLocation;
2221             } else {
2222                 return curr;
2223             }
2224         });
2225     }
2226     private class RefreshPendingLocationListener implements ReferenceManager.RefreshListener {
2227         Translog.Location lastWriteLocation;
2228         @Override
2229         public void beforeRefresh() {
2230             try {
2231                 lastWriteLocation = getEngine().getTranslogLastWriteLocation();
2232             } catch (AlreadyClosedException exc) {
2233                 lastWriteLocation = null;
2234             }
2235         }
2236         @Override
2237         public void afterRefresh(boolean didRefresh) {
2238             if (didRefresh &amp;&amp; lastWriteLocation != null) {
2239                 pendingRefreshLocation.updateAndGet(pendingLocation -&gt; {
2240                     if (pendingLocation == null || pendingLocation.compareTo(lastWriteLocation) &lt;= 0) {
2241                         return null;
2242                     } else {
2243                         return pendingLocation;
2244                     }
2245                 });
2246             }
2247         }
2248     }
2249     public final void awaitShardSearchActive(Consumer&lt;Boolean&gt; listener) {
2250         markSearcherAccessed();         final Translog.Location location = pendingRefreshLocation.get();
2251         if (location != null) {
2252             addRefreshListener(location, (b) -&gt; {
2253                 pendingRefreshLocation.compareAndSet(location, null);
2254                 listener.accept(true);
2255             });
2256         } else {
2257             listener.accept(false);
2258         }
2259     }
2260     public void addRefreshListener(Translog.Location location, Consumer&lt;Boolean&gt; listener) {
2261         final boolean readAllowed;
2262         if (isReadAllowed()) {
2263             readAllowed = true;
2264         } else {
2265             synchronized (postRecoveryMutex) {
2266                 readAllowed = isReadAllowed();
2267             }
2268         }
2269         if (readAllowed) {
2270             refreshListeners.addOrNotify(location, listener);
2271         } else {
2272             listener.accept(false);
2273         }
2274     }
2275     private static class RefreshMetricUpdater implements ReferenceManager.RefreshListener {
2276         private final MeanMetric refreshMetric;
2277         private long currentRefreshStartTime;
2278         private Thread callingThread = null;
2279         private RefreshMetricUpdater(MeanMetric refreshMetric) {
2280             this.refreshMetric = refreshMetric;
2281         }
2282         @Override
2283         public void beforeRefresh() throws IOException {
2284             if (Assertions.ENABLED) {
2285                 assert callingThread == null : "beforeRefresh was called by " + callingThread.getName() +
2286                     " without a corresponding call to afterRefresh";
2287                 callingThread = Thread.currentThread();
2288             }
2289             currentRefreshStartTime = System.nanoTime();
2290         }
2291         @Override
2292         public void afterRefresh(boolean didRefresh) throws IOException {
2293             if (Assertions.ENABLED) {
2294                 assert callingThread != null : "afterRefresh called but not beforeRefresh";
2295                 assert callingThread == Thread.currentThread() : "beforeRefreshed called by a different thread. current ["
2296                     + Thread.currentThread().getName() + "], thread that called beforeRefresh [" + callingThread.getName() + "]";
2297                 callingThread = null;
2298             }
2299             refreshMetric.inc(System.nanoTime() - currentRefreshStartTime);
2300         }
2301     }
2302     private EngineConfig.TombstoneDocSupplier tombstoneDocSupplier() {
2303         final RootObjectMapper.Builder noopRootMapper = new RootObjectMapper.Builder("default");
2304         final DocumentMapper noopDocumentMapper = mapperService == null
2305             ? null
2306             : new DocumentMapper.Builder(noopRootMapper, mapperService).build(mapperService);
2307         return new EngineConfig.TombstoneDocSupplier() {
2308             @Override
2309             public ParsedDocument newDeleteTombstoneDoc(String id) {
2310                 return mapperService.documentMapper().createDeleteTombstoneDoc(shardId.getIndexName(), id);
2311             }
2312             @Override
2313             public ParsedDocument newNoopTombstoneDoc(String reason) {
2314                 return noopDocumentMapper.createNoopTombstoneDoc(shardId.getIndexName(), reason);
2315             }
2316         };
2317     }
2318     void resetEngineToGlobalCheckpoint() throws IOException {
2319         assert Thread.holdsLock(mutex) == false : "resetting engine under mutex";
2320         assert getActiveOperationsCount() == OPERATIONS_BLOCKED
2321             : "resetting engine without blocking operations; active operations are [" + getActiveOperations() + ']';
2322         sync();         final SeqNoStats seqNoStats = seqNoStats();
2323         final TranslogStats translogStats = translogStats();
2324         flush(new FlushRequest().waitIfOngoing(true));
2325         SetOnce&lt;Engine&gt; newEngineReference = new SetOnce&lt;&gt;();
2326         final long globalCheckpoint = getLastKnownGlobalCheckpoint();
2327         assert globalCheckpoint == getLastSyncedGlobalCheckpoint();
2328         synchronized (engineMutex) {
2329             verifyNotClosed();
2330             final Engine readOnlyEngine =
2331                 new ReadOnlyEngine(newEngineConfig(replicationTracker), seqNoStats, translogStats, false, Function.identity()) {
2332                     @Override
2333                     public IndexCommitRef acquireLastIndexCommit(boolean flushFirst) {
2334                         synchronized (engineMutex) {
2335                             if (newEngineReference.get() == null) {
2336                                 throw new AlreadyClosedException("engine was closed");
2337                             }
2338                             return newEngineReference.get().acquireLastIndexCommit(false);
2339                         }
2340                     }
2341                     @Override
2342                     public IndexCommitRef acquireSafeIndexCommit() {
2343                         synchronized (engineMutex) {
2344                             if (newEngineReference.get() == null) {
2345                                 throw new AlreadyClosedException("engine was closed");
2346                             }
2347                             return newEngineReference.get().acquireSafeIndexCommit();
2348                         }
2349                     }
2350                     @Override
2351                     public void close() throws IOException {
2352                         assert Thread.holdsLock(engineMutex);
2353                         Engine newEngine = newEngineReference.get();
2354                         if (newEngine == currentEngineReference.get()) {
2355                             newEngine = null;
2356                         }
2357                         IOUtils.close(super::close, newEngine);
2358                     }
2359                 };
2360             IOUtils.close(currentEngineReference.getAndSet(readOnlyEngine));
2361             newEngineReference.set(engineFactory.newReadWriteEngine(newEngineConfig(replicationTracker)));
2362             onNewEngine(newEngineReference.get());
2363         }
2364         final Engine.TranslogRecoveryRunner translogRunner = (engine, snapshot) -&gt; runTranslogRecovery(
2365             engine, snapshot, Engine.Operation.Origin.LOCAL_RESET, () -&gt; {
2366             });
2367         newEngineReference.get().recoverFromTranslog(translogRunner, globalCheckpoint);
2368         newEngineReference.get().refresh("reset_engine");
2369         synchronized (engineMutex) {
2370             verifyNotClosed();
2371             IOUtils.close(currentEngineReference.getAndSet(newEngineReference.get()));
2372             active.set(true);
2373         }
2374         onSettingsChanged();
2375     }
2376     public long getMaxSeqNoOfUpdatesOrDeletes() {
2377         return getEngine().getMaxSeqNoOfUpdatesOrDeletes();
2378     }
2379     public void advanceMaxSeqNoOfUpdatesOrDeletes(long seqNo) {
2380         getEngine().advanceMaxSeqNoOfUpdatesOrDeletes(seqNo);
2381     }
2382     public void verifyShardBeforeIndexClosing() throws IllegalStateException {
2383         getEngine().verifyEngineBeforeIndexClosing();
2384     }
2385     public MeanMetric getFlushMetric() {
2386         return flushMetric;
2387     }
2388     public long periodicFlushCount() {
2389         return periodicFlushMetric.count();
2390     }
2391 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
