<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for RowN.java & IncrementalClusterStateWriter.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for RowN.java & IncrementalClusterStateWriter.java
      </h3>
      <h1 align="center">
        10.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>RowN.java (50.0%)<TH>IncrementalClusterStateWriter.java (6.0215054%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2035820-0.html#0',2,'match2035820-1.html#0',3)" NAME="0">(37-45)<TD><A HREF="javascript:ZweiFrames('match2035820-0.html#0',2,'match2035820-1.html#0',3)" NAME="0">(336-344)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2035820-0.html#1',2,'match2035820-1.html#1',3)" NAME="1">(61-66)<TD><A HREF="javascript:ZweiFrames('match2035820-0.html#1',2,'match2035820-1.html#1',3)" NAME="1">(356-361)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2035820-0.html#2',2,'match2035820-1.html#2',3)" NAME="2">(31-35)<TD><A HREF="javascript:ZweiFrames('match2035820-0.html#2',2,'match2035820-1.html#2',3)" NAME="2">(73-77)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RowN.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.data;

import java.util.Arrays;

public class RowN extends Row {

<A NAME="2"></A>    private final int size;
    private Object[] cells;

    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match2035820-1.html#2',3,'match2035820-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>public RowN(int size) {
        this.size = size;
    }
<A NAME="0"></A>
    public RowN(Object ... cells) {</B></FONT>
        this(cells.length);
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2035820-1.html#0',3,'match2035820-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>this.cells = cells;
    }

    @Override
    public int numColumns() {
        return size;
    }

    publi</B></FONT>c void cells(Object[] cells) {
        assert cells != null : &quot;cells must not be null&quot;;
        this.cells = cells;
    }

    @Override
    public Object get(int index) {
        assert cells != null : &quot;cells must not be null&quot;;
        return cells[index];
    }

    @Override
    public Object[] materialize() {
<A NAME="1"></A>        Object[] result = new Object[size];
        System.arraycopy(cells, 0, result, 0, size);
        return result;
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2035820-1.html#1',3,'match2035820-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public String toString() {
        return &quot;RowN{&quot; + Arrays.toString(cells) + '}';
    }</B></FONT>
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IncrementalClusterStateWriter.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.gateway;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.Manifest;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.routing.RoutingNode;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.common.settings.ClusterSettings;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.index.Index;

import io.crate.common.unit.TimeValue;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.LongSupplier;

/**
 * Tracks the metadata written to disk, allowing updated metadata to be written incrementally (i.e. only writing out the changed metadata).
 */
public class IncrementalClusterStateWriter {

    private static final Logger LOGGER = LogManager.getLogger(IncrementalClusterStateWriter.class);

    private final MetaStateService metaStateService;

    // We call updateClusterState on the (unique) cluster applier thread so there's no need to synchronize access to these fields.
    private Manifest previousManifest;
    private ClusterState previousClusterState;
    private final LongSupplier relativeTimeMillisSupplier;
    private boolean incrementalWrite;

    private volatile TimeValue slowWriteLoggingThreshold;

    IncrementalClusterStateWriter(Settings settings, ClusterSettings clusterSettings, MetaStateService metaStateService, Manifest manifest,
                                  ClusterState clusterState, LongSupplier relativeTimeMillisSupplier) {
        this.metaStateService = metaStateService;
        this.previousManifest = manifest;
        this.previousClusterState = clusterState;
        this.relativeTimeMillisSupplier = relativeTimeMillisSupplier;
        this.incrementalWrite = false;
        this.slowWriteLoggingThreshold = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(settings);
        clusterSettings.addSettingsUpdateConsumer(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD,
<A NAME="2"></A>            this::setSlowWriteLoggingThreshold);
    }

    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2035820-0.html#2',2,'match2035820-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private void setSlowWriteLoggingThreshold(TimeValue slowWriteLoggingThreshold) {
        this.slowWriteLoggingThreshold = slowWriteLoggingThreshold;
    }

    void setCurrentTerm(long currentTerm) throws WriteStateException {</B></FONT>
        Manifest manifest = new Manifest(currentTerm, previousManifest.getClusterStateVersion(), previousManifest.getGlobalGeneration(),
            new HashMap&lt;&gt;(previousManifest.getIndexGenerations()));
        metaStateService.writeManifestAndCleanup(&quot;current term changed&quot;, manifest);
        previousManifest = manifest;
    }

    Manifest getPreviousManifest() {
        return previousManifest;
    }

    void setIncrementalWrite(boolean incrementalWrite) {
        this.incrementalWrite = incrementalWrite;
    }

    /**
     * Updates manifest and meta data on disk.
     *
     * @param newState new {@link ClusterState}
     *
     * @throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.
     */
    void updateClusterState(ClusterState newState) throws WriteStateException {
        Metadata newMetadata = newState.metadata();

        final long startTimeMillis = relativeTimeMillisSupplier.getAsLong();

        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest);
        long globalStateGeneration = writeGlobalState(writer, newMetadata);
        Map&lt;Index, Long&gt; indexGenerations = writeIndicesMetadata(writer, newState);
        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations);
        writeManifest(writer, manifest);
        previousManifest = manifest;
        previousClusterState = newState;

        final long durationMillis = relativeTimeMillisSupplier.getAsLong() - startTimeMillis;
        final TimeValue finalSlowWriteLoggingThreshold = this.slowWriteLoggingThreshold;
        if (durationMillis &gt;= finalSlowWriteLoggingThreshold.getMillis()) {
            LOGGER.warn(&quot;writing cluster state took [{}ms] which is above the warn threshold of [{}]; &quot; +
                    &quot;wrote metadata for [{}] indices and skipped [{}] unchanged indices&quot;,
                durationMillis, finalSlowWriteLoggingThreshold, writer.getIndicesWritten(), writer.getIndicesSkipped());
        } else {
            LOGGER.debug(&quot;writing cluster state took [{}ms]; wrote metadata for [{}] indices and skipped [{}] unchanged indices&quot;,
                durationMillis, writer.getIndicesWritten(), writer.getIndicesSkipped());
        }
    }

    private void writeManifest(AtomicClusterStateWriter writer, Manifest manifest) throws WriteStateException {
        if (manifest.equals(previousManifest) == false) {
            writer.writeManifestAndCleanup(&quot;changed&quot;, manifest);
        }
    }

    private Map&lt;Index, Long&gt; writeIndicesMetadata(AtomicClusterStateWriter writer, ClusterState newState)
        throws WriteStateException {
        Map&lt;Index, Long&gt; previouslyWrittenIndices = previousManifest.getIndexGenerations();
        Set&lt;Index&gt; relevantIndices = getRelevantIndices(newState);

        Map&lt;Index, Long&gt; newIndices = new HashMap&lt;&gt;();

        Metadata previousMetadata = incrementalWrite ? previousClusterState.metadata() : null;
        Iterable&lt;IndexMetadataAction&gt; actions = resolveIndexMetadataActions(previouslyWrittenIndices, relevantIndices, previousMetadata,
            newState.metadata());

        for (IndexMetadataAction action : actions) {
            long generation = action.execute(writer);
            newIndices.put(action.getIndex(), generation);
        }

        return newIndices;
    }

    private long writeGlobalState(AtomicClusterStateWriter writer, Metadata newMetadata) throws WriteStateException {
        if (incrementalWrite == false || Metadata.isGlobalStateEquals(previousClusterState.metadata(), newMetadata) == false) {
            return writer.writeGlobalState(&quot;changed&quot;, newMetadata);
        }
        return previousManifest.getGlobalGeneration();
    }


    /**
     * Returns list of {@link IndexMetadataAction} for each relevant index.
     * For each relevant index there are 3 options:
     * &lt;ol&gt;
     * &lt;li&gt;
     * {@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no
     * action is required.
     * &lt;/li&gt;
     * &lt;li&gt;
     * {@link WriteNewIndexMetadata} - there is no index metadata on disk and index metadata for this index should be written.
     * &lt;/li&gt;
     * &lt;li&gt;
     * {@link WriteChangedIndexMetadata} - index metadata is already on disk, but index metadata version has changed. Updated
     * index metadata should be written to disk.
     * &lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param previouslyWrittenIndices A list of indices for which the state was already written before
     * @param relevantIndices          The list of indices for which state should potentially be written
     * @param previousMetadata         The last meta data we know of
     * @param newMetadata              The new metadata
     * @return list of {@link IndexMetadataAction} for each relevant index.
     */
    // exposed for tests
    static List&lt;IndexMetadataAction&gt; resolveIndexMetadataActions(Map&lt;Index, Long&gt; previouslyWrittenIndices,
                                                                 Set&lt;Index&gt; relevantIndices,
                                                                 Metadata previousMetadata,
                                                                 Metadata newMetadata) {
        List&lt;IndexMetadataAction&gt; actions = new ArrayList&lt;&gt;();
        for (Index index : relevantIndices) {
            IndexMetadata newIndexMetadata = newMetadata.getIndexSafe(index);
            IndexMetadata previousIndexMetadata = previousMetadata == null ? null : previousMetadata.index(index);

            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetadata == null) {
                actions.add(new WriteNewIndexMetadata(newIndexMetadata));
            } else if (previousIndexMetadata.getVersion() != newIndexMetadata.getVersion()) {
                actions.add(new WriteChangedIndexMetadata(previousIndexMetadata, newIndexMetadata));
            } else {
                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)));
            }
        }
        return actions;
    }

    static Set&lt;Index&gt; getRelevantIndices(ClusterState state) {
        assert state.nodes().getLocalNode().isDataNode();
        final RoutingNode newRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId());
        if (newRoutingNode == null) {
            throw new IllegalStateException(&quot;cluster state does not contain this node - cannot write index meta state&quot;);
        }
        final Set&lt;Index&gt; indices = new HashSet&lt;&gt;();
        for (final ShardRouting routing : newRoutingNode) {
            indices.add(routing.index());
        }
        return indices;
    }

    /**
     * Action to perform with index metadata.
     */
    interface IndexMetadataAction {
        /**
         * @return index for index metadata.
         */
        Index getIndex();

        /**
         * Executes this action using provided {@link AtomicClusterStateWriter}.
         *
         * @return new index metadata state generation, to be used in manifest file.
         * @throws WriteStateException if exception occurs.
         */
        long execute(AtomicClusterStateWriter writer) throws WriteStateException;
    }

    /**
     * This class is used to write changed global {@link Metadata}, {@link IndexMetadata} and {@link Manifest} to disk.
     * This class delegates &lt;code&gt;write*&lt;/code&gt; calls to corresponding write calls in {@link MetaStateService} and
     * additionally it keeps track of cleanup actions to be performed if transaction succeeds or fails.
     */
    static class AtomicClusterStateWriter {
        private static final String FINISHED_MSG = &quot;AtomicClusterStateWriter is finished&quot;;
        private final List&lt;Runnable&gt; commitCleanupActions;
        private final List&lt;Runnable&gt; rollbackCleanupActions;
        private final Manifest previousManifest;
        private final MetaStateService metaStateService;
        private boolean finished;

        private int indicesWritten;
        private int indicesSkipped;

        AtomicClusterStateWriter(MetaStateService metaStateService, Manifest previousManifest) {
            this.metaStateService = metaStateService;
            assert previousManifest != null;
            this.previousManifest = previousManifest;
            this.commitCleanupActions = new ArrayList&lt;&gt;();
            this.rollbackCleanupActions = new ArrayList&lt;&gt;();
            this.finished = false;
        }

        long writeGlobalState(String reason, Metadata metadata) throws WriteStateException {
            assert finished == false : FINISHED_MSG;
            try {
                rollbackCleanupActions.add(() -&gt; metaStateService.cleanupGlobalState(previousManifest.getGlobalGeneration()));
                long generation = metaStateService.writeGlobalState(reason, metadata);
                commitCleanupActions.add(() -&gt; metaStateService.cleanupGlobalState(generation));
                return generation;
            } catch (WriteStateException e) {
                rollback();
                throw e;
            }
        }

        long writeIndex(String reason, IndexMetadata metadata) throws WriteStateException {
            assert finished == false : FINISHED_MSG;
            try {
                Index index = metadata.getIndex();
                Long previousGeneration = previousManifest.getIndexGenerations().get(index);
                if (previousGeneration != null) {
                    // we prefer not to clean-up index metadata in case of rollback,
                    // if it's not referenced by previous manifest file
                    // not to break dangling indices functionality
                    rollbackCleanupActions.add(() -&gt; metaStateService.cleanupIndex(index, previousGeneration));
                }
                long generation = metaStateService.writeIndex(reason, metadata);
                commitCleanupActions.add(() -&gt; metaStateService.cleanupIndex(index, generation));
                return generation;
            } catch (WriteStateException e) {
                rollback();
                throw e;
            }
        }

        void writeManifestAndCleanup(String reason, Manifest manifest) throws WriteStateException {
            assert finished == false : FINISHED_MSG;
            try {
                metaStateService.writeManifestAndCleanup(reason, manifest);
                commitCleanupActions.forEach(Runnable::run);
                finished = true;
            } catch (WriteStateException e) {
                // If the Manifest write results in a dirty WriteStateException it's not safe to roll back, removing the new metadata files,
                // because if the Manifest was actually written to disk and its deletion fails it will reference these new metadata files.
                // On master-eligible nodes a dirty WriteStateException here is fatal to the node since we no longer really have any idea
                // what the state on disk is and the only sensible response is to start again from scratch.
                if (e.isDirty() == false) {
                    rollback();
                }
                throw e;
            }
        }

        void rollback() {
            rollbackCleanupActions.forEach(Runnable::run);
            finished = true;
        }

        void incrementIndicesWritten() {
            indicesWritten++;
        }

        void incrementIndicesSkipped() {
            indicesSkipped++;
        }

        int getIndicesWritten() {
            return indicesWritten;
        }

        int getIndicesSkipped() {
            return indicesSkipped;
        }
    }

    static class KeepPreviousGeneration implements IndexMetadataAction {
        private final Index index;
        private final long generation;
<A NAME="0"></A>
        KeepPreviousGeneration(Index index, long generation) {
            this.index = index;
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2035820-0.html#0',2,'match2035820-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.generation = generation;
        }

        @Override
        public Index getIndex() {
            return index;
        }

        @Overri</B></FONT>de
        public long execute(AtomicClusterStateWriter writer) {
            writer.incrementIndicesSkipped();
            return generation;
        }
    }

    static class WriteNewIndexMetadata implements IndexMetadataAction {
        private final IndexMetadata indexMetadata;
<A NAME="1"></A>
        WriteNewIndexMetadata(IndexMetadata indexMetadata) {
            this.indexMetadata = indexMetadata;
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2035820-0.html#1',2,'match2035820-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        @Override
        public Index getIndex() {
            return indexMetadata.getIndex();
        }</B></FONT>

        @Override
        public long execute(AtomicClusterStateWriter writer) throws WriteStateException {
            writer.incrementIndicesWritten();
            return writer.writeIndex(&quot;freshly created&quot;, indexMetadata);
        }
    }

    static class WriteChangedIndexMetadata implements IndexMetadataAction {
        private final IndexMetadata newIndexMetadata;
        private final IndexMetadata oldIndexMetadata;

        WriteChangedIndexMetadata(IndexMetadata oldIndexMetadata, IndexMetadata newIndexMetadata) {
            this.oldIndexMetadata = oldIndexMetadata;
            this.newIndexMetadata = newIndexMetadata;
        }

        @Override
        public Index getIndex() {
            return newIndexMetadata.getIndex();
        }

        @Override
        public long execute(AtomicClusterStateWriter writer) throws WriteStateException {
            writer.incrementIndicesWritten();
            return writer.writeIndex(
                    &quot;version changed from [&quot; + oldIndexMetadata.getVersion() + &quot;] to [&quot; + newIndexMetadata.getVersion() + &quot;]&quot;,
                    newIndexMetadata);
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
