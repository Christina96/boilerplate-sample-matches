<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RowN.java &amp; IncrementalClusterStateWriter.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RowN.java &amp; IncrementalClusterStateWriter.java
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RowN.java (50.0%)<th>IncrementalClusterStateWriter.java (6.0215054%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(37-45)<td><a href="#" name="0">(336-344)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(61-66)<td><a href="#" name="1">(356-361)</a><td align="center"><font color="#e50000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(31-35)<td><a href="#" name="2">(73-77)</a><td align="center"><font color="#e50000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RowN.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.data;
2 import java.util.Arrays;
3 public class RowN extends Row {
4 <a name="2"></a>    private final int size;
5     private Object[] cells;
6     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public RowN(int size) {
7         this.size = size;
8     }
9 <a name="0"></a>
10     public RowN(Object ... cells) {</b></font>
11         this(cells.length);
12         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>this.cells = cells;
13     }
14     @Override
15     public int numColumns() {
16         return size;
17     }
18     publi</b></font>c void cells(Object[] cells) {
19         assert cells != null : "cells must not be null";
20         this.cells = cells;
21     }
22     @Override
23     public Object get(int index) {
24         assert cells != null : "cells must not be null";
25         return cells[index];
26     }
27     @Override
28     public Object[] materialize() {
29 <a name="1"></a>        Object[] result = new Object[size];
30         System.arraycopy(cells, 0, result, 0, size);
31         return result;
32     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
33     @Override
34     public String toString() {
35         return "RowN{" + Arrays.toString(cells) + '}';
36     }</b></font>
37 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IncrementalClusterStateWriter.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.gateway;
2 import org.apache.logging.log4j.LogManager;
3 import org.apache.logging.log4j.Logger;
4 import org.elasticsearch.cluster.ClusterState;
5 import org.elasticsearch.cluster.metadata.IndexMetadata;
6 import org.elasticsearch.cluster.metadata.Manifest;
7 import org.elasticsearch.cluster.metadata.Metadata;
8 import org.elasticsearch.cluster.routing.RoutingNode;
9 import org.elasticsearch.cluster.routing.ShardRouting;
10 import org.elasticsearch.common.settings.ClusterSettings;
11 import org.elasticsearch.common.settings.Settings;
12 import org.elasticsearch.index.Index;
13 import io.crate.common.unit.TimeValue;
14 import java.util.ArrayList;
15 import java.util.HashMap;
16 import java.util.HashSet;
17 import java.util.List;
18 import java.util.Map;
19 import java.util.Set;
20 import java.util.function.LongSupplier;
21 public class IncrementalClusterStateWriter {
22     private static final Logger LOGGER = LogManager.getLogger(IncrementalClusterStateWriter.class);
23     private final MetaStateService metaStateService;
24     private Manifest previousManifest;
25     private ClusterState previousClusterState;
26     private final LongSupplier relativeTimeMillisSupplier;
27     private boolean incrementalWrite;
28     private volatile TimeValue slowWriteLoggingThreshold;
29     IncrementalClusterStateWriter(Settings settings, ClusterSettings clusterSettings, MetaStateService metaStateService, Manifest manifest,
30                                   ClusterState clusterState, LongSupplier relativeTimeMillisSupplier) {
31         this.metaStateService = metaStateService;
32         this.previousManifest = manifest;
33         this.previousClusterState = clusterState;
34         this.relativeTimeMillisSupplier = relativeTimeMillisSupplier;
35         this.incrementalWrite = false;
36         this.slowWriteLoggingThreshold = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(settings);
37         clusterSettings.addSettingsUpdateConsumer(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD,
38 <a name="2"></a>            this::setSlowWriteLoggingThreshold);
39     }
40     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private void setSlowWriteLoggingThreshold(TimeValue slowWriteLoggingThreshold) {
41         this.slowWriteLoggingThreshold = slowWriteLoggingThreshold;
42     }
43     void setCurrentTerm(long currentTerm) throws WriteStateException {</b></font>
44         Manifest manifest = new Manifest(currentTerm, previousManifest.getClusterStateVersion(), previousManifest.getGlobalGeneration(),
45             new HashMap&lt;&gt;(previousManifest.getIndexGenerations()));
46         metaStateService.writeManifestAndCleanup("current term changed", manifest);
47         previousManifest = manifest;
48     }
49     Manifest getPreviousManifest() {
50         return previousManifest;
51     }
52     void setIncrementalWrite(boolean incrementalWrite) {
53         this.incrementalWrite = incrementalWrite;
54     }
55     void updateClusterState(ClusterState newState) throws WriteStateException {
56         Metadata newMetadata = newState.metadata();
57         final long startTimeMillis = relativeTimeMillisSupplier.getAsLong();
58         final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest);
59         long globalStateGeneration = writeGlobalState(writer, newMetadata);
60         Map&lt;Index, Long&gt; indexGenerations = writeIndicesMetadata(writer, newState);
61         Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations);
62         writeManifest(writer, manifest);
63         previousManifest = manifest;
64         previousClusterState = newState;
65         final long durationMillis = relativeTimeMillisSupplier.getAsLong() - startTimeMillis;
66         final TimeValue finalSlowWriteLoggingThreshold = this.slowWriteLoggingThreshold;
67         if (durationMillis &gt;= finalSlowWriteLoggingThreshold.getMillis()) {
68             LOGGER.warn("writing cluster state took [{}ms] which is above the warn threshold of [{}]; " +
69                     "wrote metadata for [{}] indices and skipped [{}] unchanged indices",
70                 durationMillis, finalSlowWriteLoggingThreshold, writer.getIndicesWritten(), writer.getIndicesSkipped());
71         } else {
72             LOGGER.debug("writing cluster state took [{}ms]; wrote metadata for [{}] indices and skipped [{}] unchanged indices",
73                 durationMillis, writer.getIndicesWritten(), writer.getIndicesSkipped());
74         }
75     }
76     private void writeManifest(AtomicClusterStateWriter writer, Manifest manifest) throws WriteStateException {
77         if (manifest.equals(previousManifest) == false) {
78             writer.writeManifestAndCleanup("changed", manifest);
79         }
80     }
81     private Map&lt;Index, Long&gt; writeIndicesMetadata(AtomicClusterStateWriter writer, ClusterState newState)
82         throws WriteStateException {
83         Map&lt;Index, Long&gt; previouslyWrittenIndices = previousManifest.getIndexGenerations();
84         Set&lt;Index&gt; relevantIndices = getRelevantIndices(newState);
85         Map&lt;Index, Long&gt; newIndices = new HashMap&lt;&gt;();
86         Metadata previousMetadata = incrementalWrite ? previousClusterState.metadata() : null;
87         Iterable&lt;IndexMetadataAction&gt; actions = resolveIndexMetadataActions(previouslyWrittenIndices, relevantIndices, previousMetadata,
88             newState.metadata());
89         for (IndexMetadataAction action : actions) {
90             long generation = action.execute(writer);
91             newIndices.put(action.getIndex(), generation);
92         }
93         return newIndices;
94     }
95     private long writeGlobalState(AtomicClusterStateWriter writer, Metadata newMetadata) throws WriteStateException {
96         if (incrementalWrite == false || Metadata.isGlobalStateEquals(previousClusterState.metadata(), newMetadata) == false) {
97             return writer.writeGlobalState("changed", newMetadata);
98         }
99         return previousManifest.getGlobalGeneration();
100     }
101     static List&lt;IndexMetadataAction&gt; resolveIndexMetadataActions(Map&lt;Index, Long&gt; previouslyWrittenIndices,
102                                                                  Set&lt;Index&gt; relevantIndices,
103                                                                  Metadata previousMetadata,
104                                                                  Metadata newMetadata) {
105         List&lt;IndexMetadataAction&gt; actions = new ArrayList&lt;&gt;();
106         for (Index index : relevantIndices) {
107             IndexMetadata newIndexMetadata = newMetadata.getIndexSafe(index);
108             IndexMetadata previousIndexMetadata = previousMetadata == null ? null : previousMetadata.index(index);
109             if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetadata == null) {
110                 actions.add(new WriteNewIndexMetadata(newIndexMetadata));
111             } else if (previousIndexMetadata.getVersion() != newIndexMetadata.getVersion()) {
112                 actions.add(new WriteChangedIndexMetadata(previousIndexMetadata, newIndexMetadata));
113             } else {
114                 actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)));
115             }
116         }
117         return actions;
118     }
119     static Set&lt;Index&gt; getRelevantIndices(ClusterState state) {
120         assert state.nodes().getLocalNode().isDataNode();
121         final RoutingNode newRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId());
122         if (newRoutingNode == null) {
123             throw new IllegalStateException("cluster state does not contain this node - cannot write index meta state");
124         }
125         final Set&lt;Index&gt; indices = new HashSet&lt;&gt;();
126         for (final ShardRouting routing : newRoutingNode) {
127             indices.add(routing.index());
128         }
129         return indices;
130     }
131     interface IndexMetadataAction {
132         Index getIndex();
133         long execute(AtomicClusterStateWriter writer) throws WriteStateException;
134     }
135     static class AtomicClusterStateWriter {
136         private static final String FINISHED_MSG = "AtomicClusterStateWriter is finished";
137         private final List&lt;Runnable&gt; commitCleanupActions;
138         private final List&lt;Runnable&gt; rollbackCleanupActions;
139         private final Manifest previousManifest;
140         private final MetaStateService metaStateService;
141         private boolean finished;
142         private int indicesWritten;
143         private int indicesSkipped;
144         AtomicClusterStateWriter(MetaStateService metaStateService, Manifest previousManifest) {
145             this.metaStateService = metaStateService;
146             assert previousManifest != null;
147             this.previousManifest = previousManifest;
148             this.commitCleanupActions = new ArrayList&lt;&gt;();
149             this.rollbackCleanupActions = new ArrayList&lt;&gt;();
150             this.finished = false;
151         }
152         long writeGlobalState(String reason, Metadata metadata) throws WriteStateException {
153             assert finished == false : FINISHED_MSG;
154             try {
155                 rollbackCleanupActions.add(() -&gt; metaStateService.cleanupGlobalState(previousManifest.getGlobalGeneration()));
156                 long generation = metaStateService.writeGlobalState(reason, metadata);
157                 commitCleanupActions.add(() -&gt; metaStateService.cleanupGlobalState(generation));
158                 return generation;
159             } catch (WriteStateException e) {
160                 rollback();
161                 throw e;
162             }
163         }
164         long writeIndex(String reason, IndexMetadata metadata) throws WriteStateException {
165             assert finished == false : FINISHED_MSG;
166             try {
167                 Index index = metadata.getIndex();
168                 Long previousGeneration = previousManifest.getIndexGenerations().get(index);
169                 if (previousGeneration != null) {
170                     rollbackCleanupActions.add(() -&gt; metaStateService.cleanupIndex(index, previousGeneration));
171                 }
172                 long generation = metaStateService.writeIndex(reason, metadata);
173                 commitCleanupActions.add(() -&gt; metaStateService.cleanupIndex(index, generation));
174                 return generation;
175             } catch (WriteStateException e) {
176                 rollback();
177                 throw e;
178             }
179         }
180         void writeManifestAndCleanup(String reason, Manifest manifest) throws WriteStateException {
181             assert finished == false : FINISHED_MSG;
182             try {
183                 metaStateService.writeManifestAndCleanup(reason, manifest);
184                 commitCleanupActions.forEach(Runnable::run);
185                 finished = true;
186             } catch (WriteStateException e) {
187                 if (e.isDirty() == false) {
188                     rollback();
189                 }
190                 throw e;
191             }
192         }
193         void rollback() {
194             rollbackCleanupActions.forEach(Runnable::run);
195             finished = true;
196         }
197         void incrementIndicesWritten() {
198             indicesWritten++;
199         }
200         void incrementIndicesSkipped() {
201             indicesSkipped++;
202         }
203         int getIndicesWritten() {
204             return indicesWritten;
205         }
206         int getIndicesSkipped() {
207             return indicesSkipped;
208         }
209     }
210     static class KeepPreviousGeneration implements IndexMetadataAction {
211         private final Index index;
212         private final long generation;
213 <a name="0"></a>
214         KeepPreviousGeneration(Index index, long generation) {
215             this.index = index;
216             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>this.generation = generation;
217         }
218         @Override
219         public Index getIndex() {
220             return index;
221         }
222         @Overri</b></font>de
223         public long execute(AtomicClusterStateWriter writer) {
224             writer.incrementIndicesSkipped();
225             return generation;
226         }
227     }
228     static class WriteNewIndexMetadata implements IndexMetadataAction {
229         private final IndexMetadata indexMetadata;
230 <a name="1"></a>
231         WriteNewIndexMetadata(IndexMetadata indexMetadata) {
232             this.indexMetadata = indexMetadata;
233         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
234         @Override
235         public Index getIndex() {
236             return indexMetadata.getIndex();
237         }</b></font>
238         @Override
239         public long execute(AtomicClusterStateWriter writer) throws WriteStateException {
240             writer.incrementIndicesWritten();
241             return writer.writeIndex("freshly created", indexMetadata);
242         }
243     }
244     static class WriteChangedIndexMetadata implements IndexMetadataAction {
245         private final IndexMetadata newIndexMetadata;
246         private final IndexMetadata oldIndexMetadata;
247         WriteChangedIndexMetadata(IndexMetadata oldIndexMetadata, IndexMetadata newIndexMetadata) {
248             this.oldIndexMetadata = oldIndexMetadata;
249             this.newIndexMetadata = newIndexMetadata;
250         }
251         @Override
252         public Index getIndex() {
253             return newIndexMetadata.getIndex();
254         }
255         @Override
256         public long execute(AtomicClusterStateWriter writer) throws WriteStateException {
257             writer.incrementIndicesWritten();
258             return writer.writeIndex(
259                     "version changed from [" + oldIndexMetadata.getVersion() + "] to [" + newIndexMetadata.getVersion() + "]",
260                     newIndexMetadata);
261         }
262     }
263 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
