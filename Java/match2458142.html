<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for CompositeBytesReference.java & SubscriptValidator.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for CompositeBytesReference.java & SubscriptValidator.java
      </h3>
      <h1 align="center">
        9.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>CompositeBytesReference.java (10.0%)<TH>SubscriptValidator.java (8.52018%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2458142-0.html#0',2,'match2458142-1.html#0',3)" NAME="0">(75-82)<TD><A HREF="javascript:ZweiFrames('match2458142-0.html#0',2,'match2458142-1.html#0',3)" NAME="0">(147-154)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2458142-0.html#1',2,'match2458142-1.html#1',3)" NAME="1">(22-39)<TD><A HREF="javascript:ZweiFrames('match2458142-0.html#1',2,'match2458142-1.html#1',3)" NAME="1">(34-45)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CompositeBytesReference.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
<A NAME="1"></A>
package org.elasticsearch.common.bytes;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2458142-1.html#1',3,'match2458142-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.BytesRefBuilder;
import org.apache.lucene.util.BytesRefIterator;
import org.apache.lucene.util.RamUsageEstimator;

import java.io.IOException;
import java.util.Arrays;
import java.util.Objects;

/**
 * A composite {@link BytesReference} that allows joining multiple bytes references
 * into one without copying.
 *
 * Note, {@link #toBytesRef()} will materialize all pages in this BytesReference.
 */
public final class CompositeBytesReference extends AbstractBytesReference {

    private final BytesReference[] references</B></FONT>;
    private final int[] offsets;
    private final int length;
    private final long ramBytesUsed;

    public CompositeBytesReference(BytesReference... references) {
        this.references = Objects.requireNonNull(references, &quot;references must not be null&quot;);
        this.offsets = new int[references.length];
        long ramBytesUsed = 0;
        int offset = 0;
        for (int i = 0; i &lt; references.length; i++) {
            BytesReference reference = references[i];
            if (reference == null) {
                throw new IllegalArgumentException(&quot;references must not be null&quot;);
            }
            offsets[i] = offset; // we use the offsets to seek into the right BytesReference for random access and slicing
            offset += reference.length();
            ramBytesUsed += reference.ramBytesUsed();
        }
        this.ramBytesUsed = ramBytesUsed
            + (Integer.BYTES * offsets.length + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER) // offsets
            + (references.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER) // references
            + Integer.BYTES // length
            + Long.BYTES; // ramBytesUsed
        length = offset;
    }


    @Override
    public byte get(int index) {
        final int i = getOffsetIndex(index);
        return references[i].get(index - offsets[i]);
    }
<A NAME="0"></A>
    @Override
    public int length() {
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2458142-1.html#0',3,'match2458142-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return length;
    }

    @Override
    public BytesReference slice(int from, int length) {
        Objects.checkFromIndexSize(from, length, this.length);

        if</B></FONT> (length == 0) {
            return BytesArray.EMPTY;
        }

        // for slices we only need to find the start and the end reference
        // adjust them and pass on the references in between as they are fully contained
        final int to = from + length;
        final int limit = getOffsetIndex(to - 1);
        final int start = getOffsetIndex(from);
        final BytesReference[] inSlice = new BytesReference[1 + (limit - start)];
        for (int i = 0, j = start; i &lt; inSlice.length; i++) {
            inSlice[i] = references[j++];
        }
        int inSliceOffset = from - offsets[start];
        if (inSlice.length == 1) {
            return inSlice[0].slice(inSliceOffset, length);
        }
        // now adjust slices in front and at the end
        inSlice[0] = inSlice[0].slice(inSliceOffset, inSlice[0].length() - inSliceOffset);
        inSlice[inSlice.length - 1] = inSlice[inSlice.length - 1].slice(0, to - offsets[limit]);
        return new CompositeBytesReference(inSlice);
    }

    private int getOffsetIndex(int offset) {
        final int i = Arrays.binarySearch(offsets, offset);
        return i &lt; 0 ? (-(i + 1)) - 1 : i;
    }

    @Override
    public BytesRef toBytesRef() {
        BytesRefBuilder builder = new BytesRefBuilder();
        builder.grow(length());
        BytesRef spare;
        BytesRefIterator iterator = iterator();
        try {
            while ((spare = iterator.next()) != null) {
                builder.append(spare);
            }
        } catch (IOException ex) {
            throw new AssertionError(&quot;won't happen&quot;, ex); // this is really an error since we don't do IO in our bytesreferences
        }
        return builder.toBytesRef();
    }

    @Override
    public BytesRefIterator iterator() {
        if (references.length &gt; 0) {
            return new BytesRefIterator() {
                int index = 0;
                private BytesRefIterator current = references[index++].iterator();
                @Override
                public BytesRef next() throws IOException {
                    BytesRef next = current.next();
                    if (next == null) {
                        while (index &lt; references.length) {
                            current = references[index++].iterator();
                            next = current.next();
                            if (next != null) {
                                break;
                            }
                        }
                    }
                    return next;
                }
            };
        } else {
            return () -&gt; null;
        }

    }

    @Override
    public long ramBytesUsed() {
        return ramBytesUsed;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SubscriptValidator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.analyze;

import io.crate.sql.tree.ArrayLiteral;
import io.crate.sql.tree.AstVisitor;
import io.crate.sql.tree.Cast;
import io.crate.sql.tree.ColumnType;
import io.crate.sql.tree.Expression;
import io.crate.sql.tree.FunctionCall;
import io.crate.sql.tree.IntegerLiteral;
<A NAME="1"></A>import io.crate.sql.tree.LongLiteral;
import io.crate.sql.tree.NegativeExpression;
import io.crate.sql.tree.ObjectLiteral;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2458142-0.html#1',2,'match2458142-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.crate.sql.tree.ParameterExpression;
import io.crate.sql.tree.QualifiedNameReference;
import io.crate.sql.tree.StringLiteral;
import io.crate.sql.tree.SubqueryExpression;
import io.crate.sql.tree.SubscriptExpression;
import io.crate.sql.tree.TryCast;

import java.util.Locale;

public final class SubscriptValidator {

    private static final Long MAX_VALUE = Integer.MAX_VALUE + 1L</B></FONT>;

    private SubscriptValidator() {
    }

    public static void validate(SubscriptExpression node, SubscriptContext subscriptContext) {
        node.accept(SubscriptNameVisitor.INSTANCE, subscriptContext);
    }

    private static class SubscriptNameVisitor extends AstVisitor&lt;Void, SubscriptContext&gt; {

        private static final SubscriptNameVisitor INSTANCE = new SubscriptNameVisitor();

        @Override
        protected Void visitSubscriptExpression(SubscriptExpression node, SubscriptContext context) {
            node.index().accept(SubscriptIndexVisitor.INSTANCE, context);
            node.base().accept(this, context);
            return null;
        }

        @Override
        protected Void visitQualifiedNameReference(QualifiedNameReference node, SubscriptContext context) {
            context.qualifiedName(node.getName());
            return null;
        }

        @Override
        public Void visitArrayLiteral(ArrayLiteral node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        public Void visitObjectLiteral(ObjectLiteral node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        protected Void visitCast(Cast node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        protected Void visitTryCast(TryCast node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        protected Void visitFunctionCall(FunctionCall node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        protected Void visitSubqueryExpression(SubqueryExpression node, SubscriptContext context) {
            context.expression(node);
            return null;
        }

        @Override
        protected Void visitExpression(Expression node, SubscriptContext context) {
            throw new UnsupportedOperationException(String.format(Locale.ENGLISH,
                &quot;An expression of type %s cannot have an index accessor ([])&quot;,
                node.getClass().getSimpleName()));
        }
    }

    private static class SubscriptIndexVisitor extends AstVisitor&lt;Void, SubscriptContext&gt; {

        private static final SubscriptIndexVisitor INSTANCE = new SubscriptIndexVisitor();

        private static void raiseInvalidIndexValue() {
            throw new UnsupportedOperationException(
                String.format(Locale.ENGLISH, &quot;Array index must be in range 1 to %s&quot;,
                              MAX_VALUE));
        }

        @Override
        public Void visitParameterExpression(ParameterExpression node, SubscriptContext context) {
            throw new UnsupportedOperationException(&quot;Parameter substitution is not supported in subscript index&quot;);
        }

        @Override
        protected Void visitStringLiteral(StringLiteral node, SubscriptContext context) {
            validateNestedArrayAccess(context);
            context.add(node.getValue());
            return null;
        }


        @Override
        protected Void visitLongLiteral(LongLiteral node, SubscriptContext context) {
            validateNestedArrayAccess(context);
            long value = node.getValue();

            if (value &lt; 1 || value &gt; MAX_VALUE) {
<A NAME="0"></A>                raiseInvalidIndexValue();
            }
            context.index(new Cast(node, new ColumnType&lt;&gt;(&quot;integer&quot;)));
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2458142-0.html#0',2,'match2458142-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return null;
        }


        @Override
        protected Void visitIntegerLiteral(IntegerLiteral node, SubscriptContext context) {
            validateNestedArrayAccess(context);
            if</B></FONT> (node.getValue() &lt; 1) {
                raiseInvalidIndexValue();
            }
            context.index(new Cast(node, new ColumnType&lt;&gt;(&quot;integer&quot;)));
            return null;
        }

        @Override
        protected Void visitNegativeExpression(NegativeExpression node, SubscriptContext context) {
            throw new UnsupportedOperationException(
                String.format(Locale.ENGLISH, &quot;Array index must be in range 1 to %s&quot;,
                    MAX_VALUE));
        }

        @Override
        protected Void visitExpression(Expression node, SubscriptContext context) {
            context.index(node);
            return null;
        }

        private void validateNestedArrayAccess(SubscriptContext context) {
            if (context.index() != null) {
                throw new UnsupportedOperationException(&quot;Nested array access is not supported&quot;);
            }
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
