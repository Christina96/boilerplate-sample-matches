<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FakeTimeLimiter.java &amp; ConcurrentHashMultisetBenchmark.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FakeTimeLimiter.java &amp; ConcurrentHashMultisetBenchmark.java
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FakeTimeLimiter.java (15.151515%)<th>ConcurrentHashMultisetBenchmark.java (2.9027576%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(76-82)<td><a href="#" name="0">(388-404)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(15-25)<td><a href="#" name="1">(17-27)</a><td align="center"><font color="#d00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FakeTimeLimiter.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.util.concurrent;
2 import static com.google.common.base.Preconditions.checkNotNull;
3 import com.google.common.annotations.Beta;
4 import com.google.common.annotations.GwtIncompatible;
5 import com.google.errorprone.annotations.CanIgnoreReturnValue;
6 import java.util.concurrent.Callable;
7 import java.util.concurrent.ExecutionException;
8 import java.util.concurrent.TimeUnit;
9 import</b></font> org.checkerframework.checker.nullness.qual.Nullable;
10 @Beta
11 @CanIgnoreReturnValue
12 @GwtIncompatible
13 @ElementTypesAreNonnullByDefault
14 public final class FakeTimeLimiter implements TimeLimiter {
15   @Override
16   public &lt;T&gt; T newProxy(
17       T target, Class&lt;T&gt; interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {
18     checkNotNull(target);
19     checkNotNull(interfaceType);
20     checkNotNull(timeoutUnit);
21     return target;   }
22   @Override
23   @ParametricNullness
24   public &lt;T extends @Nullable Object&gt; T callWithTimeout(
25       Callable&lt;T&gt; callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
26     checkNotNull(callable);
27     checkNotNull(timeoutUnit);
28     try {
29       return callable.call();
30     } catch (RuntimeException e) {
31       throw new UncheckedExecutionException(e);
32     } catch (Exception e) {
33       throw new ExecutionException(e);
34     } catch (Error e) {
35       throw new ExecutionError(e);
36     } catch (Throwable e) {
37       throw new ExecutionException(e);
38     }
39   }
40   @Override
41 <a name="0"></a>  @ParametricNullness
42   public &lt;T extends @Nullable Object&gt; T callUninterruptiblyWithTimeout(
43       Callable&lt;T&gt; callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
44     return <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>callWithTimeout(callable, timeoutDuration, timeoutUnit);
45   }
46   @Override
47   public void runWithTimeout(Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {
48     checkNotNull(runnable);
49     checkNotNull</b></font>(timeoutUnit);
50     try {
51       runnable.run();
52     } catch (RuntimeException e) {
53       throw new UncheckedExecutionException(e);
54     } catch (Error e) {
55       throw new ExecutionError(e);
56     } catch (Throwable e) {
57       throw new UncheckedExecutionException(e);
58     }
59   }
60   @Override
61   public void runUninterruptiblyWithTimeout(
62       Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {
63     runWithTimeout(runnable, timeoutDuration, timeoutUnit);
64   }
65 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConcurrentHashMultisetBenchmark.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
4 import com.google.caliper.BeforeExperiment;
5 import com.google.caliper.Benchmark;
6 import com.google.caliper.Param;
7 import com.google.common.annotations.VisibleForTesting;
8 import com.google.common.primitives.Ints;
9 import</b></font> com.google.common.util.concurrent.ThreadFactoryBuilder;
10 import java.util.Iterator;
11 import java.util.List;
12 import java.util.Map;
13 import java.util.Random;
14 import java.util.Set;
15 import java.util.concurrent.Callable;
16 import java.util.concurrent.ConcurrentHashMap;
17 import java.util.concurrent.ConcurrentMap;
18 import java.util.concurrent.ExecutionException;
19 import java.util.concurrent.ExecutorService;
20 import java.util.concurrent.Executors;
21 import java.util.concurrent.Future;
22 import org.checkerframework.checker.nullness.qual.Nullable;
23 public class ConcurrentHashMultisetBenchmark {
24   @Param({"1", "2", "4", "8"})
25   int threads;
26   @Param({"3", "30", "300"})
27   int size;
28   @Param MultisetSupplier implSupplier;
29   private Multiset&lt;Integer&gt; multiset;
30   private ImmutableList&lt;Integer&gt; keys;
31   private ExecutorService threadPool;
32   @BeforeExperiment
33   void setUp() throws Exception {
34     multiset = implSupplier.get();
35     ImmutableList.Builder&lt;Integer&gt; builder = ImmutableList.builder();
36     for (int i = 0; i &lt; size; i++) {
37       builder.add(i);
38     }
39     keys = builder.build();
40     threadPool =
41         Executors.newFixedThreadPool(threads, new ThreadFactoryBuilder().setDaemon(true).build());
42   }
43   @Benchmark
44   long add(final int reps) throws ExecutionException, InterruptedException {
45     return doMultithreadedLoop(
46         new Callable&lt;Long&gt;() {
47           @Override
48           public Long call() {
49             return runAddSingleThread(reps);
50           }
51         });
52   }
53   @Benchmark
54   long addRemove(final int reps) throws ExecutionException, InterruptedException {
55     return doMultithreadedLoop(
56         new Callable&lt;Long&gt;() {
57           @Override
58           public Long call() {
59             return runAddRemoveSingleThread(reps);
60           }
61         });
62   }
63   private long doMultithreadedLoop(Callable&lt;Long&gt; task)
64       throws InterruptedException, ExecutionException {
65     List&lt;Future&lt;Long&gt;&gt; futures = Lists.newArrayListWithCapacity(threads);
66     for (int i = 0; i &lt; threads; i++) {
67       futures.add(threadPool.submit(task));
68     }
69     long total = 0;
70     for (Future&lt;Long&gt; future : futures) {
71       total += future.get();
72     }
73     return total;
74   }
75   private long runAddSingleThread(int reps) {
76     Random random = new Random();
77     int nKeys = keys.size();
78     long blah = 0;
79     for (int i = 0; i &lt; reps; i++) {
80       Integer key = keys.get(random.nextInt(nKeys));
81       int delta = random.nextInt(5);
82       blah += delta;
83       multiset.add(key, delta);
84     }
85     return blah;
86   }
87   private long runAddRemoveSingleThread(int reps) {
88     Random random = new Random();
89     int nKeys = keys.size();
90     long blah = 0;
91     for (int i = 0; i &lt; reps; i++) {
92       Integer key = keys.get(random.nextInt(nKeys));
93       int delta = random.nextInt(10) - 5;
94       blah += delta;
95       if (delta &gt;= 0) {
96         multiset.add(key, delta);
97       } else {
98         multiset.remove(key, -delta);
99       }
100     }
101     return blah;
102   }
103   private enum MultisetSupplier {
104     CONCURRENT_HASH_MULTISET() {
105       @Override
106       Multiset&lt;Integer&gt; get() {
107         return ConcurrentHashMultiset.create();
108       }
109     },
110     BOXED_ATOMIC_REPLACE() {
111       @Override
112       Multiset&lt;Integer&gt; get() {
113         return OldConcurrentHashMultiset.create();
114       }
115     },
116     SYNCHRONIZED_MULTISET() {
117       @Override
118       Multiset&lt;Integer&gt; get() {
119         return Synchronized.multiset(HashMultiset.&lt;Integer&gt;create(), null);
120       }
121     },
122     ;
123     abstract Multiset&lt;Integer&gt; get();
124   }
125   private static final class OldConcurrentHashMultiset&lt;E&gt; extends AbstractMultiset&lt;E&gt; {
126     private final transient ConcurrentMap&lt;E, Integer&gt; countMap;
127     public static &lt;E&gt; OldConcurrentHashMultiset&lt;E&gt; create() {
128       return new OldConcurrentHashMultiset&lt;E&gt;(new ConcurrentHashMap&lt;E, Integer&gt;());
129     }
130     @VisibleForTesting
131     OldConcurrentHashMultiset(ConcurrentMap&lt;E, Integer&gt; countMap) {
132       checkArgument(countMap.isEmpty());
133       this.countMap = countMap;
134     }
135     @Override
136     public int count(@Nullable Object element) {
137       try {
138         return unbox(countMap.get(element));
139       } catch (NullPointerException | ClassCastException e) {
140         return 0;
141       }
142     }
143     @Override
144     public int size() {
145       long sum = 0L;
146       for (Integer value : countMap.values()) {
147         sum += value;
148       }
149       return Ints.saturatedCast(sum);
150     }
151     @Override
152     public Object[] toArray() {
153       return snapshot().toArray();
154     }
155     @Override
156     public &lt;T&gt; T[] toArray(T[] array) {
157       return snapshot().toArray(array);
158     }
159     private List&lt;E&gt; snapshot() {
160       List&lt;E&gt; list = Lists.newArrayListWithExpectedSize(size());
161       for (Multiset.Entry&lt;E&gt; entry : entrySet()) {
162         E element = entry.getElement();
163         for (int i = entry.getCount(); i &gt; 0; i--) {
164           list.add(element);
165         }
166       }
167       return list;
168     }
169     @Override
170     public int add(E element, int occurrences) {
171       if (occurrences == 0) {
172         return count(element);
173       }
174       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
175       while (true) {
176         int current = count(element);
177         if (current == 0) {
178           if (countMap.putIfAbsent(element, occurrences) == null) {
179             return 0;
180           }
181         } else {
182           checkArgument(
183               occurrences &lt;= Integer.MAX_VALUE - current,
184               "Overflow adding %s occurrences to a count of %s",
185               occurrences,
186               current);
187           int next = current + occurrences;
188           if (countMap.replace(element, current, next)) {
189             return current;
190           }
191         }
192       }
193     }
194     @Override
195     public int remove(@Nullable Object element, int occurrences) {
196       if (occurrences == 0) {
197         return count(element);
198       }
199       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
200       while (true) {
201         int current = count(element);
202         if (current == 0) {
203           return 0;
204         }
205         if (occurrences &gt;= current) {
206           if (countMap.remove(element, current)) {
207             return current;
208           }
209         } else {
210           @SuppressWarnings("unchecked")
211           E casted = (E) element;
212           if (countMap.replace(casted, current, current - occurrences)) {
213             return current;
214           }
215         }
216       }
217     }
218     private int removeAllOccurrences(@Nullable Object element) {
219       try {
220         return unbox(countMap.remove(element));
221       } catch (NullPointerException | ClassCastException e) {
222         return 0;
223       }
224     }
225     public boolean removeExactly(@Nullable Object element, int occurrences) {
226       if (occurrences == 0) {
227         return true;
228       }
229       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
230       while (true) {
231         int current = count(element);
232         if (occurrences &gt; current) {
233           return false;
234         }
235         if (occurrences == current) {
236           if (countMap.remove(element, occurrences)) {
237             return true;
238           }
239         } else {
240           @SuppressWarnings("unchecked")           E casted = (E) element;
241           if (countMap.replace(casted, current, current - occurrences)) {
242             return true;
243           }
244         }
245       }
246     }
247 <a name="0"></a>    @Override
248     public int setCount(E element, int count) {
249       checkNonnegative(count, "count");
250       return (count == 0) ? removeAllOccurrences(element) : unbox(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>countMap.put(element, count));
251     }
252     @Override
253     public boolean setCount(E element, int oldCount, int newCount) {
254       checkNonnegative(oldCount, "oldCount");
255       checkNonnegative</b></font>(newCount, "newCount");
256       if (newCount == 0) {
257         if (oldCount == 0) {
258           return !countMap.containsKey(element);
259         } else {
260           return countMap.remove(element, oldCount);
261         }
262       }
263       if (oldCount == 0) {
264         return countMap.putIfAbsent(element, newCount) == null;
265       }
266       return countMap.replace(element, oldCount, newCount);
267     }
268     @Override
269     Set&lt;E&gt; createElementSet() {
270       final Set&lt;E&gt; delegate = countMap.keySet();
271       return new ForwardingSet&lt;E&gt;() {
272         @Override
273         protected Set&lt;E&gt; delegate() {
274           return delegate;
275         }
276         @Override
277         public boolean remove(Object object) {
278           try {
279             return delegate.remove(object);
280           } catch (NullPointerException | ClassCastException e) {
281             return false;
282           }
283         }
284       };
285     }
286     @Override
287     Iterator&lt;E&gt; elementIterator() {
288       throw new AssertionError("should never be called");
289     }
290     private transient EntrySet entrySet;
291     @Override
292     public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
293       EntrySet result = entrySet;
294       if (result == null) {
295         entrySet = result = new EntrySet();
296       }
297       return result;
298     }
299     @Override
300     int distinctElements() {
301       return countMap.size();
302     }
303     @Override
304     public boolean isEmpty() {
305       return countMap.isEmpty();
306     }
307     @Override
308     Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
309       final Iterator&lt;Map.Entry&lt;E, Integer&gt;&gt; backingIterator = countMap.entrySet().iterator();
310       return new Iterator&lt;Entry&lt;E&gt;&gt;() {
311         @Override
312         public boolean hasNext() {
313           return backingIterator.hasNext();
314         }
315         @Override
316         public Multiset.Entry&lt;E&gt; next() {
317           Map.Entry&lt;E, Integer&gt; backingEntry = backingIterator.next();
318           return Multisets.immutableEntry(backingEntry.getKey(), backingEntry.getValue());
319         }
320         @Override
321         public void remove() {
322           backingIterator.remove();
323         }
324       };
325     }
326     @Override
327     public Iterator&lt;E&gt; iterator() {
328       return Multisets.iteratorImpl(this);
329     }
330     @Override
331     public void clear() {
332       countMap.clear();
333     }
334     private class EntrySet extends AbstractMultiset&lt;E&gt;.EntrySet {
335       @Override
336       Multiset&lt;E&gt; multiset() {
337         return OldConcurrentHashMultiset.this;
338       }
339       /*
340        * Note: the superclass toArray() methods assume that size() gives a correct
341        * answer, which ours does not.
342        */
343       @Override
344       public Object[] toArray() {
345         return snapshot().toArray();
346       }
347       @Override
348       public &lt;T&gt; T[] toArray(T[] array) {
349         return snapshot().toArray(array);
350       }
351       private List&lt;Multiset.Entry&lt;E&gt;&gt; snapshot() {
352         List&lt;Multiset.Entry&lt;E&gt;&gt; list = Lists.newArrayListWithExpectedSize(size());
353         Iterators.addAll(list, iterator());
354         return list;
355       }
356       @Override
357       public boolean remove(Object object) {
358         if (object instanceof Multiset.Entry) {
359           Multiset.Entry&lt;?&gt; entry = (Multiset.Entry&lt;?&gt;) object;
360           Object element = entry.getElement();
361           int entryCount = entry.getCount();
362           return countMap.remove(element, entryCount);
363         }
364         return false;
365       }
366       @Override
367       public int hashCode() {
368         return countMap.hashCode();
369       }
370     }
371     private static int unbox(@Nullable Integer i) {
372       return (i == null) ? 0 : i;
373     }
374   }
375 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
