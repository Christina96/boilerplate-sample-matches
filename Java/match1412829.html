<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FakeTimeLimiter.java &amp; ConcurrentHashMultisetBenchmark.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FakeTimeLimiter.java &amp; ConcurrentHashMultisetBenchmark.java
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FakeTimeLimiter.java (15.151515%)<th>ConcurrentHashMultisetBenchmark.java (2.9027576%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(76-82)<td><a href="#" name="0">(388-404)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(15-25)<td><a href="#" name="1">(17-27)</a><td align="center"><font color="#d00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FakeTimeLimiter.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.util.concurrent;
import static com.google.common.base.Preconditions.checkNotNull;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import</b></font> org.checkerframework.checker.nullness.qual.Nullable;
@Beta
@CanIgnoreReturnValue
@GwtIncompatible
@ElementTypesAreNonnullByDefault
public final class FakeTimeLimiter implements TimeLimiter {
  @Override
  public &lt;T&gt; T newProxy(
      T target, Class&lt;T&gt; interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {
    checkNotNull(target);
    checkNotNull(interfaceType);
    checkNotNull(timeoutUnit);
    return target;   }
  @Override
  @ParametricNullness
  public &lt;T extends @Nullable Object&gt; T callWithTimeout(
      Callable&lt;T&gt; callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
    checkNotNull(callable);
    checkNotNull(timeoutUnit);
    try {
      return callable.call();
    } catch (RuntimeException e) {
      throw new UncheckedExecutionException(e);
    } catch (Exception e) {
      throw new ExecutionException(e);
    } catch (Error e) {
      throw new ExecutionError(e);
    } catch (Throwable e) {
      throw new ExecutionException(e);
    }
  }
  @Override
<a name="0"></a>  @ParametricNullness
  public &lt;T extends @Nullable Object&gt; T callUninterruptiblyWithTimeout(
      Callable&lt;T&gt; callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
    return <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>callWithTimeout(callable, timeoutDuration, timeoutUnit);
  }
  @Override
  public void runWithTimeout(Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {
    checkNotNull(runnable);
    checkNotNull</b></font>(timeoutUnit);
    try {
      runnable.run();
    } catch (RuntimeException e) {
      throw new UncheckedExecutionException(e);
    } catch (Error e) {
      throw new ExecutionError(e);
    } catch (Throwable e) {
      throw new UncheckedExecutionException(e);
    }
  }
  @Override
  public void runUninterruptiblyWithTimeout(
      Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {
    runWithTimeout(runnable, timeoutDuration, timeoutUnit);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConcurrentHashMultisetBenchmark.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import com.google.caliper.BeforeExperiment;
import com.google.caliper.Benchmark;
import com.google.caliper.Param;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;
import</b></font> com.google.common.util.concurrent.ThreadFactoryBuilder;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.checkerframework.checker.nullness.qual.Nullable;
public class ConcurrentHashMultisetBenchmark {
  @Param({"1", "2", "4", "8"})
  int threads;
  @Param({"3", "30", "300"})
  int size;
  @Param MultisetSupplier implSupplier;
  private Multiset&lt;Integer&gt; multiset;
  private ImmutableList&lt;Integer&gt; keys;
  private ExecutorService threadPool;
  @BeforeExperiment
  void setUp() throws Exception {
    multiset = implSupplier.get();
    ImmutableList.Builder&lt;Integer&gt; builder = ImmutableList.builder();
    for (int i = 0; i &lt; size; i++) {
      builder.add(i);
    }
    keys = builder.build();
    threadPool =
        Executors.newFixedThreadPool(threads, new ThreadFactoryBuilder().setDaemon(true).build());
  }
  @Benchmark
  long add(final int reps) throws ExecutionException, InterruptedException {
    return doMultithreadedLoop(
        new Callable&lt;Long&gt;() {
          @Override
          public Long call() {
            return runAddSingleThread(reps);
          }
        });
  }
  @Benchmark
  long addRemove(final int reps) throws ExecutionException, InterruptedException {
    return doMultithreadedLoop(
        new Callable&lt;Long&gt;() {
          @Override
          public Long call() {
            return runAddRemoveSingleThread(reps);
          }
        });
  }
  private long doMultithreadedLoop(Callable&lt;Long&gt; task)
      throws InterruptedException, ExecutionException {
    List&lt;Future&lt;Long&gt;&gt; futures = Lists.newArrayListWithCapacity(threads);
    for (int i = 0; i &lt; threads; i++) {
      futures.add(threadPool.submit(task));
    }
    long total = 0;
    for (Future&lt;Long&gt; future : futures) {
      total += future.get();
    }
    return total;
  }
  private long runAddSingleThread(int reps) {
    Random random = new Random();
    int nKeys = keys.size();
    long blah = 0;
    for (int i = 0; i &lt; reps; i++) {
      Integer key = keys.get(random.nextInt(nKeys));
      int delta = random.nextInt(5);
      blah += delta;
      multiset.add(key, delta);
    }
    return blah;
  }
  private long runAddRemoveSingleThread(int reps) {
    Random random = new Random();
    int nKeys = keys.size();
    long blah = 0;
    for (int i = 0; i &lt; reps; i++) {
      Integer key = keys.get(random.nextInt(nKeys));
      int delta = random.nextInt(10) - 5;
      blah += delta;
      if (delta &gt;= 0) {
        multiset.add(key, delta);
      } else {
        multiset.remove(key, -delta);
      }
    }
    return blah;
  }
  private enum MultisetSupplier {
    CONCURRENT_HASH_MULTISET() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return ConcurrentHashMultiset.create();
      }
    },
    BOXED_ATOMIC_REPLACE() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return OldConcurrentHashMultiset.create();
      }
    },
    SYNCHRONIZED_MULTISET() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return Synchronized.multiset(HashMultiset.&lt;Integer&gt;create(), null);
      }
    },
    ;
    abstract Multiset&lt;Integer&gt; get();
  }
  private static final class OldConcurrentHashMultiset&lt;E&gt; extends AbstractMultiset&lt;E&gt; {
    private final transient ConcurrentMap&lt;E, Integer&gt; countMap;
    public static &lt;E&gt; OldConcurrentHashMultiset&lt;E&gt; create() {
      return new OldConcurrentHashMultiset&lt;E&gt;(new ConcurrentHashMap&lt;E, Integer&gt;());
    }
    @VisibleForTesting
    OldConcurrentHashMultiset(ConcurrentMap&lt;E, Integer&gt; countMap) {
      checkArgument(countMap.isEmpty());
      this.countMap = countMap;
    }
    @Override
    public int count(@Nullable Object element) {
      try {
        return unbox(countMap.get(element));
      } catch (NullPointerException | ClassCastException e) {
        return 0;
      }
    }
    @Override
    public int size() {
      long sum = 0L;
      for (Integer value : countMap.values()) {
        sum += value;
      }
      return Ints.saturatedCast(sum);
    }
    @Override
    public Object[] toArray() {
      return snapshot().toArray();
    }
    @Override
    public &lt;T&gt; T[] toArray(T[] array) {
      return snapshot().toArray(array);
    }
    private List&lt;E&gt; snapshot() {
      List&lt;E&gt; list = Lists.newArrayListWithExpectedSize(size());
      for (Multiset.Entry&lt;E&gt; entry : entrySet()) {
        E element = entry.getElement();
        for (int i = entry.getCount(); i &gt; 0; i--) {
          list.add(element);
        }
      }
      return list;
    }
    @Override
    public int add(E element, int occurrences) {
      if (occurrences == 0) {
        return count(element);
      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) {
        int current = count(element);
        if (current == 0) {
          if (countMap.putIfAbsent(element, occurrences) == null) {
            return 0;
          }
        } else {
          checkArgument(
              occurrences &lt;= Integer.MAX_VALUE - current,
              "Overflow adding %s occurrences to a count of %s",
              occurrences,
              current);
          int next = current + occurrences;
          if (countMap.replace(element, current, next)) {
            return current;
          }
        }
      }
    }
    @Override
    public int remove(@Nullable Object element, int occurrences) {
      if (occurrences == 0) {
        return count(element);
      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) {
        int current = count(element);
        if (current == 0) {
          return 0;
        }
        if (occurrences &gt;= current) {
          if (countMap.remove(element, current)) {
            return current;
          }
        } else {
          @SuppressWarnings("unchecked")
          E casted = (E) element;
          if (countMap.replace(casted, current, current - occurrences)) {
            return current;
          }
        }
      }
    }
    private int removeAllOccurrences(@Nullable Object element) {
      try {
        return unbox(countMap.remove(element));
      } catch (NullPointerException | ClassCastException e) {
        return 0;
      }
    }
    public boolean removeExactly(@Nullable Object element, int occurrences) {
      if (occurrences == 0) {
        return true;
      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) {
        int current = count(element);
        if (occurrences &gt; current) {
          return false;
        }
        if (occurrences == current) {
          if (countMap.remove(element, occurrences)) {
            return true;
          }
        } else {
          @SuppressWarnings("unchecked")           E casted = (E) element;
          if (countMap.replace(casted, current, current - occurrences)) {
            return true;
          }
        }
      }
    }
<a name="0"></a>    @Override
    public int setCount(E element, int count) {
      checkNonnegative(count, "count");
      return (count == 0) ? removeAllOccurrences(element) : unbox(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>countMap.put(element, count));
    }
    @Override
    public boolean setCount(E element, int oldCount, int newCount) {
      checkNonnegative(oldCount, "oldCount");
      checkNonnegative</b></font>(newCount, "newCount");
      if (newCount == 0) {
        if (oldCount == 0) {
          return !countMap.containsKey(element);
        } else {
          return countMap.remove(element, oldCount);
        }
      }
      if (oldCount == 0) {
        return countMap.putIfAbsent(element, newCount) == null;
      }
      return countMap.replace(element, oldCount, newCount);
    }
    @Override
    Set&lt;E&gt; createElementSet() {
      final Set&lt;E&gt; delegate = countMap.keySet();
      return new ForwardingSet&lt;E&gt;() {
        @Override
        protected Set&lt;E&gt; delegate() {
          return delegate;
        }
        @Override
        public boolean remove(Object object) {
          try {
            return delegate.remove(object);
          } catch (NullPointerException | ClassCastException e) {
            return false;
          }
        }
      };
    }
    @Override
    Iterator&lt;E&gt; elementIterator() {
      throw new AssertionError("should never be called");
    }
    private transient EntrySet entrySet;
    @Override
    public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
      EntrySet result = entrySet;
      if (result == null) {
        entrySet = result = new EntrySet();
      }
      return result;
    }
    @Override
    int distinctElements() {
      return countMap.size();
    }
    @Override
    public boolean isEmpty() {
      return countMap.isEmpty();
    }
    @Override
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
      final Iterator&lt;Map.Entry&lt;E, Integer&gt;&gt; backingIterator = countMap.entrySet().iterator();
      return new Iterator&lt;Entry&lt;E&gt;&gt;() {
        @Override
        public boolean hasNext() {
          return backingIterator.hasNext();
        }
        @Override
        public Multiset.Entry&lt;E&gt; next() {
          Map.Entry&lt;E, Integer&gt; backingEntry = backingIterator.next();
          return Multisets.immutableEntry(backingEntry.getKey(), backingEntry.getValue());
        }
        @Override
        public void remove() {
          backingIterator.remove();
        }
      };
    }
    @Override
    public Iterator&lt;E&gt; iterator() {
      return Multisets.iteratorImpl(this);
    }
    @Override
    public void clear() {
      countMap.clear();
    }
    private class EntrySet extends AbstractMultiset&lt;E&gt;.EntrySet {
      @Override
      Multiset&lt;E&gt; multiset() {
        return OldConcurrentHashMultiset.this;
      }
      /*
       * Note: the superclass toArray() methods assume that size() gives a correct
       * answer, which ours does not.
       */
      @Override
      public Object[] toArray() {
        return snapshot().toArray();
      }
      @Override
      public &lt;T&gt; T[] toArray(T[] array) {
        return snapshot().toArray(array);
      }
      private List&lt;Multiset.Entry&lt;E&gt;&gt; snapshot() {
        List&lt;Multiset.Entry&lt;E&gt;&gt; list = Lists.newArrayListWithExpectedSize(size());
        Iterators.addAll(list, iterator());
        return list;
      }
      @Override
      public boolean remove(Object object) {
        if (object instanceof Multiset.Entry) {
          Multiset.Entry&lt;?&gt; entry = (Multiset.Entry&lt;?&gt;) object;
          Object element = entry.getElement();
          int entryCount = entry.getCount();
          return countMap.remove(element, entryCount);
        }
        return false;
      }
      @Override
      public int hashCode() {
        return countMap.hashCode();
      }
    }
    private static int unbox(@Nullable Integer i) {
      return (i == null) ? 0 : i;
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
