<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for UpdateById.java &amp; ConnectionProfile.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for UpdateById.java &amp; ConnectionProfile.java
      </h3>
<h1 align="center">
        13.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>UpdateById.java (21.142857%)<th>ConnectionProfile.java (9.462915%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(111-121)<td><a href="#" name="0">(80-86)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(22-35)<td><a href="#" name="1">(20-34)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(144-150)<td><a href="#" name="2">(310-320)</a><td align="center"><font color="#d70000">11</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UpdateById.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner.node.dml;
2 import io.crate.analyze.where.DocKeys;
3 import io.crate.common.annotations.VisibleForTesting;
4 import io.crate.data.Row;
5 import io.crate.data.RowConsumer;
6 import io.crate.execution.dml.ShardRequestExecutor;
7 import io.crate.execution.dml.upsert.ShardUpsertRequest;
8 import io.crate.execution.engine.indexing.ShardingUpsertExecutor;
9 import io.crate.expression.symbol.Assignments;
10 import io.crate.expression.symbol.Symbol;
11 import io.crate.metadata.CoordinatorTxnCtx;
12 import io.crate.metadata.NodeContext;
13 import</b></font> io.crate.metadata.Reference;
14 import io.crate.metadata.doc.DocTableInfo;
15 import io.crate.planner.DependencyCarrier;
16 import io.crate.planner.Plan;
17 import io.crate.planner.PlannerContext;
18 import io.crate.planner.operators.SubQueryResults;
19 import org.elasticsearch.cluster.service.ClusterService;
20 import org.elasticsearch.index.shard.ShardId;
21 import javax.annotation.Nullable;
22 import java.util.List;
23 import java.util.Map;
24 import java.util.concurrent.CompletableFuture;
25 public final class UpdateById implements Plan {
26     private final DocTableInfo table;
27     private final Map&lt;Reference, Symbol&gt; assignmentByTargetCol;
28     private final DocKeys docKeys;
29     private final Assignments assignments;
30     @Nullable
31     private final Symbol[] returnValues;
32     public UpdateById(DocTableInfo table,
33                       Map&lt;Reference, Symbol&gt; assignmentByTargetCol,
34                       DocKeys docKeys,
35                       @Nullable List&lt;Symbol&gt; returnValues,
36                       NodeContext nodeCtx) {
37         this.table = table;
38         this.assignments = Assignments.convert(assignmentByTargetCol, nodeCtx);
39         this.assignmentByTargetCol = assignmentByTargetCol;
40         this.docKeys = docKeys;
41         this.returnValues = returnValues == null ? null : returnValues.toArray(new Symbol[0]);
42     }
43     @VisibleForTesting
44     public Map&lt;Reference, Symbol&gt; assignmentByTargetCol() {
45         return assignmentByTargetCol;
46     }
47     @VisibleForTesting
48     public DocKeys docKeys() {
49         return docKeys;
50     }
51     @Override
52     public StatementType type() {
53         return StatementType.UPDATE;
54     }
55     @Override
56     public void executeOrFail(DependencyCarrier dependencies,
57                               PlannerContext plannerContext,
58                               RowConsumer consumer,
59                               Row params,
60                               SubQueryResults subQueryResults) {
61         ShardRequestExecutor&lt;ShardUpsertRequest&gt; executor = createExecutor(dependencies, plannerContext);
62         if (returnValues == null) {
63             executor.execute(consumer, params, subQueryResults);
64         } else {
65             executor.executeCollectValues(consumer, params, subQueryResults);
66         }
67     }
68     @Override
69     public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier dependencies,
70                                                      PlannerContext plannerContext,
71                                                      List&lt;Row&gt; bulkParams,
72                                                      SubQueryResults subQueryResults) {
73         return createExecutor(dependencies, plannerContext)
74             .executeBulk(bulkParams, subQueryResults);
75     }
76 <a name="0"></a>
77     private ShardRequestExecutor&lt;ShardUpsertRequest&gt; createExecutor(DependencyCarrier dependencies,
78                                                                     PlannerContext plannerContext) {
79         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ClusterService clusterService = dependencies.clusterService();
80         CoordinatorTxnCtx txnCtx = plannerContext.transactionContext();
81         ShardUpsertRequest.Builder requestBuilder = new ShardUpsertRequest.Builder(
82             txnCtx.sessionSettings(),
83             ShardingUpsertExecutor.BULK_REQUEST_TIMEOUT_SETTING.get(clusterService.state().metadata().settings()),
84             ShardUpsertRequest.DuplicateKeyAction.UPDATE_OR_FAIL,
85             true,
86             assignments.targetNames(),
87             null,             returnValues,
88             plannerContext.jobId</b></font>(),
89             false
90         );
91         UpdateRequests updateRequests = new UpdateRequests(requestBuilder, table, assignments);
92         return new ShardRequestExecutor&lt;&gt;(
93             clusterService,
94             txnCtx,
95             dependencies.nodeContext(),
96             table,
97             updateRequests,
98             dependencies.transportActionProvider().transportShardUpsertAction()::execute,
99             docKeys
100         );
101     }
102     private static class UpdateRequests implements ShardRequestExecutor.RequestGrouper&lt;ShardUpsertRequest&gt; {
103         private final ShardUpsertRequest.Builder requestBuilder;
104         private final DocTableInfo table;
105         private final Assignments assignments;
106 <a name="2"></a>
107         private Symbol[] assignmentSources;
108         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>UpdateRequests(ShardUpsertRequest.Builder requestBuilder, DocTableInfo table, Assignments assignments) {
109             this.requestBuilder = requestBuilder;
110             this.table = table;
111             this.assignments = assignments;
112         }
113         @Override</b></font>
114         public ShardUpsertRequest newRequest(ShardId shardId) {
115             return requestBuilder.newRequest(shardId);
116         }
117         @Override
118         public void bind(Row parameters, SubQueryResults subQueryResults) {
119             assignmentSources = assignments.bindSources(table, parameters, subQueryResults);
120         }
121         @Override
122         public void addItem(ShardUpsertRequest request,
123                             int location,
124                             String id,
125                             Long version,
126                             Long seqNo,
127                             Long primaryTerm) {
128             ShardUpsertRequest.Item item = new ShardUpsertRequest.Item(id,
129                                                                        assignmentSources,
130                                                                        null,
131                                                                        version,
132                                                                        seqNo,
133                                                                        primaryTerm);
134             request.add(location, item);
135         }
136     }
137 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConnectionProfile.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.transport;
2 import org.elasticsearch.cluster.node.DiscoveryNode;
3 import javax.annotation.Nullable;
4 import org.elasticsearch.common.settings.Settings;
5 import io.crate.common.unit.TimeValue;
6 import java.util.ArrayList;
7 import java.util.Arrays;
8 import java.util.Collections;
9 import java.util.EnumSet;
10 import java.util.List;
11 import java.util.Objects;
12 import java.util.Set;
13 import</b></font> java.util.concurrent.atomic.AtomicInteger;
14 public final class ConnectionProfile {
15     public static ConnectionProfile resolveConnectionProfile(@Nullable ConnectionProfile profile, ConnectionProfile fallbackProfile) {
16         Objects.requireNonNull(fallbackProfile);
17         if (profile == null) {
18             return fallbackProfile;
19         } else if (profile.getConnectTimeout() != null &amp;&amp; profile.getHandshakeTimeout() != null
20             &amp;&amp; profile.getPingInterval() != null &amp;&amp; profile.getCompressionEnabled() != null) {
21             return profile;
22         } else {
23             ConnectionProfile.Builder builder = new ConnectionProfile.Builder(profile);
24             if (profile.getConnectTimeout() == null) {
25                 builder.setConnectTimeout(fallbackProfile.getConnectTimeout());
26             }
27             if (profile.getHandshakeTimeout() == null) {
28                 builder.setHandshakeTimeout(fallbackProfile.getHandshakeTimeout());
29             }
30             if (profile.getPingInterval() == null) {
31                 builder.setPingInterval(fallbackProfile.getPingInterval());
32             }
33             if (profile.getCompressionEnabled() == null) {
34                 builder.setCompressionEnabled(fallbackProfile.getCompressionEnabled());
35             }
36             return builder.build();
37         }
38     }
39     public static ConnectionProfile buildDefaultConnectionProfile(Settings settings) {
40 <a name="0"></a>        int connectionsPerNodeRecovery = TransportSettings.CONNECTIONS_PER_NODE_RECOVERY.get(settings);
41         int connectionsPerNodeBulk = TransportSettings.CONNECTIONS_PER_NODE_BULK.get(settings);
42         int connectionsPerNodeReg = TransportSettings.CONNECTIONS_PER_NODE_REG.get(settings);
43         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int connectionsPerNodeState = TransportSettings.CONNECTIONS_PER_NODE_STATE.get(settings);
44         int connectionsPerNodePing = TransportSettings.CONNECTIONS_PER_NODE_PING.get(settings);
45         Builder builder = new Builder();
46         builder.setConnectTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings));
47         builder.setHandshakeTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings));
48         builder.setPingInterval(TransportSettings.PING_SCHEDULE.get(settings));
49         builder.setCompressionEnabled</b></font>(TransportSettings.TRANSPORT_COMPRESS.get(settings));
50         builder.addConnections(connectionsPerNodeBulk, TransportRequestOptions.Type.BULK);
51         builder.addConnections(connectionsPerNodePing, TransportRequestOptions.Type.PING);
52         builder.addConnections(DiscoveryNode.isMasterEligibleNode(settings) ? connectionsPerNodeState : 0, TransportRequestOptions.Type.STATE);
53         builder.addConnections(DiscoveryNode.isDataNode(settings) ? connectionsPerNodeRecovery : 0, TransportRequestOptions.Type.RECOVERY);
54         builder.addConnections(connectionsPerNodeReg, TransportRequestOptions.Type.REG);
55         return builder.build();
56     }
57     public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, @Nullable TimeValue connectTimeout,
58                                                               @Nullable TimeValue handshakeTimeout, @Nullable TimeValue pingInterval,
59                                                               @Nullable Boolean compressionEnabled) {
60         Builder builder = new Builder();
61         builder.addConnections(1, channelType);
62         final EnumSet&lt;TransportRequestOptions.Type&gt; otherTypes = EnumSet.allOf(TransportRequestOptions.Type.class);
63         otherTypes.remove(channelType);
64         builder.addConnections(0, otherTypes.toArray(new TransportRequestOptions.Type[0]));
65         if (connectTimeout != null) {
66             builder.setConnectTimeout(connectTimeout);
67         }
68         if (handshakeTimeout != null) {
69             builder.setHandshakeTimeout(handshakeTimeout);
70         }
71         if (pingInterval != null) {
72             builder.setPingInterval(pingInterval);
73         }
74         if (compressionEnabled != null) {
75             builder.setCompressionEnabled(compressionEnabled);
76         }
77         return builder.build();
78     }
79     private final List&lt;ConnectionTypeHandle&gt; handles;
80     private final int numConnections;
81     private final TimeValue connectTimeout;
82     private final TimeValue handshakeTimeout;
83     private final TimeValue pingInterval;
84     private final Boolean compressionEnabled;
85     private ConnectionProfile(List&lt;ConnectionTypeHandle&gt; handles, int numConnections, TimeValue connectTimeout,
86                               TimeValue handshakeTimeout, TimeValue pingInterval, Boolean compressionEnabled) {
87         this.handles = handles;
88         this.numConnections = numConnections;
89         this.connectTimeout = connectTimeout;
90         this.handshakeTimeout = handshakeTimeout;
91         this.pingInterval = pingInterval;
92         this.compressionEnabled = compressionEnabled;
93     }
94     public static class Builder {
95         private final List&lt;ConnectionTypeHandle&gt; handles = new ArrayList&lt;&gt;();
96         private final Set&lt;TransportRequestOptions.Type&gt; addedTypes = EnumSet.noneOf(TransportRequestOptions.Type.class);
97         private int numConnections = 0;
98         private TimeValue connectTimeout;
99         private TimeValue handshakeTimeout;
100         private Boolean compressionEnabled;
101         private TimeValue pingInterval;
102         public Builder() {
103         }
104         public Builder(ConnectionProfile source) {
105             handles.addAll(source.getHandles());
106             numConnections = source.getNumConnections();
107             handles.forEach(th -&gt; addedTypes.addAll(th.types));
108             connectTimeout = source.getConnectTimeout();
109             handshakeTimeout = source.getHandshakeTimeout();
110             compressionEnabled = source.getCompressionEnabled();
111             pingInterval = source.getPingInterval();
112         }
113         public Builder setConnectTimeout(TimeValue connectTimeout) {
114             if (connectTimeout.millis() &lt; 0) {
115                 throw new IllegalArgumentException("connectTimeout must be non-negative but was: " + connectTimeout);
116             }
117             this.connectTimeout = connectTimeout;
118             return this;
119         }
120         public Builder setHandshakeTimeout(TimeValue handshakeTimeout) {
121             if (handshakeTimeout.millis() &lt; 0) {
122                 throw new IllegalArgumentException("handshakeTimeout must be non-negative but was: " + handshakeTimeout);
123             }
124             this.handshakeTimeout = handshakeTimeout;
125             return this;
126         }
127         public Builder setPingInterval(TimeValue pingInterval) {
128             this.pingInterval = pingInterval;
129             return this;
130         }
131         public Builder setCompressionEnabled(boolean compressionEnabled) {
132             this.compressionEnabled = compressionEnabled;
133             return this;
134         }
135         public Builder addConnections(int numConnections, TransportRequestOptions.Type... types) {
136             if (types == null || types.length == 0) {
137                 throw new IllegalArgumentException("types must not be null");
138             }
139             for (TransportRequestOptions.Type type : types) {
140                 if (addedTypes.contains(type)) {
141                     throw new IllegalArgumentException("type [" + type + "] is already registered");
142                 }
143             }
144             addedTypes.addAll(Arrays.asList(types));
145             handles.add(new ConnectionTypeHandle(this.numConnections, numConnections, EnumSet.copyOf(Arrays.asList(types))));
146             this.numConnections += numConnections;
147             return this;
148         }
149         public ConnectionProfile build() {
150             EnumSet&lt;TransportRequestOptions.Type&gt; types = EnumSet.allOf(TransportRequestOptions.Type.class);
151             types.removeAll(addedTypes);
152             if (types.isEmpty() == false) {
153                 throw new IllegalStateException("not all types are added for this connection profile - missing types: " + types);
154             }
155             return new ConnectionProfile(Collections.unmodifiableList(handles), numConnections, connectTimeout, handshakeTimeout,
156                 pingInterval, compressionEnabled);
157         }
158     }
159     public TimeValue getConnectTimeout() {
160         return connectTimeout;
161     }
162     public TimeValue getHandshakeTimeout() {
163         return handshakeTimeout;
164     }
165     public TimeValue getPingInterval() {
166         return pingInterval;
167     }
168     public Boolean getCompressionEnabled() {
169         return compressionEnabled;
170     }
171     public int getNumConnections() {
172         return numConnections;
173     }
174     public int getNumConnectionsPerType(TransportRequestOptions.Type type) {
175         for (ConnectionTypeHandle handle : handles) {
176             if (handle.getTypes().contains(type)) {
177                 return handle.length;
178             }
179         }
180         throw new AssertionError("no handle found for type: " + type);
181     }
182     List&lt;ConnectionTypeHandle&gt; getHandles() {
183         return Collections.unmodifiableList(handles);
184     }
185     static final class ConnectionTypeHandle {
186         public final int length;
187         public final int offset;
188 <a name="2"></a>        private final Set&lt;TransportRequestOptions.Type&gt; types;
189         private final AtomicInteger counter = new AtomicInteger();
190         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private ConnectionTypeHandle(int offset, int length, Set&lt;TransportRequestOptions.Type&gt; types) {
191             this.length = length;
192             this.offset = offset;
193             this.types = types;
194         }
195         &lt;T&gt; T getC</b></font>hannel(List&lt;T&gt; channels) {
196             if (length == 0) {
197                 throw new IllegalStateException("can't select channel size is 0 for types: " + types);
198             }
199             assert channels.size() &gt;= offset + length : "illegal size: " + channels.size() + " expected &gt;= " + (offset + length);
200             return channels.get(offset + Math.floorMod(counter.incrementAndGet(), length));
201         }
202         Set&lt;TransportRequestOptions.Type&gt; getTypes() {
203             return types;
204         }
205     }
206 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
