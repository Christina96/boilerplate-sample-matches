
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 42, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterCommandsTest.java</h3>
            <pre><code>1  package redis.clients.jedis.commands.jedis;
2  import static org.junit.Assert.assertEquals;
3  import static org.junit.Assert.assertNotEquals;
4  import static org.junit.Assert.assertNotNull;
5  import static org.junit.Assert.assertTrue;
6  import java.util.List;
7  import java.util.Map;
8  import org.hamcrest.MatcherAssert;
9  import org.hamcrest.Matchers;
10  import org.junit.After;
11  import org.junit.AfterClass;
12  import org.junit.Before;
13  import org.junit.Test;
14  import redis.clients.jedis.HostAndPort;
15  import redis.clients.jedis.Jedis;
16  import redis.clients.jedis.args.ClusterResetType;
17  import redis.clients.jedis.HostAndPorts;
18  import redis.clients.jedis.exceptions.JedisDataException;
19  import redis.clients.jedis.util.JedisClusterCRC16;
20  import redis.clients.jedis.util.JedisClusterTestUtil;
21  public class ClusterCommandsTest {
<span onclick='openModal()' class='match'>22    private static Jedis node1;
23    private static Jedis node2;
24    private static HostAndPort nodeInfo1 = HostAndPorts.getClusterServers().get(0);
25    private static HostAndPort nodeInfo2 = HostAndPorts.getClusterServers().get(1);
26    @Before
</span>27    public void setUp() throws Exception {
28      node1 = new Jedis(nodeInfo1);
29      node1.auth("cluster");
30      node1.flushAll();
31      node2 = new Jedis(nodeInfo2);
32      node2.auth("cluster");
33      node2.flushAll();
34    }
35    @After
36    public void tearDown() {
37      node1.disconnect();
38      node2.disconnect();
39    }
40    @AfterClass
41    public static void removeSlots() throws InterruptedException {
42      try (Jedis node = new Jedis(nodeInfo1)) {
43        node.auth("cluster");
44        node.clusterReset(ClusterResetType.SOFT);
45      }
46      try (Jedis node = new Jedis(nodeInfo2)) {
47        node.auth("cluster");
48        node.clusterReset(ClusterResetType.SOFT);
49      }
50    }
51    @Test
52    public void testClusterSoftReset() {
53      node1.clusterMeet("127.0.0.1", nodeInfo2.getPort());
54      assertTrue(node1.clusterNodes().split("\n").length > 1);
55      node1.clusterReset(ClusterResetType.SOFT);
56      assertEquals(1, node1.clusterNodes().split("\n").length);
57    }
58    @Test
59    public void testClusterHardReset() {
60      String nodeId = JedisClusterTestUtil.getNodeId(node1.clusterNodes());
61      node1.clusterReset(ClusterResetType.HARD);
62      String newNodeId = JedisClusterTestUtil.getNodeId(node1.clusterNodes());
63      assertNotEquals(nodeId, newNodeId);
64    }
65    @Test
66    public void clusterSetSlotImporting() {
67      node2.clusterAddSlots(6000);
68      String[] nodes = node1.clusterNodes().split("\n");
69      String nodeId = nodes[0].split(" ")[0];
70      String status = node1.clusterSetSlotImporting(6000, nodeId);
71      assertEquals("OK", status);
72      node2.clusterDelSlots(6000);
73    }
74    @Test
75    public void clusterNodes() {
76      String nodes = node1.clusterNodes();
77      assertTrue(nodes.split("\n").length > 0);
78    }
79    @Test
80    public void clusterAddSlotsAndDelSlots() {
81      assertEquals("OK", node1.clusterAddSlots(1, 2, 3, 4, 5));
82      assertEquals("OK", node1.clusterDelSlots(1, 2, 3, 4, 5));
83    }
84    @Test
85    public void clusterInfo() {
86      String info = node1.clusterInfo();
87      assertNotNull(info);
88    }
89    @Test
90    public void addAndDelSlotsRange() {
91      assertEquals("OK", node1.clusterAddSlotsRange(100, 105));
92      String clusterNodes = node1.clusterNodes();
93      assertTrue(clusterNodes.contains("connected 100-105"));
94      assertEquals("OK", node1.clusterAddSlotsRange(110, 120));
95      clusterNodes = node1.clusterNodes();
96      assertTrue(clusterNodes.contains("connected 100-105 110-120"));
97      assertEquals("OK", node1.clusterDelSlotsRange(100, 105));
98      clusterNodes = node1.clusterNodes();
99      assertTrue(clusterNodes.contains("connected 110-120"));
100      assertEquals("OK", node1.clusterDelSlotsRange(110, 120));
101    }
102    @Test
103    public void clusterGetKeysInSlot() {
104      node1.clusterAddSlots(500);
105      List<String> keys = node1.clusterGetKeysInSlot(500, 1);
106      assertEquals(0, keys.size());
107      node1.clusterDelSlots(500);
108    }
109    @Test
110    public void clusterGetKeysInSlotBinary() {
111      node1.clusterAddSlots(501);
112      List<byte[]> keys = node1.clusterGetKeysInSlotBinary(501, 1);
113      assertEquals(0, keys.size());
114      node1.clusterDelSlots(501);
115    }
116    @Test
117    public void clusterSetSlotNode() {
118      String[] nodes = node1.clusterNodes().split("\n");
119      String nodeId = nodes[0].split(" ")[0];
120      String status = node1.clusterSetSlotNode(10000, nodeId);
121      assertEquals("OK", status);
122    }
123    @Test
124    public void clusterSetSlotMigrating() {
125      node1.clusterAddSlots(5000);
126      String[] nodes = node1.clusterNodes().split("\n");
127      String nodeId = nodes[0].split(" ")[0];
128      String status = node1.clusterSetSlotMigrating(5000, nodeId);
129      assertEquals("OK", status);
130      node1.clusterDelSlots(5000);
131    }
132    @Test
133    public void clusterSlots() {
134      assertEquals("OK", node1.clusterAddSlots(3000, 3001, 3002));
135      List<Object> slots = node1.clusterSlots();
136      assertNotNull(slots);
137      assertTrue(slots.size() > 0);
138      for (Object slotInfoObj : slots) {
139        assertNotNull(slotInfoObj);
140        List<Object> slotInfo = (List<Object>) slotInfoObj;
141        assertTrue(slotInfo.size() >= 2);
142        assertTrue(slotInfo.get(0) instanceof Long);
143        assertTrue(slotInfo.get(1) instanceof Long);
144        if (slotInfo.size() > 2) {
145          assertTrue(slotInfo.get(2) instanceof List);
146        }
147      }
148      node1.clusterDelSlots(3000, 3001, 3002);
149    }
150    @Test
151    public void clusterLinks() throws InterruptedException {
152      List<Map<String, Object>> links = node1.clusterLinks();
153      assertNotNull(links);
154      assertEquals(0, links.size());
155    }
156    @Test
157    public void testClusterKeySlot() {
158      assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"),
159        node1.clusterKeySlot("{user1000}.following"));
160      assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"),
161          node1.clusterKeySlot("foo{bar}{zap}"));
162      assertEquals(JedisClusterCRC16.getSlot("foo{}{bar}"),
163          node1.clusterKeySlot("foo{}{bar}"));
164      assertEquals(JedisClusterCRC16.getSlot("foo{{bar}}zap"),
165          node1.clusterKeySlot("foo{{bar}}zap"));
166    }
167    @Test
168    public void clusterCountFailureReports() {
169      assertEquals(0, node1.clusterCountFailureReports(node1.clusterMyId()));
170    }
171    @Test
172    public void clusterMyId() {
173      MatcherAssert.assertThat(node1.clusterMyId(), Matchers.not(Matchers.isEmptyOrNullString()));
174    }
175    @Test
176    public void clusterMyShardId() {
177      MatcherAssert.assertThat(node1.clusterMyShardId(), Matchers.not(Matchers.isEmptyOrNullString()));
178    }
179    @Test
180    public void testClusterEpoch() {
181      try {
182        assertEquals("OK", node1.clusterSetConfigEpoch(1));
183      } catch (JedisDataException jde) {
184        assertEquals("ERR The user can assign a config epoch only when the node does not know any other node.", jde.getMessage());
185      }
186    }
187    @Test
188    public void ClusterBumpEpoch() {
189      MatcherAssert.assertThat(node1.clusterBumpEpoch(), Matchers.matchesPattern("^BUMPED|STILL [0-9]+$"));
190    }
191  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterPipeliningTest.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static org.junit.Assert.*;
3  import static redis.clients.jedis.Protocol.CLUSTER_HASHSLOTS;
4  import java.util.*;
5  import org.hamcrest.MatcherAssert;
6  import org.hamcrest.Matchers;
7  import org.junit.After;
8  import org.junit.AfterClass;
9  import org.junit.Before;
10  import org.junit.BeforeClass;
11  import org.junit.Test;
12  import redis.clients.jedis.args.*;
13  import redis.clients.jedis.exceptions.JedisDataException;
14  import redis.clients.jedis.params.*;
15  import redis.clients.jedis.providers.ClusterConnectionProvider;
16  import redis.clients.jedis.resps.GeoRadiusResponse;
17  import redis.clients.jedis.resps.StreamEntry;
18  import redis.clients.jedis.resps.Tuple;
19  import redis.clients.jedis.util.AssertUtil;
20  import redis.clients.jedis.util.JedisClusterTestUtil;
21  import redis.clients.jedis.util.SafeEncoder;
22  public class ClusterPipeliningTest {
23    private static final String LOCAL_IP = "127.0.0.1";
24    private static final DefaultJedisClientConfig DEFAULT_CLIENT_CONFIG
25        = DefaultJedisClientConfig.builder().password("cluster").build();
26    private static Jedis node1;
<span onclick='openModal()' class='match'>27    private static Jedis node2;
28    private static Jedis node3;
29    private static HostAndPort nodeInfo1 = HostAndPorts.getClusterServers().get(0);
30    private static HostAndPort nodeInfo2 = HostAndPorts.getClusterServers().get(1);
31    private static HostAndPort nodeInfo3 = HostAndPorts.getClusterServers().get(2);
</span>32    private Set<HostAndPort> nodes = new HashSet<>(Arrays.asList(nodeInfo1, nodeInfo2, nodeInfo3));
33    @BeforeClass
34    public static void setUp() throws InterruptedException {
35      node1 = new Jedis(nodeInfo1);
36      node1.auth("cluster");
37      node1.flushAll();
38      node2 = new Jedis(nodeInfo2);
39      node2.auth("cluster");
40      node2.flushAll();
41      node3 = new Jedis(nodeInfo3);
42      node3.auth("cluster");
43      node3.flushAll();
44      node1.clusterMeet(LOCAL_IP, nodeInfo2.getPort());
45      node1.clusterMeet(LOCAL_IP, nodeInfo3.getPort());
46      int slotsPerNode = CLUSTER_HASHSLOTS / 3;
47      int[] node1Slots = new int[slotsPerNode];
48      int[] node2Slots = new int[slotsPerNode + 1];
49      int[] node3Slots = new int[slotsPerNode];
50      for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0; i < CLUSTER_HASHSLOTS; i++) {
51        if (i < slotsPerNode) {
52          node1Slots[slot1++] = i;
53        } else if (i > slotsPerNode * 2) {
54          node3Slots[slot3++] = i;
55        } else {
56          node2Slots[slot2++] = i;
57        }
58      }
59      node1.clusterAddSlots(node1Slots);
60      node2.clusterAddSlots(node2Slots);
61      node3.clusterAddSlots(node3Slots);
62      JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
63    }
64    @Before
65    public void prepare() {
66      node1.flushAll();
67      node2.flushAll();
68      node3.flushAll();
69    }
70    @After
71    public void cleanUp() {
72      node1.flushDB();
73      node2.flushDB();
74      node3.flushDB();
75    }
76    @AfterClass
77    public static void tearDown() throws InterruptedException {
78      node1.flushDB();
79      node2.flushDB();
80      node3.flushDB();
81      node1.clusterReset(ClusterResetType.SOFT);
82      node2.clusterReset(ClusterResetType.SOFT);
83      node3.clusterReset(ClusterResetType.SOFT);
84    }
85    @Test
86    public void constructorClientConfig() {
87      try (ClusterPipeline pipe = new ClusterPipeline(nodes, DEFAULT_CLIENT_CONFIG)) {
88        Response<String> r1 = pipe.set("key1", "value1");
89        Response<String> r2 = pipe.set("key2", "value2");
90        Response<String> r3 = pipe.set("key3", "value3");
91        Response<String> r4 = pipe.get("key1");
92        Response<String> r5 = pipe.get("key2");
93        Response<String> r6 = pipe.get("key3");
94        pipe.sync();
95        assertEquals("OK", r1.get());
96        assertEquals("OK", r2.get());
97        assertEquals("OK", r3.get());
98        assertEquals("value1", r4.get());
99        assertEquals("value2", r5.get());
100        assertEquals("value3", r6.get());
101      }
102    }
103    @Test
104    public void constructorPoolConfig() {
105      try (ClusterPipeline pipe = new ClusterPipeline(nodes, DEFAULT_CLIENT_CONFIG, new ConnectionPoolConfig())) {
106        Response<String> r1 = pipe.set("key1", "value1");
107        Response<String> r2 = pipe.set("key2", "value2");
108        Response<String> r3 = pipe.set("key3", "value3");
109        Response<String> r4 = pipe.get("key1");
110        Response<String> r5 = pipe.get("key2");
111        Response<String> r6 = pipe.get("key3");
112        pipe.sync();
113        assertEquals("OK", r1.get());
114        assertEquals("OK", r2.get());
115        assertEquals("OK", r3.get());
116        assertEquals("value1", r4.get());
117        assertEquals("value2", r5.get());
118        assertEquals("value3", r6.get());
119      }
120    }
121    @Test
122    public void constructorConnectionProvider() {
123      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
124          ClusterPipeline pipeline = new ClusterPipeline(provider)) {
125        Response<String> r1 = pipeline.set("key1", "value1");
126        Response<String> r2 = pipeline.set("key2", "value2");
127        Response<String> r3 = pipeline.set("key3", "value3");
128        Response<String> r4 = pipeline.get("key1");
129        Response<String> r5 = pipeline.get("key2");
130        Response<String> r6 = pipeline.get("key3");
131        pipeline.sync();
132        assertEquals("OK", r1.get());
133        assertEquals("OK", r2.get());
134        assertEquals("OK", r3.get());
135        assertEquals("value1", r4.get());
136        assertEquals("value2", r5.get());
137        assertEquals("value3", r6.get());
138      }
139    }
140    @Test
141    public void clusterPipelined() {
142      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
143          ClusterPipeline pipeline = cluster.pipelined()) {
144        Response<String> r1 = pipeline.set("key1", "value1");
145        Response<String> r2 = pipeline.set("key2", "value2");
146        Response<String> r3 = pipeline.set("key3", "value3");
147        Response<String> r4 = pipeline.get("key1");
148        Response<String> r5 = pipeline.get("key2");
149        Response<String> r6 = pipeline.get("key3");
150        pipeline.sync();
151        assertEquals("OK", r1.get());
152        assertEquals("OK", r2.get());
153        assertEquals("OK", r3.get());
154        assertEquals("value1", r4.get());
155        assertEquals("value2", r5.get());
156        assertEquals("value3", r6.get());
157      }
158    }
159    @Test
160    public void intermediateSync() {
161      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
162          ClusterPipeline pipeline = cluster.pipelined()) {
163        Response<String> r1 = pipeline.set("key1", "value1");
164        Response<String> r2 = pipeline.set("key2", "value2");
165        Response<String> r3 = pipeline.set("key3", "value3");
166        pipeline.sync();
167        assertEquals("OK", r1.get());
168        assertEquals("OK", r2.get());
169        assertEquals("OK", r3.get());
170        Response<String> r4 = pipeline.get("key1");
171        Response<String> r5 = pipeline.get("key2");
172        Response<String> r6 = pipeline.get("key3");
173        pipeline.sync();
174        assertEquals("value1", r4.get());
175        assertEquals("value2", r5.get());
176        assertEquals("value3", r6.get());
177      }
178    }
179    @Test
180    public void intermediateSyncs() {
181      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
182          ClusterPipeline pipeline = cluster.pipelined()) {
183        Response<String> r1 = pipeline.set("key1", "value1");
184        Response<String> r2 = pipeline.set("key2", "value2");
185        Response<String> r3 = pipeline.set("key3", "value3");
186        for (int i = 0; i < 100; i++) pipeline.sync();
187        assertEquals("OK", r1.get());
188        assertEquals("OK", r2.get());
189        assertEquals("OK", r3.get());
190        Response<String> r4 = pipeline.get("key1");
191        Response<String> r5 = pipeline.get("key2");
192        Response<String> r6 = pipeline.get("key3");
193        for (int i = 0; i < 100; i++) pipeline.sync();
194        assertEquals("value1", r4.get());
195        assertEquals("value2", r5.get());
196        assertEquals("value3", r6.get());
197      }
198    }
199    @Test
200    public void pipelineResponse() {
201      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
202        jc.set("string", "foo");
203        jc.lpush("list", "foo");
204        jc.hset("hash", "foo", "bar");
205        jc.zadd("zset", 1, "foo");
206        jc.sadd("set", "foo");
207        jc.setrange("setrange", 0, "0123456789");
208        byte[] bytesForSetRange = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
209        jc.setrange("setrangebytes".getBytes(), 0, bytesForSetRange);
210      }
211      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
212        ClusterPipeline p = new ClusterPipeline(provider);
213        Response<String> string = p.get("string");
214        Response<String> list = p.lpop("list");
215        Response<String> hash = p.hget("hash", "foo");
216        Response<List<String>> zset = p.zrange("zset", 0, -1);
217        Response<String> set = p.spop("set");
218        Response<Boolean> blist = p.exists("list");
219        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
220        Response<Long> zcard = p.zcard("zset");
221        p.lpush("list", "bar");
222        Response<List<String>> lrange = p.lrange("list", 0, -1);
223        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
224        p.sadd("set", "foo");
225        Response<Set<String>> smembers = p.smembers("set");
226        Response<List<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0, -1);
227        Response<String> getrange = p.getrange("setrange", 1, 3);
228        Response<byte[]> getrangeBytes = p.getrange("setrangebytes".getBytes(), 6, 8);
229        p.sync();
230        assertEquals("foo", string.get());
231        assertEquals("foo", list.get());
232        assertEquals("bar", hash.get());
233        assertEquals("foo", zset.get().iterator().next());
234        assertEquals("foo", set.get());
235        assertEquals(false, blist.get());
236        assertEquals(Double.valueOf(2), zincrby.get());
237        assertEquals(Long.valueOf(1), zcard.get());
238        assertEquals(1, lrange.get().size());
239        assertNotNull(hgetAll.get().get("foo"));
240        assertEquals(1, smembers.get().size());
241        assertEquals(1, zrangeWithScores.get().size());
242        assertEquals("123", getrange.get());
243        byte[] expectedGetRangeBytes = {6, 7, 8};
244        assertArrayEquals(expectedGetRangeBytes, getrangeBytes.get());
245      }
246    }
247    @Test
248    public void pipelineBinarySafeHashCommands() {
249      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
250        jc.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
251        jc.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());
252      }
253      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
254        ClusterPipeline p = new ClusterPipeline(provider);
255        Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
256        Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
257        Response<List<byte[]>> fordered = p.hmget("key".getBytes(), "f22".getBytes(), "f1".getBytes());
258        Response<List<byte[]>> fvals = p.hvals("key".getBytes());
259        p.sync();
260        assertNotNull(fmap.get());
261        Map<byte[], byte[]> map = fmap.get();
262        Set<byte[]> mapKeys = map.keySet();
263        Iterator<byte[]> iterMap = mapKeys.iterator();
264        byte[] firstMapKey = iterMap.next();
265        byte[] secondMapKey = iterMap.next();
266        assertFalse(iterMap.hasNext());
267        verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(), "f22".getBytes());
268        byte[] firstMapValue = map.get(firstMapKey);
269        byte[] secondMapValue = map.get(secondMapKey);
270        verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(), "v2222".getBytes());
271        assertNotNull(fkeys.get());
272        Iterator<byte[]> iter = fkeys.get().iterator();
273        byte[] firstKey = iter.next();
274        byte[] secondKey = iter.next();
275        assertFalse(iter.hasNext());
276        verifyHasBothValues(firstKey, secondKey, "f1".getBytes(), "f22".getBytes());
277        assertNotNull(fordered.get());
278        assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
279        assertArrayEquals("v111".getBytes(), fordered.get().get(1));
280        assertNotNull(fvals.get());
281        assertEquals(2, fvals.get().size());
282        byte[] firstValue = fvals.get().get(0);
283        byte[] secondValue = fvals.get().get(1);
284        verifyHasBothValues(firstValue, secondValue, "v111".getBytes(), "v2222".getBytes());
285      }
286    }
287    private void verifyHasBothValues(byte[] firstKey, byte[] secondKey, byte[] value1, byte[] value2) {
288      assertFalse(Arrays.equals(firstKey, secondKey));
289      assertTrue(Arrays.equals(firstKey, value1) || Arrays.equals(firstKey, value2));
290      assertTrue(Arrays.equals(secondKey, value1) || Arrays.equals(secondKey, value2));
291    }
292    @Test(expected = IllegalStateException.class)
293    public void pipelineResponseWithinPipeline() {
294      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
295        ClusterPipeline p = new ClusterPipeline(provider);
296        Response<String> string = p.get("string");
297        string.get();
298        p.sync();
299      }
300    }
301    @Test
302    public void pipelineWithPubSub() {
303      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
304        ClusterPipeline pipelined = new ClusterPipeline(provider);
305        Response<Long> p1 = pipelined.publish("foo", "bar");
306        Response<Long> p2 = pipelined.publish("foo".getBytes(), "bar".getBytes());
307        pipelined.sync();
308        assertEquals(0, p1.get().longValue());
309        assertEquals(0, p2.get().longValue());
310      }
311    }
312    @Test
313    public void canRetrieveUnsetKey() {
314      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
315        ClusterPipeline p = new ClusterPipeline(provider);
316        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
317        p.sync();
318        assertNull(shouldNotExist.get());
319      }
320    }
321    @Test
322    public void piplineWithError() {
323      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
324        ClusterPipeline p = new ClusterPipeline(provider);
325        p.set("foo", "bar");
326        Response<Set<String>> error = p.smembers("foo");
327        Response<String> r = p.get("foo");
328        p.sync();
329        try {
330          error.get();
331          fail();
332        } catch (JedisDataException e) {
333        }
334        assertEquals(r.get(), "bar");
335      }
336    }
337    @Test
338    public void getSetParams() {
339      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
340      ClusterPipeline p = new ClusterPipeline(provider);
341      Response<String> r1 = p.set("key1", "value1");
342      Response<String> r2 = p.set("key2", "value2");
343      Response<String> r3 = p.set("key3", "value3");
344      Response<String> r4 = p.set("key3", "value4", new SetParams().nx()); 
345      Response<String> r5 = p.get("key1");
346      Response<String> r6 = p.get("key2");
347      Response<String> r7 = p.get("key3");
348      p.sync();
349      assertEquals("OK", r1.get());
350      assertEquals("OK", r2.get());
351      assertEquals("OK", r3.get());
352      assertNull(r4.get());
353      assertEquals("value1", r5.get());
354      assertEquals("value2", r6.get());
355      assertEquals("value3", r7.get());
356    }
357    @Test
358    public void clusterPipelineSort() {
359      List<String> sorted = new ArrayList<>();
360      sorted.add("1");
361      sorted.add("2");
362      sorted.add("3");
363      sorted.add("4");
364      sorted.add("5");
365      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
366      ClusterPipeline p = new ClusterPipeline(provider);
367      Response<Long> r1 = p.rpush("key1", "2", "3", "5", "1", "4");
368      Response<List<String>> r2 = p.sort("key1");
369      Response<Long> r3 = p.sort("key1", "key1");
370      Response<List<String>> r4 = p.lrange("key1", 0, 4);
371      Response<List<String>> r5 = p.sort("key1", new SortingParams().limit(0, 2));
372      Response<Long> r6 = p.sort("key1", new SortingParams().desc(), "key1");
373      Response<List<String>> r7 = p.lrange("key1", 0, 4);
374      p.sync();
375      assertEquals(Long.valueOf(5), r1.get());
376      assertEquals(sorted, r2.get());
377      assertEquals(Long.valueOf(5), r3.get());
378      assertEquals(sorted, r4.get());
379      assertEquals(2, r5.get().size());
380      assertEquals(Long.valueOf(5), r6.get());
381      Collections.reverse(sorted);
382      assertEquals(sorted, r7.get());
383    }
384    @Test
385    public void clusterPipelineList() {
386      List<String> vals = new ArrayList<>();
387      vals.add("foobar");
388      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
389      ClusterPipeline p = new ClusterPipeline(provider);
390      Response<Long> r1 = p.lpush("my{list}", "hello", "hello", "foo", "foo"); 
391      Response<Long> r2 = p.rpush("my{newlist}", "hello", "hello", "foo", "foo");  
392      Response<Long> r3 = p.lpos("my{list}", "foo");
393      Response<Long> r4 = p.lpos("my{list}", "foo", new LPosParams().maxlen(1));
394      Response<List<Long>> r5 = p.lpos("my{list}", "foo", new LPosParams().maxlen(1), 2);
395      Response<String> r6 = p.ltrim("my{list}", 2, 3); 
396      Response<Long> r7 = p.llen("my{list}");
397      Response<String> r8 = p.lindex("my{list}", -1);
398      Response<String> r9 = p.lset("my{list}", 1, "foobar"); 
399      Response<Long> r10 = p.lrem("my{list}", 1, "hello"); 
400      Response<List<String>> r11 = p.lrange("my{list}", 0, 10);
401      Response<String> r12 = p.rpop("my{newlist}"); 
402      Response<List<String>> r13 = p.lpop("my{list}", 1); 
403      Response<List<String>> r14 = p.rpop("my{newlist}", 2); 
404      Response<Long> r15 = p.linsert("my{newlist}", ListPosition.AFTER, "hello", "world"); 
405      Response<Long> r16 = p.lpushx("myother{newlist}", "foo", "bar");
406      Response<Long> r17 = p.rpushx("myother{newlist}", "foo", "bar");
407      Response<String> r18 = p.rpoplpush("my{newlist}", "myother{newlist}");
408      Response<String> r19 = p.lmove("my{newlist}", "myother{newlist}", ListDirection.LEFT, ListDirection.RIGHT);
409      p.sync();
410      assertEquals(Long.valueOf(4), r1.get());
411      assertEquals(Long.valueOf(4), r2.get());
412      assertEquals(Long.valueOf(0), r3.get());
413      assertEquals(Long.valueOf(0), r4.get());
414      assertEquals(1, r5.get().size());
415      assertEquals("OK", r6.get());
416      assertEquals(Long.valueOf(2), r7.get());
417      assertEquals("hello", r8.get());
418      assertEquals("OK", r9.get());
419      assertEquals(Long.valueOf(1), r10.get());
420      assertEquals(vals, r11.get());
421      assertEquals("foo", r12.get());
422      assertEquals(vals, r13.get());
423      assertEquals(2, r14.get().size());
424      assertEquals(Long.valueOf(2), r15.get());
425      assertEquals(Long.valueOf(0), r16.get());
426      assertEquals(Long.valueOf(0), r17.get());
427      assertEquals("world", r18.get());
428      assertEquals("hello", r19.get());
429    }
430    @Test
431    public void clusterPipelineSet() {
432      Set<String> diff = new HashSet<>();
433      diff.add("bar");
434      diff.add("foo");
435      Set<String> union = new HashSet<>();
436      union.add("hello");
437      union.add("world");
438      union.add("bar");
439      union.add("foo");
440      Set<String> inter = new HashSet<>();
441      inter.add("world");
442      inter.add("hello");
443      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
444      ClusterPipeline p = new ClusterPipeline(provider);
445      Response<Long> r1 = p.sadd("my{set}", "hello", "hello", "world", "foo", "bar");
446      p.sadd("mynew{set}", "hello", "hello", "world");
447      Response<Set<String>> r2 = p.sdiff("my{set}", "mynew{set}");
448      Response<Long> r3 = p.sdiffStore("diffset{set}", "my{set}", "mynew{set}");
449      Response<Set<String>> r4 = p.smembers("diffset{set}");
450      Response<Set<String>> r5 = p.sinter("my{set}", "mynew{set}");
451      Response<Long> r6 = p.sinterstore("interset{set}", "my{set}", "mynew{set}");
452      Response<Set<String>> r7 = p.smembers("interset{set}");
453      Response<Set<String>> r8 = p.sunion("my{set}", "mynew{set}");
454      Response<Long> r9 = p.sunionstore("unionset{set}", "my{set}", "mynew{set}");
455      Response<Set<String>> r10 = p.smembers("unionset{set}");
456      Response<Boolean> r11 = p.sismember("my{set}", "foo");
457      Response<List<Boolean>> r12 = p.smismember("my{set}", "foo", "foobar");
458      Response<Long> r13 = p.srem("my{set}", "foo");
459      Response<Set<String>> r14 = p.spop("my{set}", 1);
460      Response<Long> r15 = p.scard("my{set}");
461      Response<String> r16 = p.srandmember("my{set}");
462      Response<List<String>> r17 = p.srandmember("my{set}", 2);
463      p.sync();
464      assertEquals(Long.valueOf(4), r1.get());
465      assertEquals(diff, r2.get());
466      assertEquals(Long.valueOf(diff.size()), r3.get());
467      assertEquals(diff, r4.get());
468      assertEquals(inter, r5.get());
469      assertEquals(Long.valueOf(inter.size()), r6.get());
470      assertEquals(inter, r7.get());
471      assertEquals(union, r8.get());
472      assertEquals(Long.valueOf(union.size()), r9.get());
473      assertEquals(union, r10.get());
474      assertTrue(r11.get());
475      assertTrue(r12.get().get(0) && !r12.get().get(1));
476      assertEquals(Long.valueOf(1), r13.get());
477      assertTrue(union.containsAll(r14.get()));
478      assertEquals(Long.valueOf(2), r15.get());
479      assertTrue(union.contains(r16.get()));
480      assertTrue(union.containsAll(r17.get()));
481    }
482    @Test
483    public void clusterPipelineSortedSet() {
484      Map<String, Double> hm = new HashMap<>();
485      hm.put("a1", 1d);
486      hm.put("a2", 2d);
487      hm.put("a3", 3d);
488      Set<String> members = new HashSet<>(hm.keySet());
489      Tuple max = new Tuple("a3", 3d);
490      Tuple min = new Tuple("a1", 1d);
491      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
492      ClusterPipeline p = new ClusterPipeline(provider);
493      Response<Long> r1 = p.zadd("myset", hm);
494      Response<Long> r2 = p.zrank("myset", "a3");
495      Response<Long> r3 = p.zrevrank("myset", "a3");
496      Response<Long> r4 = p.zrem("myset", "a1");
497      Response<Long> r5 = p.zadd("myset", 1d, "a1");
498      Response<Long> r6 = p.zadd("myotherset", 2d, "a1", new ZAddParams().nx());
499      Response<Double> r7 = p.zaddIncr("myset", 3d, "a4", new ZAddParams().xx()); 
500      Response<List<String>> r8 = p.zrevrange("myset", 0, 0);
501      Response<List<Tuple>> r9 = p.zrevrangeWithScores("myset", 0, 0);
502      Response<String> r10 = p.zrandmember("myset");
503      Response<List<String>> r11 = p.zrandmember("myset", 2);
504      Response<List<Tuple>> r12 = p.zrandmemberWithScores("myset", 1);
505      Response<Double> r13 = p.zscore("myset", "a1");
506      Response<List<Double>> r14 = p.zmscore("myset", "a1", "a2");
507      Response<Tuple> r15 = p.zpopmax("myset");
508      Response<Tuple> r16 = p.zpopmin("myset");
509      Response<Long> r17 = p.zcount("myotherset", 2, 5);
510      Response<Long> r18 = p.zcount("myotherset", "(2", "5");
511      p.zadd("myset", hm, new ZAddParams().nx()); 
512      Response<List<Tuple>> r19 = p.zpopmax("myset", 2);
513      Response<List<Tuple>> r20 = p.zpopmin("myset", 1);
514      p.sync();
515      assertEquals(Long.valueOf(3), r1.get());
516      assertEquals(Long.valueOf(2), r2.get());
517      assertEquals(Long.valueOf(0), r3.get());
518      assertEquals(Long.valueOf(1), r4.get());
519      assertEquals(Long.valueOf(1), r5.get());
520      assertEquals(Long.valueOf(1), r6.get());
521      assertNull(r7.get());
522      assertTrue(r8.get().size() == 1 && r8.get().contains("a3"));
523      assertTrue(r9.get().size() == 1 && r9.get().contains(max));
524      assertTrue(members.contains(r10.get()));
525      assertTrue(members.containsAll(r11.get()));
526      assertEquals(1, r12.get().size());
527      assertEquals(Double.valueOf(1), r13.get());
528      assertTrue(hm.values().containsAll(r14.get()));
529      assertEquals(max, r15.get());
530      assertEquals(min, r16.get());
531      assertEquals(Long.valueOf(1), r17.get());
532      assertEquals(Long.valueOf(0), r18.get());
533      assertTrue(r19.get().size() == 2 && r19.get().contains(max));
534      assertTrue(r20.get().size() == 1 && r20.get().contains(min));
535    }
536    @Test
537    public void clusterPipelineHash() {
538      Map<String, String> hm = new HashMap<>();
539      hm.put("field2", "2");
540      hm.put("field3", "5");
541      Set<String> keys = new HashSet<>();
542      keys.add("field2");
543      List<String> vals = new ArrayList<>();
544      vals.add("3.5");
545      List<String> vals2 = new ArrayList<>();
546      vals2.add("hello");
547      vals2.add(null);
548      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
549      ClusterPipeline p = new ClusterPipeline(provider);
550      Response<Long> r1 = p.hset("myhash", "field1", "hello");
551      Response<Long> r2 = p.hsetnx("myhash", "field1", "hello");
552      Response<String> r3 = p.hget("myhash", "field1");
553      Response<Long> r4 = p.hset("myotherhash", hm);
554      Response<String> r5 = p.hmset("mynewhash", hm);
555      p.hincrBy("mynewhash", "field2", 1);
556      Response<Double> r6 = p.hincrByFloat("mynewhash", "field2", 0.5);
557      Response<Long> r7 = p.hlen("myhash");
558      Response<Long> r8 = p.hdel("mynewhash", "field3");
559      Response<Boolean> r9 = p.hexists("mynewhash", "field3");
560      Response<Set<String>> r10 = p.hkeys("mynewhash");
561      Response<List<String>> r11 = p.hvals("mynewhash");
562      Response<List<String>> r12 = p.hmget("myhash", "field1", "field2");
563      Response<String> r13 = p.hrandfield("myotherhash");
564      Response<List<String>> r14 = p.hrandfield("myotherhash", 4);
565      Response<List<String>> r15 = p.hrandfield("myotherhash", -4);
566      Response<Long> r16 = p.hstrlen("myhash", "field1");
567      Response<List<Map.Entry<String, String>>> r17 = p.hrandfieldWithValues("myotherhash", 4);
568      Response<List<Map.Entry<String, String>>> r18 = p.hrandfieldWithValues("myotherhash", -4);
569      p.sync();
570      assertEquals(Long.valueOf(1), r1.get());
571      assertEquals(Long.valueOf(0), r2.get());
572      assertEquals("hello", r3.get());
573      assertEquals(Long.valueOf(2), r4.get());
574      assertEquals("OK", r5.get());
575      assertEquals(Double.valueOf(3.5), r6.get());
576      assertEquals(Long.valueOf(1), r7.get());
577      assertEquals(Long.valueOf(1), r8.get());
578      assertFalse(r9.get());
579      assertEquals(keys, r10.get());
580      assertEquals(vals, r11.get());
581      assertEquals(vals2, r12.get());
582      AssertUtil.assertCollectionContains(hm.keySet(), r13.get());
583      assertEquals(2, r14.get().size());
584      assertEquals(4, r15.get().size());
585      assertEquals(Long.valueOf(5), r16.get());
586      assertEquals(2, r17.get().size());
587      assertEquals(4, r18.get().size());
588    }
589    @Test
590    public void clusterPipelineGeo() {
591      Map<String, GeoCoordinate> hm = new HashMap<>();
592      hm.put("place1", new GeoCoordinate(2.1909389952632, 41.433791470673));
593      hm.put("place2", new GeoCoordinate(2.1873744593677, 41.406342043777));
594      List<GeoCoordinate> values = new ArrayList<>();
595      values.add(new GeoCoordinate(2.19093829393386841, 41.43379028184083523));
596      values.add(new GeoCoordinate(2.18737632036209106, 41.40634178640635099));
597      List<String> hashValues = new ArrayList<>();
598      hashValues.add("sp3e9yg3kd0");
599      hashValues.add("sp3e9cbc3t0");
600      hashValues.add(null);
601      GeoRadiusParam params = new GeoRadiusParam().withCoord().withHash().withDist();
602      GeoRadiusParam params2 = new GeoRadiusParam().count(1, true);
603      GeoRadiusStoreParam storeParams = new GeoRadiusStoreParam().store("radius{#}");
604      GeoRadiusResponse expectedResponse = new GeoRadiusResponse("place1".getBytes());
605      expectedResponse.setCoordinate(new GeoCoordinate(2.19093829393386841, 41.43379028184083523));
606      expectedResponse.setDistance(0.0881);
607      expectedResponse.setRawScore(3471609698139488L);
608      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
609      ClusterPipeline p = new ClusterPipeline(provider);
610      Response<Long> r1 = p.geoadd("barcelona", hm);
611      p.geoadd("barcelona{#}", new GeoAddParams().nx(), hm);
612      Response<Double> r2 = p.geodist("barcelona", "place1", "place2");
613      Response<Double> r3 = p.geodist("barcelona", "place1", "place2", GeoUnit.KM);
614      Response<List<String>> r4 = p.geohash("barcelona", "place1", "place2", "place3");
615      Response<List<GeoCoordinate>> r5 = p.geopos("barcelona", "place1", "place2");
616      Response<List<GeoRadiusResponse>> r6 = p.georadius("barcelona", 2.191, 41.433, 1000, GeoUnit.M);
617      Response<List<GeoRadiusResponse>> r7 = p.georadiusReadonly("barcelona", 2.191, 41.433, 1000, GeoUnit.M);
618      Response<List<GeoRadiusResponse>> r8 = p.georadius("barcelona", 2.191, 41.433, 1, GeoUnit.KM, params);
619      Response<List<GeoRadiusResponse>> r9 = p.georadiusReadonly("barcelona", 2.191, 41.433, 1, GeoUnit.KM, params);
620      Response<Long> r10 = p.georadiusStore("barcelona{#}", 2.191, 41.433, 1000, GeoUnit.M, params2, storeParams);
621      Response<List<String>> r11 = p.zrange("radius{#}", 0, -1);
622      Response<List<GeoRadiusResponse>> r12 = p.georadiusByMember("barcelona", "place1", 4, GeoUnit.KM);
623      Response<List<GeoRadiusResponse>> r13 = p.georadiusByMemberReadonly("barcelona", "place1", 4, GeoUnit.KM);
624      Response<List<GeoRadiusResponse>> r14 = p.georadiusByMember("barcelona", "place1", 4, GeoUnit.KM, params2);
625      Response<List<GeoRadiusResponse>> r15 = p.georadiusByMemberReadonly("barcelona", "place1", 4, GeoUnit.KM, params2);
626      Response<Long> r16 = p.georadiusByMemberStore("barcelona{#}", "place1", 4, GeoUnit.KM, params2, storeParams);
627      Response<List<String>> r17 = p.zrange("radius{#}", 0, -1);
628      p.sync();
629      assertEquals(Long.valueOf(2), r1.get());
630      assertEquals(Double.valueOf(3067.4157), r2.get());
631      assertEquals(Double.valueOf(3.0674), r3.get());
632      assertEquals(hashValues, r4.get());
633      assertEquals(values, r5.get());
634      assertTrue(r6.get().size() == 1 && r6.get().get(0).getMemberByString().equals("place1"));
635      assertTrue(r7.get().size() == 1 && r7.get().get(0).getMemberByString().equals("place1"));
636      assertEquals(expectedResponse, r8.get().get(0));
637      assertEquals(expectedResponse, r9.get().get(0));
638      assertEquals(Long.valueOf(1), r10.get());
639      assertTrue(r11.get().size() == 1 && r11.get().contains("place1"));
640      assertTrue(r12.get().size() == 2 && r12.get().get(0).getMemberByString().equals("place2"));
641      assertTrue(r13.get().size() == 2 && r13.get().get(0).getMemberByString().equals("place2"));
642      assertTrue(r14.get().size() == 1 && r14.get().get(0).getMemberByString().equals("place2"));
643      assertTrue(r15.get().size() == 1 && r15.get().get(0).getMemberByString().equals("place2"));
644      assertEquals(Long.valueOf(1), r16.get());
645      assertTrue(r17.get().size() == 1 && r17.get().contains("place2"));
646    }
647    @Test
648    public void clusterPipelineHyperLogLog() {
649      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
650      ClusterPipeline p = new ClusterPipeline(provider);
651      Response<Long> r1 = p.pfadd("{hll}_1", "foo", "bar", "zap", "a");
652      Response<Long> r2 = p.pfadd("{hll}_2", "foo", "bar", "zap");
653      Response<Long> r3 = p.pfcount("{hll}_1", "{hll}_2");
654      Response<String> r4 = p.pfmerge("{hll}3", "{hll}_1", "{hll}_2");
655      Response<Long> r5 = p.pfcount("{hll}3");
656      p.sync();
657      assertEquals(Long.valueOf(1), r1.get());
658      assertEquals(Long.valueOf(1), r2.get());
659      assertEquals(Long.valueOf(4), r3.get());
660      assertEquals("OK", r4.get());
661      assertEquals(Long.valueOf(4), r5.get());
662    }
663    @Test
664    public void clusterPipelineStringsAndBits() {
665      List<Long> fieldRes = new ArrayList<>();
666      fieldRes.add(1L);
667      fieldRes.add(0L);
668      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
669      ClusterPipeline p = new ClusterPipeline(provider);
670      Response<String> r1 = p.set("{mykey}", "foobar"); 
671      p.set("my{otherkey}", "foo");
672      Response<String> r2 = p.substr("{mykey}", 0, 2);
673      Response<Long> r3 = p.strlen("{mykey}");
674      Response<Long> r4 = p.bitcount("my{otherkey}");
675      Response<Long> r5 = p.bitcount("my{otherkey}", 1, 1);
676      Response<Long> r6 = p.bitpos("{mykey}", true);
677      Response<Long> r7 = p.bitpos("{mykey}", false, new BitPosParams(1, 2));
678      Response<List<Long>> r8 = p.bitfield("mynew{key}", "INCRBY", "i5", "100", "1", "GET", "u4", "0");
679      Response<List<Long>> r9 = p.bitfieldReadonly("hello", "GET", "i8", "17");
680      p.set("myother{mykey}", "abcdef");
681      Response<Long> r10 = p.bitop(BitOP.AND, "dest{mykey}", "{mykey}", "myother{mykey}");
682      Response<String> r11 = p.get("dest{mykey}");
683      Response<Boolean> r12 = p.setbit("my{otherkey}", 7, true);
684      Response<Boolean> r13 = p.getbit("my{otherkey}", 7);
685      p.sync();
686      assertEquals("OK", r1.get());
687      assertEquals("foo", r2.get());
688      assertEquals(Long.valueOf(6), r3.get());
689      assertEquals(Long.valueOf(16), r4.get());
690      assertEquals(Long.valueOf(6), r5.get());
691      assertEquals(Long.valueOf(1), r6.get());
692      assertEquals(Long.valueOf(8), r7.get());
693      assertEquals(fieldRes, r8.get());
694      assertEquals(fieldRes.subList(1, 2), r9.get());
695      assertEquals(Long.valueOf(6), r10.get());
696      assertEquals("`bc`ab", r11.get());
697      assertFalse(r12.get());
698      assertTrue(r13.get());
699    }
700    @Test
701    public void clusterPipelineStream() {
702      Map<String, String> hm = new HashMap<>();
703      hm.put("one", "one");
704      hm.put("two", "two");
705      hm.put("three", "three");
706      StreamEntryID streamId1 = new StreamEntryID("1638277876711-0");
707      StreamEntryID streamId2 = new StreamEntryID("1638277959731-0");
708      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
709      ClusterPipeline p = new ClusterPipeline(provider);
710      Response<StreamEntryID> r1 = p.xadd("mystream", streamId1, hm);
711      Response<StreamEntryID> r2 = p.xadd("mystream", new XAddParams().id(new StreamEntryID("1638277959731-0")).maxLen(2).approximateTrimming(), hm);
712      Response<Long> r3 = p.xlen("mystream");
713      Response<List<StreamEntry>> r4 = p.xrange("mystream", streamId1, streamId2);
714      Response<List<StreamEntry>> r5 = p.xrange("mystream", streamId1, streamId2, 1);
715      Response<List<StreamEntry>> r6 = p.xrevrange("mystream", streamId2, streamId1);
716      Response<List<StreamEntry>> r7 = p.xrevrange("mystream", streamId2, streamId1, 1);
717      Response<String> r8 = p.xgroupCreate("mystream", "group", streamId1, false);
718      Response<String> r9 = p.xgroupSetID("mystream", "group", streamId2);
719      p.sync();
720      assertEquals(streamId1, r1.get());
721      assertEquals(streamId2, r2.get());
722      assertEquals(Long.valueOf(2), r3.get());
723      assertTrue(r4.get().size() == 2
724          && r4.get().get(0).getID().compareTo(streamId1) == 0
725          && r4.get().get(1).getID().compareTo(streamId2) == 0);
726      assertTrue(r5.get().size() == 1 && r5.get().get(0).getID().compareTo(streamId1) == 0);
727      assertTrue(r6.get().size() == 2
728          && r6.get().get(1).getID().compareTo(streamId1) == 0
729          && r6.get().get(0).getID().compareTo(streamId2) == 0);
730      assertTrue(r7.get().size() == 1 && r7.get().get(0).getID().compareTo(streamId2) == 0);
731      assertEquals("OK", r8.get());
732      assertEquals("OK", r9.get());
733    }
734    @Test
735    public void testEval() {
736      String script = "return 'success!'";
737      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
738        ClusterPipeline p = new ClusterPipeline(provider);
739        Response<Object> result = p.eval(script);
740        p.sync();
741        assertEquals("success!", result.get());
742      }
743    }
744    @Test
745    public void testEvalWithBinary() {
746      String script = "return 'success!'";
747      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
748        ClusterPipeline p = new ClusterPipeline(provider);
749        Response<Object> result = p.eval(SafeEncoder.encode(script));
750        p.sync();
751        assertArrayEquals(SafeEncoder.encode("success!"), (byte[]) result.get());
752      }
753    }
754    @Test
755    public void testEvalKeyAndArg() {
756      String key = "test";
757      String arg = "3";
758      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
759      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
760        ClusterPipeline p = new ClusterPipeline(provider);
761        p.set(key, "0");
762        Response<Object> result0 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
763        p.incr(key);
764        Response<Object> result1 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
765        Response<String> result2 = p.get(key);
766        p.sync();
767        assertNull(result0.get());
768        assertNull(result1.get());
769        assertEquals("13", result2.get());
770      }
771    }
772    @Test
773    public void testEvalKeyAndArgWithBinary() {
774      byte[] bKey = SafeEncoder.encode("test");
775      byte[] bArg = SafeEncoder.encode("3");
776      byte[] bScript = SafeEncoder.encode("redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])");
777      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
778        ClusterPipeline bP = new ClusterPipeline(provider);
779        bP.set(bKey, SafeEncoder.encode("0"));
780        Response<Object> bResult0 = bP.eval(bScript, Arrays.asList(bKey), Arrays.asList(bArg));
781        bP.incr(bKey);
782        Response<Object> bResult1 = bP.eval(bScript, Arrays.asList(bKey), Arrays.asList(bArg));
783        Response<byte[]> bResult2 = bP.get(bKey);
784        bP.sync();
785        assertNull(bResult0.get());
786        assertNull(bResult1.get());
787        assertArrayEquals(SafeEncoder.encode("13"), bResult2.get());
788      }
789    }
790    @Test
791    public void testEvalNestedLists() {
792      String script = "return { {KEYS[1]} , {2} }";
793      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
794        ClusterPipeline p = new ClusterPipeline(provider);
795        Response<Object> result = p.eval(script, 1, "key1");
796        p.sync();
797        List<?> results = (List<?>) result.get();
798        MatcherAssert.assertThat((List<String>) results.get(0), Matchers.hasItem("key1"));
799        MatcherAssert.assertThat((List<Long>) results.get(1), Matchers.hasItem(2L));
800      }
801    }
802    @Test
803    public void testEvalNestedListsWithBinary() {
804      byte[] bScript = SafeEncoder.encode("return { {KEYS[1]} , {2} }");
805      byte[] bKey = SafeEncoder.encode("key1");
806      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
807        ClusterPipeline p = new ClusterPipeline(provider);
808        Response<Object> result = p.eval(bScript, 1, bKey);
809        p.sync();
810        List<?> results = (List<?>) result.get();
811        MatcherAssert.assertThat((List<byte[]>) results.get(0), Matchers.hasItem(bKey));
812        MatcherAssert.assertThat((List<Long>) results.get(1), Matchers.hasItem(2L));
813      }
814    }
815    @Test
816    public void testEvalsha() {
817      String script = "return 'success!'";
818      String sha1;
819      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
820        sha1 = jc.scriptLoad(script, "sampleKey");
821        assertTrue(jc.scriptExists(sha1, "sampleKey"));
822      }
823      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
824        ClusterPipeline p = new ClusterPipeline(provider);
825        Response<Object> result = p.evalsha(sha1, 1, "sampleKey");
826        p.sync();
827        assertEquals("success!", result.get());
828      }
829    }
830    @Test
831    public void testEvalshaKeyAndArg() {
832      String key = "test";
833      String arg = "3";
834      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
835      String sha1;
836      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
837        sha1 = jc.scriptLoad(script, key);
838        assertTrue(jc.scriptExists(sha1, key));
839      }
840      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
841        ClusterPipeline p = new ClusterPipeline(provider);
842        p.set(key, "0");
843        Response<Object> result0 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
844        p.incr(key);
845        Response<Object> result1 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
846        Response<String> result2 = p.get(key);
847        p.sync();
848        assertNull(result0.get());
849        assertNull(result1.get());
850        assertEquals("13", result2.get());
851      }
852    }
853    @Test
854    public void testEvalshaKeyAndArgWithBinary() {
855      byte[] bKey = SafeEncoder.encode("test");
856      byte[] bArg = SafeEncoder.encode("3");
857      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
858      byte[] bScript = SafeEncoder.encode(script);
859      byte[] bSha1;
860      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
861        bSha1 = jc.scriptLoad(bScript, bKey);
862        assertTrue(jc.scriptExists(bSha1, bKey));
863      }
864      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
865        ClusterPipeline p = new ClusterPipeline(provider);
866        p.set(bKey, SafeEncoder.encode("0"));
867        Response<Object> result0 = p.evalsha(bSha1, Arrays.asList(bKey), Arrays.asList(bArg));
868        p.incr(bKey);
869        Response<Object> result1 = p.evalsha(bSha1, Arrays.asList(bKey), Arrays.asList(bArg));
870        Response<byte[]> result2 = p.get(bKey);
871        p.sync();
872        assertNull(result0.get());
873        assertNull(result1.get());
874        assertArrayEquals(SafeEncoder.encode("13"), result2.get());
875      }
876    }
877    @Test
878    public void simple() { 
879      try (JedisCluster jedis = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
880        final int count = 10;
881        int totalCount = 0;
882        for (int i = 0; i < count; i++) {
883          jedis.set("foo" + i, "bar" + i);
884        }
885        totalCount += count;
886        for (int i = 0; i < count; i++) {
887          jedis.rpush("foobar" + i, "foo" + i, "bar" + i);
888        }
889        totalCount += count;
890        List<Response<?>> responses = new ArrayList<>(totalCount);
891        List<Object> expected = new ArrayList<>(totalCount);
892        try (ClusterPipeline pipeline = jedis.pipelined()) {
893          for (int i = 0; i < count; i++) {
894            responses.add(pipeline.get("foo" + i));
895            expected.add("bar" + i);
896          }
897          for (int i = 0; i < count; i++) {
898            responses.add(pipeline.lrange("foobar" + i, 0, -1));
899            expected.add(Arrays.asList("foo" + i, "bar" + i));
900          }
901        }
902        for (int i = 0; i < totalCount; i++) {
903          assertEquals(expected.get(i), responses.get(i).get());
904        }
905      }
906    }
907    @Test
908    public void transaction() {
909      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
910        assertThrows(UnsupportedOperationException.class, () -> cluster.multi());
911      }
912    }
913    @Test(timeout = 10_000L)
914    public void multiple() {
915      final int maxTotal = 100;
916      ConnectionPoolConfig poolConfig = new ConnectionPoolConfig();
917      poolConfig.setMaxTotal(maxTotal);
918      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG, 5, poolConfig)) {
919        for (int i = 0; i < maxTotal; i++) {
920          assertThreadsCount();
921          String s = Integer.toString(i);
922          try (ClusterPipeline pipeline = cluster.pipelined()) {
923            pipeline.set(s, s);
924            pipeline.sync();
925          }
926          assertThreadsCount();
927        }
928      }
929    }
930    private static void assertThreadsCount() {
931      final ThreadGroup rootGroup = Thread.currentThread().getThreadGroup().getParent();
932      final Thread[] threads = new Thread[rootGroup.activeCount()];
933      rootGroup.enumerate(threads);
934      final int count = (int) Arrays.stream(threads)
935          .filter(thread -> thread != null && thread.getName() != null
936              && thread.getName().startsWith("pool-"))
937          .count();
938      MatcherAssert.assertThat(count, Matchers.lessThanOrEqualTo(20));
939    }
940  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterCommandsTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterPipeliningTest.java</div>
                </div>
                <div class="column column_space"><pre><code>22    private static Jedis node1;
23    private static Jedis node2;
24    private static HostAndPort nodeInfo1 = HostAndPorts.getClusterServers().get(0);
25    private static HostAndPort nodeInfo2 = HostAndPorts.getClusterServers().get(1);
26    @Before
</pre></code></div>
                <div class="column column_space"><pre><code>27    private static Jedis node2;
28    private static Jedis node3;
29    private static HostAndPort nodeInfo1 = HostAndPorts.getClusterServers().get(0);
30    private static HostAndPort nodeInfo2 = HostAndPorts.getClusterServers().get(1);
31    private static HostAndPort nodeInfo3 = HostAndPorts.getClusterServers().get(2);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    