<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for PgGetKeywordsFunction.java & CreateFunctionAnalyzerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for PgGetKeywordsFunction.java & CreateFunctionAnalyzerTest.java
      </h3>
      <h1 align="center">
        8.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>PgGetKeywordsFunction.java (12.962963%)<TH>CreateFunctionAnalyzerTest.java (6.6037736%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2592713-0.html#0',2,'match2592713-1.html#0',3)" NAME="0">(27-44)<TD><A HREF="javascript:ZweiFrames('match2592713-0.html#0',2,'match2592713-1.html#0',3)" NAME="0">(24-40)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>PgGetKeywordsFunction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.expression.tablefunctions;

<A NAME="0"></A>import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.data.RowN;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2592713-1.html#0',3,'match2592713-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.metadata.FunctionName;
import io.crate.metadata.NodeContext;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.functions.Signature;
import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;
import io.crate.metadata.tablefunctions.TableFunctionImplementation;
import io.crate.sql.Identifiers;
import io.crate.types.RowType;

import java.util.List;
import java.util.Locale;
import java.util.function.Function;

import static io.crate.types.DataTypes.STRING;

public final class PgGetKeywordsFunction extends TableFunctionImplementation&lt;List&lt;Object&gt;&gt; {

    private static final String NAME = &quot;pg_get_keywords&quot;</B></FONT>;
    private static final FunctionName FUNCTION_NAME = new FunctionName(PgCatalogSchemaInfo.NAME, NAME);
    private static final RowType RETURN_TYPE = new RowType(
        List.of(STRING, STRING, STRING),
        List.of(&quot;word&quot;, &quot;catcode&quot;, &quot;catdesc&quot;)
    );

    public static void register(TableFunctionModule module) {

        module.register(
            Signature.table(
                FUNCTION_NAME,
                RETURN_TYPE.getTypeSignature()
            ),
            PgGetKeywordsFunction::new
        );
    }

    private final Signature signature;
    private final Signature boundSignature;

    public PgGetKeywordsFunction(Signature signature, Signature boundSignature) {
        this.signature = signature;
        this.boundSignature = boundSignature;
    }

    @Override
    public Iterable&lt;Row&gt; evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input&lt;List&lt;Object&gt;&gt;[] args) {
        return () -&gt; Identifiers.KEYWORDS.stream()
            .map(new Function&lt;Identifiers.Keyword, Row&gt;() {

                final Object[] columns = new Object[3];
                final RowN row = new RowN(columns);

                @Override
                public Row apply(Identifiers.Keyword keyword) {
                    columns[0] = keyword.getWord().toLowerCase(Locale.ENGLISH);
                    if (keyword.isReserved()) {
                        columns[1] = &quot;R&quot;;
                        columns[2] = &quot;reserved&quot;;
                    } else {
                        columns[1] = &quot;U&quot;;
                        columns[2] = &quot;unreserved&quot;;
                    }
                    return row;
                }
            }).iterator();
    }

    @Override
    public Signature signature() {
        return signature;
    }

    @Override
    public Signature boundSignature() {
        return boundSignature;
    }

    @Override
    public RowType returnType() {
        return RETURN_TYPE;
    }

    @Override
    public boolean hasLazyResultSet() {
        return false;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CreateFunctionAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.analyze;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2592713-0.html#0',2,'match2592713-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.crate.action.sql.SessionContext;
import io.crate.user.User;
import io.crate.expression.symbol.Literal;
import io.crate.sql.parser.SqlParser;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.ArrayType;
import io.crate.types.DataTypes;
import org.junit.Before;
import org.junit.Test;

import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;

public class CreateFunctionAnalyzerTest extends CrateDummyClusterServiceUnitTest {

    private SQLExecutor e</B></FONT>;

    @Before
    public void initExecutor() throws Exception {
        e = SQLExecutor.builder(clusterService).build();
    }

    @Test
    public void testCreateFunctionSimple() {
        AnalyzedStatement analyzedStatement = e.analyze(&quot;CREATE FUNCTION bar(long, long)&quot; +
            &quot; RETURNS long LANGUAGE dummy_lang AS 'function(a, b) { return a + b; }'&quot;);
        assertThat(analyzedStatement, instanceOf(AnalyzedCreateFunction.class));

        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) analyzedStatement;
        assertThat(analysis.schema(), is(&quot;doc&quot;));
        assertThat(analysis.name(), is(&quot;bar&quot;));
        assertThat(analysis.replace(), is(false));
        assertThat(analysis.returnType(), is(DataTypes.LONG));
        assertThat(analysis.arguments().get(0), is(FunctionArgumentDefinition.of(DataTypes.LONG)));
        assertThat(analysis.arguments().get(1), is(FunctionArgumentDefinition.of(DataTypes.LONG)));
        assertThat(analysis.language(), is(Literal.of(&quot;dummy_lang&quot;)));
        assertThat(analysis.definition(), is(Literal.of(&quot;function(a, b) { return a + b; }&quot;)));
    }

    @Test
    public void testCreateFunctionWithSchemaName() {
        AnalyzedCreateFunction analyzedStatement = e.analyze(
            &quot;CREATE FUNCTION foo.bar(long, long)&quot; +
            &quot; RETURNS long LANGUAGE dummy_lang AS 'function(a, b) { return a + b; }'&quot;);
        assertThat(analyzedStatement.schema(), is(&quot;foo&quot;));
        assertThat(analyzedStatement.name(), is(&quot;bar&quot;));
    }

    @Test
    public void testCreateFunctionWithSessionSetSchema() throws Exception {
        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) e.analyzer.analyze(
            SqlParser.createStatement(
                &quot;CREATE FUNCTION bar(long, long)&quot; +
                &quot; RETURNS long LANGUAGE dummy_lang AS 'function(a, b) { return a + b; }'&quot;),
            new SessionContext(User.CRATE_USER, &quot;my_schema&quot;),
            ParamTypeHints.EMPTY);

        assertThat(analysis.schema(), is(&quot;my_schema&quot;));
        assertThat(analysis.name(), is(&quot;bar&quot;));
    }

    @Test
    public void testCreateFunctionExplicitSchemaSupersedesSessionSchema() throws Exception {
        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) e.analyzer.analyze(
            SqlParser.createStatement(&quot;CREATE FUNCTION my_other_schema.bar(long, long)&quot; +
                &quot; RETURNS long LANGUAGE dummy_lang AS 'function(a, b) { return a + b; }'&quot;),
            new SessionContext(User.CRATE_USER, &quot;my_schema&quot;),
            ParamTypeHints.EMPTY);

        assertThat(analysis.schema(), is(&quot;my_other_schema&quot;));
        assertThat(analysis.name(), is(&quot;bar&quot;));
    }

    @Test
    public void testCreateFunctionOrReplace() {
        AnalyzedStatement analyzedStatement = e.analyze(&quot;CREATE OR REPLACE FUNCTION bar()&quot; +
            &quot; RETURNS long LANGUAGE dummy_lang AS 'function() { return 1; }'&quot;);
        assertThat(analyzedStatement, instanceOf(AnalyzedCreateFunction.class));

        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) analyzedStatement;
        assertThat(analysis.name(), is(&quot;bar&quot;));
        assertThat(analysis.replace(), is(true));
        assertThat(analysis.returnType(), is(DataTypes.LONG));
        assertThat(analysis.language(), is(Literal.of(&quot;dummy_lang&quot;)));
        assertThat(analysis.definition(), is(Literal.of(&quot;function() { return 1; }&quot;)));
    }

    @Test
    public void testCreateFunctionWithComplexGeoDataTypes() {
        AnalyzedStatement analyzedStatement = e.analyze(&quot;CREATE FUNCTION bar(geo_point, geo_shape)&quot; +
            &quot; RETURNS geo_point LANGUAGE dummy_lang AS 'function() { return 1; }'&quot;);
        assertThat(analyzedStatement, instanceOf(AnalyzedCreateFunction.class));

        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) analyzedStatement;
        assertThat(analysis.name(), is(&quot;bar&quot;));
        assertThat(analysis.replace(), is(false));
        assertThat(analysis.returnType(), is(DataTypes.GEO_POINT));
        assertThat(analysis.arguments().get(0), is(FunctionArgumentDefinition.of(DataTypes.GEO_POINT)));
        assertThat(analysis.arguments().get(1), is(FunctionArgumentDefinition.of(DataTypes.GEO_SHAPE)));
        assertThat(analysis.language(), is(Literal.of(&quot;dummy_lang&quot;)));
    }

    @Test
    public void testCreateFunctionWithComplexComplexTypes() {
        AnalyzedStatement analyzedStatement = e.analyze(
            &quot;CREATE FUNCTION&quot; +
            &quot;   bar(array(integer),&quot; +
            &quot;   object, ip,&quot; +
            &quot;   timestamp with time zone&quot; +
            &quot;) RETURNS array(geo_point) LANGUAGE dummy_lang AS 'function() { return 1; }'&quot;);
        assertThat(analyzedStatement, instanceOf(AnalyzedCreateFunction.class));

        AnalyzedCreateFunction analysis = (AnalyzedCreateFunction) analyzedStatement;
        assertThat(analysis.name(), is(&quot;bar&quot;));
        assertThat(analysis.replace(), is(false));
        assertThat(analysis.returnType(), is(new ArrayType(DataTypes.GEO_POINT)));
        assertThat(analysis.arguments().get(0), is(FunctionArgumentDefinition.of(new ArrayType(DataTypes.INTEGER))));
        assertThat(analysis.arguments().get(1), is(FunctionArgumentDefinition.of(DataTypes.UNTYPED_OBJECT)));
        assertThat(analysis.arguments().get(2), is(FunctionArgumentDefinition.of(DataTypes.IP)));
        assertThat(analysis.arguments().get(3), is(FunctionArgumentDefinition.of(DataTypes.TIMESTAMPZ)));
        assertThat(analysis.language(), is(Literal.of(&quot;dummy_lang&quot;)));
    }
}
</PRE>
</div>
  </div>
</body>
</html>
