<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for QuantilesTest.java & CacheLoadingTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for QuantilesTest.java & CacheLoadingTest.java
      </h3>
      <h1 align="center">
        21.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>QuantilesTest.java (54.701717%)<TH>CacheLoadingTest.java (13.115151%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#0',2,'match186757-1.html#0',3)" NAME="0">(19-78)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#0',2,'match186757-1.html#0',3)" NAME="0">(31-64)</A><TD ALIGN=center><FONT COLOR="#ff0000">28</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#1',2,'match186757-1.html#1',3)" NAME="1">(187-198)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#1',2,'match186757-1.html#1',3)" NAME="1">(815-824)</A><TD ALIGN=center><FONT COLOR="#ad0000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#2',2,'match186757-1.html#2',3)" NAME="2">(206-214)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#2',2,'match186757-1.html#2',3)" NAME="2">(324-335)</A><TD ALIGN=center><FONT COLOR="#a30000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#3',2,'match186757-1.html#3',3)" NAME="3">(307-323)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#3',2,'match186757-1.html#3',3)" NAME="3">(836-845)</A><TD ALIGN=center><FONT COLOR="#9a0000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#4',2,'match186757-1.html#4',3)" NAME="4">(335-348)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#4',2,'match186757-1.html#4',3)" NAME="4">(1758-1771)</A><TD ALIGN=center><FONT COLOR="#880000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#5',2,'match186757-1.html#5',3)" NAME="5">(589-594)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#5',2,'match186757-1.html#5',3)" NAME="5">(2289-2301)</A><TD ALIGN=center><FONT COLOR="#7f0000">14</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#6',2,'match186757-1.html#6',3)" NAME="6">(348-360)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#6',2,'match186757-1.html#6',3)" NAME="6">(2233-2247)</A><TD ALIGN=center><FONT COLOR="#7f0000">14</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#7',2,'match186757-1.html#7',3)" NAME="7">(158-167)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#7',2,'match186757-1.html#7',3)" NAME="7">(1839-1854)</A><TD ALIGN=center><FONT COLOR="#7f0000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#8',2,'match186757-1.html#8',3)" NAME="8">(144-151)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#8',2,'match186757-1.html#8',3)" NAME="8">(1820-1830)</A><TD ALIGN=center><FONT COLOR="#7f0000">14</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#9',2,'match186757-1.html#9',3)" NAME="9">(384-397)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#9',2,'match186757-1.html#9',3)" NAME="9">(451-456)</A><TD ALIGN=center><FONT COLOR="#760000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#10',2,'match186757-1.html#10',3)" NAME="10">(294-306)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#10',2,'match186757-1.html#10',3)" NAME="10">(372-379)</A><TD ALIGN=center><FONT COLOR="#760000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#11',2,'match186757-1.html#11',3)" NAME="11">(132-137)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#11',2,'match186757-1.html#11',3)" NAME="11">(153-160)</A><TD ALIGN=center><FONT COLOR="#760000">13</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#12',2,'match186757-1.html#12',3)" NAME="12">(573-579)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#12',2,'match186757-1.html#12',3)" NAME="12">(262-269)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#13',2,'match186757-1.html#13',3)" NAME="13">(323-335)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#13',2,'match186757-1.html#13',3)" NAME="13">(201-208)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#14',2,'match186757-1.html#14',3)" NAME="14">(663-667)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#14',2,'match186757-1.html#14',3)" NAME="14">(564-568)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#15',2,'match186757-1.html#15',3)" NAME="15">(654-658)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#15',2,'match186757-1.html#15',3)" NAME="15">(524-528)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#16',2,'match186757-1.html#16',3)" NAME="16">(370-383)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#16',2,'match186757-1.html#16',3)" NAME="16">(708-714)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#17',2,'match186757-1.html#17',3)" NAME="17">(228-242)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#17',2,'match186757-1.html#17',3)" NAME="17">(663-669)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#18',2,'match186757-1.html#18',3)" NAME="18">(214-221)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#18',2,'match186757-1.html#18',3)" NAME="18">(1951-1959)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#19',2,'match186757-1.html#19',3)" NAME="19">(180-186)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#19',2,'match186757-1.html#19',3)" NAME="19">(573-578)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#20',2,'match186757-1.html#20',3)" NAME="20">(168-174)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#20',2,'match186757-1.html#20',3)" NAME="20">(94-98)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#21',2,'match186757-1.html#21',3)" NAME="21">(152-158)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#21',2,'match186757-1.html#21',3)" NAME="21">(533-538)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#22',2,'match186757-1.html#22',3)" NAME="22">(138-144)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#22',2,'match186757-1.html#22',3)" NAME="22">(419-425)</A><TD ALIGN=center><FONT COLOR="#640000">11</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#23',2,'match186757-1.html#23',3)" NAME="23">(671-675)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#23',2,'match186757-1.html#23',3)" NAME="23">(1749-1754)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#24',2,'match186757-1.html#24',3)" NAME="24">(618-622)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#24',2,'match186757-1.html#24',3)" NAME="24">(2117-2121)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#25',2,'match186757-1.html#25',3)" NAME="25">(609-613)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#25',2,'match186757-1.html#25',3)" NAME="25">(2067-2071)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#26',2,'match186757-1.html#26',3)" NAME="26">(601-605)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#26',2,'match186757-1.html#26',3)" NAME="26">(2024-2028)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#27',2,'match186757-1.html#27',3)" NAME="27">(546-550)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#27',2,'match186757-1.html#27',3)" NAME="27">(1320-1325)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#28',2,'match186757-1.html#28',3)" NAME="28">(534-538)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#28',2,'match186757-1.html#28',3)" NAME="28">(104-108)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#29',2,'match186757-1.html#29',3)" NAME="29">(522-524)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#29',2,'match186757-1.html#29',3)" NAME="29">(2059-2063)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#ae694a"><FONT COLOR="#ae694a">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#30',2,'match186757-1.html#30',3)" NAME="30">(498-502)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#30',2,'match186757-1.html#30',3)" NAME="30">(2180-2184)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#3ea99f"><FONT COLOR="#3ea99f">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#31',2,'match186757-1.html#31',3)" NAME="31">(474-485)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#31',2,'match186757-1.html#31',3)" NAME="31">(1273-1278)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#5b8daf"><FONT COLOR="#5b8daf">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#32',2,'match186757-1.html#32',3)" NAME="32">(459-473)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#32',2,'match186757-1.html#32',3)" NAME="32">(1197-1202)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#736aff"><FONT COLOR="#736aff">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#33',2,'match186757-1.html#33',3)" NAME="33">(438-452)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#33',2,'match186757-1.html#33',3)" NAME="33">(1129-1134)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#827d6b"><FONT COLOR="#827d6b">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#34',2,'match186757-1.html#34',3)" NAME="34">(417-431)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#34',2,'match186757-1.html#34',3)" NAME="34">(1105-1110)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#41a317"><FONT COLOR="#41a317">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#35',2,'match186757-1.html#35',3)" NAME="35">(361-368)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#35',2,'match186757-1.html#35',3)" NAME="35">(1042-1047)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#ff00ff"><FONT COLOR="#ff00ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#36',2,'match186757-1.html#36',3)" NAME="36">(283-293)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#36',2,'match186757-1.html#36',3)" NAME="36">(995-1000)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#810541"><FONT COLOR="#810541">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#37',2,'match186757-1.html#37',3)" NAME="37">(271-281)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#37',2,'match186757-1.html#37',3)" NAME="37">(948-953)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#348781"><FONT COLOR="#348781">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#38',2,'match186757-1.html#38',3)" NAME="38">(262-269)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#38',2,'match186757-1.html#38',3)" NAME="38">(873-878)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#152dc6"><FONT COLOR="#152dc6">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#39',2,'match186757-1.html#39',3)" NAME="39">(245-257)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#39',2,'match186757-1.html#39',3)" NAME="39">(2372-2379)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#347235"><FONT COLOR="#347235">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#40',2,'match186757-1.html#40',3)" NAME="40">(198-205)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#40',2,'match186757-1.html#40',3)" NAME="40">(755-761)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#f87a17"><FONT COLOR="#f87a17">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#41',2,'match186757-1.html#41',3)" NAME="41">(126-132)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#41',2,'match186757-1.html#41',3)" NAME="41">(493-498)</A><TD ALIGN=center><FONT COLOR="#5b0000">10</FONT>
<TR><TD BGCOLOR="#c57717"><FONT COLOR="#c57717">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#42',2,'match186757-1.html#42',3)" NAME="42">(763-766)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#42',2,'match186757-1.html#42',3)" NAME="42">(599-602)</A><TD ALIGN=center><FONT COLOR="#510000">9</FONT>
<TR><TD BGCOLOR="#c22817"><FONT COLOR="#c22817">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#43',2,'match186757-1.html#43',3)" NAME="43">(567-571)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#43',2,'match186757-1.html#43',3)" NAME="43">(2018-2021)</A><TD ALIGN=center><FONT COLOR="#510000">9</FONT>
<TR><TD BGCOLOR="#a057a5"><FONT COLOR="#a057a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#44',2,'match186757-1.html#44',3)" NAME="44">(454-458)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#44',2,'match186757-1.html#44',3)" NAME="44">(1430-1435)</A><TD ALIGN=center><FONT COLOR="#510000">9</FONT>
<TR><TD BGCOLOR="#549748"><FONT COLOR="#549748">-</FONT><TD><A HREF="javascript:ZweiFrames('match186757-0.html#45',2,'match186757-1.html#45',3)" NAME="45">(433-437)<TD><A HREF="javascript:ZweiFrames('match186757-0.html#45',2,'match186757-1.html#45',3)" NAME="45">(1367-1372)</A><TD ALIGN=center><FONT COLOR="#510000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>QuantilesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.math;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match186757-1.html#0',3,'match186757-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.math.Quantiles.median;
import static com.google.common.math.Quantiles.percentiles;
import static com.google.common.math.Quantiles.quartiles;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;
import static java.lang.Double.NEGATIVE_INFINITY;
import static java.lang.Double.NaN;
import static java.lang.Double.POSITIVE_INFINITY;
import static java.math.RoundingMode.CEILING;
import static java.math.RoundingMode.FLOOR;
import static java.math.RoundingMode.UNNECESSARY;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Ordering;
import com.google.common.math.Quantiles.ScaleAndIndexes;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.truth.Correspondence;
import com.google.common.truth.Correspondence.BinaryPredicate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import junit.framework.TestCase;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Tests for {@link Quantiles}.
 *
 * @author Pete Gillin
 */
public class QuantilesTest extends TestCase {

  /*
   * Since Quantiles provides a fluent-style API, each test covers a chain of methods resulting in
   * the computation of one or more quantiles (or in an error) rather than individual methods. The
   * tests are divided into three sections:
   * 1. Tests on a hardcoded dataset for chains starting with median(), quartiles(), and scale(10);
   * 2. Tests on hardcoded datasets include non-finite values for chains starting with scale(10);
   * 3. Tests on a mechanically generated dataset for chains starting with percentiles();
   * 4. Tests of illegal usages of the API.
   */

  /*
   * Covering every combination would lead to an explosion in the number of tests. So we cover only:
   * - median with compute taking a double-collection and with computeInPlace;
   * - quartiles with index and with indexes taking int-varargs, and with compute taking a
   *   double-collection and with computeInPlace;
   * - scale with index and with indexes taking int-varargs, and with all overloads of compute
   *   taking a double-collection and with computeInPlace;
   * - scale with indexes taking integer-collection with compute taking a double-collection and with
   *   computeInPlace;
   * - (except that, for non-finite values, we don't do all combinations exhaustively);
   * - percentiles with index and with indexes taking int-varargs, and with compute taking a
   *   double-collection and with computeInPlace.
   */

  private static final double ALLOWED_ERROR = 1.0e-10</B></FONT>;

  /**
   * A {@link Correspondence} which accepts finite values within {@link #ALLOWED_ERROR} of each
   * other.
   */
  private static final Correspondence&lt;Number, Number&gt; FINITE_QUANTILE_CORRESPONDENCE =
      Correspondence.tolerance(ALLOWED_ERROR);

  /**
   * A {@link Correspondence} which accepts either finite values within {@link #ALLOWED_ERROR} of
   * each other or identical non-finite values.
   */
  private static final Correspondence&lt;Double, Double&gt; QUANTILE_CORRESPONDENCE =
      Correspondence.from(
          new BinaryPredicate&lt;Double, Double&gt;() {
            @Override
            public boolean apply(@Nullable Double actual, @Nullable Double expected) {
              // Test for equality to allow non-finite values to match; otherwise, use the finite
              // test.
              return actual.equals(expected)
                  || FINITE_QUANTILE_CORRESPONDENCE.compare(actual, expected);
            }
          },
          &quot;is identical to or &quot; + FINITE_QUANTILE_CORRESPONDENCE);

  // 1. Tests on a hardcoded dataset for chains starting with median(), quartiles(), and scale(10):

  /** The squares of the 16 integers from 0 to 15, in an arbitrary order. */
  private static final ImmutableList&lt;Double&gt; SIXTEEN_SQUARES_DOUBLES =
      ImmutableList.of(
          25.0, 100.0, 0.0, 144.0, 9.0, 121.0, 4.0, 225.0, 169.0, 64.0, 49.0, 16.0, 36.0, 1.0, 81.0,
          196.0);

  private static final ImmutableList&lt;Long&gt; SIXTEEN_SQUARES_LONGS =
      ImmutableList.of(
          25L, 100L, 0L, 144L, 9L, 121L, 4L, 225L, 169L, 64L, 49L, 16L, 36L, 1L, 81L, 196L);
  private static final ImmutableList&lt;Integer&gt; SIXTEEN_SQUARES_INTEGERS =
      ImmutableList.of(25, 100, 0, 144, 9, 121, 4, 225, 169, 64, 49, 16, 36, 1, 81, 196);
  private static final double SIXTEEN_SQUARES_MIN = 0.0;
  private static final double SIXTEEN_SQUARES_DECILE_1 = 0.5 * (1.0 + 4.0);
  private static final double SIXTEEN_SQUARES_QUARTILE_1 = 0.25 * 9.0 + 0.75 * 16.0;
  private static final double SIXTEEN_SQUARES_MEDIAN = 0.5 * (49.0 + 64.0);
  private static final double SIXTEEN_SQUARES_QUARTILE_3 = 0.75 * 121.0 + 0.25 * 144.0;
  private static final double SIXTEEN_SQUARES_DECILE_8 = 144.0;
<A NAME="41"></A>  private static final double SIXTEEN_SQUARES_MAX = 225.0;

  public void testMedian_compute_doubleCollection() {
    <FONT color="#f87a17"><A HREF="javascript:ZweiFrames('match186757-1.html#41',3,'match186757-top.html#41',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(median().compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_MEDIAN);
<A NAME="11"></A>  }

  public void testMedian_computeInPlace() {
    double[] dataset = <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match186757-1.html#11',3,'match186757-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</B></FONT>;
    assertThat(median().computeInPlace(dataset)).isWithin(ALLOWED_ERROR).of(SIXTEEN_SQUARES_MEDIAN);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<A NAME="22"></A>  }

  public void testQuartiles_index_compute_doubleCollection() {</B></FONT>
    <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match186757-1.html#22',3,'match186757-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(quartiles().index(1).compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_QUARTILE_1);
<A NAME="8"></A>  }

  public void testQuartiles_index_computeInPlace() {
    double[] dataset = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match186757-1.html#8',3,'match186757-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</B></FONT>;
    assertThat(quartiles().index(1).computeInPlace(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_QUARTILE_1);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<A NAME="21"></A>  }

  public void testQuartiles_indexes_varargs_compute_doubleCollection() {</B></FONT>
    <FONT color="#947010"><A HREF="javascript:ZweiFrames('match186757-1.html#21',3,'match186757-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(quartiles().indexes(1, 3).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(1, SIXTEEN_SQUARES_QUARTILE_1, 3, SIXTEEN_SQUARES_QUARTILE_3);
<A NAME="7"></A>  }

  public void testQuartiles_indexes_varargs_computeInPlace() {
    double[] dataset = <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match186757-1.html#7',3,'match186757-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</B></FONT>;
    assertThat(quartiles().indexes(1, 3).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            1, SIXTEEN_SQUARES_QUARTILE_1,
            3, SIXTEEN_SQUARES_QUARTILE_3);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<A NAME="20"></A>  }

  public void testScale_index_compute_doubleCollection() {</B></FONT>
    <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match186757-1.html#20',3,'match186757-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
  }

  public void testScale_index_compute_longCollection() {
    assertThat</B></FONT>(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_LONGS))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
<A NAME="19"></A>  }

  public void testScale_index_compute_integerCollection() {
    <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match186757-1.html#19',3,'match186757-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_INTEGERS))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
  }
<A NAME="1"></A>
  public void testScale_index_compute_doubleVarargs() {
    double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</B></FONT>;
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match186757-1.html#1',3,'match186757-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(1).compute(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset)
        .usingExactEquality()
        .containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES)
        .inOrder();
  }
<A NAME="40"></A>
  public void testScale_index_compute_longVarargs() {
    long[] dataset = Longs.toArray(SIXTEEN_SQUARES_LONGS);
    assertThat(<FONT color="#347235"><A HREF="javascript:ZweiFrames('match186757-1.html#40',3,'match186757-top.html#40',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Quantiles.scale(10).index(1).compute</B></FONT>(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_LONGS);
  }
<A NAME="2"></A>
  public void testScale_index_compute_intVarargs() {
    int[] dataset = Ints.toArray(SIXTEEN_SQUARES_INTEGERS)</B></FONT>;
    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match186757-1.html#2',3,'match186757-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(1).compute(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_INTEGERS);
  }
<A NAME="18"></A>
  public void testScale_index_computeInPlace() {
    double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
    assertThat</B></FONT>(<FONT color="#800517"><A HREF="javascript:ZweiFrames('match186757-1.html#18',3,'match186757-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Quantiles.scale(10).index(1).computeInPlace(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
  }

  public void testScale_index_computeInPlace_explicitVarargs() {
    assertThat</B></FONT>(Quantiles.scale(10).index(5).computeInPlace(78.9, 12.3, 45.6))
        .isWithin(ALLOWED_ERROR)
        .of(45.6);
  }
<A NAME="17"></A>
  public void testScale_indexes_varargs_compute_doubleCollection() {
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match186757-1.html#17',3,'match186757-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }

  public void testScale_indexes_varargs_compute_doubleCollection_snapshotsIndexes() {
    // This test is the same as testScale_indexes_varargs_compute_doubleCollection except that the
    // array of indexes to be calculated is modified between the calls to indexes and compute: since
    // the contract is that it is snapshotted, this shouldn't make any difference to the result.
<A NAME="39"></A>    int[] indexes = {0, 10, 5, 1, 8, 10}</B></FONT>;
    ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(indexes);
    indexes[0] = 3;
    <FONT color="#152dc6"><A HREF="javascript:ZweiFrames('match186757-1.html#39',3,'match186757-top.html#39',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(intermediate.compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }

  public void testScale_indexes_largeVarargs_compute_doubleCollection() {
    int scale = Integer.MAX_VALUE;
    int otherIndex = (Integer.MAX_VALUE - 1) / 3</B></FONT>; // this divides exactly
    // For the otherIndex calculation, we have q=Integer.MAX_VALUE, k=(Integer.MAX_VALUE-1)/3, and
<A NAME="38"></A>    // N=16. Therefore k*(N-1)/q = 5-5/Integer.MAX_VALUE, which has floor 4 and fractional part
    // (1-5/Integer.MAX_VALUE).
    double otherValue = 16.0 * 5.0 / Integer.MAX_VALUE + 25.0 * (1.0 - 5.0 / Integer.MAX_VALUE);
    <FONT color="#348781"><A HREF="javascript:ZweiFrames('match186757-1.html#38',3,'match186757-top.html#38',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            Quantiles.scale(scale).indexes(0, scale, otherIndex).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN, scale, SIXTEEN_SQUARES_MAX, otherIndex, otherValue);
  }
<A NAME="37"></A>
  public void testScale_indexes_varargs_compute_longCollection() {</B></FONT>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <FONT color="#810541"><A HREF="javascript:ZweiFrames('match186757-1.html#37',3,'match186757-top.html#37',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_LONGS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }
<A NAME="36"></A>
  public void testScale_indexes_varargs_compute_integerCollection() {</B></FONT>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <FONT color="#ff00ff"><A HREF="javascript:ZweiFrames('match186757-1.html#36',3,'match186757-top.html#36',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
<A NAME="10"></A>  }

  public void testScale_indexes_varargs_compute_indexOrderIsMaintained() {</B></FONT>
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match186757-1.html#10',3,'match186757-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8)
        .inOrder();
  }
<A NAME="3"></A>
  public void testScale_indexes_varargs_compute_doubleVarargs() {
    double[] dataset = Doubles.toArray</B></FONT>(SIXTEEN_SQUARES_DOUBLES);
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match186757-1.html#3',3,'match186757-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset)
        .usingExactEquality()
        .containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES)
        .inOrder();
  }
<A NAME="13"></A>
  public void testScale_indexes_varargs_compute_longVarargs() {
    long[] dataset = Longs.toArray(SIXTEEN_SQUARES_LONGS);
    <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match186757-1.html#13',3,'match186757-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))</B></FONT>
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_LONGS);
<A NAME="4"></A>  }

  public void testScale_indexes_varargs_compute_intVarargs() {
    int[] dataset = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match186757-1.html#4',3,'match186757-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Ints.toArray(SIXTEEN_SQUARES_INTEGERS)</B></FONT>;
    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_INTEGERS);
<A NAME="6"></A>  }

  public void testScale_indexes_varargs_computeInPlace() {
    double[] dataset = <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match186757-1.html#6',3,'match186757-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</B></FONT>;
    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<A NAME="35"></A>  }

  public void testScale_indexes_varargs_computeInPlace_explicitVarargs() {</B></FONT>
    <FONT color="#41a317"><A HREF="javascript:ZweiFrames('match186757-1.html#35',3,'match186757-top.html#35',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 10).computeInPlace(78.9, 12.3, 45.6))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, 12.3,
            10, 78.9);
  }
<A NAME="16"></A>
  public void testScale_indexes_collection_compute_doubleCollection() {</B></FONT>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match186757-1.html#16',3,'match186757-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            Quantiles.scale(10)
                .indexes(ImmutableList.of(0, 10, 5, 1, 8, 1))
                .compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
<A NAME="9"></A>  }

  public void testScale_indexes_collection_computeInPlace() {</B></FONT>
    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match186757-1.html#9',3,'match186757-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
    assertThat(
            Quantiles.scale(10)
                .indexes(ImmutableList.of(0, 10, 5, 1, 8, 1))
                .computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
  }</B></FONT>

  // 2. Tests on hardcoded datasets include non-finite values for chains starting with scale(10):

  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_POSITIVE_INFINITY =
      ImmutableList.of(3.0, 5.0, POSITIVE_INFINITY, 1.0, 4.0, 2.0);
  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_NEGATIVE_INFINITY =
      ImmutableList.of(3.0, 5.0, NEGATIVE_INFINITY, 1.0, 4.0, 2.0);
  private static final ImmutableList&lt;Double&gt; NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES =
      ImmutableList.of(
          POSITIVE_INFINITY,
          POSITIVE_INFINITY,
          NEGATIVE_INFINITY,
          POSITIVE_INFINITY,
          POSITIVE_INFINITY,
          POSITIVE_INFINITY);
  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_NAN =
<A NAME="34"></A>      ImmutableList.of(3.0, 5.0, NaN, 1.0, 4.0, 2.0);

  public void testScale_indexes_varargs_compute_doubleCollection_positiveInfinity() {
    <FONT color="#827d6b"><A HREF="javascript:ZweiFrames('match186757-1.html#34',3,'match186757-top.html#34',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(ONE_TO_FIVE_AND_POSITIVE_INFINITY))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, 1.0,
            1, 1.5,
            2, 2.0,
            8, 5.0,
            9, POSITIVE_INFINITY, // interpolating between 5.0 and POSITIVE_INFNINITY
            10, POSITIVE_INFINITY);
  }
<A NAME="45"></A>
  public void testScale_index_compute_doubleCollection_positiveInfinity() {</B></FONT>
    // interpolating between 5.0 and POSITIVE_INFNINITY
    <FONT color="#549748"><A HREF="javascript:ZweiFrames('match186757-1.html#45',3,'match186757-top.html#45',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(9).compute(ONE_TO_FIVE_AND_POSITIVE_INFINITY))
        .isPositiveInfinity();
<A NAME="33"></A>  }

  public void testScale_indexes_varargs_compute_doubleCollection_negativeInfinity() {</B></FONT>
    <FONT color="#736aff"><A HREF="javascript:ZweiFrames('match186757-1.html#33',3,'match186757-top.html#33',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(ONE_TO_FIVE_AND_NEGATIVE_INFINITY))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NEGATIVE_INFINITY,
            1, NEGATIVE_INFINITY, // interpolating between NEGATIVE_INFNINITY and 1.0
            2, 1.0,
            8, 4.0,
            9, 4.5,
            10, 5.0);
  }
<A NAME="44"></A>
  public void testScale_index_compute_doubleCollection_negativeInfinity() {</B></FONT>
    // interpolating between NEGATIVE_INFNINITY and 1.0
    <FONT color="#a057a5"><A HREF="javascript:ZweiFrames('match186757-1.html#44',3,'match186757-top.html#44',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).index(1).compute(ONE_TO_FIVE_AND_NEGATIVE_INFINITY))
        .isNegativeInfinity();
<A NAME="32"></A>  }

  public void testScale_indexes_varargs_compute_doubleCollection_bothInfinities() {</B></FONT>
    <FONT color="#5b8daf"><A HREF="javascript:ZweiFrames('match186757-1.html#32',3,'match186757-top.html#32',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NEGATIVE_INFINITY,
            1, NaN, // interpolating between NEGATIVE_ and POSITIVE_INFINITY values
            2, POSITIVE_INFINITY,
            8, POSITIVE_INFINITY,
            9, POSITIVE_INFINITY, // interpolating between two POSITIVE_INFINITY values
            10, POSITIVE_INFINITY);
<A NAME="31"></A>  }

  public void testScale_indexes_varargs_compute_doubleCollection_nan() {</B></FONT>
    <FONT color="#3ea99f"><A HREF="javascript:ZweiFrames('match186757-1.html#31',3,'match186757-top.html#31',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(Quantiles.scale(10).indexes(0, 1, 2, 8, 9, 10).compute(ONE_TO_FIVE_AND_NAN))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NaN,
            1, NaN,
            2, NaN,
            8, NaN,
            9, NaN,
            10, NaN);
  }

  public void testScale_index_compute_doubleCollection_nan() {</B></FONT>
    assertThat(Quantiles.scale(10).index(5).compute(ONE_TO_FIVE_AND_NAN)).isNaN();
  }

  // 3. Tests on a mechanically generated dataset for chains starting with percentiles():

  private static final int PSEUDORANDOM_DATASET_SIZE = 9951;
  private static final ImmutableList&lt;Double&gt; PSEUDORANDOM_DATASET = generatePseudorandomDataset();
  private static final ImmutableList&lt;Double&gt; PSEUDORANDOM_DATASET_SORTED =
      Ordering.natural().immutableSortedCopy(PSEUDORANDOM_DATASET);
<A NAME="30"></A>
  private static ImmutableList&lt;Double&gt; generatePseudorandomDataset() {
    Random random = new Random(2211275185798966364L);
    <FONT color="#ae694a"><A HREF="javascript:ZweiFrames('match186757-1.html#30',3,'match186757-top.html#30',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableList.Builder&lt;Double&gt; largeDatasetBuilder = ImmutableList.builder();
    for (int i = 0; i &lt; PSEUDORANDOM_DATASET_SIZE; i++) {
      largeDatasetBuilder.add(random.nextGaussian());
    }
    return</B></FONT> largeDatasetBuilder.build();
  }

  private static double expectedLargeDatasetPercentile(int index) {
    // We have q=100, k=index, and N=9951. Therefore k*(N-1)/q is 99.5*index. If index is even, that
    // is an integer 199*index/2. If index is odd, that is halfway between floor(199*index/2) and
    // ceil(199*index/2).
    if (index % 2 == 0) {
      int position = IntMath.divide(199 * index, 2, UNNECESSARY);
      return PSEUDORANDOM_DATASET_SORTED.get(position);
    } else {
      int positionFloor = IntMath.divide(199 * index, 2, FLOOR);
      int positionCeil = IntMath.divide(199 * index, 2, CEILING);
      double lowerValue = PSEUDORANDOM_DATASET_SORTED.get(positionFloor);
      double upperValue = PSEUDORANDOM_DATASET_SORTED.get(positionCeil);
      return (lowerValue + upperValue) / 2.0;
    }
<A NAME="29"></A>  }

  public void testPercentiles_index_compute_doubleCollection() {
    <FONT color="#af7a82"><A HREF="javascript:ZweiFrames('match186757-1.html#29',3,'match186757-top.html#29',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (int index = 0; index &lt;= 100; index++) {
      assertWithMessage(&quot;quantile at index &quot; + index)
          .that(percentiles</B></FONT>().index(index).compute(PSEUDORANDOM_DATASET))
          .isWithin(ALLOWED_ERROR)
          .of(expectedLargeDatasetPercentile(index));
    }
  }

  @AndroidIncompatible // slow
<A NAME="28"></A>  public void testPercentiles_index_computeInPlace() {
    // Assert that the computation gives the correct result for all possible percentiles.
    for (int index = 0; index &lt;= 100; index++) {
      <FONT color="#717d7d"><A HREF="javascript:ZweiFrames('match186757-1.html#28',3,'match186757-top.html#28',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
      assertWithMessage(&quot;quantile at index &quot; + index)
          .that(percentiles().index(index).computeInPlace(dataset))
          .isWithin(ALLOWED_ERROR)
          .of(expectedLargeDatasetPercentile</B></FONT>(index));
    }

    // Assert that the dataset contains the same elements after the in-place computation (although
    // they may be reordered). We only do this for one index rather than for all indexes, as it is
<A NAME="27"></A>    // quite expensives (quadratic in the size of PSEUDORANDOM_DATASET).
    double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
    @SuppressWarnings(&quot;unused&quot;)
    double actual = <FONT color="#e77471"><A HREF="javascript:ZweiFrames('match186757-1.html#27',3,'match186757-top.html#27',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>percentiles().index(33).computeInPlace(dataset);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(PSEUDORANDOM_DATASET);
  }

  public void testPercentiles_indexes_varargsPairs_compute_doubleCollection() {</B></FONT>
    for (int index1 = 0; index1 &lt;= 100; index1++) {
      for (int index2 = 0; index2 &lt;= 100; index2++) {
        ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = ImmutableMap.builder();
        expectedBuilder.put(index1, expectedLargeDatasetPercentile(index1));
        if (index2 != index1) {
          expectedBuilder.put(index2, expectedLargeDatasetPercentile(index2));
        }
        assertThat(percentiles().indexes(index1, index2).compute(PSEUDORANDOM_DATASET))
            .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
            .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
      }
    }
  }
<A NAME="43"></A>
  public void testPercentiles_indexes_varargsAll_compute_doubleCollection() {
    ArrayList&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
    ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = <FONT color="#c22817"><A HREF="javascript:ZweiFrames('match186757-1.html#43',3,'match186757-top.html#43',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableMap.builder();
    for (int index = 0; index &lt;= 100; index++) {
      indexes.add(index);
<A NAME="12"></A>      expectedBuilder.put(index, expectedLargeDatasetPercentile(index));
    }</B></FONT>
    Random random = new Random(770683168895677741L);
    <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match186757-1.html#12',3,'match186757-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Collections.shuffle(indexes, random);
    assertThat(percentiles().indexes(Ints.toArray(indexes)).compute(PSEUDORANDOM_DATASET))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
  }

  @AndroidIncompatible // slow</B></FONT>
  public void testPercentiles_indexes_varargsAll_computeInPlace() {
    double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
    List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
    ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = ImmutableMap.builder();
    for (int index = 0; index &lt;= 100; index++) {
      indexes.add(index);
<A NAME="5"></A>      expectedBuilder.put(index, expectedLargeDatasetPercentile(index));
    }
    Random random = new Random(770683168895677741L);
    <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match186757-1.html#5',3,'match186757-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Collections.shuffle(indexes, random);
    assertThat(percentiles().indexes(Ints.toArray(indexes)).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(PSEUDORANDOM_DATASET);
  }</B></FONT>

  // 4. Tests of illegal usages of the API:

<A NAME="26"></A>  private static final ImmutableList&lt;Double&gt; EMPTY_DATASET = ImmutableList.of();

  public void testScale_zero() {
    <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match186757-1.html#26',3,'match186757-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      Quantiles.scale(0);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
<A NAME="25"></A>  }

  public void testScale_negative() {
    <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match186757-1.html#25',3,'match186757-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      Quantiles.scale(-4);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
  }
<A NAME="24"></A>
  public void testScale_index_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match186757-1.html#24',3,'match186757-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      intermediate.index(-1);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
  }

  public void testScale_index_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.index(11);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.indexes(1, -1, 3);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.indexes(1, 11, 3);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }
<A NAME="15"></A>
  public void testScale_indexes_collection_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match186757-1.html#15',3,'match186757-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      intermediate.indexes(ImmutableList.of(1, -1, 3));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
  }
<A NAME="14"></A>
  public void testScale_indexes_collection_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match186757-1.html#14',3,'match186757-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      intermediate.indexes(ImmutableList.of(1, 11, 3));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
<A NAME="23"></A>  }

  public void testScale_index_compute_doubleCollection_empty() {
    Quantiles.ScaleAndIndex intermediate = <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match186757-1.html#23',3,'match186757-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Quantiles.scale(10).index(3);
    try {
      intermediate.compute(EMPTY_DATASET);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {</B></FONT>
    }
  }

  public void testScale_index_compute_doubleVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new double[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_compute_longVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new long[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_compute_intVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new int[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_computeInPlace_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.computeInPlace(new double[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_doubleCollection_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(EMPTY_DATASET);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_doubleVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new double[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_longVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new long[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_intVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new int[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_computeInPlace_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.computeInPlace(new double[] {});
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

<A NAME="42"></A>  public void testScale_indexes_indexes_computeInPlace_empty() {
    int[] emptyIndexes = {};
    try {
      Quantiles.ScaleAndIndexes unused = <FONT color="#c57717"><A HREF="javascript:ZweiFrames('match186757-1.html#42',3,'match186757-top.html#42',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Quantiles.scale(10).indexes(emptyIndexes);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }</B></FONT>
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CacheLoadingTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.cache;

import static com.google.common.cache.TestingCacheLoaders.bulkLoader;
import static com.google.common.cache.TestingCacheLoaders.constantLoader;
import static com.google.common.cache.TestingCacheLoaders.errorLoader;
import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
import static com.google.common.cache.TestingCacheLoaders.identityLoader;
import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
import static com.google.common.truth.Truth.assertThat;
import static java.lang.Thread.currentThread;
import static java.util.Arrays.asList;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

<A NAME="0"></A>import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
import com.google.common.cache.TestingCacheLoaders.CountingLoader;
import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#0',2,'match186757-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.testing.FakeTicker;
import com.google.common.testing.TestLogHandler;
import com.google.common.util.concurrent.Callables;
import com.google.common.util.concurrent.ExecutionError;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.UncheckedExecutionException;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.logging.LogRecord;
import junit.framework.TestCase;

/**
 * Tests relating to cache loading: concurrent loading, exceptions during loading, etc.
 *
 * @author mike nonemacher
 */
public class CacheLoadingTest extends TestCase {
  TestLogHandler logHandler</B></FONT>;

  @Override
  public void setUp() throws Exception {
    super.setUp();
    logHandler = new TestLogHandler();
    LocalCache.logger.addHandler(logHandler);
  }

  @Override
  public void tearDown() throws Exception {
    super.tearDown();
    // TODO(cpovirk): run tests in other thread instead of messing with main thread interrupt status
    currentThread().interrupted();
    LocalCache.logger.removeHandler(logHandler);
  }

  private Throwable popLoggedThrowable() {
    List&lt;LogRecord&gt; logRecords = logHandler.getStoredLogRecords();
    assertEquals(1, logRecords.size());
    LogRecord logRecord = logRecords.get(0);
    logHandler.clear();
    return logRecord.getThrown();
  }

  private void checkNothingLogged() {
    assertThat(logHandler.getStoredLogRecords()).isEmpty();
<A NAME="20"></A>  }

  private void checkLoggedCause(Throwable t) {
    <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#20',2,'match186757-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(popLoggedThrowable()).hasCauseThat().isSameInstanceAs(t);
  }

  private void checkLoggedInvalidLoad() {
    assertThat(popLoggedThrowable</B></FONT>()).isInstanceOf(InvalidCacheLoadException.class);
  }

<A NAME="28"></A>  public void testLoad() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(identityLoader());
    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#28',2,'match186757-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount</B></FONT>());

    Object key = new Object();
    assertSame(key, cache.get(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    key = new Object();
    assertSame(key, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    key = new Object();
    cache.refresh(key);
    checkNothingLogged();
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(key, cache.get(key));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    Object value = new Object();
    // callable is not called
    assertSame(key, cache.get(key, throwing(new Exception())));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<A NAME="11"></A>
    key = new Object();
    assertSame(value, cache.get(key, Callables.returning(value)));
    stats = <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#11',2,'match186757-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
  }

  public void testReload() throws ExecutionException {</B></FONT>
    final Object one = new Object();
    final Object two = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkNothingLogged();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
<A NAME="13"></A>
    assertSame(two, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#13',2,'match186757-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefresh() {
    final Object one = new Object()</B></FONT>;
    final Object two = new Object();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<A NAME="12"></A>
    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getUnchecked(key));
    stats = <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#12',2,'match186757-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testRefresh_</B></FONT>getIfPresent() {
    final Object one = new Object();
    final Object two = new Object();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getIfPresent(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getIfPresent(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<A NAME="2"></A>
    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getIfPresent(key));
    stats = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#2',2,'match186757-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoad_default() throws ExecutionException {
    LoadingCache&lt;Integer, Integer&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .build(TestingCacheLoaders.&lt;Integer&gt;identityLoader</B></FONT>());
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());

<A NAME="10"></A>    // duplicate keys are ignored, and don't impact stats
    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
    stats = cache.stats();
    assertEquals(5, <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#10',2,'match186757-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.missCount());
    assertEquals(5, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(4, stats.hitCount());
  }

  public void testBulkLoad_loadAll() throws ExecutionException {
    IdentityLoader&lt;Integer&gt; backingLoader = identityLoader</B></FONT>();
    CacheLoader&lt;Integer, Integer&gt; loader = bulkLoader(backingLoader);
    LoadingCache&lt;Integer, Integer&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());

    // duplicate keys are ignored, and don't impact stats
<A NAME="22"></A>    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
    stats = cache.stats();
    assertEquals(5, stats.missCount());
    <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#22',2,'match186757-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(4, stats.hitCount());
  }

  public void testBulkLoad_extra() throws ExecutionException {
    CacheLoader&lt;Object, Object&gt; loader =</B></FONT>
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            return new Object();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
              // add extra entries
              result.put(value, key);
            }
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
<A NAME="9"></A>    assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
    for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
      Object key = entry.getKey();
      <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#9',2,'match186757-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Object value = entry.getValue();
      assertSame(value, result.get(key));
      assertNull(result.get(value));
      assertSame(value, cache.asMap().get(key));
      assertSame(key, cache.asMap().get(value));
    }</B></FONT>
  }

  public void testBulkLoad_clobber() throws ExecutionException {
    final Object extraKey = new Object();
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
    assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
    for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
      Object key = entry.getKey();
      Object value = entry.getValue();
<A NAME="41"></A>      assertSame(value, result.get(key));
      assertSame(value, cache.asMap().get(key));
    }
    <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#41',2,'match186757-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertNull(result.get(extraKey));
    assertSame(extraValue, cache.asMap().get(extraKey));
  }

  public void testBulkLoad_clobberNullValue() throws ExecutionException {
    final Object extraKey = new Object()</B></FONT>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            result.put(extraValue, null);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
<A NAME="15"></A>    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#15',2,'match186757-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</B></FONT>

<A NAME="21"></A>    for (Object key : lookupKeys) {
      assertTrue(cache.asMap().containsKey(key));
    }
    <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#21',2,'match186757-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(extraValue, cache.asMap().get(extraKey));
    assertFalse(cache.asMap().containsKey(extraValue));
  }

  public void testBulkLoad_clobberNullKey() throws ExecutionException {
    final Object extraKey = new Object()</B></FONT>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            result.put(null, extraKey);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
<A NAME="14"></A>    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#14',2,'match186757-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</B></FONT>

<A NAME="19"></A>    for (Object key : lookupKeys) {
      assertTrue(cache.asMap().containsKey(key));
    }
    <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#19',2,'match186757-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(extraValue, cache.asMap().get(extraKey));
    assertFalse(cache.asMap().containsValue(extraKey));
  }

  public void testBulkLoad_partial() throws ExecutionException {
    final Object extraKey = new Object()</B></FONT>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            // ignore request keys
            result.put(extraKey, extraValue);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
<A NAME="42"></A>
    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    try {
      <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#42',2,'match186757-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</B></FONT>
    assertSame(extraValue, cache.asMap().get(extraKey));
  }

  public void testLoadNull() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object(), Callables.returning(null));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
<A NAME="17"></A>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#17',2,'match186757-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadNull() throws ExecutionException {
    final Object one = new Object()</B></FONT>;
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return null;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
<A NAME="16"></A>
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#16',2,'match186757-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadNullFuture() throws ExecutionException {</B></FONT>
    final Object one = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(null);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<A NAME="40"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#40',2,'match186757-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshNull() {
    final Object one = new Object()</B></FONT>;
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(null);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<A NAME="1"></A>
    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#1',2,'match186757-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadNull() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader</B></FONT>(null)));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
<A NAME="3"></A>      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#3',2,'match186757-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testBulkLoadNullMap() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder</B></FONT>()
            .recordStats()
            .build(
                new CacheLoader&lt;Object, Object&gt;() {
                  @Override
                  public Object load(Object key) {
                    throw new AssertionError();
                  }

                  @Override
                  public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) {
                    return null;
                  }
                });

    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
<A NAME="38"></A>    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#38',2,'match186757-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadError() throws ExecutionException {</B></FONT>
    Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    final Error callableError = new Error();
    try {
      cache.get(
          new Object(),
          new Callable&lt;Object&gt;() {
            @Override
            public Object call() {
              throw callableError;
            }
          });
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<A NAME="37"></A>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#37',2,'match186757-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadError() throws ExecutionException {</B></FONT>
    final Object one = new Object();
    final Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<A NAME="36"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#36',2,'match186757-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureError() throws ExecutionException {</B></FONT>
    final Object one = new Object();
    final Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<A NAME="35"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#35',2,'match186757-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshError() {</B></FONT>
    final Object one = new Object();
    final Error e = new Error();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
<A NAME="34"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#34',2,'match186757-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadError() throws ExecutionException {</B></FONT>
    Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<A NAME="33"></A>    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#33',2,'match186757-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadCheckedException() {</B></FONT>
    Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new Exception();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<A NAME="32"></A>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <FONT color="#5b8daf"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#32',2,'match186757-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadInterruptedException() {</B></FONT>
    Exception e = new InterruptedException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    // Sanity check:
    assertFalse(currentThread().interrupted());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    assertTrue(currentThread().interrupted());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new InterruptedException();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
<A NAME="31"></A>    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#31',2,'match186757-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadCheckedException() {</B></FONT>
    final Object one = new Object();
    final Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<A NAME="27"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#27',2,'match186757-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureCheckedException() {</B></FONT>
    final Object one = new Object();
    final Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<A NAME="45"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <FONT color="#549748"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#45',2,'match186757-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshCheckedException() {</B></FONT>
    final Object one = new Object();
    final Exception e = new Exception();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
<A NAME="44"></A>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <FONT color="#a057a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#44',2,'match186757-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadCheckedException() {</B></FONT>
    Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testBulkLoadInterruptedException() {
    Exception e = new InterruptedException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadUncheckedException() throws ExecutionException {
    Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new RuntimeException();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadUncheckedException() throws ExecutionException {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureUncheckedException() throws ExecutionException {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshUncheckedException() {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadUncheckedException() throws ExecutionException {
    Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadAfterFailure() throws ExecutionException {
    final AtomicInteger count = new AtomicInteger();
    final Exception e = new IllegalStateException(&quot;exception to trigger failure on first load()&quot;);
    CacheLoader&lt;Integer, String&gt; failOnceFunction =
        new CacheLoader&lt;Integer, String&gt;() {

          @Override
          public String load(Integer key) throws Exception {
            if (count.getAndIncrement() == 0) {
              throw e;
            }
            return key.toString();
          }
<A NAME="23"></A>        };
    CountingRemovalListener&lt;Integer, String&gt; removalListener = countingRemovalListener();
    LoadingCache&lt;Integer, String&gt; cache =
        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#23',2,'match186757-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CacheBuilder.newBuilder().removalListener(removalListener).build(failOnceFunction);

    try {
      cache.getUnchecked(1);
      fail();
    } catch (UncheckedExecutionException ue) {</B></FONT>
<A NAME="4"></A>      assertThat(ue).hasCauseThat().isSameInstanceAs(e);
    }

    assertEquals(&quot;1&quot;, <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#4',2,'match186757-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.getUnchecked(1));
    assertEquals(0, removalListener.getCount());

    count.set(0);
    cache.refresh(2);
    checkLoggedCause(e);

    assertEquals(&quot;2&quot;, cache.getUnchecked(2));
    assertEquals(0, removalListener.getCount());
  }


  public void testReloadAfterValueReclamation() throws InterruptedException, ExecutionException {
    CountingLoader countingLoader = new CountingLoader()</B></FONT>;
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().weakValues().build(countingLoader);
    ConcurrentMap&lt;Object, Object&gt; map = cache.asMap();

    int iterations = 10;
    WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(null);
    int expectedComputations = 0;
    for (int i = 0; i &lt; iterations; i++) {
      // The entry should get garbage collected and recomputed.
      Object oldValue = ref.get();
      if (oldValue == null) {
        expectedComputations++;
      }
      ref = new WeakReference&lt;&gt;(cache.getUnchecked(1));
      oldValue = null;
      Thread.sleep(i);
      System.gc();
    }
    assertEquals(expectedComputations, countingLoader.getCount());

    for (int i = 0; i &lt; iterations; i++) {
      // The entry should get garbage collected and recomputed.
      Object oldValue = ref.get();
      if (oldValue == null) {
        expectedComputations++;
      }
      cache.refresh(1);
      checkNothingLogged();
      ref = new WeakReference&lt;&gt;(map.get(1));
      oldValue = null;
      Thread.sleep(i);
      System.gc();
    }
    assertEquals(expectedComputations, countingLoader.getCount());
  }

  public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);

    Object key = new Object();
    assertNotNull(cache.getUnchecked(key));

    CacheTesting.simulateValueReclamation(cache, key);
<A NAME="8"></A>
    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#8',2,'match186757-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cache.size());
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateValueReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(1, cache.size());
    assertEquals(3, countingLoader.getCount());
  }

  public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {</B></FONT>
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);

    Object key = new Object();
<A NAME="7"></A>    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, cache.size());

    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#7',2,'match186757-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CacheTesting.simulateKeyReclamation(cache, key);

    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateKeyReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(3, countingLoader.getCount());
  }

  /**
   * Make sure LoadingCache correctly wraps ExecutionExceptions and UncheckedExecutionExceptions.
   */
  public void testLoadingExceptionWithCause() {</B></FONT>
    final Exception cause = new Exception();
    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
    final ExecutionException ee = new ExecutionException(cause);

    LoadingCache&lt;Object, Object&gt; cacheUnchecked =
        CacheBuilder.newBuilder().build(exceptionLoader(uee));
    LoadingCache&lt;Object, Object&gt; cacheChecked =
        CacheBuilder.newBuilder().build(exceptionLoader(ee));

    try {
      cacheUnchecked.get(new Object());
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheUnchecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);
    }

    cacheUnchecked.refresh(new Object());
    checkLoggedCause(uee);

    try {
      cacheUnchecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheChecked.get(new Object());
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }

    try {
      cacheChecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);
    }

    cacheChecked.refresh(new Object());
    checkLoggedCause(ee);

    try {
      cacheChecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }
  }

  public void testBulkLoadingExceptionWithCause() {
    final Exception cause = new Exception();
    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
    final ExecutionException ee = new ExecutionException(cause);

    LoadingCache&lt;Object, Object&gt; cacheUnchecked =
        CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(uee)));
    LoadingCache&lt;Object, Object&gt; cacheChecked =
        CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(ee)));

    try {
      cacheUnchecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheChecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }
  }


  public void testConcurrentLoading() throws InterruptedException {
    testConcurrentLoading(CacheBuilder.newBuilder());
  }
<A NAME="18"></A>
  private static void testConcurrentLoading(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {
    <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#18',2,'match186757-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>testConcurrentLoadingDefault(builder);
    testConcurrentLoadingNull(builder);
    testConcurrentLoadingUncheckedException(builder);
    testConcurrentLoadingCheckedException(builder);
  }


  public void testConcurrentExpirationLoading() throws InterruptedException {
    testConcurrentLoading(CacheBuilder.newBuilder</B></FONT>().expireAfterWrite(10, TimeUnit.SECONDS));
  }

  /**
   * On a successful concurrent computation, only one thread does the work, but all the threads get
   * the same result.
   */
  private static void testConcurrentLoadingDefault(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final Object result = new Object();

    LoadingCache&lt;String, Object&gt; cache =
        builder.build(
            new CacheLoader&lt;String, Object&gt;() {
              @Override
              public Object load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                return result;
              }
            });

    List&lt;Object&gt; resultArray = doConcurrentGet(cache, &quot;bar&quot;, count, startSignal);

    assertEquals(1, callCount.get());
    for (int i = 0; i &lt; count; i++) {
      assertSame(&quot;result(&quot; + i + &quot;) didn't match expected&quot;, result, resultArray.get(i));
    }
  }

  /**
   * On a concurrent computation that returns null, all threads should get an
   * InvalidCacheLoadException, with the loader only called once. The result should not be cached (a
   * later request should call the loader again).
   */
  private static void testConcurrentLoadingNull(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                return null;
              }
            });
<A NAME="43"></A>
    List&lt;Object&gt; result = doConcurrentGet(cache, &quot;bar&quot;, count, startSignal);

    assertEquals(1, <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#43',2,'match186757-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>callCount.get());
    for (int i = 0; i &lt; count; i++) {
      assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);
<A NAME="26"></A>    }</B></FONT>

    // subsequent calls should call the loader again, not get the old exception
    <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#26',2,'match186757-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      cache.getUnchecked(&quot;bar&quot;);
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</B></FONT>
    assertEquals(2, callCount.get());
  }

  /**
   * On a concurrent computation that throws an unchecked exception, all threads should get the
   * (wrapped) exception, with the loader called only once. The result should not be cached (a later
   * request should call the loader again).
   */
  private static void testConcurrentLoadingUncheckedException(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final RuntimeException e = new RuntimeException();

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                throw e;
              }
            });

<A NAME="29"></A>    List&lt;Object&gt; result = doConcurrentGet(cache, &quot;bar&quot;, count, startSignal);

    assertEquals(1, callCount.get());
    <FONT color="#af7a82"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#29',2,'match186757-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i = 0; i &lt; count; i++) {
      // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
      // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
      assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
      assertThat(((UncheckedExecutionException) result.get</B></FONT>(i))).hasCauseThat().isSameInstanceAs(e);
<A NAME="25"></A>    }

    // subsequent calls should call the loader again, not get the old exception
    <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#25',2,'match186757-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      cache.getUnchecked(&quot;bar&quot;);
      fail();
    } catch (UncheckedExecutionException expected) {
    }</B></FONT>
    assertEquals(2, callCount.get());
  }

  /**
   * On a concurrent computation that throws a checked exception, all threads should get the
   * (wrapped) exception, with the loader called only once. The result should not be cached (a later
   * request should call the loader again).
   */
  private static void testConcurrentLoadingCheckedException(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final IOException e = new IOException();

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws IOException, InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                throw e;
              }
            });

    List&lt;Object&gt; result = doConcurrentGet(cache, &quot;bar&quot;, count, startSignal);

    assertEquals(1, callCount.get());
    for (int i = 0; i &lt; count; i++) {
      // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),
      // we should get an ExecutionException; if we call getUnchecked(), we should get an
      // UncheckedExecutionException.
      int mod = i % 3;
      if (mod == 0 || mod == 2) {
        assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
        assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
      } else {
        assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
        assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
      }
<A NAME="24"></A>    }

    // subsequent calls should call the loader again, not get the old exception
    <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#24',2,'match186757-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      cache.getUnchecked(&quot;bar&quot;);
      fail();
    } catch (UncheckedExecutionException expected) {
    }</B></FONT>
    assertEquals(2, callCount.get());
  }

  /**
   * Test-helper method that performs {@code nThreads} concurrent calls to {@code cache.get(key)} or
   * {@code cache.getUnchecked(key)}, and returns a List containing each of the results. The result
   * for any given call to {@code cache.get} or {@code cache.getUnchecked} is the value returned, or
   * the exception thrown.
   *
   * &lt;p&gt;As we iterate from {@code 0} to {@code nThreads}, threads with an even index will call
   * {@code getUnchecked}, and threads with an odd index will call {@code get}. If the cache throws
   * exceptions, this difference may be visible in the returned List.
   */
  private static &lt;K&gt; List&lt;Object&gt; doConcurrentGet(
      final LoadingCache&lt;K, ?&gt; cache,
      final K key,
      int nThreads,
      final CountDownLatch gettersStartedSignal)
      throws InterruptedException {

    final AtomicReferenceArray&lt;Object&gt; result = new AtomicReferenceArray&lt;&gt;(nThreads);
    final CountDownLatch gettersComplete = new CountDownLatch(nThreads);
    for (int i = 0; i &lt; nThreads; i++) {
      final int index = i;
      Thread thread =
          new Thread(
              new Runnable() {
                @Override
                public void run() {
                  gettersStartedSignal.countDown();
                  Object value = null;
                  try {
                    int mod = index % 3;
                    if (mod == 0) {
                      value = cache.get(key);
                    } else if (mod == 1) {
                      value = cache.getUnchecked(key);
                    } else {
                      cache.refresh(key);
                      value = cache.get(key);
                    }
                    result.set(index, value);
                  } catch (Throwable t) {
                    result.set(index, t);
                  }
                  gettersComplete.countDown();
                }
              });
      thread.start();
      // we want to wait until each thread is WAITING - one thread waiting inside CacheLoader.load
      // (in startSignal.await()), and the others waiting for that thread's result.
      while (thread.isAlive() &amp;&amp; thread.getState() != Thread.State.WAITING) {
        Thread.yield();
      }
    }
<A NAME="30"></A>    gettersStartedSignal.countDown();
    gettersComplete.await();

    <FONT color="#ae694a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#30',2,'match186757-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>List&lt;Object&gt; resultList = Lists.newArrayListWithExpectedSize(nThreads);
    for (int i = 0; i &lt; nThreads; i++) {
      resultList.add(result.get(i));
    }
    return</B></FONT> resultList;
  }


  public void testAsMapDuringLoading() throws InterruptedException, ExecutionException {
    final CountDownLatch getStartedSignal = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = &quot;get&quot;;
    final String refreshKey = &quot;refresh&quot;;
    final String suffix = &quot;Suffix&quot;;

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            getStartedSignal.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, map.get(refreshKey));

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    getStartedSignal.await();

<A NAME="6"></A>    // computation is in progress; asMap shouldn't have changed
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#6',2,'match186757-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.get(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // asMap view should have been updated
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }


  public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {</B></FONT>
    // computation starts; invalidate() is called on the key being computed, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = &quot;get&quot;;
    final String refreshKey = &quot;refresh&quot;;
    final String suffix = &quot;Suffix&quot;;

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
<A NAME="5"></A>    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#5',2,'match186757-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.containsKey(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // results should be visible
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
    assertEquals(2, cache.size());
  }</B></FONT>


  public void testInvalidateAndReloadDuringLoading()
      throws InterruptedException, ExecutionException {
    // computation starts; clear() is called, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(4);
    final String getKey = &quot;get&quot;;
    final String refreshKey = &quot;refresh&quot;;
    final String suffix = &quot;Suffix&quot;;

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(map.containsKey(refreshKey));

    // start new computations
    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();
<A NAME="39"></A>
    // results should be visible
    assertEquals(2, cache.size());
    <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match186757-0.html#39',2,'match186757-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }


  public void testExpandDuringLoading() throws InterruptedException {
    final int count = 3;
    final AtomicInteger callCount = new AtomicInteger()</B></FONT>;
    // tells the computing thread when to start computing
    final CountDownLatch computeSignal = new CountDownLatch(1);
    // tells the main thread when computation is pending
    final CountDownLatch secondSignal = new CountDownLatch(1);
    // tells the main thread when the second get has started
    final CountDownLatch thirdSignal = new CountDownLatch(1);
    // tells the main thread when the third get has started
    final CountDownLatch fourthSignal = new CountDownLatch(1);
    // tells the test when all gets have returned
    final CountDownLatch doneSignal = new CountDownLatch(count);

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            callCount.incrementAndGet();
            secondSignal.countDown();
            computeSignal.await();
            return key + &quot;foo&quot;;
          }
        };

    final LoadingCache&lt;String, String&gt; cache =
        CacheBuilder.newBuilder().weakKeys().build(computeFunction);

    final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(count);

    final String key = &quot;bar&quot;;

    // start computing thread
    new Thread() {
      @Override
      public void run() {
        result.set(0, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // wait for computation to start
    secondSignal.await();

    // start waiting thread
    new Thread() {
      @Override
      public void run() {
        thirdSignal.countDown();
        result.set(1, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the second get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    thirdSignal.await();
    Thread.yield();

    // Expand!
    CacheTesting.forceExpandSegment(cache, key);

    // start another waiting thread
    new Thread() {
      @Override
      public void run() {
        fourthSignal.countDown();
        result.set(2, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the third get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    fourthSignal.await();
    Thread.yield();

    // let computation finish
    computeSignal.countDown();
    doneSignal.await();

    assertTrue(callCount.get() == 1);
    assertEquals(&quot;barfoo&quot;, result.get(0));
    assertEquals(&quot;barfoo&quot;, result.get(1));
    assertEquals(&quot;barfoo&quot;, result.get(2));
    assertEquals(&quot;barfoo&quot;, cache.getUnchecked(key));
  }

  // Test ignored because it is extremely flaky in CI builds

  public void
      ignoreTestExpandDuringRefresh()
      throws InterruptedException, ExecutionException {
    final AtomicInteger callCount = new AtomicInteger();
    // tells the computing thread when to start computing
    final CountDownLatch computeSignal = new CountDownLatch(1);
    // tells the main thread when computation is pending
    final CountDownLatch secondSignal = new CountDownLatch(1);
    // tells the main thread when the second get has started
    final CountDownLatch thirdSignal = new CountDownLatch(1);
    // tells the main thread when the third get has started
    final CountDownLatch fourthSignal = new CountDownLatch(1);
    // tells the test when all gets have returned
    final CountDownLatch doneSignal = new CountDownLatch(3);
    final String suffix = &quot;Suffix&quot;;

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            callCount.incrementAndGet();
            secondSignal.countDown();
            computeSignal.await();
            return key + suffix;
          }
        };

    final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(2);

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    final String key = &quot;bar&quot;;
    cache.asMap().put(key, key);

    // start computing thread
    new Thread() {
      @Override
      public void run() {
        cache.refresh(key);
        doneSignal.countDown();
      }
    }.start();

    // wait for computation to start
    secondSignal.await();
    checkNothingLogged();

    // start waiting thread
    new Thread() {
      @Override
      public void run() {
        thirdSignal.countDown();
        result.set(0, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the second get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    thirdSignal.await();
    Thread.yield();

    // Expand!
    CacheTesting.forceExpandSegment(cache, key);

    // start another waiting thread
    new Thread() {
      @Override
      public void run() {
        fourthSignal.countDown();
        result.set(1, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the third get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    fourthSignal.await();
    Thread.yield();

    // let computation finish
    computeSignal.countDown();
    doneSignal.await();

    assertTrue(callCount.get() == 1);
    assertEquals(key, result.get(0));
    assertEquals(key, result.get(1));
    assertEquals(key + suffix, cache.getUnchecked(key));
  }

  static &lt;T&gt; Callable&lt;T&gt; throwing(final Exception exception) {
    return new Callable&lt;T&gt;() {
      @Override
      public T call() throws Exception {
        throw exception;
      }
    };
  }
}
</PRE>
</div>
  </div>
</body>
</html>
