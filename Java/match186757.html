<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for QuantilesTest.java &amp; CacheLoadingTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for QuantilesTest.java &amp; CacheLoadingTest.java
      </h3>
<h1 align="center">
        21.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>QuantilesTest.java (54.701717%)<th>CacheLoadingTest.java (13.115151%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-78)<td><a href="#" name="0">(31-64)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(187-198)<td><a href="#" name="1">(815-824)</a><td align="center"><font color="#ad0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(206-214)<td><a href="#" name="2">(324-335)</a><td align="center"><font color="#a30000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(307-323)<td><a href="#" name="3">(836-845)</a><td align="center"><font color="#9a0000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(335-348)<td><a href="#" name="4">(1758-1771)</a><td align="center"><font color="#880000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(589-594)<td><a href="#" name="5">(2289-2301)</a><td align="center"><font color="#7f0000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(348-360)<td><a href="#" name="6">(2233-2247)</a><td align="center"><font color="#7f0000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(158-167)<td><a href="#" name="7">(1839-1854)</a><td align="center"><font color="#7f0000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(144-151)<td><a href="#" name="8">(1820-1830)</a><td align="center"><font color="#7f0000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(384-397)<td><a href="#" name="9">(451-456)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(294-306)<td><a href="#" name="10">(372-379)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(132-137)<td><a href="#" name="11">(153-160)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(573-579)<td><a href="#" name="12">(262-269)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(323-335)<td><a href="#" name="13">(201-208)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(663-667)<td><a href="#" name="14">(564-568)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(654-658)<td><a href="#" name="15">(524-528)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(370-383)<td><a href="#" name="16">(708-714)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(228-242)<td><a href="#" name="17">(663-669)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(214-221)<td><a href="#" name="18">(1951-1959)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(180-186)<td><a href="#" name="19">(573-578)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(168-174)<td><a href="#" name="20">(94-98)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(152-158)<td><a href="#" name="21">(533-538)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(138-144)<td><a href="#" name="22">(419-425)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(671-675)<td><a href="#" name="23">(1749-1754)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(618-622)<td><a href="#" name="24">(2117-2121)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(609-613)<td><a href="#" name="25">(2067-2071)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(601-605)<td><a href="#" name="26">(2024-2028)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(546-550)<td><a href="#" name="27">(1320-1325)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(534-538)<td><a href="#" name="28">(104-108)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(522-524)<td><a href="#" name="29">(2059-2063)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(498-502)<td><a href="#" name="30">(2180-2184)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(474-485)<td><a href="#" name="31">(1273-1278)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(459-473)<td><a href="#" name="32">(1197-1202)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(438-452)<td><a href="#" name="33">(1129-1134)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(417-431)<td><a href="#" name="34">(1105-1110)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#41a317")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#41a317"><font color="#41a317">-</font><td><a href="#" name="35">(361-368)<td><a href="#" name="35">(1042-1047)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#ff00ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ff00ff"><font color="#ff00ff">-</font><td><a href="#" name="36">(283-293)<td><a href="#" name="36">(995-1000)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#810541")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#810541"><font color="#810541">-</font><td><a href="#" name="37">(271-281)<td><a href="#" name="37">(948-953)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#348781")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#348781"><font color="#348781">-</font><td><a href="#" name="38">(262-269)<td><a href="#" name="38">(873-878)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#152dc6")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#152dc6"><font color="#152dc6">-</font><td><a href="#" name="39">(245-257)<td><a href="#" name="39">(2372-2379)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#347235")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#347235"><font color="#347235">-</font><td><a href="#" name="40">(198-205)<td><a href="#" name="40">(755-761)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#f87a17")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f87a17"><font color="#f87a17">-</font><td><a href="#" name="41">(126-132)<td><a href="#" name="41">(493-498)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#c57717")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c57717"><font color="#c57717">-</font><td><a href="#" name="42">(763-766)<td><a href="#" name="42">(599-602)</a><td align="center"><font color="#510000">9</font>
<tr onclick='openModal("#c22817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c22817"><font color="#c22817">-</font><td><a href="#" name="43">(567-571)<td><a href="#" name="43">(2018-2021)</a><td align="center"><font color="#510000">9</font>
<tr onclick='openModal("#a057a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#a057a5"><font color="#a057a5">-</font><td><a href="#" name="44">(454-458)<td><a href="#" name="44">(1430-1435)</a><td align="center"><font color="#510000">9</font>
<tr onclick='openModal("#549748")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#549748"><font color="#549748">-</font><td><a href="#" name="45">(433-437)<td><a href="#" name="45">(1367-1372)</a><td align="center"><font color="#510000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>QuantilesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="0"></a>
package com.google.common.math;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.math.Quantiles.median;
import static com.google.common.math.Quantiles.percentiles;
import static com.google.common.math.Quantiles.quartiles;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;
import static java.lang.Double.NEGATIVE_INFINITY;
import static java.lang.Double.NaN;
import static java.lang.Double.POSITIVE_INFINITY;
import static java.math.RoundingMode.CEILING;
import static java.math.RoundingMode.FLOOR;
import static java.math.RoundingMode.UNNECESSARY;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Ordering;
import com.google.common.math.Quantiles.ScaleAndIndexes;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.truth.Correspondence;
import com.google.common.truth.Correspondence.BinaryPredicate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import junit.framework.TestCase;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Tests for {@link Quantiles}.
 *
 * @author Pete Gillin
 */
public class QuantilesTest extends TestCase {

  /*
   * Since Quantiles provides a fluent-style API, each test covers a chain of methods resulting in
   * the computation of one or more quantiles (or in an error) rather than individual methods. The
   * tests are divided into three sections:
   * 1. Tests on a hardcoded dataset for chains starting with median(), quartiles(), and scale(10);
   * 2. Tests on hardcoded datasets include non-finite values for chains starting with scale(10);
   * 3. Tests on a mechanically generated dataset for chains starting with percentiles();
   * 4. Tests of illegal usages of the API.
   */

  /*
   * Covering every combination would lead to an explosion in the number of tests. So we cover only:
   * - median with compute taking a double-collection and with computeInPlace;
   * - quartiles with index and with indexes taking int-varargs, and with compute taking a
   *   double-collection and with computeInPlace;
   * - scale with index and with indexes taking int-varargs, and with all overloads of compute
   *   taking a double-collection and with computeInPlace;
   * - scale with indexes taking integer-collection with compute taking a double-collection and with
   *   computeInPlace;
   * - (except that, for non-finite values, we don't do all combinations exhaustively);
   * - percentiles with index and with indexes taking int-varargs, and with compute taking a
   *   double-collection and with computeInPlace.
   */

  private static final double ALLOWED_ERROR = 1.0e-10</b></font>;

  /**
   * A {@link Correspondence} which accepts finite values within {@link #ALLOWED_ERROR} of each
   * other.
   */
  private static final Correspondence&lt;Number, Number&gt; FINITE_QUANTILE_CORRESPONDENCE =
      Correspondence.tolerance(ALLOWED_ERROR);

  /**
   * A {@link Correspondence} which accepts either finite values within {@link #ALLOWED_ERROR} of
   * each other or identical non-finite values.
   */
  private static final Correspondence&lt;Double, Double&gt; QUANTILE_CORRESPONDENCE =
      Correspondence.from(
          new BinaryPredicate&lt;Double, Double&gt;() {
            @Override
            public boolean apply(@Nullable Double actual, @Nullable Double expected) {
              // Test for equality to allow non-finite values to match; otherwise, use the finite
              // test.
              return actual.equals(expected)
                  || FINITE_QUANTILE_CORRESPONDENCE.compare(actual, expected);
            }
          },
          "is identical to or " + FINITE_QUANTILE_CORRESPONDENCE);

  // 1. Tests on a hardcoded dataset for chains starting with median(), quartiles(), and scale(10):

  /** The squares of the 16 integers from 0 to 15, in an arbitrary order. */
  private static final ImmutableList&lt;Double&gt; SIXTEEN_SQUARES_DOUBLES =
      ImmutableList.of(
          25.0, 100.0, 0.0, 144.0, 9.0, 121.0, 4.0, 225.0, 169.0, 64.0, 49.0, 16.0, 36.0, 1.0, 81.0,
          196.0);

  private static final ImmutableList&lt;Long&gt; SIXTEEN_SQUARES_LONGS =
      ImmutableList.of(
          25L, 100L, 0L, 144L, 9L, 121L, 4L, 225L, 169L, 64L, 49L, 16L, 36L, 1L, 81L, 196L);
  private static final ImmutableList&lt;Integer&gt; SIXTEEN_SQUARES_INTEGERS =
      ImmutableList.of(25, 100, 0, 144, 9, 121, 4, 225, 169, 64, 49, 16, 36, 1, 81, 196);
  private static final double SIXTEEN_SQUARES_MIN = 0.0;
  private static final double SIXTEEN_SQUARES_DECILE_1 = 0.5 * (1.0 + 4.0);
  private static final double SIXTEEN_SQUARES_QUARTILE_1 = 0.25 * 9.0 + 0.75 * 16.0;
  private static final double SIXTEEN_SQUARES_MEDIAN = 0.5 * (49.0 + 64.0);
  private static final double SIXTEEN_SQUARES_QUARTILE_3 = 0.75 * 121.0 + 0.25 * 144.0;
  private static final double SIXTEEN_SQUARES_DECILE_8 = 144.0;
<a name="41"></a>  private static final double SIXTEEN_SQUARES_MAX = 225.0;

  public void testMedian_compute_doubleCollection() {
    <font color="#f87a17"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(median().compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_MEDIAN);
<a name="11"></a>  }

  public void testMedian_computeInPlace() {
    double[] dataset = <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</b></font>;
    assertThat(median().computeInPlace(dataset)).isWithin(ALLOWED_ERROR).of(SIXTEEN_SQUARES_MEDIAN);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<a name="22"></a>  }

  public void testQuartiles_index_compute_doubleCollection() {</b></font>
    <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(quartiles().index(1).compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_QUARTILE_1);
<a name="8"></a>  }

  public void testQuartiles_index_computeInPlace() {
    double[] dataset = <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</b></font>;
    assertThat(quartiles().index(1).computeInPlace(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_QUARTILE_1);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<a name="21"></a>  }

  public void testQuartiles_indexes_varargs_compute_doubleCollection() {</b></font>
    <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(quartiles().indexes(1, 3).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(1, SIXTEEN_SQUARES_QUARTILE_1, 3, SIXTEEN_SQUARES_QUARTILE_3);
<a name="7"></a>  }

  public void testQuartiles_indexes_varargs_computeInPlace() {
    double[] dataset = <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</b></font>;
    assertThat(quartiles().indexes(1, 3).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            1, SIXTEEN_SQUARES_QUARTILE_1,
            3, SIXTEEN_SQUARES_QUARTILE_3);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<a name="20"></a>  }

  public void testScale_index_compute_doubleCollection() {</b></font>
    <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_DOUBLES))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
  }

  public void testScale_index_compute_longCollection() {
    assertThat</b></font>(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_LONGS))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
<a name="19"></a>  }

  public void testScale_index_compute_integerCollection() {
    <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(1).compute(SIXTEEN_SQUARES_INTEGERS))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
  }
<a name="1"></a>
  public void testScale_index_compute_doubleVarargs() {
    double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</b></font>;
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(1).compute(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset)
        .usingExactEquality()
        .containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES)
        .inOrder();
  }
<a name="40"></a>
  public void testScale_index_compute_longVarargs() {
    long[] dataset = Longs.toArray(SIXTEEN_SQUARES_LONGS);
    assertThat(<font color="#347235"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Quantiles.scale(10).index(1).compute</b></font>(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_LONGS);
  }
<a name="2"></a>
  public void testScale_index_compute_intVarargs() {
    int[] dataset = Ints.toArray(SIXTEEN_SQUARES_INTEGERS)</b></font>;
    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(1).compute(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_INTEGERS);
  }
<a name="18"></a>
  public void testScale_index_computeInPlace() {
    double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
    assertThat</b></font>(<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Quantiles.scale(10).index(1).computeInPlace(dataset))
        .isWithin(ALLOWED_ERROR)
        .of(SIXTEEN_SQUARES_DECILE_1);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
  }

  public void testScale_index_computeInPlace_explicitVarargs() {
    assertThat</b></font>(Quantiles.scale(10).index(5).computeInPlace(78.9, 12.3, 45.6))
        .isWithin(ALLOWED_ERROR)
        .of(45.6);
  }
<a name="17"></a>
  public void testScale_indexes_varargs_compute_doubleCollection() {
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }

  public void testScale_indexes_varargs_compute_doubleCollection_snapshotsIndexes() {
    // This test is the same as testScale_indexes_varargs_compute_doubleCollection except that the
    // array of indexes to be calculated is modified between the calls to indexes and compute: since
    // the contract is that it is snapshotted, this shouldn't make any difference to the result.
<a name="39"></a>    int[] indexes = {0, 10, 5, 1, 8, 10}</b></font>;
    ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(indexes);
    indexes[0] = 3;
    <font color="#152dc6"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(intermediate.compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }

  public void testScale_indexes_largeVarargs_compute_doubleCollection() {
    int scale = Integer.MAX_VALUE;
    int otherIndex = (Integer.MAX_VALUE - 1) / 3</b></font>; // this divides exactly
    // For the otherIndex calculation, we have q=Integer.MAX_VALUE, k=(Integer.MAX_VALUE-1)/3, and
<a name="38"></a>    // N=16. Therefore k*(N-1)/q = 5-5/Integer.MAX_VALUE, which has floor 4 and fractional part
    // (1-5/Integer.MAX_VALUE).
    double otherValue = 16.0 * 5.0 / Integer.MAX_VALUE + 25.0 * (1.0 - 5.0 / Integer.MAX_VALUE);
    <font color="#348781"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(
            Quantiles.scale(scale).indexes(0, scale, otherIndex).compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN, scale, SIXTEEN_SQUARES_MAX, otherIndex, otherValue);
  }
<a name="37"></a>
  public void testScale_indexes_varargs_compute_longCollection() {</b></font>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <font color="#810541"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_LONGS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
  }
<a name="36"></a>
  public void testScale_indexes_varargs_compute_integerCollection() {</b></font>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <font color="#ff00ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
<a name="10"></a>  }

  public void testScale_indexes_varargs_compute_indexOrderIsMaintained() {</b></font>
    <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8)
        .inOrder();
  }
<a name="3"></a>
  public void testScale_indexes_varargs_compute_doubleVarargs() {
    double[] dataset = Doubles.toArray</b></font>(SIXTEEN_SQUARES_DOUBLES);
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset)
        .usingExactEquality()
        .containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES)
        .inOrder();
  }
<a name="13"></a>
  public void testScale_indexes_varargs_compute_longVarargs() {
    long[] dataset = Longs.toArray(SIXTEEN_SQUARES_LONGS);
    <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))</b></font>
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_LONGS);
<a name="4"></a>  }

  public void testScale_indexes_varargs_compute_intVarargs() {
    int[] dataset = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Ints.toArray(SIXTEEN_SQUARES_INTEGERS)</b></font>;
    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).asList().isEqualTo(SIXTEEN_SQUARES_INTEGERS);
<a name="6"></a>  }

  public void testScale_indexes_varargs_computeInPlace() {
    double[] dataset = <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Doubles.toArray(SIXTEEN_SQUARES_DOUBLES)</b></font>;
    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
<a name="35"></a>  }

  public void testScale_indexes_varargs_computeInPlace_explicitVarargs() {</b></font>
    <font color="#41a317"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 10).computeInPlace(78.9, 12.3, 45.6))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, 12.3,
            10, 78.9);
  }
<a name="16"></a>
  public void testScale_indexes_collection_compute_doubleCollection() {</b></font>
    // Note that we specify index 1 twice, which by the method contract should be ignored.
    <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(
            Quantiles.scale(10)
                .indexes(ImmutableList.of(0, 10, 5, 1, 8, 1))
                .compute(SIXTEEN_SQUARES_DOUBLES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
<a name="9"></a>  }

  public void testScale_indexes_collection_computeInPlace() {</b></font>
    <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
    assertThat(
            Quantiles.scale(10)
                .indexes(ImmutableList.of(0, 10, 5, 1, 8, 1))
                .computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, SIXTEEN_SQUARES_MIN,
            10, SIXTEEN_SQUARES_MAX,
            5, SIXTEEN_SQUARES_MEDIAN,
            1, SIXTEEN_SQUARES_DECILE_1,
            8, SIXTEEN_SQUARES_DECILE_8);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(SIXTEEN_SQUARES_DOUBLES);
  }</b></font>

  // 2. Tests on hardcoded datasets include non-finite values for chains starting with scale(10):

  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_POSITIVE_INFINITY =
      ImmutableList.of(3.0, 5.0, POSITIVE_INFINITY, 1.0, 4.0, 2.0);
  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_NEGATIVE_INFINITY =
      ImmutableList.of(3.0, 5.0, NEGATIVE_INFINITY, 1.0, 4.0, 2.0);
  private static final ImmutableList&lt;Double&gt; NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES =
      ImmutableList.of(
          POSITIVE_INFINITY,
          POSITIVE_INFINITY,
          NEGATIVE_INFINITY,
          POSITIVE_INFINITY,
          POSITIVE_INFINITY,
          POSITIVE_INFINITY);
  private static final ImmutableList&lt;Double&gt; ONE_TO_FIVE_AND_NAN =
<a name="34"></a>      ImmutableList.of(3.0, 5.0, NaN, 1.0, 4.0, 2.0);

  public void testScale_indexes_varargs_compute_doubleCollection_positiveInfinity() {
    <font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(ONE_TO_FIVE_AND_POSITIVE_INFINITY))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, 1.0,
            1, 1.5,
            2, 2.0,
            8, 5.0,
            9, POSITIVE_INFINITY, // interpolating between 5.0 and POSITIVE_INFNINITY
            10, POSITIVE_INFINITY);
  }
<a name="45"></a>
  public void testScale_index_compute_doubleCollection_positiveInfinity() {</b></font>
    // interpolating between 5.0 and POSITIVE_INFNINITY
    <font color="#549748"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(9).compute(ONE_TO_FIVE_AND_POSITIVE_INFINITY))
        .isPositiveInfinity();
<a name="33"></a>  }

  public void testScale_indexes_varargs_compute_doubleCollection_negativeInfinity() {</b></font>
    <font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(ONE_TO_FIVE_AND_NEGATIVE_INFINITY))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NEGATIVE_INFINITY,
            1, NEGATIVE_INFINITY, // interpolating between NEGATIVE_INFNINITY and 1.0
            2, 1.0,
            8, 4.0,
            9, 4.5,
            10, 5.0);
  }
<a name="44"></a>
  public void testScale_index_compute_doubleCollection_negativeInfinity() {</b></font>
    // interpolating between NEGATIVE_INFNINITY and 1.0
    <font color="#a057a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).index(1).compute(ONE_TO_FIVE_AND_NEGATIVE_INFINITY))
        .isNegativeInfinity();
<a name="32"></a>  }

  public void testScale_indexes_varargs_compute_doubleCollection_bothInfinities() {</b></font>
    <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(
            Quantiles.scale(10)
                .indexes(0, 1, 2, 8, 9, 10)
                .compute(NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NEGATIVE_INFINITY,
            1, NaN, // interpolating between NEGATIVE_ and POSITIVE_INFINITY values
            2, POSITIVE_INFINITY,
            8, POSITIVE_INFINITY,
            9, POSITIVE_INFINITY, // interpolating between two POSITIVE_INFINITY values
            10, POSITIVE_INFINITY);
<a name="31"></a>  }

  public void testScale_indexes_varargs_compute_doubleCollection_nan() {</b></font>
    <font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(Quantiles.scale(10).indexes(0, 1, 2, 8, 9, 10).compute(ONE_TO_FIVE_AND_NAN))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactly(
            0, NaN,
            1, NaN,
            2, NaN,
            8, NaN,
            9, NaN,
            10, NaN);
  }

  public void testScale_index_compute_doubleCollection_nan() {</b></font>
    assertThat(Quantiles.scale(10).index(5).compute(ONE_TO_FIVE_AND_NAN)).isNaN();
  }

  // 3. Tests on a mechanically generated dataset for chains starting with percentiles():

  private static final int PSEUDORANDOM_DATASET_SIZE = 9951;
  private static final ImmutableList&lt;Double&gt; PSEUDORANDOM_DATASET = generatePseudorandomDataset();
  private static final ImmutableList&lt;Double&gt; PSEUDORANDOM_DATASET_SORTED =
      Ordering.natural().immutableSortedCopy(PSEUDORANDOM_DATASET);
<a name="30"></a>
  private static ImmutableList&lt;Double&gt; generatePseudorandomDataset() {
    Random random = new Random(2211275185798966364L);
    <font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ImmutableList.Builder&lt;Double&gt; largeDatasetBuilder = ImmutableList.builder();
    for (int i = 0; i &lt; PSEUDORANDOM_DATASET_SIZE; i++) {
      largeDatasetBuilder.add(random.nextGaussian());
    }
    return</b></font> largeDatasetBuilder.build();
  }

  private static double expectedLargeDatasetPercentile(int index) {
    // We have q=100, k=index, and N=9951. Therefore k*(N-1)/q is 99.5*index. If index is even, that
    // is an integer 199*index/2. If index is odd, that is halfway between floor(199*index/2) and
    // ceil(199*index/2).
    if (index % 2 == 0) {
      int position = IntMath.divide(199 * index, 2, UNNECESSARY);
      return PSEUDORANDOM_DATASET_SORTED.get(position);
    } else {
      int positionFloor = IntMath.divide(199 * index, 2, FLOOR);
      int positionCeil = IntMath.divide(199 * index, 2, CEILING);
      double lowerValue = PSEUDORANDOM_DATASET_SORTED.get(positionFloor);
      double upperValue = PSEUDORANDOM_DATASET_SORTED.get(positionCeil);
      return (lowerValue + upperValue) / 2.0;
    }
<a name="29"></a>  }

  public void testPercentiles_index_compute_doubleCollection() {
    <font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int index = 0; index &lt;= 100; index++) {
      assertWithMessage("quantile at index " + index)
          .that(percentiles</b></font>().index(index).compute(PSEUDORANDOM_DATASET))
          .isWithin(ALLOWED_ERROR)
          .of(expectedLargeDatasetPercentile(index));
    }
  }

  @AndroidIncompatible // slow
<a name="28"></a>  public void testPercentiles_index_computeInPlace() {
    // Assert that the computation gives the correct result for all possible percentiles.
    for (int index = 0; index &lt;= 100; index++) {
      <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
      assertWithMessage("quantile at index " + index)
          .that(percentiles().index(index).computeInPlace(dataset))
          .isWithin(ALLOWED_ERROR)
          .of(expectedLargeDatasetPercentile</b></font>(index));
    }

    // Assert that the dataset contains the same elements after the in-place computation (although
    // they may be reordered). We only do this for one index rather than for all indexes, as it is
<a name="27"></a>    // quite expensives (quadratic in the size of PSEUDORANDOM_DATASET).
    double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
    @SuppressWarnings("unused")
    double actual = <font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>percentiles().index(33).computeInPlace(dataset);
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(PSEUDORANDOM_DATASET);
  }

  public void testPercentiles_indexes_varargsPairs_compute_doubleCollection() {</b></font>
    for (int index1 = 0; index1 &lt;= 100; index1++) {
      for (int index2 = 0; index2 &lt;= 100; index2++) {
        ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = ImmutableMap.builder();
        expectedBuilder.put(index1, expectedLargeDatasetPercentile(index1));
        if (index2 != index1) {
          expectedBuilder.put(index2, expectedLargeDatasetPercentile(index2));
        }
        assertThat(percentiles().indexes(index1, index2).compute(PSEUDORANDOM_DATASET))
            .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
            .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
      }
    }
  }
<a name="43"></a>
  public void testPercentiles_indexes_varargsAll_compute_doubleCollection() {
    ArrayList&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
    ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = <font color="#c22817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ImmutableMap.builder();
    for (int index = 0; index &lt;= 100; index++) {
      indexes.add(index);
<a name="12"></a>      expectedBuilder.put(index, expectedLargeDatasetPercentile(index));
    }</b></font>
    Random random = new Random(770683168895677741L);
    <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Collections.shuffle(indexes, random);
    assertThat(percentiles().indexes(Ints.toArray(indexes)).compute(PSEUDORANDOM_DATASET))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
  }

  @AndroidIncompatible // slow</b></font>
  public void testPercentiles_indexes_varargsAll_computeInPlace() {
    double[] dataset = Doubles.toArray(PSEUDORANDOM_DATASET);
    List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
    ImmutableMap.Builder&lt;Integer, Double&gt; expectedBuilder = ImmutableMap.builder();
    for (int index = 0; index &lt;= 100; index++) {
      indexes.add(index);
<a name="5"></a>      expectedBuilder.put(index, expectedLargeDatasetPercentile(index));
    }
    Random random = new Random(770683168895677741L);
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Collections.shuffle(indexes, random);
    assertThat(percentiles().indexes(Ints.toArray(indexes)).computeInPlace(dataset))
        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
        .containsExactlyEntriesIn(expectedBuilder.buildOrThrow());
    assertThat(dataset).usingExactEquality().containsExactlyElementsIn(PSEUDORANDOM_DATASET);
  }</b></font>

  // 4. Tests of illegal usages of the API:

<a name="26"></a>  private static final ImmutableList&lt;Double&gt; EMPTY_DATASET = ImmutableList.of();

  public void testScale_zero() {
    <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
      Quantiles.scale(0);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
<a name="25"></a>  }

  public void testScale_negative() {
    <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
      Quantiles.scale(-4);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
  }
<a name="24"></a>
  public void testScale_index_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
      intermediate.index(-1);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
  }

  public void testScale_index_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.index(11);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.indexes(1, -1, 3);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    try {
      intermediate.indexes(1, 11, 3);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
<a name="15"></a>
  public void testScale_indexes_collection_negative() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
      intermediate.indexes(ImmutableList.of(1, -1, 3));
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
  }
<a name="14"></a>
  public void testScale_indexes_collection_tooHigh() {
    Quantiles.Scale intermediate = Quantiles.scale(10);
    <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
      intermediate.indexes(ImmutableList.of(1, 11, 3));
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
<a name="23"></a>  }

  public void testScale_index_compute_doubleCollection_empty() {
    Quantiles.ScaleAndIndex intermediate = <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Quantiles.scale(10).index(3);
    try {
      intermediate.compute(EMPTY_DATASET);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {</b></font>
    }
  }

  public void testScale_index_compute_doubleVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new double[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_compute_longVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new long[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_compute_intVarargs_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.compute(new int[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_index_computeInPlace_empty() {
    Quantiles.ScaleAndIndex intermediate = Quantiles.scale(10).index(3);
    try {
      intermediate.computeInPlace(new double[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_doubleCollection_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(EMPTY_DATASET);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_doubleVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new double[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_longVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new long[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_compute_intVarargs_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.compute(new int[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testScale_indexes_varargs_computeInPlace_empty() {
    Quantiles.ScaleAndIndexes intermediate = Quantiles.scale(10).indexes(1, 3, 5);
    try {
      intermediate.computeInPlace(new double[] {});
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

<a name="42"></a>  public void testScale_indexes_indexes_computeInPlace_empty() {
    int[] emptyIndexes = {};
    try {
      Quantiles.ScaleAndIndexes unused = <font color="#c57717"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Quantiles.scale(10).indexes(emptyIndexes);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }</b></font>
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CacheLoadingTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.cache;

import static com.google.common.cache.TestingCacheLoaders.bulkLoader;
import static com.google.common.cache.TestingCacheLoaders.constantLoader;
import static com.google.common.cache.TestingCacheLoaders.errorLoader;
import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
import static com.google.common.cache.TestingCacheLoaders.identityLoader;
import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
import static com.google.common.truth.Truth.assertThat;
import static java.lang.Thread.currentThread;
import static java.util.Arrays.asList;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

<a name="0"></a>import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
import com.google.common.cache.TestingCacheLoaders.CountingLoader;
import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.testing.FakeTicker;
import com.google.common.testing.TestLogHandler;
import com.google.common.util.concurrent.Callables;
import com.google.common.util.concurrent.ExecutionError;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.UncheckedExecutionException;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.logging.LogRecord;
import junit.framework.TestCase;

/**
 * Tests relating to cache loading: concurrent loading, exceptions during loading, etc.
 *
 * @author mike nonemacher
 */
public class CacheLoadingTest extends TestCase {
  TestLogHandler logHandler</b></font>;

  @Override
  public void setUp() throws Exception {
    super.setUp();
    logHandler = new TestLogHandler();
    LocalCache.logger.addHandler(logHandler);
  }

  @Override
  public void tearDown() throws Exception {
    super.tearDown();
    // TODO(cpovirk): run tests in other thread instead of messing with main thread interrupt status
    currentThread().interrupted();
    LocalCache.logger.removeHandler(logHandler);
  }

  private Throwable popLoggedThrowable() {
    List&lt;LogRecord&gt; logRecords = logHandler.getStoredLogRecords();
    assertEquals(1, logRecords.size());
    LogRecord logRecord = logRecords.get(0);
    logHandler.clear();
    return logRecord.getThrown();
  }

  private void checkNothingLogged() {
    assertThat(logHandler.getStoredLogRecords()).isEmpty();
<a name="20"></a>  }

  private void checkLoggedCause(Throwable t) {
    <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(popLoggedThrowable()).hasCauseThat().isSameInstanceAs(t);
  }

  private void checkLoggedInvalidLoad() {
    assertThat(popLoggedThrowable</b></font>()).isInstanceOf(InvalidCacheLoadException.class);
  }

<a name="28"></a>  public void testLoad() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(identityLoader());
    <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount</b></font>());

    Object key = new Object();
    assertSame(key, cache.get(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    key = new Object();
    assertSame(key, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    key = new Object();
    cache.refresh(key);
    checkNothingLogged();
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(key, cache.get(key));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    Object value = new Object();
    // callable is not called
    assertSame(key, cache.get(key, throwing(new Exception())));
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<a name="11"></a>
    key = new Object();
    assertSame(value, cache.get(key, Callables.returning(value)));
    stats = <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
  }

  public void testReload() throws ExecutionException {</b></font>
    final Object one = new Object();
    final Object two = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkNothingLogged();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
<a name="13"></a>
    assertSame(two, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefresh() {
    final Object one = new Object()</b></font>;
    final Object two = new Object();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<a name="12"></a>
    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getUnchecked(key));
    stats = <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testRefresh_</b></font>getIfPresent() {
    final Object one = new Object();
    final Object two = new Object();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(two);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getIfPresent(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getIfPresent(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<a name="2"></a>
    ticker.advance(1, MILLISECONDS);
    assertSame(two, cache.getIfPresent(key));
    stats = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoad_default() throws ExecutionException {
    LoadingCache&lt;Integer, Integer&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .build(TestingCacheLoaders.&lt;Integer&gt;identityLoader</b></font>());
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(4, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());

<a name="10"></a>    // duplicate keys are ignored, and don't impact stats
    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
    stats = cache.stats();
    assertEquals(5, <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.missCount());
    assertEquals(5, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(4, stats.hitCount());
  }

  public void testBulkLoad_loadAll() throws ExecutionException {
    IdentityLoader&lt;Integer&gt; backingLoader = identityLoader</b></font>();
    CacheLoader&lt;Integer, Integer&gt; loader = bulkLoader(backingLoader);
    LoadingCache&lt;Integer, Integer&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(2, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());

    // duplicate keys are ignored, and don't impact stats
<a name="22"></a>    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
    stats = cache.stats();
    assertEquals(5, stats.missCount());
    <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(3, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(4, stats.hitCount());
  }

  public void testBulkLoad_extra() throws ExecutionException {
    CacheLoader&lt;Object, Object&gt; loader =</b></font>
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            return new Object();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
              // add extra entries
              result.put(value, key);
            }
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
<a name="9"></a>    assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
    for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
      Object key = entry.getKey();
      <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Object value = entry.getValue();
      assertSame(value, result.get(key));
      assertNull(result.get(value));
      assertSame(value, cache.asMap().get(key));
      assertSame(key, cache.asMap().get(value));
    }</b></font>
  }

  public void testBulkLoad_clobber() throws ExecutionException {
    final Object extraKey = new Object();
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
    assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
    for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
      Object key = entry.getKey();
      Object value = entry.getValue();
<a name="41"></a>      assertSame(value, result.get(key));
      assertSame(value, cache.asMap().get(key));
    }
    <font color="#f87a17"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertNull(result.get(extraKey));
    assertSame(extraValue, cache.asMap().get(extraKey));
  }

  public void testBulkLoad_clobberNullValue() throws ExecutionException {
    final Object extraKey = new Object()</b></font>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            result.put(extraValue, null);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
<a name="15"></a>    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
      cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</b></font>

<a name="21"></a>    for (Object key : lookupKeys) {
      assertTrue(cache.asMap().containsKey(key));
    }
    <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertSame(extraValue, cache.asMap().get(extraKey));
    assertFalse(cache.asMap().containsKey(extraValue));
  }

  public void testBulkLoad_clobberNullKey() throws ExecutionException {
    final Object extraKey = new Object()</b></font>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            for (Object key : keys) {
              Object value = new Object();
              result.put(key, value);
            }
            result.put(extraKey, extraValue);
            result.put(null, extraKey);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
    cache.asMap().put(extraKey, extraKey);
<a name="14"></a>    assertSame(extraKey, cache.asMap().get(extraKey));

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
      cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</b></font>

<a name="19"></a>    for (Object key : lookupKeys) {
      assertTrue(cache.asMap().containsKey(key));
    }
    <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertSame(extraValue, cache.asMap().get(extraKey));
    assertFalse(cache.asMap().containsValue(extraKey));
  }

  public void testBulkLoad_partial() throws ExecutionException {
    final Object extraKey = new Object()</b></font>;
    final Object extraValue = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
            Map&lt;Object, Object&gt; result = Maps.newHashMap();
            // ignore request keys
            result.put(extraKey, extraValue);
            return result;
          }
        };
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
<a name="42"></a>
    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    try {
      <font color="#c57717"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</b></font>
    assertSame(extraValue, cache.asMap().get(extraKey));
  }

  public void testLoadNull() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object(), Callables.returning(null));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
<a name="17"></a>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadNull() throws ExecutionException {
    final Object one = new Object()</b></font>;
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return null;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
<a name="16"></a>
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadNullFuture() throws ExecutionException {</b></font>
    final Object one = new Object();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(null);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedInvalidLoad();
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<a name="40"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <font color="#347235"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshNull() {
    final Object one = new Object()</b></font>;
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFuture(null);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());
<a name="1"></a>
    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadNull() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader</b></font>(null)));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
<a name="3"></a>      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testBulkLoadNullMap() throws ExecutionException {
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder</b></font>()
            .recordStats()
            .build(
                new CacheLoader&lt;Object, Object&gt;() {
                  @Override
                  public Object load(Object key) {
                    throw new AssertionError();
                  }

                  @Override
                  public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) {
                    return null;
                  }
                });

    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
<a name="38"></a>    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#348781"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadError() throws ExecutionException {</b></font>
    Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    final Error callableError = new Error();
    try {
      cache.get(
          new Object(),
          new Callable&lt;Object&gt;() {
            @Override
            public Object call() {
              throw callableError;
            }
          });
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<a name="37"></a>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <font color="#810541"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadError() throws ExecutionException {</b></font>
    final Object one = new Object();
    final Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<a name="36"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#ff00ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureError() throws ExecutionException {</b></font>
    final Object one = new Object();
    final Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<a name="35"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#41a317"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshError() {</b></font>
    final Object one = new Object();
    final Error e = new Error();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
<a name="34"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadError() throws ExecutionException {</b></font>
    Error e = new Error();
    CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionError expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<a name="33"></a>    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadCheckedException() {</b></font>
    Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new Exception();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
<a name="32"></a>    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadInterruptedException() {</b></font>
    Exception e = new InterruptedException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    // Sanity check:
    assertFalse(currentThread().interrupted());

    try {
      cache.get(new Object());
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    assertTrue(currentThread().interrupted());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new InterruptedException();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
<a name="31"></a>    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    <font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadCheckedException() {</b></font>
    final Object one = new Object();
    final Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<a name="27"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureCheckedException() {</b></font>
    final Object one = new Object();
    final Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

<a name="45"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <font color="#549748"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshCheckedException() {</b></font>
    final Object one = new Object();
    final Exception e = new Exception();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
<a name="44"></a>    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, <font color="#a057a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadCheckedException() {</b></font>
    Exception e = new Exception();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testBulkLoadInterruptedException() {
    Exception e = new InterruptedException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testLoadUncheckedException() throws ExecutionException {
    Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.get(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(new Object());
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(2, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(3, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    Exception callableException = new RuntimeException();
    try {
      cache.get(new Object(), throwing(callableException));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
    }
    stats = cache.stats();
    assertEquals(3, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(4, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(4, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(5, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadUncheckedException() throws ExecutionException {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
            throw e;
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testReloadFutureUncheckedException() throws ExecutionException {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    cache.refresh(key);
    checkLoggedCause(e);
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());
  }

  public void testRefreshUncheckedException() {
    final Object one = new Object();
    final Exception e = new RuntimeException();
    FakeTicker ticker = new FakeTicker();
    CacheLoader&lt;Object, Object&gt; loader =
        new CacheLoader&lt;Object, Object&gt;() {
          @Override
          public Object load(Object key) {
            return one;
          }

          @Override
          public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
            return Futures.immediateFailedFuture(e);
          }
        };

    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .ticker(ticker)
            .refreshAfterWrite(1, MILLISECONDS)
            .build(loader);
    Object key = new Object();
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(1, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    // refreshed
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(2, stats.hitCount());

    ticker.advance(1, MILLISECONDS);
    assertSame(one, cache.getUnchecked(key));
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(1, stats.loadSuccessCount());
    assertEquals(2, stats.loadExceptionCount());
    assertEquals(3, stats.hitCount());
  }

  public void testBulkLoadUncheckedException() throws ExecutionException {
    Exception e = new RuntimeException();
    CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertThat(expected).hasCauseThat().isSameInstanceAs(e);
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }

  public void testReloadAfterFailure() throws ExecutionException {
    final AtomicInteger count = new AtomicInteger();
    final Exception e = new IllegalStateException("exception to trigger failure on first load()");
    CacheLoader&lt;Integer, String&gt; failOnceFunction =
        new CacheLoader&lt;Integer, String&gt;() {

          @Override
          public String load(Integer key) throws Exception {
            if (count.getAndIncrement() == 0) {
              throw e;
            }
            return key.toString();
          }
<a name="23"></a>        };
    CountingRemovalListener&lt;Integer, String&gt; removalListener = countingRemovalListener();
    LoadingCache&lt;Integer, String&gt; cache =
        <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CacheBuilder.newBuilder().removalListener(removalListener).build(failOnceFunction);

    try {
      cache.getUnchecked(1);
      fail();
    } catch (UncheckedExecutionException ue) {</b></font>
<a name="4"></a>      assertThat(ue).hasCauseThat().isSameInstanceAs(e);
    }

    assertEquals("1", <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.getUnchecked(1));
    assertEquals(0, removalListener.getCount());

    count.set(0);
    cache.refresh(2);
    checkLoggedCause(e);

    assertEquals("2", cache.getUnchecked(2));
    assertEquals(0, removalListener.getCount());
  }


  public void testReloadAfterValueReclamation() throws InterruptedException, ExecutionException {
    CountingLoader countingLoader = new CountingLoader()</b></font>;
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().weakValues().build(countingLoader);
    ConcurrentMap&lt;Object, Object&gt; map = cache.asMap();

    int iterations = 10;
    WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(null);
    int expectedComputations = 0;
    for (int i = 0; i &lt; iterations; i++) {
      // The entry should get garbage collected and recomputed.
      Object oldValue = ref.get();
      if (oldValue == null) {
        expectedComputations++;
      }
      ref = new WeakReference&lt;&gt;(cache.getUnchecked(1));
      oldValue = null;
      Thread.sleep(i);
      System.gc();
    }
    assertEquals(expectedComputations, countingLoader.getCount());

    for (int i = 0; i &lt; iterations; i++) {
      // The entry should get garbage collected and recomputed.
      Object oldValue = ref.get();
      if (oldValue == null) {
        expectedComputations++;
      }
      cache.refresh(1);
      checkNothingLogged();
      ref = new WeakReference&lt;&gt;(map.get(1));
      oldValue = null;
      Thread.sleep(i);
      System.gc();
    }
    assertEquals(expectedComputations, countingLoader.getCount());
  }

  public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);

    Object key = new Object();
    assertNotNull(cache.getUnchecked(key));

    CacheTesting.simulateValueReclamation(cache, key);
<a name="8"></a>
    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.size());
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateValueReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(1, cache.size());
    assertEquals(3, countingLoader.getCount());
  }

  public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {</b></font>
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache&lt;Object, Object&gt; cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);

    Object key = new Object();
<a name="7"></a>    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, cache.size());

    <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CacheTesting.simulateKeyReclamation(cache, key);

    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateKeyReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(3, countingLoader.getCount());
  }

  /**
   * Make sure LoadingCache correctly wraps ExecutionExceptions and UncheckedExecutionExceptions.
   */
  public void testLoadingExceptionWithCause() {</b></font>
    final Exception cause = new Exception();
    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
    final ExecutionException ee = new ExecutionException(cause);

    LoadingCache&lt;Object, Object&gt; cacheUnchecked =
        CacheBuilder.newBuilder().build(exceptionLoader(uee));
    LoadingCache&lt;Object, Object&gt; cacheChecked =
        CacheBuilder.newBuilder().build(exceptionLoader(ee));

    try {
      cacheUnchecked.get(new Object());
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheUnchecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);
    }

    cacheUnchecked.refresh(new Object());
    checkLoggedCause(uee);

    try {
      cacheUnchecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheChecked.get(new Object());
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }

    try {
      cacheChecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);
    }

    cacheChecked.refresh(new Object());
    checkLoggedCause(ee);

    try {
      cacheChecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }
  }

  public void testBulkLoadingExceptionWithCause() {
    final Exception cause = new Exception();
    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
    final ExecutionException ee = new ExecutionException(cause);

    LoadingCache&lt;Object, Object&gt; cacheUnchecked =
        CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(uee)));
    LoadingCache&lt;Object, Object&gt; cacheChecked =
        CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(ee)));

    try {
      cacheUnchecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
    }

    try {
      cacheChecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException caughtEe) {
      assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
    }
  }


  public void testConcurrentLoading() throws InterruptedException {
    testConcurrentLoading(CacheBuilder.newBuilder());
  }
<a name="18"></a>
  private static void testConcurrentLoading(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {
    <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>testConcurrentLoadingDefault(builder);
    testConcurrentLoadingNull(builder);
    testConcurrentLoadingUncheckedException(builder);
    testConcurrentLoadingCheckedException(builder);
  }


  public void testConcurrentExpirationLoading() throws InterruptedException {
    testConcurrentLoading(CacheBuilder.newBuilder</b></font>().expireAfterWrite(10, TimeUnit.SECONDS));
  }

  /**
   * On a successful concurrent computation, only one thread does the work, but all the threads get
   * the same result.
   */
  private static void testConcurrentLoadingDefault(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final Object result = new Object();

    LoadingCache&lt;String, Object&gt; cache =
        builder.build(
            new CacheLoader&lt;String, Object&gt;() {
              @Override
              public Object load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                return result;
              }
            });

    List&lt;Object&gt; resultArray = doConcurrentGet(cache, "bar", count, startSignal);

    assertEquals(1, callCount.get());
    for (int i = 0; i &lt; count; i++) {
      assertSame("result(" + i + ") didn't match expected", result, resultArray.get(i));
    }
  }

  /**
   * On a concurrent computation that returns null, all threads should get an
   * InvalidCacheLoadException, with the loader only called once. The result should not be cached (a
   * later request should call the loader again).
   */
  private static void testConcurrentLoadingNull(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                return null;
              }
            });
<a name="43"></a>
    List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);

    assertEquals(1, <font color="#c22817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>callCount.get());
    for (int i = 0; i &lt; count; i++) {
      assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);
<a name="26"></a>    }</b></font>

    // subsequent calls should call the loader again, not get the old exception
    <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
      cache.getUnchecked("bar");
      fail();
    } catch (InvalidCacheLoadException expected) {
    }</b></font>
    assertEquals(2, callCount.get());
  }

  /**
   * On a concurrent computation that throws an unchecked exception, all threads should get the
   * (wrapped) exception, with the loader called only once. The result should not be cached (a later
   * request should call the loader again).
   */
  private static void testConcurrentLoadingUncheckedException(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final RuntimeException e = new RuntimeException();

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                throw e;
              }
            });

<a name="29"></a>    List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);

    assertEquals(1, callCount.get());
    <font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (int i = 0; i &lt; count; i++) {
      // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
      // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
      assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
      assertThat(((UncheckedExecutionException) result.get</b></font>(i))).hasCauseThat().isSameInstanceAs(e);
<a name="25"></a>    }

    // subsequent calls should call the loader again, not get the old exception
    <font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
      cache.getUnchecked("bar");
      fail();
    } catch (UncheckedExecutionException expected) {
    }</b></font>
    assertEquals(2, callCount.get());
  }

  /**
   * On a concurrent computation that throws a checked exception, all threads should get the
   * (wrapped) exception, with the loader called only once. The result should not be cached (a later
   * request should call the loader again).
   */
  private static void testConcurrentLoadingCheckedException(CacheBuilder&lt;Object, Object&gt; builder)
      throws InterruptedException {

    int count = 10;
    final AtomicInteger callCount = new AtomicInteger();
    final CountDownLatch startSignal = new CountDownLatch(count + 1);
    final IOException e = new IOException();

    LoadingCache&lt;String, String&gt; cache =
        builder.build(
            new CacheLoader&lt;String, String&gt;() {
              @Override
              public String load(String key) throws IOException, InterruptedException {
                callCount.incrementAndGet();
                startSignal.await();
                throw e;
              }
            });

    List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);

    assertEquals(1, callCount.get());
    for (int i = 0; i &lt; count; i++) {
      // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),
      // we should get an ExecutionException; if we call getUnchecked(), we should get an
      // UncheckedExecutionException.
      int mod = i % 3;
      if (mod == 0 || mod == 2) {
        assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
        assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
      } else {
        assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
        assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
      }
<a name="24"></a>    }

    // subsequent calls should call the loader again, not get the old exception
    <font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
      cache.getUnchecked("bar");
      fail();
    } catch (UncheckedExecutionException expected) {
    }</b></font>
    assertEquals(2, callCount.get());
  }

  /**
   * Test-helper method that performs {@code nThreads} concurrent calls to {@code cache.get(key)} or
   * {@code cache.getUnchecked(key)}, and returns a List containing each of the results. The result
   * for any given call to {@code cache.get} or {@code cache.getUnchecked} is the value returned, or
   * the exception thrown.
   *
   * &lt;p&gt;As we iterate from {@code 0} to {@code nThreads}, threads with an even index will call
   * {@code getUnchecked}, and threads with an odd index will call {@code get}. If the cache throws
   * exceptions, this difference may be visible in the returned List.
   */
  private static &lt;K&gt; List&lt;Object&gt; doConcurrentGet(
      final LoadingCache&lt;K, ?&gt; cache,
      final K key,
      int nThreads,
      final CountDownLatch gettersStartedSignal)
      throws InterruptedException {

    final AtomicReferenceArray&lt;Object&gt; result = new AtomicReferenceArray&lt;&gt;(nThreads);
    final CountDownLatch gettersComplete = new CountDownLatch(nThreads);
    for (int i = 0; i &lt; nThreads; i++) {
      final int index = i;
      Thread thread =
          new Thread(
              new Runnable() {
                @Override
                public void run() {
                  gettersStartedSignal.countDown();
                  Object value = null;
                  try {
                    int mod = index % 3;
                    if (mod == 0) {
                      value = cache.get(key);
                    } else if (mod == 1) {
                      value = cache.getUnchecked(key);
                    } else {
                      cache.refresh(key);
                      value = cache.get(key);
                    }
                    result.set(index, value);
                  } catch (Throwable t) {
                    result.set(index, t);
                  }
                  gettersComplete.countDown();
                }
              });
      thread.start();
      // we want to wait until each thread is WAITING - one thread waiting inside CacheLoader.load
      // (in startSignal.await()), and the others waiting for that thread's result.
      while (thread.isAlive() &amp;&amp; thread.getState() != Thread.State.WAITING) {
        Thread.yield();
      }
    }
<a name="30"></a>    gettersStartedSignal.countDown();
    gettersComplete.await();

    <font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;Object&gt; resultList = Lists.newArrayListWithExpectedSize(nThreads);
    for (int i = 0; i &lt; nThreads; i++) {
      resultList.add(result.get(i));
    }
    return</b></font> resultList;
  }


  public void testAsMapDuringLoading() throws InterruptedException, ExecutionException {
    final CountDownLatch getStartedSignal = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            getStartedSignal.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, map.get(refreshKey));

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    getStartedSignal.await();

<a name="6"></a>    // computation is in progress; asMap shouldn't have changed
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>map.get(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // asMap view should have been updated
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }


  public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {</b></font>
    // computation starts; invalidate() is called on the key being computed, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
<a name="5"></a>    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>map.containsKey(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // results should be visible
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
    assertEquals(2, cache.size());
  }</b></font>


  public void testInvalidateAndReloadDuringLoading()
      throws InterruptedException, ExecutionException {
    // computation starts; clear() is called, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(4);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap&lt;String, String&gt; map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(map.containsKey(refreshKey));

    // start new computations
    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();
<a name="39"></a>
    // results should be visible
    assertEquals(2, cache.size());
    <font color="#152dc6"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }


  public void testExpandDuringLoading() throws InterruptedException {
    final int count = 3;
    final AtomicInteger callCount = new AtomicInteger()</b></font>;
    // tells the computing thread when to start computing
    final CountDownLatch computeSignal = new CountDownLatch(1);
    // tells the main thread when computation is pending
    final CountDownLatch secondSignal = new CountDownLatch(1);
    // tells the main thread when the second get has started
    final CountDownLatch thirdSignal = new CountDownLatch(1);
    // tells the main thread when the third get has started
    final CountDownLatch fourthSignal = new CountDownLatch(1);
    // tells the test when all gets have returned
    final CountDownLatch doneSignal = new CountDownLatch(count);

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            callCount.incrementAndGet();
            secondSignal.countDown();
            computeSignal.await();
            return key + "foo";
          }
        };

    final LoadingCache&lt;String, String&gt; cache =
        CacheBuilder.newBuilder().weakKeys().build(computeFunction);

    final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(count);

    final String key = "bar";

    // start computing thread
    new Thread() {
      @Override
      public void run() {
        result.set(0, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // wait for computation to start
    secondSignal.await();

    // start waiting thread
    new Thread() {
      @Override
      public void run() {
        thirdSignal.countDown();
        result.set(1, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the second get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    thirdSignal.await();
    Thread.yield();

    // Expand!
    CacheTesting.forceExpandSegment(cache, key);

    // start another waiting thread
    new Thread() {
      @Override
      public void run() {
        fourthSignal.countDown();
        result.set(2, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the third get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    fourthSignal.await();
    Thread.yield();

    // let computation finish
    computeSignal.countDown();
    doneSignal.await();

    assertTrue(callCount.get() == 1);
    assertEquals("barfoo", result.get(0));
    assertEquals("barfoo", result.get(1));
    assertEquals("barfoo", result.get(2));
    assertEquals("barfoo", cache.getUnchecked(key));
  }

  // Test ignored because it is extremely flaky in CI builds

  public void
      ignoreTestExpandDuringRefresh()
      throws InterruptedException, ExecutionException {
    final AtomicInteger callCount = new AtomicInteger();
    // tells the computing thread when to start computing
    final CountDownLatch computeSignal = new CountDownLatch(1);
    // tells the main thread when computation is pending
    final CountDownLatch secondSignal = new CountDownLatch(1);
    // tells the main thread when the second get has started
    final CountDownLatch thirdSignal = new CountDownLatch(1);
    // tells the main thread when the third get has started
    final CountDownLatch fourthSignal = new CountDownLatch(1);
    // tells the test when all gets have returned
    final CountDownLatch doneSignal = new CountDownLatch(3);
    final String suffix = "Suffix";

    CacheLoader&lt;String, String&gt; computeFunction =
        new CacheLoader&lt;String, String&gt;() {
          @Override
          public String load(String key) throws InterruptedException {
            callCount.incrementAndGet();
            secondSignal.countDown();
            computeSignal.await();
            return key + suffix;
          }
        };

    final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(2);

    final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
    final String key = "bar";
    cache.asMap().put(key, key);

    // start computing thread
    new Thread() {
      @Override
      public void run() {
        cache.refresh(key);
        doneSignal.countDown();
      }
    }.start();

    // wait for computation to start
    secondSignal.await();
    checkNothingLogged();

    // start waiting thread
    new Thread() {
      @Override
      public void run() {
        thirdSignal.countDown();
        result.set(0, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the second get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    thirdSignal.await();
    Thread.yield();

    // Expand!
    CacheTesting.forceExpandSegment(cache, key);

    // start another waiting thread
    new Thread() {
      @Override
      public void run() {
        fourthSignal.countDown();
        result.set(1, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the third get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    fourthSignal.await();
    Thread.yield();

    // let computation finish
    computeSignal.countDown();
    doneSignal.await();

    assertTrue(callCount.get() == 1);
    assertEquals(key, result.get(0));
    assertEquals(key, result.get(1));
    assertEquals(key + suffix, cache.getUnchecked(key));
  }

  static &lt;T&gt; Callable&lt;T&gt; throwing(final Exception exception) {
    return new Callable&lt;T&gt;() {
      @Override
      public T call() throws Exception {
        throw exception;
      }
    };
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
