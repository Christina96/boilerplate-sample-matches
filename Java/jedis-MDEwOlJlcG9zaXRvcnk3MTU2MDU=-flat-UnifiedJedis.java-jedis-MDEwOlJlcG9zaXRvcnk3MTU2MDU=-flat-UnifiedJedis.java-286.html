
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.net.URI;
3  import java.time.Duration;
4  import java.util.List;
5  import java.util.Map;
6  import java.util.Set;
7  import java.util.regex.Pattern;
8  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
9  import org.json.JSONArray;
10  import redis.clients.jedis.args.*;
11  import redis.clients.jedis.bloom.*;
12  import redis.clients.jedis.commands.JedisCommands;
13  import redis.clients.jedis.commands.JedisBinaryCommands;
14  import redis.clients.jedis.commands.ProtocolCommand;
15  import redis.clients.jedis.commands.SampleBinaryKeyedCommands;
16  import redis.clients.jedis.commands.SampleKeyedCommands;
17  import redis.clients.jedis.commands.RedisModuleCommands;
18  import redis.clients.jedis.exceptions.JedisException;
19  import redis.clients.jedis.executors.*;
20  import redis.clients.jedis.graph.GraphCommandObjects;
21  import redis.clients.jedis.graph.ResultSet;
22  import redis.clients.jedis.json.JsonSetParams;
23  import redis.clients.jedis.json.Path;
24  import redis.clients.jedis.json.Path2;
25  import redis.clients.jedis.json.JsonObjectMapper;
26  import redis.clients.jedis.params.*;
27  import redis.clients.jedis.providers.*;
28  import redis.clients.jedis.resps.*;
29  import redis.clients.jedis.search.*;
30  import redis.clients.jedis.search.aggr.AggregationBuilder;
31  import redis.clients.jedis.search.aggr.AggregationResult;
32  import redis.clients.jedis.search.aggr.FtAggregateIteration;
33  import redis.clients.jedis.search.schemafields.SchemaField;
34  import redis.clients.jedis.timeseries.*;
35  import redis.clients.jedis.util.IOUtils;
36  import redis.clients.jedis.util.JedisURIHelper;
37  import redis.clients.jedis.util.KeyValue;
38  public class UnifiedJedis implements JedisCommands, JedisBinaryCommands,
39      SampleKeyedCommands, SampleBinaryKeyedCommands, RedisModuleCommands,
40      AutoCloseable {
41    protected RedisProtocol protocol = null;
42    protected final ConnectionProvider provider;
43    protected final CommandExecutor executor;
44    protected final CommandObjects commandObjects;
45    private final GraphCommandObjects graphCommandObjects;
46    private JedisBroadcastAndRoundRobinConfig broadcastAndRoundRobinConfig = null;
47    public UnifiedJedis() {
48      this(new HostAndPort(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT));
49    }
50    public UnifiedJedis(HostAndPort hostAndPort) {
51      this(new PooledConnectionProvider(hostAndPort));
52    }
53    public UnifiedJedis(final String url) {
54      this(URI.create(url));
55    }
56    public UnifiedJedis(final URI uri) {
57      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
58          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
59          .database(JedisURIHelper.getDBIndex(uri)).protocol(JedisURIHelper.getRedisProtocol(uri))
60          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
61    }
62    public UnifiedJedis(final URI uri, JedisClientConfig config) {
63      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
64          .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
65          .socketTimeoutMillis(config.getSocketTimeoutMillis())
66          .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
67          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
68          .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
69          .protocol(JedisURIHelper.getRedisProtocol(uri))
70          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
71          .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
72          .build());
73    }
74    public UnifiedJedis(HostAndPort hostAndPort, JedisClientConfig clientConfig) {
75      this(new PooledConnectionProvider(hostAndPort, clientConfig));
76      RedisProtocol proto = clientConfig.getRedisProtocol();
77      if (proto != null) commandObjects.setProtocol(proto);
78    }
79    public UnifiedJedis(ConnectionProvider provider) {
80      this.provider = provider;
81      this.executor = new DefaultCommandExecutor(provider);
82      this.commandObjects = new CommandObjects();
83      this.graphCommandObjects = new GraphCommandObjects(this);
84      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
85      try (Connection conn = this.provider.getConnection()) {
86        if (conn != null) {
87          RedisProtocol proto = conn.getRedisProtocol();
88          if (proto != null) commandObjects.setProtocol(proto);
89        }
90      } catch (JedisException je) { 
91      }
92    }
93    public UnifiedJedis(JedisSocketFactory socketFactory) {
94      this(new Connection(socketFactory));
95    }
96    public UnifiedJedis(JedisSocketFactory socketFactory, JedisClientConfig clientConfig) {
97      this(new Connection(socketFactory, clientConfig));
98    }
99    public UnifiedJedis(Connection connection) {
100      this.provider = null;
101      this.executor = new SimpleCommandExecutor(connection);
102      this.commandObjects = new CommandObjects();
103      this.graphCommandObjects = new GraphCommandObjects(this);
104      RedisProtocol proto = connection.getRedisProtocol();
105      if (proto == RedisProtocol.RESP3) this.commandObjects.setProtocol(proto);
106    }
107    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts) {
108      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts,
109          Duration.ofMillis(maxAttempts * clientConfig.getSocketTimeoutMillis()));
110      RedisProtocol proto = clientConfig.getRedisProtocol();
111      if (proto != null) commandObjects.setProtocol(proto);
112    }
113    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
114      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts, maxTotalRetriesDuration);
115      RedisProtocol proto = clientConfig.getRedisProtocol();
116      if (proto != null) commandObjects.setProtocol(proto);
117    }
118    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig,
119        GenericObjectPoolConfig&lt;Connection&gt; poolConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
120      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig, poolConfig), maxAttempts, maxTotalRetriesDuration);
121      RedisProtocol proto = clientConfig.getRedisProtocol();
122      if (proto != null) commandObjects.setProtocol(proto);
123    }
124    public UnifiedJedis(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
125      this.provider = provider;
126      this.executor = new ClusterCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
127      this.commandObjects = new ClusterCommandObjects();
128      this.graphCommandObjects = new GraphCommandObjects(this);
129      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
130    }
131    @Deprecated
132    public UnifiedJedis(ShardedConnectionProvider provider) {
133      this.provider = provider;
134      this.executor = new DefaultCommandExecutor(provider);
135      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo());
136      this.graphCommandObjects = new GraphCommandObjects(this);
137      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
138    }
139    @Deprecated
140    public UnifiedJedis(ShardedConnectionProvider provider, Pattern tagPattern) {
141      this.provider = provider;
142      this.executor = new DefaultCommandExecutor(provider);
143      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo(), tagPattern);
144      this.graphCommandObjects = new GraphCommandObjects(this);
145      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
146    }
147    public UnifiedJedis(ConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
148      this.provider = provider;
149      this.executor = new RetryableCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
150      this.commandObjects = new CommandObjects();
151      this.graphCommandObjects = new GraphCommandObjects(this);
152      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
153    }
154    public UnifiedJedis(MultiClusterPooledConnectionProvider provider) {
155      this.provider = provider;
156      this.executor = new CircuitBreakerCommandExecutor(provider);
157      this.commandObjects = new CommandObjects();
158      this.graphCommandObjects = new GraphCommandObjects(this);
159      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
160    }
161    public UnifiedJedis(CommandExecutor executor) {
162      this.provider = null;
163      this.executor = executor;
164      this.commandObjects = new CommandObjects();
165      this.graphCommandObjects = new GraphCommandObjects(this);
166      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
167    }
168    @Override
169    public void close() {
170      IOUtils.closeQuietly(this.executor);
171    }
172    protected final void setProtocol(RedisProtocol protocol) {
173      this.protocol = protocol;
174      this.commandObjects.setProtocol(this.protocol);
175    }
176    public final &lt;T&gt; T executeCommand(CommandObject&lt;T&gt; commandObject) {
177      return executor.executeCommand(commandObject);
178    }
179    public final &lt;T&gt; T broadcastCommand(CommandObject&lt;T&gt; commandObject) {
180      return executor.broadcastCommand(commandObject);
181    }
182    private &lt;T&gt; T checkAndBroadcastCommand(CommandObject&lt;T&gt; commandObject) {
183      boolean broadcast = true;
184      if (broadcastAndRoundRobinConfig == null) {
185      } else if (commandObject.getArguments().getCommand() instanceof SearchProtocol.SearchCommand
186          &amp;&amp; broadcastAndRoundRobinConfig.getRediSearchModeInCluster() == JedisBroadcastAndRoundRobinConfig.RediSearchMode.LIGHT) {
187        broadcast = false;
188      }
189      return broadcast ? broadcastCommand(commandObject) : executeCommand(commandObject);
190    }
191    public void setBroadcastAndRoundRobinConfig(JedisBroadcastAndRoundRobinConfig config) {
192      this.broadcastAndRoundRobinConfig = config;
193      this.commandObjects.setBroadcastAndRoundRobinConfig(this.broadcastAndRoundRobinConfig);
194    }
195    public String ping() {
196      return checkAndBroadcastCommand(commandObjects.ping());
197    }
198    public String flushDB() {
199      return checkAndBroadcastCommand(commandObjects.flushDB());
200    }
201    public String flushAll() {
202      return checkAndBroadcastCommand(commandObjects.flushAll());
203    }
204    public String configSet(String parameter, String value) {
205      return checkAndBroadcastCommand(commandObjects.configSet(parameter, value));
206    }
207    @Override
208    public boolean exists(String key) {
209      return executeCommand(commandObjects.exists(key));
210    }
211    @Override
212    public long exists(String... keys) {
213      return executeCommand(commandObjects.exists(keys));
214    }
215    @Override
216    public long persist(String key) {
217      return executeCommand(commandObjects.persist(key));
218    }
219    @Override
220    public String type(String key) {
221      return executeCommand(commandObjects.type(key));
222    }
223    @Override
224    public boolean exists(byte[] key) {
225      return executeCommand(commandObjects.exists(key));
226    }
227    @Override
228    public long exists(byte[]... keys) {
229      return executeCommand(commandObjects.exists(keys));
230    }
231    @Override
232    public long persist(byte[] key) {
233      return executeCommand(commandObjects.persist(key));
234    }
235    @Override
236    public String type(byte[] key) {
237      return executeCommand(commandObjects.type(key));
238    }
239    @Override
240    public byte[] dump(String key) {
241      return executeCommand(commandObjects.dump(key));
242    }
243    @Override
244    public String restore(String key, long ttl, byte[] serializedValue) {
245      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
246    }
247    @Override
248    public String restore(String key, long ttl, byte[] serializedValue, RestoreParams params) {
249      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
250    }
251    @Override
252    public byte[] dump(byte[] key) {
253      return executeCommand(commandObjects.dump(key));
254    }
255    @Override
256    public String restore(byte[] key, long ttl, byte[] serializedValue) {
257      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
258    }
259    @Override
260    public String restore(byte[] key, long ttl, byte[] serializedValue, RestoreParams params) {
261      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
262    }
263    @Override
264    public long expire(String key, long seconds) {
265      return executeCommand(commandObjects.expire(key, seconds));
266    }
267    @Override
268    public long expire(String key, long seconds, ExpiryOption expiryOption) {
269      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
270    }
271    @Override
272    public long pexpire(String key, long milliseconds) {
273      return executeCommand(commandObjects.pexpire(key, milliseconds));
274    }
275    @Override
276    public long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {
277      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
278    }
279    @Override
280    public long expireTime(String key) {
281      return executeCommand(commandObjects.expireTime(key));
282    }
283    @Override
284    public long pexpireTime(String key) {
285      return executeCommand(commandObjects.pexpireTime(key));
286    }
287    @Override
288    public long expireAt(String key, long unixTime) {
289      return executeCommand(commandObjects.expireAt(key, unixTime));
290    }
291    @Override
292    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
293      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
294    }
295    @Override
296    public long pexpireAt(String key, long millisecondsTimestamp) {
297      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
298    }
299    @Override
300    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
301      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
302    }
303    @Override
304    public long expire(byte[] key, long seconds) {
305      return executeCommand(commandObjects.expire(key, seconds));
306    }
307    @Override
308    public long expire(byte[] key, long seconds, ExpiryOption expiryOption) {
309      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
310    }
311    @Override
312    public long pexpire(byte[] key, long milliseconds) {
313      return executeCommand(commandObjects.pexpire(key, milliseconds));
314    }
315    @Override
316    public long pexpire(byte[] key, long milliseconds, ExpiryOption expiryOption) {
317      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
318    }
319    @Override
320    public long expireTime(byte[] key) {
321      return executeCommand(commandObjects.expireTime(key));
322    }
323    @Override
324    public long pexpireTime(byte[] key) {
325      return executeCommand(commandObjects.pexpireTime(key));
326    }
327    @Override
328    public long expireAt(byte[] key, long unixTime) {
329      return executeCommand(commandObjects.expireAt(key, unixTime));
330    }
331    @Override
332    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
333      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
334    }
335    @Override
336    public long pexpireAt(byte[] key, long millisecondsTimestamp) {
337      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
338    }
339    @Override
340    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
341      return executeCommand(commandObjects.expireAt(key, millisecondsTimestamp, expiryOption));
342    }
343    @Override
344    public long ttl(String key) {
345      return executeCommand(commandObjects.ttl(key));
346    }
347    @Override
348    public long pttl(String key) {
349      return executeCommand(commandObjects.pttl(key));
350    }
351    @Override
352    public long touch(String key) {
353      return executeCommand(commandObjects.touch(key));
354    }
355    @Override
356    public long touch(String... keys) {
357      return executeCommand(commandObjects.touch(keys));
358    }
359    @Override
360    public long ttl(byte[] key) {
361      return executeCommand(commandObjects.ttl(key));
362    }
363    @Override
364    public long pttl(byte[] key) {
365      return executeCommand(commandObjects.pttl(key));
366    }
367    @Override
368    public long touch(byte[] key) {
369      return executeCommand(commandObjects.touch(key));
370    }
371    @Override
372    public long touch(byte[]... keys) {
373      return executeCommand(commandObjects.touch(keys));
374    }
375    @Override
376    public List&lt;String&gt; sort(String key) {
377      return executeCommand(commandObjects.sort(key));
378    }
379    @Override
380    public List&lt;String&gt; sort(String key, SortingParams sortingParams) {
381      return executeCommand(commandObjects.sort(key, sortingParams));
382    }
383    @Override
384    public long sort(String key, String dstkey) {
385      return executeCommand(commandObjects.sort(key, dstkey));
386    }
387    @Override
388    public long sort(String key, SortingParams sortingParams, String dstkey) {
389      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
390    }
391    @Override
392    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
393      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
394    }
395    @Override
396    public List&lt;byte[]&gt; sort(byte[] key) {
397      return executeCommand(commandObjects.sort(key));
398    }
399    @Override
400    public List&lt;byte[]&gt; sort(byte[] key, SortingParams sortingParams) {
401      return executeCommand(commandObjects.sort(key, sortingParams));
402    }
403    @Override
404    public long sort(byte[] key, byte[] dstkey) {
405      return executeCommand(commandObjects.sort(key, dstkey));
406    }
407    @Override
408    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
409      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
410    }
411    @Override
412    public long sort(byte[] key, SortingParams sortingParams, byte[] dstkey) {
413      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
414    }
415    @Override
416    public long del(String key) {
417      return executeCommand(commandObjects.del(key));
418    }
419    @Override
420    public long del(String... keys) {
421      return executeCommand(commandObjects.del(keys));
422    }
423    @Override
424    public long unlink(String key) {
425      return executeCommand(commandObjects.unlink(key));
426    }
427    @Override
428    public long unlink(String... keys) {
429      return executeCommand(commandObjects.unlink(keys));
430    }
431    @Override
432    public long del(byte[] key) {
433      return executeCommand(commandObjects.del(key));
434    }
435    @Override
436    public long del(byte[]... keys) {
437      return executeCommand(commandObjects.del(keys));
438    }
439    @Override
440    public long unlink(byte[] key) {
441      return executeCommand(commandObjects.unlink(key));
442    }
443    @Override
444    public long unlink(byte[]... keys) {
445      return executeCommand(commandObjects.unlink(keys));
446    }
447    @Override
448    public Long memoryUsage(String key) {
449      return executeCommand(commandObjects.memoryUsage(key));
450    }
451    @Override
452    public Long memoryUsage(String key, int samples) {
453      return executeCommand(commandObjects.memoryUsage(key, samples));
454    }
455    @Override
456    public Long memoryUsage(byte[] key) {
457      return executeCommand(commandObjects.memoryUsage(key));
458    }
459    @Override
460    public Long memoryUsage(byte[] key, int samples) {
461      return executeCommand(commandObjects.memoryUsage(key, samples));
462    }
463    @Override
464    public boolean copy(String srcKey, String dstKey, boolean replace) {
465      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
466    }
467    @Override
468    public String rename(String oldkey, String newkey) {
469      return executeCommand(commandObjects.rename(oldkey, newkey));
470    }
471    @Override
472    public long renamenx(String oldkey, String newkey) {
473      return executeCommand(commandObjects.renamenx(oldkey, newkey));
474    }
475    @Override
476    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
477      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
478    }
479    @Override
480    public String rename(byte[] oldkey, byte[] newkey) {
481      return executeCommand(commandObjects.rename(oldkey, newkey));
482    }
483    @Override
484    public long renamenx(byte[] oldkey, byte[] newkey) {
485      return executeCommand(commandObjects.renamenx(oldkey, newkey));
486    }
487    public long dbSize() {
488      return executeCommand(commandObjects.dbSize());
489    }
490    @Override
491    public Set&lt;String&gt; keys(String pattern) {
492      return executeCommand(commandObjects.keys(pattern));
493    }
494    @Override
495    public ScanResult&lt;String&gt; scan(String cursor) {
496      return executeCommand(commandObjects.scan(cursor));
497    }
498    @Override
499    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params) {
500      return executeCommand(commandObjects.scan(cursor, params));
501    }
502    @Override
503    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params, String type) {
504      return executeCommand(commandObjects.scan(cursor, params, type));
505    }
506    public ScanIteration scanIteration(int batchCount, String match) {
507      return new ScanIteration(provider, batchCount, match);
508    }
509    public ScanIteration scanIteration(int batchCount, String match, String type) {
510      return new ScanIteration(provider, batchCount, match, type);
511    }
512    @Override
513    public Set&lt;byte[]&gt; keys(byte[] pattern) {
514      return executeCommand(commandObjects.keys(pattern));
515    }
516    @Override
517    public ScanResult&lt;byte[]&gt; scan(byte[] cursor) {
518      return executeCommand(commandObjects.scan(cursor));
519    }
520    @Override
521    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params) {
522      return executeCommand(commandObjects.scan(cursor, params));
523    }
524    @Override
525    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params, byte[] type) {
526      return executeCommand(commandObjects.scan(cursor, params, type));
527    }
528    @Override
529    public String randomKey() {
530      return executeCommand(commandObjects.randomKey());
531    }
532    @Override
533    public byte[] randomBinaryKey() {
534      return executeCommand(commandObjects.randomBinaryKey());
535    }
536    @Override
537    public String set(String key, String value) {
538      return executeCommand(commandObjects.set(key, value));
539    }
540    @Override
541    public String set(String key, String value, SetParams params) {
542      return executeCommand(commandObjects.set(key, value, params));
543    }
544    @Override
545    public String get(String key) {
546      return executeCommand(commandObjects.get(key));
547    }
548    @Override
549    public String setGet(String key, String value) {
550      return executeCommand(commandObjects.setGet(key, value));
551    }
552    @Override
553    public String setGet(String key, String value, SetParams params) {
554      return executeCommand(commandObjects.setGet(key, value, params));
555    }
556    @Override
557    public String getDel(String key) {
558      return executeCommand(commandObjects.getDel(key));
559    }
560    @Override
561    public String getEx(String key, GetExParams params) {
562      return executeCommand(commandObjects.getEx(key, params));
563    }
564    @Override
565    public String set(byte[] key, byte[] value) {
566      return executeCommand(commandObjects.set(key, value));
567    }
568    @Override
569    public String set(byte[] key, byte[] value, SetParams params) {
570      return executeCommand(commandObjects.set(key, value, params));
571    }
572    @Override
573    public byte[] get(byte[] key) {
574      return executeCommand(commandObjects.get(key));
575    }
576    @Override
577    public byte[] setGet(byte[] key, byte[] value) {
578      return executeCommand(commandObjects.setGet(key, value));
579    }
580    @Override
581    public byte[] setGet(byte[] key, byte[] value, SetParams params) {
582      return executeCommand(commandObjects.setGet(key, value, params));
583    }
584    @Override
585    public byte[] getDel(byte[] key) {
586      return executeCommand(commandObjects.getDel(key));
587    }
588    @Override
589    public byte[] getEx(byte[] key, GetExParams params) {
590      return executeCommand(commandObjects.getEx(key, params));
591    }
592    @Override
593    public boolean setbit(String key, long offset, boolean value) {
594      return executeCommand(commandObjects.setbit(key, offset, value));
595    }
596    @Override
597    public boolean getbit(String key, long offset) {
598      return executeCommand(commandObjects.getbit(key, offset));
599    }
600    @Override
601    public long setrange(String key, long offset, String value) {
602      return executeCommand(commandObjects.setrange(key, offset, value));
603    }
604    @Override
605    public String getrange(String key, long startOffset, long endOffset) {
606      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
607    }
608    @Override
609    public boolean setbit(byte[] key, long offset, boolean value) {
610      return executeCommand(commandObjects.setbit(key, offset, value));
611    }
612    @Override
613    public boolean getbit(byte[] key, long offset) {
614      return executeCommand(commandObjects.getbit(key, offset));
615    }
616    @Override
617    public long setrange(byte[] key, long offset, byte[] value) {
618      return executeCommand(commandObjects.setrange(key, offset, value));
619    }
620    @Override
621    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
622      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
623    }
624    @Override
625    public String getSet(String key, String value) {
626      return executeCommand(commandObjects.getSet(key, value));
627    }
628    @Override
629    public long setnx(String key, String value) {
630      return executeCommand(commandObjects.setnx(key, value));
631    }
632    @Override
633    public String setex(String key, long seconds, String value) {
634      return executeCommand(commandObjects.setex(key, seconds, value));
635    }
636    @Override
637    public String psetex(String key, long milliseconds, String value) {
638      return executeCommand(commandObjects.psetex(key, milliseconds, value));
639    }
640    @Override
641    public byte[] getSet(byte[] key, byte[] value) {
642      return executeCommand(commandObjects.getSet(key, value));
643    }
644    @Override
645    public long setnx(byte[] key, byte[] value) {
646      return executeCommand(commandObjects.setnx(key, value));
647    }
648    @Override
649    public String setex(byte[] key, long seconds, byte[] value) {
650      return executeCommand(commandObjects.setex(key, seconds, value));
651    }
652    @Override
653    public String psetex(byte[] key, long milliseconds, byte[] value) {
654      return executeCommand(commandObjects.psetex(key, milliseconds, value));
655    }
656    @Override
657    public long incr(String key) {
658      return executeCommand(commandObjects.incr(key));
659    }
660    @Override
661    public long incrBy(String key, long increment) {
662      return executeCommand(commandObjects.incrBy(key, increment));
663    }
664    @Override
665    public double incrByFloat(String key, double increment) {
666      return executeCommand(commandObjects.incrByFloat(key, increment));
667    }
668    @Override
669    public long decr(String key) {
670      return executeCommand(commandObjects.decr(key));
671    }
672    @Override
673    public long decrBy(String key, long decrement) {
674      return executeCommand(commandObjects.decrBy(key, decrement));
675    }
676    @Override
677    public long incr(byte[] key) {
678      return executeCommand(commandObjects.incr(key));
679    }
680    @Override
681    public long incrBy(byte[] key, long increment) {
682      return executeCommand(commandObjects.incrBy(key, increment));
683    }
684    @Override
685    public double incrByFloat(byte[] key, double increment) {
686      return executeCommand(commandObjects.incrByFloat(key, increment));
687    }
688    @Override
689    public long decr(byte[] key) {
690      return executeCommand(commandObjects.decr(key));
691    }
692    @Override
693    public long decrBy(byte[] key, long decrement) {
694      return executeCommand(commandObjects.decrBy(key, decrement));
695    }
696    @Override
697    public List&lt;String&gt; mget(String... keys) {
698      return executeCommand(commandObjects.mget(keys));
699    }
700    @Override
701    public String mset(String... keysvalues) {
702      return executeCommand(commandObjects.mset(keysvalues));
703    }
704    @Override
705    public long msetnx(String... keysvalues) {
706      return executeCommand(commandObjects.msetnx(keysvalues));
707    }
708    @Override
709    public List&lt;byte[]&gt; mget(byte[]... keys) {
710      return executeCommand(commandObjects.mget(keys));
711    }
712    @Override
713    public String mset(byte[]... keysvalues) {
714      return executeCommand(commandObjects.mset(keysvalues));
715    }
716    @Override
717    public long msetnx(byte[]... keysvalues) {
718      return executeCommand(commandObjects.msetnx(keysvalues));
719    }
720    @Override
721    public long append(String key, String value) {
722      return executeCommand(commandObjects.append(key, value));
723    }
724    @Override
725    public String substr(String key, int start, int end) {
726      return executeCommand(commandObjects.substr(key, start, end));
727    }
728    @Override
729    public long strlen(String key) {
730      return executeCommand(commandObjects.strlen(key));
731    }
732    @Override
733    public long append(byte[] key, byte[] value) {
734      return executeCommand(commandObjects.append(key, value));
735    }
736    @Override
737    public byte[] substr(byte[] key, int start, int end) {
738      return executeCommand(commandObjects.substr(key, start, end));
739    }
740    @Override
741    public long strlen(byte[] key) {
742      return executeCommand(commandObjects.strlen(key));
743    }
744    @Override
745    public long bitcount(String key) {
746      return executeCommand(commandObjects.bitcount(key));
747    }
748    @Override
749    public long bitcount(String key, long start, long end) {
750      return executeCommand(commandObjects.bitcount(key, start, end));
751    }
752    @Override
753    public long bitcount(String key, long start, long end, BitCountOption option) {
754      return executeCommand(commandObjects.bitcount(key, start, end, option));
755    }
756    @Override
757    public long bitpos(String key, boolean value) {
758      return executeCommand(commandObjects.bitpos(key, value));
759    }
760    @Override
761    public long bitpos(String key, boolean value, BitPosParams params) {
762      return executeCommand(commandObjects.bitpos(key, value, params));
763    }
764    @Override
765    public long bitcount(byte[] key) {
766      return executeCommand(commandObjects.bitcount(key));
767    }
768    @Override
769    public long bitcount(byte[] key, long start, long end) {
770      return executeCommand(commandObjects.bitcount(key, start, end));
771    }
772    @Override
773    public long bitcount(byte[] key, long start, long end, BitCountOption option) {
774      return executeCommand(commandObjects.bitcount(key, start, end, option));
775    }
776    @Override
777    public long bitpos(byte[] key, boolean value) {
778      return executeCommand(commandObjects.bitpos(key, value));
779    }
780    @Override
781    public long bitpos(byte[] key, boolean value, BitPosParams params) {
782      return executeCommand(commandObjects.bitpos(key, value, params));
783    }
784    @Override
785    public List&lt;Long&gt; bitfield(String key, String... arguments) {
786      return executeCommand(commandObjects.bitfield(key, arguments));
787    }
788    @Override
789    public List&lt;Long&gt; bitfieldReadonly(String key, String... arguments) {
790      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
791    }
792    @Override
793    public List&lt;Long&gt; bitfield(byte[] key, byte[]... arguments) {
794      return executeCommand(commandObjects.bitfield(key, arguments));
795    }
796    @Override
797    public List&lt;Long&gt; bitfieldReadonly(byte[] key, byte[]... arguments) {
798      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
799    }
800    @Override
801    public long bitop(BitOP op, String destKey, String... srcKeys) {
802      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
803    }
804    @Override
805    public long bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
806      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
807    }
808    @Override
809    public LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {
810      return executeCommand(commandObjects.lcs(keyA, keyB, params));
811    }
812    @Override
813    public LCSMatchResult lcs(byte[] keyA, byte[] keyB, LCSParams params) {
814      return executeCommand(commandObjects.lcs(keyA, keyB, params));
815    }
816    @Override
817    public long rpush(String key, String... string) {
818      return executeCommand(commandObjects.rpush(key, string));
819    }
820    @Override
821    public long lpush(String key, String... string) {
822      return executeCommand(commandObjects.lpush(key, string));
823    }
824    @Override
825    public long llen(String key) {
826      return executeCommand(commandObjects.llen(key));
827    }
828    @Override
829    public List&lt;String&gt; lrange(String key, long start, long stop) {
830      return executeCommand(commandObjects.lrange(key, start, stop));
831    }
832    @Override
833    public String ltrim(String key, long start, long stop) {
834      return executeCommand(commandObjects.ltrim(key, start, stop));
835    }
836    @Override
837    public String lindex(String key, long index) {
838      return executeCommand(commandObjects.lindex(key, index));
839    }
840    @Override
841    public long rpush(byte[] key, byte[]... args) {
842      return executeCommand(commandObjects.rpush(key, args));
843    }
844    @Override
845    public long lpush(byte[] key, byte[]... args) {
846      return executeCommand(commandObjects.lpush(key, args));
847    }
848    @Override
849    public long llen(byte[] key) {
850      return executeCommand(commandObjects.llen(key));
851    }
852    @Override
853    public List&lt;byte[]&gt; lrange(byte[] key, long start, long stop) {
854      return executeCommand(commandObjects.lrange(key, start, stop));
855    }
856    @Override
857    public String ltrim(byte[] key, long start, long stop) {
858      return executeCommand(commandObjects.ltrim(key, start, stop));
859    }
860    @Override
861    public byte[] lindex(byte[] key, long index) {
862      return executeCommand(commandObjects.lindex(key, index));
863    }
864    @Override
865    public String lset(String key, long index, String value) {
866      return executeCommand(commandObjects.lset(key, index, value));
867    }
868    @Override
869    public long lrem(String key, long count, String value) {
870      return executeCommand(commandObjects.lrem(key, count, value));
871    }
872    @Override
873    public String lpop(String key) {
874      return executeCommand(commandObjects.lpop(key));
875    }
876    @Override
877    public List&lt;String&gt; lpop(String key, int count) {
878      return executeCommand(commandObjects.lpop(key, count));
879    }
880    @Override
881    public String lset(byte[] key, long index, byte[] value) {
882      return executeCommand(commandObjects.lset(key, index, value));
883    }
884    @Override
885    public long lrem(byte[] key, long count, byte[] value) {
886      return executeCommand(commandObjects.lrem(key, count, value));
887    }
888    @Override
889    public byte[] lpop(byte[] key) {
890      return executeCommand(commandObjects.lpop(key));
891    }
892    @Override
893    public List&lt;byte[]&gt; lpop(byte[] key, int count) {
894      return executeCommand(commandObjects.lpop(key, count));
895    }
896    @Override
897    public Long lpos(String key, String element) {
898      return executeCommand(commandObjects.lpos(key, element));
899    }
900    @Override
901    public Long lpos(String key, String element, LPosParams params) {
902      return executeCommand(commandObjects.lpos(key, element, params));
903    }
904    @Override
905    public List&lt;Long&gt; lpos(String key, String element, LPosParams params, long count) {
906      return executeCommand(commandObjects.lpos(key, element, params, count));
907    }
908    @Override
909    public Long lpos(byte[] key, byte[] element) {
910      return executeCommand(commandObjects.lpos(key, element));
911    }
912    @Override
913    public Long lpos(byte[] key, byte[] element, LPosParams params) {
914      return executeCommand(commandObjects.lpos(key, element, params));
915    }
916    @Override
917    public List&lt;Long&gt; lpos(byte[] key, byte[] element, LPosParams params, long count) {
918      return executeCommand(commandObjects.lpos(key, element, params, count));
919    }
920    @Override
921    public String rpop(String key) {
922      return executeCommand(commandObjects.rpop(key));
923    }
924    @Override
925    public List&lt;String&gt; rpop(String key, int count) {
926      return executeCommand(commandObjects.rpop(key, count));
927    }
928    @Override
929    public byte[] rpop(byte[] key) {
930      return executeCommand(commandObjects.rpop(key));
931    }
932    @Override
933    public List&lt;byte[]&gt; rpop(byte[] key, int count) {
934      return executeCommand(commandObjects.rpop(key, count));
935    }
936    @Override
937    public long linsert(String key, ListPosition where, String pivot, String value) {
938      return executeCommand(commandObjects.linsert(key, where, pivot, value));
939    }
940    @Override
941    public long lpushx(String key, String... strings) {
942      return executeCommand(commandObjects.lpushx(key, strings));
943    }
944    @Override
945    public long rpushx(String key, String... strings) {
946      return executeCommand(commandObjects.rpushx(key, strings));
947    }
948    @Override
949    public long linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value) {
950      return executeCommand(commandObjects.linsert(key, where, pivot, value));
951    }
952    @Override
953    public long lpushx(byte[] key, byte[]... args) {
954      return executeCommand(commandObjects.lpushx(key, args));
955    }
956    @Override
957    public long rpushx(byte[] key, byte[]... args) {
958      return executeCommand(commandObjects.rpushx(key, args));
959    }
960    @Override
961    public List&lt;String&gt; blpop(int timeout, String key) {
962      return executeCommand(commandObjects.blpop(timeout, key));
963    }
964    @Override
965    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
966      return executeCommand(commandObjects.blpop(timeout, key));
967    }
968    @Override
969    public List&lt;String&gt; brpop(int timeout, String key) {
970      return executeCommand(commandObjects.brpop(timeout, key));
971    }
972    @Override
973    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
974      return executeCommand(commandObjects.brpop(timeout, key));
975    }
976    @Override
977    public List&lt;String&gt; blpop(int timeout, String... keys) {
978      return executeCommand(commandObjects.blpop(timeout, keys));
979    }
980    @Override
981    public KeyValue&lt;String, String&gt; blpop(double timeout, String... keys) {
982      return executeCommand(commandObjects.blpop(timeout, keys));
983    }
984    @Override
985    public List&lt;String&gt; brpop(int timeout, String... keys) {
986      return executeCommand(commandObjects.brpop(timeout, keys));
987    }
988    @Override
989    public KeyValue&lt;String, String&gt; brpop(double timeout, String... keys) {
990      return executeCommand(commandObjects.brpop(timeout, keys));
991    }
992    @Override
993    public List&lt;byte[]&gt; blpop(int timeout, byte[]... keys) {
994      return executeCommand(commandObjects.blpop(timeout, keys));
995    }
996    @Override
997    public KeyValue&lt;byte[], byte[]&gt; blpop(double timeout, byte[]... keys) {
998      return executeCommand(commandObjects.blpop(timeout, keys));
999    }
1000    @Override
1001    public List&lt;byte[]&gt; brpop(int timeout, byte[]... keys) {
1002      return executeCommand(commandObjects.brpop(timeout, keys));
1003    }
1004    @Override
1005    public KeyValue&lt;byte[], byte[]&gt; brpop(double timeout, byte[]... keys) {
1006      return executeCommand(commandObjects.brpop(timeout, keys));
1007    }
1008    @Override
1009    public String rpoplpush(String srckey, String dstkey) {
1010      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1011    }
1012    @Override
1013    public String brpoplpush(String source, String destination, int timeout) {
1014      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1015    }
1016    @Override
1017    public byte[] rpoplpush(byte[] srckey, byte[] dstkey) {
1018      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1019    }
1020    @Override
1021    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
1022      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1023    }
1024    @Override
1025    public String lmove(String srcKey, String dstKey, ListDirection from, ListDirection to) {
1026      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1027    }
1028    @Override
1029    public String blmove(String srcKey, String dstKey, ListDirection from, ListDirection to, double timeout) {
1030      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1031    }
1032    @Override
1033    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1034      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1035    }
1036    @Override
1037    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1038      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1039    }
1040    @Override
1041    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
1042      return executeCommand(commandObjects.lmpop(direction, keys));
1043    }
1044    @Override
1045    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
1046      return executeCommand(commandObjects.lmpop(direction, count, keys));
1047    }
1048    @Override
1049    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
1050      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1051    }
1052    @Override
1053    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
1054      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1055    }
1056    @Override
1057    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1058      return executeCommand(commandObjects.lmpop(direction, keys));
1059    }
1060    @Override
1061    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1062      return executeCommand(commandObjects.lmpop(direction, count, keys));
1063    }
1064    @Override
1065    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1066      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1067    }
1068    @Override
1069    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1070      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1071    }
1072    @Override
1073    public long hset(String key, String field, String value) {
1074      return executeCommand(commandObjects.hset(key, field, value));
1075    }
1076    @Override
1077    public long hset(String key, Map&lt;String, String&gt; hash) {
1078      return executeCommand(commandObjects.hset(key, hash));
1079    }
1080    @Override
1081    public String hget(String key, String field) {
1082      return executeCommand(commandObjects.hget(key, field));
1083    }
1084    @Override
1085    public long hsetnx(String key, String field, String value) {
1086      return executeCommand(commandObjects.hsetnx(key, field, value));
1087    }
1088    @Override
1089    public String hmset(String key, Map&lt;String, String&gt; hash) {
1090      return executeCommand(commandObjects.hmset(key, hash));
1091    }
1092    @Override
1093    public List&lt;String&gt; hmget(String key, String... fields) {
1094      return executeCommand(commandObjects.hmget(key, fields));
1095    }
1096    @Override
1097    public long hset(byte[] key, byte[] field, byte[] value) {
1098      return executeCommand(commandObjects.hset(key, field, value));
1099    }
1100    @Override
1101    public long hset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1102      return executeCommand(commandObjects.hset(key, hash));
1103    }
1104    @Override
1105    public byte[] hget(byte[] key, byte[] field) {
1106      return executeCommand(commandObjects.hget(key, field));
1107    }
1108    @Override
1109    public long hsetnx(byte[] key, byte[] field, byte[] value) {
1110      return executeCommand(commandObjects.hsetnx(key, field, value));
1111    }
1112    @Override
1113    public String hmset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1114      return executeCommand(commandObjects.hmset(key, hash));
1115    }
1116    @Override
1117    public List&lt;byte[]&gt; hmget(byte[] key, byte[]... fields) {
1118      return executeCommand(commandObjects.hmget(key, fields));
1119    }
1120    @Override
1121    public long hincrBy(String key, String field, long value) {
1122      return executeCommand(commandObjects.hincrBy(key, field, value));
1123    }
1124    @Override
1125    public double hincrByFloat(String key, String field, double value) {
1126      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1127    }
1128    @Override
1129    public boolean hexists(String key, String field) {
1130      return executeCommand(commandObjects.hexists(key, field));
1131    }
1132    @Override
1133    public long hdel(String key, String... field) {
1134      return executeCommand(commandObjects.hdel(key, field));
1135    }
1136    @Override
1137    public long hlen(String key) {
1138      return executeCommand(commandObjects.hlen(key));
1139    }
1140    @Override
1141    public long hincrBy(byte[] key, byte[] field, long value) {
1142      return executeCommand(commandObjects.hincrBy(key, field, value));
1143    }
1144    @Override
1145    public double hincrByFloat(byte[] key, byte[] field, double value) {
1146      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1147    }
1148    @Override
1149    public boolean hexists(byte[] key, byte[] field) {
1150      return executeCommand(commandObjects.hexists(key, field));
1151    }
1152    @Override
1153    public long hdel(byte[] key, byte[]... field) {
1154      return executeCommand(commandObjects.hdel(key, field));
1155    }
1156    @Override
1157    public long hlen(byte[] key) {
1158      return executeCommand(commandObjects.hlen(key));
1159    }
1160    @Override
1161    public Set&lt;String&gt; hkeys(String key) {
1162      return executeCommand(commandObjects.hkeys(key));
1163    }
1164    @Override
1165    public List&lt;String&gt; hvals(String key) {
1166      return executeCommand(commandObjects.hvals(key));
1167    }
1168    @Override
1169    public Map&lt;String, String&gt; hgetAll(String key) {
1170      return executeCommand(commandObjects.hgetAll(key));
1171    }
1172    @Override
1173    public Set&lt;byte[]&gt; hkeys(byte[] key) {
1174      return executeCommand(commandObjects.hkeys(key));
1175    }
1176    @Override
1177    public List&lt;byte[]&gt; hvals(byte[] key) {
1178      return executeCommand(commandObjects.hvals(key));
1179    }
1180    @Override
1181    public Map&lt;byte[], byte[]&gt; hgetAll(byte[] key) {
1182      return executeCommand(commandObjects.hgetAll(key));
1183    }
1184    @Override
1185    public String hrandfield(String key) {
1186      return executeCommand(commandObjects.hrandfield(key));
1187    }
1188    @Override
1189    public List&lt;String&gt; hrandfield(String key, long count) {
1190      return executeCommand(commandObjects.hrandfield(key, count));
1191    }
1192    @Override
1193    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(String key, long count) {
1194      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1195    }
1196    @Override
1197    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(String key, String cursor, ScanParams params) {
1198      return executeCommand(commandObjects.hscan(key, cursor, params));
1199    }
1200    @Override
1201    public long hstrlen(String key, String field) {
1202      return executeCommand(commandObjects.hstrlen(key, field));
1203    }
1204    @Override
1205    public byte[] hrandfield(byte[] key) {
1206      return executeCommand(commandObjects.hrandfield(key));
1207    }
1208    @Override
1209    public List&lt;byte[]&gt; hrandfield(byte[] key, long count) {
1210      return executeCommand(commandObjects.hrandfield(key, count));
1211    }
1212    @Override
1213    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(byte[] key, long count) {
1214      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1215    }
1216    @Override
1217    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(byte[] key, byte[] cursor, ScanParams params) {
1218      return executeCommand(commandObjects.hscan(key, cursor, params));
1219    }
1220    @Override
1221    public long hstrlen(byte[] key, byte[] field) {
1222      return executeCommand(commandObjects.hstrlen(key, field));
1223    }
1224    @Override
1225    public long sadd(String key, String... members) {
1226      return executeCommand(commandObjects.sadd(key, members));
1227    }
1228    @Override
1229    public Set&lt;String&gt; smembers(String key) {
1230      return executeCommand(commandObjects.smembers(key));
1231    }
1232    @Override
1233    public long srem(String key, String... members) {
1234      return executeCommand(commandObjects.srem(key, members));
1235    }
1236    @Override
1237    public String spop(String key) {
1238      return executeCommand(commandObjects.spop(key));
1239    }
1240    @Override
1241    public Set&lt;String&gt; spop(String key, long count) {
1242      return executeCommand(commandObjects.spop(key, count));
1243    }
1244    @Override
1245    public long scard(String key) {
1246      return executeCommand(commandObjects.scard(key));
1247    }
1248    @Override
1249    public boolean sismember(String key, String member) {
1250      return executeCommand(commandObjects.sismember(key, member));
1251    }
1252    @Override
1253    public List&lt;Boolean&gt; smismember(String key, String... members) {
1254      return executeCommand(commandObjects.smismember(key, members));
1255    }
1256    @Override
1257    public long sadd(byte[] key, byte[]... members) {
1258      return executeCommand(commandObjects.sadd(key, members));
1259    }
1260    @Override
1261    public Set&lt;byte[]&gt; smembers(byte[] key) {
1262      return executeCommand(commandObjects.smembers(key));
1263    }
1264    @Override
1265    public long srem(byte[] key, byte[]... members) {
1266      return executeCommand(commandObjects.srem(key, members));
1267    }
1268    @Override
1269    public byte[] spop(byte[] key) {
1270      return executeCommand(commandObjects.spop(key));
1271    }
1272    @Override
1273    public Set&lt;byte[]&gt; spop(byte[] key, long count) {
1274      return executeCommand(commandObjects.spop(key, count));
1275    }
1276    @Override
1277    public long scard(byte[] key) {
1278      return executeCommand(commandObjects.scard(key));
1279    }
1280    @Override
1281    public boolean sismember(byte[] key, byte[] member) {
1282      return executeCommand(commandObjects.sismember(key, member));
1283    }
1284    @Override
1285    public List&lt;Boolean&gt; smismember(byte[] key, byte[]... members) {
1286      return executeCommand(commandObjects.smismember(key, members));
1287    }
1288    @Override
1289    public String srandmember(String key) {
1290      return executeCommand(commandObjects.srandmember(key));
1291    }
1292    @Override
1293    public List&lt;String&gt; srandmember(String key, int count) {
1294      return executeCommand(commandObjects.srandmember(key, count));
1295    }
1296    @Override
1297    public ScanResult&lt;String&gt; sscan(String key, String cursor, ScanParams params) {
1298      return executeCommand(commandObjects.sscan(key, cursor, params));
1299    }
1300    @Override
1301    public byte[] srandmember(byte[] key) {
1302      return executeCommand(commandObjects.srandmember(key));
1303    }
1304    @Override
1305    public List&lt;byte[]&gt; srandmember(byte[] key, int count) {
1306      return executeCommand(commandObjects.srandmember(key, count));
1307    }
1308    @Override
1309    public ScanResult&lt;byte[]&gt; sscan(byte[] key, byte[] cursor, ScanParams params) {
1310      return executeCommand(commandObjects.sscan(key, cursor, params));
1311    }
1312    @Override
1313    public Set&lt;String&gt; sdiff(String... keys) {
1314      return executeCommand(commandObjects.sdiff(keys));
1315    }
1316    @Override
1317    public long sdiffstore(String dstkey, String... keys) {
1318      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1319    }
1320    @Override
1321    public Set&lt;String&gt; sinter(String... keys) {
1322      return executeCommand(commandObjects.sinter(keys));
1323    }
1324    @Override
1325    public long sinterstore(String dstkey, String... keys) {
1326      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1327    }
1328    @Override
1329    public long sintercard(String... keys) {
1330      return executeCommand(commandObjects.sintercard(keys));
1331    }
1332    @Override
1333    public long sintercard(int limit, String... keys) {
1334      return executeCommand(commandObjects.sintercard(limit, keys));
1335    }
1336    @Override
1337    public Set&lt;String&gt; sunion(String... keys) {
1338      return executeCommand(commandObjects.sunion(keys));
1339    }
1340    @Override
1341    public long sunionstore(String dstkey, String... keys) {
1342      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1343    }
1344    @Override
1345    public long smove(String srckey, String dstkey, String member) {
1346      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1347    }
1348    @Override
1349    public Set&lt;byte[]&gt; sdiff(byte[]... keys) {
1350      return executeCommand(commandObjects.sdiff(keys));
1351    }
1352    @Override
1353    public long sdiffstore(byte[] dstkey, byte[]... keys) {
1354      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1355    }
1356    @Override
1357    public Set&lt;byte[]&gt; sinter(byte[]... keys) {
1358      return executeCommand(commandObjects.sinter(keys));
1359    }
1360    @Override
1361    public long sinterstore(byte[] dstkey, byte[]... keys) {
1362      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1363    }
1364    @Override
1365    public long sintercard(byte[]... keys) {
1366      return executeCommand(commandObjects.sintercard(keys));
1367    }
1368    @Override
1369    public long sintercard(int limit, byte[]... keys) {
1370      return executeCommand(commandObjects.sintercard(limit, keys));
1371    }
1372    @Override
1373    public Set&lt;byte[]&gt; sunion(byte[]... keys) {
1374      return executeCommand(commandObjects.sunion(keys));
1375    }
1376    @Override
1377    public long sunionstore(byte[] dstkey, byte[]... keys) {
1378      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1379    }
1380    @Override
1381    public long smove(byte[] srckey, byte[] dstkey, byte[] member) {
1382      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1383    }
1384    @Override
1385    public long zadd(String key, double score, String member) {
1386      return executeCommand(commandObjects.zadd(key, score, member));
1387    }
1388    @Override
1389    public long zadd(String key, double score, String member, ZAddParams params) {
1390      return executeCommand(commandObjects.zadd(key, score, member, params));
1391    }
1392    @Override
1393    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers) {
1394      return executeCommand(commandObjects.zadd(key, scoreMembers));
1395    }
1396    @Override
1397    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers, ZAddParams params) {
1398      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1399    }
1400    @Override
1401    public Double zaddIncr(String key, double score, String member, ZAddParams params) {
1402      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1403    }
1404    @Override
1405    public long zadd(byte[] key, double score, byte[] member) {
1406      return executeCommand(commandObjects.zadd(key, score, member));
1407    }
1408    @Override
1409    public long zadd(byte[] key, double score, byte[] member, ZAddParams params) {
1410      return executeCommand(commandObjects.zadd(key, score, member, params));
1411    }
1412    @Override
1413    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers) {
1414      return executeCommand(commandObjects.zadd(key, scoreMembers));
1415    }
1416    @Override
1417    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers, ZAddParams params) {
1418      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1419    }
1420    @Override
1421    public Double zaddIncr(byte[] key, double score, byte[] member, ZAddParams params) {
1422      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1423    }
1424    @Override
1425    public long zrem(String key, String... members) {
1426      return executeCommand(commandObjects.zrem(key, members));
1427    }
1428    @Override
1429    public double zincrby(String key, double increment, String member) {
1430      return executeCommand(commandObjects.zincrby(key, increment, member));
1431    }
1432    @Override
1433    public Double zincrby(String key, double increment, String member, ZIncrByParams params) {
1434      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1435    }
1436    @Override
1437    public Long zrank(String key, String member) {
1438      return executeCommand(commandObjects.zrank(key, member));
1439    }
1440    @Override
1441    public Long zrevrank(String key, String member) {
1442      return executeCommand(commandObjects.zrevrank(key, member));
1443    }
1444    @Override
1445    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
1446      return executeCommand(commandObjects.zrankWithScore(key, member));
1447    }
1448    @Override
1449    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
1450      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1451    }
1452    @Override
1453    public long zrem(byte[] key, byte[]... members) {
1454      return executeCommand(commandObjects.zrem(key, members));
1455    }
1456    @Override
1457    public double zincrby(byte[] key, double increment, byte[] member) {
1458      return executeCommand(commandObjects.zincrby(key, increment, member));
1459    }
1460    @Override
1461    public Double zincrby(byte[] key, double increment, byte[] member, ZIncrByParams params) {
1462      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1463    }
1464    @Override
1465    public Long zrank(byte[] key, byte[] member) {
1466      return executeCommand(commandObjects.zrank(key, member));
1467    }
1468    @Override
1469    public Long zrevrank(byte[] key, byte[] member) {
1470      return executeCommand(commandObjects.zrevrank(key, member));
1471    }
1472    @Override
1473    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
1474      return executeCommand(commandObjects.zrankWithScore(key, member));
1475    }
1476    @Override
1477    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
1478      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1479    }
1480    @Override
1481    public String zrandmember(String key) {
1482      return executeCommand(commandObjects.zrandmember(key));
1483    }
1484    @Override
1485    public List&lt;String&gt; zrandmember(String key, long count) {
1486      return executeCommand(commandObjects.zrandmember(key, count));
1487    }
1488    @Override
1489    public List&lt;Tuple&gt; zrandmemberWithScores(String key, long count) {
1490      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1491    }
1492    @Override
1493    public long zcard(String key) {
1494      return executeCommand(commandObjects.zcard(key));
1495    }
1496    @Override
1497    public Double zscore(String key, String member) {
1498      return executeCommand(commandObjects.zscore(key, member));
1499    }
1500    @Override
1501    public List&lt;Double&gt; zmscore(String key, String... members) {
1502      return executeCommand(commandObjects.zmscore(key, members));
1503    }
1504    @Override
1505    public byte[] zrandmember(byte[] key) {
1506      return executeCommand(commandObjects.zrandmember(key));
1507    }
1508    @Override
1509    public List&lt;byte[]&gt; zrandmember(byte[] key, long count) {
1510      return executeCommand(commandObjects.zrandmember(key, count));
1511    }
1512    @Override
1513    public List&lt;Tuple&gt; zrandmemberWithScores(byte[] key, long count) {
1514      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1515    }
1516    @Override
1517    public long zcard(byte[] key) {
1518      return executeCommand(commandObjects.zcard(key));
1519    }
1520    @Override
1521    public Double zscore(byte[] key, byte[] member) {
1522      return executeCommand(commandObjects.zscore(key, member));
1523    }
1524    @Override
1525    public List&lt;Double&gt; zmscore(byte[] key, byte[]... members) {
1526      return executeCommand(commandObjects.zmscore(key, members));
1527    }
1528    @Override
1529    public Tuple zpopmax(String key) {
1530      return executeCommand(commandObjects.zpopmax(key));
1531    }
1532    @Override
1533    public List&lt;Tuple&gt; zpopmax(String key, int count) {
1534      return executeCommand(commandObjects.zpopmax(key, count));
1535    }
1536    @Override
1537    public Tuple zpopmin(String key) {
1538      return executeCommand(commandObjects.zpopmin(key));
1539    }
1540    @Override
1541    public List&lt;Tuple&gt; zpopmin(String key, int count) {
1542      return executeCommand(commandObjects.zpopmin(key, count));
1543    }
1544    @Override
1545    public long zcount(String key, double min, double max) {
1546      return executeCommand(commandObjects.zcount(key, min, max));
1547    }
1548    @Override
1549    public long zcount(String key, String min, String max) {
1550      return executeCommand(commandObjects.zcount(key, min, max));
1551    }
1552    @Override
1553    public Tuple zpopmax(byte[] key) {
1554      return executeCommand(commandObjects.zpopmax(key));
1555    }
1556    @Override
1557    public List&lt;Tuple&gt; zpopmax(byte[] key, int count) {
1558      return executeCommand(commandObjects.zpopmax(key, count));
1559    }
1560    @Override
1561    public Tuple zpopmin(byte[] key) {
1562      return executeCommand(commandObjects.zpopmin(key));
1563    }
1564    @Override
1565    public List&lt;Tuple&gt; zpopmin(byte[] key, int count) {
1566      return executeCommand(commandObjects.zpopmin(key, count));
1567    }
1568    @Override
1569    public long zcount(byte[] key, double min, double max) {
1570      return executeCommand(commandObjects.zcount(key, min, max));
1571    }
1572    @Override
1573    public long zcount(byte[] key, byte[] min, byte[] max) {
1574      return executeCommand(commandObjects.zcount(key, min, max));
1575    }
1576    @Override
1577    public List&lt;String&gt; zrange(String key, long start, long stop) {
1578      return executeCommand(commandObjects.zrange(key, start, stop));
1579    }
1580    @Override
1581    public List&lt;String&gt; zrevrange(String key, long start, long stop) {
1582      return executeCommand(commandObjects.zrevrange(key, start, stop));
1583    }
1584    @Override
1585    public List&lt;Tuple&gt; zrangeWithScores(String key, long start, long stop) {
1586      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1587    }
1588    @Override
1589    public List&lt;Tuple&gt; zrevrangeWithScores(String key, long start, long stop) {
1590      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1591    }
1592    @Override
1593    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
1594      return executeCommand(commandObjects.zrange(key, zRangeParams));
1595    }
1596    @Override
1597    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
1598      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1599    }
1600    @Override
1601    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
1602      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1603    }
1604    @Override
1605    public List&lt;String&gt; zrangeByScore(String key, double min, double max) {
1606      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1607    }
1608    @Override
1609    public List&lt;String&gt; zrangeByScore(String key, String min, String max) {
1610      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1611    }
1612    @Override
1613    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min) {
1614      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1615    }
1616    @Override
1617    public List&lt;String&gt; zrangeByScore(String key, double min, double max, int offset, int count) {
1618      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1619    }
1620    @Override
1621    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min) {
1622      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1623    }
1624    @Override
1625    public List&lt;String&gt; zrangeByScore(String key, String min, String max, int offset, int count) {
1626      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1627    }
1628    @Override
1629    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min, int offset, int count) {
1630      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1631    }
1632    @Override
1633    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max) {
1634      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1635    }
1636    @Override
1637    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min) {
1638      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1639    }
1640    @Override
1641    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max, int offset, int count) {
1642      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1643    }
1644    @Override
1645    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min, int offset, int count) {
1646      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1647    }
1648    @Override
1649    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max) {
1650      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1651    }
1652    @Override
1653    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min) {
1654      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1655    }
1656    @Override
1657    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max, int offset, int count) {
1658      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1659    }
1660    @Override
1661    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) {
1662      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1663    }
1664    @Override
1665    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count) {
1666      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1667    }
1668    @Override
1669    public List&lt;byte[]&gt; zrange(byte[] key, long start, long stop) {
1670      return executeCommand(commandObjects.zrange(key, start, stop));
1671    }
1672    @Override
1673    public List&lt;byte[]&gt; zrevrange(byte[] key, long start, long stop) {
1674      return executeCommand(commandObjects.zrevrange(key, start, stop));
1675    }
1676    @Override
1677    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, long start, long stop) {
1678      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1679    }
1680    @Override
1681    public List&lt;Tuple&gt; zrevrangeWithScores(byte[] key, long start, long stop) {
1682      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1683    }
1684    @Override
1685    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
1686      return executeCommand(commandObjects.zrange(key, zRangeParams));
1687    }
1688    @Override
1689    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
1690      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1691    }
1692    @Override
1693    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
1694      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1695    }
1696    @Override
1697    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max) {
1698      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1699    }
1700    @Override
1701    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max) {
1702      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1703    }
1704    @Override
1705    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min) {
1706      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1707    }
1708    @Override
1709    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max, int offset, int count) {
1710      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1711    }
1712    @Override
1713    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
1714      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1715    }
1716    @Override
1717    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count) {
1718      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1719    }
1720    @Override
1721    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min, int offset, int count) {
1722      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1723    }
1724    @Override
1725    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max) {
1726      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1727    }
1728    @Override
1729    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min) {
1730      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1731    }
1732    @Override
1733    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count) {
1734      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1735    }
1736    @Override
1737    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count) {
1738      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1739    }
1740    @Override
1741    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
1742      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1743    }
1744    @Override
1745    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
1746      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1747    }
1748    @Override
1749    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count) {
1750      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1751    }
1752    @Override
1753    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count) {
1754      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1755    }
1756    @Override
1757    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count) {
1758      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1759    }
1760    @Override
1761    public long zremrangeByRank(String key, long start, long stop) {
1762      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1763    }
1764    @Override
1765    public long zremrangeByScore(String key, double min, double max) {
1766      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1767    }
1768    @Override
1769    public long zremrangeByScore(String key, String min, String max) {
1770      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1771    }
1772    @Override
1773    public long zremrangeByRank(byte[] key, long start, long stop) {
1774      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1775    }
1776    @Override
1777    public long zremrangeByScore(byte[] key, double min, double max) {
1778      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1779    }
1780    @Override
1781    public long zremrangeByScore(byte[] key, byte[] min, byte[] max) {
1782      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1783    }
1784    @Override
1785    public long zlexcount(String key, String min, String max) {
1786      return executeCommand(commandObjects.zlexcount(key, min, max));
1787    }
1788    @Override
1789    public List&lt;String&gt; zrangeByLex(String key, String min, String max) {
1790      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1791    }
1792    @Override
1793    public List&lt;String&gt; zrangeByLex(String key, String min, String max, int offset, int count) {
1794      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1795    }
1796    @Override
1797    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min) {
1798      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1799    }
1800    @Override
1801    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min, int offset, int count) {
1802      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1803    }
1804    @Override
1805    public long zremrangeByLex(String key, String min, String max) {
1806      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1807    }
1808    @Override
1809    public long zlexcount(byte[] key, byte[] min, byte[] max) {
1810      return executeCommand(commandObjects.zlexcount(key, min, max));
1811    }
1812    @Override
1813    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max) {
1814      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1815    }
1816    @Override
1817    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count) {
1818      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1819    }
1820    @Override
1821    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
1822      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1823    }
1824    @Override
1825    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
1826      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1827    }
1828    @Override
1829    public long zremrangeByLex(byte[] key, byte[] min, byte[] max) {
1830      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1831    }
1832    @Override
1833    public ScanResult&lt;Tuple&gt; zscan(String key, String cursor, ScanParams params) {
1834      return executeCommand(commandObjects.zscan(key, cursor, params));
1835    }
1836    @Override
1837    public ScanResult&lt;Tuple&gt; zscan(byte[] key, byte[] cursor, ScanParams params) {
1838      return executeCommand(commandObjects.zscan(key, cursor, params));
1839    }
1840    @Override
1841    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
1842      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1843    }
1844    @Override
1845    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
1846      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1847    }
1848    @Override
1849    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(double timeout, byte[]... keys) {
1850      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1851    }
1852    @Override
1853    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(double timeout, byte[]... keys) {
1854      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1855    }
1856    @Override
1857    public List&lt;String&gt; zdiff(String... keys) {
1858      return executeCommand(commandObjects.zdiff(keys));
1859    }
1860    @Override
1861    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
1862      return executeCommand(commandObjects.zdiffWithScores(keys));
1863    }
1864    @Override
1865    @Deprecated
1866    public long zdiffStore(String dstkey, String... keys) {
1867      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1868    }
1869    @Override
1870    public long zdiffstore(String dstkey, String... keys) {
1871      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1872    }
1873    @Override
1874    public List&lt;byte[]&gt; zdiff(byte[]... keys) {
1875      return executeCommand(commandObjects.zdiff(keys));
1876    }
1877    @Override
1878    public List&lt;Tuple&gt; zdiffWithScores(byte[]... keys) {
1879      return executeCommand(commandObjects.zdiffWithScores(keys));
1880    }
1881    @Override
1882    @Deprecated
1883    public long zdiffStore(byte[] dstkey, byte[]... keys) {
1884      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1885    }
1886    @Override
1887    public long zdiffstore(byte[] dstkey, byte[]... keys) {
1888      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1889    }
1890    @Override
1891    public long zinterstore(String dstkey, String... sets) {
1892      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1893    }
1894    @Override
1895    public long zinterstore(String dstkey, ZParams params, String... sets) {
1896      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1897    }
1898    @Override
1899    public List&lt;String&gt; zinter(ZParams params, String... keys) {
1900      return executeCommand(commandObjects.zinter(params, keys));
1901    }
1902    @Override
1903    public List&lt;Tuple&gt; zinterWithScores(ZParams params, String... keys) {
1904      return executeCommand(commandObjects.zinterWithScores(params, keys));
1905    }
1906    @Override
1907    public long zinterstore(byte[] dstkey, byte[]... sets) {
1908      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1909    }
1910    @Override
1911    public long zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
1912      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1913    }
1914    @Override
1915    public long zintercard(byte[]... keys) {
1916      return executeCommand(commandObjects.zintercard(keys));
1917    }
1918    @Override
1919    public long zintercard(long limit, byte[]... keys) {
1920      return executeCommand(commandObjects.zintercard(limit, keys));
1921    }
1922    @Override
1923    public long zintercard(String... keys) {
1924      return executeCommand(commandObjects.zintercard(keys));
1925    }
1926    @Override
1927    public long zintercard(long limit, String... keys) {
1928      return executeCommand(commandObjects.zintercard(limit, keys));
1929    }
1930    @Override
1931    public List&lt;byte[]&gt; zinter(ZParams params, byte[]... keys) {
1932      return executeCommand(commandObjects.zinter(params, keys));
1933    }
1934    @Override
1935    public List&lt;Tuple&gt; zinterWithScores(ZParams params, byte[]... keys) {
1936      return executeCommand(commandObjects.zinterWithScores(params, keys));
1937    }
1938    @Override
1939    public List&lt;String&gt; zunion(ZParams params, String... keys) {
1940      return executeCommand(commandObjects.zunion(params, keys));
1941    }
1942    @Override
1943    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
1944      return executeCommand(commandObjects.zunionWithScores(params, keys));
1945    }
1946    @Override
1947    public long zunionstore(String dstkey, String... sets) {
1948      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1949    }
1950    @Override
1951    public long zunionstore(String dstkey, ZParams params, String... sets) {
1952      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1953    }
1954    @Override
1955    public List&lt;byte[]&gt; zunion(ZParams params, byte[]... keys) {
1956      return executeCommand(commandObjects.zunion(params, keys));
1957    }
1958    @Override
1959    public List&lt;Tuple&gt; zunionWithScores(ZParams params, byte[]... keys) {
1960      return executeCommand(commandObjects.zunionWithScores(params, keys));
1961    }
1962    @Override
1963    public long zunionstore(byte[] dstkey, byte[]... sets) {
1964      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1965    }
1966    @Override
1967    public long zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
1968      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1969    }
1970    @Override
1971    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
1972      return executeCommand(commandObjects.zmpop(option, keys));
1973    }
1974    @Override
1975    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
1976      return executeCommand(commandObjects.zmpop(option, count, keys));
1977    }
1978    @Override
1979    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
1980      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1981    }
1982    @Override
1983    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
1984      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1985    }
1986    @Override
1987    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1988      return executeCommand(commandObjects.zmpop(option, keys));
1989    }
1990    @Override
1991    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1992      return executeCommand(commandObjects.zmpop(option, count, keys));
1993    }
1994    @Override
1995    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1996      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1997    }
1998    @Override
1999    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
2000      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
2001    }
2002    @Override
2003    public long geoadd(String key, double longitude, double latitude, String member) {
2004      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2005    }
2006    @Override
2007    public long geoadd(String key, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2008      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2009    }
2010    @Override
2011    public long geoadd(String key, GeoAddParams params, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2012      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2013    }
2014    @Override
2015    public Double geodist(String key, String member1, String member2) {
2016      return executeCommand(commandObjects.geodist(key, member1, member2));
2017    }
2018    @Override
2019    public Double geodist(String key, String member1, String member2, GeoUnit unit) {
2020      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2021    }
2022    @Override
2023    public List&lt;String&gt; geohash(String key, String... members) {
2024      return executeCommand(commandObjects.geohash(key, members));
2025    }
2026    @Override
2027    public List&lt;GeoCoordinate&gt; geopos(String key, String... members) {
2028      return executeCommand(commandObjects.geopos(key, members));
2029    }
2030    @Override
2031    public long geoadd(byte[] key, double longitude, double latitude, byte[] member) {
2032      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2033    }
2034    @Override
2035    public long geoadd(byte[] key, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2036      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2037    }
2038    @Override
2039    public long geoadd(byte[] key, GeoAddParams params, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2040      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2041    }
2042    @Override
2043    public Double geodist(byte[] key, byte[] member1, byte[] member2) {
2044      return executeCommand(commandObjects.geodist(key, member1, member2));
2045    }
2046    @Override
2047    public Double geodist(byte[] key, byte[] member1, byte[] member2, GeoUnit unit) {
2048      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2049    }
2050    @Override
2051    public List&lt;byte[]&gt; geohash(byte[] key, byte[]... members) {
2052      return executeCommand(commandObjects.geohash(key, members));
2053    }
2054    @Override
2055    public List&lt;GeoCoordinate&gt; geopos(byte[] key, byte[]... members) {
2056      return executeCommand(commandObjects.geopos(key, members));
2057    }
2058    @Override
2059    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2060      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2061    }
2062    @Override
2063    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2064      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2065    }
2066    @Override
2067    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2068      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2069    }
2070    @Override
2071    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2072      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2073    }
2074    @Override
2075    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit) {
2076      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2077    }
2078    @Override
2079    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit) {
2080      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2081    }
2082    @Override
2083    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2084      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2085    }
2086    @Override
2087    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2088      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2089    }
2090    @Override
2091    public long georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2092      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2093    }
2094    @Override
2095    public long georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2096      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2097    }
2098    @Override
2099    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
2100      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
2101    }
2102    @Override
2103    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
2104      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2105    }
2106    @Override
2107    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
2108      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2112      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2113    }
2114    @Override
2115    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
2116      return executeCommand(commandObjects.geosearch(key, params));
2117    }
2118    @Override
2119    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
2120      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2121    }
2122    @Override
2123    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
2124      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2125    }
2126    @Override
2127    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
2128      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2129    }
2130    @Override
2131    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2132      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2133    }
2134    @Override
2135    public long geosearchStore(String dest, String src, GeoSearchParam params) {
2136      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2137    }
2138    @Override
2139    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
2140      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2141    }
2142    @Override
2143    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2144      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2145    }
2146    @Override
2147    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2148      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2152      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2153    }
2154    @Override
2155    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2156      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2157    }
2158    @Override
2159    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit) {
2160      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2161    }
2162    @Override
2163    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit) {
2164      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2165    }
2166    @Override
2167    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2168      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2169    }
2170    @Override
2171    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2172      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2173    }
2174    @Override
2175    public long georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2176      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2177    }
2178    @Override
2179    public long georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2180      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2181    }
2182    @Override
2183    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2184      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
2185    }
2186    @Override
2187    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2188      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2189    }
2190    @Override
2191    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2192      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2193    }
2194    @Override
2195    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2196      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2197    }
2198    @Override
2199    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2200      return executeCommand(commandObjects.geosearch(key, params));
2201    }
2202    @Override
2203    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2204      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2205    }
2206    @Override
2207    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2208      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2209    }
2210    @Override
2211    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2212      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2213    }
2214    @Override
2215    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2216      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2217    }
2218    @Override
2219    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2220      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2221    }
2222    @Override
2223    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2224      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2225    }
2226    @Override
2227    public long pfadd(String key, String... elements) {
2228      return executeCommand(commandObjects.pfadd(key, elements));
2229    }
2230    @Override
2231    public String pfmerge(String destkey, String... sourcekeys) {
2232      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2233    }
2234    @Override
2235    public long pfcount(String key) {
2236      return executeCommand(commandObjects.pfcount(key));
2237    }
2238    @Override
2239    public long pfcount(String... keys) {
2240      return executeCommand(commandObjects.pfcount(keys));
2241    }
2242    @Override
2243    public long pfadd(byte[] key, byte[]... elements) {
2244      return executeCommand(commandObjects.pfadd(key, elements));
2245    }
2246    @Override
2247    public String pfmerge(byte[] destkey, byte[]... sourcekeys) {
2248      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2249    }
2250    @Override
2251    public long pfcount(byte[] key) {
2252      return executeCommand(commandObjects.pfcount(key));
2253    }
2254    @Override
2255    public long pfcount(byte[]... keys) {
2256      return executeCommand(commandObjects.pfcount(keys));
2257    }
2258    @Override
2259    public StreamEntryID xadd(String key, StreamEntryID id, Map&lt;String, String&gt; hash) {
2260      return executeCommand(commandObjects.xadd(key, id, hash));
2261    }
2262    @Override
2263    public StreamEntryID xadd(String key, XAddParams params, Map&lt;String, String&gt; hash) {
2264      return executeCommand(commandObjects.xadd(key, params, hash));
2265    }
2266    @Override
2267    public long xlen(String key) {
2268      return executeCommand(commandObjects.xlen(key));
2269    }
2270    @Override
2271    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end) {
2272      return executeCommand(commandObjects.xrange(key, start, end));
2273    }
2274    @Override
2275    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end, int count) {
2276      return executeCommand(commandObjects.xrange(key, start, end, count));
2277    }
2278    @Override
2279    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start) {
2280      return executeCommand(commandObjects.xrevrange(key, end, start));
2281    }
2282    @Override
2283    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start, int count) {
2284      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2285    }
2286    @Override
2287    public List&lt;StreamEntry&gt; xrange(String key, String start, String end) {
2288      return executeCommand(commandObjects.xrange(key, start, end));
2289    }
2290    @Override
2291    public List&lt;StreamEntry&gt; xrange(String key, String start, String end, int count) {
2292      return executeCommand(commandObjects.xrange(key, start, end, count));
2293    }
2294    @Override
2295    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start) {
2296      return executeCommand(commandObjects.xrevrange(key, end, start));
2297    }
2298    @Override
2299    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start, int count) {
2300      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2301    }
2302    @Override
2303    public long xack(String key, String group, StreamEntryID... ids) {
2304      return executeCommand(commandObjects.xack(key, group, ids));
2305    }
2306    @Override
2307    public String xgroupCreate(String key, String groupName, StreamEntryID id, boolean makeStream) {
2308      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2309    }
2310    @Override
2311    public String xgroupSetID(String key, String groupName, StreamEntryID id) {
2312      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2313    }
2314    @Override
2315    public long xgroupDestroy(String key, String groupName) {
2316      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2317    }
2318    @Override
2319    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
2320      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2321    }
2322    @Override
2323    public long xgroupDelConsumer(String key, String groupName, String consumerName) {
2324      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2325    }
2326    @Override
2327    public StreamPendingSummary xpending(String key, String groupName) {
2328      return executeCommand(commandObjects.xpending(key, groupName));
2329    }
2330    @Override
2331    public List&lt;StreamPendingEntry&gt; xpending(String key, String groupName, XPendingParams params) {
2332      return executeCommand(commandObjects.xpending(key, groupName, params));
2333    }
2334    @Override
2335    public long xdel(String key, StreamEntryID... ids) {
2336      return executeCommand(commandObjects.xdel(key, ids));
2337    }
2338    @Override
2339    public long xtrim(String key, long maxLen, boolean approximate) {
2340      return executeCommand(commandObjects.xtrim(key, maxLen, approximate));
2341    }
2342    @Override
2343    public long xtrim(String key, XTrimParams params) {
2344      return executeCommand(commandObjects.xtrim(key, params));
2345    }
2346    @Override
2347    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2348      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2349    }
2350    @Override
2351    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2352      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2353    }
2354    @Override
2355    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2356      return executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
2357    }
2358    @Override
2359    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2360      return executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
2361    }
2362    @Override
2363    public StreamInfo xinfoStream(String key) {
2364      return executeCommand(commandObjects.xinfoStream(key));
2365    }
2366    @Override
2367    public StreamFullInfo xinfoStreamFull(String key) {
2368      return executeCommand(commandObjects.xinfoStreamFull(key));
2369    }
2370    @Override
2371    public StreamFullInfo xinfoStreamFull(String key, int count) {
2372      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2373    }
2374    @Override
2375    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
2376      return executeCommand(commandObjects.xinfoGroups(key));
2377    }
2378    @Override
2379    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
2380      return executeCommand(commandObjects.xinfoConsumers(key, group));
2381    }
2382    @Override
2383    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
2384      return executeCommand(commandObjects.xinfoConsumers2(key, group));
2385    }
2386    @Override
2387    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(XReadParams xReadParams, Map&lt;String, StreamEntryID&gt; streams) {
2388      return executeCommand(commandObjects.xread(xReadParams, streams));
2389    }
2390    @Override
2391    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(String groupName, String consumer,
2392        XReadGroupParams xReadGroupParams, Map&lt;String, StreamEntryID&gt; streams) {
2393      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2394    }
2395    @Override
2396    public byte[] xadd(byte[] key, XAddParams params, Map&lt;byte[], byte[]&gt; hash) {
2397      return executeCommand(commandObjects.xadd(key, params, hash));
2398    }
2399    @Override
2400    public long xlen(byte[] key) {
2401      return executeCommand(commandObjects.xlen(key));
2402    }
2403    @Override
2404    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2405      return executeCommand(commandObjects.xrange(key, start, end));
2406    }
2407    @Override
2408    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2409      return executeCommand(commandObjects.xrange(key, start, end, count));
2410    }
2411    @Override
2412    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2413      return executeCommand(commandObjects.xrevrange(key, end, start));
2414    }
2415    @Override
2416    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2417      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2418    }
2419    @Override
2420    public long xack(byte[] key, byte[] group, byte[]... ids) {
2421      return executeCommand(commandObjects.xack(key, group, ids));
2422    }
2423    @Override
2424    public String xgroupCreate(byte[] key, byte[] groupName, byte[] id, boolean makeStream) {
2425      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2426    }
2427    @Override
2428    public String xgroupSetID(byte[] key, byte[] groupName, byte[] id) {
2429      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2430    }
2431    @Override
2432    public long xgroupDestroy(byte[] key, byte[] groupName) {
2433      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2434    }
2435    @Override
2436    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2437      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2438    }
2439    @Override
2440    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2441      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2442    }
2443    @Override
2444    public long xdel(byte[] key, byte[]... ids) {
2445      return executeCommand(commandObjects.xdel(key, ids));
2446    }
2447    @Override
2448    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2449      return executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2450    }
2451    @Override
2452    public long xtrim(byte[] key, XTrimParams params) {
2453      return executeCommand(commandObjects.xtrim(key, params));
2454    }
2455    @Override
2456    public Object xpending(byte[] key, byte[] groupName) {
2457      return executeCommand(commandObjects.xpending(key, groupName));
2458    }
2459    @Override
2460    public List&lt;Object&gt; xpending(byte[] key, byte[] groupName, XPendingParams params) {
2461      return executeCommand(commandObjects.xpending(key, groupName, params));
2462    }
2463    @Override
2464    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2465      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2466    }
2467    @Override
2468    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2469      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2470    }
2471    @Override
2472    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2473      return executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2474    }
2475    @Override
2476    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2477      return executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2478    }
2479    @Override
2480    public Object xinfoStream(byte[] key) {
2481      return executeCommand(commandObjects.xinfoStream(key));
2482    }
2483    @Override
2484    public Object xinfoStreamFull(byte[] key) {
2485      return executeCommand(commandObjects.xinfoStreamFull(key));
2486    }
2487    @Override
2488    public Object xinfoStreamFull(byte[] key, int count) {
2489      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2490    }
2491    @Override
2492    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2493      return executeCommand(commandObjects.xinfoGroups(key));
2494    }
2495    @Override
2496    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2497      return executeCommand(commandObjects.xinfoConsumers(key, group));
2498    }
2499    @Override
2500    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2501      return executeCommand(commandObjects.xread(xReadParams, streams));
2502    }
2503    @Override
2504    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2505      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2506    }
2507    @Override
2508    public Object eval(String script) {
2509      return executeCommand(commandObjects.eval(script));
2510    }
2511    @Override
2512    public Object eval(String script, int keyCount, String... params) {
2513      return executeCommand(commandObjects.eval(script, keyCount, params));
2514    }
2515    @Override
2516    public Object eval(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2517      return executeCommand(commandObjects.eval(script, keys, args));
2518    }
2519    @Override
2520    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2521      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2522    }
2523    @Override
2524    public Object evalsha(String sha1) {
2525      return executeCommand(commandObjects.evalsha(sha1));
2526    }
2527    @Override
2528    public Object evalsha(String sha1, int keyCount, String... params) {
2529      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2530    }
2531    @Override
2532    public Object evalsha(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2533      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2534    }
2535    @Override
2536    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2537      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2538    }
2539    @Override
2540    public Object eval(byte[] script) {
2541      return executeCommand(commandObjects.eval(script));
2542    }
2543    @Override
2544    public Object eval(byte[] script, int keyCount, byte[]... params) {
2545      return executeCommand(commandObjects.eval(script, keyCount, params));
2546    }
2547    @Override
2548    public Object eval(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2549      return executeCommand(commandObjects.eval(script, keys, args));
2550    }
2551    @Override
2552    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2553      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2554    }
2555    @Override
2556    public Object evalsha(byte[] sha1) {
2557      return executeCommand(commandObjects.evalsha(sha1));
2558    }
2559    @Override
2560    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
2561      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2562    }
2563    @Override
2564    public Object evalsha(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2565      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2566    }
2567    @Override
2568    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2569      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2570    }
2571    @Override
2572    public Object fcall(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2573      return executeCommand(commandObjects.fcall(name, keys, args));
2574    }
2575    @Override
2576    public Object fcallReadonly(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2577      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2578    }
2579    @Override
2580    public String functionDelete(String libraryName) {
2581      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2582    }
2583    @Override
2584    public String functionFlush() {
2585      return checkAndBroadcastCommand(commandObjects.functionFlush());
2586    }
2587    @Override
2588    public String functionFlush(FlushMode mode) {
2589      return checkAndBroadcastCommand(commandObjects.functionFlush(mode));
2590    }
2591    @Override
2592    public String functionKill() {
2593      return checkAndBroadcastCommand(commandObjects.functionKill());
2594    }
2595    @Override
2596    public List&lt;LibraryInfo&gt; functionList() {
2597      return executeCommand(commandObjects.functionList());
2598    }
2599    @Override
2600    public List&lt;LibraryInfo&gt; functionList(String libraryNamePattern) {
2601      return executeCommand(commandObjects.functionList(libraryNamePattern));
2602    }
2603    @Override
2604    public List&lt;LibraryInfo&gt; functionListWithCode() {
2605      return executeCommand(commandObjects.functionListWithCode());
2606    }
2607    @Override
2608    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
2609      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2610    }
2611    @Override
2612    public String functionLoad(String functionCode) {
2613      return executeCommand(commandObjects.functionLoad(functionCode));
2614    }
2615    @Override
2616    public String functionLoadReplace(String functionCode) {
2617      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2618    }
2619    @Override
2620    public FunctionStats functionStats() {
2621      return executeCommand(commandObjects.functionStats());
2622    }
2623    @Override
2624    public Object fcall(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2625      return executeCommand(commandObjects.fcall(name, keys, args));
2626    }
2627    @Override
2628    public Object fcallReadonly(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2629      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2630    }
2631    @Override
2632    public String functionDelete(byte[] libraryName) {
2633      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2634    }
2635    @Override
2636    public byte[] functionDump() {
2637      return executeCommand(commandObjects.functionDump());
2638    }
2639    @Override
2640    public List&lt;Object&gt; functionListBinary() {
2641      return executeCommand(commandObjects.functionListBinary());
2642    }
2643    @Override
2644    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
2645      return executeCommand(commandObjects.functionList(libraryNamePattern));
2646    }
2647    @Override
2648    public List&lt;Object&gt; functionListWithCodeBinary() {
2649      return executeCommand(commandObjects.functionListWithCodeBinary());
2650    }
2651    @Override
2652    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
2653      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2654    }
2655    @Override
2656    public String functionLoad(byte[] functionCode) {
2657      return executeCommand(commandObjects.functionLoad(functionCode));
2658    }
2659    @Override
2660    public String functionLoadReplace(byte[] functionCode) {
2661      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2662    }
2663    @Override
2664    public String functionRestore(byte[] serializedValue) {
2665      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue));
2666    }
2667    @Override
2668    public String functionRestore(byte[] serializedValue, FunctionRestorePolicy policy) {
2669      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue, policy));
2670    }
2671    @Override
2672    public Object functionStatsBinary() {
2673      return executeCommand(commandObjects.functionStatsBinary());
2674    }
2675    @Override
2676    public Long objectRefcount(String key) {
2677      return executeCommand(commandObjects.objectRefcount(key));
2678    }
2679    @Override
2680    public String objectEncoding(String key) {
2681      return executeCommand(commandObjects.objectEncoding(key));
2682    }
2683    @Override
2684    public Long objectIdletime(String key) {
2685      return executeCommand(commandObjects.objectIdletime(key));
2686    }
2687    @Override
2688    public Long objectFreq(String key) {
2689      return executeCommand(commandObjects.objectFreq(key));
2690    }
2691    @Override
2692    public Long objectRefcount(byte[] key) {
2693      return executeCommand(commandObjects.objectRefcount(key));
2694    }
2695    @Override
2696    public byte[] objectEncoding(byte[] key) {
2697      return executeCommand(commandObjects.objectEncoding(key));
2698    }
2699    @Override
2700    public Long objectIdletime(byte[] key) {
2701      return executeCommand(commandObjects.objectIdletime(key));
2702    }
2703    @Override
2704    public Long objectFreq(byte[] key) {
2705      return executeCommand(commandObjects.objectFreq(key));
2706    }
2707    @Override
2708    public String migrate(String host, int port, String key, int timeout) {
2709      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2710    }
2711    @Override
2712    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
2713      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2714    }
2715    @Override
2716    public String migrate(String host, int port, byte[] key, int timeout) {
2717      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2718    }
2719    @Override
2720    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
2721      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2722    }
2723    @Override
2724    public long waitReplicas(String sampleKey, int replicas, long timeout) {
2725      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2726    }
2727    @Override
2728    public long waitReplicas(byte[] sampleKey, int replicas, long timeout) {
2729      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2730    }
2731    @Override
2732    public KeyValue&lt;Long, Long&gt; waitAOF(String sampleKey, long numLocal, long numReplicas, long timeout) {
2733      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2734    }
2735    @Override
2736    public KeyValue&lt;Long, Long&gt; waitAOF(byte[] sampleKey, long numLocal, long numReplicas, long timeout) {
2737      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2738    }
2739    @Override
2740    public Object eval(String script, String sampleKey) {
2741      return executeCommand(commandObjects.eval(script, sampleKey));
2742    }
2743    @Override
2744    public Object evalsha(String sha1, String sampleKey) {
2745      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2746    }
2747    @Override
2748    public Object eval(byte[] script, byte[] sampleKey) {
2749      return executeCommand(commandObjects.eval(script, sampleKey));
2750    }
2751    @Override
2752    public Object evalsha(byte[] sha1, byte[] sampleKey) {
2753      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2754    }
2755    public List&lt;Boolean&gt; scriptExists(List&lt;String&gt; sha1s) {
2756      return checkAndBroadcastCommand(commandObjects.scriptExists(sha1s));
2757    }
2758    @Override
2759    public Boolean scriptExists(String sha1, String sampleKey) {
2760      return scriptExists(sampleKey, new String[]{sha1}).get(0);
2761    }
2762    @Override
2763    public List&lt;Boolean&gt; scriptExists(String sampleKey, String... sha1s) {
2764      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2765    }
2766    @Override
2767    public Boolean scriptExists(byte[] sha1, byte[] sampleKey) {
2768      return scriptExists(sampleKey, new byte[][]{sha1}).get(0);
2769    }
2770    @Override
2771    public List&lt;Boolean&gt; scriptExists(byte[] sampleKey, byte[]... sha1s) {
2772      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2773    }
2774    public String scriptLoad(String script) {
2775      return checkAndBroadcastCommand(commandObjects.scriptLoad(script));
2776    }
2777    @Override
2778    public String scriptLoad(String script, String sampleKey) {
2779      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2780    }
2781    public String scriptFlush() {
2782      return checkAndBroadcastCommand(commandObjects.scriptFlush());
2783    }
2784    @Override
2785    public String scriptFlush(String sampleKey) {
2786      return executeCommand(commandObjects.scriptFlush(sampleKey));
2787    }
2788    @Override
2789    public String scriptFlush(String sampleKey, FlushMode flushMode) {
2790      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2791    }
2792    public String scriptKill() {
2793      return checkAndBroadcastCommand(commandObjects.scriptKill());
2794    }
2795    @Override
2796    public String scriptKill(String sampleKey) {
2797      return executeCommand(commandObjects.scriptKill(sampleKey));
2798    }
2799    @Override
2800    public byte[] scriptLoad(byte[] script, byte[] sampleKey) {
2801      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2802    }
2803    @Override
2804    public String scriptFlush(byte[] sampleKey) {
2805      return executeCommand(commandObjects.scriptFlush(sampleKey));
2806    }
2807    @Override
2808    public String scriptFlush(byte[] sampleKey, FlushMode flushMode) {
2809      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2810    }
2811    @Override
2812    public String scriptKill(byte[] sampleKey) {
2813      return executeCommand(commandObjects.scriptKill(sampleKey));
2814    }
2815    public String slowlogReset() {
2816      return checkAndBroadcastCommand(commandObjects.slowlogReset());
2817    }
<span onclick='openModal()' class='match'>2818    public long publish(String channel, String message) {
2819      return executeCommand(commandObjects.publish(channel, message));
2820    }
2821    public long publish(byte[] channel, byte[] message) {
</span>2822      return executeCommand(commandObjects.publish(channel, message));
2823    }
2824    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
2825      try (Connection connection = this.provider.getConnection()) {
2826        jedisPubSub.proceed(connection, channels);
2827      }
2828    }
2829    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
2830      try (Connection connection = this.provider.getConnection()) {
2831        jedisPubSub.proceedWithPatterns(connection, patterns);
2832      }
2833    }
2834    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
2835      try (Connection connection = this.provider.getConnection()) {
2836        jedisPubSub.proceed(connection, channels);
2837      }
2838    }
2839    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
2840      try (Connection connection = this.provider.getConnection()) {
2841        jedisPubSub.proceedWithPatterns(connection, patterns);
2842      }
2843    }
2844    @Override
2845    public String ftCreate(String indexName, IndexOptions indexOptions, Schema schema) {
2846      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, indexOptions, schema));
2847    }
2848    @Override
2849    public String ftCreate(String indexName, FTCreateParams createParams, Iterable&lt;SchemaField&gt; schemaFields) {
2850      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, createParams, schemaFields));
2851    }
2852    @Override
2853    public String ftAlter(String indexName, Schema schema) {
2854      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schema));
2855    }
2856    @Override
2857    public String ftAlter(String indexName, Iterable&lt;SchemaField&gt; schemaFields) {
2858      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schemaFields));
2859    }
2860    @Override
2861    public SearchResult ftSearch(String indexName, String query) {
2862      return executeCommand(commandObjects.ftSearch(indexName, query));
2863    }
2864    @Override
2865    public SearchResult ftSearch(String indexName, String query, FTSearchParams params) {
2866      return executeCommand(commandObjects.ftSearch(indexName, query, params));
2867    }
2868    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, String query, FTSearchParams params) {
2869      return new FtSearchIteration(provider, batchSize, indexName, query, params);
2870    }
2871    @Override
2872    public SearchResult ftSearch(String indexName, Query query) {
2873      return executeCommand(commandObjects.ftSearch(indexName, query));
2874    }
2875    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, Query query) {
2876      return new FtSearchIteration(provider, batchSize, indexName, query);
2877    }
2878    @Override
2879    public SearchResult ftSearch(byte[] indexName, Query query) {
2880      return executeCommand(commandObjects.ftSearch(indexName, query));
2881    }
2882    @Override
2883    public String ftExplain(String indexName, Query query) {
2884      return executeCommand(commandObjects.ftExplain(indexName, query));
2885    }
2886    @Override
2887    public List&lt;String&gt; ftExplainCLI(String indexName, Query query) {
2888      return executeCommand(commandObjects.ftExplainCLI(indexName, query));
2889    }
2890    @Override
2891    public AggregationResult ftAggregate(String indexName, AggregationBuilder aggr) {
2892      return executeCommand(commandObjects.ftAggregate(indexName, aggr));
2893    }
2894    @Override
2895    public AggregationResult ftCursorRead(String indexName, long cursorId, int count) {
2896      return executeCommand(commandObjects.ftCursorRead(indexName, cursorId, count));
2897    }
2898    @Override
2899    public String ftCursorDel(String indexName, long cursorId) {
2900      return executeCommand(commandObjects.ftCursorDel(indexName, cursorId));
2901    }
2902    public FtAggregateIteration ftAggregateIteration(String indexName, AggregationBuilder aggr) {
2903      return new FtAggregateIteration(provider, indexName, aggr);
2904    }
2905    @Override
2906    public Map.Entry&lt;AggregationResult, Map&lt;String, Object&gt;&gt; ftProfileAggregate(String indexName,
2907        FTProfileParams profileParams, AggregationBuilder aggr) {
2908      return executeCommand(commandObjects.ftProfileAggregate(indexName, profileParams, aggr));
2909    }
2910    @Override
2911    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2912        FTProfileParams profileParams, Query query) {
2913      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query));
2914    }
2915    @Override
2916    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2917        FTProfileParams profileParams, String query, FTSearchParams searchParams) {
2918      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query, searchParams));
2919    }
2920    @Override
2921    public String ftDropIndex(String indexName) {
2922      return checkAndBroadcastCommand(commandObjects.ftDropIndex(indexName));
2923    }
2924    @Override
2925    public String ftDropIndexDD(String indexName) {
2926      return checkAndBroadcastCommand(commandObjects.ftDropIndexDD(indexName));
2927    }
2928    @Override
2929    public String ftSynUpdate(String indexName, String synonymGroupId, String... terms) {
2930      return executeCommand(commandObjects.ftSynUpdate(indexName, synonymGroupId, terms));
2931    }
2932    @Override
2933    public Map&lt;String, List&lt;String&gt;&gt; ftSynDump(String indexName) {
2934      return executeCommand(commandObjects.ftSynDump(indexName));
2935    }
2936    @Override
2937    public long ftDictAdd(String dictionary, String... terms) {
2938      return executeCommand(commandObjects.ftDictAdd(dictionary, terms));
2939    }
2940    @Override
2941    public long ftDictDel(String dictionary, String... terms) {
2942      return executeCommand(commandObjects.ftDictDel(dictionary, terms));
2943    }
2944    @Override
2945    public Set&lt;String&gt; ftDictDump(String dictionary) {
2946      return executeCommand(commandObjects.ftDictDump(dictionary));
2947    }
2948    @Override
2949    public long ftDictAddBySampleKey(String indexName, String dictionary, String... terms) {
2950      return executeCommand(commandObjects.ftDictAddBySampleKey(indexName, dictionary, terms));
2951    }
2952    @Override
2953    public long ftDictDelBySampleKey(String indexName, String dictionary, String... terms) {
2954      return executeCommand(commandObjects.ftDictDelBySampleKey(indexName, dictionary, terms));
2955    }
2956    @Override
2957    public Set&lt;String&gt; ftDictDumpBySampleKey(String indexName, String dictionary) {
2958      return executeCommand(commandObjects.ftDictDumpBySampleKey(indexName, dictionary));
2959    }
2960    @Override
2961    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query) {
2962      return executeCommand(commandObjects.ftSpellCheck(index, query));
2963    }
2964    @Override
2965    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query, FTSpellCheckParams spellCheckParams) {
2966      return executeCommand(commandObjects.ftSpellCheck(index, query, spellCheckParams));
2967    }
2968    @Override
2969    public Map&lt;String, Object&gt; ftInfo(String indexName) {
2970      return executeCommand(commandObjects.ftInfo(indexName));
2971    }
2972    @Override
2973    public Set&lt;String&gt; ftTagVals(String indexName, String fieldName) {
2974      return executeCommand(commandObjects.ftTagVals(indexName, fieldName));
2975    }
2976    @Override
2977    public String ftAliasAdd(String aliasName, String indexName) {
2978      return checkAndBroadcastCommand(commandObjects.ftAliasAdd(aliasName, indexName));
2979    }
2980    @Override
2981    public String ftAliasUpdate(String aliasName, String indexName) {
2982      return checkAndBroadcastCommand(commandObjects.ftAliasUpdate(aliasName, indexName));
2983    }
2984    @Override
2985    public String ftAliasDel(String aliasName) {
2986      return checkAndBroadcastCommand(commandObjects.ftAliasDel(aliasName));
2987    }
2988    @Override
2989    public Map&lt;String, String&gt; ftConfigGet(String option) {
2990      return executeCommand(commandObjects.ftConfigGet(option));
2991    }
2992    @Override
2993    public Map&lt;String, String&gt; ftConfigGet(String indexName, String option) {
2994      return executeCommand(commandObjects.ftConfigGet(indexName, option));
2995    }
2996    @Override
2997    public String ftConfigSet(String option, String value) {
2998      return executeCommand(commandObjects.ftConfigSet(option, value));
2999    }
3000    @Override
3001    public String ftConfigSet(String indexName, String option, String value) {
3002      return executeCommand(commandObjects.ftConfigSet(indexName, option, value));
3003    }
3004    @Override
3005    public long ftSugAdd(String key, String string, double score) {
3006      return executeCommand(commandObjects.ftSugAdd(key, string, score));
3007    }
3008    @Override
3009    public long ftSugAddIncr(String key, String string, double score) {
3010      return executeCommand(commandObjects.ftSugAddIncr(key, string, score));
3011    }
3012    @Override
3013    public List&lt;String&gt; ftSugGet(String key, String prefix) {
3014      return executeCommand(commandObjects.ftSugGet(key, prefix));
3015    }
3016    @Override
3017    public List&lt;String&gt; ftSugGet(String key, String prefix, boolean fuzzy, int max) {
3018      return executeCommand(commandObjects.ftSugGet(key, prefix, fuzzy, max));
3019    }
3020    @Override
3021    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix) {
3022      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix));
3023    }
3024    @Override
3025    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix, boolean fuzzy, int max) {
3026      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix, fuzzy, max));
3027    }
3028    @Override
3029    public boolean ftSugDel(String key, String string) {
3030      return executeCommand(commandObjects.ftSugDel(key, string));
3031    }
3032    @Override
3033    public long ftSugLen(String key) {
3034      return executeCommand(commandObjects.ftSugLen(key));
3035    }
3036    @Override
3037    public List&lt;String&gt; ftList() {
3038      return executeCommand(commandObjects.ftList());
3039    }
3040    @Override
3041    public String jsonSet(String key, Path2 path, Object object) {
3042      return executeCommand(commandObjects.jsonSet(key, path, object));
3043    }
3044    @Override
3045    public String jsonSetWithEscape(String key, Path2 path, Object object) {
3046      return executeCommand(commandObjects.jsonSetWithEscape(key, path, object));
3047    }
3048    @Override
3049    public String jsonSet(String key, Path path, Object pojo) {
3050      return executeCommand(commandObjects.jsonSet(key, path, pojo));
3051    }
3052    @Override
3053    public String jsonSetWithPlainString(String key, Path path, String string) {
3054      return executeCommand(commandObjects.jsonSetWithPlainString(key, path, string));
3055    }
3056    @Override
3057    public String jsonSet(String key, Path2 path, Object pojo, JsonSetParams params) {
3058      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3059    }
3060    @Override
3061    public String jsonSetWithEscape(String key, Path2 path, Object pojo, JsonSetParams params) {
3062      return executeCommand(commandObjects.jsonSetWithEscape(key, path, pojo, params));
3063    }
3064    @Override
3065    public String jsonSet(String key, Path path, Object pojo, JsonSetParams params) {
3066      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3067    }
3068    @Override
3069    public String jsonMerge(String key, Path2 path, Object object) {
3070      return executeCommand(commandObjects.jsonMerge(key, path, object));
3071    }
3072    @Override
3073    public String jsonMerge(String key, Path path, Object pojo) {
3074      return executeCommand(commandObjects.jsonMerge(key, path, pojo));
3075    }
3076    @Override
3077    public Object jsonGet(String key) {
3078      return executeCommand(commandObjects.jsonGet(key));
3079    }
3080    @Override
3081    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz) {
3082      return executeCommand(commandObjects.jsonGet(key, clazz));
3083    }
3084    @Override
3085    public Object jsonGet(String key, Path2... paths) {
3086      return executeCommand(commandObjects.jsonGet(key, paths));
3087    }
3088    @Override
3089    public Object jsonGet(String key, Path... paths) {
3090      return executeCommand(commandObjects.jsonGet(key, paths));
3091    }
3092    @Override
3093    public String jsonGetAsPlainString(String key, Path path) {
3094      return executeCommand(commandObjects.jsonGetAsPlainString(key, path));
3095    }
3096    @Override
3097    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz, Path... paths) {
3098      return executeCommand(commandObjects.jsonGet(key, clazz, paths));
3099    }
3100    @Override
3101    public List&lt;JSONArray&gt; jsonMGet(Path2 path, String... keys) {
3102      return executeCommand(commandObjects.jsonMGet(path, keys));
3103    }
3104    @Override
3105    public &lt;T&gt; List&lt;T&gt; jsonMGet(Path path, Class&lt;T&gt; clazz, String... keys) {
3106      return executeCommand(commandObjects.jsonMGet(path, clazz, keys));
3107    }
3108    @Override
3109    public long jsonDel(String key) {
3110      return executeCommand(commandObjects.jsonDel(key));
3111    }
3112    @Override
3113    public long jsonDel(String key, Path2 path) {
3114      return executeCommand(commandObjects.jsonDel(key, path));
3115    }
3116    @Override
3117    public long jsonDel(String key, Path path) {
3118      return executeCommand(commandObjects.jsonDel(key, path));
3119    }
3120    @Override
3121    public long jsonClear(String key) {
3122      return executeCommand(commandObjects.jsonClear(key));
3123    }
3124    @Override
3125    public long jsonClear(String key, Path2 path) {
3126      return executeCommand(commandObjects.jsonClear(key, path));
3127    }
3128    @Override
3129    public long jsonClear(String key, Path path) {
3130      return executeCommand(commandObjects.jsonClear(key, path));
3131    }
3132    @Override
3133    public List&lt;Boolean&gt; jsonToggle(String key, Path2 path) {
3134      return executeCommand(commandObjects.jsonToggle(key, path));
3135    }
3136    @Override
3137    public String jsonToggle(String key, Path path) {
3138      return executeCommand(commandObjects.jsonToggle(key, path));
3139    }
3140    @Override
3141    public Class&lt;?&gt; jsonType(String key) {
3142      return executeCommand(commandObjects.jsonType(key));
3143    }
3144    @Override
3145    public List&lt;Class&lt;?&gt;&gt; jsonType(String key, Path2 path) {
3146      return executeCommand(commandObjects.jsonType(key, path));
3147    }
3148    @Override
3149    public Class&lt;?&gt; jsonType(String key, Path path) {
3150      return executeCommand(commandObjects.jsonType(key, path));
3151    }
3152    @Override
3153    public long jsonStrAppend(String key, Object string) {
3154      return executeCommand(commandObjects.jsonStrAppend(key, string));
3155    }
3156    @Override
3157    public List&lt;Long&gt; jsonStrAppend(String key, Path2 path, Object string) {
3158      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3159    }
3160    @Override
3161    public long jsonStrAppend(String key, Path path, Object string) {
3162      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3163    }
3164    @Override
3165    public Long jsonStrLen(String key) {
3166      return executeCommand(commandObjects.jsonStrLen(key));
3167    }
3168    @Override
3169    public List&lt;Long&gt; jsonStrLen(String key, Path2 path) {
3170      return executeCommand(commandObjects.jsonStrLen(key, path));
3171    }
3172    @Override
3173    public Long jsonStrLen(String key, Path path) {
3174      return executeCommand(commandObjects.jsonStrLen(key, path));
3175    }
3176    @Override
3177    public JSONArray jsonNumIncrBy(String key, Path2 path, double value) {
3178      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3179    }
3180    @Override
3181    public double jsonNumIncrBy(String key, Path path, double value) {
3182      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3183    }
3184    @Override
3185    public List&lt;Long&gt; jsonArrAppend(String key, Path2 path, Object... objects) {
3186      return executeCommand(commandObjects.jsonArrAppend(key, path, objects));
3187    }
3188    @Override
3189    public List&lt;Long&gt; jsonArrAppendWithEscape(String key, Path2 path, Object... objects) {
3190      return executeCommand(commandObjects.jsonArrAppendWithEscape(key, path, objects));
3191    }
3192    @Override
3193    public Long jsonArrAppend(String key, Path path, Object... pojos) {
3194      return executeCommand(commandObjects.jsonArrAppend(key, path, pojos));
3195    }
3196    @Override
3197    public List&lt;Long&gt; jsonArrIndex(String key, Path2 path, Object scalar) {
3198      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3199    }
3200    @Override
3201    public List&lt;Long&gt; jsonArrIndexWithEscape(String key, Path2 path, Object scalar) {
3202      return executeCommand(commandObjects.jsonArrIndexWithEscape(key, path, scalar));
3203    }
3204    @Override
3205    public long jsonArrIndex(String key, Path path, Object scalar) {
3206      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3207    }
3208    @Override
3209    public List&lt;Long&gt; jsonArrInsert(String key, Path2 path, int index, Object... objects) {
3210      return executeCommand(commandObjects.jsonArrInsert(key, path, index, objects));
3211    }
3212    @Override
3213    public List&lt;Long&gt; jsonArrInsertWithEscape(String key, Path2 path, int index, Object... objects) {
3214      return executeCommand(commandObjects.jsonArrInsertWithEscape(key, path, index, objects));
3215    }
3216    @Override
3217    public long jsonArrInsert(String key, Path path, int index, Object... pojos) {
3218      return executeCommand(commandObjects.jsonArrInsert(key, path, index, pojos));
3219    }
3220    @Override
3221    public Object jsonArrPop(String key) {
3222      return executeCommand(commandObjects.jsonArrPop(key));
3223    }
3224    @Override
3225    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz) {
3226      return executeCommand(commandObjects.jsonArrPop(key, clazz));
3227    }
3228    @Override
3229    public List&lt;Object&gt; jsonArrPop(String key, Path2 path) {
3230      return executeCommand(commandObjects.jsonArrPop(key, path));
3231    }
3232    @Override
3233    public Object jsonArrPop(String key, Path path) {
3234      return executeCommand(commandObjects.jsonArrPop(key, path));
3235    }
3236    @Override
3237    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path) {
3238      return executeCommand(commandObjects.jsonArrPop(key, clazz, path));
3239    }
3240    @Override
3241    public List&lt;Object&gt; jsonArrPop(String key, Path2 path, int index) {
3242      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3243    }
3244    @Override
3245    public Object jsonArrPop(String key, Path path, int index) {
3246      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3247    }
3248    @Override
3249    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path, int index) {
3250      return executeCommand(commandObjects.jsonArrPop(key, clazz, path, index));
3251    }
3252    @Override
3253    public Long jsonArrLen(String key) {
3254      return executeCommand(commandObjects.jsonArrLen(key));
3255    }
3256    @Override
3257    public List&lt;Long&gt; jsonArrLen(String key, Path2 path) {
3258      return executeCommand(commandObjects.jsonArrLen(key, path));
3259    }
3260    @Override
3261    public Long jsonArrLen(String key, Path path) {
3262      return executeCommand(commandObjects.jsonArrLen(key, path));
3263    }
3264    @Override
3265    public List&lt;Long&gt; jsonArrTrim(String key, Path2 path, int start, int stop) {
3266      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3267    }
3268    @Override
3269    public Long jsonArrTrim(String key, Path path, int start, int stop) {
3270      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3271    }
3272    @Override
3273    public Long jsonObjLen(String key) {
3274      return executeCommand(commandObjects.jsonObjLen(key));
3275    }
3276    @Override
3277    public Long jsonObjLen(String key, Path path) {
3278      return executeCommand(commandObjects.jsonObjLen(key, path));
3279    }
3280    @Override
3281    public List&lt;Long&gt; jsonObjLen(String key, Path2 path) {
3282      return executeCommand(commandObjects.jsonObjLen(key, path));
3283    }
3284    @Override
3285    public List&lt;String&gt; jsonObjKeys(String key) {
3286      return executeCommand(commandObjects.jsonObjKeys(key));
3287    }
3288    @Override
3289    public List&lt;String&gt; jsonObjKeys(String key, Path path) {
3290      return executeCommand(commandObjects.jsonObjKeys(key, path));
3291    }
3292    @Override
3293    public List&lt;List&lt;String&gt;&gt; jsonObjKeys(String key, Path2 path) {
3294      return executeCommand(commandObjects.jsonObjKeys(key, path));
3295    }
3296    @Override
3297    public long jsonDebugMemory(String key) {
3298      return executeCommand(commandObjects.jsonDebugMemory(key));
3299    }
3300    @Override
3301    public long jsonDebugMemory(String key, Path path) {
3302      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3303    }
3304    @Override
3305    public List&lt;Long&gt; jsonDebugMemory(String key, Path2 path) {
3306      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3307    }
3308    @Override
3309    public List&lt;Object&gt; jsonResp(String key) {
3310      return executeCommand(commandObjects.jsonResp(key));
3311    }
3312    @Override
3313    public List&lt;Object&gt; jsonResp(String key, Path path) {
3314      return executeCommand(commandObjects.jsonResp(key, path));
3315    }
3316    @Override
3317    public List&lt;List&lt;Object&gt;&gt; jsonResp(String key, Path2 path) {
3318      return executeCommand(commandObjects.jsonResp(key, path));
3319    }
3320    @Override
3321    public String tsCreate(String key) {
3322      return executeCommand(commandObjects.tsCreate(key));
3323    }
3324    @Override
3325    public String tsCreate(String key, TSCreateParams createParams) {
3326      return executeCommand(commandObjects.tsCreate(key, createParams));
3327    }
3328    @Override
3329    public long tsDel(String key, long fromTimestamp, long toTimestamp) {
3330      return executeCommand(commandObjects.tsDel(key, fromTimestamp, toTimestamp));
3331    }
3332    @Override
3333    public String tsAlter(String key, TSAlterParams alterParams) {
3334      return executeCommand(commandObjects.tsAlter(key, alterParams));
3335    }
3336    @Override
3337    public long tsAdd(String key, double value) {
3338      return executeCommand(commandObjects.tsAdd(key, value));
3339    }
3340    @Override
3341    public long tsAdd(String key, long timestamp, double value) {
3342      return executeCommand(commandObjects.tsAdd(key, timestamp, value));
3343    }
3344    @Override
3345    public long tsAdd(String key, long timestamp, double value, TSCreateParams createParams) {
3346      return executeCommand(commandObjects.tsAdd(key, timestamp, value, createParams));
3347    }
3348    @Override
3349    public List&lt;Long&gt; tsMAdd(Map.Entry&lt;String, TSElement&gt;... entries) {
3350      return executeCommand(commandObjects.tsMAdd(entries));
3351    }
3352    @Override
3353    public long tsIncrBy(String key, double value) {
3354      return executeCommand(commandObjects.tsIncrBy(key, value));
3355    }
3356    @Override
3357    public long tsIncrBy(String key, double value, long timestamp) {
3358      return executeCommand(commandObjects.tsIncrBy(key, value, timestamp));
3359    }
3360    @Override
3361    public long tsDecrBy(String key, double value) {
3362      return executeCommand(commandObjects.tsDecrBy(key, value));
3363    }
3364    @Override
3365    public long tsDecrBy(String key, double value, long timestamp) {
3366      return executeCommand(commandObjects.tsDecrBy(key, value, timestamp));
3367    }
3368    @Override
3369    public List&lt;TSElement&gt; tsRange(String key, long fromTimestamp, long toTimestamp) {
3370      return executeCommand(commandObjects.tsRange(key, fromTimestamp, toTimestamp));
3371    }
3372    @Override
3373    public List&lt;TSElement&gt; tsRange(String key, TSRangeParams rangeParams) {
3374      return executeCommand(commandObjects.tsRange(key, rangeParams));
3375    }
3376    @Override
3377    public List&lt;TSElement&gt; tsRevRange(String key, long fromTimestamp, long toTimestamp) {
3378      return executeCommand(commandObjects.tsRevRange(key, fromTimestamp, toTimestamp));
3379    }
3380    @Override
3381    public List&lt;TSElement&gt; tsRevRange(String key, TSRangeParams rangeParams) {
3382      return executeCommand(commandObjects.tsRevRange(key, rangeParams));
3383    }
3384    @Override
3385    public Map&lt;String, TSMRangeElements&gt; tsMRange(long fromTimestamp, long toTimestamp, String... filters) {
3386      return executeCommand(commandObjects.tsMRange(fromTimestamp, toTimestamp, filters));
3387    }
3388    @Override
3389    public Map&lt;String, TSMRangeElements&gt; tsMRange(TSMRangeParams multiRangeParams) {
3390      return executeCommand(commandObjects.tsMRange(multiRangeParams));
3391    }
3392    @Override
3393    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(long fromTimestamp, long toTimestamp, String... filters) {
3394      return executeCommand(commandObjects.tsMRevRange(fromTimestamp, toTimestamp, filters));
3395    }
3396    @Override
3397    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(TSMRangeParams multiRangeParams) {
3398      return executeCommand(commandObjects.tsMRevRange(multiRangeParams));
3399    }
3400    @Override
3401    public TSElement tsGet(String key) {
3402      return executeCommand(commandObjects.tsGet(key));
3403    }
3404    @Override
3405    public TSElement tsGet(String key, TSGetParams getParams) {
3406      return executeCommand(commandObjects.tsGet(key, getParams));
3407    }
3408    @Override
3409    public Map&lt;String, TSMGetElement&gt; tsMGet(TSMGetParams multiGetParams, String... filters) {
3410      return executeCommand(commandObjects.tsMGet(multiGetParams, filters));
3411    }
3412    @Override
3413    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long timeBucket) {
3414      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, timeBucket));
3415    }
3416    @Override
3417    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long bucketDuration, long alignTimestamp) {
3418      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, bucketDuration, alignTimestamp));
3419    }
3420    @Override
3421    public String tsDeleteRule(String sourceKey, String destKey) {
3422      return executeCommand(commandObjects.tsDeleteRule(sourceKey, destKey));
3423    }
3424    @Override
3425    public List&lt;String&gt; tsQueryIndex(String... filters) {
3426      return executeCommand(commandObjects.tsQueryIndex(filters));
3427    }
3428    @Override
3429    public TSInfo tsInfo(String key) {
3430      return executor.executeCommand(commandObjects.tsInfo(key));
3431    }
3432    @Override
3433    public TSInfo tsInfoDebug(String key) {
3434      return executeCommand(commandObjects.tsInfoDebug(key));
3435    }
3436    @Override
3437    public String bfReserve(String key, double errorRate, long capacity) {
3438      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity));
3439    }
3440    @Override
3441    public String bfReserve(String key, double errorRate, long capacity, BFReserveParams reserveParams) {
3442      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity, reserveParams));
3443    }
3444    @Override
3445    public boolean bfAdd(String key, String item) {
3446      return executeCommand(commandObjects.bfAdd(key, item));
3447    }
3448    @Override
3449    public List&lt;Boolean&gt; bfMAdd(String key, String... items) {
3450      return executeCommand(commandObjects.bfMAdd(key, items));
3451    }
3452    @Override
3453    public List&lt;Boolean&gt; bfInsert(String key, String... items) {
3454      return executeCommand(commandObjects.bfInsert(key, items));
3455    }
3456    @Override
3457    public List&lt;Boolean&gt; bfInsert(String key, BFInsertParams insertParams, String... items) {
3458      return executeCommand(commandObjects.bfInsert(key, insertParams, items));
3459    }
3460    @Override
3461    public boolean bfExists(String key, String item) {
3462      return executeCommand(commandObjects.bfExists(key, item));
3463    }
3464    @Override
3465    public List&lt;Boolean&gt; bfMExists(String key, String... items) {
3466      return executeCommand(commandObjects.bfMExists(key, items));
3467    }
3468    @Override
3469    public Map.Entry&lt;Long, byte[]&gt; bfScanDump(String key, long iterator) {
3470      return executeCommand(commandObjects.bfScanDump(key, iterator));
3471    }
3472    @Override
3473    public String bfLoadChunk(String key, long iterator, byte[] data) {
3474      return executeCommand(commandObjects.bfLoadChunk(key, iterator, data));
3475    }
3476    @Override
3477    public long bfCard(String key) {
3478      return executeCommand(commandObjects.bfCard(key));
3479    }
3480    @Override
3481    public Map&lt;String, Object&gt; bfInfo(String key) {
3482      return executeCommand(commandObjects.bfInfo(key));
3483    }
3484    @Override
3485    public String cfReserve(String key, long capacity) {
3486      return executeCommand(commandObjects.cfReserve(key, capacity));
3487    }
3488    @Override
3489    public String cfReserve(String key, long capacity, CFReserveParams reserveParams) {
3490      return executeCommand(commandObjects.cfReserve(key, capacity, reserveParams));
3491    }
3492    @Override
3493    public boolean cfAdd(String key, String item) {
3494      return executeCommand(commandObjects.cfAdd(key, item));
3495    }
3496    @Override
3497    public boolean cfAddNx(String key, String item) {
3498      return executeCommand(commandObjects.cfAddNx(key, item));
3499    }
3500    @Override
3501    public List&lt;Boolean&gt; cfInsert(String key, String... items) {
3502      return executeCommand(commandObjects.cfInsert(key, items));
3503    }
3504    @Override
3505    public List&lt;Boolean&gt; cfInsert(String key, CFInsertParams insertParams, String... items) {
3506      return executeCommand(commandObjects.cfInsert(key, insertParams, items));
3507    }
3508    @Override
3509    public List&lt;Boolean&gt; cfInsertNx(String key, String... items) {
3510      return executeCommand(commandObjects.cfInsertNx(key, items));
3511    }
3512    @Override
3513    public List&lt;Boolean&gt; cfInsertNx(String key, CFInsertParams insertParams, String... items) {
3514      return executeCommand(commandObjects.cfInsertNx(key, insertParams, items));
3515    }
3516    @Override
3517    public boolean cfExists(String key, String item) {
3518      return executeCommand(commandObjects.cfExists(key, item));
3519    }
3520    @Override
3521    public List&lt;Boolean&gt; cfMExists(String key, String... items) {
3522      return executeCommand(commandObjects.cfMExists(key, items));
3523    }
3524    @Override
3525    public boolean cfDel(String key, String item) {
3526      return executeCommand(commandObjects.cfDel(key, item));
3527    }
3528    @Override
3529    public long cfCount(String key, String item) {
3530      return executeCommand(commandObjects.cfCount(key, item));
3531    }
3532    @Override
3533    public Map.Entry&lt;Long, byte[]&gt; cfScanDump(String key, long iterator) {
3534      return executeCommand(commandObjects.cfScanDump(key, iterator));
3535    }
3536    @Override
3537    public String cfLoadChunk(String key, long iterator, byte[] data) {
3538      return executeCommand(commandObjects.cfLoadChunk(key, iterator, data));
3539    }
3540    @Override
3541    public Map&lt;String, Object&gt; cfInfo(String key) {
3542      return executeCommand(commandObjects.cfInfo(key));
3543    }
3544    @Override
3545    public String cmsInitByDim(String key, long width, long depth) {
3546      return executeCommand(commandObjects.cmsInitByDim(key, width, depth));
3547    }
3548    @Override
3549    public String cmsInitByProb(String key, double error, double probability) {
3550      return executeCommand(commandObjects.cmsInitByProb(key, error, probability));
3551    }
3552    @Override
3553    public List&lt;Long&gt; cmsIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3554      return executeCommand(commandObjects.cmsIncrBy(key, itemIncrements));
3555    }
3556    @Override
3557    public List&lt;Long&gt; cmsQuery(String key, String... items) {
3558      return executeCommand(commandObjects.cmsQuery(key, items));
3559    }
3560    @Override
3561    public String cmsMerge(String destKey, String... keys) {
3562      return executeCommand(commandObjects.cmsMerge(destKey, keys));
3563    }
3564    @Override
3565    public String cmsMerge(String destKey, Map&lt;String, Long&gt; keysAndWeights) {
3566      return executeCommand(commandObjects.cmsMerge(destKey, keysAndWeights));
3567    }
3568    @Override
3569    public Map&lt;String, Object&gt; cmsInfo(String key) {
3570      return executeCommand(commandObjects.cmsInfo(key));
3571    }
3572    @Override
3573    public String topkReserve(String key, long topk) {
3574      return executeCommand(commandObjects.topkReserve(key, topk));
3575    }
3576    @Override
3577    public String topkReserve(String key, long topk, long width, long depth, double decay) {
3578      return executeCommand(commandObjects.topkReserve(key, topk, width, depth, decay));
3579    }
3580    @Override
3581    public List&lt;String&gt; topkAdd(String key, String... items) {
3582      return executeCommand(commandObjects.topkAdd(key, items));
3583    }
3584    @Override
3585    public List&lt;String&gt; topkIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3586      return executeCommand(commandObjects.topkIncrBy(key, itemIncrements));
3587    }
3588    @Override
3589    public List&lt;Boolean&gt; topkQuery(String key, String... items) {
3590      return executeCommand(commandObjects.topkQuery(key, items));
3591    }
3592    @Override
3593    public List&lt;String&gt; topkList(String key) {
3594      return executeCommand(commandObjects.topkList(key));
3595    }
3596    @Override
3597    public Map&lt;String, Object&gt; topkInfo(String key) {
3598      return executeCommand(commandObjects.topkInfo(key));
3599    }
3600    @Override
3601    public String tdigestCreate(String key) {
3602      return executeCommand(commandObjects.tdigestCreate(key));
3603    }
3604    @Override
3605    public String tdigestCreate(String key, int compression) {
3606      return executeCommand(commandObjects.tdigestCreate(key, compression));
3607    }
3608    @Override
3609    public String tdigestReset(String key) {
3610      return executeCommand(commandObjects.tdigestReset(key));
3611    }
3612    @Override
3613    public String tdigestMerge(String destinationKey, String... sourceKeys) {
3614      return executeCommand(commandObjects.tdigestMerge(destinationKey, sourceKeys));
3615    }
3616    @Override
3617    public String tdigestMerge(TDigestMergeParams mergeParams, String destinationKey, String... sourceKeys) {
3618      return executeCommand(commandObjects.tdigestMerge(mergeParams, destinationKey, sourceKeys));
3619    }
3620    @Override
3621    public Map&lt;String, Object&gt; tdigestInfo(String key) {
3622      return executeCommand(commandObjects.tdigestInfo(key));
3623    }
3624    @Override
3625    public String tdigestAdd(String key, double... values) {
3626      return executeCommand(commandObjects.tdigestAdd(key, values));
3627    }
3628    @Override
3629    public List&lt;Double&gt; tdigestCDF(String key, double... values) {
3630      return executeCommand(commandObjects.tdigestCDF(key, values));
3631    }
3632    @Override
3633    public List&lt;Double&gt; tdigestQuantile(String key, double... quantiles) {
3634      return executeCommand(commandObjects.tdigestQuantile(key, quantiles));
3635    }
3636    @Override
3637    public double tdigestMin(String key) {
3638      return executeCommand(commandObjects.tdigestMin(key));
3639    }
3640    @Override
3641    public double tdigestMax(String key) {
3642      return executeCommand(commandObjects.tdigestMax(key));
3643    }
3644    @Override
3645    public double tdigestTrimmedMean(String key, double lowCutQuantile, double highCutQuantile) {
3646      return executeCommand(commandObjects.tdigestTrimmedMean(key, lowCutQuantile, highCutQuantile));
3647    }
3648    @Override
3649    public List&lt;Long&gt; tdigestRank(String key, double... values) {
3650      return executeCommand(commandObjects.tdigestRank(key, values));
3651    }
3652    @Override
3653    public List&lt;Long&gt; tdigestRevRank(String key, double... values) {
3654      return executeCommand(commandObjects.tdigestRevRank(key, values));
3655    }
3656    @Override
3657    public List&lt;Double&gt; tdigestByRank(String key, long... ranks) {
3658      return executeCommand(commandObjects.tdigestByRank(key, ranks));
3659    }
3660    @Override
3661    public List&lt;Double&gt; tdigestByRevRank(String key, long... ranks) {
3662      return executeCommand(commandObjects.tdigestByRevRank(key, ranks));
3663    }
3664    @Override
3665    public ResultSet graphQuery(String name, String query) {
3666      return executeCommand(graphCommandObjects.graphQuery(name, query));
3667    }
3668    @Override
3669    public ResultSet graphReadonlyQuery(String name, String query) {
3670      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query));
3671    }
3672    @Override
3673    public ResultSet graphQuery(String name, String query, long timeout) {
3674      return executeCommand(graphCommandObjects.graphQuery(name, query, timeout));
3675    }
3676    @Override
3677    public ResultSet graphReadonlyQuery(String name, String query, long timeout) {
3678      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, timeout));
3679    }
3680    @Override
3681    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params) {
3682      return executeCommand(graphCommandObjects.graphQuery(name, query, params));
3683    }
3684    @Override
3685    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params) {
3686      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params));
3687    }
3688    @Override
3689    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3690      return executeCommand(graphCommandObjects.graphQuery(name, query, params, timeout));
3691    }
3692    @Override
3693    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3694      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params, timeout));
3695    }
3696    @Override
3697    public String graphDelete(String name) {
3698      return executeCommand(graphCommandObjects.graphDelete(name));
3699    }
3700    @Override
3701    public List&lt;String&gt; graphList() {
3702      return executeCommand(commandObjects.graphList());
3703    }
3704    @Override
3705    public List&lt;String&gt; graphProfile(String graphName, String query) {
3706      return executeCommand(commandObjects.graphProfile(graphName, query));
3707    }
3708    @Override
3709    public List&lt;String&gt; graphExplain(String graphName, String query) {
3710      return executeCommand(commandObjects.graphExplain(graphName, query));
3711    }
3712    @Override
3713    public List&lt;List&lt;Object&gt;&gt; graphSlowlog(String graphName) {
3714      return executeCommand(commandObjects.graphSlowlog(graphName));
3715    }
3716    @Override
3717    public String graphConfigSet(String configName, Object value) {
3718      return executeCommand(commandObjects.graphConfigSet(configName, value));
3719    }
3720    @Override
3721    public Map&lt;String, Object&gt; graphConfigGet(String configName) {
3722      return executeCommand(commandObjects.graphConfigGet(configName));
3723    }
3724    public PipelineBase pipelined() {
3725      if (provider == null) {
3726        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3727      }
3728      return new Pipeline(provider.getConnection(), true);
3729    }
3730    public Transaction multi() {
3731      if (provider == null) {
3732        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3733      }
3734      return new Transaction(provider.getConnection(), true, true);
3735    }
3736    public Object sendCommand(ProtocolCommand cmd) {
3737      return executeCommand(commandObjects.commandArguments(cmd));
3738    }
3739    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
3740      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3741    }
3742    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
3743      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3744    }
3745    public Object sendCommand(ProtocolCommand cmd, String... args) {
3746      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3747    }
3748    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
3749      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3750    }
3751    public Object sendCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3752      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3753    }
3754    public Object sendBlockingCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3755      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3756    }
3757    public Object sendCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3758      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3759    }
3760    public Object sendBlockingCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3761      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3762    }
3763    public Object executeCommand(CommandArguments args) {
3764      return executeCommand(new CommandObject&lt;&gt;(args, BuilderFactory.RAW_OBJECT));
3765    }
3766    public void setJsonObjectMapper(JsonObjectMapper jsonObjectMapper) {
3767      this.commandObjects.setJsonObjectMapper(jsonObjectMapper);
3768    }
3769    public void setDefaultSearchDialect(int dialect) {
3770      this.commandObjects.setDefaultSearchDialect(dialect);
3771    }
3772  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.net.URI;
3  import java.time.Duration;
4  import java.util.List;
5  import java.util.Map;
6  import java.util.Set;
7  import java.util.regex.Pattern;
8  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
9  import org.json.JSONArray;
10  import redis.clients.jedis.args.*;
11  import redis.clients.jedis.bloom.*;
12  import redis.clients.jedis.commands.JedisCommands;
13  import redis.clients.jedis.commands.JedisBinaryCommands;
14  import redis.clients.jedis.commands.ProtocolCommand;
15  import redis.clients.jedis.commands.SampleBinaryKeyedCommands;
16  import redis.clients.jedis.commands.SampleKeyedCommands;
17  import redis.clients.jedis.commands.RedisModuleCommands;
18  import redis.clients.jedis.exceptions.JedisException;
19  import redis.clients.jedis.executors.*;
20  import redis.clients.jedis.graph.GraphCommandObjects;
21  import redis.clients.jedis.graph.ResultSet;
22  import redis.clients.jedis.json.JsonSetParams;
23  import redis.clients.jedis.json.Path;
24  import redis.clients.jedis.json.Path2;
25  import redis.clients.jedis.json.JsonObjectMapper;
26  import redis.clients.jedis.params.*;
27  import redis.clients.jedis.providers.*;
28  import redis.clients.jedis.resps.*;
29  import redis.clients.jedis.search.*;
30  import redis.clients.jedis.search.aggr.AggregationBuilder;
31  import redis.clients.jedis.search.aggr.AggregationResult;
32  import redis.clients.jedis.search.aggr.FtAggregateIteration;
33  import redis.clients.jedis.search.schemafields.SchemaField;
34  import redis.clients.jedis.timeseries.*;
35  import redis.clients.jedis.util.IOUtils;
36  import redis.clients.jedis.util.JedisURIHelper;
37  import redis.clients.jedis.util.KeyValue;
38  public class UnifiedJedis implements JedisCommands, JedisBinaryCommands,
39      SampleKeyedCommands, SampleBinaryKeyedCommands, RedisModuleCommands,
40      AutoCloseable {
41    protected RedisProtocol protocol = null;
42    protected final ConnectionProvider provider;
43    protected final CommandExecutor executor;
44    protected final CommandObjects commandObjects;
45    private final GraphCommandObjects graphCommandObjects;
46    private JedisBroadcastAndRoundRobinConfig broadcastAndRoundRobinConfig = null;
47    public UnifiedJedis() {
48      this(new HostAndPort(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT));
49    }
50    public UnifiedJedis(HostAndPort hostAndPort) {
51      this(new PooledConnectionProvider(hostAndPort));
52    }
53    public UnifiedJedis(final String url) {
54      this(URI.create(url));
55    }
56    public UnifiedJedis(final URI uri) {
57      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
58          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
59          .database(JedisURIHelper.getDBIndex(uri)).protocol(JedisURIHelper.getRedisProtocol(uri))
60          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
61    }
62    public UnifiedJedis(final URI uri, JedisClientConfig config) {
63      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
64          .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
65          .socketTimeoutMillis(config.getSocketTimeoutMillis())
66          .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
67          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
68          .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
69          .protocol(JedisURIHelper.getRedisProtocol(uri))
70          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
71          .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
72          .build());
73    }
74    public UnifiedJedis(HostAndPort hostAndPort, JedisClientConfig clientConfig) {
75      this(new PooledConnectionProvider(hostAndPort, clientConfig));
76      RedisProtocol proto = clientConfig.getRedisProtocol();
77      if (proto != null) commandObjects.setProtocol(proto);
78    }
79    public UnifiedJedis(ConnectionProvider provider) {
80      this.provider = provider;
81      this.executor = new DefaultCommandExecutor(provider);
82      this.commandObjects = new CommandObjects();
83      this.graphCommandObjects = new GraphCommandObjects(this);
84      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
85      try (Connection conn = this.provider.getConnection()) {
86        if (conn != null) {
87          RedisProtocol proto = conn.getRedisProtocol();
88          if (proto != null) commandObjects.setProtocol(proto);
89        }
90      } catch (JedisException je) { 
91      }
92    }
93    public UnifiedJedis(JedisSocketFactory socketFactory) {
94      this(new Connection(socketFactory));
95    }
96    public UnifiedJedis(JedisSocketFactory socketFactory, JedisClientConfig clientConfig) {
97      this(new Connection(socketFactory, clientConfig));
98    }
99    public UnifiedJedis(Connection connection) {
100      this.provider = null;
101      this.executor = new SimpleCommandExecutor(connection);
102      this.commandObjects = new CommandObjects();
103      this.graphCommandObjects = new GraphCommandObjects(this);
104      RedisProtocol proto = connection.getRedisProtocol();
105      if (proto == RedisProtocol.RESP3) this.commandObjects.setProtocol(proto);
106    }
107    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts) {
108      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts,
109          Duration.ofMillis(maxAttempts * clientConfig.getSocketTimeoutMillis()));
110      RedisProtocol proto = clientConfig.getRedisProtocol();
111      if (proto != null) commandObjects.setProtocol(proto);
112    }
113    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
114      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts, maxTotalRetriesDuration);
115      RedisProtocol proto = clientConfig.getRedisProtocol();
116      if (proto != null) commandObjects.setProtocol(proto);
117    }
118    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig,
119        GenericObjectPoolConfig&lt;Connection&gt; poolConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
120      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig, poolConfig), maxAttempts, maxTotalRetriesDuration);
121      RedisProtocol proto = clientConfig.getRedisProtocol();
122      if (proto != null) commandObjects.setProtocol(proto);
123    }
124    public UnifiedJedis(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
125      this.provider = provider;
126      this.executor = new ClusterCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
127      this.commandObjects = new ClusterCommandObjects();
128      this.graphCommandObjects = new GraphCommandObjects(this);
129      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
130    }
131    @Deprecated
132    public UnifiedJedis(ShardedConnectionProvider provider) {
133      this.provider = provider;
134      this.executor = new DefaultCommandExecutor(provider);
135      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo());
136      this.graphCommandObjects = new GraphCommandObjects(this);
137      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
138    }
139    @Deprecated
140    public UnifiedJedis(ShardedConnectionProvider provider, Pattern tagPattern) {
141      this.provider = provider;
142      this.executor = new DefaultCommandExecutor(provider);
143      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo(), tagPattern);
144      this.graphCommandObjects = new GraphCommandObjects(this);
145      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
146    }
147    public UnifiedJedis(ConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
148      this.provider = provider;
149      this.executor = new RetryableCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
150      this.commandObjects = new CommandObjects();
151      this.graphCommandObjects = new GraphCommandObjects(this);
152      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
153    }
154    public UnifiedJedis(MultiClusterPooledConnectionProvider provider) {
155      this.provider = provider;
156      this.executor = new CircuitBreakerCommandExecutor(provider);
157      this.commandObjects = new CommandObjects();
158      this.graphCommandObjects = new GraphCommandObjects(this);
159      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
160    }
161    public UnifiedJedis(CommandExecutor executor) {
162      this.provider = null;
163      this.executor = executor;
164      this.commandObjects = new CommandObjects();
165      this.graphCommandObjects = new GraphCommandObjects(this);
166      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
167    }
168    @Override
169    public void close() {
170      IOUtils.closeQuietly(this.executor);
171    }
172    protected final void setProtocol(RedisProtocol protocol) {
173      this.protocol = protocol;
174      this.commandObjects.setProtocol(this.protocol);
175    }
176    public final &lt;T&gt; T executeCommand(CommandObject&lt;T&gt; commandObject) {
177      return executor.executeCommand(commandObject);
178    }
179    public final &lt;T&gt; T broadcastCommand(CommandObject&lt;T&gt; commandObject) {
180      return executor.broadcastCommand(commandObject);
181    }
182    private &lt;T&gt; T checkAndBroadcastCommand(CommandObject&lt;T&gt; commandObject) {
183      boolean broadcast = true;
184      if (broadcastAndRoundRobinConfig == null) {
185      } else if (commandObject.getArguments().getCommand() instanceof SearchProtocol.SearchCommand
186          &amp;&amp; broadcastAndRoundRobinConfig.getRediSearchModeInCluster() == JedisBroadcastAndRoundRobinConfig.RediSearchMode.LIGHT) {
187        broadcast = false;
188      }
189      return broadcast ? broadcastCommand(commandObject) : executeCommand(commandObject);
190    }
191    public void setBroadcastAndRoundRobinConfig(JedisBroadcastAndRoundRobinConfig config) {
192      this.broadcastAndRoundRobinConfig = config;
193      this.commandObjects.setBroadcastAndRoundRobinConfig(this.broadcastAndRoundRobinConfig);
194    }
195    public String ping() {
196      return checkAndBroadcastCommand(commandObjects.ping());
197    }
198    public String flushDB() {
199      return checkAndBroadcastCommand(commandObjects.flushDB());
200    }
201    public String flushAll() {
202      return checkAndBroadcastCommand(commandObjects.flushAll());
203    }
204    public String configSet(String parameter, String value) {
205      return checkAndBroadcastCommand(commandObjects.configSet(parameter, value));
206    }
207    @Override
208    public boolean exists(String key) {
209      return executeCommand(commandObjects.exists(key));
210    }
211    @Override
212    public long exists(String... keys) {
213      return executeCommand(commandObjects.exists(keys));
214    }
215    @Override
216    public long persist(String key) {
217      return executeCommand(commandObjects.persist(key));
218    }
219    @Override
220    public String type(String key) {
221      return executeCommand(commandObjects.type(key));
222    }
223    @Override
224    public boolean exists(byte[] key) {
225      return executeCommand(commandObjects.exists(key));
226    }
227    @Override
228    public long exists(byte[]... keys) {
229      return executeCommand(commandObjects.exists(keys));
230    }
231    @Override
232    public long persist(byte[] key) {
233      return executeCommand(commandObjects.persist(key));
234    }
235    @Override
236    public String type(byte[] key) {
237      return executeCommand(commandObjects.type(key));
238    }
239    @Override
240    public byte[] dump(String key) {
241      return executeCommand(commandObjects.dump(key));
242    }
243    @Override
244    public String restore(String key, long ttl, byte[] serializedValue) {
245      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
246    }
247    @Override
248    public String restore(String key, long ttl, byte[] serializedValue, RestoreParams params) {
249      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
250    }
251    @Override
252    public byte[] dump(byte[] key) {
253      return executeCommand(commandObjects.dump(key));
254    }
255    @Override
256    public String restore(byte[] key, long ttl, byte[] serializedValue) {
257      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
258    }
259    @Override
260    public String restore(byte[] key, long ttl, byte[] serializedValue, RestoreParams params) {
261      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
262    }
263    @Override
264    public long expire(String key, long seconds) {
265      return executeCommand(commandObjects.expire(key, seconds));
266    }
267    @Override
268    public long expire(String key, long seconds, ExpiryOption expiryOption) {
269      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
270    }
271    @Override
272    public long pexpire(String key, long milliseconds) {
273      return executeCommand(commandObjects.pexpire(key, milliseconds));
274    }
275    @Override
276    public long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {
277      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
278    }
279    @Override
280    public long expireTime(String key) {
281      return executeCommand(commandObjects.expireTime(key));
282    }
283    @Override
284    public long pexpireTime(String key) {
285      return executeCommand(commandObjects.pexpireTime(key));
286    }
287    @Override
288    public long expireAt(String key, long unixTime) {
289      return executeCommand(commandObjects.expireAt(key, unixTime));
290    }
291    @Override
292    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
293      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
294    }
295    @Override
296    public long pexpireAt(String key, long millisecondsTimestamp) {
297      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
298    }
299    @Override
300    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
301      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
302    }
303    @Override
304    public long expire(byte[] key, long seconds) {
305      return executeCommand(commandObjects.expire(key, seconds));
306    }
307    @Override
308    public long expire(byte[] key, long seconds, ExpiryOption expiryOption) {
309      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
310    }
311    @Override
312    public long pexpire(byte[] key, long milliseconds) {
313      return executeCommand(commandObjects.pexpire(key, milliseconds));
314    }
315    @Override
316    public long pexpire(byte[] key, long milliseconds, ExpiryOption expiryOption) {
317      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
318    }
319    @Override
320    public long expireTime(byte[] key) {
321      return executeCommand(commandObjects.expireTime(key));
322    }
323    @Override
324    public long pexpireTime(byte[] key) {
325      return executeCommand(commandObjects.pexpireTime(key));
326    }
327    @Override
328    public long expireAt(byte[] key, long unixTime) {
329      return executeCommand(commandObjects.expireAt(key, unixTime));
330    }
331    @Override
332    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
333      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
334    }
335    @Override
336    public long pexpireAt(byte[] key, long millisecondsTimestamp) {
337      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
338    }
339    @Override
340    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
341      return executeCommand(commandObjects.expireAt(key, millisecondsTimestamp, expiryOption));
342    }
343    @Override
344    public long ttl(String key) {
345      return executeCommand(commandObjects.ttl(key));
346    }
347    @Override
348    public long pttl(String key) {
349      return executeCommand(commandObjects.pttl(key));
350    }
351    @Override
352    public long touch(String key) {
353      return executeCommand(commandObjects.touch(key));
354    }
355    @Override
356    public long touch(String... keys) {
357      return executeCommand(commandObjects.touch(keys));
358    }
359    @Override
360    public long ttl(byte[] key) {
361      return executeCommand(commandObjects.ttl(key));
362    }
363    @Override
364    public long pttl(byte[] key) {
365      return executeCommand(commandObjects.pttl(key));
366    }
367    @Override
368    public long touch(byte[] key) {
369      return executeCommand(commandObjects.touch(key));
370    }
371    @Override
372    public long touch(byte[]... keys) {
373      return executeCommand(commandObjects.touch(keys));
374    }
375    @Override
376    public List&lt;String&gt; sort(String key) {
377      return executeCommand(commandObjects.sort(key));
378    }
379    @Override
380    public List&lt;String&gt; sort(String key, SortingParams sortingParams) {
381      return executeCommand(commandObjects.sort(key, sortingParams));
382    }
383    @Override
<span onclick='openModal()' class='match'>384    public long sort(String key, String dstkey) {
385      return executeCommand(commandObjects.sort(key, dstkey));
386    }
387    @Override
</span>388    public long sort(String key, SortingParams sortingParams, String dstkey) {
389      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
390    }
391    @Override
392    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
393      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
394    }
395    @Override
396    public List&lt;byte[]&gt; sort(byte[] key) {
397      return executeCommand(commandObjects.sort(key));
398    }
399    @Override
400    public List&lt;byte[]&gt; sort(byte[] key, SortingParams sortingParams) {
401      return executeCommand(commandObjects.sort(key, sortingParams));
402    }
403    @Override
404    public long sort(byte[] key, byte[] dstkey) {
405      return executeCommand(commandObjects.sort(key, dstkey));
406    }
407    @Override
408    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
409      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
410    }
411    @Override
412    public long sort(byte[] key, SortingParams sortingParams, byte[] dstkey) {
413      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
414    }
415    @Override
416    public long del(String key) {
417      return executeCommand(commandObjects.del(key));
418    }
419    @Override
420    public long del(String... keys) {
421      return executeCommand(commandObjects.del(keys));
422    }
423    @Override
424    public long unlink(String key) {
425      return executeCommand(commandObjects.unlink(key));
426    }
427    @Override
428    public long unlink(String... keys) {
429      return executeCommand(commandObjects.unlink(keys));
430    }
431    @Override
432    public long del(byte[] key) {
433      return executeCommand(commandObjects.del(key));
434    }
435    @Override
436    public long del(byte[]... keys) {
437      return executeCommand(commandObjects.del(keys));
438    }
439    @Override
440    public long unlink(byte[] key) {
441      return executeCommand(commandObjects.unlink(key));
442    }
443    @Override
444    public long unlink(byte[]... keys) {
445      return executeCommand(commandObjects.unlink(keys));
446    }
447    @Override
448    public Long memoryUsage(String key) {
449      return executeCommand(commandObjects.memoryUsage(key));
450    }
451    @Override
452    public Long memoryUsage(String key, int samples) {
453      return executeCommand(commandObjects.memoryUsage(key, samples));
454    }
455    @Override
456    public Long memoryUsage(byte[] key) {
457      return executeCommand(commandObjects.memoryUsage(key));
458    }
459    @Override
460    public Long memoryUsage(byte[] key, int samples) {
461      return executeCommand(commandObjects.memoryUsage(key, samples));
462    }
463    @Override
464    public boolean copy(String srcKey, String dstKey, boolean replace) {
465      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
466    }
467    @Override
468    public String rename(String oldkey, String newkey) {
469      return executeCommand(commandObjects.rename(oldkey, newkey));
470    }
471    @Override
472    public long renamenx(String oldkey, String newkey) {
473      return executeCommand(commandObjects.renamenx(oldkey, newkey));
474    }
475    @Override
476    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
477      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
478    }
479    @Override
480    public String rename(byte[] oldkey, byte[] newkey) {
481      return executeCommand(commandObjects.rename(oldkey, newkey));
482    }
483    @Override
484    public long renamenx(byte[] oldkey, byte[] newkey) {
485      return executeCommand(commandObjects.renamenx(oldkey, newkey));
486    }
487    public long dbSize() {
488      return executeCommand(commandObjects.dbSize());
489    }
490    @Override
491    public Set&lt;String&gt; keys(String pattern) {
492      return executeCommand(commandObjects.keys(pattern));
493    }
494    @Override
495    public ScanResult&lt;String&gt; scan(String cursor) {
496      return executeCommand(commandObjects.scan(cursor));
497    }
498    @Override
499    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params) {
500      return executeCommand(commandObjects.scan(cursor, params));
501    }
502    @Override
503    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params, String type) {
504      return executeCommand(commandObjects.scan(cursor, params, type));
505    }
506    public ScanIteration scanIteration(int batchCount, String match) {
507      return new ScanIteration(provider, batchCount, match);
508    }
509    public ScanIteration scanIteration(int batchCount, String match, String type) {
510      return new ScanIteration(provider, batchCount, match, type);
511    }
512    @Override
513    public Set&lt;byte[]&gt; keys(byte[] pattern) {
514      return executeCommand(commandObjects.keys(pattern));
515    }
516    @Override
517    public ScanResult&lt;byte[]&gt; scan(byte[] cursor) {
518      return executeCommand(commandObjects.scan(cursor));
519    }
520    @Override
521    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params) {
522      return executeCommand(commandObjects.scan(cursor, params));
523    }
524    @Override
525    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params, byte[] type) {
526      return executeCommand(commandObjects.scan(cursor, params, type));
527    }
528    @Override
529    public String randomKey() {
530      return executeCommand(commandObjects.randomKey());
531    }
532    @Override
533    public byte[] randomBinaryKey() {
534      return executeCommand(commandObjects.randomBinaryKey());
535    }
536    @Override
537    public String set(String key, String value) {
538      return executeCommand(commandObjects.set(key, value));
539    }
540    @Override
541    public String set(String key, String value, SetParams params) {
542      return executeCommand(commandObjects.set(key, value, params));
543    }
544    @Override
545    public String get(String key) {
546      return executeCommand(commandObjects.get(key));
547    }
548    @Override
549    public String setGet(String key, String value) {
550      return executeCommand(commandObjects.setGet(key, value));
551    }
552    @Override
553    public String setGet(String key, String value, SetParams params) {
554      return executeCommand(commandObjects.setGet(key, value, params));
555    }
556    @Override
557    public String getDel(String key) {
558      return executeCommand(commandObjects.getDel(key));
559    }
560    @Override
561    public String getEx(String key, GetExParams params) {
562      return executeCommand(commandObjects.getEx(key, params));
563    }
564    @Override
565    public String set(byte[] key, byte[] value) {
566      return executeCommand(commandObjects.set(key, value));
567    }
568    @Override
569    public String set(byte[] key, byte[] value, SetParams params) {
570      return executeCommand(commandObjects.set(key, value, params));
571    }
572    @Override
573    public byte[] get(byte[] key) {
574      return executeCommand(commandObjects.get(key));
575    }
576    @Override
577    public byte[] setGet(byte[] key, byte[] value) {
578      return executeCommand(commandObjects.setGet(key, value));
579    }
580    @Override
581    public byte[] setGet(byte[] key, byte[] value, SetParams params) {
582      return executeCommand(commandObjects.setGet(key, value, params));
583    }
584    @Override
585    public byte[] getDel(byte[] key) {
586      return executeCommand(commandObjects.getDel(key));
587    }
588    @Override
589    public byte[] getEx(byte[] key, GetExParams params) {
590      return executeCommand(commandObjects.getEx(key, params));
591    }
592    @Override
593    public boolean setbit(String key, long offset, boolean value) {
594      return executeCommand(commandObjects.setbit(key, offset, value));
595    }
596    @Override
597    public boolean getbit(String key, long offset) {
598      return executeCommand(commandObjects.getbit(key, offset));
599    }
600    @Override
601    public long setrange(String key, long offset, String value) {
602      return executeCommand(commandObjects.setrange(key, offset, value));
603    }
604    @Override
605    public String getrange(String key, long startOffset, long endOffset) {
606      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
607    }
608    @Override
609    public boolean setbit(byte[] key, long offset, boolean value) {
610      return executeCommand(commandObjects.setbit(key, offset, value));
611    }
612    @Override
613    public boolean getbit(byte[] key, long offset) {
614      return executeCommand(commandObjects.getbit(key, offset));
615    }
616    @Override
617    public long setrange(byte[] key, long offset, byte[] value) {
618      return executeCommand(commandObjects.setrange(key, offset, value));
619    }
620    @Override
621    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
622      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
623    }
624    @Override
625    public String getSet(String key, String value) {
626      return executeCommand(commandObjects.getSet(key, value));
627    }
628    @Override
629    public long setnx(String key, String value) {
630      return executeCommand(commandObjects.setnx(key, value));
631    }
632    @Override
633    public String setex(String key, long seconds, String value) {
634      return executeCommand(commandObjects.setex(key, seconds, value));
635    }
636    @Override
637    public String psetex(String key, long milliseconds, String value) {
638      return executeCommand(commandObjects.psetex(key, milliseconds, value));
639    }
640    @Override
641    public byte[] getSet(byte[] key, byte[] value) {
642      return executeCommand(commandObjects.getSet(key, value));
643    }
644    @Override
645    public long setnx(byte[] key, byte[] value) {
646      return executeCommand(commandObjects.setnx(key, value));
647    }
648    @Override
649    public String setex(byte[] key, long seconds, byte[] value) {
650      return executeCommand(commandObjects.setex(key, seconds, value));
651    }
652    @Override
653    public String psetex(byte[] key, long milliseconds, byte[] value) {
654      return executeCommand(commandObjects.psetex(key, milliseconds, value));
655    }
656    @Override
657    public long incr(String key) {
658      return executeCommand(commandObjects.incr(key));
659    }
660    @Override
661    public long incrBy(String key, long increment) {
662      return executeCommand(commandObjects.incrBy(key, increment));
663    }
664    @Override
665    public double incrByFloat(String key, double increment) {
666      return executeCommand(commandObjects.incrByFloat(key, increment));
667    }
668    @Override
669    public long decr(String key) {
670      return executeCommand(commandObjects.decr(key));
671    }
672    @Override
673    public long decrBy(String key, long decrement) {
674      return executeCommand(commandObjects.decrBy(key, decrement));
675    }
676    @Override
677    public long incr(byte[] key) {
678      return executeCommand(commandObjects.incr(key));
679    }
680    @Override
681    public long incrBy(byte[] key, long increment) {
682      return executeCommand(commandObjects.incrBy(key, increment));
683    }
684    @Override
685    public double incrByFloat(byte[] key, double increment) {
686      return executeCommand(commandObjects.incrByFloat(key, increment));
687    }
688    @Override
689    public long decr(byte[] key) {
690      return executeCommand(commandObjects.decr(key));
691    }
692    @Override
693    public long decrBy(byte[] key, long decrement) {
694      return executeCommand(commandObjects.decrBy(key, decrement));
695    }
696    @Override
697    public List&lt;String&gt; mget(String... keys) {
698      return executeCommand(commandObjects.mget(keys));
699    }
700    @Override
701    public String mset(String... keysvalues) {
702      return executeCommand(commandObjects.mset(keysvalues));
703    }
704    @Override
705    public long msetnx(String... keysvalues) {
706      return executeCommand(commandObjects.msetnx(keysvalues));
707    }
708    @Override
709    public List&lt;byte[]&gt; mget(byte[]... keys) {
710      return executeCommand(commandObjects.mget(keys));
711    }
712    @Override
713    public String mset(byte[]... keysvalues) {
714      return executeCommand(commandObjects.mset(keysvalues));
715    }
716    @Override
717    public long msetnx(byte[]... keysvalues) {
718      return executeCommand(commandObjects.msetnx(keysvalues));
719    }
720    @Override
721    public long append(String key, String value) {
722      return executeCommand(commandObjects.append(key, value));
723    }
724    @Override
725    public String substr(String key, int start, int end) {
726      return executeCommand(commandObjects.substr(key, start, end));
727    }
728    @Override
729    public long strlen(String key) {
730      return executeCommand(commandObjects.strlen(key));
731    }
732    @Override
733    public long append(byte[] key, byte[] value) {
734      return executeCommand(commandObjects.append(key, value));
735    }
736    @Override
737    public byte[] substr(byte[] key, int start, int end) {
738      return executeCommand(commandObjects.substr(key, start, end));
739    }
740    @Override
741    public long strlen(byte[] key) {
742      return executeCommand(commandObjects.strlen(key));
743    }
744    @Override
745    public long bitcount(String key) {
746      return executeCommand(commandObjects.bitcount(key));
747    }
748    @Override
749    public long bitcount(String key, long start, long end) {
750      return executeCommand(commandObjects.bitcount(key, start, end));
751    }
752    @Override
753    public long bitcount(String key, long start, long end, BitCountOption option) {
754      return executeCommand(commandObjects.bitcount(key, start, end, option));
755    }
756    @Override
757    public long bitpos(String key, boolean value) {
758      return executeCommand(commandObjects.bitpos(key, value));
759    }
760    @Override
761    public long bitpos(String key, boolean value, BitPosParams params) {
762      return executeCommand(commandObjects.bitpos(key, value, params));
763    }
764    @Override
765    public long bitcount(byte[] key) {
766      return executeCommand(commandObjects.bitcount(key));
767    }
768    @Override
769    public long bitcount(byte[] key, long start, long end) {
770      return executeCommand(commandObjects.bitcount(key, start, end));
771    }
772    @Override
773    public long bitcount(byte[] key, long start, long end, BitCountOption option) {
774      return executeCommand(commandObjects.bitcount(key, start, end, option));
775    }
776    @Override
777    public long bitpos(byte[] key, boolean value) {
778      return executeCommand(commandObjects.bitpos(key, value));
779    }
780    @Override
781    public long bitpos(byte[] key, boolean value, BitPosParams params) {
782      return executeCommand(commandObjects.bitpos(key, value, params));
783    }
784    @Override
785    public List&lt;Long&gt; bitfield(String key, String... arguments) {
786      return executeCommand(commandObjects.bitfield(key, arguments));
787    }
788    @Override
789    public List&lt;Long&gt; bitfieldReadonly(String key, String... arguments) {
790      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
791    }
792    @Override
793    public List&lt;Long&gt; bitfield(byte[] key, byte[]... arguments) {
794      return executeCommand(commandObjects.bitfield(key, arguments));
795    }
796    @Override
797    public List&lt;Long&gt; bitfieldReadonly(byte[] key, byte[]... arguments) {
798      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
799    }
800    @Override
801    public long bitop(BitOP op, String destKey, String... srcKeys) {
802      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
803    }
804    @Override
805    public long bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
806      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
807    }
808    @Override
809    public LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {
810      return executeCommand(commandObjects.lcs(keyA, keyB, params));
811    }
812    @Override
813    public LCSMatchResult lcs(byte[] keyA, byte[] keyB, LCSParams params) {
814      return executeCommand(commandObjects.lcs(keyA, keyB, params));
815    }
816    @Override
817    public long rpush(String key, String... string) {
818      return executeCommand(commandObjects.rpush(key, string));
819    }
820    @Override
821    public long lpush(String key, String... string) {
822      return executeCommand(commandObjects.lpush(key, string));
823    }
824    @Override
825    public long llen(String key) {
826      return executeCommand(commandObjects.llen(key));
827    }
828    @Override
829    public List&lt;String&gt; lrange(String key, long start, long stop) {
830      return executeCommand(commandObjects.lrange(key, start, stop));
831    }
832    @Override
833    public String ltrim(String key, long start, long stop) {
834      return executeCommand(commandObjects.ltrim(key, start, stop));
835    }
836    @Override
837    public String lindex(String key, long index) {
838      return executeCommand(commandObjects.lindex(key, index));
839    }
840    @Override
841    public long rpush(byte[] key, byte[]... args) {
842      return executeCommand(commandObjects.rpush(key, args));
843    }
844    @Override
845    public long lpush(byte[] key, byte[]... args) {
846      return executeCommand(commandObjects.lpush(key, args));
847    }
848    @Override
849    public long llen(byte[] key) {
850      return executeCommand(commandObjects.llen(key));
851    }
852    @Override
853    public List&lt;byte[]&gt; lrange(byte[] key, long start, long stop) {
854      return executeCommand(commandObjects.lrange(key, start, stop));
855    }
856    @Override
857    public String ltrim(byte[] key, long start, long stop) {
858      return executeCommand(commandObjects.ltrim(key, start, stop));
859    }
860    @Override
861    public byte[] lindex(byte[] key, long index) {
862      return executeCommand(commandObjects.lindex(key, index));
863    }
864    @Override
865    public String lset(String key, long index, String value) {
866      return executeCommand(commandObjects.lset(key, index, value));
867    }
868    @Override
869    public long lrem(String key, long count, String value) {
870      return executeCommand(commandObjects.lrem(key, count, value));
871    }
872    @Override
873    public String lpop(String key) {
874      return executeCommand(commandObjects.lpop(key));
875    }
876    @Override
877    public List&lt;String&gt; lpop(String key, int count) {
878      return executeCommand(commandObjects.lpop(key, count));
879    }
880    @Override
881    public String lset(byte[] key, long index, byte[] value) {
882      return executeCommand(commandObjects.lset(key, index, value));
883    }
884    @Override
885    public long lrem(byte[] key, long count, byte[] value) {
886      return executeCommand(commandObjects.lrem(key, count, value));
887    }
888    @Override
889    public byte[] lpop(byte[] key) {
890      return executeCommand(commandObjects.lpop(key));
891    }
892    @Override
893    public List&lt;byte[]&gt; lpop(byte[] key, int count) {
894      return executeCommand(commandObjects.lpop(key, count));
895    }
896    @Override
897    public Long lpos(String key, String element) {
898      return executeCommand(commandObjects.lpos(key, element));
899    }
900    @Override
901    public Long lpos(String key, String element, LPosParams params) {
902      return executeCommand(commandObjects.lpos(key, element, params));
903    }
904    @Override
905    public List&lt;Long&gt; lpos(String key, String element, LPosParams params, long count) {
906      return executeCommand(commandObjects.lpos(key, element, params, count));
907    }
908    @Override
909    public Long lpos(byte[] key, byte[] element) {
910      return executeCommand(commandObjects.lpos(key, element));
911    }
912    @Override
913    public Long lpos(byte[] key, byte[] element, LPosParams params) {
914      return executeCommand(commandObjects.lpos(key, element, params));
915    }
916    @Override
917    public List&lt;Long&gt; lpos(byte[] key, byte[] element, LPosParams params, long count) {
918      return executeCommand(commandObjects.lpos(key, element, params, count));
919    }
920    @Override
921    public String rpop(String key) {
922      return executeCommand(commandObjects.rpop(key));
923    }
924    @Override
925    public List&lt;String&gt; rpop(String key, int count) {
926      return executeCommand(commandObjects.rpop(key, count));
927    }
928    @Override
929    public byte[] rpop(byte[] key) {
930      return executeCommand(commandObjects.rpop(key));
931    }
932    @Override
933    public List&lt;byte[]&gt; rpop(byte[] key, int count) {
934      return executeCommand(commandObjects.rpop(key, count));
935    }
936    @Override
937    public long linsert(String key, ListPosition where, String pivot, String value) {
938      return executeCommand(commandObjects.linsert(key, where, pivot, value));
939    }
940    @Override
941    public long lpushx(String key, String... strings) {
942      return executeCommand(commandObjects.lpushx(key, strings));
943    }
944    @Override
945    public long rpushx(String key, String... strings) {
946      return executeCommand(commandObjects.rpushx(key, strings));
947    }
948    @Override
949    public long linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value) {
950      return executeCommand(commandObjects.linsert(key, where, pivot, value));
951    }
952    @Override
953    public long lpushx(byte[] key, byte[]... args) {
954      return executeCommand(commandObjects.lpushx(key, args));
955    }
956    @Override
957    public long rpushx(byte[] key, byte[]... args) {
958      return executeCommand(commandObjects.rpushx(key, args));
959    }
960    @Override
961    public List&lt;String&gt; blpop(int timeout, String key) {
962      return executeCommand(commandObjects.blpop(timeout, key));
963    }
964    @Override
965    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
966      return executeCommand(commandObjects.blpop(timeout, key));
967    }
968    @Override
969    public List&lt;String&gt; brpop(int timeout, String key) {
970      return executeCommand(commandObjects.brpop(timeout, key));
971    }
972    @Override
973    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
974      return executeCommand(commandObjects.brpop(timeout, key));
975    }
976    @Override
977    public List&lt;String&gt; blpop(int timeout, String... keys) {
978      return executeCommand(commandObjects.blpop(timeout, keys));
979    }
980    @Override
981    public KeyValue&lt;String, String&gt; blpop(double timeout, String... keys) {
982      return executeCommand(commandObjects.blpop(timeout, keys));
983    }
984    @Override
985    public List&lt;String&gt; brpop(int timeout, String... keys) {
986      return executeCommand(commandObjects.brpop(timeout, keys));
987    }
988    @Override
989    public KeyValue&lt;String, String&gt; brpop(double timeout, String... keys) {
990      return executeCommand(commandObjects.brpop(timeout, keys));
991    }
992    @Override
993    public List&lt;byte[]&gt; blpop(int timeout, byte[]... keys) {
994      return executeCommand(commandObjects.blpop(timeout, keys));
995    }
996    @Override
997    public KeyValue&lt;byte[], byte[]&gt; blpop(double timeout, byte[]... keys) {
998      return executeCommand(commandObjects.blpop(timeout, keys));
999    }
1000    @Override
1001    public List&lt;byte[]&gt; brpop(int timeout, byte[]... keys) {
1002      return executeCommand(commandObjects.brpop(timeout, keys));
1003    }
1004    @Override
1005    public KeyValue&lt;byte[], byte[]&gt; brpop(double timeout, byte[]... keys) {
1006      return executeCommand(commandObjects.brpop(timeout, keys));
1007    }
1008    @Override
1009    public String rpoplpush(String srckey, String dstkey) {
1010      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1011    }
1012    @Override
1013    public String brpoplpush(String source, String destination, int timeout) {
1014      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1015    }
1016    @Override
1017    public byte[] rpoplpush(byte[] srckey, byte[] dstkey) {
1018      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1019    }
1020    @Override
1021    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
1022      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1023    }
1024    @Override
1025    public String lmove(String srcKey, String dstKey, ListDirection from, ListDirection to) {
1026      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1027    }
1028    @Override
1029    public String blmove(String srcKey, String dstKey, ListDirection from, ListDirection to, double timeout) {
1030      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1031    }
1032    @Override
1033    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1034      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1035    }
1036    @Override
1037    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1038      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1039    }
1040    @Override
1041    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
1042      return executeCommand(commandObjects.lmpop(direction, keys));
1043    }
1044    @Override
1045    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
1046      return executeCommand(commandObjects.lmpop(direction, count, keys));
1047    }
1048    @Override
1049    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
1050      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1051    }
1052    @Override
1053    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
1054      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1055    }
1056    @Override
1057    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1058      return executeCommand(commandObjects.lmpop(direction, keys));
1059    }
1060    @Override
1061    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1062      return executeCommand(commandObjects.lmpop(direction, count, keys));
1063    }
1064    @Override
1065    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1066      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1067    }
1068    @Override
1069    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1070      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1071    }
1072    @Override
1073    public long hset(String key, String field, String value) {
1074      return executeCommand(commandObjects.hset(key, field, value));
1075    }
1076    @Override
1077    public long hset(String key, Map&lt;String, String&gt; hash) {
1078      return executeCommand(commandObjects.hset(key, hash));
1079    }
1080    @Override
1081    public String hget(String key, String field) {
1082      return executeCommand(commandObjects.hget(key, field));
1083    }
1084    @Override
1085    public long hsetnx(String key, String field, String value) {
1086      return executeCommand(commandObjects.hsetnx(key, field, value));
1087    }
1088    @Override
1089    public String hmset(String key, Map&lt;String, String&gt; hash) {
1090      return executeCommand(commandObjects.hmset(key, hash));
1091    }
1092    @Override
1093    public List&lt;String&gt; hmget(String key, String... fields) {
1094      return executeCommand(commandObjects.hmget(key, fields));
1095    }
1096    @Override
1097    public long hset(byte[] key, byte[] field, byte[] value) {
1098      return executeCommand(commandObjects.hset(key, field, value));
1099    }
1100    @Override
1101    public long hset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1102      return executeCommand(commandObjects.hset(key, hash));
1103    }
1104    @Override
1105    public byte[] hget(byte[] key, byte[] field) {
1106      return executeCommand(commandObjects.hget(key, field));
1107    }
1108    @Override
1109    public long hsetnx(byte[] key, byte[] field, byte[] value) {
1110      return executeCommand(commandObjects.hsetnx(key, field, value));
1111    }
1112    @Override
1113    public String hmset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1114      return executeCommand(commandObjects.hmset(key, hash));
1115    }
1116    @Override
1117    public List&lt;byte[]&gt; hmget(byte[] key, byte[]... fields) {
1118      return executeCommand(commandObjects.hmget(key, fields));
1119    }
1120    @Override
1121    public long hincrBy(String key, String field, long value) {
1122      return executeCommand(commandObjects.hincrBy(key, field, value));
1123    }
1124    @Override
1125    public double hincrByFloat(String key, String field, double value) {
1126      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1127    }
1128    @Override
1129    public boolean hexists(String key, String field) {
1130      return executeCommand(commandObjects.hexists(key, field));
1131    }
1132    @Override
1133    public long hdel(String key, String... field) {
1134      return executeCommand(commandObjects.hdel(key, field));
1135    }
1136    @Override
1137    public long hlen(String key) {
1138      return executeCommand(commandObjects.hlen(key));
1139    }
1140    @Override
1141    public long hincrBy(byte[] key, byte[] field, long value) {
1142      return executeCommand(commandObjects.hincrBy(key, field, value));
1143    }
1144    @Override
1145    public double hincrByFloat(byte[] key, byte[] field, double value) {
1146      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1147    }
1148    @Override
1149    public boolean hexists(byte[] key, byte[] field) {
1150      return executeCommand(commandObjects.hexists(key, field));
1151    }
1152    @Override
1153    public long hdel(byte[] key, byte[]... field) {
1154      return executeCommand(commandObjects.hdel(key, field));
1155    }
1156    @Override
1157    public long hlen(byte[] key) {
1158      return executeCommand(commandObjects.hlen(key));
1159    }
1160    @Override
1161    public Set&lt;String&gt; hkeys(String key) {
1162      return executeCommand(commandObjects.hkeys(key));
1163    }
1164    @Override
1165    public List&lt;String&gt; hvals(String key) {
1166      return executeCommand(commandObjects.hvals(key));
1167    }
1168    @Override
1169    public Map&lt;String, String&gt; hgetAll(String key) {
1170      return executeCommand(commandObjects.hgetAll(key));
1171    }
1172    @Override
1173    public Set&lt;byte[]&gt; hkeys(byte[] key) {
1174      return executeCommand(commandObjects.hkeys(key));
1175    }
1176    @Override
1177    public List&lt;byte[]&gt; hvals(byte[] key) {
1178      return executeCommand(commandObjects.hvals(key));
1179    }
1180    @Override
1181    public Map&lt;byte[], byte[]&gt; hgetAll(byte[] key) {
1182      return executeCommand(commandObjects.hgetAll(key));
1183    }
1184    @Override
1185    public String hrandfield(String key) {
1186      return executeCommand(commandObjects.hrandfield(key));
1187    }
1188    @Override
1189    public List&lt;String&gt; hrandfield(String key, long count) {
1190      return executeCommand(commandObjects.hrandfield(key, count));
1191    }
1192    @Override
1193    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(String key, long count) {
1194      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1195    }
1196    @Override
1197    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(String key, String cursor, ScanParams params) {
1198      return executeCommand(commandObjects.hscan(key, cursor, params));
1199    }
1200    @Override
1201    public long hstrlen(String key, String field) {
1202      return executeCommand(commandObjects.hstrlen(key, field));
1203    }
1204    @Override
1205    public byte[] hrandfield(byte[] key) {
1206      return executeCommand(commandObjects.hrandfield(key));
1207    }
1208    @Override
1209    public List&lt;byte[]&gt; hrandfield(byte[] key, long count) {
1210      return executeCommand(commandObjects.hrandfield(key, count));
1211    }
1212    @Override
1213    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(byte[] key, long count) {
1214      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1215    }
1216    @Override
1217    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(byte[] key, byte[] cursor, ScanParams params) {
1218      return executeCommand(commandObjects.hscan(key, cursor, params));
1219    }
1220    @Override
1221    public long hstrlen(byte[] key, byte[] field) {
1222      return executeCommand(commandObjects.hstrlen(key, field));
1223    }
1224    @Override
1225    public long sadd(String key, String... members) {
1226      return executeCommand(commandObjects.sadd(key, members));
1227    }
1228    @Override
1229    public Set&lt;String&gt; smembers(String key) {
1230      return executeCommand(commandObjects.smembers(key));
1231    }
1232    @Override
1233    public long srem(String key, String... members) {
1234      return executeCommand(commandObjects.srem(key, members));
1235    }
1236    @Override
1237    public String spop(String key) {
1238      return executeCommand(commandObjects.spop(key));
1239    }
1240    @Override
1241    public Set&lt;String&gt; spop(String key, long count) {
1242      return executeCommand(commandObjects.spop(key, count));
1243    }
1244    @Override
1245    public long scard(String key) {
1246      return executeCommand(commandObjects.scard(key));
1247    }
1248    @Override
1249    public boolean sismember(String key, String member) {
1250      return executeCommand(commandObjects.sismember(key, member));
1251    }
1252    @Override
1253    public List&lt;Boolean&gt; smismember(String key, String... members) {
1254      return executeCommand(commandObjects.smismember(key, members));
1255    }
1256    @Override
1257    public long sadd(byte[] key, byte[]... members) {
1258      return executeCommand(commandObjects.sadd(key, members));
1259    }
1260    @Override
1261    public Set&lt;byte[]&gt; smembers(byte[] key) {
1262      return executeCommand(commandObjects.smembers(key));
1263    }
1264    @Override
1265    public long srem(byte[] key, byte[]... members) {
1266      return executeCommand(commandObjects.srem(key, members));
1267    }
1268    @Override
1269    public byte[] spop(byte[] key) {
1270      return executeCommand(commandObjects.spop(key));
1271    }
1272    @Override
1273    public Set&lt;byte[]&gt; spop(byte[] key, long count) {
1274      return executeCommand(commandObjects.spop(key, count));
1275    }
1276    @Override
1277    public long scard(byte[] key) {
1278      return executeCommand(commandObjects.scard(key));
1279    }
1280    @Override
1281    public boolean sismember(byte[] key, byte[] member) {
1282      return executeCommand(commandObjects.sismember(key, member));
1283    }
1284    @Override
1285    public List&lt;Boolean&gt; smismember(byte[] key, byte[]... members) {
1286      return executeCommand(commandObjects.smismember(key, members));
1287    }
1288    @Override
1289    public String srandmember(String key) {
1290      return executeCommand(commandObjects.srandmember(key));
1291    }
1292    @Override
1293    public List&lt;String&gt; srandmember(String key, int count) {
1294      return executeCommand(commandObjects.srandmember(key, count));
1295    }
1296    @Override
1297    public ScanResult&lt;String&gt; sscan(String key, String cursor, ScanParams params) {
1298      return executeCommand(commandObjects.sscan(key, cursor, params));
1299    }
1300    @Override
1301    public byte[] srandmember(byte[] key) {
1302      return executeCommand(commandObjects.srandmember(key));
1303    }
1304    @Override
1305    public List&lt;byte[]&gt; srandmember(byte[] key, int count) {
1306      return executeCommand(commandObjects.srandmember(key, count));
1307    }
1308    @Override
1309    public ScanResult&lt;byte[]&gt; sscan(byte[] key, byte[] cursor, ScanParams params) {
1310      return executeCommand(commandObjects.sscan(key, cursor, params));
1311    }
1312    @Override
1313    public Set&lt;String&gt; sdiff(String... keys) {
1314      return executeCommand(commandObjects.sdiff(keys));
1315    }
1316    @Override
1317    public long sdiffstore(String dstkey, String... keys) {
1318      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1319    }
1320    @Override
1321    public Set&lt;String&gt; sinter(String... keys) {
1322      return executeCommand(commandObjects.sinter(keys));
1323    }
1324    @Override
1325    public long sinterstore(String dstkey, String... keys) {
1326      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1327    }
1328    @Override
1329    public long sintercard(String... keys) {
1330      return executeCommand(commandObjects.sintercard(keys));
1331    }
1332    @Override
1333    public long sintercard(int limit, String... keys) {
1334      return executeCommand(commandObjects.sintercard(limit, keys));
1335    }
1336    @Override
1337    public Set&lt;String&gt; sunion(String... keys) {
1338      return executeCommand(commandObjects.sunion(keys));
1339    }
1340    @Override
1341    public long sunionstore(String dstkey, String... keys) {
1342      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1343    }
1344    @Override
1345    public long smove(String srckey, String dstkey, String member) {
1346      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1347    }
1348    @Override
1349    public Set&lt;byte[]&gt; sdiff(byte[]... keys) {
1350      return executeCommand(commandObjects.sdiff(keys));
1351    }
1352    @Override
1353    public long sdiffstore(byte[] dstkey, byte[]... keys) {
1354      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1355    }
1356    @Override
1357    public Set&lt;byte[]&gt; sinter(byte[]... keys) {
1358      return executeCommand(commandObjects.sinter(keys));
1359    }
1360    @Override
1361    public long sinterstore(byte[] dstkey, byte[]... keys) {
1362      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1363    }
1364    @Override
1365    public long sintercard(byte[]... keys) {
1366      return executeCommand(commandObjects.sintercard(keys));
1367    }
1368    @Override
1369    public long sintercard(int limit, byte[]... keys) {
1370      return executeCommand(commandObjects.sintercard(limit, keys));
1371    }
1372    @Override
1373    public Set&lt;byte[]&gt; sunion(byte[]... keys) {
1374      return executeCommand(commandObjects.sunion(keys));
1375    }
1376    @Override
1377    public long sunionstore(byte[] dstkey, byte[]... keys) {
1378      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1379    }
1380    @Override
1381    public long smove(byte[] srckey, byte[] dstkey, byte[] member) {
1382      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1383    }
1384    @Override
1385    public long zadd(String key, double score, String member) {
1386      return executeCommand(commandObjects.zadd(key, score, member));
1387    }
1388    @Override
1389    public long zadd(String key, double score, String member, ZAddParams params) {
1390      return executeCommand(commandObjects.zadd(key, score, member, params));
1391    }
1392    @Override
1393    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers) {
1394      return executeCommand(commandObjects.zadd(key, scoreMembers));
1395    }
1396    @Override
1397    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers, ZAddParams params) {
1398      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1399    }
1400    @Override
1401    public Double zaddIncr(String key, double score, String member, ZAddParams params) {
1402      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1403    }
1404    @Override
1405    public long zadd(byte[] key, double score, byte[] member) {
1406      return executeCommand(commandObjects.zadd(key, score, member));
1407    }
1408    @Override
1409    public long zadd(byte[] key, double score, byte[] member, ZAddParams params) {
1410      return executeCommand(commandObjects.zadd(key, score, member, params));
1411    }
1412    @Override
1413    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers) {
1414      return executeCommand(commandObjects.zadd(key, scoreMembers));
1415    }
1416    @Override
1417    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers, ZAddParams params) {
1418      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1419    }
1420    @Override
1421    public Double zaddIncr(byte[] key, double score, byte[] member, ZAddParams params) {
1422      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1423    }
1424    @Override
1425    public long zrem(String key, String... members) {
1426      return executeCommand(commandObjects.zrem(key, members));
1427    }
1428    @Override
1429    public double zincrby(String key, double increment, String member) {
1430      return executeCommand(commandObjects.zincrby(key, increment, member));
1431    }
1432    @Override
1433    public Double zincrby(String key, double increment, String member, ZIncrByParams params) {
1434      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1435    }
1436    @Override
1437    public Long zrank(String key, String member) {
1438      return executeCommand(commandObjects.zrank(key, member));
1439    }
1440    @Override
1441    public Long zrevrank(String key, String member) {
1442      return executeCommand(commandObjects.zrevrank(key, member));
1443    }
1444    @Override
1445    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
1446      return executeCommand(commandObjects.zrankWithScore(key, member));
1447    }
1448    @Override
1449    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
1450      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1451    }
1452    @Override
1453    public long zrem(byte[] key, byte[]... members) {
1454      return executeCommand(commandObjects.zrem(key, members));
1455    }
1456    @Override
1457    public double zincrby(byte[] key, double increment, byte[] member) {
1458      return executeCommand(commandObjects.zincrby(key, increment, member));
1459    }
1460    @Override
1461    public Double zincrby(byte[] key, double increment, byte[] member, ZIncrByParams params) {
1462      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1463    }
1464    @Override
1465    public Long zrank(byte[] key, byte[] member) {
1466      return executeCommand(commandObjects.zrank(key, member));
1467    }
1468    @Override
1469    public Long zrevrank(byte[] key, byte[] member) {
1470      return executeCommand(commandObjects.zrevrank(key, member));
1471    }
1472    @Override
1473    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
1474      return executeCommand(commandObjects.zrankWithScore(key, member));
1475    }
1476    @Override
1477    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
1478      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1479    }
1480    @Override
1481    public String zrandmember(String key) {
1482      return executeCommand(commandObjects.zrandmember(key));
1483    }
1484    @Override
1485    public List&lt;String&gt; zrandmember(String key, long count) {
1486      return executeCommand(commandObjects.zrandmember(key, count));
1487    }
1488    @Override
1489    public List&lt;Tuple&gt; zrandmemberWithScores(String key, long count) {
1490      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1491    }
1492    @Override
1493    public long zcard(String key) {
1494      return executeCommand(commandObjects.zcard(key));
1495    }
1496    @Override
1497    public Double zscore(String key, String member) {
1498      return executeCommand(commandObjects.zscore(key, member));
1499    }
1500    @Override
1501    public List&lt;Double&gt; zmscore(String key, String... members) {
1502      return executeCommand(commandObjects.zmscore(key, members));
1503    }
1504    @Override
1505    public byte[] zrandmember(byte[] key) {
1506      return executeCommand(commandObjects.zrandmember(key));
1507    }
1508    @Override
1509    public List&lt;byte[]&gt; zrandmember(byte[] key, long count) {
1510      return executeCommand(commandObjects.zrandmember(key, count));
1511    }
1512    @Override
1513    public List&lt;Tuple&gt; zrandmemberWithScores(byte[] key, long count) {
1514      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1515    }
1516    @Override
1517    public long zcard(byte[] key) {
1518      return executeCommand(commandObjects.zcard(key));
1519    }
1520    @Override
1521    public Double zscore(byte[] key, byte[] member) {
1522      return executeCommand(commandObjects.zscore(key, member));
1523    }
1524    @Override
1525    public List&lt;Double&gt; zmscore(byte[] key, byte[]... members) {
1526      return executeCommand(commandObjects.zmscore(key, members));
1527    }
1528    @Override
1529    public Tuple zpopmax(String key) {
1530      return executeCommand(commandObjects.zpopmax(key));
1531    }
1532    @Override
1533    public List&lt;Tuple&gt; zpopmax(String key, int count) {
1534      return executeCommand(commandObjects.zpopmax(key, count));
1535    }
1536    @Override
1537    public Tuple zpopmin(String key) {
1538      return executeCommand(commandObjects.zpopmin(key));
1539    }
1540    @Override
1541    public List&lt;Tuple&gt; zpopmin(String key, int count) {
1542      return executeCommand(commandObjects.zpopmin(key, count));
1543    }
1544    @Override
1545    public long zcount(String key, double min, double max) {
1546      return executeCommand(commandObjects.zcount(key, min, max));
1547    }
1548    @Override
1549    public long zcount(String key, String min, String max) {
1550      return executeCommand(commandObjects.zcount(key, min, max));
1551    }
1552    @Override
1553    public Tuple zpopmax(byte[] key) {
1554      return executeCommand(commandObjects.zpopmax(key));
1555    }
1556    @Override
1557    public List&lt;Tuple&gt; zpopmax(byte[] key, int count) {
1558      return executeCommand(commandObjects.zpopmax(key, count));
1559    }
1560    @Override
1561    public Tuple zpopmin(byte[] key) {
1562      return executeCommand(commandObjects.zpopmin(key));
1563    }
1564    @Override
1565    public List&lt;Tuple&gt; zpopmin(byte[] key, int count) {
1566      return executeCommand(commandObjects.zpopmin(key, count));
1567    }
1568    @Override
1569    public long zcount(byte[] key, double min, double max) {
1570      return executeCommand(commandObjects.zcount(key, min, max));
1571    }
1572    @Override
1573    public long zcount(byte[] key, byte[] min, byte[] max) {
1574      return executeCommand(commandObjects.zcount(key, min, max));
1575    }
1576    @Override
1577    public List&lt;String&gt; zrange(String key, long start, long stop) {
1578      return executeCommand(commandObjects.zrange(key, start, stop));
1579    }
1580    @Override
1581    public List&lt;String&gt; zrevrange(String key, long start, long stop) {
1582      return executeCommand(commandObjects.zrevrange(key, start, stop));
1583    }
1584    @Override
1585    public List&lt;Tuple&gt; zrangeWithScores(String key, long start, long stop) {
1586      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1587    }
1588    @Override
1589    public List&lt;Tuple&gt; zrevrangeWithScores(String key, long start, long stop) {
1590      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1591    }
1592    @Override
1593    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
1594      return executeCommand(commandObjects.zrange(key, zRangeParams));
1595    }
1596    @Override
1597    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
1598      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1599    }
1600    @Override
1601    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
1602      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1603    }
1604    @Override
1605    public List&lt;String&gt; zrangeByScore(String key, double min, double max) {
1606      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1607    }
1608    @Override
1609    public List&lt;String&gt; zrangeByScore(String key, String min, String max) {
1610      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1611    }
1612    @Override
1613    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min) {
1614      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1615    }
1616    @Override
1617    public List&lt;String&gt; zrangeByScore(String key, double min, double max, int offset, int count) {
1618      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1619    }
1620    @Override
1621    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min) {
1622      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1623    }
1624    @Override
1625    public List&lt;String&gt; zrangeByScore(String key, String min, String max, int offset, int count) {
1626      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1627    }
1628    @Override
1629    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min, int offset, int count) {
1630      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1631    }
1632    @Override
1633    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max) {
1634      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1635    }
1636    @Override
1637    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min) {
1638      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1639    }
1640    @Override
1641    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max, int offset, int count) {
1642      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1643    }
1644    @Override
1645    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min, int offset, int count) {
1646      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1647    }
1648    @Override
1649    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max) {
1650      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1651    }
1652    @Override
1653    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min) {
1654      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1655    }
1656    @Override
1657    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max, int offset, int count) {
1658      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1659    }
1660    @Override
1661    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) {
1662      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1663    }
1664    @Override
1665    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count) {
1666      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1667    }
1668    @Override
1669    public List&lt;byte[]&gt; zrange(byte[] key, long start, long stop) {
1670      return executeCommand(commandObjects.zrange(key, start, stop));
1671    }
1672    @Override
1673    public List&lt;byte[]&gt; zrevrange(byte[] key, long start, long stop) {
1674      return executeCommand(commandObjects.zrevrange(key, start, stop));
1675    }
1676    @Override
1677    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, long start, long stop) {
1678      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1679    }
1680    @Override
1681    public List&lt;Tuple&gt; zrevrangeWithScores(byte[] key, long start, long stop) {
1682      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1683    }
1684    @Override
1685    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
1686      return executeCommand(commandObjects.zrange(key, zRangeParams));
1687    }
1688    @Override
1689    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
1690      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1691    }
1692    @Override
1693    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
1694      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1695    }
1696    @Override
1697    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max) {
1698      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1699    }
1700    @Override
1701    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max) {
1702      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1703    }
1704    @Override
1705    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min) {
1706      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1707    }
1708    @Override
1709    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max, int offset, int count) {
1710      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1711    }
1712    @Override
1713    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
1714      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1715    }
1716    @Override
1717    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count) {
1718      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1719    }
1720    @Override
1721    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min, int offset, int count) {
1722      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1723    }
1724    @Override
1725    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max) {
1726      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1727    }
1728    @Override
1729    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min) {
1730      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1731    }
1732    @Override
1733    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count) {
1734      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1735    }
1736    @Override
1737    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count) {
1738      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1739    }
1740    @Override
1741    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
1742      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1743    }
1744    @Override
1745    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
1746      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1747    }
1748    @Override
1749    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count) {
1750      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1751    }
1752    @Override
1753    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count) {
1754      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1755    }
1756    @Override
1757    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count) {
1758      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1759    }
1760    @Override
1761    public long zremrangeByRank(String key, long start, long stop) {
1762      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1763    }
1764    @Override
1765    public long zremrangeByScore(String key, double min, double max) {
1766      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1767    }
1768    @Override
1769    public long zremrangeByScore(String key, String min, String max) {
1770      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1771    }
1772    @Override
1773    public long zremrangeByRank(byte[] key, long start, long stop) {
1774      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1775    }
1776    @Override
1777    public long zremrangeByScore(byte[] key, double min, double max) {
1778      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1779    }
1780    @Override
1781    public long zremrangeByScore(byte[] key, byte[] min, byte[] max) {
1782      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1783    }
1784    @Override
1785    public long zlexcount(String key, String min, String max) {
1786      return executeCommand(commandObjects.zlexcount(key, min, max));
1787    }
1788    @Override
1789    public List&lt;String&gt; zrangeByLex(String key, String min, String max) {
1790      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1791    }
1792    @Override
1793    public List&lt;String&gt; zrangeByLex(String key, String min, String max, int offset, int count) {
1794      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1795    }
1796    @Override
1797    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min) {
1798      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1799    }
1800    @Override
1801    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min, int offset, int count) {
1802      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1803    }
1804    @Override
1805    public long zremrangeByLex(String key, String min, String max) {
1806      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1807    }
1808    @Override
1809    public long zlexcount(byte[] key, byte[] min, byte[] max) {
1810      return executeCommand(commandObjects.zlexcount(key, min, max));
1811    }
1812    @Override
1813    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max) {
1814      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1815    }
1816    @Override
1817    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count) {
1818      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1819    }
1820    @Override
1821    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
1822      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1823    }
1824    @Override
1825    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
1826      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1827    }
1828    @Override
1829    public long zremrangeByLex(byte[] key, byte[] min, byte[] max) {
1830      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1831    }
1832    @Override
1833    public ScanResult&lt;Tuple&gt; zscan(String key, String cursor, ScanParams params) {
1834      return executeCommand(commandObjects.zscan(key, cursor, params));
1835    }
1836    @Override
1837    public ScanResult&lt;Tuple&gt; zscan(byte[] key, byte[] cursor, ScanParams params) {
1838      return executeCommand(commandObjects.zscan(key, cursor, params));
1839    }
1840    @Override
1841    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
1842      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1843    }
1844    @Override
1845    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
1846      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1847    }
1848    @Override
1849    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(double timeout, byte[]... keys) {
1850      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1851    }
1852    @Override
1853    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(double timeout, byte[]... keys) {
1854      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1855    }
1856    @Override
1857    public List&lt;String&gt; zdiff(String... keys) {
1858      return executeCommand(commandObjects.zdiff(keys));
1859    }
1860    @Override
1861    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
1862      return executeCommand(commandObjects.zdiffWithScores(keys));
1863    }
1864    @Override
1865    @Deprecated
1866    public long zdiffStore(String dstkey, String... keys) {
1867      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1868    }
1869    @Override
1870    public long zdiffstore(String dstkey, String... keys) {
1871      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1872    }
1873    @Override
1874    public List&lt;byte[]&gt; zdiff(byte[]... keys) {
1875      return executeCommand(commandObjects.zdiff(keys));
1876    }
1877    @Override
1878    public List&lt;Tuple&gt; zdiffWithScores(byte[]... keys) {
1879      return executeCommand(commandObjects.zdiffWithScores(keys));
1880    }
1881    @Override
1882    @Deprecated
1883    public long zdiffStore(byte[] dstkey, byte[]... keys) {
1884      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1885    }
1886    @Override
1887    public long zdiffstore(byte[] dstkey, byte[]... keys) {
1888      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1889    }
1890    @Override
1891    public long zinterstore(String dstkey, String... sets) {
1892      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1893    }
1894    @Override
1895    public long zinterstore(String dstkey, ZParams params, String... sets) {
1896      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1897    }
1898    @Override
1899    public List&lt;String&gt; zinter(ZParams params, String... keys) {
1900      return executeCommand(commandObjects.zinter(params, keys));
1901    }
1902    @Override
1903    public List&lt;Tuple&gt; zinterWithScores(ZParams params, String... keys) {
1904      return executeCommand(commandObjects.zinterWithScores(params, keys));
1905    }
1906    @Override
1907    public long zinterstore(byte[] dstkey, byte[]... sets) {
1908      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1909    }
1910    @Override
1911    public long zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
1912      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1913    }
1914    @Override
1915    public long zintercard(byte[]... keys) {
1916      return executeCommand(commandObjects.zintercard(keys));
1917    }
1918    @Override
1919    public long zintercard(long limit, byte[]... keys) {
1920      return executeCommand(commandObjects.zintercard(limit, keys));
1921    }
1922    @Override
1923    public long zintercard(String... keys) {
1924      return executeCommand(commandObjects.zintercard(keys));
1925    }
1926    @Override
1927    public long zintercard(long limit, String... keys) {
1928      return executeCommand(commandObjects.zintercard(limit, keys));
1929    }
1930    @Override
1931    public List&lt;byte[]&gt; zinter(ZParams params, byte[]... keys) {
1932      return executeCommand(commandObjects.zinter(params, keys));
1933    }
1934    @Override
1935    public List&lt;Tuple&gt; zinterWithScores(ZParams params, byte[]... keys) {
1936      return executeCommand(commandObjects.zinterWithScores(params, keys));
1937    }
1938    @Override
1939    public List&lt;String&gt; zunion(ZParams params, String... keys) {
1940      return executeCommand(commandObjects.zunion(params, keys));
1941    }
1942    @Override
1943    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
1944      return executeCommand(commandObjects.zunionWithScores(params, keys));
1945    }
1946    @Override
1947    public long zunionstore(String dstkey, String... sets) {
1948      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1949    }
1950    @Override
1951    public long zunionstore(String dstkey, ZParams params, String... sets) {
1952      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1953    }
1954    @Override
1955    public List&lt;byte[]&gt; zunion(ZParams params, byte[]... keys) {
1956      return executeCommand(commandObjects.zunion(params, keys));
1957    }
1958    @Override
1959    public List&lt;Tuple&gt; zunionWithScores(ZParams params, byte[]... keys) {
1960      return executeCommand(commandObjects.zunionWithScores(params, keys));
1961    }
1962    @Override
1963    public long zunionstore(byte[] dstkey, byte[]... sets) {
1964      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1965    }
1966    @Override
1967    public long zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
1968      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1969    }
1970    @Override
1971    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
1972      return executeCommand(commandObjects.zmpop(option, keys));
1973    }
1974    @Override
1975    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
1976      return executeCommand(commandObjects.zmpop(option, count, keys));
1977    }
1978    @Override
1979    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
1980      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1981    }
1982    @Override
1983    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
1984      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1985    }
1986    @Override
1987    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1988      return executeCommand(commandObjects.zmpop(option, keys));
1989    }
1990    @Override
1991    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1992      return executeCommand(commandObjects.zmpop(option, count, keys));
1993    }
1994    @Override
1995    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1996      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1997    }
1998    @Override
1999    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
2000      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
2001    }
2002    @Override
2003    public long geoadd(String key, double longitude, double latitude, String member) {
2004      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2005    }
2006    @Override
2007    public long geoadd(String key, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2008      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2009    }
2010    @Override
2011    public long geoadd(String key, GeoAddParams params, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2012      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2013    }
2014    @Override
2015    public Double geodist(String key, String member1, String member2) {
2016      return executeCommand(commandObjects.geodist(key, member1, member2));
2017    }
2018    @Override
2019    public Double geodist(String key, String member1, String member2, GeoUnit unit) {
2020      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2021    }
2022    @Override
2023    public List&lt;String&gt; geohash(String key, String... members) {
2024      return executeCommand(commandObjects.geohash(key, members));
2025    }
2026    @Override
2027    public List&lt;GeoCoordinate&gt; geopos(String key, String... members) {
2028      return executeCommand(commandObjects.geopos(key, members));
2029    }
2030    @Override
2031    public long geoadd(byte[] key, double longitude, double latitude, byte[] member) {
2032      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2033    }
2034    @Override
2035    public long geoadd(byte[] key, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2036      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2037    }
2038    @Override
2039    public long geoadd(byte[] key, GeoAddParams params, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2040      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2041    }
2042    @Override
2043    public Double geodist(byte[] key, byte[] member1, byte[] member2) {
2044      return executeCommand(commandObjects.geodist(key, member1, member2));
2045    }
2046    @Override
2047    public Double geodist(byte[] key, byte[] member1, byte[] member2, GeoUnit unit) {
2048      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2049    }
2050    @Override
2051    public List&lt;byte[]&gt; geohash(byte[] key, byte[]... members) {
2052      return executeCommand(commandObjects.geohash(key, members));
2053    }
2054    @Override
2055    public List&lt;GeoCoordinate&gt; geopos(byte[] key, byte[]... members) {
2056      return executeCommand(commandObjects.geopos(key, members));
2057    }
2058    @Override
2059    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2060      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2061    }
2062    @Override
2063    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2064      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2065    }
2066    @Override
2067    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2068      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2069    }
2070    @Override
2071    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2072      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2073    }
2074    @Override
2075    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit) {
2076      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2077    }
2078    @Override
2079    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit) {
2080      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2081    }
2082    @Override
2083    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2084      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2085    }
2086    @Override
2087    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2088      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2089    }
2090    @Override
2091    public long georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2092      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2093    }
2094    @Override
2095    public long georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2096      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2097    }
2098    @Override
2099    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
2100      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
2101    }
2102    @Override
2103    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
2104      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2105    }
2106    @Override
2107    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
2108      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2112      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2113    }
2114    @Override
2115    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
2116      return executeCommand(commandObjects.geosearch(key, params));
2117    }
2118    @Override
2119    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
2120      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2121    }
2122    @Override
2123    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
2124      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2125    }
2126    @Override
2127    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
2128      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2129    }
2130    @Override
2131    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2132      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2133    }
2134    @Override
2135    public long geosearchStore(String dest, String src, GeoSearchParam params) {
2136      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2137    }
2138    @Override
2139    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
2140      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2141    }
2142    @Override
2143    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2144      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2145    }
2146    @Override
2147    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2148      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2152      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2153    }
2154    @Override
2155    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2156      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2157    }
2158    @Override
2159    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit) {
2160      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2161    }
2162    @Override
2163    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit) {
2164      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2165    }
2166    @Override
2167    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2168      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2169    }
2170    @Override
2171    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2172      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2173    }
2174    @Override
2175    public long georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2176      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2177    }
2178    @Override
2179    public long georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2180      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2181    }
2182    @Override
2183    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2184      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
2185    }
2186    @Override
2187    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2188      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2189    }
2190    @Override
2191    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2192      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2193    }
2194    @Override
2195    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2196      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2197    }
2198    @Override
2199    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2200      return executeCommand(commandObjects.geosearch(key, params));
2201    }
2202    @Override
2203    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2204      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2205    }
2206    @Override
2207    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2208      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2209    }
2210    @Override
2211    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2212      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2213    }
2214    @Override
2215    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2216      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2217    }
2218    @Override
2219    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2220      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2221    }
2222    @Override
2223    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2224      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2225    }
2226    @Override
2227    public long pfadd(String key, String... elements) {
2228      return executeCommand(commandObjects.pfadd(key, elements));
2229    }
2230    @Override
2231    public String pfmerge(String destkey, String... sourcekeys) {
2232      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2233    }
2234    @Override
2235    public long pfcount(String key) {
2236      return executeCommand(commandObjects.pfcount(key));
2237    }
2238    @Override
2239    public long pfcount(String... keys) {
2240      return executeCommand(commandObjects.pfcount(keys));
2241    }
2242    @Override
2243    public long pfadd(byte[] key, byte[]... elements) {
2244      return executeCommand(commandObjects.pfadd(key, elements));
2245    }
2246    @Override
2247    public String pfmerge(byte[] destkey, byte[]... sourcekeys) {
2248      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2249    }
2250    @Override
2251    public long pfcount(byte[] key) {
2252      return executeCommand(commandObjects.pfcount(key));
2253    }
2254    @Override
2255    public long pfcount(byte[]... keys) {
2256      return executeCommand(commandObjects.pfcount(keys));
2257    }
2258    @Override
2259    public StreamEntryID xadd(String key, StreamEntryID id, Map&lt;String, String&gt; hash) {
2260      return executeCommand(commandObjects.xadd(key, id, hash));
2261    }
2262    @Override
2263    public StreamEntryID xadd(String key, XAddParams params, Map&lt;String, String&gt; hash) {
2264      return executeCommand(commandObjects.xadd(key, params, hash));
2265    }
2266    @Override
2267    public long xlen(String key) {
2268      return executeCommand(commandObjects.xlen(key));
2269    }
2270    @Override
2271    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end) {
2272      return executeCommand(commandObjects.xrange(key, start, end));
2273    }
2274    @Override
2275    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end, int count) {
2276      return executeCommand(commandObjects.xrange(key, start, end, count));
2277    }
2278    @Override
2279    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start) {
2280      return executeCommand(commandObjects.xrevrange(key, end, start));
2281    }
2282    @Override
2283    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start, int count) {
2284      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2285    }
2286    @Override
2287    public List&lt;StreamEntry&gt; xrange(String key, String start, String end) {
2288      return executeCommand(commandObjects.xrange(key, start, end));
2289    }
2290    @Override
2291    public List&lt;StreamEntry&gt; xrange(String key, String start, String end, int count) {
2292      return executeCommand(commandObjects.xrange(key, start, end, count));
2293    }
2294    @Override
2295    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start) {
2296      return executeCommand(commandObjects.xrevrange(key, end, start));
2297    }
2298    @Override
2299    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start, int count) {
2300      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2301    }
2302    @Override
2303    public long xack(String key, String group, StreamEntryID... ids) {
2304      return executeCommand(commandObjects.xack(key, group, ids));
2305    }
2306    @Override
2307    public String xgroupCreate(String key, String groupName, StreamEntryID id, boolean makeStream) {
2308      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2309    }
2310    @Override
2311    public String xgroupSetID(String key, String groupName, StreamEntryID id) {
2312      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2313    }
2314    @Override
2315    public long xgroupDestroy(String key, String groupName) {
2316      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2317    }
2318    @Override
2319    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
2320      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2321    }
2322    @Override
2323    public long xgroupDelConsumer(String key, String groupName, String consumerName) {
2324      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2325    }
2326    @Override
2327    public StreamPendingSummary xpending(String key, String groupName) {
2328      return executeCommand(commandObjects.xpending(key, groupName));
2329    }
2330    @Override
2331    public List&lt;StreamPendingEntry&gt; xpending(String key, String groupName, XPendingParams params) {
2332      return executeCommand(commandObjects.xpending(key, groupName, params));
2333    }
2334    @Override
2335    public long xdel(String key, StreamEntryID... ids) {
2336      return executeCommand(commandObjects.xdel(key, ids));
2337    }
2338    @Override
2339    public long xtrim(String key, long maxLen, boolean approximate) {
2340      return executeCommand(commandObjects.xtrim(key, maxLen, approximate));
2341    }
2342    @Override
2343    public long xtrim(String key, XTrimParams params) {
2344      return executeCommand(commandObjects.xtrim(key, params));
2345    }
2346    @Override
2347    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2348      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2349    }
2350    @Override
2351    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2352      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2353    }
2354    @Override
2355    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2356      return executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
2357    }
2358    @Override
2359    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2360      return executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
2361    }
2362    @Override
2363    public StreamInfo xinfoStream(String key) {
2364      return executeCommand(commandObjects.xinfoStream(key));
2365    }
2366    @Override
2367    public StreamFullInfo xinfoStreamFull(String key) {
2368      return executeCommand(commandObjects.xinfoStreamFull(key));
2369    }
2370    @Override
2371    public StreamFullInfo xinfoStreamFull(String key, int count) {
2372      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2373    }
2374    @Override
2375    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
2376      return executeCommand(commandObjects.xinfoGroups(key));
2377    }
2378    @Override
2379    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
2380      return executeCommand(commandObjects.xinfoConsumers(key, group));
2381    }
2382    @Override
2383    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
2384      return executeCommand(commandObjects.xinfoConsumers2(key, group));
2385    }
2386    @Override
2387    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(XReadParams xReadParams, Map&lt;String, StreamEntryID&gt; streams) {
2388      return executeCommand(commandObjects.xread(xReadParams, streams));
2389    }
2390    @Override
2391    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(String groupName, String consumer,
2392        XReadGroupParams xReadGroupParams, Map&lt;String, StreamEntryID&gt; streams) {
2393      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2394    }
2395    @Override
2396    public byte[] xadd(byte[] key, XAddParams params, Map&lt;byte[], byte[]&gt; hash) {
2397      return executeCommand(commandObjects.xadd(key, params, hash));
2398    }
2399    @Override
2400    public long xlen(byte[] key) {
2401      return executeCommand(commandObjects.xlen(key));
2402    }
2403    @Override
2404    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2405      return executeCommand(commandObjects.xrange(key, start, end));
2406    }
2407    @Override
2408    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2409      return executeCommand(commandObjects.xrange(key, start, end, count));
2410    }
2411    @Override
2412    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2413      return executeCommand(commandObjects.xrevrange(key, end, start));
2414    }
2415    @Override
2416    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2417      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2418    }
2419    @Override
2420    public long xack(byte[] key, byte[] group, byte[]... ids) {
2421      return executeCommand(commandObjects.xack(key, group, ids));
2422    }
2423    @Override
2424    public String xgroupCreate(byte[] key, byte[] groupName, byte[] id, boolean makeStream) {
2425      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2426    }
2427    @Override
2428    public String xgroupSetID(byte[] key, byte[] groupName, byte[] id) {
2429      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2430    }
2431    @Override
2432    public long xgroupDestroy(byte[] key, byte[] groupName) {
2433      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2434    }
2435    @Override
2436    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2437      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2438    }
2439    @Override
2440    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2441      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2442    }
2443    @Override
2444    public long xdel(byte[] key, byte[]... ids) {
2445      return executeCommand(commandObjects.xdel(key, ids));
2446    }
2447    @Override
2448    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2449      return executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2450    }
2451    @Override
2452    public long xtrim(byte[] key, XTrimParams params) {
2453      return executeCommand(commandObjects.xtrim(key, params));
2454    }
2455    @Override
2456    public Object xpending(byte[] key, byte[] groupName) {
2457      return executeCommand(commandObjects.xpending(key, groupName));
2458    }
2459    @Override
2460    public List&lt;Object&gt; xpending(byte[] key, byte[] groupName, XPendingParams params) {
2461      return executeCommand(commandObjects.xpending(key, groupName, params));
2462    }
2463    @Override
2464    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2465      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2466    }
2467    @Override
2468    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2469      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2470    }
2471    @Override
2472    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2473      return executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2474    }
2475    @Override
2476    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2477      return executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2478    }
2479    @Override
2480    public Object xinfoStream(byte[] key) {
2481      return executeCommand(commandObjects.xinfoStream(key));
2482    }
2483    @Override
2484    public Object xinfoStreamFull(byte[] key) {
2485      return executeCommand(commandObjects.xinfoStreamFull(key));
2486    }
2487    @Override
2488    public Object xinfoStreamFull(byte[] key, int count) {
2489      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2490    }
2491    @Override
2492    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2493      return executeCommand(commandObjects.xinfoGroups(key));
2494    }
2495    @Override
2496    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2497      return executeCommand(commandObjects.xinfoConsumers(key, group));
2498    }
2499    @Override
2500    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2501      return executeCommand(commandObjects.xread(xReadParams, streams));
2502    }
2503    @Override
2504    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2505      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2506    }
2507    @Override
2508    public Object eval(String script) {
2509      return executeCommand(commandObjects.eval(script));
2510    }
2511    @Override
2512    public Object eval(String script, int keyCount, String... params) {
2513      return executeCommand(commandObjects.eval(script, keyCount, params));
2514    }
2515    @Override
2516    public Object eval(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2517      return executeCommand(commandObjects.eval(script, keys, args));
2518    }
2519    @Override
2520    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2521      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2522    }
2523    @Override
2524    public Object evalsha(String sha1) {
2525      return executeCommand(commandObjects.evalsha(sha1));
2526    }
2527    @Override
2528    public Object evalsha(String sha1, int keyCount, String... params) {
2529      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2530    }
2531    @Override
2532    public Object evalsha(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2533      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2534    }
2535    @Override
2536    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2537      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2538    }
2539    @Override
2540    public Object eval(byte[] script) {
2541      return executeCommand(commandObjects.eval(script));
2542    }
2543    @Override
2544    public Object eval(byte[] script, int keyCount, byte[]... params) {
2545      return executeCommand(commandObjects.eval(script, keyCount, params));
2546    }
2547    @Override
2548    public Object eval(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2549      return executeCommand(commandObjects.eval(script, keys, args));
2550    }
2551    @Override
2552    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2553      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2554    }
2555    @Override
2556    public Object evalsha(byte[] sha1) {
2557      return executeCommand(commandObjects.evalsha(sha1));
2558    }
2559    @Override
2560    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
2561      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2562    }
2563    @Override
2564    public Object evalsha(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2565      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2566    }
2567    @Override
2568    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2569      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2570    }
2571    @Override
2572    public Object fcall(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2573      return executeCommand(commandObjects.fcall(name, keys, args));
2574    }
2575    @Override
2576    public Object fcallReadonly(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2577      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2578    }
2579    @Override
2580    public String functionDelete(String libraryName) {
2581      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2582    }
2583    @Override
2584    public String functionFlush() {
2585      return checkAndBroadcastCommand(commandObjects.functionFlush());
2586    }
2587    @Override
2588    public String functionFlush(FlushMode mode) {
2589      return checkAndBroadcastCommand(commandObjects.functionFlush(mode));
2590    }
2591    @Override
2592    public String functionKill() {
2593      return checkAndBroadcastCommand(commandObjects.functionKill());
2594    }
2595    @Override
2596    public List&lt;LibraryInfo&gt; functionList() {
2597      return executeCommand(commandObjects.functionList());
2598    }
2599    @Override
2600    public List&lt;LibraryInfo&gt; functionList(String libraryNamePattern) {
2601      return executeCommand(commandObjects.functionList(libraryNamePattern));
2602    }
2603    @Override
2604    public List&lt;LibraryInfo&gt; functionListWithCode() {
2605      return executeCommand(commandObjects.functionListWithCode());
2606    }
2607    @Override
2608    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
2609      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2610    }
2611    @Override
2612    public String functionLoad(String functionCode) {
2613      return executeCommand(commandObjects.functionLoad(functionCode));
2614    }
2615    @Override
2616    public String functionLoadReplace(String functionCode) {
2617      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2618    }
2619    @Override
2620    public FunctionStats functionStats() {
2621      return executeCommand(commandObjects.functionStats());
2622    }
2623    @Override
2624    public Object fcall(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2625      return executeCommand(commandObjects.fcall(name, keys, args));
2626    }
2627    @Override
2628    public Object fcallReadonly(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2629      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2630    }
2631    @Override
2632    public String functionDelete(byte[] libraryName) {
2633      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2634    }
2635    @Override
2636    public byte[] functionDump() {
2637      return executeCommand(commandObjects.functionDump());
2638    }
2639    @Override
2640    public List&lt;Object&gt; functionListBinary() {
2641      return executeCommand(commandObjects.functionListBinary());
2642    }
2643    @Override
2644    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
2645      return executeCommand(commandObjects.functionList(libraryNamePattern));
2646    }
2647    @Override
2648    public List&lt;Object&gt; functionListWithCodeBinary() {
2649      return executeCommand(commandObjects.functionListWithCodeBinary());
2650    }
2651    @Override
2652    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
2653      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2654    }
2655    @Override
2656    public String functionLoad(byte[] functionCode) {
2657      return executeCommand(commandObjects.functionLoad(functionCode));
2658    }
2659    @Override
2660    public String functionLoadReplace(byte[] functionCode) {
2661      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2662    }
2663    @Override
2664    public String functionRestore(byte[] serializedValue) {
2665      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue));
2666    }
2667    @Override
2668    public String functionRestore(byte[] serializedValue, FunctionRestorePolicy policy) {
2669      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue, policy));
2670    }
2671    @Override
2672    public Object functionStatsBinary() {
2673      return executeCommand(commandObjects.functionStatsBinary());
2674    }
2675    @Override
2676    public Long objectRefcount(String key) {
2677      return executeCommand(commandObjects.objectRefcount(key));
2678    }
2679    @Override
2680    public String objectEncoding(String key) {
2681      return executeCommand(commandObjects.objectEncoding(key));
2682    }
2683    @Override
2684    public Long objectIdletime(String key) {
2685      return executeCommand(commandObjects.objectIdletime(key));
2686    }
2687    @Override
2688    public Long objectFreq(String key) {
2689      return executeCommand(commandObjects.objectFreq(key));
2690    }
2691    @Override
2692    public Long objectRefcount(byte[] key) {
2693      return executeCommand(commandObjects.objectRefcount(key));
2694    }
2695    @Override
2696    public byte[] objectEncoding(byte[] key) {
2697      return executeCommand(commandObjects.objectEncoding(key));
2698    }
2699    @Override
2700    public Long objectIdletime(byte[] key) {
2701      return executeCommand(commandObjects.objectIdletime(key));
2702    }
2703    @Override
2704    public Long objectFreq(byte[] key) {
2705      return executeCommand(commandObjects.objectFreq(key));
2706    }
2707    @Override
2708    public String migrate(String host, int port, String key, int timeout) {
2709      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2710    }
2711    @Override
2712    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
2713      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2714    }
2715    @Override
2716    public String migrate(String host, int port, byte[] key, int timeout) {
2717      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2718    }
2719    @Override
2720    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
2721      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2722    }
2723    @Override
2724    public long waitReplicas(String sampleKey, int replicas, long timeout) {
2725      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2726    }
2727    @Override
2728    public long waitReplicas(byte[] sampleKey, int replicas, long timeout) {
2729      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2730    }
2731    @Override
2732    public KeyValue&lt;Long, Long&gt; waitAOF(String sampleKey, long numLocal, long numReplicas, long timeout) {
2733      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2734    }
2735    @Override
2736    public KeyValue&lt;Long, Long&gt; waitAOF(byte[] sampleKey, long numLocal, long numReplicas, long timeout) {
2737      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2738    }
2739    @Override
2740    public Object eval(String script, String sampleKey) {
2741      return executeCommand(commandObjects.eval(script, sampleKey));
2742    }
2743    @Override
2744    public Object evalsha(String sha1, String sampleKey) {
2745      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2746    }
2747    @Override
2748    public Object eval(byte[] script, byte[] sampleKey) {
2749      return executeCommand(commandObjects.eval(script, sampleKey));
2750    }
2751    @Override
2752    public Object evalsha(byte[] sha1, byte[] sampleKey) {
2753      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2754    }
2755    public List&lt;Boolean&gt; scriptExists(List&lt;String&gt; sha1s) {
2756      return checkAndBroadcastCommand(commandObjects.scriptExists(sha1s));
2757    }
2758    @Override
2759    public Boolean scriptExists(String sha1, String sampleKey) {
2760      return scriptExists(sampleKey, new String[]{sha1}).get(0);
2761    }
2762    @Override
2763    public List&lt;Boolean&gt; scriptExists(String sampleKey, String... sha1s) {
2764      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2765    }
2766    @Override
2767    public Boolean scriptExists(byte[] sha1, byte[] sampleKey) {
2768      return scriptExists(sampleKey, new byte[][]{sha1}).get(0);
2769    }
2770    @Override
2771    public List&lt;Boolean&gt; scriptExists(byte[] sampleKey, byte[]... sha1s) {
2772      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2773    }
2774    public String scriptLoad(String script) {
2775      return checkAndBroadcastCommand(commandObjects.scriptLoad(script));
2776    }
2777    @Override
2778    public String scriptLoad(String script, String sampleKey) {
2779      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2780    }
2781    public String scriptFlush() {
2782      return checkAndBroadcastCommand(commandObjects.scriptFlush());
2783    }
2784    @Override
2785    public String scriptFlush(String sampleKey) {
2786      return executeCommand(commandObjects.scriptFlush(sampleKey));
2787    }
2788    @Override
2789    public String scriptFlush(String sampleKey, FlushMode flushMode) {
2790      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2791    }
2792    public String scriptKill() {
2793      return checkAndBroadcastCommand(commandObjects.scriptKill());
2794    }
2795    @Override
2796    public String scriptKill(String sampleKey) {
2797      return executeCommand(commandObjects.scriptKill(sampleKey));
2798    }
2799    @Override
2800    public byte[] scriptLoad(byte[] script, byte[] sampleKey) {
2801      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2802    }
2803    @Override
2804    public String scriptFlush(byte[] sampleKey) {
2805      return executeCommand(commandObjects.scriptFlush(sampleKey));
2806    }
2807    @Override
2808    public String scriptFlush(byte[] sampleKey, FlushMode flushMode) {
2809      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2810    }
2811    @Override
2812    public String scriptKill(byte[] sampleKey) {
2813      return executeCommand(commandObjects.scriptKill(sampleKey));
2814    }
2815    public String slowlogReset() {
2816      return checkAndBroadcastCommand(commandObjects.slowlogReset());
2817    }
2818    public long publish(String channel, String message) {
2819      return executeCommand(commandObjects.publish(channel, message));
2820    }
2821    public long publish(byte[] channel, byte[] message) {
2822      return executeCommand(commandObjects.publish(channel, message));
2823    }
2824    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
2825      try (Connection connection = this.provider.getConnection()) {
2826        jedisPubSub.proceed(connection, channels);
2827      }
2828    }
2829    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
2830      try (Connection connection = this.provider.getConnection()) {
2831        jedisPubSub.proceedWithPatterns(connection, patterns);
2832      }
2833    }
2834    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
2835      try (Connection connection = this.provider.getConnection()) {
2836        jedisPubSub.proceed(connection, channels);
2837      }
2838    }
2839    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
2840      try (Connection connection = this.provider.getConnection()) {
2841        jedisPubSub.proceedWithPatterns(connection, patterns);
2842      }
2843    }
2844    @Override
2845    public String ftCreate(String indexName, IndexOptions indexOptions, Schema schema) {
2846      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, indexOptions, schema));
2847    }
2848    @Override
2849    public String ftCreate(String indexName, FTCreateParams createParams, Iterable&lt;SchemaField&gt; schemaFields) {
2850      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, createParams, schemaFields));
2851    }
2852    @Override
2853    public String ftAlter(String indexName, Schema schema) {
2854      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schema));
2855    }
2856    @Override
2857    public String ftAlter(String indexName, Iterable&lt;SchemaField&gt; schemaFields) {
2858      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schemaFields));
2859    }
2860    @Override
2861    public SearchResult ftSearch(String indexName, String query) {
2862      return executeCommand(commandObjects.ftSearch(indexName, query));
2863    }
2864    @Override
2865    public SearchResult ftSearch(String indexName, String query, FTSearchParams params) {
2866      return executeCommand(commandObjects.ftSearch(indexName, query, params));
2867    }
2868    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, String query, FTSearchParams params) {
2869      return new FtSearchIteration(provider, batchSize, indexName, query, params);
2870    }
2871    @Override
2872    public SearchResult ftSearch(String indexName, Query query) {
2873      return executeCommand(commandObjects.ftSearch(indexName, query));
2874    }
2875    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, Query query) {
2876      return new FtSearchIteration(provider, batchSize, indexName, query);
2877    }
2878    @Override
2879    public SearchResult ftSearch(byte[] indexName, Query query) {
2880      return executeCommand(commandObjects.ftSearch(indexName, query));
2881    }
2882    @Override
2883    public String ftExplain(String indexName, Query query) {
2884      return executeCommand(commandObjects.ftExplain(indexName, query));
2885    }
2886    @Override
2887    public List&lt;String&gt; ftExplainCLI(String indexName, Query query) {
2888      return executeCommand(commandObjects.ftExplainCLI(indexName, query));
2889    }
2890    @Override
2891    public AggregationResult ftAggregate(String indexName, AggregationBuilder aggr) {
2892      return executeCommand(commandObjects.ftAggregate(indexName, aggr));
2893    }
2894    @Override
2895    public AggregationResult ftCursorRead(String indexName, long cursorId, int count) {
2896      return executeCommand(commandObjects.ftCursorRead(indexName, cursorId, count));
2897    }
2898    @Override
2899    public String ftCursorDel(String indexName, long cursorId) {
2900      return executeCommand(commandObjects.ftCursorDel(indexName, cursorId));
2901    }
2902    public FtAggregateIteration ftAggregateIteration(String indexName, AggregationBuilder aggr) {
2903      return new FtAggregateIteration(provider, indexName, aggr);
2904    }
2905    @Override
2906    public Map.Entry&lt;AggregationResult, Map&lt;String, Object&gt;&gt; ftProfileAggregate(String indexName,
2907        FTProfileParams profileParams, AggregationBuilder aggr) {
2908      return executeCommand(commandObjects.ftProfileAggregate(indexName, profileParams, aggr));
2909    }
2910    @Override
2911    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2912        FTProfileParams profileParams, Query query) {
2913      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query));
2914    }
2915    @Override
2916    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2917        FTProfileParams profileParams, String query, FTSearchParams searchParams) {
2918      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query, searchParams));
2919    }
2920    @Override
2921    public String ftDropIndex(String indexName) {
2922      return checkAndBroadcastCommand(commandObjects.ftDropIndex(indexName));
2923    }
2924    @Override
2925    public String ftDropIndexDD(String indexName) {
2926      return checkAndBroadcastCommand(commandObjects.ftDropIndexDD(indexName));
2927    }
2928    @Override
2929    public String ftSynUpdate(String indexName, String synonymGroupId, String... terms) {
2930      return executeCommand(commandObjects.ftSynUpdate(indexName, synonymGroupId, terms));
2931    }
2932    @Override
2933    public Map&lt;String, List&lt;String&gt;&gt; ftSynDump(String indexName) {
2934      return executeCommand(commandObjects.ftSynDump(indexName));
2935    }
2936    @Override
2937    public long ftDictAdd(String dictionary, String... terms) {
2938      return executeCommand(commandObjects.ftDictAdd(dictionary, terms));
2939    }
2940    @Override
2941    public long ftDictDel(String dictionary, String... terms) {
2942      return executeCommand(commandObjects.ftDictDel(dictionary, terms));
2943    }
2944    @Override
2945    public Set&lt;String&gt; ftDictDump(String dictionary) {
2946      return executeCommand(commandObjects.ftDictDump(dictionary));
2947    }
2948    @Override
2949    public long ftDictAddBySampleKey(String indexName, String dictionary, String... terms) {
2950      return executeCommand(commandObjects.ftDictAddBySampleKey(indexName, dictionary, terms));
2951    }
2952    @Override
2953    public long ftDictDelBySampleKey(String indexName, String dictionary, String... terms) {
2954      return executeCommand(commandObjects.ftDictDelBySampleKey(indexName, dictionary, terms));
2955    }
2956    @Override
2957    public Set&lt;String&gt; ftDictDumpBySampleKey(String indexName, String dictionary) {
2958      return executeCommand(commandObjects.ftDictDumpBySampleKey(indexName, dictionary));
2959    }
2960    @Override
2961    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query) {
2962      return executeCommand(commandObjects.ftSpellCheck(index, query));
2963    }
2964    @Override
2965    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query, FTSpellCheckParams spellCheckParams) {
2966      return executeCommand(commandObjects.ftSpellCheck(index, query, spellCheckParams));
2967    }
2968    @Override
2969    public Map&lt;String, Object&gt; ftInfo(String indexName) {
2970      return executeCommand(commandObjects.ftInfo(indexName));
2971    }
2972    @Override
2973    public Set&lt;String&gt; ftTagVals(String indexName, String fieldName) {
2974      return executeCommand(commandObjects.ftTagVals(indexName, fieldName));
2975    }
2976    @Override
2977    public String ftAliasAdd(String aliasName, String indexName) {
2978      return checkAndBroadcastCommand(commandObjects.ftAliasAdd(aliasName, indexName));
2979    }
2980    @Override
2981    public String ftAliasUpdate(String aliasName, String indexName) {
2982      return checkAndBroadcastCommand(commandObjects.ftAliasUpdate(aliasName, indexName));
2983    }
2984    @Override
2985    public String ftAliasDel(String aliasName) {
2986      return checkAndBroadcastCommand(commandObjects.ftAliasDel(aliasName));
2987    }
2988    @Override
2989    public Map&lt;String, String&gt; ftConfigGet(String option) {
2990      return executeCommand(commandObjects.ftConfigGet(option));
2991    }
2992    @Override
2993    public Map&lt;String, String&gt; ftConfigGet(String indexName, String option) {
2994      return executeCommand(commandObjects.ftConfigGet(indexName, option));
2995    }
2996    @Override
2997    public String ftConfigSet(String option, String value) {
2998      return executeCommand(commandObjects.ftConfigSet(option, value));
2999    }
3000    @Override
3001    public String ftConfigSet(String indexName, String option, String value) {
3002      return executeCommand(commandObjects.ftConfigSet(indexName, option, value));
3003    }
3004    @Override
3005    public long ftSugAdd(String key, String string, double score) {
3006      return executeCommand(commandObjects.ftSugAdd(key, string, score));
3007    }
3008    @Override
3009    public long ftSugAddIncr(String key, String string, double score) {
3010      return executeCommand(commandObjects.ftSugAddIncr(key, string, score));
3011    }
3012    @Override
3013    public List&lt;String&gt; ftSugGet(String key, String prefix) {
3014      return executeCommand(commandObjects.ftSugGet(key, prefix));
3015    }
3016    @Override
3017    public List&lt;String&gt; ftSugGet(String key, String prefix, boolean fuzzy, int max) {
3018      return executeCommand(commandObjects.ftSugGet(key, prefix, fuzzy, max));
3019    }
3020    @Override
3021    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix) {
3022      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix));
3023    }
3024    @Override
3025    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix, boolean fuzzy, int max) {
3026      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix, fuzzy, max));
3027    }
3028    @Override
3029    public boolean ftSugDel(String key, String string) {
3030      return executeCommand(commandObjects.ftSugDel(key, string));
3031    }
3032    @Override
3033    public long ftSugLen(String key) {
3034      return executeCommand(commandObjects.ftSugLen(key));
3035    }
3036    @Override
3037    public List&lt;String&gt; ftList() {
3038      return executeCommand(commandObjects.ftList());
3039    }
3040    @Override
3041    public String jsonSet(String key, Path2 path, Object object) {
3042      return executeCommand(commandObjects.jsonSet(key, path, object));
3043    }
3044    @Override
3045    public String jsonSetWithEscape(String key, Path2 path, Object object) {
3046      return executeCommand(commandObjects.jsonSetWithEscape(key, path, object));
3047    }
3048    @Override
3049    public String jsonSet(String key, Path path, Object pojo) {
3050      return executeCommand(commandObjects.jsonSet(key, path, pojo));
3051    }
3052    @Override
3053    public String jsonSetWithPlainString(String key, Path path, String string) {
3054      return executeCommand(commandObjects.jsonSetWithPlainString(key, path, string));
3055    }
3056    @Override
3057    public String jsonSet(String key, Path2 path, Object pojo, JsonSetParams params) {
3058      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3059    }
3060    @Override
3061    public String jsonSetWithEscape(String key, Path2 path, Object pojo, JsonSetParams params) {
3062      return executeCommand(commandObjects.jsonSetWithEscape(key, path, pojo, params));
3063    }
3064    @Override
3065    public String jsonSet(String key, Path path, Object pojo, JsonSetParams params) {
3066      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3067    }
3068    @Override
3069    public String jsonMerge(String key, Path2 path, Object object) {
3070      return executeCommand(commandObjects.jsonMerge(key, path, object));
3071    }
3072    @Override
3073    public String jsonMerge(String key, Path path, Object pojo) {
3074      return executeCommand(commandObjects.jsonMerge(key, path, pojo));
3075    }
3076    @Override
3077    public Object jsonGet(String key) {
3078      return executeCommand(commandObjects.jsonGet(key));
3079    }
3080    @Override
3081    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz) {
3082      return executeCommand(commandObjects.jsonGet(key, clazz));
3083    }
3084    @Override
3085    public Object jsonGet(String key, Path2... paths) {
3086      return executeCommand(commandObjects.jsonGet(key, paths));
3087    }
3088    @Override
3089    public Object jsonGet(String key, Path... paths) {
3090      return executeCommand(commandObjects.jsonGet(key, paths));
3091    }
3092    @Override
3093    public String jsonGetAsPlainString(String key, Path path) {
3094      return executeCommand(commandObjects.jsonGetAsPlainString(key, path));
3095    }
3096    @Override
3097    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz, Path... paths) {
3098      return executeCommand(commandObjects.jsonGet(key, clazz, paths));
3099    }
3100    @Override
3101    public List&lt;JSONArray&gt; jsonMGet(Path2 path, String... keys) {
3102      return executeCommand(commandObjects.jsonMGet(path, keys));
3103    }
3104    @Override
3105    public &lt;T&gt; List&lt;T&gt; jsonMGet(Path path, Class&lt;T&gt; clazz, String... keys) {
3106      return executeCommand(commandObjects.jsonMGet(path, clazz, keys));
3107    }
3108    @Override
3109    public long jsonDel(String key) {
3110      return executeCommand(commandObjects.jsonDel(key));
3111    }
3112    @Override
3113    public long jsonDel(String key, Path2 path) {
3114      return executeCommand(commandObjects.jsonDel(key, path));
3115    }
3116    @Override
3117    public long jsonDel(String key, Path path) {
3118      return executeCommand(commandObjects.jsonDel(key, path));
3119    }
3120    @Override
3121    public long jsonClear(String key) {
3122      return executeCommand(commandObjects.jsonClear(key));
3123    }
3124    @Override
3125    public long jsonClear(String key, Path2 path) {
3126      return executeCommand(commandObjects.jsonClear(key, path));
3127    }
3128    @Override
3129    public long jsonClear(String key, Path path) {
3130      return executeCommand(commandObjects.jsonClear(key, path));
3131    }
3132    @Override
3133    public List&lt;Boolean&gt; jsonToggle(String key, Path2 path) {
3134      return executeCommand(commandObjects.jsonToggle(key, path));
3135    }
3136    @Override
3137    public String jsonToggle(String key, Path path) {
3138      return executeCommand(commandObjects.jsonToggle(key, path));
3139    }
3140    @Override
3141    public Class&lt;?&gt; jsonType(String key) {
3142      return executeCommand(commandObjects.jsonType(key));
3143    }
3144    @Override
3145    public List&lt;Class&lt;?&gt;&gt; jsonType(String key, Path2 path) {
3146      return executeCommand(commandObjects.jsonType(key, path));
3147    }
3148    @Override
3149    public Class&lt;?&gt; jsonType(String key, Path path) {
3150      return executeCommand(commandObjects.jsonType(key, path));
3151    }
3152    @Override
3153    public long jsonStrAppend(String key, Object string) {
3154      return executeCommand(commandObjects.jsonStrAppend(key, string));
3155    }
3156    @Override
3157    public List&lt;Long&gt; jsonStrAppend(String key, Path2 path, Object string) {
3158      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3159    }
3160    @Override
3161    public long jsonStrAppend(String key, Path path, Object string) {
3162      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3163    }
3164    @Override
3165    public Long jsonStrLen(String key) {
3166      return executeCommand(commandObjects.jsonStrLen(key));
3167    }
3168    @Override
3169    public List&lt;Long&gt; jsonStrLen(String key, Path2 path) {
3170      return executeCommand(commandObjects.jsonStrLen(key, path));
3171    }
3172    @Override
3173    public Long jsonStrLen(String key, Path path) {
3174      return executeCommand(commandObjects.jsonStrLen(key, path));
3175    }
3176    @Override
3177    public JSONArray jsonNumIncrBy(String key, Path2 path, double value) {
3178      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3179    }
3180    @Override
3181    public double jsonNumIncrBy(String key, Path path, double value) {
3182      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3183    }
3184    @Override
3185    public List&lt;Long&gt; jsonArrAppend(String key, Path2 path, Object... objects) {
3186      return executeCommand(commandObjects.jsonArrAppend(key, path, objects));
3187    }
3188    @Override
3189    public List&lt;Long&gt; jsonArrAppendWithEscape(String key, Path2 path, Object... objects) {
3190      return executeCommand(commandObjects.jsonArrAppendWithEscape(key, path, objects));
3191    }
3192    @Override
3193    public Long jsonArrAppend(String key, Path path, Object... pojos) {
3194      return executeCommand(commandObjects.jsonArrAppend(key, path, pojos));
3195    }
3196    @Override
3197    public List&lt;Long&gt; jsonArrIndex(String key, Path2 path, Object scalar) {
3198      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3199    }
3200    @Override
3201    public List&lt;Long&gt; jsonArrIndexWithEscape(String key, Path2 path, Object scalar) {
3202      return executeCommand(commandObjects.jsonArrIndexWithEscape(key, path, scalar));
3203    }
3204    @Override
3205    public long jsonArrIndex(String key, Path path, Object scalar) {
3206      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3207    }
3208    @Override
3209    public List&lt;Long&gt; jsonArrInsert(String key, Path2 path, int index, Object... objects) {
3210      return executeCommand(commandObjects.jsonArrInsert(key, path, index, objects));
3211    }
3212    @Override
3213    public List&lt;Long&gt; jsonArrInsertWithEscape(String key, Path2 path, int index, Object... objects) {
3214      return executeCommand(commandObjects.jsonArrInsertWithEscape(key, path, index, objects));
3215    }
3216    @Override
3217    public long jsonArrInsert(String key, Path path, int index, Object... pojos) {
3218      return executeCommand(commandObjects.jsonArrInsert(key, path, index, pojos));
3219    }
3220    @Override
3221    public Object jsonArrPop(String key) {
3222      return executeCommand(commandObjects.jsonArrPop(key));
3223    }
3224    @Override
3225    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz) {
3226      return executeCommand(commandObjects.jsonArrPop(key, clazz));
3227    }
3228    @Override
3229    public List&lt;Object&gt; jsonArrPop(String key, Path2 path) {
3230      return executeCommand(commandObjects.jsonArrPop(key, path));
3231    }
3232    @Override
3233    public Object jsonArrPop(String key, Path path) {
3234      return executeCommand(commandObjects.jsonArrPop(key, path));
3235    }
3236    @Override
3237    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path) {
3238      return executeCommand(commandObjects.jsonArrPop(key, clazz, path));
3239    }
3240    @Override
3241    public List&lt;Object&gt; jsonArrPop(String key, Path2 path, int index) {
3242      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3243    }
3244    @Override
3245    public Object jsonArrPop(String key, Path path, int index) {
3246      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3247    }
3248    @Override
3249    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path, int index) {
3250      return executeCommand(commandObjects.jsonArrPop(key, clazz, path, index));
3251    }
3252    @Override
3253    public Long jsonArrLen(String key) {
3254      return executeCommand(commandObjects.jsonArrLen(key));
3255    }
3256    @Override
3257    public List&lt;Long&gt; jsonArrLen(String key, Path2 path) {
3258      return executeCommand(commandObjects.jsonArrLen(key, path));
3259    }
3260    @Override
3261    public Long jsonArrLen(String key, Path path) {
3262      return executeCommand(commandObjects.jsonArrLen(key, path));
3263    }
3264    @Override
3265    public List&lt;Long&gt; jsonArrTrim(String key, Path2 path, int start, int stop) {
3266      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3267    }
3268    @Override
3269    public Long jsonArrTrim(String key, Path path, int start, int stop) {
3270      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3271    }
3272    @Override
3273    public Long jsonObjLen(String key) {
3274      return executeCommand(commandObjects.jsonObjLen(key));
3275    }
3276    @Override
3277    public Long jsonObjLen(String key, Path path) {
3278      return executeCommand(commandObjects.jsonObjLen(key, path));
3279    }
3280    @Override
3281    public List&lt;Long&gt; jsonObjLen(String key, Path2 path) {
3282      return executeCommand(commandObjects.jsonObjLen(key, path));
3283    }
3284    @Override
3285    public List&lt;String&gt; jsonObjKeys(String key) {
3286      return executeCommand(commandObjects.jsonObjKeys(key));
3287    }
3288    @Override
3289    public List&lt;String&gt; jsonObjKeys(String key, Path path) {
3290      return executeCommand(commandObjects.jsonObjKeys(key, path));
3291    }
3292    @Override
3293    public List&lt;List&lt;String&gt;&gt; jsonObjKeys(String key, Path2 path) {
3294      return executeCommand(commandObjects.jsonObjKeys(key, path));
3295    }
3296    @Override
3297    public long jsonDebugMemory(String key) {
3298      return executeCommand(commandObjects.jsonDebugMemory(key));
3299    }
3300    @Override
3301    public long jsonDebugMemory(String key, Path path) {
3302      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3303    }
3304    @Override
3305    public List&lt;Long&gt; jsonDebugMemory(String key, Path2 path) {
3306      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3307    }
3308    @Override
3309    public List&lt;Object&gt; jsonResp(String key) {
3310      return executeCommand(commandObjects.jsonResp(key));
3311    }
3312    @Override
3313    public List&lt;Object&gt; jsonResp(String key, Path path) {
3314      return executeCommand(commandObjects.jsonResp(key, path));
3315    }
3316    @Override
3317    public List&lt;List&lt;Object&gt;&gt; jsonResp(String key, Path2 path) {
3318      return executeCommand(commandObjects.jsonResp(key, path));
3319    }
3320    @Override
3321    public String tsCreate(String key) {
3322      return executeCommand(commandObjects.tsCreate(key));
3323    }
3324    @Override
3325    public String tsCreate(String key, TSCreateParams createParams) {
3326      return executeCommand(commandObjects.tsCreate(key, createParams));
3327    }
3328    @Override
3329    public long tsDel(String key, long fromTimestamp, long toTimestamp) {
3330      return executeCommand(commandObjects.tsDel(key, fromTimestamp, toTimestamp));
3331    }
3332    @Override
3333    public String tsAlter(String key, TSAlterParams alterParams) {
3334      return executeCommand(commandObjects.tsAlter(key, alterParams));
3335    }
3336    @Override
3337    public long tsAdd(String key, double value) {
3338      return executeCommand(commandObjects.tsAdd(key, value));
3339    }
3340    @Override
3341    public long tsAdd(String key, long timestamp, double value) {
3342      return executeCommand(commandObjects.tsAdd(key, timestamp, value));
3343    }
3344    @Override
3345    public long tsAdd(String key, long timestamp, double value, TSCreateParams createParams) {
3346      return executeCommand(commandObjects.tsAdd(key, timestamp, value, createParams));
3347    }
3348    @Override
3349    public List&lt;Long&gt; tsMAdd(Map.Entry&lt;String, TSElement&gt;... entries) {
3350      return executeCommand(commandObjects.tsMAdd(entries));
3351    }
3352    @Override
3353    public long tsIncrBy(String key, double value) {
3354      return executeCommand(commandObjects.tsIncrBy(key, value));
3355    }
3356    @Override
3357    public long tsIncrBy(String key, double value, long timestamp) {
3358      return executeCommand(commandObjects.tsIncrBy(key, value, timestamp));
3359    }
3360    @Override
3361    public long tsDecrBy(String key, double value) {
3362      return executeCommand(commandObjects.tsDecrBy(key, value));
3363    }
3364    @Override
3365    public long tsDecrBy(String key, double value, long timestamp) {
3366      return executeCommand(commandObjects.tsDecrBy(key, value, timestamp));
3367    }
3368    @Override
3369    public List&lt;TSElement&gt; tsRange(String key, long fromTimestamp, long toTimestamp) {
3370      return executeCommand(commandObjects.tsRange(key, fromTimestamp, toTimestamp));
3371    }
3372    @Override
3373    public List&lt;TSElement&gt; tsRange(String key, TSRangeParams rangeParams) {
3374      return executeCommand(commandObjects.tsRange(key, rangeParams));
3375    }
3376    @Override
3377    public List&lt;TSElement&gt; tsRevRange(String key, long fromTimestamp, long toTimestamp) {
3378      return executeCommand(commandObjects.tsRevRange(key, fromTimestamp, toTimestamp));
3379    }
3380    @Override
3381    public List&lt;TSElement&gt; tsRevRange(String key, TSRangeParams rangeParams) {
3382      return executeCommand(commandObjects.tsRevRange(key, rangeParams));
3383    }
3384    @Override
3385    public Map&lt;String, TSMRangeElements&gt; tsMRange(long fromTimestamp, long toTimestamp, String... filters) {
3386      return executeCommand(commandObjects.tsMRange(fromTimestamp, toTimestamp, filters));
3387    }
3388    @Override
3389    public Map&lt;String, TSMRangeElements&gt; tsMRange(TSMRangeParams multiRangeParams) {
3390      return executeCommand(commandObjects.tsMRange(multiRangeParams));
3391    }
3392    @Override
3393    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(long fromTimestamp, long toTimestamp, String... filters) {
3394      return executeCommand(commandObjects.tsMRevRange(fromTimestamp, toTimestamp, filters));
3395    }
3396    @Override
3397    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(TSMRangeParams multiRangeParams) {
3398      return executeCommand(commandObjects.tsMRevRange(multiRangeParams));
3399    }
3400    @Override
3401    public TSElement tsGet(String key) {
3402      return executeCommand(commandObjects.tsGet(key));
3403    }
3404    @Override
3405    public TSElement tsGet(String key, TSGetParams getParams) {
3406      return executeCommand(commandObjects.tsGet(key, getParams));
3407    }
3408    @Override
3409    public Map&lt;String, TSMGetElement&gt; tsMGet(TSMGetParams multiGetParams, String... filters) {
3410      return executeCommand(commandObjects.tsMGet(multiGetParams, filters));
3411    }
3412    @Override
3413    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long timeBucket) {
3414      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, timeBucket));
3415    }
3416    @Override
3417    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long bucketDuration, long alignTimestamp) {
3418      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, bucketDuration, alignTimestamp));
3419    }
3420    @Override
3421    public String tsDeleteRule(String sourceKey, String destKey) {
3422      return executeCommand(commandObjects.tsDeleteRule(sourceKey, destKey));
3423    }
3424    @Override
3425    public List&lt;String&gt; tsQueryIndex(String... filters) {
3426      return executeCommand(commandObjects.tsQueryIndex(filters));
3427    }
3428    @Override
3429    public TSInfo tsInfo(String key) {
3430      return executor.executeCommand(commandObjects.tsInfo(key));
3431    }
3432    @Override
3433    public TSInfo tsInfoDebug(String key) {
3434      return executeCommand(commandObjects.tsInfoDebug(key));
3435    }
3436    @Override
3437    public String bfReserve(String key, double errorRate, long capacity) {
3438      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity));
3439    }
3440    @Override
3441    public String bfReserve(String key, double errorRate, long capacity, BFReserveParams reserveParams) {
3442      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity, reserveParams));
3443    }
3444    @Override
3445    public boolean bfAdd(String key, String item) {
3446      return executeCommand(commandObjects.bfAdd(key, item));
3447    }
3448    @Override
3449    public List&lt;Boolean&gt; bfMAdd(String key, String... items) {
3450      return executeCommand(commandObjects.bfMAdd(key, items));
3451    }
3452    @Override
3453    public List&lt;Boolean&gt; bfInsert(String key, String... items) {
3454      return executeCommand(commandObjects.bfInsert(key, items));
3455    }
3456    @Override
3457    public List&lt;Boolean&gt; bfInsert(String key, BFInsertParams insertParams, String... items) {
3458      return executeCommand(commandObjects.bfInsert(key, insertParams, items));
3459    }
3460    @Override
3461    public boolean bfExists(String key, String item) {
3462      return executeCommand(commandObjects.bfExists(key, item));
3463    }
3464    @Override
3465    public List&lt;Boolean&gt; bfMExists(String key, String... items) {
3466      return executeCommand(commandObjects.bfMExists(key, items));
3467    }
3468    @Override
3469    public Map.Entry&lt;Long, byte[]&gt; bfScanDump(String key, long iterator) {
3470      return executeCommand(commandObjects.bfScanDump(key, iterator));
3471    }
3472    @Override
3473    public String bfLoadChunk(String key, long iterator, byte[] data) {
3474      return executeCommand(commandObjects.bfLoadChunk(key, iterator, data));
3475    }
3476    @Override
3477    public long bfCard(String key) {
3478      return executeCommand(commandObjects.bfCard(key));
3479    }
3480    @Override
3481    public Map&lt;String, Object&gt; bfInfo(String key) {
3482      return executeCommand(commandObjects.bfInfo(key));
3483    }
3484    @Override
3485    public String cfReserve(String key, long capacity) {
3486      return executeCommand(commandObjects.cfReserve(key, capacity));
3487    }
3488    @Override
3489    public String cfReserve(String key, long capacity, CFReserveParams reserveParams) {
3490      return executeCommand(commandObjects.cfReserve(key, capacity, reserveParams));
3491    }
3492    @Override
3493    public boolean cfAdd(String key, String item) {
3494      return executeCommand(commandObjects.cfAdd(key, item));
3495    }
3496    @Override
3497    public boolean cfAddNx(String key, String item) {
3498      return executeCommand(commandObjects.cfAddNx(key, item));
3499    }
3500    @Override
3501    public List&lt;Boolean&gt; cfInsert(String key, String... items) {
3502      return executeCommand(commandObjects.cfInsert(key, items));
3503    }
3504    @Override
3505    public List&lt;Boolean&gt; cfInsert(String key, CFInsertParams insertParams, String... items) {
3506      return executeCommand(commandObjects.cfInsert(key, insertParams, items));
3507    }
3508    @Override
3509    public List&lt;Boolean&gt; cfInsertNx(String key, String... items) {
3510      return executeCommand(commandObjects.cfInsertNx(key, items));
3511    }
3512    @Override
3513    public List&lt;Boolean&gt; cfInsertNx(String key, CFInsertParams insertParams, String... items) {
3514      return executeCommand(commandObjects.cfInsertNx(key, insertParams, items));
3515    }
3516    @Override
3517    public boolean cfExists(String key, String item) {
3518      return executeCommand(commandObjects.cfExists(key, item));
3519    }
3520    @Override
3521    public List&lt;Boolean&gt; cfMExists(String key, String... items) {
3522      return executeCommand(commandObjects.cfMExists(key, items));
3523    }
3524    @Override
3525    public boolean cfDel(String key, String item) {
3526      return executeCommand(commandObjects.cfDel(key, item));
3527    }
3528    @Override
3529    public long cfCount(String key, String item) {
3530      return executeCommand(commandObjects.cfCount(key, item));
3531    }
3532    @Override
3533    public Map.Entry&lt;Long, byte[]&gt; cfScanDump(String key, long iterator) {
3534      return executeCommand(commandObjects.cfScanDump(key, iterator));
3535    }
3536    @Override
3537    public String cfLoadChunk(String key, long iterator, byte[] data) {
3538      return executeCommand(commandObjects.cfLoadChunk(key, iterator, data));
3539    }
3540    @Override
3541    public Map&lt;String, Object&gt; cfInfo(String key) {
3542      return executeCommand(commandObjects.cfInfo(key));
3543    }
3544    @Override
3545    public String cmsInitByDim(String key, long width, long depth) {
3546      return executeCommand(commandObjects.cmsInitByDim(key, width, depth));
3547    }
3548    @Override
3549    public String cmsInitByProb(String key, double error, double probability) {
3550      return executeCommand(commandObjects.cmsInitByProb(key, error, probability));
3551    }
3552    @Override
3553    public List&lt;Long&gt; cmsIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3554      return executeCommand(commandObjects.cmsIncrBy(key, itemIncrements));
3555    }
3556    @Override
3557    public List&lt;Long&gt; cmsQuery(String key, String... items) {
3558      return executeCommand(commandObjects.cmsQuery(key, items));
3559    }
3560    @Override
3561    public String cmsMerge(String destKey, String... keys) {
3562      return executeCommand(commandObjects.cmsMerge(destKey, keys));
3563    }
3564    @Override
3565    public String cmsMerge(String destKey, Map&lt;String, Long&gt; keysAndWeights) {
3566      return executeCommand(commandObjects.cmsMerge(destKey, keysAndWeights));
3567    }
3568    @Override
3569    public Map&lt;String, Object&gt; cmsInfo(String key) {
3570      return executeCommand(commandObjects.cmsInfo(key));
3571    }
3572    @Override
3573    public String topkReserve(String key, long topk) {
3574      return executeCommand(commandObjects.topkReserve(key, topk));
3575    }
3576    @Override
3577    public String topkReserve(String key, long topk, long width, long depth, double decay) {
3578      return executeCommand(commandObjects.topkReserve(key, topk, width, depth, decay));
3579    }
3580    @Override
3581    public List&lt;String&gt; topkAdd(String key, String... items) {
3582      return executeCommand(commandObjects.topkAdd(key, items));
3583    }
3584    @Override
3585    public List&lt;String&gt; topkIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3586      return executeCommand(commandObjects.topkIncrBy(key, itemIncrements));
3587    }
3588    @Override
3589    public List&lt;Boolean&gt; topkQuery(String key, String... items) {
3590      return executeCommand(commandObjects.topkQuery(key, items));
3591    }
3592    @Override
3593    public List&lt;String&gt; topkList(String key) {
3594      return executeCommand(commandObjects.topkList(key));
3595    }
3596    @Override
3597    public Map&lt;String, Object&gt; topkInfo(String key) {
3598      return executeCommand(commandObjects.topkInfo(key));
3599    }
3600    @Override
3601    public String tdigestCreate(String key) {
3602      return executeCommand(commandObjects.tdigestCreate(key));
3603    }
3604    @Override
3605    public String tdigestCreate(String key, int compression) {
3606      return executeCommand(commandObjects.tdigestCreate(key, compression));
3607    }
3608    @Override
3609    public String tdigestReset(String key) {
3610      return executeCommand(commandObjects.tdigestReset(key));
3611    }
3612    @Override
3613    public String tdigestMerge(String destinationKey, String... sourceKeys) {
3614      return executeCommand(commandObjects.tdigestMerge(destinationKey, sourceKeys));
3615    }
3616    @Override
3617    public String tdigestMerge(TDigestMergeParams mergeParams, String destinationKey, String... sourceKeys) {
3618      return executeCommand(commandObjects.tdigestMerge(mergeParams, destinationKey, sourceKeys));
3619    }
3620    @Override
3621    public Map&lt;String, Object&gt; tdigestInfo(String key) {
3622      return executeCommand(commandObjects.tdigestInfo(key));
3623    }
3624    @Override
3625    public String tdigestAdd(String key, double... values) {
3626      return executeCommand(commandObjects.tdigestAdd(key, values));
3627    }
3628    @Override
3629    public List&lt;Double&gt; tdigestCDF(String key, double... values) {
3630      return executeCommand(commandObjects.tdigestCDF(key, values));
3631    }
3632    @Override
3633    public List&lt;Double&gt; tdigestQuantile(String key, double... quantiles) {
3634      return executeCommand(commandObjects.tdigestQuantile(key, quantiles));
3635    }
3636    @Override
3637    public double tdigestMin(String key) {
3638      return executeCommand(commandObjects.tdigestMin(key));
3639    }
3640    @Override
3641    public double tdigestMax(String key) {
3642      return executeCommand(commandObjects.tdigestMax(key));
3643    }
3644    @Override
3645    public double tdigestTrimmedMean(String key, double lowCutQuantile, double highCutQuantile) {
3646      return executeCommand(commandObjects.tdigestTrimmedMean(key, lowCutQuantile, highCutQuantile));
3647    }
3648    @Override
3649    public List&lt;Long&gt; tdigestRank(String key, double... values) {
3650      return executeCommand(commandObjects.tdigestRank(key, values));
3651    }
3652    @Override
3653    public List&lt;Long&gt; tdigestRevRank(String key, double... values) {
3654      return executeCommand(commandObjects.tdigestRevRank(key, values));
3655    }
3656    @Override
3657    public List&lt;Double&gt; tdigestByRank(String key, long... ranks) {
3658      return executeCommand(commandObjects.tdigestByRank(key, ranks));
3659    }
3660    @Override
3661    public List&lt;Double&gt; tdigestByRevRank(String key, long... ranks) {
3662      return executeCommand(commandObjects.tdigestByRevRank(key, ranks));
3663    }
3664    @Override
3665    public ResultSet graphQuery(String name, String query) {
3666      return executeCommand(graphCommandObjects.graphQuery(name, query));
3667    }
3668    @Override
3669    public ResultSet graphReadonlyQuery(String name, String query) {
3670      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query));
3671    }
3672    @Override
3673    public ResultSet graphQuery(String name, String query, long timeout) {
3674      return executeCommand(graphCommandObjects.graphQuery(name, query, timeout));
3675    }
3676    @Override
3677    public ResultSet graphReadonlyQuery(String name, String query, long timeout) {
3678      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, timeout));
3679    }
3680    @Override
3681    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params) {
3682      return executeCommand(graphCommandObjects.graphQuery(name, query, params));
3683    }
3684    @Override
3685    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params) {
3686      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params));
3687    }
3688    @Override
3689    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3690      return executeCommand(graphCommandObjects.graphQuery(name, query, params, timeout));
3691    }
3692    @Override
3693    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3694      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params, timeout));
3695    }
3696    @Override
3697    public String graphDelete(String name) {
3698      return executeCommand(graphCommandObjects.graphDelete(name));
3699    }
3700    @Override
3701    public List&lt;String&gt; graphList() {
3702      return executeCommand(commandObjects.graphList());
3703    }
3704    @Override
3705    public List&lt;String&gt; graphProfile(String graphName, String query) {
3706      return executeCommand(commandObjects.graphProfile(graphName, query));
3707    }
3708    @Override
3709    public List&lt;String&gt; graphExplain(String graphName, String query) {
3710      return executeCommand(commandObjects.graphExplain(graphName, query));
3711    }
3712    @Override
3713    public List&lt;List&lt;Object&gt;&gt; graphSlowlog(String graphName) {
3714      return executeCommand(commandObjects.graphSlowlog(graphName));
3715    }
3716    @Override
3717    public String graphConfigSet(String configName, Object value) {
3718      return executeCommand(commandObjects.graphConfigSet(configName, value));
3719    }
3720    @Override
3721    public Map&lt;String, Object&gt; graphConfigGet(String configName) {
3722      return executeCommand(commandObjects.graphConfigGet(configName));
3723    }
3724    public PipelineBase pipelined() {
3725      if (provider == null) {
3726        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3727      }
3728      return new Pipeline(provider.getConnection(), true);
3729    }
3730    public Transaction multi() {
3731      if (provider == null) {
3732        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3733      }
3734      return new Transaction(provider.getConnection(), true, true);
3735    }
3736    public Object sendCommand(ProtocolCommand cmd) {
3737      return executeCommand(commandObjects.commandArguments(cmd));
3738    }
3739    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
3740      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3741    }
3742    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
3743      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3744    }
3745    public Object sendCommand(ProtocolCommand cmd, String... args) {
3746      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3747    }
3748    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
3749      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3750    }
3751    public Object sendCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3752      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3753    }
3754    public Object sendBlockingCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3755      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3756    }
3757    public Object sendCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3758      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3759    }
3760    public Object sendBlockingCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3761      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3762    }
3763    public Object executeCommand(CommandArguments args) {
3764      return executeCommand(new CommandObject&lt;&gt;(args, BuilderFactory.RAW_OBJECT));
3765    }
3766    public void setJsonObjectMapper(JsonObjectMapper jsonObjectMapper) {
3767      this.commandObjects.setJsonObjectMapper(jsonObjectMapper);
3768    }
3769    public void setDefaultSearchDialect(int dialect) {
3770      this.commandObjects.setDefaultSearchDialect(dialect);
3771    }
3772  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</div>
                </div>
                <div class="column column_space"><pre><code>2818    public long publish(String channel, String message) {
2819      return executeCommand(commandObjects.publish(channel, message));
2820    }
2821    public long publish(byte[] channel, byte[] message) {
</pre></code></div>
                <div class="column column_space"><pre><code>384    public long sort(String key, String dstkey) {
385      return executeCommand(commandObjects.sort(key, dstkey));
386    }
387    @Override
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    