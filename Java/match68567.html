<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for FunctionsTest.java & MapMakerInternalMapTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for FunctionsTest.java & MapMakerInternalMapTest.java
      </h3>
      <h1 align="center">
        31.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>FunctionsTest.java (48.16587%)<TH>MapMakerInternalMapTest.java (23.124043%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#0',2,'match68567-1.html#0',3)" NAME="0">(194-206)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#0',2,'match68567-1.html#0',3)" NAME="0">(494-506)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#1',2,'match68567-1.html#1',3)" NAME="1">(119-127)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#1',2,'match68567-1.html#1',3)" NAME="1">(293-310)</A><TD ALIGN=center><FONT COLOR="#f20000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#2',2,'match68567-1.html#2',3)" NAME="2">(309-322)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#2',2,'match68567-1.html#2',3)" NAME="2">(343-355)</A><TD ALIGN=center><FONT COLOR="#e50000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#3',2,'match68567-1.html#3',3)" NAME="3">(286-299)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#3',2,'match68567-1.html#3',3)" NAME="3">(810-827)</A><TD ALIGN=center><FONT COLOR="#e50000">18</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#4',2,'match68567-1.html#4',3)" NAME="4">(139-146)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#4',2,'match68567-1.html#4',3)" NAME="4">(366-385)</A><TD ALIGN=center><FONT COLOR="#d80000">17</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#5',2,'match68567-1.html#5',3)" NAME="5">(53-61)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#5',2,'match68567-1.html#5',3)" NAME="5">(108-122)</A><TD ALIGN=center><FONT COLOR="#bf0000">15</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#6',2,'match68567-1.html#6',3)" NAME="6">(231-244)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#6',2,'match68567-1.html#6',3)" NAME="6">(604-612)</A><TD ALIGN=center><FONT COLOR="#b20000">14</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#7',2,'match68567-1.html#7',3)" NAME="7">(88-96)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#7',2,'match68567-1.html#7',3)" NAME="7">(272-279)</A><TD ALIGN=center><FONT COLOR="#b20000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#8',2,'match68567-1.html#8',3)" NAME="8">(395-401)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#8',2,'match68567-1.html#8',3)" NAME="8">(316-325)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#9',2,'match68567-1.html#9',3)" NAME="9">(246-255)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#9',2,'match68567-1.html#9',3)" NAME="9">(453-464)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#10',2,'match68567-1.html#10',3)" NAME="10">(19-37)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#10',2,'match68567-1.html#10',3)" NAME="10">(20-34)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#11',2,'match68567-1.html#11',3)" NAME="11">(343-349)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#11',2,'match68567-1.html#11',3)" NAME="11">(671-679)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#12',2,'match68567-1.html#12',3)" NAME="12">(128-138)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#12',2,'match68567-1.html#12',3)" NAME="12">(689-696)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#13',2,'match68567-1.html#13',3)" NAME="13">(41-48)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#13',2,'match68567-1.html#13',3)" NAME="13">(192-199)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#14',2,'match68567-1.html#14',3)" NAME="14">(337-342)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#14',2,'match68567-1.html#14',3)" NAME="14">(432-438)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#15',2,'match68567-1.html#15',3)" NAME="15">(323-328)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#15',2,'match68567-1.html#15',3)" NAME="15">(54-59)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#16',2,'match68567-1.html#16',3)" NAME="16">(176-183)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#16',2,'match68567-1.html#16',3)" NAME="16">(238-246)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#17',2,'match68567-1.html#17',3)" NAME="17">(161-168)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#17',2,'match68567-1.html#17',3)" NAME="17">(223-230)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#18',2,'match68567-1.html#18',3)" NAME="18">(112-118)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#18',2,'match68567-1.html#18',3)" NAME="18">(393-399)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#19',2,'match68567-1.html#19',3)" NAME="19">(184-192)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#19',2,'match68567-1.html#19',3)" NAME="19">(466-471)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#20',2,'match68567-1.html#20',3)" NAME="20">(448-451)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#20',2,'match68567-1.html#20',3)" NAME="20">(167-176)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#21',2,'match68567-1.html#21',3)" NAME="21">(349-356)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#21',2,'match68567-1.html#21',3)" NAME="21">(478-488)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match68567-0.html#22',2,'match68567-1.html#22',3)" NAME="22">(258-267)<TD><A HREF="javascript:ZweiFrames('match68567-0.html#22',2,'match68567-1.html#22',3)" NAME="22">(555-561)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FunctionsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2005 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="10"></A>
package com.google.common.base;

<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match68567-1.html#10',3,'match68567-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.testing.ClassSanityTester;
import com.google.common.testing.EqualsTester;
import com.google.common.testing.NullPointerTester;
import com.google.common.testing.SerializableTester;
import java.io.Serializable;
import java.util.Map;
import junit.framework.TestCase;

/**
 * Tests for {@link Functions}.
 *
 * @author Mike Bostock
 * @author Vlad Patryshev
 */
@</B></FONT>GwtCompatible(emulated = true)
<A NAME="13"></A>public class FunctionsTest extends TestCase {

  public void testIdentity_same() {
    Function&lt;String, String&gt; identity = <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match68567-1.html#13',3,'match68567-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Functions.identity();
    assertNull(identity.apply(null));
    assertSame(&quot;foo&quot;, identity.apply(&quot;foo&quot;));
  }

  public void testIdentity_notSame() {
    Function&lt;Long, Long&gt; identity = Functions.identity();
    assertNotSame</B></FONT>(new Long(135135L), identity.apply(new Long(135135L)));
  }
<A NAME="5"></A>
  @GwtIncompatible // SerializableTester
  public void testIdentitySerializable() {
    <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match68567-1.html#5',3,'match68567-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkCanReserializeSingleton(Functions.identity());
  }

  public void testToStringFunction_apply() {
    assertEquals(&quot;3&quot;, Functions.toStringFunction().apply(3));
    assertEquals(&quot;hiya&quot;, Functions.toStringFunction().apply(&quot;hiya&quot;));
    assertEquals(
        &quot;I'm a string&quot;,
        Functions.toStringFunction</B></FONT>()
            .apply(
                new Object() {
                  @Override
                  public String toString() {
                    return &quot;I'm a string&quot;;
                  }
                }));
    try {
      Functions.toStringFunction().apply(null);
      fail(&quot;expected NullPointerException&quot;);
    } catch (NullPointerException expected) {
    }
  }

  @GwtIncompatible // SerializableTester
  public void testToStringFunctionSerializable() {
    checkCanReserializeSingleton(Functions.toStringFunction());
  }

  @GwtIncompatible // NullPointerTester
  public void testNullPointerExceptions() {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(Functions.class);
<A NAME="7"></A>  }

  public void testForMapWithoutDefault() {
    Map&lt;String, Integer&gt; map = <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match68567-1.html#7',3,'match68567-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Maps.newHashMap();
    map.put(&quot;One&quot;, 1);
    map.put(&quot;Three&quot;, 3);
    map.put(&quot;Null&quot;, null);
    Function&lt;String, Integer&gt; function = Functions.forMap(map);

    assertEquals(1, function.apply(&quot;One&quot;).intValue());
    assertEquals(3, function.apply(&quot;Three&quot;).intValue());
    assertNull(function.apply</B></FONT>(&quot;Null&quot;));

    try {
      function.apply(&quot;Two&quot;);
      fail();
    } catch (IllegalArgumentException expected) {
    }

    new EqualsTester()
        .addEqualityGroup(function, Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, 42))
        .testEquals();
  }
<A NAME="18"></A>
  @GwtIncompatible // SerializableTester
  public void testForMapWithoutDefaultSerializable() {
    <FONT color="#800517"><A HREF="javascript:ZweiFrames('match68567-1.html#18',3,'match68567-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkCanReserialize(Functions.forMap(ImmutableMap.of(1, 2)));
  }

  public void testForMapWithDefault() {
<A NAME="1"></A>    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put(&quot;One&quot;, 1);
    map.put</B></FONT>(&quot;Three&quot;, 3);
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match68567-1.html#1',3,'match68567-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>map.put(&quot;Null&quot;, null);
    Function&lt;String, Integer&gt; function = Functions.forMap(map, 42);

    assertEquals(1, function.apply(&quot;One&quot;).intValue());
    assertEquals(42, function.apply(&quot;Two&quot;).intValue());
    assertEquals(3, function.apply(&quot;Three&quot;).intValue());
<A NAME="12"></A>    assertNull(function.apply(&quot;Null&quot;));

    new EqualsTester()</B></FONT>
        .addEqualityGroup(function, <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match68567-1.html#12',3,'match68567-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Functions.forMap(map, 42))
        .addEqualityGroup(Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, null))
        .addEqualityGroup(Functions.forMap(map, 43))
        .testEquals();
  }

  @GwtIncompatible // SerializableTester
<A NAME="4"></A>  public void testForMapWithDefault_includeSerializable() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put</B></FONT>(&quot;One&quot;, 1);
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match68567-1.html#4',3,'match68567-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>map.put(&quot;Three&quot;, 3);
    Function&lt;String, Integer&gt; function = Functions.forMap(map, 42);

    assertEquals(1, function.apply(&quot;One&quot;).intValue());
    assertEquals(42, function.apply(&quot;Two&quot;).intValue());
    assertEquals(3, function.apply(&quot;Three&quot;).intValue());

    new EqualsTester()</B></FONT>
        .addEqualityGroup(
            function, Functions.forMap(map, 42), SerializableTester.reserialize(function))
        .addEqualityGroup(Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, null))
        .addEqualityGroup(Functions.forMap(map, 43))
        .testEquals();
  }

  @GwtIncompatible // SerializableTester
  public void testForMapWithDefaultSerializable() {
    checkCanReserialize(Functions.forMap(ImmutableMap.of(1, 2), 3));
<A NAME="17"></A>  }

  public void testForMapWithDefault_null() {
    <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match68567-1.html#17',3,'match68567-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableMap&lt;String, Integer&gt; map = ImmutableMap.of(&quot;One&quot;, 1);
    Function&lt;String, Integer&gt; function = Functions.forMap(map, null);

    assertEquals((Integer) 1, function.apply(&quot;One&quot;));
    assertNull(function.apply(&quot;Two&quot;));

    // check basic sanity of equals and hashCode
    new EqualsTester()</B></FONT>
        .addEqualityGroup(function)
        .addEqualityGroup(Functions.forMap(map, 1))
        .testEquals();
  }
<A NAME="16"></A>
  @GwtIncompatible // SerializableTester
  public void testForMapWithDefault_null_compareWithSerializable() {
    <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match68567-1.html#16',3,'match68567-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableMap&lt;String, Integer&gt; map = ImmutableMap.of(&quot;One&quot;, 1);
    Function&lt;String, Integer&gt; function = Functions.forMap(map, null);

    assertEquals((Integer) 1, function.apply(&quot;One&quot;));
    assertNull(function.apply(&quot;Two&quot;));
<A NAME="19"></A>
    // check basic sanity of equals and hashCode
    new EqualsTester()</B></FONT>
        .addEqualityGroup(function, <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match68567-1.html#19',3,'match68567-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SerializableTester.reserialize(function))
        .addEqualityGroup(Functions.forMap(map, 1))
        .testEquals();
  }

  public void testForMapWildCardWithDefault() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
<A NAME="0"></A>    map.put(&quot;One&quot;, 1);
    map.put</B></FONT>(&quot;Three&quot;, 3);
    Number number = Double.valueOf(42);
    Function&lt;String, Number&gt; function = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match68567-1.html#0',3,'match68567-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Functions.forMap(map, number);

    assertEquals(1, function.apply(&quot;One&quot;).intValue());
    assertEquals(number, function.apply(&quot;Two&quot;));
    assertEquals(3L, function.apply(&quot;Three&quot;).longValue());
  }

  public void testComposition() {
    Map&lt;String, Integer&gt; mJapaneseToInteger = Maps.newHashMap();
    mJapaneseToInteger.put(&quot;Ichi&quot;, 1);
    mJapaneseToInteger.put(&quot;Ni&quot;, 2);
    mJapaneseToInteger.put(&quot;San&quot;, 3);
    Function&lt;String, Integer&gt; japaneseToInteger = Functions.forMap</B></FONT>(mJapaneseToInteger);

    Map&lt;Integer, String&gt; mIntegerToSpanish = Maps.newHashMap();
    mIntegerToSpanish.put(1, &quot;Uno&quot;);
    mIntegerToSpanish.put(3, &quot;Tres&quot;);
    mIntegerToSpanish.put(4, &quot;Cuatro&quot;);
    Function&lt;Integer, String&gt; integerToSpanish = Functions.forMap(mIntegerToSpanish);

    Function&lt;String, String&gt; japaneseToSpanish =
        Functions.compose(integerToSpanish, japaneseToInteger);

    assertEquals(&quot;Uno&quot;, japaneseToSpanish.apply(&quot;Ichi&quot;));
    try {
      japaneseToSpanish.apply(&quot;Ni&quot;);
      fail();
    } catch (IllegalArgumentException e) {
    }
    assertEquals(&quot;Tres&quot;, japaneseToSpanish.apply(&quot;San&quot;));
    try {
      japaneseToSpanish.apply(&quot;Shi&quot;);
      fail();
    } catch (IllegalArgumentException e) {
<A NAME="6"></A>    }

    new EqualsTester()
        .addEqualityGroup(japaneseToSpanish, <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match68567-1.html#6',3,'match68567-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Functions.compose(integerToSpanish, japaneseToInteger))
        .addEqualityGroup(japaneseToInteger)
        .addEqualityGroup(integerToSpanish)
        .addEqualityGroup(Functions.compose(japaneseToInteger, integerToSpanish))
        .testEquals();
  }

  @GwtIncompatible // SerializableTester
  public void testComposition_includeReserializabled() {
    Map&lt;String, Integer&gt; mJapaneseToInteger = Maps.newHashMap();
    mJapaneseToInteger.put(&quot;Ichi&quot;, 1);
    mJapaneseToInteger.put(&quot;Ni&quot;, 2);
<A NAME="9"></A>    mJapaneseToInteger.put(&quot;San&quot;, 3);
    Function&lt;String, Integer&gt; japaneseToInteger = Functions.forMap</B></FONT>(mJapaneseToInteger);

    Map&lt;Integer, String&gt; mIntegerToSpanish = <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match68567-1.html#9',3,'match68567-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Maps.newHashMap();
    mIntegerToSpanish.put(1, &quot;Uno&quot;);
    mIntegerToSpanish.put(3, &quot;Tres&quot;);
    mIntegerToSpanish.put(4, &quot;Cuatro&quot;);
    Function&lt;Integer, String&gt; integerToSpanish = Functions.forMap(mIntegerToSpanish);

    Function&lt;String, String&gt; japaneseToSpanish =
        Functions.compose(integerToSpanish, japaneseToInteger);

<A NAME="22"></A>    new EqualsTester()</B></FONT>
        .addEqualityGroup(
            japaneseToSpanish,
            <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match68567-1.html#22',3,'match68567-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Functions.compose(integerToSpanish, japaneseToInteger),
            SerializableTester.reserialize(japaneseToSpanish))
        .addEqualityGroup(japaneseToInteger)
        .addEqualityGroup(integerToSpanish)
        .addEqualityGroup(Functions.compose(japaneseToInteger, integerToSpanish))
        .testEquals();
  }

  public void testCompositionWildcard() {
    Map&lt;String, Integer&gt; mapJapaneseToInteger = Maps.newHashMap</B></FONT>();
    Function&lt;String, Integer&gt; japaneseToInteger = Functions.forMap(mapJapaneseToInteger);

    Function&lt;Object, String&gt; numberToSpanish = Functions.constant(&quot;Yo no se&quot;);

    Function&lt;String, String&gt; japaneseToSpanish =
        Functions.compose(numberToSpanish, japaneseToInteger);
  }

  private static class HashCodeFunction implements Function&lt;Object, Integer&gt; {
    @Override
    public Integer apply(Object o) {
      return (o == null) ? 0 : o.hashCode();
    }
  }

<A NAME="3"></A>  public void testComposeOfFunctionsIsAssociative() {
    Map&lt;Float, String&gt; m = ImmutableMap.of(4.0f, &quot;A&quot;, 3.0f, &quot;B&quot;, 2.0f, &quot;C&quot;, 1.0f, &quot;D&quot;);
    Function&lt;? super Integer, Boolean&gt; h = Functions.constant(Boolean.TRUE);
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match68567-1.html#3',3,'match68567-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Function&lt;? super String, Integer&gt; g = new HashCodeFunction();
    Function&lt;Float, String&gt; f = Functions.forMap(m, &quot;F&quot;);

    Function&lt;Float, Boolean&gt; c1 = Functions.compose(Functions.compose(h, g), f);
    Function&lt;Float, Boolean&gt; c2 = Functions.compose(h, Functions.compose(g, f));

    // Might be nice (eventually) to have:
    //     assertEquals(c1, c2);

    // But for now, settle for this:
    assertEquals(c1.hashCode(), c2.hashCode());

    assertEquals(c1.apply(1.0f), c2.apply(1.0f));
    assertEquals(c1.apply</B></FONT>(5.0f), c2.apply(5.0f));
  }

  public void testComposeOfPredicateAndFunctionIsAssociative() {
    Map&lt;Float, String&gt; m = ImmutableMap.of(4.0f, &quot;A&quot;, 3.0f, &quot;B&quot;, 2.0f, &quot;C&quot;, 1.0f, &quot;D&quot;);
    Predicate&lt;? super Integer&gt; h = Predicates.equalTo(42);
    Function&lt;? super String, Integer&gt; g = new HashCodeFunction();
<A NAME="2"></A>    Function&lt;Float, String&gt; f = Functions.forMap(m, &quot;F&quot;);

    Predicate&lt;Float&gt; p1 = Predicates.compose(Predicates.compose(h, g), f);
    Predicate&lt;Float&gt; p2 = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match68567-1.html#2',3,'match68567-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Predicates.compose(h, Functions.compose(g, f));

    // Might be nice (eventually) to have:
    //     assertEquals(p1, p2);

    // But for now, settle for this:
    assertEquals(p1.hashCode(), p2.hashCode());

    assertEquals(p1.apply(1.0f), p2.apply(1.0f));
    assertEquals(p1.apply(5.0f), p2.apply(5.0f));
  }
<A NAME="15"></A>
  public void testForPredicate() {
    Function&lt;Object, Boolean&gt; alwaysTrue = Functions.forPredicate(Predicates.alwaysTrue</B></FONT>());
    <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match68567-1.html#15',3,'match68567-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Function&lt;Object, Boolean&gt; alwaysFalse = Functions.forPredicate(Predicates.alwaysFalse());

    assertTrue(alwaysTrue.apply(0));
    assertFalse(alwaysFalse.apply(0));

    new EqualsTester()</B></FONT>
        .addEqualityGroup(alwaysTrue, Functions.forPredicate(Predicates.alwaysTrue()))
        .addEqualityGroup(alwaysFalse)
        .addEqualityGroup(Functions.identity())
        .testEquals();
  }
<A NAME="14"></A>
  @GwtIncompatible // SerializableTester
  public void testForPredicateSerializable() {
    <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match68567-1.html#14',3,'match68567-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkCanReserialize(Functions.forPredicate(Predicates.equalTo(5)));
  }

<A NAME="11"></A>  public void testConstant() {
    Function&lt;Object, Object&gt; f = Functions.&lt;Object&gt;constant(&quot;correct&quot;);
    assertEquals(&quot;correct&quot;, f.apply</B></FONT>(new Object()));
    <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match68567-1.html#11',3,'match68567-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(&quot;correct&quot;, f.apply(null));

    Function&lt;Object, String&gt; g = Functions.constant(null);
<A NAME="21"></A>    assertEquals(null, g.apply(2));
    assertEquals(null, g.apply(null));

    <FONT color="#947010"><A HREF="javascript:ZweiFrames('match68567-1.html#21',3,'match68567-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new EqualsTester()</B></FONT>
        .addEqualityGroup(f, Functions.constant(&quot;correct&quot;))
        .addEqualityGroup(Functions.constant(&quot;incorrect&quot;))
        .addEqualityGroup(Functions.toStringFunction())
        .addEqualityGroup(g)
        .testEquals();

    new EqualsTester()</B></FONT>
        .addEqualityGroup(g, Functions.constant(null))
        .addEqualityGroup(Functions.constant(&quot;incorrect&quot;))
        .addEqualityGroup(Functions.toStringFunction())
        .addEqualityGroup(f)
        .testEquals();
  }

  @GwtIncompatible // SerializableTester
  public void testConstantSerializable() {
    checkCanReserialize(Functions.constant(5));
  }

  private static class CountingSupplier implements Supplier&lt;Integer&gt;, Serializable {

    private static final long serialVersionUID = 0;

    private int value;

    @Override
    public Integer get() {
      return ++value;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj instanceof CountingSupplier) {
        return this.value == ((CountingSupplier) obj).value;
      }
      return false;
    }

    @Override
    public int hashCode() {
      return value;
    }
<A NAME="8"></A>  }

  public void testForSupplier() {
    <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match68567-1.html#8',3,'match68567-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Supplier&lt;Integer&gt; supplier = new CountingSupplier();
    Function&lt;Object, Integer&gt; function = Functions.forSupplier(supplier);

    assertEquals(1, (int) function.apply(null));
    assertEquals(2, (int) function.apply(&quot;foo&quot;));

    new EqualsTester()</B></FONT>
        .addEqualityGroup(function, Functions.forSupplier(supplier))
        .addEqualityGroup(Functions.forSupplier(new CountingSupplier()))
        .addEqualityGroup(Functions.forSupplier(Suppliers.ofInstance(12)))
        .addEqualityGroup(Functions.toStringFunction())
        .testEquals();
  }

  @GwtIncompatible // SerializableTester
  public void testForSupplierSerializable() {
    checkCanReserialize(Functions.forSupplier(new CountingSupplier()));
  }

  @GwtIncompatible // reflection
  public void testNulls() throws Exception {
    new ClassSanityTester().forAllPublicStaticMethods(Functions.class).testNulls();
  }

  @GwtIncompatible // reflection
  @AndroidIncompatible // TODO(cpovirk): ClassNotFoundException: com.google.common.base.Function
  // (I suspect that this and the other similar failures happen with ArbitraryInstances proxies.)
  public void testEqualsAndSerializable() throws Exception {
    new ClassSanityTester().forAllPublicStaticMethods(Functions.class).testEqualsAndSerializable();
  }

  @GwtIncompatible // SerializableTester
  private static &lt;Y&gt; void checkCanReserialize(Function&lt;? super Integer, Y&gt; f) {
    Function&lt;? super Integer, Y&gt; g = SerializableTester.reserializeAndAssert(f);
    for (int i = 1; i &lt; 5; i++) {
      // convoluted way to check that the same result happens from each
      Y expected = null;
      try {
        expected = f.apply(i);
      } catch (IllegalArgumentException e) {
        try {
          g.apply(i);
          fail();
        } catch (IllegalArgumentException ok) {
          continue;
        }
      }
      assertEquals(expected, g.apply(i));
    }
  }
<A NAME="20"></A>
  @GwtIncompatible // SerializableTester
  private static &lt;Y&gt; void checkCanReserializeSingleton(Function&lt;? super String, Y&gt; f) {
    Function&lt;? super String, Y&gt; g = <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match68567-1.html#20',3,'match68567-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SerializableTester.reserializeAndAssert(f);
    assertSame(f, g);
    for (Integer i = 1; i &lt; 5; i++) {
      assertEquals(f.apply(i.toString()), g.apply</B></FONT>(i.toString()));
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapMakerInternalMapTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

<A NAME="10"></A>package com.google.common.collect;

import static com.google.common.collect.MapMakerInternalMap.DRAIN_THRESHOLD;
<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#10',2,'match68567-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.truth.Truth.assertThat;

import com.google.common.base.Equivalence;
import com.google.common.collect.MapMakerInternalMap.InternalEntry;
import com.google.common.collect.MapMakerInternalMap.Segment;
import com.google.common.collect.MapMakerInternalMap.Strength;
import com.google.common.collect.MapMakerInternalMap.WeakValueEntry;
import com.google.common.collect.MapMakerInternalMap.WeakValueReference;
import com.google.common.testing.NullPointerTester;
import java.lang.ref.Reference;
import java.util.concurrent.atomic.AtomicReferenceArray;
import junit.framework.TestCase;

/** @author Charles Fry */
@</B></FONT>SuppressWarnings(&quot;deprecation&quot;) // many tests of deprecated methods
public class MapMakerInternalMapTest extends TestCase {

  static final int SMALL_MAX_SIZE = DRAIN_THRESHOLD * 5;

  private static &lt;K, V&gt;
      MapMakerInternalMap&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;, ? extends Segment&lt;K, V, ?, ?&gt;&gt;
          makeMap(MapMaker maker) {
    return MapMakerInternalMap.create(maker);
  }

  private static MapMaker createMapMaker() {
    MapMaker maker = new MapMaker();
    maker.useCustomMap = true;
    return maker;
  }

<A NAME="15"></A>  // constructor tests

  public void testDefaults() {
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#15',2,'match68567-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(createMapMaker());

    assertSame(Strength.STRONG, map.keyStrength());
    assertSame(Strength.STRONG, map.valueStrength());
    assertSame(map.keyStrength().defaultEquivalence(), map.keyEquivalence);
    assertSame</B></FONT>(map.valueStrength().defaultEquivalence(), map.valueEquivalence());

    assertThat(map.entryHelper)
        .isInstanceOf(MapMakerInternalMap.StrongKeyStrongValueEntry.Helper.class);

    assertEquals(4, map.concurrencyLevel);

    // concurrency level
    assertThat(map.segments).hasLength(4);
    // initial capacity / concurrency level
    assertEquals(16 / map.segments.length, map.segments[0].table.length());
  }

  public void testSetKeyEquivalence() {
    Equivalence&lt;Object&gt; testEquivalence =
        new Equivalence&lt;Object&gt;() {
          @Override
          protected boolean doEquivalent(Object a, Object b) {
            return false;
          }

          @Override
          protected int doHash(Object t) {
            return 0;
          }
        };

    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().keyEquivalence(testEquivalence));
    assertSame(testEquivalence, map.keyEquivalence);
    assertSame(map.valueStrength().defaultEquivalence(), map.valueEquivalence());
  }

  public void testSetConcurrencyLevel() {
    // round up to nearest power of two

    checkConcurrencyLevel(1, 1);
    checkConcurrencyLevel(2, 2);
    checkConcurrencyLevel(3, 4);
    checkConcurrencyLevel(4, 4);
    checkConcurrencyLevel(5, 8);
    checkConcurrencyLevel(6, 8);
    checkConcurrencyLevel(7, 8);
    checkConcurrencyLevel(8, 8);
  }

<A NAME="5"></A>  private static void checkConcurrencyLevel(int concurrencyLevel, int segmentCount) {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(concurrencyLevel));
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#5',2,'match68567-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(map.segments).hasLength(segmentCount);
  }

  public void testSetInitialCapacity() {
    // share capacity over each segment, then round up to nearest power of two

    checkInitialCapacity(1, 0, 1);
    checkInitialCapacity(1, 1, 1);
    checkInitialCapacity(1, 2, 2);
    checkInitialCapacity(1, 3, 4);
    checkInitialCapacity(1, 4, 4);
    checkInitialCapacity(1, 5, 8);
    checkInitialCapacity(1, 6, 8);
    checkInitialCapacity(1, 7, 8);
    checkInitialCapacity</B></FONT>(1, 8, 8);

    checkInitialCapacity(2, 0, 1);
    checkInitialCapacity(2, 1, 1);
    checkInitialCapacity(2, 2, 1);
    checkInitialCapacity(2, 3, 2);
    checkInitialCapacity(2, 4, 2);
    checkInitialCapacity(2, 5, 4);
    checkInitialCapacity(2, 6, 4);
    checkInitialCapacity(2, 7, 4);
    checkInitialCapacity(2, 8, 4);

    checkInitialCapacity(4, 0, 1);
    checkInitialCapacity(4, 1, 1);
    checkInitialCapacity(4, 2, 1);
    checkInitialCapacity(4, 3, 1);
    checkInitialCapacity(4, 4, 1);
    checkInitialCapacity(4, 5, 2);
    checkInitialCapacity(4, 6, 2);
    checkInitialCapacity(4, 7, 2);
    checkInitialCapacity(4, 8, 2);
  }

  private static void checkInitialCapacity(
      int concurrencyLevel, int initialCapacity, int segmentSize) {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(
            createMapMaker().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));
    for (int i = 0; i &lt; map.segments.length; i++) {
      assertEquals(segmentSize, map.segments[i].table.length());
    }
  }

  public void testSetMaximumSize() {
    // vary maximumSize wrt concurrencyLevel

    for (int maxSize = 1; maxSize &lt; 8; maxSize++) {
      checkMaximumSize(1, 8, maxSize);
      checkMaximumSize(2, 8, maxSize);
      checkMaximumSize(4, 8, maxSize);
      checkMaximumSize(8, 8, maxSize);
    }
<A NAME="20"></A>
    checkMaximumSize(1, 8, Integer.MAX_VALUE);
    checkMaximumSize(2, 8, Integer.MAX_VALUE);
    <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#20',2,'match68567-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>checkMaximumSize(4, 8, Integer.MAX_VALUE);
    checkMaximumSize(8, 8, Integer.MAX_VALUE);

    // vary initial capacity wrt maximumSize

    for (int capacity = 0; capacity &lt; 8; capacity++) {
      checkMaximumSize(1, capacity, 4);
      checkMaximumSize(2, capacity, 4);
      checkMaximumSize(4, capacity, 4);
      checkMaximumSize</B></FONT>(8, capacity, 4);
    }
  }

  private static void checkMaximumSize(int concurrencyLevel, int initialCapacity, int maxSize) {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(
            createMapMaker().concurrencyLevel(concurrencyLevel).initialCapacity(initialCapacity));
    int totalCapacity = 0;
    for (int i = 0; i &lt; map.segments.length; i++) {
      totalCapacity += map.segments[i].maxSegmentSize;
    }
    assertTrue(&quot;totalCapcity=&quot; + totalCapacity + &quot;, maxSize=&quot; + maxSize, totalCapacity &lt;= maxSize);
<A NAME="13"></A>  }

  public void testSetWeakKeys() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(<FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#13',2,'match68567-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMapMaker().weakKeys());
    checkStrength(map, Strength.WEAK, Strength.STRONG);
    assertThat(map.entryHelper)
        .isInstanceOf(MapMakerInternalMap.WeakKeyStrongValueEntry.Helper.class);
  }

  public void testSetWeakValues() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(createMapMaker().weakValues</B></FONT>());
    checkStrength(map, Strength.STRONG, Strength.WEAK);
    assertThat(map.entryHelper)
        .isInstanceOf(MapMakerInternalMap.StrongKeyWeakValueEntry.Helper.class);
  }

  private static void checkStrength(
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map, Strength keyStrength, Strength valueStrength) {
    assertSame(keyStrength, map.keyStrength());
    assertSame(valueStrength, map.valueStrength());
    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);
    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence());
  }

  // Segment core tests

  public void testNewEntry() {
    for (MapMaker maker : allWeakValueStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker);
      Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

<A NAME="17"></A>      Object keyOne = new Object();
      Object valueOne = new Object();
      int hashOne = map.hash(keyOne);
      <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#17',2,'match68567-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>InternalEntry&lt;Object, Object, ?&gt; entryOne = segment.newEntryForTesting(keyOne, hashOne, null);
      WeakValueReference&lt;Object, Object, ?&gt; valueRefOne =
          segment.newWeakValueReferenceForTesting(entryOne, valueOne);
      assertSame(valueOne, valueRefOne.get());
      segment.setWeakValueReferenceForTesting(entryOne, valueRefOne);

      assertSame(keyOne, entryOne.getKey());
      assertEquals(hashOne, entryOne.getHash</B></FONT>());
      assertNull(entryOne.getNext());
      assertSame(valueRefOne, segment.getWeakValueReferenceForTesting(entryOne));

      Object keyTwo = new Object();
<A NAME="16"></A>      Object valueTwo = new Object();
      int hashTwo = map.hash(keyTwo);

      <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#16',2,'match68567-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>InternalEntry&lt;Object, Object, ?&gt; entryTwo =
          segment.newEntryForTesting(keyTwo, hashTwo, entryOne);
      WeakValueReference&lt;Object, Object, ?&gt; valueRefTwo =
          segment.newWeakValueReferenceForTesting(entryTwo, valueTwo);
      assertSame(valueTwo, valueRefTwo.get());
      segment.setWeakValueReferenceForTesting(entryTwo, valueRefTwo);

      assertSame(keyTwo, entryTwo.getKey());
      assertEquals(hashTwo, entryTwo.getHash</B></FONT>());
      assertSame(entryOne, entryTwo.getNext());
      assertSame(valueRefTwo, segment.getWeakValueReferenceForTesting(entryTwo));
    }
  }

  public void testCopyEntry() {
    for (MapMaker maker : allWeakValueStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker);
      Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

      Object keyOne = new Object();
      Object valueOne = new Object();
      int hashOne = map.hash(keyOne);
      InternalEntry&lt;Object, Object, ?&gt; entryOne = segment.newEntryForTesting(keyOne, hashOne, null);
      segment.setValueForTesting(entryOne, valueOne);

      Object keyTwo = new Object();
      Object valueTwo = new Object();
      int hashTwo = map.hash(keyTwo);
      InternalEntry&lt;Object, Object, ?&gt; entryTwo = segment.newEntryForTesting(keyTwo, hashTwo, null);
      segment.setValueForTesting(entryTwo, valueTwo);

<A NAME="7"></A>      InternalEntry&lt;Object, Object, ?&gt; copyOne = segment.copyForTesting(entryOne, null);
      assertSame(keyOne, entryOne.getKey());
      assertEquals(hashOne, entryOne.getHash());
      <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#7',2,'match68567-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertNull(entryOne.getNext());
      assertSame(valueOne, copyOne.getValue());

      InternalEntry&lt;Object, Object, ?&gt; copyTwo = segment.copyForTesting(entryTwo, copyOne);
      assertSame(keyTwo, copyTwo.getKey());
      assertEquals(hashTwo, copyTwo.getHash());
      assertSame(copyOne, copyTwo.getNext());
      assertSame(valueTwo, copyTwo.getValue</B></FONT>());
    }
  }

  public void testSegmentGetAndContains() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
<A NAME="1"></A>    int hash = map.hash(key);
    Object value = new Object();
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    int index = hash &amp; (<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#1',2,'match68567-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>table.length() - 1);

    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);

    assertNull(segment.get(key, hash));

    // count == 0
    segment.setTableEntryForTesting(index, entry);
    assertNull(segment.get(key, hash));
    assertFalse(segment.containsKey(key, hash));
    assertFalse(segment.containsValue(value));

    // count == 1
    segment.count++;
    assertSame(value, segment.get(key, hash));
    assertTrue(segment.containsKey(key, hash));
    assertTrue(segment.containsValue</B></FONT>(value));
    // don't see absent values now that count &gt; 0
    assertNull(segment.get(new Object(), hash));
<A NAME="8"></A>
    // null key
    InternalEntry&lt;Object, Object, ?&gt; nullEntry = segment.newEntryForTesting(null, hash, entry);
    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#8',2,'match68567-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Object nullValue = new Object();
    WeakValueReference&lt;Object, Object, ?&gt; nullValueRef =
        segment.newWeakValueReferenceForTesting(nullEntry, nullValue);
    segment.setWeakValueReferenceForTesting(nullEntry, nullValueRef);
    segment.setTableEntryForTesting(index, nullEntry);
    // skip the null key
    assertSame(value, segment.get(key, hash));
    assertTrue(segment.containsKey(key, hash));
    assertTrue(segment.containsValue(value));
    assertFalse</B></FONT>(segment.containsValue(nullValue));

    // hash collision
    InternalEntry&lt;Object, Object, ?&gt; dummyEntry =
        segment.newEntryForTesting(new Object(), hash, entry);
    Object dummyValue = new Object();
    WeakValueReference&lt;Object, Object, ?&gt; dummyValueRef =
        segment.newWeakValueReferenceForTesting(dummyEntry, dummyValue);
    segment.setWeakValueReferenceForTesting(dummyEntry, dummyValueRef);
    segment.setTableEntryForTesting(index, dummyEntry);
    assertSame(value, segment.get(key, hash));
    assertTrue(segment.containsKey(key, hash));
    assertTrue(segment.containsValue(value));
    assertTrue(segment.containsValue(dummyValue));

<A NAME="2"></A>    // key collision
    dummyEntry = segment.newEntryForTesting(key, hash, entry);
    dummyValue = new Object();
    dummyValueRef = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#2',2,'match68567-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>segment.newWeakValueReferenceForTesting(dummyEntry, dummyValue);
    segment.setWeakValueReferenceForTesting(dummyEntry, dummyValueRef);
    segment.setTableEntryForTesting(index, dummyEntry);
    // returns the most recent entry
    assertSame(dummyValue, segment.get(key, hash));
    assertTrue(segment.containsKey(key, hash));
    assertTrue(segment.containsValue(value));
    assertTrue(segment.containsValue(dummyValue));
  }

  public void testSegmentReplaceValue() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues</B></FONT>());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
<A NAME="4"></A>    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    int index = hash &amp; (table.length() - 1);

    InternalEntry&lt;Object, Object, ?&gt; entry = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#4',2,'match68567-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>segment.newEntryForTesting(key, hash, null);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(0, segment.count);

    // same value
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertTrue(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // different value
    assertFalse</B></FONT>(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
<A NAME="18"></A>    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    oldValueRef.clear();
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#18',2,'match68567-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }

  public void testSegmentReplace() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel</B></FONT>(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    int index = hash &amp; (table.length() - 1);

    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertNull(segment.replace(key, hash, newValue));
    assertEquals(0, segment.count);

    // same key
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.replace(key, hash, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
<A NAME="14"></A>    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    oldValueRef.clear();
    assertNull(segment.replace(key, hash, newValue));
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#14',2,'match68567-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }

  public void testSegmentPut() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel</B></FONT>(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, false));
<A NAME="9"></A>    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#9',2,'match68567-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    InternalEntry&lt;Object, Object, ?&gt; entry = segment.getEntry(key, hash);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
<A NAME="19"></A>    oldValueRef.clear();
    assertNull</B></FONT>(segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#19',2,'match68567-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(newValue, segment.get(key, hash));
  }

  public void testSegmentPutIfAbsent() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel</B></FONT>(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    // TODO(fry): check recency ordering

<A NAME="21"></A>    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#21',2,'match68567-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, true));
    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame</B></FONT>(oldValue, segment.get(key, hash));

    // cleared
<A NAME="0"></A>    InternalEntry&lt;Object, Object, ?&gt; entry = segment.getEntry(key, hash);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#0',2,'match68567-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));
  }

  public void testSegmentPut_expand() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    assertEquals</B></FONT>(1, segment.table.length());

    int count = 1024;
    for (int i = 0; i &lt; count; i++) {
      Object key = new Object();
      Object value = new Object();
      int hash = map.hash(key);
      assertNull(segment.put(key, hash, value, false));
      assertTrue(segment.table.length() &gt; i);
    }
  }

  public void testSegmentRemove() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    int index = hash &amp; (table.length() - 1);

    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);

    // same key
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.remove(key, hash));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));

    // cleared
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
<A NAME="22"></A>    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.remove(key, hash));
    <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#22',2,'match68567-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }

  public void testSegmentRemoveValue() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap</B></FONT>(createMapMaker().concurrencyLevel(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    int index = hash &amp; (table.length() - 1);

    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference&lt;Object, Object, ?&gt; oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);

    // same value
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertTrue(segment.remove(key, hash, oldValue));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));

    // different value
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertFalse(segment.remove(key, hash, newValue));
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));

    // cleared
    assertSame(oldValue, segment.get(key, hash));
<A NAME="6"></A>    oldValueRef.clear();
    assertFalse(segment.remove(key, hash, oldValue));
    assertEquals(0, segment.count);
    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#6',2,'match68567-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertNull(segment.get(key, hash));
  }

  @SuppressWarnings(&quot;GuardedBy&quot;)
  public void testExpand() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    assertEquals</B></FONT>(1, segment.table.length());

    // manually add elements to avoid expansion
    int originalCount = 1024;
    InternalEntry&lt;Object, Object, ?&gt; entry = null;
    for (int i = 0; i &lt; originalCount; i++) {
      Object key = new Object();
      Object value = new Object();
      int hash = map.hash(key);
      // chain all entries together as we only have a single bucket
      entry = segment.newEntryForTesting(key, hash, entry);
      segment.setValueForTesting(entry, value);
    }
    segment.setTableEntryForTesting(0, entry);
    segment.count = originalCount;
    ImmutableMap&lt;Object, Object&gt; originalMap = ImmutableMap.copyOf(map);
    assertEquals(originalCount, originalMap.size());
    assertEquals(originalMap, map);

    for (int i = 1; i &lt;= originalCount * 2; i *= 2) {
      if (i &gt; 1) {
        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
        // held
        segment.expand();
      }
      assertEquals(i, segment.table.length());
      assertEquals(originalCount, countLiveEntries(map));
      assertEquals(originalCount, segment.count);
      assertEquals(originalMap, map);
    }
  }

  public void testRemoveFromChain() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(createMapMaker().concurrencyLevel(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

    // create 3 objects and chain them together
    Object keyOne = new Object();
    Object valueOne = new Object();
    int hashOne = map.hash(keyOne);
    InternalEntry&lt;Object, Object, ?&gt; entryOne = segment.newEntryForTesting(keyOne, hashOne, null);
    segment.setValueForTesting(entryOne, valueOne);
    Object keyTwo = new Object();
    Object valueTwo = new Object();
    int hashTwo = map.hash(keyTwo);
    InternalEntry&lt;Object, Object, ?&gt; entryTwo =
        segment.newEntryForTesting(keyTwo, hashTwo, entryOne);
    segment.setValueForTesting(entryTwo, valueTwo);
    Object keyThree = new Object();
    Object valueThree = new Object();
    int hashThree = map.hash(keyThree);
    InternalEntry&lt;Object, Object, ?&gt; entryThree =
        segment.newEntryForTesting(keyThree, hashThree, entryTwo);
    segment.setValueForTesting(entryThree, valueThree);

    // alone
<A NAME="11"></A>    assertNull(segment.removeFromChainForTesting(entryOne, entryOne));

    // head
    <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#11',2,'match68567-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(entryOne, segment.removeFromChainForTesting(entryTwo, entryTwo));

    // middle
    InternalEntry&lt;Object, Object, ?&gt; newFirst =
        segment.removeFromChainForTesting(entryThree, entryTwo);
    assertSame(keyThree, newFirst.getKey());
    assertSame(valueThree, newFirst.getValue());
    assertEquals(hashThree, newFirst.getHash());
    assertSame(entryOne, newFirst.getNext</B></FONT>());

    // tail (remaining entries are copied in reverse order)
    newFirst = segment.removeFromChainForTesting(entryThree, entryOne);
    assertSame(keyTwo, newFirst.getKey());
    assertSame(valueTwo, newFirst.getValue());
    assertEquals(hashTwo, newFirst.getHash());
<A NAME="12"></A>    newFirst = newFirst.getNext();
    assertSame(keyThree, newFirst.getKey());
    assertSame(valueThree, newFirst.getValue());
    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#12',2,'match68567-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(hashThree, newFirst.getHash());
    assertNull(newFirst.getNext());
  }

  @SuppressWarnings(&quot;GuardedBy&quot;)
  public void testExpand_cleanup() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity</B></FONT>(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    assertEquals(1, segment.table.length());

    // manually add elements to avoid expansion
    // 1/3 null keys, 1/3 null values
    int originalCount = 1024;
    InternalEntry&lt;Object, Object, ?&gt; entry = null;
    for (int i = 0; i &lt; originalCount; i++) {
      Object key = new Object();
      Object value = (i % 3 == 0) ? null : new Object();
      int hash = map.hash(key);
      if (i % 3 == 1) {
        key = null;
      }
      // chain all entries together as we only have a single bucket
      entry = segment.newEntryForTesting(key, hash, entry);
      segment.setValueForTesting(entry, value);
    }
    segment.setTableEntryForTesting(0, entry);
    segment.count = originalCount;
    int liveCount = originalCount / 3;
    assertEquals(1, segment.table.length());
    assertEquals(liveCount, countLiveEntries(map));
    ImmutableMap&lt;Object, Object&gt; originalMap = ImmutableMap.copyOf(map);
    assertEquals(liveCount, originalMap.size());
    // can't compare map contents until cleanup occurs

    for (int i = 1; i &lt;= originalCount * 2; i *= 2) {
      if (i &gt; 1) {
        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
        // held
        segment.expand();
      }
      assertEquals(i, segment.table.length());
      assertEquals(liveCount, countLiveEntries(map));
      // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies
      assertTrue(segment.count &gt;= liveCount);
      assertTrue(segment.count &lt;= originalCount);
      assertEquals(originalMap, ImmutableMap.copyOf(map));
    }
  }

  private static &lt;K, V&gt; int countLiveEntries(MapMakerInternalMap&lt;K, V, ?, ?&gt; map) {
    int result = 0;
    for (Segment&lt;K, V, ?, ?&gt; segment : map.segments) {
      AtomicReferenceArray&lt;? extends InternalEntry&lt;K, V, ?&gt;&gt; table = segment.table;
      for (int i = 0; i &lt; table.length(); i++) {
        for (InternalEntry&lt;K, V, ?&gt; e = table.get(i); e != null; e = e.getNext()) {
          if (map.isLiveForTesting(e)) {
            result++;
          }
        }
      }
    }
    return result;
  }

  public void testClear() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);

    segment.setTableEntryForTesting(0, entry);
    segment.readCount.incrementAndGet();
    segment.count = 1;

    assertSame(entry, table.get(0));

    segment.clear();
    assertNull(table.get(0));
    assertEquals(0, segment.readCount.get());
    assertEquals(0, segment.count);
  }

  public void testRemoveEntry() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);

    // remove absent
    assertFalse(segment.removeTableEntryForTesting(entry));

    segment.setTableEntryForTesting(0, entry);
    segment.count = 1;
    assertTrue(segment.removeTableEntryForTesting(entry));
    assertEquals(0, segment.count);
    assertNull(table.get(0));
  }

  public void testClearValue() {
    MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1).weakValues());
    Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];
    AtomicReferenceArray&lt;? extends InternalEntry&lt;Object, Object, ?&gt;&gt; table = segment.table;
<A NAME="3"></A>    assertEquals(1, table.length());

    Object key = new Object();
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68567-0.html#3',2,'match68567-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Object value = new Object();
    int hash = map.hash(key);
    InternalEntry&lt;Object, Object, ?&gt; entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);
    WeakValueReference&lt;Object, Object, ?&gt; valueRef = segment.getWeakValueReferenceForTesting(entry);

    // clear absent
    assertFalse(segment.clearValueForTesting(key, hash, valueRef));

    segment.setTableEntryForTesting(0, entry);
    // don't increment count; this is used during computation
    assertTrue(segment.clearValueForTesting(key, hash, valueRef));
    // no notification sent with clearValue
    assertEquals(0, segment.count);
    assertNull(table.get(0));

    // clear wrong value reference
    segment.setTableEntryForTesting</B></FONT>(0, entry);
    WeakValueReference&lt;Object, Object, ?&gt; otherValueRef =
        segment.newWeakValueReferenceForTesting(entry, value);
    segment.setWeakValueReferenceForTesting(entry, otherValueRef);
    assertFalse(segment.clearValueForTesting(key, hash, valueRef));
    segment.setWeakValueReferenceForTesting(entry, valueRef);
    assertTrue(segment.clearValueForTesting(key, hash, valueRef));
  }

  // reference queues

  public void testDrainKeyReferenceQueueOnWrite() {
    for (MapMaker maker : allWeakKeyStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker.concurrencyLevel(1));
      if (maker.getKeyStrength() == Strength.WEAK) {
        Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

        Object keyOne = new Object();
        int hashOne = map.hash(keyOne);
        Object valueOne = new Object();
        Object keyTwo = new Object();
        Object valueTwo = new Object();

        map.put(keyOne, valueOne);
        InternalEntry&lt;Object, Object, ?&gt; entry = segment.getEntry(keyOne, hashOne);

        @SuppressWarnings(&quot;unchecked&quot;)
        Reference&lt;Object&gt; reference = (Reference&lt;Object&gt;) entry;
        reference.enqueue();

        map.put(keyTwo, valueTwo);
        assertFalse(map.containsKey(keyOne));
        assertFalse(map.containsValue(valueOne));
        assertNull(map.get(keyOne));
        assertEquals(1, map.size());
        assertNull(segment.getKeyReferenceQueueForTesting().poll());
      }
    }
  }

  public void testDrainValueReferenceQueueOnWrite() {
    for (MapMaker maker : allWeakValueStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker.concurrencyLevel(1));
      if (maker.getValueStrength() == Strength.WEAK) {
        Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

        Object keyOne = new Object();
        int hashOne = map.hash(keyOne);
        Object valueOne = new Object();
        Object keyTwo = new Object();
        Object valueTwo = new Object();

        map.put(keyOne, valueOne);
        @SuppressWarnings(&quot;unchecked&quot;)
        WeakValueEntry&lt;Object, Object, ?&gt; entry =
            (WeakValueEntry&lt;Object, Object, ?&gt;) segment.getEntry(keyOne, hashOne);
        WeakValueReference&lt;Object, Object, ?&gt; valueReference = entry.getValueReference();

        @SuppressWarnings(&quot;unchecked&quot;)
        Reference&lt;Object&gt; reference = (Reference&lt;Object&gt;) valueReference;
        reference.enqueue();

        map.put(keyTwo, valueTwo);
        assertFalse(map.containsKey(keyOne));
        assertFalse(map.containsValue(valueOne));
        assertNull(map.get(keyOne));
        assertEquals(1, map.size());
        assertNull(segment.getValueReferenceQueueForTesting().poll());
      }
    }
  }

  public void testDrainKeyReferenceQueueOnRead() {
    for (MapMaker maker : allWeakKeyStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker.concurrencyLevel(1));
      if (maker.getKeyStrength() == Strength.WEAK) {
        Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

        Object keyOne = new Object();
        int hashOne = map.hash(keyOne);
        Object valueOne = new Object();
        Object keyTwo = new Object();

        map.put(keyOne, valueOne);
        InternalEntry&lt;Object, Object, ?&gt; entry = segment.getEntry(keyOne, hashOne);

        @SuppressWarnings(&quot;unchecked&quot;)
        Reference&lt;Object&gt; reference = (Reference&lt;Object&gt;) entry;
        reference.enqueue();

        for (int i = 0; i &lt; SMALL_MAX_SIZE; i++) {
          Object unused = map.get(keyTwo);
        }
        assertFalse(map.containsKey(keyOne));
        assertFalse(map.containsValue(valueOne));
        assertNull(map.get(keyOne));
        assertEquals(0, map.size());
        assertNull(segment.getKeyReferenceQueueForTesting().poll());
      }
    }
  }

  public void testDrainValueReferenceQueueOnRead() {
    for (MapMaker maker : allWeakValueStrengthMakers()) {
      MapMakerInternalMap&lt;Object, Object, ?, ?&gt; map = makeMap(maker.concurrencyLevel(1));
      if (maker.getValueStrength() == Strength.WEAK) {
        Segment&lt;Object, Object, ?, ?&gt; segment = map.segments[0];

        Object keyOne = new Object();
        int hashOne = map.hash(keyOne);
        Object valueOne = new Object();
        Object keyTwo = new Object();

        map.put(keyOne, valueOne);
        @SuppressWarnings(&quot;unchecked&quot;)
        WeakValueEntry&lt;Object, Object, ?&gt; entry =
            (WeakValueEntry&lt;Object, Object, ?&gt;) segment.getEntry(keyOne, hashOne);
        WeakValueReference&lt;Object, Object, ?&gt; valueReference = entry.getValueReference();

        @SuppressWarnings(&quot;unchecked&quot;)
        Reference&lt;Object&gt; reference = (Reference&lt;Object&gt;) valueReference;
        reference.enqueue();

        for (int i = 0; i &lt; SMALL_MAX_SIZE; i++) {
          Object unused = map.get(keyTwo);
        }
        assertFalse(map.containsKey(keyOne));
        assertFalse(map.containsValue(valueOne));
        assertNull(map.get(keyOne));
        assertEquals(0, map.size());
        assertNull(segment.getValueReferenceQueueForTesting().poll());
      }
    }
  }

  // utility methods

  private static Iterable&lt;MapMaker&gt; allWeakKeyStrengthMakers() {
    return ImmutableList.of(createMapMaker().weakKeys(), createMapMaker().weakKeys().weakValues());
  }

  private static Iterable&lt;MapMaker&gt; allWeakValueStrengthMakers() {
    return ImmutableList.of(
        createMapMaker().weakValues(), createMapMaker().weakKeys().weakValues());
  }

  public void testNullParameters() throws Exception {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicInstanceMethods(makeMap(createMapMaker()));
  }
}
</PRE>
</div>
  </div>
</body>
</html>
