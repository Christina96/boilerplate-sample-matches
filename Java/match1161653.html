<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ExecutionSequencerTest.java & Tables.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ExecutionSequencerTest.java & Tables.java
      </h3>
      <h1 align="center">
        6.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ExecutionSequencerTest.java (7.305936%)<TH>Tables.java (5.498282%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1161653-0.html#0',2,'match1161653-1.html#0',3)" NAME="0">(15-36)<TD><A HREF="javascript:ZweiFrames('match1161653-0.html#0',2,'match1161653-1.html#0',3)" NAME="0">(17-38)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1161653-0.html#1',2,'match1161653-1.html#1',3)" NAME="1">(68-73)<TD><A HREF="javascript:ZweiFrames('match1161653-0.html#1',2,'match1161653-1.html#1',3)" NAME="1">(122-125)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1161653-0.html#2',2,'match1161653-1.html#2',3)" NAME="2">(301-305)<TD><A HREF="javascript:ZweiFrames('match1161653-0.html#2',2,'match1161653-1.html#2',3)" NAME="2">(427-431)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1161653-0.html#3',2,'match1161653-1.html#3',3)" NAME="3">(56-63)<TD><A HREF="javascript:ZweiFrames('match1161653-0.html#3',2,'match1161653-1.html#3',3)" NAME="3">(166-173)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ExecutionSequencerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2018 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
<A NAME="0"></A> * the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1161653-1.html#0',3,'match1161653-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.util.concurrent;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.Futures.allAsList;
import static com.google.common.util.concurrent.Futures.getDone;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.concurrent.TimeUnit.SECONDS;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.testing.GcFinalization;
import com.google.common.testing.TestLogHandler;
import com.google.j2objc.annotations.J2ObjCIncompatible;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import</B></FONT> java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
import junit.framework.TestCase;

/** Tests for {@link ExecutionSequencer} */
public class ExecutionSequencerTest extends TestCase {

  ExecutorService executor;

  private ExecutionSequencer serializer;
  private SettableFuture&lt;Void&gt; firstFuture;
  private TestCallable firstCallable;

  @Override
  public void setUp() throws Exception {
    executor = Executors.newCachedThreadPool();
<A NAME="3"></A>    serializer = ExecutionSequencer.create();
    firstFuture = SettableFuture.create();
    firstCallable = new TestCallable(firstFuture);
  <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1161653-1.html#3',3,'match1161653-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  @Override
  public void tearDown() throws Exception {
    executor.shutdown();
  }

  public void testCallableStartsAfterFirstFut</B></FONT>ureCompletes() {
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
<A NAME="1"></A>    Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
    Future&lt;?&gt; possiblyIgnoredError1 = <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1161653-1.html#1',3,'match1161653-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>serializer.submitAsync(secondCallable, directExecutor());
    assertThat(firstCallable.called).isTrue();
    assertThat(secondCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isTrue();
  }</B></FONT>

  public void testCancellationDoesNotViolateSerialization() {
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
    Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
    ListenableFuture&lt;Void&gt; secondFuture = serializer.submitAsync(secondCallable, directExecutor());
    TestCallable thirdCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
    Future&lt;?&gt; possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
    secondFuture.cancel(true);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isTrue();
  }

  public void testCancellationMultipleThreads() throws Exception {
    final BlockingCallable blockingCallable = new BlockingCallable();
    ListenableFuture&lt;Void&gt; unused = serializer.submit(blockingCallable, executor);
    ListenableFuture&lt;Boolean&gt; future2 =
        serializer.submit(
            new Callable&lt;Boolean&gt;() {
              @Override
              public Boolean call() {
                return blockingCallable.isRunning();
              }
            },
            directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }

  public void testSecondTaskWaitsForFirstEvenIfCancelled() throws Exception {
    final BlockingCallable blockingCallable = new BlockingCallable();
    ListenableFuture&lt;Void&gt; future1 = serializer.submit(blockingCallable, executor);
    ListenableFuture&lt;Boolean&gt; future2 =
        serializer.submit(
            new Callable&lt;Boolean&gt;() {
              @Override
              public Boolean call() {
                return blockingCallable.isRunning();
              }
            },
            directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // This time, cancel the future for the first task. The task remains running, only the future
    // is cancelled.
    future1.cancel(false);

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    // (This is the assertion that fails.)
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }

  @GwtIncompatible
  @J2ObjCIncompatible // gc
  @AndroidIncompatible
  public void testCancellationWithReferencedObject() throws Exception {
    Object toBeGCed = new Object();
    WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(toBeGCed);
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
    ListenableFuture&lt;?&gt; ignored =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
    toBeGCed = null;
    GcFinalization.awaitClear(ref);
  }

  private static Callable&lt;String&gt; toStringCallable(final Object object) {
    return new Callable&lt;String&gt;() {
      @Override
      public String call() {
        return object.toString();
      }
    };
  }

  public void testCancellationDuringReentrancy() throws Exception {
    TestLogHandler logHandler = new TestLogHandler();
    Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);

    List&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;&gt;();
    final Runnable[] manualExecutorTask = new Runnable[1];
    Executor manualExecutor =
        new Executor() {
          @Override
          public void execute(Runnable task) {
            manualExecutorTask[0] = task;
          }
        };

    results.add(serializer.submit(Callables.returning(null), manualExecutor));
    final Future&lt;?&gt;[] thingToCancel = new Future&lt;?&gt;[1];
    results.add(
        serializer.submit(
            new Callable&lt;Void&gt;() {
              @Override
              public Void call() {
                thingToCancel[0].cancel(false);
                return null;
              }
            },
            directExecutor()));
    thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
    results.add(thingToCancel[0]);
    // Enqueue more than enough tasks to force reentrancy.
    for (int i = 0; i &lt; 5; i++) {
      results.add(serializer.submit(Callables.returning(null), directExecutor()));
    }

    manualExecutorTask[0].run();

    for (Future&lt;?&gt; result : results) {
      if (!result.isCancelled()) {
        result.get(10, SECONDS);
      }
      // TODO(cpovirk): Verify that the cancelled futures are exactly ones that we expect.
    }

    assertThat(logHandler.getStoredLogRecords()).isEmpty();
  }

  public void testAvoidsStackOverflow_manySubmitted() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
    ArrayList&lt;ListenableFuture&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;(50_001);
    results.add(
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor()));
    for (int i = 0; i &lt; 50_000; i++) {
      results.add(serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()));
    }
    settableFuture.set(null);
    getDone(allAsList(results));
  }

  public void testAvoidsStackOverflow_manyCancelled() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
    ListenableFuture&lt;Void&gt; unused =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    for (int i = 0; i &lt; 50_000; i++) {
      serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
    }
    ListenableFuture&lt;Integer&gt; stackDepthCheck =
        serializer.submit(
            new Callable&lt;Integer&gt;() {
              @Override
              public Integer call() {
                return Thread.currentThread().getStackTrace().length;
              }
            },
            directExecutor());
    settableFuture.set(null);
    assertThat(getDone(stackDepthCheck))
        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
  }

  public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
    ListenableFuture&lt;Void&gt; unused =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    for (int i = 0; i &lt; 25_000; i++) {
      serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
      unused = serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor());
    }
    ListenableFuture&lt;Integer&gt; stackDepthCheck =
        serializer.submit(
            new Callable&lt;Integer&gt;() {
              @Override
              public Integer call() {
                return Thread.currentThread().getStackTrace().length;
              }
            },
            directExecutor());
    settableFuture.set(null);
    assertThat(getDone(stackDepthCheck))
<A NAME="2"></A>        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
  }

  private static Function&lt;Integer, Integer&gt; add(final int delta) <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1161653-1.html#2',3,'match1161653-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    return new Function&lt;Integer, Integer&gt;() {
      @Override
      public Integer apply(Integer input) {
        return</B></FONT> input + delta;
      }
    };
  }

  private static AsyncCallable&lt;Integer&gt; asyncAdd(
      final ListenableFuture&lt;Integer&gt; future, final int delta, final Executor executor) {
    return new AsyncCallable&lt;Integer&gt;() {
      @Override
      public ListenableFuture&lt;Integer&gt; call() throws Exception {
        return Futures.transform(future, add(delta), executor);
      }
    };
  }

  private static final class LongHolder {
    long count;
  }

  private static final int ITERATION_COUNT = 50_000;
  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;

  @GwtIncompatible // threads
  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
    final LongHolder holder = new LongHolder();
    final ArrayList&lt;ListenableFuture&lt;Integer&gt;&gt; lengthChecks = new ArrayList&lt;&gt;();
    final List&lt;Integer&gt; completeLengthChecks;
    final int baseStackDepth;
    ExecutorService service = Executors.newFixedThreadPool(5);
    try {
      // Avoid counting frames from the executor itself, or the ExecutionSequencer
      baseStackDepth =
          serializer
              .submit(
                  new Callable&lt;Integer&gt;() {
                    @Override
                    public Integer call() {
                      return Thread.currentThread().getStackTrace().length;
                    }
                  },
                  service)
              .get();
      final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
      ListenableFuture&lt;?&gt; unused =
          serializer.submitAsync(
              new AsyncCallable&lt;Void&gt;() {
                @Override
                public ListenableFuture&lt;Void&gt; call() {
                  return settableFuture;
                }
              },
              directExecutor());
      for (int i = 0; i &lt; 50_000; i++) {
        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
          // after some number of iterations, switch threads
          unused =
              serializer.submit(
                  new Callable&lt;Void&gt;() {
                    @Override
                    public Void call() {
                      holder.count++;
                      return null;
                    }
                  },
                  service);
        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
          // When at max depth, record stack trace depth
          lengthChecks.add(
              serializer.submit(
                  new Callable&lt;Integer&gt;() {
                    @Override
                    public Integer call() {
                      holder.count++;
                      return Thread.currentThread().getStackTrace().length;
                    }
                  },
                  directExecutor()));
        } else {
          // Otherwise, schedule a task on directExecutor
          unused =
              serializer.submit(
                  new Callable&lt;Void&gt;() {
                    @Override
                    public Void call() {
                      holder.count++;
                      return null;
                    }
                  },
                  directExecutor());
        }
      }
      settableFuture.set(null);
      completeLengthChecks = allAsList(lengthChecks).get();
    } finally {
      service.shutdown();
    }
    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
    for (int length : completeLengthChecks) {
      // Verify that at max depth, less than one stack frame per submitted task was consumed
      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
    }
  }

  @SuppressWarnings(&quot;ObjectToString&quot;) // Intended behavior
  public void testToString() {
    Future&lt;?&gt; unused = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(SettableFuture.&lt;Void&gt;create());
    Future&lt;?&gt; second = serializer.submitAsync(secondCallable, directExecutor());
    assertThat(secondCallable.called).isFalse();
    assertThat(second.toString()).contains(secondCallable.toString());
    firstFuture.set(null);
    assertThat(second.toString()).contains(secondCallable.future.toString());
  }

  private static class BlockingCallable implements Callable&lt;Void&gt; {
    private final CountDownLatch startLatch = new CountDownLatch(1);
    private final CountDownLatch stopLatch = new CountDownLatch(1);

    private volatile boolean running = false;

    @Override
    public Void call() throws InterruptedException {
      running = true;
      startLatch.countDown();
      stopLatch.await();
      running = false;
      return null;
    }

    public void waitForStart() throws InterruptedException {
      startLatch.await();
    }

    public void stop() {
      stopLatch.countDown();
    }

    public boolean isRunning() {
      return running;
    }
  }

  private static final class TestCallable implements AsyncCallable&lt;Void&gt; {

    private final ListenableFuture&lt;Void&gt; future;
    private boolean called = false;

    private TestCallable(ListenableFuture&lt;Void&gt; future) {
      this.future = future;
    }

    @Override
    public ListenableFuture&lt;Void&gt; call() throws Exception {
      called = true;
      return future;
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Tables.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1161653-0.html#0',2,'match1161653-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Supplier;
import com.google.common.collect.Table.Cell;
import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import javax.annotation.CheckForNull;
import</B></FONT> org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Provides static methods that involve a {@code Table}.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/CollectionUtilitiesExplained#tables&quot;&gt;{@code Tables}&lt;/a&gt;.
 *
 * @author Jared Levy
 * @author Louis Wasserman
 * @since 7.0
 */
@GwtCompatible
@ElementTypesAreNonnullByDefault
public final class Tables {
  private Tables() {}

  /**
   * Returns an immutable cell with the specified row key, column key, and value.
   *
   * &lt;p&gt;The returned cell is serializable.
   *
   * @param rowKey the row key to be associated with the returned cell
   * @param columnKey the column key to be associated with the returned cell
   * @param value the value to be associated with the returned cell
   */
  public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      Cell&lt;R, C, V&gt; immutableCell(
          @ParametricNullness R rowKey,
          @ParametricNullness C columnKey,
          @ParametricNullness V value) {
    return new ImmutableCell&lt;&gt;(rowKey, columnKey, value);
  }

  static final class ImmutableCell&lt;
          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      extends AbstractCell&lt;R, C, V&gt; implements Serializable {
    @ParametricNullness private final R rowKey;
    @ParametricNullness private final C columnKey;
    @ParametricNullness private final V value;

    ImmutableCell(
        @ParametricNullness R rowKey,
        @ParametricNullness C columnKey,
        @ParametricNullness V value) {
      this.rowKey = rowKey;
      this.columnKey = columnKey;
      this.value = value;
    }

    @Override
    @ParametricNullness
    public R getRowKey() {
      return rowKey;
    }

    @Override
    @ParametricNullness
    public C getColumnKey() {
      return columnKey;
    }

    @Override
    @ParametricNullness
    public V getValue() {
      return value;
    }

    private static final long serialVersionUID = 0;
  }

  abstract static class AbstractCell&lt;
          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      implements Cell&lt;R, C, V&gt; {
    // needed for serialization
    AbstractCell() {}

    @Override
    public boolean equals(@CheckForNull Object obj) {
      if (obj == this) {
        return true;
<A NAME="1"></A>      }
      if (obj instanceof Cell) {
        Cell&lt;?, ?, ?&gt; other = (Cell&lt;?, ?, ?&gt;) obj;
        return <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1161653-0.html#1',2,'match1161653-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Objects.equal(getRowKey(), other.getRowKey())
            &amp;&amp; Objects.equal(getColumnKey(), other.getColumnKey())
            &amp;&amp; Objects.equal(getValue(), other.getValue());
      }</B></FONT>
      return false;
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getRowKey(), getColumnKey(), getValue());
    }

    @Override
    public String toString() {
      return &quot;(&quot; + getRowKey() + &quot;,&quot; + getColumnKey() + &quot;)=&quot; + getValue();
    }
  }

  /**
   * Creates a transposed view of a given table that flips its row and column keys. In other words,
   * calling {@code get(columnKey, rowKey)} on the generated table always returns the same value as
   * calling {@code get(rowKey, columnKey)} on the original table. Updating the original table
   * changes the contents of the transposed table and vice versa.
   *
   * &lt;p&gt;The returned table supports update operations as long as the input table supports the
   * analogous operation with swapped rows and columns. For example, in a {@link HashBasedTable}
   * instance, {@code rowKeySet().iterator()} supports {@code remove()} but {@code
   * columnKeySet().iterator()} doesn't. With a transposed {@link HashBasedTable}, it's the other
   * way around.
   */
  public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      Table&lt;C, R, V&gt; transpose(Table&lt;R, C, V&gt; table) {
    return (table instanceof TransposeTable)
        ? ((TransposeTable&lt;R, C, V&gt;) table).original
        : new TransposeTable&lt;C, R, V&gt;(table);
  }

  private static class TransposeTable&lt;
          C extends @Nullable Object, R extends @Nullable Object, V extends @Nullable Object&gt;
      extends AbstractTable&lt;C, R, V&gt; {
    final Table&lt;R, C, V&gt; original;
<A NAME="3"></A>
    TransposeTable(Table&lt;R, C, V&gt; original) {
      this.original = checkNotNull(original);
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1161653-0.html#3',2,'match1161653-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public void clear() {
      original.clear();
    }

    @Overr</B></FONT>ide
    public Map&lt;C, V&gt; column(@ParametricNullness R columnKey) {
      return original.row(columnKey);
    }

    @Override
    public Set&lt;R&gt; columnKeySet() {
      return original.rowKeySet();
    }

    @Override
    public Map&lt;R, Map&lt;C, V&gt;&gt; columnMap() {
      return original.rowMap();
    }

    @Override
    public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      return original.contains(columnKey, rowKey);
    }

    @Override
    public boolean containsColumn(@CheckForNull Object columnKey) {
      return original.containsRow(columnKey);
    }

    @Override
    public boolean containsRow(@CheckForNull Object rowKey) {
      return original.containsColumn(rowKey);
    }

    @Override
    public boolean containsValue(@CheckForNull Object value) {
      return original.containsValue(value);
    }

    @Override
    @CheckForNull
    public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      return original.get(columnKey, rowKey);
    }

    @Override
    @CheckForNull
    public V put(
        @ParametricNullness C rowKey,
        @ParametricNullness R columnKey,
        @ParametricNullness V value) {
      return original.put(columnKey, rowKey, value);
    }

    @Override
    public void putAll(Table&lt;? extends C, ? extends R, ? extends V&gt; table) {
      original.putAll(transpose(table));
    }

    @Override
    @CheckForNull
    public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      return original.remove(columnKey, rowKey);
    }

    @Override
    public Map&lt;R, V&gt; row(@ParametricNullness C rowKey) {
      return original.column(rowKey);
    }

    @Override
    public Set&lt;C&gt; rowKeySet() {
      return original.columnKeySet();
    }

    @Override
    public Map&lt;C, Map&lt;R, V&gt;&gt; rowMap() {
      return original.columnMap();
    }

    @Override
    public int size() {
      return original.size();
    }

    @Override
    public Collection&lt;V&gt; values() {
      return original.values();
    }

    // Will cast TRANSPOSE_CELL to a type that always succeeds
    private static final Function&lt;Cell&lt;?, ?, ?&gt;, Cell&lt;?, ?, ?&gt;&gt; TRANSPOSE_CELL =
        new Function&lt;Cell&lt;?, ?, ?&gt;, Cell&lt;?, ?, ?&gt;&gt;() {
          @Override
          public Cell&lt;?, ?, ?&gt; apply(Cell&lt;?, ?, ?&gt; cell) {
            return immutableCell(cell.getColumnKey(), cell.getRowKey(), cell.getValue());
          }
        };

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    Iterator&lt;Cell&lt;C, R, V&gt;&gt; cellIterator() {
      return Iterators.transform(original.cellSet().iterator(), (Function) TRANSPOSE_CELL);
    }
  }

  /**
   * Creates a table that uses the specified backing map and factory. It can generate a table based
   * on arbitrary {@link Map} classes.
   *
   * &lt;p&gt;The {@code factory}-generated and {@code backingMap} classes determine the table iteration
   * order. However, the table's {@code row()} method returns instances of a different class than
   * {@code factory.get()} does.
   *
   * &lt;p&gt;Call this method only when the simpler factory methods in classes like {@link
   * HashBasedTable} and {@link TreeBasedTable} won't suffice.
   *
   * &lt;p&gt;The views returned by the {@code Table} methods {@link Table#column}, {@link
   * Table#columnKeySet}, and {@link Table#columnMap} have iterators that don't support {@code
   * remove()}. Otherwise, all optional operations are supported. Null row keys, columns keys, and
   * values are not supported.
   *
   * &lt;p&gt;Lookups by row key are often faster than lookups by column key, because the data is stored
   * in a {@code Map&lt;R, Map&lt;C, V&gt;&gt;}. A method call like {@code column(columnKey).get(rowKey)} still
   * runs quickly, since the row key is provided. However, {@code column(columnKey).size()} takes
   * longer, since an iteration across all row keys occurs.
   *
   * &lt;p&gt;Note that this implementation is not synchronized. If multiple threads access this table
   * concurrently and one of the threads modifies the table, it must be synchronized externally.
   *
   * &lt;p&gt;The table is serializable if {@code backingMap}, {@code factory}, the maps generated by
   * {@code factory}, and the table contents are all serializable.
   *
   * &lt;p&gt;Note: the table assumes complete ownership over of {@code backingMap} and the maps returned
   * by {@code factory}. Those objects should not be manually updated and they should not use soft,
   * weak, or phantom references.
   *
   * @param backingMap place to store the mapping from each row key to its corresponding column key
   *     / value map
   * @param factory supplier of new, empty maps that will each hold all column key / value mappings
   *     for a given row key
   * @throws IllegalArgumentException if {@code backingMap} is not empty
   * @since 10.0
   */
  @Beta
  public static &lt;R, C, V&gt; Table&lt;R, C, V&gt; newCustomTable(
      Map&lt;R, Map&lt;C, V&gt;&gt; backingMap, Supplier&lt;? extends Map&lt;C, V&gt;&gt; factory) {
    checkArgument(backingMap.isEmpty());
    checkNotNull(factory);
    // TODO(jlevy): Wrap factory to validate that the supplied maps are empty?
    return new StandardTable&lt;&gt;(backingMap, factory);
  }

  /**
   * Returns a view of a table where each value is transformed by a function. All other properties
   * of the table, such as iteration order, are left intact.
   *
   * &lt;p&gt;Changes in the underlying table are reflected in this view. Conversely, this view supports
   * removal operations, and these are reflected in the underlying table.
   *
   * &lt;p&gt;It's acceptable for the underlying table to contain null keys, and even null values provided
   * that the function is capable of accepting null input. The transformed table might contain null
   * values, if the function sometimes gives a null result.
   *
   * &lt;p&gt;The returned table is not thread-safe or serializable, even if the underlying table is.
   *
   * &lt;p&gt;The function is applied lazily, invoked when needed. This is necessary for the returned
   * table to be a view, but it means that the function will be applied many times for bulk
   * operations like {@link Table#containsValue} and {@code Table.toString()}. For this to perform
   * well, {@code function} should be fast. To avoid lazy evaluation when the returned table doesn't
   * need to be a view, copy the returned table into a new table of your choosing.
   *
   * @since 10.0
   */
  @Beta
  public static &lt;
          R extends @Nullable Object,
          C extends @Nullable Object,
          V1 extends @Nullable Object,
          V2 extends @Nullable Object&gt;
      Table&lt;R, C, V2&gt; transformValues(
          Table&lt;R, C, V1&gt; fromTable, Function&lt;? super V1, V2&gt; function) {
    return new TransformedTable&lt;&gt;(fromTable, function);
  }

  private static class TransformedTable&lt;
          R extends @Nullable Object,
          C extends @Nullable Object,
          V1 extends @Nullable Object,
          V2 extends @Nullable Object&gt;
      extends AbstractTable&lt;R, C, V2&gt; {
    final Table&lt;R, C, V1&gt; fromTable;
    final Function&lt;? super V1, V2&gt; function;

    TransformedTable(Table&lt;R, C, V1&gt; fromTable, Function&lt;? super V1, V2&gt; function) {
      this.fromTable = checkNotNull(fromTable);
      this.function = checkNotNull(function);
    }

    @Override
    public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      return fromTable.contains(rowKey, columnKey);
    }

    @Override
    @CheckForNull
    public V2 get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      // The function is passed a null input only when the table contains a null
      // value.
      // The cast is safe because of the contains() check.
      return contains(rowKey, columnKey)
          ? function.apply(uncheckedCastNullableTToT(fromTable.get(rowKey, columnKey)))
          : null;
    }

    @Override
    public int size() {
      return fromTable.size();
    }

    @Override
    public void clear() {
      fromTable.clear();
    }

    @Override
    @CheckForNull
    public V2 put(
        @ParametricNullness R rowKey,
        @ParametricNullness C columnKey,
        @ParametricNullness V2 value) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void putAll(Table&lt;? extends R, ? extends C, ? extends V2&gt; table) {
      throw new UnsupportedOperationException();
    }

    @Override
    @CheckForNull
    public V2 remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      return contains(rowKey, columnKey)
          // The cast is safe because of the contains() check.
          ? function.apply(uncheckedCastNullableTToT(fromTable.remove(rowKey, columnKey)))
          : null;
    }

    @Override
    public Map&lt;C, V2&gt; row(@ParametricNullness R rowKey) {
      return Maps.transformValues(fromTable.row(rowKey), function);
    }

    @Override
    public Map&lt;R, V2&gt; column(@ParametricNullness C columnKey) {
<A NAME="2"></A>      return Maps.transformValues(fromTable.column(columnKey), function);
    }

    Function&lt;Cell&lt;R, C, V1&gt;, Cell&lt;R, C, V2&gt;&gt; cellFunction() <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1161653-0.html#2',2,'match1161653-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
      return new Function&lt;Cell&lt;R, C, V1&gt;, Cell&lt;R, C, V2&gt;&gt;() {
        @Override
        public Cell&lt;R, C, V2&gt; apply(Cell&lt;R, C, V1&gt; cell) {
          return</B></FONT> immutableCell(
              cell.getRowKey(), cell.getColumnKey(), function.apply(cell.getValue()));
        }
      };
    }

    @Override
    Iterator&lt;Cell&lt;R, C, V2&gt;&gt; cellIterator() {
      return Iterators.transform(fromTable.cellSet().iterator(), cellFunction());
    }

    @Override
    public Set&lt;R&gt; rowKeySet() {
      return fromTable.rowKeySet();
    }

    @Override
    public Set&lt;C&gt; columnKeySet() {
      return fromTable.columnKeySet();
    }

    @Override
    Collection&lt;V2&gt; createValues() {
      return Collections2.transform(fromTable.values(), function);
    }

    @Override
    public Map&lt;R, Map&lt;C, V2&gt;&gt; rowMap() {
      Function&lt;Map&lt;C, V1&gt;, Map&lt;C, V2&gt;&gt; rowFunction =
          new Function&lt;Map&lt;C, V1&gt;, Map&lt;C, V2&gt;&gt;() {
            @Override
            public Map&lt;C, V2&gt; apply(Map&lt;C, V1&gt; row) {
              return Maps.transformValues(row, function);
            }
          };
      return Maps.transformValues(fromTable.rowMap(), rowFunction);
    }

    @Override
    public Map&lt;C, Map&lt;R, V2&gt;&gt; columnMap() {
      Function&lt;Map&lt;R, V1&gt;, Map&lt;R, V2&gt;&gt; columnFunction =
          new Function&lt;Map&lt;R, V1&gt;, Map&lt;R, V2&gt;&gt;() {
            @Override
            public Map&lt;R, V2&gt; apply(Map&lt;R, V1&gt; column) {
              return Maps.transformValues(column, function);
            }
          };
      return Maps.transformValues(fromTable.columnMap(), columnFunction);
    }
  }

  /**
   * Returns an unmodifiable view of the specified table. This method allows modules to provide
   * users with &quot;read-only&quot; access to internal tables. Query operations on the returned table &quot;read
   * through&quot; to the specified table, and attempts to modify the returned table, whether direct or
   * via its collection views, result in an {@code UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned table will be serializable if the specified table is serializable.
   *
   * &lt;p&gt;Consider using an {@link ImmutableTable}, which is guaranteed never to change.
   *
   * @since 11.0
   */
  public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      Table&lt;R, C, V&gt; unmodifiableTable(Table&lt;? extends R, ? extends C, ? extends V&gt; table) {
    return new UnmodifiableTable&lt;&gt;(table);
  }

  private static class UnmodifiableTable&lt;
          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      extends ForwardingTable&lt;R, C, V&gt; implements Serializable {
    final Table&lt;? extends R, ? extends C, ? extends V&gt; delegate;

    UnmodifiableTable(Table&lt;? extends R, ? extends C, ? extends V&gt; delegate) {
      this.delegate = checkNotNull(delegate);
    }

    @SuppressWarnings(&quot;unchecked&quot;) // safe, covariant cast
    @Override
    protected Table&lt;R, C, V&gt; delegate() {
      return (Table&lt;R, C, V&gt;) delegate;
    }

    @Override
    public Set&lt;Cell&lt;R, C, V&gt;&gt; cellSet() {
      return Collections.unmodifiableSet(super.cellSet());
    }

    @Override
    public void clear() {
      throw new UnsupportedOperationException();
    }

    @Override
    public Map&lt;R, V&gt; column(@ParametricNullness C columnKey) {
      return Collections.unmodifiableMap(super.column(columnKey));
    }

    @Override
    public Set&lt;C&gt; columnKeySet() {
      return Collections.unmodifiableSet(super.columnKeySet());
    }

    @Override
    public Map&lt;C, Map&lt;R, V&gt;&gt; columnMap() {
      Function&lt;Map&lt;R, V&gt;, Map&lt;R, V&gt;&gt; wrapper = unmodifiableWrapper();
      return Collections.unmodifiableMap(Maps.transformValues(super.columnMap(), wrapper));
    }

    @Override
    @CheckForNull
    public V put(
        @ParametricNullness R rowKey,
        @ParametricNullness C columnKey,
        @ParametricNullness V value) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void putAll(Table&lt;? extends R, ? extends C, ? extends V&gt; table) {
      throw new UnsupportedOperationException();
    }

    @Override
    @CheckForNull
    public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
      throw new UnsupportedOperationException();
    }

    @Override
    public Map&lt;C, V&gt; row(@ParametricNullness R rowKey) {
      return Collections.unmodifiableMap(super.row(rowKey));
    }

    @Override
    public Set&lt;R&gt; rowKeySet() {
      return Collections.unmodifiableSet(super.rowKeySet());
    }

    @Override
    public Map&lt;R, Map&lt;C, V&gt;&gt; rowMap() {
      Function&lt;Map&lt;C, V&gt;, Map&lt;C, V&gt;&gt; wrapper = unmodifiableWrapper();
      return Collections.unmodifiableMap(Maps.transformValues(super.rowMap(), wrapper));
    }

    @Override
    public Collection&lt;V&gt; values() {
      return Collections.unmodifiableCollection(super.values());
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns an unmodifiable view of the specified row-sorted table. This method allows modules to
   * provide users with &quot;read-only&quot; access to internal tables. Query operations on the returned
   * table &quot;read through&quot; to the specified table, and attempts to modify the returned table, whether
   * direct or via its collection views, result in an {@code UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned table will be serializable if the specified table is serializable.
   *
   * @param table the row-sorted table for which an unmodifiable view is to be returned
   * @return an unmodifiable view of the specified table
   * @since 11.0
   */
  @Beta
  public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      RowSortedTable&lt;R, C, V&gt; unmodifiableRowSortedTable(
          RowSortedTable&lt;R, ? extends C, ? extends V&gt; table) {
    /*
     * It's not ? extends R, because it's technically not covariant in R. Specifically,
     * table.rowMap().comparator() could return a comparator that only works for the ? extends R.
     * Collections.unmodifiableSortedMap makes the same distinction.
     */
    return new UnmodifiableRowSortedMap&lt;&gt;(table);
  }

  static final class UnmodifiableRowSortedMap&lt;
          R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      extends UnmodifiableTable&lt;R, C, V&gt; implements RowSortedTable&lt;R, C, V&gt; {

    public UnmodifiableRowSortedMap(RowSortedTable&lt;R, ? extends C, ? extends V&gt; delegate) {
      super(delegate);
    }

    @Override
    protected RowSortedTable&lt;R, C, V&gt; delegate() {
      return (RowSortedTable&lt;R, C, V&gt;) super.delegate();
    }

    @Override
    public SortedMap&lt;R, Map&lt;C, V&gt;&gt; rowMap() {
      Function&lt;Map&lt;C, V&gt;, Map&lt;C, V&gt;&gt; wrapper = unmodifiableWrapper();
      return Collections.unmodifiableSortedMap(Maps.transformValues(delegate().rowMap(), wrapper));
    }

    @Override
    public SortedSet&lt;R&gt; rowKeySet() {
      return Collections.unmodifiableSortedSet(delegate().rowKeySet());
    }

    private static final long serialVersionUID = 0;
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      Function&lt;Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; unmodifiableWrapper() {
    return (Function) UNMODIFIABLE_WRAPPER;
  }

  private static final Function&lt;? extends Map&lt;?, ?&gt;, ? extends Map&lt;?, ?&gt;&gt; UNMODIFIABLE_WRAPPER =
      new Function&lt;Map&lt;Object, Object&gt;, Map&lt;Object, Object&gt;&gt;() {
        @Override
        public Map&lt;Object, Object&gt; apply(Map&lt;Object, Object&gt; input) {
          return Collections.unmodifiableMap(input);
        }
      };

  /**
   * Returns a synchronized (thread-safe) table backed by the specified table. In order to guarantee
   * serial access, it is critical that &lt;b&gt;all&lt;/b&gt; access to the backing table is accomplished
   * through the returned table.
   *
   * &lt;p&gt;It is imperative that the user manually synchronize on the returned table when accessing any
   * of its collection views:
   *
   * &lt;pre&gt;{@code
   * Table&lt;R, C, V&gt; table = Tables.synchronizedTable(HashBasedTable.&lt;R, C, V&gt;create());
   * ...
   * Map&lt;C, V&gt; row = table.row(rowKey);  // Needn't be in synchronized block
   * ...
   * synchronized (table) {  // Synchronizing on table, not row!
   *   Iterator&lt;Entry&lt;C, V&gt;&gt; i = row.entrySet().iterator(); // Must be in synchronized block
   *   while (i.hasNext()) {
   *     foo(i.next());
   *   }
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Failure to follow this advice may result in non-deterministic behavior.
   *
   * &lt;p&gt;The returned table will be serializable if the specified table is serializable.
   *
   * @param table the table to be wrapped in a synchronized view
   * @return a synchronized view of the specified table
   * @since 22.0
   */
  public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
      Table&lt;R, C, V&gt; synchronizedTable(Table&lt;R, C, V&gt; table) {
    return Synchronized.table(table, null);
  }

  static boolean equalsImpl(Table&lt;?, ?, ?&gt; table, @CheckForNull Object obj) {
    if (obj == table) {
      return true;
    } else if (obj instanceof Table) {
      Table&lt;?, ?, ?&gt; that = (Table&lt;?, ?, ?&gt;) obj;
      return table.cellSet().equals(that.cellSet());
    } else {
      return false;
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
