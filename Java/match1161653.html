<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ExecutionSequencerTest.java &amp; Tables.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ExecutionSequencerTest.java &amp; Tables.java
      </h3>
<h1 align="center">
        6.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ExecutionSequencerTest.java (7.305936%)<th>Tables.java (5.498282%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-36)<td><a href="#" name="0">(17-38)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-73)<td><a href="#" name="1">(122-125)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(301-305)<td><a href="#" name="2">(427-431)</a><td align="center"><font color="#720000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(56-63)<td><a href="#" name="3">(166-173)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ExecutionSequencerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.util.concurrent;
2 import static com.google.common.truth.Truth.assertThat;
3 import static com.google.common.util.concurrent.Futures.allAsList;
4 import static com.google.common.util.concurrent.Futures.getDone;
5 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
6 import static java.util.concurrent.TimeUnit.SECONDS;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.base.Function;
9 import com.google.common.testing.GcFinalization;
10 import com.google.common.testing.TestLogHandler;
11 import com.google.j2objc.annotations.J2ObjCIncompatible;
12 import java.lang.ref.WeakReference;
13 import java.util.ArrayList;
14 import java.util.List;
15 import java.util.concurrent.Callable;
16 import java.util.concurrent.CountDownLatch;
17 import java.util.concurrent.Executor;
18 import java.util.concurrent.ExecutorService;
19 import java.util.concurrent.Executors;
20 import</b></font> java.util.concurrent.Future;
21 import java.util.concurrent.TimeUnit;
22 import java.util.logging.Logger;
23 import junit.framework.TestCase;
24 public class ExecutionSequencerTest extends TestCase {
25   ExecutorService executor;
26   private ExecutionSequencer serializer;
27   private SettableFuture&lt;Void&gt; firstFuture;
28   private TestCallable firstCallable;
29   @Override
30   public void setUp() throws Exception {
31     executor = Executors.newCachedThreadPool();
32 <a name="3"></a>    serializer = ExecutionSequencer.create();
33     firstFuture = SettableFuture.create();
34     firstCallable = new TestCallable(firstFuture);
35   <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
36   @Override
37   public void tearDown() throws Exception {
38     executor.shutdown();
39   }
40   public void testCallableStartsAfterFirstFut</b></font>ureCompletes() {
41     @SuppressWarnings({"unused", "nullness"})
42 <a name="1"></a>    Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
43     TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
44     @SuppressWarnings({"unused", "nullness"})
45     Future&lt;?&gt; possiblyIgnoredError1 = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>serializer.submitAsync(secondCallable, directExecutor());
46     assertThat(firstCallable.called).isTrue();
47     assertThat(secondCallable.called).isFalse();
48     firstFuture.set(null);
49     assertThat(secondCallable.called).isTrue();
50   }</b></font>
51   public void testCancellationDoesNotViolateSerialization() {
52     @SuppressWarnings({"unused", "nullness"})
53     Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
54     TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
55     ListenableFuture&lt;Void&gt; secondFuture = serializer.submitAsync(secondCallable, directExecutor());
56     TestCallable thirdCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
57     @SuppressWarnings({"unused", "nullness"})
58     Future&lt;?&gt; possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
59     secondFuture.cancel(true);
60     assertThat(secondCallable.called).isFalse();
61     assertThat(thirdCallable.called).isFalse();
62     firstFuture.set(null);
63     assertThat(secondCallable.called).isFalse();
64     assertThat(thirdCallable.called).isTrue();
65   }
66   public void testCancellationMultipleThreads() throws Exception {
67     final BlockingCallable blockingCallable = new BlockingCallable();
68     ListenableFuture&lt;Void&gt; unused = serializer.submit(blockingCallable, executor);
69     ListenableFuture&lt;Boolean&gt; future2 =
70         serializer.submit(
71             new Callable&lt;Boolean&gt;() {
72               @Override
73               public Boolean call() {
74                 return blockingCallable.isRunning();
75               }
76             },
77             directExecutor());
78     blockingCallable.waitForStart();
79     assertThat(future2.isDone()).isFalse();
80     blockingCallable.stop();
81     executor.shutdown();
82     assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
83     assertThat(getDone(future2)).isFalse();
84   }
85   public void testSecondTaskWaitsForFirstEvenIfCancelled() throws Exception {
86     final BlockingCallable blockingCallable = new BlockingCallable();
87     ListenableFuture&lt;Void&gt; future1 = serializer.submit(blockingCallable, executor);
88     ListenableFuture&lt;Boolean&gt; future2 =
89         serializer.submit(
90             new Callable&lt;Boolean&gt;() {
91               @Override
92               public Boolean call() {
93                 return blockingCallable.isRunning();
94               }
95             },
96             directExecutor());
97     blockingCallable.waitForStart();
98     future1.cancel(false);
99     assertThat(future2.isDone()).isFalse();
100     blockingCallable.stop();
101     executor.shutdown();
102     assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
103     assertThat(getDone(future2)).isFalse();
104   }
105   @GwtIncompatible
106   @J2ObjCIncompatible   @AndroidIncompatible
107   public void testCancellationWithReferencedObject() throws Exception {
108     Object toBeGCed = new Object();
109     WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(toBeGCed);
110     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
111     ListenableFuture&lt;?&gt; ignored =
112         serializer.submitAsync(
113             new AsyncCallable&lt;Void&gt;() {
114               @Override
115               public ListenableFuture&lt;Void&gt; call() {
116                 return settableFuture;
117               }
118             },
119             directExecutor());
120     serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
121     toBeGCed = null;
122     GcFinalization.awaitClear(ref);
123   }
124   private static Callable&lt;String&gt; toStringCallable(final Object object) {
125     return new Callable&lt;String&gt;() {
126       @Override
127       public String call() {
128         return object.toString();
129       }
130     };
131   }
132   public void testCancellationDuringReentrancy() throws Exception {
133     TestLogHandler logHandler = new TestLogHandler();
134     Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
135     List&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;&gt;();
136     final Runnable[] manualExecutorTask = new Runnable[1];
137     Executor manualExecutor =
138         new Executor() {
139           @Override
140           public void execute(Runnable task) {
141             manualExecutorTask[0] = task;
142           }
143         };
144     results.add(serializer.submit(Callables.returning(null), manualExecutor));
145     final Future&lt;?&gt;[] thingToCancel = new Future&lt;?&gt;[1];
146     results.add(
147         serializer.submit(
148             new Callable&lt;Void&gt;() {
149               @Override
150               public Void call() {
151                 thingToCancel[0].cancel(false);
152                 return null;
153               }
154             },
155             directExecutor()));
156     thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
157     results.add(thingToCancel[0]);
158     for (int i = 0; i &lt; 5; i++) {
159       results.add(serializer.submit(Callables.returning(null), directExecutor()));
160     }
161     manualExecutorTask[0].run();
162     for (Future&lt;?&gt; result : results) {
163       if (!result.isCancelled()) {
164         result.get(10, SECONDS);
165       }
166     }
167     assertThat(logHandler.getStoredLogRecords()).isEmpty();
168   }
169   public void testAvoidsStackOverflow_manySubmitted() throws Exception {
170     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
171     ArrayList&lt;ListenableFuture&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;(50_001);
172     results.add(
173         serializer.submitAsync(
174             new AsyncCallable&lt;Void&gt;() {
175               @Override
176               public ListenableFuture&lt;Void&gt; call() {
177                 return settableFuture;
178               }
179             },
180             directExecutor()));
181     for (int i = 0; i &lt; 50_000; i++) {
182       results.add(serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()));
183     }
184     settableFuture.set(null);
185     getDone(allAsList(results));
186   }
187   public void testAvoidsStackOverflow_manyCancelled() throws Exception {
188     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
189     ListenableFuture&lt;Void&gt; unused =
190         serializer.submitAsync(
191             new AsyncCallable&lt;Void&gt;() {
192               @Override
193               public ListenableFuture&lt;Void&gt; call() {
194                 return settableFuture;
195               }
196             },
197             directExecutor());
198     for (int i = 0; i &lt; 50_000; i++) {
199       serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
200     }
201     ListenableFuture&lt;Integer&gt; stackDepthCheck =
202         serializer.submit(
203             new Callable&lt;Integer&gt;() {
204               @Override
205               public Integer call() {
206                 return Thread.currentThread().getStackTrace().length;
207               }
208             },
209             directExecutor());
210     settableFuture.set(null);
211     assertThat(getDone(stackDepthCheck))
212         .isLessThan(Thread.currentThread().getStackTrace().length + 100);
213   }
214   public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
215     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
216     ListenableFuture&lt;Void&gt; unused =
217         serializer.submitAsync(
218             new AsyncCallable&lt;Void&gt;() {
219               @Override
220               public ListenableFuture&lt;Void&gt; call() {
221                 return settableFuture;
222               }
223             },
224             directExecutor());
225     for (int i = 0; i &lt; 25_000; i++) {
226       serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
227       unused = serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor());
228     }
229     ListenableFuture&lt;Integer&gt; stackDepthCheck =
230         serializer.submit(
231             new Callable&lt;Integer&gt;() {
232               @Override
233               public Integer call() {
234                 return Thread.currentThread().getStackTrace().length;
235               }
236             },
237             directExecutor());
238     settableFuture.set(null);
239     assertThat(getDone(stackDepthCheck))
240 <a name="2"></a>        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
241   }
242   private static Function&lt;Integer, Integer&gt; add(final int delta) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
243     return new Function&lt;Integer, Integer&gt;() {
244       @Override
245       public Integer apply(Integer input) {
246         return</b></font> input + delta;
247       }
248     };
249   }
250   private static AsyncCallable&lt;Integer&gt; asyncAdd(
251       final ListenableFuture&lt;Integer&gt; future, final int delta, final Executor executor) {
252     return new AsyncCallable&lt;Integer&gt;() {
253       @Override
254       public ListenableFuture&lt;Integer&gt; call() throws Exception {
255         return Futures.transform(future, add(delta), executor);
256       }
257     };
258   }
259   private static final class LongHolder {
260     long count;
261   }
262   private static final int ITERATION_COUNT = 50_000;
263   private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
264   @GwtIncompatible   public void testAvoidsStackOverflow_multipleThreads() throws Exception {
265     final LongHolder holder = new LongHolder();
266     final ArrayList&lt;ListenableFuture&lt;Integer&gt;&gt; lengthChecks = new ArrayList&lt;&gt;();
267     final List&lt;Integer&gt; completeLengthChecks;
268     final int baseStackDepth;
269     ExecutorService service = Executors.newFixedThreadPool(5);
270     try {
271       baseStackDepth =
272           serializer
273               .submit(
274                   new Callable&lt;Integer&gt;() {
275                     @Override
276                     public Integer call() {
277                       return Thread.currentThread().getStackTrace().length;
278                     }
279                   },
280                   service)
281               .get();
282       final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
283       ListenableFuture&lt;?&gt; unused =
284           serializer.submitAsync(
285               new AsyncCallable&lt;Void&gt;() {
286                 @Override
287                 public ListenableFuture&lt;Void&gt; call() {
288                   return settableFuture;
289                 }
290               },
291               directExecutor());
292       for (int i = 0; i &lt; 50_000; i++) {
293         if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
294           unused =
295               serializer.submit(
296                   new Callable&lt;Void&gt;() {
297                     @Override
298                     public Void call() {
299                       holder.count++;
300                       return null;
301                     }
302                   },
303                   service);
304         } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
305           lengthChecks.add(
306               serializer.submit(
307                   new Callable&lt;Integer&gt;() {
308                     @Override
309                     public Integer call() {
310                       holder.count++;
311                       return Thread.currentThread().getStackTrace().length;
312                     }
313                   },
314                   directExecutor()));
315         } else {
316           unused =
317               serializer.submit(
318                   new Callable&lt;Void&gt;() {
319                     @Override
320                     public Void call() {
321                       holder.count++;
322                       return null;
323                     }
324                   },
325                   directExecutor());
326         }
327       }
328       settableFuture.set(null);
329       completeLengthChecks = allAsList(lengthChecks).get();
330     } finally {
331       service.shutdown();
332     }
333     assertThat(holder.count).isEqualTo(ITERATION_COUNT);
334     for (int length : completeLengthChecks) {
335       assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
336     }
337   }
338   @SuppressWarnings("ObjectToString")   public void testToString() {
339     Future&lt;?&gt; unused = serializer.submitAsync(firstCallable, directExecutor());
340     TestCallable secondCallable = new TestCallable(SettableFuture.&lt;Void&gt;create());
341     Future&lt;?&gt; second = serializer.submitAsync(secondCallable, directExecutor());
342     assertThat(secondCallable.called).isFalse();
343     assertThat(second.toString()).contains(secondCallable.toString());
344     firstFuture.set(null);
345     assertThat(second.toString()).contains(secondCallable.future.toString());
346   }
347   private static class BlockingCallable implements Callable&lt;Void&gt; {
348     private final CountDownLatch startLatch = new CountDownLatch(1);
349     private final CountDownLatch stopLatch = new CountDownLatch(1);
350     private volatile boolean running = false;
351     @Override
352     public Void call() throws InterruptedException {
353       running = true;
354       startLatch.countDown();
355       stopLatch.await();
356       running = false;
357       return null;
358     }
359     public void waitForStart() throws InterruptedException {
360       startLatch.await();
361     }
362     public void stop() {
363       stopLatch.countDown();
364     }
365     public boolean isRunning() {
366       return running;
367     }
368   }
369   private static final class TestCallable implements AsyncCallable&lt;Void&gt; {
370     private final ListenableFuture&lt;Void&gt; future;
371     private boolean called = false;
372     private TestCallable(ListenableFuture&lt;Void&gt; future) {
373       this.future = future;
374     }
375     @Override
376     public ListenableFuture&lt;Void&gt; call() throws Exception {
377       called = true;
378       return future;
379     }
380   }
381 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Tables.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
5 import com.google.common.annotations.Beta;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.base.Function;
8 import com.google.common.base.Objects;
9 import com.google.common.base.Supplier;
10 import com.google.common.collect.Table.Cell;
11 import java.io.Serializable;
12 import java.util.Collection;
13 import java.util.Collections;
14 import java.util.Iterator;
15 import java.util.Map;
16 import java.util.Set;
17 import java.util.SortedMap;
18 import java.util.SortedSet;
19 import javax.annotation.CheckForNull;
20 import</b></font> org.checkerframework.checker.nullness.qual.Nullable;
21 @GwtCompatible
22 @ElementTypesAreNonnullByDefault
23 public final class Tables {
24   private Tables() {}
25   public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
26       Cell&lt;R, C, V&gt; immutableCell(
27           @ParametricNullness R rowKey,
28           @ParametricNullness C columnKey,
29           @ParametricNullness V value) {
30     return new ImmutableCell&lt;&gt;(rowKey, columnKey, value);
31   }
32   static final class ImmutableCell&lt;
33           R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
34       extends AbstractCell&lt;R, C, V&gt; implements Serializable {
35     @ParametricNullness private final R rowKey;
36     @ParametricNullness private final C columnKey;
37     @ParametricNullness private final V value;
38     ImmutableCell(
39         @ParametricNullness R rowKey,
40         @ParametricNullness C columnKey,
41         @ParametricNullness V value) {
42       this.rowKey = rowKey;
43       this.columnKey = columnKey;
44       this.value = value;
45     }
46     @Override
47     @ParametricNullness
48     public R getRowKey() {
49       return rowKey;
50     }
51     @Override
52     @ParametricNullness
53     public C getColumnKey() {
54       return columnKey;
55     }
56     @Override
57     @ParametricNullness
58     public V getValue() {
59       return value;
60     }
61     private static final long serialVersionUID = 0;
62   }
63   abstract static class AbstractCell&lt;
64           R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
65       implements Cell&lt;R, C, V&gt; {
66     AbstractCell() {}
67     @Override
68     public boolean equals(@CheckForNull Object obj) {
69       if (obj == this) {
70         return true;
71 <a name="1"></a>      }
72       if (obj instanceof Cell) {
73         Cell&lt;?, ?, ?&gt; other = (Cell&lt;?, ?, ?&gt;) obj;
74         return <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Objects.equal(getRowKey(), other.getRowKey())
75             &amp;&amp; Objects.equal(getColumnKey(), other.getColumnKey())
76             &amp;&amp; Objects.equal(getValue(), other.getValue());
77       }</b></font>
78       return false;
79     }
80     @Override
81     public int hashCode() {
82       return Objects.hashCode(getRowKey(), getColumnKey(), getValue());
83     }
84     @Override
85     public String toString() {
86       return "(" + getRowKey() + "," + getColumnKey() + ")=" + getValue();
87     }
88   }
89   public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
90       Table&lt;C, R, V&gt; transpose(Table&lt;R, C, V&gt; table) {
91     return (table instanceof TransposeTable)
92         ? ((TransposeTable&lt;R, C, V&gt;) table).original
93         : new TransposeTable&lt;C, R, V&gt;(table);
94   }
95   private static class TransposeTable&lt;
96           C extends @Nullable Object, R extends @Nullable Object, V extends @Nullable Object&gt;
97       extends AbstractTable&lt;C, R, V&gt; {
98     final Table&lt;R, C, V&gt; original;
99 <a name="3"></a>
100     TransposeTable(Table&lt;R, C, V&gt; original) {
101       this.original = checkNotNull(original);
102     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
103     @Override
104     public void clear() {
105       original.clear();
106     }
107     @Overr</b></font>ide
108     public Map&lt;C, V&gt; column(@ParametricNullness R columnKey) {
109       return original.row(columnKey);
110     }
111     @Override
112     public Set&lt;R&gt; columnKeySet() {
113       return original.rowKeySet();
114     }
115     @Override
116     public Map&lt;R, Map&lt;C, V&gt;&gt; columnMap() {
117       return original.rowMap();
118     }
119     @Override
120     public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
121       return original.contains(columnKey, rowKey);
122     }
123     @Override
124     public boolean containsColumn(@CheckForNull Object columnKey) {
125       return original.containsRow(columnKey);
126     }
127     @Override
128     public boolean containsRow(@CheckForNull Object rowKey) {
129       return original.containsColumn(rowKey);
130     }
131     @Override
132     public boolean containsValue(@CheckForNull Object value) {
133       return original.containsValue(value);
134     }
135     @Override
136     @CheckForNull
137     public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
138       return original.get(columnKey, rowKey);
139     }
140     @Override
141     @CheckForNull
142     public V put(
143         @ParametricNullness C rowKey,
144         @ParametricNullness R columnKey,
145         @ParametricNullness V value) {
146       return original.put(columnKey, rowKey, value);
147     }
148     @Override
149     public void putAll(Table&lt;? extends C, ? extends R, ? extends V&gt; table) {
150       original.putAll(transpose(table));
151     }
152     @Override
153     @CheckForNull
154     public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
155       return original.remove(columnKey, rowKey);
156     }
157     @Override
158     public Map&lt;R, V&gt; row(@ParametricNullness C rowKey) {
159       return original.column(rowKey);
160     }
161     @Override
162     public Set&lt;C&gt; rowKeySet() {
163       return original.columnKeySet();
164     }
165     @Override
166     public Map&lt;C, Map&lt;R, V&gt;&gt; rowMap() {
167       return original.columnMap();
168     }
169     @Override
170     public int size() {
171       return original.size();
172     }
173     @Override
174     public Collection&lt;V&gt; values() {
175       return original.values();
176     }
177     private static final Function&lt;Cell&lt;?, ?, ?&gt;, Cell&lt;?, ?, ?&gt;&gt; TRANSPOSE_CELL =
178         new Function&lt;Cell&lt;?, ?, ?&gt;, Cell&lt;?, ?, ?&gt;&gt;() {
179           @Override
180           public Cell&lt;?, ?, ?&gt; apply(Cell&lt;?, ?, ?&gt; cell) {
181             return immutableCell(cell.getColumnKey(), cell.getRowKey(), cell.getValue());
182           }
183         };
184     @SuppressWarnings("unchecked")
185     @Override
186     Iterator&lt;Cell&lt;C, R, V&gt;&gt; cellIterator() {
187       return Iterators.transform(original.cellSet().iterator(), (Function) TRANSPOSE_CELL);
188     }
189   }
190   @Beta
191   public static &lt;R, C, V&gt; Table&lt;R, C, V&gt; newCustomTable(
192       Map&lt;R, Map&lt;C, V&gt;&gt; backingMap, Supplier&lt;? extends Map&lt;C, V&gt;&gt; factory) {
193     checkArgument(backingMap.isEmpty());
194     checkNotNull(factory);
195     return new StandardTable&lt;&gt;(backingMap, factory);
196   }
197   @Beta
198   public static &lt;
199           R extends @Nullable Object,
200           C extends @Nullable Object,
201           V1 extends @Nullable Object,
202           V2 extends @Nullable Object&gt;
203       Table&lt;R, C, V2&gt; transformValues(
204           Table&lt;R, C, V1&gt; fromTable, Function&lt;? super V1, V2&gt; function) {
205     return new TransformedTable&lt;&gt;(fromTable, function);
206   }
207   private static class TransformedTable&lt;
208           R extends @Nullable Object,
209           C extends @Nullable Object,
210           V1 extends @Nullable Object,
211           V2 extends @Nullable Object&gt;
212       extends AbstractTable&lt;R, C, V2&gt; {
213     final Table&lt;R, C, V1&gt; fromTable;
214     final Function&lt;? super V1, V2&gt; function;
215     TransformedTable(Table&lt;R, C, V1&gt; fromTable, Function&lt;? super V1, V2&gt; function) {
216       this.fromTable = checkNotNull(fromTable);
217       this.function = checkNotNull(function);
218     }
219     @Override
220     public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
221       return fromTable.contains(rowKey, columnKey);
222     }
223     @Override
224     @CheckForNull
225     public V2 get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
226       return contains(rowKey, columnKey)
227           ? function.apply(uncheckedCastNullableTToT(fromTable.get(rowKey, columnKey)))
228           : null;
229     }
230     @Override
231     public int size() {
232       return fromTable.size();
233     }
234     @Override
235     public void clear() {
236       fromTable.clear();
237     }
238     @Override
239     @CheckForNull
240     public V2 put(
241         @ParametricNullness R rowKey,
242         @ParametricNullness C columnKey,
243         @ParametricNullness V2 value) {
244       throw new UnsupportedOperationException();
245     }
246     @Override
247     public void putAll(Table&lt;? extends R, ? extends C, ? extends V2&gt; table) {
248       throw new UnsupportedOperationException();
249     }
250     @Override
251     @CheckForNull
252     public V2 remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
253       return contains(rowKey, columnKey)
254           ? function.apply(uncheckedCastNullableTToT(fromTable.remove(rowKey, columnKey)))
255           : null;
256     }
257     @Override
258     public Map&lt;C, V2&gt; row(@ParametricNullness R rowKey) {
259       return Maps.transformValues(fromTable.row(rowKey), function);
260     }
261     @Override
262     public Map&lt;R, V2&gt; column(@ParametricNullness C columnKey) {
263 <a name="2"></a>      return Maps.transformValues(fromTable.column(columnKey), function);
264     }
265     Function&lt;Cell&lt;R, C, V1&gt;, Cell&lt;R, C, V2&gt;&gt; cellFunction() <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
266       return new Function&lt;Cell&lt;R, C, V1&gt;, Cell&lt;R, C, V2&gt;&gt;() {
267         @Override
268         public Cell&lt;R, C, V2&gt; apply(Cell&lt;R, C, V1&gt; cell) {
269           return</b></font> immutableCell(
270               cell.getRowKey(), cell.getColumnKey(), function.apply(cell.getValue()));
271         }
272       };
273     }
274     @Override
275     Iterator&lt;Cell&lt;R, C, V2&gt;&gt; cellIterator() {
276       return Iterators.transform(fromTable.cellSet().iterator(), cellFunction());
277     }
278     @Override
279     public Set&lt;R&gt; rowKeySet() {
280       return fromTable.rowKeySet();
281     }
282     @Override
283     public Set&lt;C&gt; columnKeySet() {
284       return fromTable.columnKeySet();
285     }
286     @Override
287     Collection&lt;V2&gt; createValues() {
288       return Collections2.transform(fromTable.values(), function);
289     }
290     @Override
291     public Map&lt;R, Map&lt;C, V2&gt;&gt; rowMap() {
292       Function&lt;Map&lt;C, V1&gt;, Map&lt;C, V2&gt;&gt; rowFunction =
293           new Function&lt;Map&lt;C, V1&gt;, Map&lt;C, V2&gt;&gt;() {
294             @Override
295             public Map&lt;C, V2&gt; apply(Map&lt;C, V1&gt; row) {
296               return Maps.transformValues(row, function);
297             }
298           };
299       return Maps.transformValues(fromTable.rowMap(), rowFunction);
300     }
301     @Override
302     public Map&lt;C, Map&lt;R, V2&gt;&gt; columnMap() {
303       Function&lt;Map&lt;R, V1&gt;, Map&lt;R, V2&gt;&gt; columnFunction =
304           new Function&lt;Map&lt;R, V1&gt;, Map&lt;R, V2&gt;&gt;() {
305             @Override
306             public Map&lt;R, V2&gt; apply(Map&lt;R, V1&gt; column) {
307               return Maps.transformValues(column, function);
308             }
309           };
310       return Maps.transformValues(fromTable.columnMap(), columnFunction);
311     }
312   }
313   public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
314       Table&lt;R, C, V&gt; unmodifiableTable(Table&lt;? extends R, ? extends C, ? extends V&gt; table) {
315     return new UnmodifiableTable&lt;&gt;(table);
316   }
317   private static class UnmodifiableTable&lt;
318           R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
319       extends ForwardingTable&lt;R, C, V&gt; implements Serializable {
320     final Table&lt;? extends R, ? extends C, ? extends V&gt; delegate;
321     UnmodifiableTable(Table&lt;? extends R, ? extends C, ? extends V&gt; delegate) {
322       this.delegate = checkNotNull(delegate);
323     }
324     @SuppressWarnings("unchecked")     @Override
325     protected Table&lt;R, C, V&gt; delegate() {
326       return (Table&lt;R, C, V&gt;) delegate;
327     }
328     @Override
329     public Set&lt;Cell&lt;R, C, V&gt;&gt; cellSet() {
330       return Collections.unmodifiableSet(super.cellSet());
331     }
332     @Override
333     public void clear() {
334       throw new UnsupportedOperationException();
335     }
336     @Override
337     public Map&lt;R, V&gt; column(@ParametricNullness C columnKey) {
338       return Collections.unmodifiableMap(super.column(columnKey));
339     }
340     @Override
341     public Set&lt;C&gt; columnKeySet() {
342       return Collections.unmodifiableSet(super.columnKeySet());
343     }
344     @Override
345     public Map&lt;C, Map&lt;R, V&gt;&gt; columnMap() {
346       Function&lt;Map&lt;R, V&gt;, Map&lt;R, V&gt;&gt; wrapper = unmodifiableWrapper();
347       return Collections.unmodifiableMap(Maps.transformValues(super.columnMap(), wrapper));
348     }
349     @Override
350     @CheckForNull
351     public V put(
352         @ParametricNullness R rowKey,
353         @ParametricNullness C columnKey,
354         @ParametricNullness V value) {
355       throw new UnsupportedOperationException();
356     }
357     @Override
358     public void putAll(Table&lt;? extends R, ? extends C, ? extends V&gt; table) {
359       throw new UnsupportedOperationException();
360     }
361     @Override
362     @CheckForNull
363     public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
364       throw new UnsupportedOperationException();
365     }
366     @Override
367     public Map&lt;C, V&gt; row(@ParametricNullness R rowKey) {
368       return Collections.unmodifiableMap(super.row(rowKey));
369     }
370     @Override
371     public Set&lt;R&gt; rowKeySet() {
372       return Collections.unmodifiableSet(super.rowKeySet());
373     }
374     @Override
375     public Map&lt;R, Map&lt;C, V&gt;&gt; rowMap() {
376       Function&lt;Map&lt;C, V&gt;, Map&lt;C, V&gt;&gt; wrapper = unmodifiableWrapper();
377       return Collections.unmodifiableMap(Maps.transformValues(super.rowMap(), wrapper));
378     }
379     @Override
380     public Collection&lt;V&gt; values() {
381       return Collections.unmodifiableCollection(super.values());
382     }
383     private static final long serialVersionUID = 0;
384   }
385   @Beta
386   public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
387       RowSortedTable&lt;R, C, V&gt; unmodifiableRowSortedTable(
388           RowSortedTable&lt;R, ? extends C, ? extends V&gt; table) {
389     return new UnmodifiableRowSortedMap&lt;&gt;(table);
390   }
391   static final class UnmodifiableRowSortedMap&lt;
392           R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
393       extends UnmodifiableTable&lt;R, C, V&gt; implements RowSortedTable&lt;R, C, V&gt; {
394     public UnmodifiableRowSortedMap(RowSortedTable&lt;R, ? extends C, ? extends V&gt; delegate) {
395       super(delegate);
396     }
397     @Override
398     protected RowSortedTable&lt;R, C, V&gt; delegate() {
399       return (RowSortedTable&lt;R, C, V&gt;) super.delegate();
400     }
401     @Override
402     public SortedMap&lt;R, Map&lt;C, V&gt;&gt; rowMap() {
403       Function&lt;Map&lt;C, V&gt;, Map&lt;C, V&gt;&gt; wrapper = unmodifiableWrapper();
404       return Collections.unmodifiableSortedMap(Maps.transformValues(delegate().rowMap(), wrapper));
405     }
406     @Override
407     public SortedSet&lt;R&gt; rowKeySet() {
408       return Collections.unmodifiableSortedSet(delegate().rowKeySet());
409     }
410     private static final long serialVersionUID = 0;
411   }
412   @SuppressWarnings("unchecked")
413   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
414       Function&lt;Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; unmodifiableWrapper() {
415     return (Function) UNMODIFIABLE_WRAPPER;
416   }
417   private static final Function&lt;? extends Map&lt;?, ?&gt;, ? extends Map&lt;?, ?&gt;&gt; UNMODIFIABLE_WRAPPER =
418       new Function&lt;Map&lt;Object, Object&gt;, Map&lt;Object, Object&gt;&gt;() {
419         @Override
420         public Map&lt;Object, Object&gt; apply(Map&lt;Object, Object&gt; input) {
421           return Collections.unmodifiableMap(input);
422         }
423       };
424   public static &lt;R extends @Nullable Object, C extends @Nullable Object, V extends @Nullable Object&gt;
425       Table&lt;R, C, V&gt; synchronizedTable(Table&lt;R, C, V&gt; table) {
426     return Synchronized.table(table, null);
427   }
428   static boolean equalsImpl(Table&lt;?, ?, ?&gt; table, @CheckForNull Object obj) {
429     if (obj == table) {
430       return true;
431     } else if (obj instanceof Table) {
432       Table&lt;?, ?, ?&gt; that = (Table&lt;?, ?, ?&gt;) obj;
433       return table.cellSet().equals(that.cellSet());
434     } else {
435       return false;
436     }
437   }
438 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
