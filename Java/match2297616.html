<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for KeywordFieldMapper.java &amp; UserDefinedFunctionsIntegrationTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for KeywordFieldMapper.java &amp; UserDefinedFunctionsIntegrationTest.java
      </h3>
<h1 align="center">
        9.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>KeywordFieldMapper.java (10.473816%)<th>UserDefinedFunctionsIntegrationTest.java (9.150327%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-42)<td><a href="#" name="0">(22-41)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(286-294)<td><a href="#" name="1">(82-90)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(133-146)<td><a href="#" name="2">(92-100)</a><td align="center"><font color="#930000">11</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KeywordFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<a name="0"></a> * under the License.
 */

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.index.mapper;

import static org.elasticsearch.index.mapper.TypeParsers.parseField;

import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import javax.annotation.Nullable;

import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.SortedSetDocValuesField;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentParser;
import</b></font> org.elasticsearch.common.xcontent.support.XContentMapValues;

/**
 * A field mapper for keywords. This mapper accepts strings and indexes them as-is.
 */
public final class KeywordFieldMapper extends FieldMapper {

    public static final String CONTENT_TYPE = "keyword";

    public static class Defaults {
        public static final FieldType FIELD_TYPE = new FieldType();

        static {
            FIELD_TYPE.setTokenized(false);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
            FIELD_TYPE.freeze();
        }

        public static final String NULL_VALUE = null;
        public static final int IGNORE_ABOVE = Integer.MAX_VALUE;
    }

    public static class KeywordField extends Field {

        public KeywordField(String field, BytesRef term, FieldType ft) {
            super(field, term, ft);
        }

        public KeywordField(String field, BytesRef term) {
            super(field, term, Defaults.FIELD_TYPE);
        }
    }

    public static class Builder extends FieldMapper.Builder&lt;Builder&gt; {

        protected String nullValue = Defaults.NULL_VALUE;
        protected int ignoreAbove = Defaults.IGNORE_ABOVE;
        private Integer lengthLimit;

        public Builder(String name) {
            super(name, Defaults.FIELD_TYPE);
            builder = this;
        }

        public Builder ignoreAbove(int ignoreAbove) {
            if (ignoreAbove &lt; 0) {
                throw new IllegalArgumentException("[ignore_above] must be positive, got " + ignoreAbove);
            }
            this.ignoreAbove = ignoreAbove;
            return this;
        }

        public Builder lengthLimit(int lengthLimit) {
            if (lengthLimit &lt; 0) {
                throw new IllegalArgumentException("[legnth_limit] must be positive, got " + lengthLimit);
            }
            this.lengthLimit = lengthLimit;
            return this;
        }

        @Override
        public Builder indexOptions(IndexOptions indexOptions) {
            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) &gt; 0) {
                throw new IllegalArgumentException("The [keyword] field does not support positions, got [index_options]="
                        + indexOptionToString(indexOptions));
            }
            return super.indexOptions(indexOptions);
        }

        public Builder nullValue(String nullValue) {
            this.nullValue = nullValue;
            return builder;
        }

        private KeywordFieldType buildFieldType(BuilderContext context) {
            return new KeywordFieldType(
                buildFullName(context),
                indexed,
                hasDocValues,
                fieldType.omitNorms() == false
            );
        }

        @Override
        public KeywordFieldMapper build(BuilderContext context) {
            return new KeywordFieldMapper(
                name,
<a name="2"></a>                position,
                defaultExpression,
                fieldType,
                <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>buildFieldType(context),
                ignoreAbove,
                nullValue,
                lengthLimit,
                context.indexSettings(),
                multiFieldsBuilder.build(this, context),
                copyTo
            );
        }
    }

    public static class TypeParser implements Mapper.TypeParser {
        @Override
        public Mapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node</b></font>, ParserContext parserContext) throws MapperParsingException {
            KeywordFieldMapper.Builder builder = new KeywordFieldMapper.Builder(name);
            parseField(builder, name, node, parserContext);
            for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = node.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry&lt;String, Object&gt; entry = iterator.next();
                String propName = entry.getKey();
                Object propNode = entry.getValue();
                if (propName.equals("ignore_above")) {
                    builder.ignoreAbove(XContentMapValues.nodeIntegerValue(propNode, -1));
                    iterator.remove();
                } else if (propName.equals("length_limit")) {
                    builder.lengthLimit(XContentMapValues.nodeIntegerValue(propNode, -1));
                    iterator.remove();
                }
            }
            return builder;
        }
    }

    public static final class KeywordFieldType extends StringFieldType {

        boolean hasNorms;

        public KeywordFieldType(String name,
                                boolean isSearchable,
                                boolean hasDocValues,
                                boolean hasNorms) {
            super(name, isSearchable, hasDocValues);
            this.hasNorms = hasNorms;
            setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
            setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
        }

        public KeywordFieldType(String name, boolean isSearchable, boolean hasDocValues) {
            this(name, isSearchable, hasDocValues, true);
        }

        public KeywordFieldType(String name) {
            this(name, true, true);
        }


        @Override
        public String typeName() {
            return CONTENT_TYPE;
        }

        @Override
        protected BytesRef indexedValueForSearch(Object value) {
            if (searchAnalyzer() == Lucene.KEYWORD_ANALYZER) {
                // keyword analyzer with the default attribute source which encodes terms using UTF8
                // in that case we skip normalization, which may be slow if there many terms need to
                // parse (eg. large terms query) since Analyzer.normalize involves things like creating
                // attributes through reflection
                // This if statement will be used whenever a normalizer is NOT configured
                return super.indexedValueForSearch(value);
            }

            if (value == null) {
                return null;
            }
            if (value instanceof BytesRef) {
                value = ((BytesRef) value).utf8ToString();
            }
            return searchAnalyzer().normalize(name(), value.toString());
        }
    }

    private int ignoreAbove;
    private Integer lengthLimit;
    private String nullValue;


    protected KeywordFieldMapper(String simpleName,
                                 Integer position,
                                 @Nullable String defaultExpression,
                                 FieldType fieldType,
                                 MappedFieldType mappedFieldType,
                                 int ignoreAbove,
                                 String nullValue,
                                 Integer lengthLimit,
                                 Settings indexSettings,
                                 MultiFields multiFields,
                                 CopyTo copyTo) {
        super(simpleName, position, defaultExpression, fieldType, mappedFieldType, indexSettings, multiFields, copyTo);
        assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) &lt;= 0;
        this.ignoreAbove = ignoreAbove;
        this.lengthLimit = lengthLimit;
        this.nullValue = nullValue;
    }

    /** Values that have more chars than the return value of this method will
     *  be skipped at parsing time. */
    // pkg-private for testing
    int ignoreAbove() {
        return ignoreAbove;
    }

    @Override
    protected KeywordFieldMapper clone() {
        return (KeywordFieldMapper) super.clone();
    }

    @Override
    public KeywordFieldType fieldType() {
        return (KeywordFieldType) super.fieldType();
    }

    @Override
    protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
        String value;
        if (context.externalValueSet()) {
            value = context.externalValue().toString();
        } else {
            XContentParser parser = context.parser();
            if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {
                value = nullValue;
            } else {
                value = parser.textOrNull();
            }
        }

        if (value == null || value.length() &gt; ignoreAbove) {
            return;
        }

        // convert to utf8 only once before feeding postings/dv/stored fields
        final BytesRef binaryValue = new BytesRef(value);
        if (fieldType.indexOptions() != IndexOptions.NONE || fieldType.stored()) {
            Field field = new Field(fieldType().name(), binaryValue, fieldType);
            fields.add(field);

            if (fieldType().hasDocValues() == false &amp;&amp; fieldType.omitNorms()) {
                createFieldNamesField(context, fields);
            }
        }

<a name="1"></a>        if (fieldType().hasDocValues()) {
            fields.add(new SortedSetDocValuesField(fieldType().name(), binaryValue));
        }
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    protected String contentType() {
        return CONTENT_TYPE;
    }

    @Override
    protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts</b></font>) {
        KeywordFieldMapper k = (KeywordFieldMapper) other;
        if (!Objects.equals(this.lengthLimit, k.lengthLimit)) {
            throw new IllegalArgumentException(
                "mapper [" + name() + "] has different length_limit settings, current ["
                + this.lengthLimit + "], merged [" + k.lengthLimit + "]");
        }
        this.ignoreAbove = k.ignoreAbove;
        this.fieldType().setSearchAnalyzer(k.fieldType().searchAnalyzer());
    }

    @Override
    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {
        super.doXContentBody(builder, includeDefaults, params);


        if (includeDefaults || ignoreAbove != Defaults.IGNORE_ABOVE) {
            builder.field("ignore_above", ignoreAbove);
        }

        if (includeDefaults || lengthLimit != null) {
            builder.field("length_limit", lengthLimit);
        }
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>UserDefinedFunctionsIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.integrationtests;

import io.crate.data.Input;
import io.crate.expression.scalar.timestamp.CurrentTimeFunction;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.expression.udf.UDFLanguage;
import io.crate.expression.udf.UserDefinedFunctionMetadata;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.metadata.FunctionName;
import io.crate.metadata.FunctionType;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Scalar;
import io.crate.metadata.Schemas;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.functions.Signature;
import io.crate.metadata.pgcatalog.OidHash;
import io.crate.types.DataType;
import</b></font> io.crate.types.DataTypes;
import io.crate.types.TypeSignature;
import org.elasticsearch.test.ESIntegTestCase;
import org.junit.Before;
import org.junit.Test;

import javax.script.ScriptException;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.SQLErrorMatcher.isSQLError;
import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.Matchers.containsString;

@ESIntegTestCase.ClusterScope(numDataNodes = 2, numClientNodes = 0)
public class UserDefinedFunctionsIntegrationTest extends SQLIntegrationTestCase {

    public static class DummyFunction&lt;InputType&gt; extends Scalar&lt;String, InputType&gt;  {

        private final Signature signature;
        private final UserDefinedFunctionMetadata metadata;

        private DummyFunction(UserDefinedFunctionMetadata metadata,
                              Signature signature) {
            this.signature = signature;
            this.metadata = metadata;
        }

<a name="1"></a>        @Override
        public Signature signature() {
            return signature;
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

        @Override
        public Signature boundSignature() {
            return signature;
        }

<a name="2"></a>        @Override
        public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx</b></font>, Input&lt;InputType&gt;... args) {
            // dummy-lang functions simple print the type of the only argument
            return "DUMMY EATS " + <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>metadata.argumentTypes().get(0).getName();
        }
    }

    public static class DummyLang implements UDFLanguage {

        @Override
        public Scalar createFunctionImplementation(UserDefinedFunctionMetadata metadata,
                                                   Signature signature</b></font>) throws ScriptException {
            return new DummyFunction&lt;&gt;(metadata, signature);
        }

        @Override
        public String validate(UserDefinedFunctionMetadata metadata) {
            // dummy language does not validate anything
            return null;
        }

        @Override
        public String name() {
            return "dummy_lang";
        }
    }

    private final DummyLang dummyLang = new DummyLang();

    @Before
    public void beforeTest() {
        // clustering by id into two shards must assure that the two inserted
        // records reside on two different nodes configured in the test setup.
        // So then it would be possible to test that a function is created and
        // applied on all of nodes.
        Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
        for (UserDefinedFunctionService udfService : udfServices) {
            udfService.registerLanguage(dummyLang);
        }
    }

    @Test
    public void testCreateOverloadedFunction() throws Exception {
        execute("create table test (id long, str string) clustered by(id) into 2 shards");
        Object[][] rows = new Object[10][];
        for (int i = 0; i &lt; 10; i++) {
            rows[i] = new Object[]{(long) i, String.valueOf(i)};
        }
        execute("insert into test (id, str) values (?, ?)", rows);
        refresh();
        try {
            execute("create function foo(long)" +
                " returns string language dummy_lang as 'function foo(x) { return \"1\"; }'");
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.LONG));

            execute("create function foo(string)" +
                " returns string language dummy_lang as 'function foo(x) { return x; }'");
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.STRING));

            execute("select foo(str) from test order by id asc");
            assertThat(response.rows()[0][0], is("DUMMY EATS text"));

            execute("select foo(id) from test order by id asc");
            assertThat(response.rows()[0][0], is("DUMMY EATS bigint"));
        } finally {
            dropFunction("foo", List.of(Literal.of(1L)));
            dropFunction("foo", List.of(Literal.of("dummy")));
        }
    }

    @Test
    public void testFunctionIsLookedUpInSearchPath() throws Exception {
        sqlExecutor.setSearchPath("firstschema", "secondschema");
        execute("create function secondschema.udf(integer) returns string language dummy_lang as '42'");
        assertFunctionIsCreatedOnAll("secondschema", "udf", List.of(DataTypes.INTEGER));

        execute("select udf(1::integer)");
        assertThat(response.rows()[0][0], is("DUMMY EATS integer"));
    }

    @Test
    public void testFunctionIsCreatedInThePgCatalogSchema() throws Exception {
        execute("create function pg_catalog.udf(integer) returns string language dummy_lang as '42'");
        assertFunctionIsCreatedOnAll("pg_catalog", "udf", List.of(DataTypes.INTEGER));

        execute("select udf(1::integer)");
        assertThat(response.rows()[0][0], is("DUMMY EATS integer"));
    }

    @Test
    public void testDropFunction() throws Exception {
        execute("create function custom(string) returns string language dummy_lang as 'DUMMY DUMMY DUMMY'");
        assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "custom", List.of(DataTypes.STRING));

        dropFunction("custom", List.of(Literal.of("foo")));
        assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), "custom", List.of(Literal.of("foo")));
    }

    @Test
    public void testNewSchemaWithFunction() throws Exception {
        execute("create function new_schema.custom() returns integer language dummy_lang as 'function custom() {return 1;}'");
        assertFunctionIsCreatedOnAll("new_schema", "custom", List.of());
        execute("select count(*) from information_schema.schemata where schema_name='new_schema'");
        assertThat(response.rows()[0][0], is(1L));

        execute("drop function new_schema.custom()");
        assertFunctionIsDeletedOnAll("new_schema", "custom", List.of());
        execute("select count(*) from information_schema.schemata where schema_name='new_schema'");
        assertThat(response.rows()[0][0], is(0L));
    }

    @Test
    public void testSelectFunctionsFromRoutines() throws Exception {
        try {
            execute("create function subtract_test(long, long, long) " +
                    "returns long language dummy_lang " +
                    "as 'function subtract_test(a, b, c) { return a - b - c; }'");
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(),
                "subtract_test",
                List.of(DataTypes.LONG, DataTypes.LONG, DataTypes.LONG)
            );

            execute("select routine_name, routine_body, data_type, routine_definition, routine_schema, specific_name" +
                    " from information_schema.routines " +
                    " where routine_type = 'FUNCTION' and routine_name = 'subtract_test'");
            assertThat(response.rowCount(), is(1L));
            assertThat(response.rows()[0][0], is("subtract_test"));
            assertThat(response.rows()[0][1], is("dummy_lang"));
            assertThat(response.rows()[0][2], is("bigint"));
            assertThat(response.rows()[0][3], is("function subtract_test(a, b, c) { return a - b - c; }"));
            assertThat(response.rows()[0][4], is(sqlExecutor.getCurrentSchema()));
            assertThat(response.rows()[0][5], is("subtract_test(bigint, bigint, bigint)"));
        } finally {
            execute("drop function if exists subtract_test(long, long, long)");
        }
    }

    @Test
    public void testConcurrentFunctionRegistering() throws Throwable {
        // This test creates a function which is executed repeatedly while another function
        // is created and dropped on the same schema. It proves that creating and dropping
        // functions doesn't affect already registered functions.
        execute("create function foo(long) returns string language dummy_lang as 'f doo()'");
        assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.LONG));

        final CountDownLatch latch = new CountDownLatch(50);
        final AtomicReference&lt;Throwable&gt; lastThrowable = new AtomicReference&lt;&gt;();

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -&gt; {
            while (latch.getCount() &gt; 0) {
                try {
                    execute("create function bar(long) returns long language dummy_lang as 'dummy'");
                    assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "bar", List.of(DataTypes.LONG));
                    execute("drop function bar(long)");
                } catch (Exception e) {
                    lastThrowable.set(e);
                } finally {
                    latch.countDown();
                }
            }
        });
        try {
            while (latch.getCount() &gt; 0) {
                execute("select foo(5)");
            }
        } finally {
            executor.shutdown();
            executor.awaitTermination(500, TimeUnit.MILLISECONDS);
            execute("DROP FUNCTION foo(long)");
            execute("DROP FUNCTION IF EXISTS bar(long)");
            Throwable throwable = lastThrowable.get();
            if (throwable != null) {
                throw throwable;
            }
        }

    }

    private void dropFunction(String name, List&lt;Symbol&gt; arguments) throws Exception {
        var types = Symbols.typeView(arguments);
        execute(String.format(Locale.ENGLISH, "drop function %s(\"%s\")",
            name, types.stream().map(DataType::getName).collect(Collectors.joining(", "))));
        assertThat(response.rowCount(), is(1L));
        assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), name, arguments);
    }

    @Test
    public void test_pg_function_is_visible() throws Exception {
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, "my_func"))
            .argumentTypes(
                TypeSignature.parseTypeSignature("array(array(integer))"),
                TypeSignature.parseTypeSignature("integer"),
                TypeSignature.parseTypeSignature("text"))
            .returnType(TypeSignature.parseTypeSignature("text"))
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute("select pg_function_is_visible(" + functionOid + ")");
        assertThat(response.rows()[0][0], is(false));

        execute("create function doc.my_func(array(array(integer)), integer, text) returns text language dummy_lang as '42'");

        execute("select pg_function_is_visible(" + functionOid + ")");
        assertThat(response.rows()[0][0], is(true));

        execute("drop function doc.my_func(array(array(integer)), integer, text)");
        execute("select pg_function_is_visible(" + functionOid + ")");
        assertThat(response.rows()[0][0], is(false));
    }

    @Test
    public void test_pg_get_function_result() throws Exception {
        TypeSignature returnTypeSig = TypeSignature.parseTypeSignature("array(array(integer))");
        String returnType = returnTypeSig.toString();
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, "make_2d_array"))
            .argumentTypes(DataTypes.INTEGER.getTypeSignature())
            .returnType(returnTypeSig)
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute("select pg_get_function_result(?)", new Object[]{functionOid});
        assertThat(response.rows()[0][0], nullValue());

        execute("create function doc.make_2d_array(integer) returns array(array(integer)) language dummy_lang as ?", new Object[]{returnType});

        execute("select pg_get_function_result(" + functionOid + ")");
        assertThat(response.rows()[0][0], is(returnType));

        execute("drop function doc.make_2d_array(integer)");
        execute("select pg_get_function_result(" + functionOid + ")");
        assertThat(response.rows()[0][0], nullValue());
    }

    @Test
    public void test_pg_function_is_visible_when_oid_is_retrieved_from_column() throws Exception {
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(null, CurrentTimeFunction.NAME))
            .argumentTypes()
            .returnType(DataTypes.TIMETZ.getTypeSignature())
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute("create table oid_test(oid integer)");
        execute("insert into oid_test values(" + functionOid + ")");
        execute("refresh table oid_test");
        execute("select pg_function_is_visible(t.oid) from oid_test t");
        assertThat(response.rows()[0][0], is(true));
        execute("drop table oid_test");
    }

    @Test
    public void test_udf_used_inside_generated_column_definition_cannot_be_dropped() {
        execute("create function doc.foo(long) returns string language dummy_lang as" +
            " 'function foo(a) { return a; }'");
        execute("create table doc.t1 (id long, l as doc.foo(id))");

        assertThrowsMatches(
            () -&gt; execute("drop function doc.foo(long)"),
            isSQLError(containsString(
                    "Cannot drop function 'doc.foo(bigint)', it is still in use by 'doc.t1.l AS doc.foo(id)'"),
                INTERNAL_ERROR,
                BAD_REQUEST,
                4000)
        );
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
