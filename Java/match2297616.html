<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for KeywordFieldMapper.java &amp; UserDefinedFunctionsIntegrationTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for KeywordFieldMapper.java &amp; UserDefinedFunctionsIntegrationTest.java
      </h3>
<h1 align="center">
        9.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>KeywordFieldMapper.java (10.473816%)<th>UserDefinedFunctionsIntegrationTest.java (9.150327%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-42)<td><a href="#" name="0">(22-41)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(286-294)<td><a href="#" name="1">(82-90)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(133-146)<td><a href="#" name="2">(92-100)</a><td align="center"><font color="#930000">11</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KeywordFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.index.mapper;
2 import static org.elasticsearch.index.mapper.TypeParsers.parseField;
3 import java.io.IOException;
4 import java.util.Iterator;
5 import java.util.List;
6 import java.util.Map;
7 import java.util.Objects;
8 import javax.annotation.Nullable;
9 import org.apache.lucene.document.Field;
10 import org.apache.lucene.document.FieldType;
11 import org.apache.lucene.document.SortedSetDocValuesField;
12 import org.apache.lucene.index.IndexOptions;
13 import org.apache.lucene.index.IndexableField;
14 import org.apache.lucene.util.BytesRef;
15 import org.elasticsearch.common.lucene.Lucene;
16 import org.elasticsearch.common.settings.Settings;
17 import org.elasticsearch.common.xcontent.XContentBuilder;
18 import org.elasticsearch.common.xcontent.XContentParser;
19 import</b></font> org.elasticsearch.common.xcontent.support.XContentMapValues;
20 public final class KeywordFieldMapper extends FieldMapper {
21     public static final String CONTENT_TYPE = "keyword";
22     public static class Defaults {
23         public static final FieldType FIELD_TYPE = new FieldType();
24         static {
25             FIELD_TYPE.setTokenized(false);
26             FIELD_TYPE.setOmitNorms(true);
27             FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
28             FIELD_TYPE.freeze();
29         }
30         public static final String NULL_VALUE = null;
31         public static final int IGNORE_ABOVE = Integer.MAX_VALUE;
32     }
33     public static class KeywordField extends Field {
34         public KeywordField(String field, BytesRef term, FieldType ft) {
35             super(field, term, ft);
36         }
37         public KeywordField(String field, BytesRef term) {
38             super(field, term, Defaults.FIELD_TYPE);
39         }
40     }
41     public static class Builder extends FieldMapper.Builder&lt;Builder&gt; {
42         protected String nullValue = Defaults.NULL_VALUE;
43         protected int ignoreAbove = Defaults.IGNORE_ABOVE;
44         private Integer lengthLimit;
45         public Builder(String name) {
46             super(name, Defaults.FIELD_TYPE);
47             builder = this;
48         }
49         public Builder ignoreAbove(int ignoreAbove) {
50             if (ignoreAbove &lt; 0) {
51                 throw new IllegalArgumentException("[ignore_above] must be positive, got " + ignoreAbove);
52             }
53             this.ignoreAbove = ignoreAbove;
54             return this;
55         }
56         public Builder lengthLimit(int lengthLimit) {
57             if (lengthLimit &lt; 0) {
58                 throw new IllegalArgumentException("[legnth_limit] must be positive, got " + lengthLimit);
59             }
60             this.lengthLimit = lengthLimit;
61             return this;
62         }
63         @Override
64         public Builder indexOptions(IndexOptions indexOptions) {
65             if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) &gt; 0) {
66                 throw new IllegalArgumentException("The [keyword] field does not support positions, got [index_options]="
67                         + indexOptionToString(indexOptions));
68             }
69             return super.indexOptions(indexOptions);
70         }
71         public Builder nullValue(String nullValue) {
72             this.nullValue = nullValue;
73             return builder;
74         }
75         private KeywordFieldType buildFieldType(BuilderContext context) {
76             return new KeywordFieldType(
77                 buildFullName(context),
78                 indexed,
79                 hasDocValues,
80                 fieldType.omitNorms() == false
81             );
82         }
83         @Override
84         public KeywordFieldMapper build(BuilderContext context) {
85             return new KeywordFieldMapper(
86                 name,
87 <a name="2"></a>                position,
88                 defaultExpression,
89                 fieldType,
90                 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>buildFieldType(context),
91                 ignoreAbove,
92                 nullValue,
93                 lengthLimit,
94                 context.indexSettings(),
95                 multiFieldsBuilder.build(this, context),
96                 copyTo
97             );
98         }
99     }
100     public static class TypeParser implements Mapper.TypeParser {
101         @Override
102         public Mapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node</b></font>, ParserContext parserContext) throws MapperParsingException {
103             KeywordFieldMapper.Builder builder = new KeywordFieldMapper.Builder(name);
104             parseField(builder, name, node, parserContext);
105             for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = node.entrySet().iterator(); iterator.hasNext();) {
106                 Map.Entry&lt;String, Object&gt; entry = iterator.next();
107                 String propName = entry.getKey();
108                 Object propNode = entry.getValue();
109                 if (propName.equals("ignore_above")) {
110                     builder.ignoreAbove(XContentMapValues.nodeIntegerValue(propNode, -1));
111                     iterator.remove();
112                 } else if (propName.equals("length_limit")) {
113                     builder.lengthLimit(XContentMapValues.nodeIntegerValue(propNode, -1));
114                     iterator.remove();
115                 }
116             }
117             return builder;
118         }
119     }
120     public static final class KeywordFieldType extends StringFieldType {
121         boolean hasNorms;
122         public KeywordFieldType(String name,
123                                 boolean isSearchable,
124                                 boolean hasDocValues,
125                                 boolean hasNorms) {
126             super(name, isSearchable, hasDocValues);
127             this.hasNorms = hasNorms;
128             setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
129             setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
130         }
131         public KeywordFieldType(String name, boolean isSearchable, boolean hasDocValues) {
132             this(name, isSearchable, hasDocValues, true);
133         }
134         public KeywordFieldType(String name) {
135             this(name, true, true);
136         }
137         @Override
138         public String typeName() {
139             return CONTENT_TYPE;
140         }
141         @Override
142         protected BytesRef indexedValueForSearch(Object value) {
143             if (searchAnalyzer() == Lucene.KEYWORD_ANALYZER) {
144                 return super.indexedValueForSearch(value);
145             }
146             if (value == null) {
147                 return null;
148             }
149             if (value instanceof BytesRef) {
150                 value = ((BytesRef) value).utf8ToString();
151             }
152             return searchAnalyzer().normalize(name(), value.toString());
153         }
154     }
155     private int ignoreAbove;
156     private Integer lengthLimit;
157     private String nullValue;
158     protected KeywordFieldMapper(String simpleName,
159                                  Integer position,
160                                  @Nullable String defaultExpression,
161                                  FieldType fieldType,
162                                  MappedFieldType mappedFieldType,
163                                  int ignoreAbove,
164                                  String nullValue,
165                                  Integer lengthLimit,
166                                  Settings indexSettings,
167                                  MultiFields multiFields,
168                                  CopyTo copyTo) {
169         super(simpleName, position, defaultExpression, fieldType, mappedFieldType, indexSettings, multiFields, copyTo);
170         assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) &lt;= 0;
171         this.ignoreAbove = ignoreAbove;
172         this.lengthLimit = lengthLimit;
173         this.nullValue = nullValue;
174     }
175     int ignoreAbove() {
176         return ignoreAbove;
177     }
178     @Override
179     protected KeywordFieldMapper clone() {
180         return (KeywordFieldMapper) super.clone();
181     }
182     @Override
183     public KeywordFieldType fieldType() {
184         return (KeywordFieldType) super.fieldType();
185     }
186     @Override
187     protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
188         String value;
189         if (context.externalValueSet()) {
190             value = context.externalValue().toString();
191         } else {
192             XContentParser parser = context.parser();
193             if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {
194                 value = nullValue;
195             } else {
196                 value = parser.textOrNull();
197             }
198         }
199         if (value == null || value.length() &gt; ignoreAbove) {
200             return;
201         }
202         final BytesRef binaryValue = new BytesRef(value);
203         if (fieldType.indexOptions() != IndexOptions.NONE || fieldType.stored()) {
204             Field field = new Field(fieldType().name(), binaryValue, fieldType);
205             fields.add(field);
206             if (fieldType().hasDocValues() == false &amp;&amp; fieldType.omitNorms()) {
207                 createFieldNamesField(context, fields);
208             }
209         }
210 <a name="1"></a>        if (fieldType().hasDocValues()) {
211             fields.add(new SortedSetDocValuesField(fieldType().name(), binaryValue));
212         }
213     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
214     @Override
215     protected String contentType() {
216         return CONTENT_TYPE;
217     }
218     @Override
219     protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts</b></font>) {
220         KeywordFieldMapper k = (KeywordFieldMapper) other;
221         if (!Objects.equals(this.lengthLimit, k.lengthLimit)) {
222             throw new IllegalArgumentException(
223                 "mapper [" + name() + "] has different length_limit settings, current ["
224                 + this.lengthLimit + "], merged [" + k.lengthLimit + "]");
225         }
226         this.ignoreAbove = k.ignoreAbove;
227         this.fieldType().setSearchAnalyzer(k.fieldType().searchAnalyzer());
228     }
229     @Override
230     protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {
231         super.doXContentBody(builder, includeDefaults, params);
232         if (includeDefaults || ignoreAbove != Defaults.IGNORE_ABOVE) {
233             builder.field("ignore_above", ignoreAbove);
234         }
235         if (includeDefaults || lengthLimit != null) {
236             builder.field("length_limit", lengthLimit);
237         }
238     }
239 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>UserDefinedFunctionsIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.integrationtests;
22 import io.crate.data.Input;
23 import io.crate.expression.scalar.timestamp.CurrentTimeFunction;
24 import io.crate.expression.symbol.Literal;
25 import io.crate.expression.symbol.Symbol;
26 import io.crate.expression.symbol.Symbols;
27 import io.crate.expression.udf.UDFLanguage;
28 import io.crate.expression.udf.UserDefinedFunctionMetadata;
29 import io.crate.expression.udf.UserDefinedFunctionService;
30 import io.crate.metadata.FunctionName;
31 import io.crate.metadata.FunctionType;
32 import io.crate.metadata.NodeContext;
33 import io.crate.metadata.Scalar;
34 import io.crate.metadata.Schemas;
35 import io.crate.metadata.TransactionContext;
36 import io.crate.metadata.functions.Signature;
37 import io.crate.metadata.pgcatalog.OidHash;
38 import io.crate.types.DataType;
39 import</b></font> io.crate.types.DataTypes;
40 import io.crate.types.TypeSignature;
41 import org.elasticsearch.test.ESIntegTestCase;
42 import org.junit.Before;
43 import org.junit.Test;
44 import javax.script.ScriptException;
45 import java.util.List;
46 import java.util.Locale;
47 import java.util.concurrent.CountDownLatch;
48 import java.util.concurrent.ExecutorService;
49 import java.util.concurrent.Executors;
50 import java.util.concurrent.TimeUnit;
51 import java.util.concurrent.atomic.AtomicReference;
52 import java.util.stream.Collectors;
53 import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
54 import static io.crate.testing.Asserts.assertThrowsMatches;
55 import static io.crate.testing.SQLErrorMatcher.isSQLError;
56 import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
57 import static org.hamcrest.CoreMatchers.is;
58 import static org.hamcrest.CoreMatchers.nullValue;
59 import static org.hamcrest.Matchers.containsString;
60 @ESIntegTestCase.ClusterScope(numDataNodes = 2, numClientNodes = 0)
61 public class UserDefinedFunctionsIntegrationTest extends SQLIntegrationTestCase {
62     public static class DummyFunction&lt;InputType&gt; extends Scalar&lt;String, InputType&gt;  {
63         private final Signature signature;
64         private final UserDefinedFunctionMetadata metadata;
65         private DummyFunction(UserDefinedFunctionMetadata metadata,
66                               Signature signature) {
67             this.signature = signature;
68             this.metadata = metadata;
69         }
70 <a name="1"></a>        @Override
71         public Signature signature() {
72             return signature;
73         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
74         @Override
75         public Signature boundSignature() {
76             return signature;
77         }
78 <a name="2"></a>        @Override
79         public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx</b></font>, Input&lt;InputType&gt;... args) {
80             return "DUMMY EATS " + <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>metadata.argumentTypes().get(0).getName();
81         }
82     }
83     public static class DummyLang implements UDFLanguage {
84         @Override
85         public Scalar createFunctionImplementation(UserDefinedFunctionMetadata metadata,
86                                                    Signature signature</b></font>) throws ScriptException {
87             return new DummyFunction&lt;&gt;(metadata, signature);
88         }
89         @Override
90         public String validate(UserDefinedFunctionMetadata metadata) {
91             return null;
92         }
93         @Override
94         public String name() {
95             return "dummy_lang";
96         }
97     }
98     private final DummyLang dummyLang = new DummyLang();
99     @Before
100     public void beforeTest() {
101         Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
102         for (UserDefinedFunctionService udfService : udfServices) {
103             udfService.registerLanguage(dummyLang);
104         }
105     }
106     @Test
107     public void testCreateOverloadedFunction() throws Exception {
108         execute("create table test (id long, str string) clustered by(id) into 2 shards");
109         Object[][] rows = new Object[10][];
110         for (int i = 0; i &lt; 10; i++) {
111             rows[i] = new Object[]{(long) i, String.valueOf(i)};
112         }
113         execute("insert into test (id, str) values (?, ?)", rows);
114         refresh();
115         try {
116             execute("create function foo(long)" +
117                 " returns string language dummy_lang as 'function foo(x) { return \"1\"; }'");
118             assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.LONG));
119             execute("create function foo(string)" +
120                 " returns string language dummy_lang as 'function foo(x) { return x; }'");
121             assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.STRING));
122             execute("select foo(str) from test order by id asc");
123             assertThat(response.rows()[0][0], is("DUMMY EATS text"));
124             execute("select foo(id) from test order by id asc");
125             assertThat(response.rows()[0][0], is("DUMMY EATS bigint"));
126         } finally {
127             dropFunction("foo", List.of(Literal.of(1L)));
128             dropFunction("foo", List.of(Literal.of("dummy")));
129         }
130     }
131     @Test
132     public void testFunctionIsLookedUpInSearchPath() throws Exception {
133         sqlExecutor.setSearchPath("firstschema", "secondschema");
134         execute("create function secondschema.udf(integer) returns string language dummy_lang as '42'");
135         assertFunctionIsCreatedOnAll("secondschema", "udf", List.of(DataTypes.INTEGER));
136         execute("select udf(1::integer)");
137         assertThat(response.rows()[0][0], is("DUMMY EATS integer"));
138     }
139     @Test
140     public void testFunctionIsCreatedInThePgCatalogSchema() throws Exception {
141         execute("create function pg_catalog.udf(integer) returns string language dummy_lang as '42'");
142         assertFunctionIsCreatedOnAll("pg_catalog", "udf", List.of(DataTypes.INTEGER));
143         execute("select udf(1::integer)");
144         assertThat(response.rows()[0][0], is("DUMMY EATS integer"));
145     }
146     @Test
147     public void testDropFunction() throws Exception {
148         execute("create function custom(string) returns string language dummy_lang as 'DUMMY DUMMY DUMMY'");
149         assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "custom", List.of(DataTypes.STRING));
150         dropFunction("custom", List.of(Literal.of("foo")));
151         assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), "custom", List.of(Literal.of("foo")));
152     }
153     @Test
154     public void testNewSchemaWithFunction() throws Exception {
155         execute("create function new_schema.custom() returns integer language dummy_lang as 'function custom() {return 1;}'");
156         assertFunctionIsCreatedOnAll("new_schema", "custom", List.of());
157         execute("select count(*) from information_schema.schemata where schema_name='new_schema'");
158         assertThat(response.rows()[0][0], is(1L));
159         execute("drop function new_schema.custom()");
160         assertFunctionIsDeletedOnAll("new_schema", "custom", List.of());
161         execute("select count(*) from information_schema.schemata where schema_name='new_schema'");
162         assertThat(response.rows()[0][0], is(0L));
163     }
164     @Test
165     public void testSelectFunctionsFromRoutines() throws Exception {
166         try {
167             execute("create function subtract_test(long, long, long) " +
168                     "returns long language dummy_lang " +
169                     "as 'function subtract_test(a, b, c) { return a - b - c; }'");
170             assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(),
171                 "subtract_test",
172                 List.of(DataTypes.LONG, DataTypes.LONG, DataTypes.LONG)
173             );
174             execute("select routine_name, routine_body, data_type, routine_definition, routine_schema, specific_name" +
175                     " from information_schema.routines " +
176                     " where routine_type = 'FUNCTION' and routine_name = 'subtract_test'");
177             assertThat(response.rowCount(), is(1L));
178             assertThat(response.rows()[0][0], is("subtract_test"));
179             assertThat(response.rows()[0][1], is("dummy_lang"));
180             assertThat(response.rows()[0][2], is("bigint"));
181             assertThat(response.rows()[0][3], is("function subtract_test(a, b, c) { return a - b - c; }"));
182             assertThat(response.rows()[0][4], is(sqlExecutor.getCurrentSchema()));
183             assertThat(response.rows()[0][5], is("subtract_test(bigint, bigint, bigint)"));
184         } finally {
185             execute("drop function if exists subtract_test(long, long, long)");
186         }
187     }
188     @Test
189     public void testConcurrentFunctionRegistering() throws Throwable {
190         execute("create function foo(long) returns string language dummy_lang as 'f doo()'");
191         assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "foo", List.of(DataTypes.LONG));
192         final CountDownLatch latch = new CountDownLatch(50);
193         final AtomicReference&lt;Throwable&gt; lastThrowable = new AtomicReference&lt;&gt;();
194         ExecutorService executor = Executors.newSingleThreadExecutor();
195         executor.submit(() -&gt; {
196             while (latch.getCount() &gt; 0) {
197                 try {
198                     execute("create function bar(long) returns long language dummy_lang as 'dummy'");
199                     assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), "bar", List.of(DataTypes.LONG));
200                     execute("drop function bar(long)");
201                 } catch (Exception e) {
202                     lastThrowable.set(e);
203                 } finally {
204                     latch.countDown();
205                 }
206             }
207         });
208         try {
209             while (latch.getCount() &gt; 0) {
210                 execute("select foo(5)");
211             }
212         } finally {
213             executor.shutdown();
214             executor.awaitTermination(500, TimeUnit.MILLISECONDS);
215             execute("DROP FUNCTION foo(long)");
216             execute("DROP FUNCTION IF EXISTS bar(long)");
217             Throwable throwable = lastThrowable.get();
218             if (throwable != null) {
219                 throw throwable;
220             }
221         }
222     }
223     private void dropFunction(String name, List&lt;Symbol&gt; arguments) throws Exception {
224         var types = Symbols.typeView(arguments);
225         execute(String.format(Locale.ENGLISH, "drop function %s(\"%s\")",
226             name, types.stream().map(DataType::getName).collect(Collectors.joining(", "))));
227         assertThat(response.rowCount(), is(1L));
228         assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), name, arguments);
229     }
230     @Test
231     public void test_pg_function_is_visible() throws Exception {
232         Signature signature = Signature
233             .builder()
234             .kind(FunctionType.SCALAR)
235             .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, "my_func"))
236             .argumentTypes(
237                 TypeSignature.parseTypeSignature("array(array(integer))"),
238                 TypeSignature.parseTypeSignature("integer"),
239                 TypeSignature.parseTypeSignature("text"))
240             .returnType(TypeSignature.parseTypeSignature("text"))
241             .build();
242         int functionOid = OidHash.functionOid(signature);
243         execute("select pg_function_is_visible(" + functionOid + ")");
244         assertThat(response.rows()[0][0], is(false));
245         execute("create function doc.my_func(array(array(integer)), integer, text) returns text language dummy_lang as '42'");
246         execute("select pg_function_is_visible(" + functionOid + ")");
247         assertThat(response.rows()[0][0], is(true));
248         execute("drop function doc.my_func(array(array(integer)), integer, text)");
249         execute("select pg_function_is_visible(" + functionOid + ")");
250         assertThat(response.rows()[0][0], is(false));
251     }
252     @Test
253     public void test_pg_get_function_result() throws Exception {
254         TypeSignature returnTypeSig = TypeSignature.parseTypeSignature("array(array(integer))");
255         String returnType = returnTypeSig.toString();
256         Signature signature = Signature
257             .builder()
258             .kind(FunctionType.SCALAR)
259             .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, "make_2d_array"))
260             .argumentTypes(DataTypes.INTEGER.getTypeSignature())
261             .returnType(returnTypeSig)
262             .build();
263         int functionOid = OidHash.functionOid(signature);
264         execute("select pg_get_function_result(?)", new Object[]{functionOid});
265         assertThat(response.rows()[0][0], nullValue());
266         execute("create function doc.make_2d_array(integer) returns array(array(integer)) language dummy_lang as ?", new Object[]{returnType});
267         execute("select pg_get_function_result(" + functionOid + ")");
268         assertThat(response.rows()[0][0], is(returnType));
269         execute("drop function doc.make_2d_array(integer)");
270         execute("select pg_get_function_result(" + functionOid + ")");
271         assertThat(response.rows()[0][0], nullValue());
272     }
273     @Test
274     public void test_pg_function_is_visible_when_oid_is_retrieved_from_column() throws Exception {
275         Signature signature = Signature
276             .builder()
277             .kind(FunctionType.SCALAR)
278             .name(new FunctionName(null, CurrentTimeFunction.NAME))
279             .argumentTypes()
280             .returnType(DataTypes.TIMETZ.getTypeSignature())
281             .build();
282         int functionOid = OidHash.functionOid(signature);
283         execute("create table oid_test(oid integer)");
284         execute("insert into oid_test values(" + functionOid + ")");
285         execute("refresh table oid_test");
286         execute("select pg_function_is_visible(t.oid) from oid_test t");
287         assertThat(response.rows()[0][0], is(true));
288         execute("drop table oid_test");
289     }
290     @Test
291     public void test_udf_used_inside_generated_column_definition_cannot_be_dropped() {
292         execute("create function doc.foo(long) returns string language dummy_lang as" +
293             " 'function foo(a) { return a; }'");
294         execute("create table doc.t1 (id long, l as doc.foo(id))");
295         assertThrowsMatches(
296             () -&gt; execute("drop function doc.foo(long)"),
297             isSQLError(containsString(
298                     "Cannot drop function 'doc.foo(bigint)', it is still in use by 'doc.t1.l AS doc.foo(id)'"),
299                 INTERNAL_ERROR,
300                 BAD_REQUEST,
301                 4000)
302         );
303     }
304 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
