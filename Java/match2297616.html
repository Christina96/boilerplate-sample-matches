<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for KeywordFieldMapper.java & UserDefinedFunctionsIntegrationTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for KeywordFieldMapper.java & UserDefinedFunctionsIntegrationTest.java
      </h3>
      <h1 align="center">
        9.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>KeywordFieldMapper.java (10.473816%)<TH>UserDefinedFunctionsIntegrationTest.java (9.150327%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2297616-0.html#0',2,'match2297616-1.html#0',3)" NAME="0">(20-42)<TD><A HREF="javascript:ZweiFrames('match2297616-0.html#0',2,'match2297616-1.html#0',3)" NAME="0">(22-41)</A><TD ALIGN=center><FONT COLOR="#ff0000">19</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2297616-0.html#1',2,'match2297616-1.html#1',3)" NAME="1">(286-294)<TD><A HREF="javascript:ZweiFrames('match2297616-0.html#1',2,'match2297616-1.html#1',3)" NAME="1">(82-90)</A><TD ALIGN=center><FONT COLOR="#a10000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2297616-0.html#2',2,'match2297616-1.html#2',3)" NAME="2">(133-146)<TD><A HREF="javascript:ZweiFrames('match2297616-0.html#2',2,'match2297616-1.html#2',3)" NAME="2">(92-100)</A><TD ALIGN=center><FONT COLOR="#930000">11</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KeywordFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2297616-1.html#0',3,'match2297616-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.index.mapper;

import static org.elasticsearch.index.mapper.TypeParsers.parseField;

import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import javax.annotation.Nullable;

import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.SortedSetDocValuesField;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentParser;
import</B></FONT> org.elasticsearch.common.xcontent.support.XContentMapValues;

/**
 * A field mapper for keywords. This mapper accepts strings and indexes them as-is.
 */
public final class KeywordFieldMapper extends FieldMapper {

    public static final String CONTENT_TYPE = &quot;keyword&quot;;

    public static class Defaults {
        public static final FieldType FIELD_TYPE = new FieldType();

        static {
            FIELD_TYPE.setTokenized(false);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
            FIELD_TYPE.freeze();
        }

        public static final String NULL_VALUE = null;
        public static final int IGNORE_ABOVE = Integer.MAX_VALUE;
    }

    public static class KeywordField extends Field {

        public KeywordField(String field, BytesRef term, FieldType ft) {
            super(field, term, ft);
        }

        public KeywordField(String field, BytesRef term) {
            super(field, term, Defaults.FIELD_TYPE);
        }
    }

    public static class Builder extends FieldMapper.Builder&lt;Builder&gt; {

        protected String nullValue = Defaults.NULL_VALUE;
        protected int ignoreAbove = Defaults.IGNORE_ABOVE;
        private Integer lengthLimit;

        public Builder(String name) {
            super(name, Defaults.FIELD_TYPE);
            builder = this;
        }

        public Builder ignoreAbove(int ignoreAbove) {
            if (ignoreAbove &lt; 0) {
                throw new IllegalArgumentException(&quot;[ignore_above] must be positive, got &quot; + ignoreAbove);
            }
            this.ignoreAbove = ignoreAbove;
            return this;
        }

        public Builder lengthLimit(int lengthLimit) {
            if (lengthLimit &lt; 0) {
                throw new IllegalArgumentException(&quot;[legnth_limit] must be positive, got &quot; + lengthLimit);
            }
            this.lengthLimit = lengthLimit;
            return this;
        }

        @Override
        public Builder indexOptions(IndexOptions indexOptions) {
            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) &gt; 0) {
                throw new IllegalArgumentException(&quot;The [keyword] field does not support positions, got [index_options]=&quot;
                        + indexOptionToString(indexOptions));
            }
            return super.indexOptions(indexOptions);
        }

        public Builder nullValue(String nullValue) {
            this.nullValue = nullValue;
            return builder;
        }

        private KeywordFieldType buildFieldType(BuilderContext context) {
            return new KeywordFieldType(
                buildFullName(context),
                indexed,
                hasDocValues,
                fieldType.omitNorms() == false
            );
        }

        @Override
        public KeywordFieldMapper build(BuilderContext context) {
            return new KeywordFieldMapper(
                name,
<A NAME="2"></A>                position,
                defaultExpression,
                fieldType,
                <FONT color="#980517"><A HREF="javascript:ZweiFrames('match2297616-1.html#2',3,'match2297616-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>buildFieldType(context),
                ignoreAbove,
                nullValue,
                lengthLimit,
                context.indexSettings(),
                multiFieldsBuilder.build(this, context),
                copyTo
            );
        }
    }

    public static class TypeParser implements Mapper.TypeParser {
        @Override
        public Mapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node</B></FONT>, ParserContext parserContext) throws MapperParsingException {
            KeywordFieldMapper.Builder builder = new KeywordFieldMapper.Builder(name);
            parseField(builder, name, node, parserContext);
            for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = node.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry&lt;String, Object&gt; entry = iterator.next();
                String propName = entry.getKey();
                Object propNode = entry.getValue();
                if (propName.equals(&quot;ignore_above&quot;)) {
                    builder.ignoreAbove(XContentMapValues.nodeIntegerValue(propNode, -1));
                    iterator.remove();
                } else if (propName.equals(&quot;length_limit&quot;)) {
                    builder.lengthLimit(XContentMapValues.nodeIntegerValue(propNode, -1));
                    iterator.remove();
                }
            }
            return builder;
        }
    }

    public static final class KeywordFieldType extends StringFieldType {

        boolean hasNorms;

        public KeywordFieldType(String name,
                                boolean isSearchable,
                                boolean hasDocValues,
                                boolean hasNorms) {
            super(name, isSearchable, hasDocValues);
            this.hasNorms = hasNorms;
            setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
            setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
        }

        public KeywordFieldType(String name, boolean isSearchable, boolean hasDocValues) {
            this(name, isSearchable, hasDocValues, true);
        }

        public KeywordFieldType(String name) {
            this(name, true, true);
        }


        @Override
        public String typeName() {
            return CONTENT_TYPE;
        }

        @Override
        protected BytesRef indexedValueForSearch(Object value) {
            if (searchAnalyzer() == Lucene.KEYWORD_ANALYZER) {
                // keyword analyzer with the default attribute source which encodes terms using UTF8
                // in that case we skip normalization, which may be slow if there many terms need to
                // parse (eg. large terms query) since Analyzer.normalize involves things like creating
                // attributes through reflection
                // This if statement will be used whenever a normalizer is NOT configured
                return super.indexedValueForSearch(value);
            }

            if (value == null) {
                return null;
            }
            if (value instanceof BytesRef) {
                value = ((BytesRef) value).utf8ToString();
            }
            return searchAnalyzer().normalize(name(), value.toString());
        }
    }

    private int ignoreAbove;
    private Integer lengthLimit;
    private String nullValue;


    protected KeywordFieldMapper(String simpleName,
                                 Integer position,
                                 @Nullable String defaultExpression,
                                 FieldType fieldType,
                                 MappedFieldType mappedFieldType,
                                 int ignoreAbove,
                                 String nullValue,
                                 Integer lengthLimit,
                                 Settings indexSettings,
                                 MultiFields multiFields,
                                 CopyTo copyTo) {
        super(simpleName, position, defaultExpression, fieldType, mappedFieldType, indexSettings, multiFields, copyTo);
        assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) &lt;= 0;
        this.ignoreAbove = ignoreAbove;
        this.lengthLimit = lengthLimit;
        this.nullValue = nullValue;
    }

    /** Values that have more chars than the return value of this method will
     *  be skipped at parsing time. */
    // pkg-private for testing
    int ignoreAbove() {
        return ignoreAbove;
    }

    @Override
    protected KeywordFieldMapper clone() {
        return (KeywordFieldMapper) super.clone();
    }

    @Override
    public KeywordFieldType fieldType() {
        return (KeywordFieldType) super.fieldType();
    }

    @Override
    protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
        String value;
        if (context.externalValueSet()) {
            value = context.externalValue().toString();
        } else {
            XContentParser parser = context.parser();
            if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {
                value = nullValue;
            } else {
                value = parser.textOrNull();
            }
        }

        if (value == null || value.length() &gt; ignoreAbove) {
            return;
        }

        // convert to utf8 only once before feeding postings/dv/stored fields
        final BytesRef binaryValue = new BytesRef(value);
        if (fieldType.indexOptions() != IndexOptions.NONE || fieldType.stored()) {
            Field field = new Field(fieldType().name(), binaryValue, fieldType);
            fields.add(field);

            if (fieldType().hasDocValues() == false &amp;&amp; fieldType.omitNorms()) {
                createFieldNamesField(context, fields);
            }
        }

<A NAME="1"></A>        if (fieldType().hasDocValues()) {
            fields.add(new SortedSetDocValuesField(fieldType().name(), binaryValue));
        }
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2297616-1.html#1',3,'match2297616-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    protected String contentType() {
        return CONTENT_TYPE;
    }

    @Override
    protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts</B></FONT>) {
        KeywordFieldMapper k = (KeywordFieldMapper) other;
        if (!Objects.equals(this.lengthLimit, k.lengthLimit)) {
            throw new IllegalArgumentException(
                &quot;mapper [&quot; + name() + &quot;] has different length_limit settings, current [&quot;
                + this.lengthLimit + &quot;], merged [&quot; + k.lengthLimit + &quot;]&quot;);
        }
        this.ignoreAbove = k.ignoreAbove;
        this.fieldType().setSearchAnalyzer(k.fieldType().searchAnalyzer());
    }

    @Override
    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {
        super.doXContentBody(builder, includeDefaults, params);


        if (includeDefaults || ignoreAbove != Defaults.IGNORE_ABOVE) {
            builder.field(&quot;ignore_above&quot;, ignoreAbove);
        }

        if (includeDefaults || lengthLimit != null) {
            builder.field(&quot;length_limit&quot;, lengthLimit);
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>UserDefinedFunctionsIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2297616-0.html#0',2,'match2297616-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.integrationtests;

import io.crate.data.Input;
import io.crate.expression.scalar.timestamp.CurrentTimeFunction;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.expression.udf.UDFLanguage;
import io.crate.expression.udf.UserDefinedFunctionMetadata;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.metadata.FunctionName;
import io.crate.metadata.FunctionType;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Scalar;
import io.crate.metadata.Schemas;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.functions.Signature;
import io.crate.metadata.pgcatalog.OidHash;
import io.crate.types.DataType;
import</B></FONT> io.crate.types.DataTypes;
import io.crate.types.TypeSignature;
import org.elasticsearch.test.ESIntegTestCase;
import org.junit.Before;
import org.junit.Test;

import javax.script.ScriptException;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.SQLErrorMatcher.isSQLError;
import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.Matchers.containsString;

@ESIntegTestCase.ClusterScope(numDataNodes = 2, numClientNodes = 0)
public class UserDefinedFunctionsIntegrationTest extends SQLIntegrationTestCase {

    public static class DummyFunction&lt;InputType&gt; extends Scalar&lt;String, InputType&gt;  {

        private final Signature signature;
        private final UserDefinedFunctionMetadata metadata;

        private DummyFunction(UserDefinedFunctionMetadata metadata,
                              Signature signature) {
            this.signature = signature;
            this.metadata = metadata;
        }

<A NAME="1"></A>        @Override
        public Signature signature() {
            return signature;
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2297616-0.html#1',2,'match2297616-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        @Override
        public Signature boundSignature() {
            return signature;
        }

<A NAME="2"></A>        @Override
        public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx</B></FONT>, Input&lt;InputType&gt;... args) {
            // dummy-lang functions simple print the type of the only argument
            return &quot;DUMMY EATS &quot; + <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2297616-0.html#2',2,'match2297616-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>metadata.argumentTypes().get(0).getName();
        }
    }

    public static class DummyLang implements UDFLanguage {

        @Override
        public Scalar createFunctionImplementation(UserDefinedFunctionMetadata metadata,
                                                   Signature signature</B></FONT>) throws ScriptException {
            return new DummyFunction&lt;&gt;(metadata, signature);
        }

        @Override
        public String validate(UserDefinedFunctionMetadata metadata) {
            // dummy language does not validate anything
            return null;
        }

        @Override
        public String name() {
            return &quot;dummy_lang&quot;;
        }
    }

    private final DummyLang dummyLang = new DummyLang();

    @Before
    public void beforeTest() {
        // clustering by id into two shards must assure that the two inserted
        // records reside on two different nodes configured in the test setup.
        // So then it would be possible to test that a function is created and
        // applied on all of nodes.
        Iterable&lt;UserDefinedFunctionService&gt; udfServices = internalCluster().getInstances(UserDefinedFunctionService.class);
        for (UserDefinedFunctionService udfService : udfServices) {
            udfService.registerLanguage(dummyLang);
        }
    }

    @Test
    public void testCreateOverloadedFunction() throws Exception {
        execute(&quot;create table test (id long, str string) clustered by(id) into 2 shards&quot;);
        Object[][] rows = new Object[10][];
        for (int i = 0; i &lt; 10; i++) {
            rows[i] = new Object[]{(long) i, String.valueOf(i)};
        }
        execute(&quot;insert into test (id, str) values (?, ?)&quot;, rows);
        refresh();
        try {
            execute(&quot;create function foo(long)&quot; +
                &quot; returns string language dummy_lang as 'function foo(x) { return \&quot;1\&quot;; }'&quot;);
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), &quot;foo&quot;, List.of(DataTypes.LONG));

            execute(&quot;create function foo(string)&quot; +
                &quot; returns string language dummy_lang as 'function foo(x) { return x; }'&quot;);
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), &quot;foo&quot;, List.of(DataTypes.STRING));

            execute(&quot;select foo(str) from test order by id asc&quot;);
            assertThat(response.rows()[0][0], is(&quot;DUMMY EATS text&quot;));

            execute(&quot;select foo(id) from test order by id asc&quot;);
            assertThat(response.rows()[0][0], is(&quot;DUMMY EATS bigint&quot;));
        } finally {
            dropFunction(&quot;foo&quot;, List.of(Literal.of(1L)));
            dropFunction(&quot;foo&quot;, List.of(Literal.of(&quot;dummy&quot;)));
        }
    }

    @Test
    public void testFunctionIsLookedUpInSearchPath() throws Exception {
        sqlExecutor.setSearchPath(&quot;firstschema&quot;, &quot;secondschema&quot;);
        execute(&quot;create function secondschema.udf(integer) returns string language dummy_lang as '42'&quot;);
        assertFunctionIsCreatedOnAll(&quot;secondschema&quot;, &quot;udf&quot;, List.of(DataTypes.INTEGER));

        execute(&quot;select udf(1::integer)&quot;);
        assertThat(response.rows()[0][0], is(&quot;DUMMY EATS integer&quot;));
    }

    @Test
    public void testFunctionIsCreatedInThePgCatalogSchema() throws Exception {
        execute(&quot;create function pg_catalog.udf(integer) returns string language dummy_lang as '42'&quot;);
        assertFunctionIsCreatedOnAll(&quot;pg_catalog&quot;, &quot;udf&quot;, List.of(DataTypes.INTEGER));

        execute(&quot;select udf(1::integer)&quot;);
        assertThat(response.rows()[0][0], is(&quot;DUMMY EATS integer&quot;));
    }

    @Test
    public void testDropFunction() throws Exception {
        execute(&quot;create function custom(string) returns string language dummy_lang as 'DUMMY DUMMY DUMMY'&quot;);
        assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), &quot;custom&quot;, List.of(DataTypes.STRING));

        dropFunction(&quot;custom&quot;, List.of(Literal.of(&quot;foo&quot;)));
        assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), &quot;custom&quot;, List.of(Literal.of(&quot;foo&quot;)));
    }

    @Test
    public void testNewSchemaWithFunction() throws Exception {
        execute(&quot;create function new_schema.custom() returns integer language dummy_lang as 'function custom() {return 1;}'&quot;);
        assertFunctionIsCreatedOnAll(&quot;new_schema&quot;, &quot;custom&quot;, List.of());
        execute(&quot;select count(*) from information_schema.schemata where schema_name='new_schema'&quot;);
        assertThat(response.rows()[0][0], is(1L));

        execute(&quot;drop function new_schema.custom()&quot;);
        assertFunctionIsDeletedOnAll(&quot;new_schema&quot;, &quot;custom&quot;, List.of());
        execute(&quot;select count(*) from information_schema.schemata where schema_name='new_schema'&quot;);
        assertThat(response.rows()[0][0], is(0L));
    }

    @Test
    public void testSelectFunctionsFromRoutines() throws Exception {
        try {
            execute(&quot;create function subtract_test(long, long, long) &quot; +
                    &quot;returns long language dummy_lang &quot; +
                    &quot;as 'function subtract_test(a, b, c) { return a - b - c; }'&quot;);
            assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(),
                &quot;subtract_test&quot;,
                List.of(DataTypes.LONG, DataTypes.LONG, DataTypes.LONG)
            );

            execute(&quot;select routine_name, routine_body, data_type, routine_definition, routine_schema, specific_name&quot; +
                    &quot; from information_schema.routines &quot; +
                    &quot; where routine_type = 'FUNCTION' and routine_name = 'subtract_test'&quot;);
            assertThat(response.rowCount(), is(1L));
            assertThat(response.rows()[0][0], is(&quot;subtract_test&quot;));
            assertThat(response.rows()[0][1], is(&quot;dummy_lang&quot;));
            assertThat(response.rows()[0][2], is(&quot;bigint&quot;));
            assertThat(response.rows()[0][3], is(&quot;function subtract_test(a, b, c) { return a - b - c; }&quot;));
            assertThat(response.rows()[0][4], is(sqlExecutor.getCurrentSchema()));
            assertThat(response.rows()[0][5], is(&quot;subtract_test(bigint, bigint, bigint)&quot;));
        } finally {
            execute(&quot;drop function if exists subtract_test(long, long, long)&quot;);
        }
    }

    @Test
    public void testConcurrentFunctionRegistering() throws Throwable {
        // This test creates a function which is executed repeatedly while another function
        // is created and dropped on the same schema. It proves that creating and dropping
        // functions doesn't affect already registered functions.
        execute(&quot;create function foo(long) returns string language dummy_lang as 'f doo()'&quot;);
        assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), &quot;foo&quot;, List.of(DataTypes.LONG));

        final CountDownLatch latch = new CountDownLatch(50);
        final AtomicReference&lt;Throwable&gt; lastThrowable = new AtomicReference&lt;&gt;();

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -&gt; {
            while (latch.getCount() &gt; 0) {
                try {
                    execute(&quot;create function bar(long) returns long language dummy_lang as 'dummy'&quot;);
                    assertFunctionIsCreatedOnAll(sqlExecutor.getCurrentSchema(), &quot;bar&quot;, List.of(DataTypes.LONG));
                    execute(&quot;drop function bar(long)&quot;);
                } catch (Exception e) {
                    lastThrowable.set(e);
                } finally {
                    latch.countDown();
                }
            }
        });
        try {
            while (latch.getCount() &gt; 0) {
                execute(&quot;select foo(5)&quot;);
            }
        } finally {
            executor.shutdown();
            executor.awaitTermination(500, TimeUnit.MILLISECONDS);
            execute(&quot;DROP FUNCTION foo(long)&quot;);
            execute(&quot;DROP FUNCTION IF EXISTS bar(long)&quot;);
            Throwable throwable = lastThrowable.get();
            if (throwable != null) {
                throw throwable;
            }
        }

    }

    private void dropFunction(String name, List&lt;Symbol&gt; arguments) throws Exception {
        var types = Symbols.typeView(arguments);
        execute(String.format(Locale.ENGLISH, &quot;drop function %s(\&quot;%s\&quot;)&quot;,
            name, types.stream().map(DataType::getName).collect(Collectors.joining(&quot;, &quot;))));
        assertThat(response.rowCount(), is(1L));
        assertFunctionIsDeletedOnAll(sqlExecutor.getCurrentSchema(), name, arguments);
    }

    @Test
    public void test_pg_function_is_visible() throws Exception {
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, &quot;my_func&quot;))
            .argumentTypes(
                TypeSignature.parseTypeSignature(&quot;array(array(integer))&quot;),
                TypeSignature.parseTypeSignature(&quot;integer&quot;),
                TypeSignature.parseTypeSignature(&quot;text&quot;))
            .returnType(TypeSignature.parseTypeSignature(&quot;text&quot;))
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute(&quot;select pg_function_is_visible(&quot; + functionOid + &quot;)&quot;);
        assertThat(response.rows()[0][0], is(false));

        execute(&quot;create function doc.my_func(array(array(integer)), integer, text) returns text language dummy_lang as '42'&quot;);

        execute(&quot;select pg_function_is_visible(&quot; + functionOid + &quot;)&quot;);
        assertThat(response.rows()[0][0], is(true));

        execute(&quot;drop function doc.my_func(array(array(integer)), integer, text)&quot;);
        execute(&quot;select pg_function_is_visible(&quot; + functionOid + &quot;)&quot;);
        assertThat(response.rows()[0][0], is(false));
    }

    @Test
    public void test_pg_get_function_result() throws Exception {
        TypeSignature returnTypeSig = TypeSignature.parseTypeSignature(&quot;array(array(integer))&quot;);
        String returnType = returnTypeSig.toString();
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(Schemas.DOC_SCHEMA_NAME, &quot;make_2d_array&quot;))
            .argumentTypes(DataTypes.INTEGER.getTypeSignature())
            .returnType(returnTypeSig)
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute(&quot;select pg_get_function_result(?)&quot;, new Object[]{functionOid});
        assertThat(response.rows()[0][0], nullValue());

        execute(&quot;create function doc.make_2d_array(integer) returns array(array(integer)) language dummy_lang as ?&quot;, new Object[]{returnType});

        execute(&quot;select pg_get_function_result(&quot; + functionOid + &quot;)&quot;);
        assertThat(response.rows()[0][0], is(returnType));

        execute(&quot;drop function doc.make_2d_array(integer)&quot;);
        execute(&quot;select pg_get_function_result(&quot; + functionOid + &quot;)&quot;);
        assertThat(response.rows()[0][0], nullValue());
    }

    @Test
    public void test_pg_function_is_visible_when_oid_is_retrieved_from_column() throws Exception {
        Signature signature = Signature
            .builder()
            .kind(FunctionType.SCALAR)
            .name(new FunctionName(null, CurrentTimeFunction.NAME))
            .argumentTypes()
            .returnType(DataTypes.TIMETZ.getTypeSignature())
            .build();
        int functionOid = OidHash.functionOid(signature);

        execute(&quot;create table oid_test(oid integer)&quot;);
        execute(&quot;insert into oid_test values(&quot; + functionOid + &quot;)&quot;);
        execute(&quot;refresh table oid_test&quot;);
        execute(&quot;select pg_function_is_visible(t.oid) from oid_test t&quot;);
        assertThat(response.rows()[0][0], is(true));
        execute(&quot;drop table oid_test&quot;);
    }

    @Test
    public void test_udf_used_inside_generated_column_definition_cannot_be_dropped() {
        execute(&quot;create function doc.foo(long) returns string language dummy_lang as&quot; +
            &quot; 'function foo(a) { return a; }'&quot;);
        execute(&quot;create table doc.t1 (id long, l as doc.foo(id))&quot;);

        assertThrowsMatches(
            () -&gt; execute(&quot;drop function doc.foo(long)&quot;),
            isSQLError(containsString(
                    &quot;Cannot drop function 'doc.foo(bigint)', it is still in use by 'doc.t1.l AS doc.foo(id)'&quot;),
                INTERNAL_ERROR,
                BAD_REQUEST,
                4000)
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
