<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for CaliperMeasure.java & HashedWheelTimerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for CaliperMeasure.java & HashedWheelTimerTest.java
      </h3>
      <h1 align="center">
        7.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>CaliperMeasure.java (13.259668%)<TH>HashedWheelTimerTest.java (5.5555553%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match523998-0.html#0',2,'match523998-1.html#0',3)" NAME="0">(17-38)<TD><A HREF="javascript:ZweiFrames('match523998-0.html#0',2,'match523998-1.html#0',3)" NAME="0">(16-33)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match523998-0.html#1',2,'match523998-1.html#1',3)" NAME="1">(92-99)<TD><A HREF="javascript:ZweiFrames('match523998-0.html#1',2,'match523998-1.html#1',3)" NAME="1">(253-256)</A><TD ALIGN=center><FONT COLOR="#b60000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CaliperMeasure.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match523998-1.html#0',3,'match523998-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.netty.test.udt.util;

import com.google.caliper.Measurement;
import com.google.caliper.MeasurementSet;
import com.google.caliper.Run;
import com.google.caliper.Scenario;
import com.google.caliper.ScenarioResult;
import com.yammer.metrics.core.Gauge;
import com.yammer.metrics.core.Meter;
import com.yammer.metrics.core.MetricsRegistry;
import com.yammer.metrics.core.Timer;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Caliper measure with Metrics provider.
 * &lt;p&gt;
 * measure up to 3 values: {@link #rate()}, {@link #time()}, {@link #size()}
 */
publi</B></FONT>c class CaliperMeasure {

    /**
     * Gauge any double value
     */
    public static class SizeGuage extends Gauge&lt;Double&gt; {

        private volatile Double size = 0.0;

        @Override
        public Double value() {
            return size;
        }

        public void value(final double size) {
            this.size = size;
        }
    }

    /**
     * Default rate measurement units.
     */
    private static final Map&lt;String, Integer&gt; RATE_UNIT = new HashMap&lt;String, Integer&gt;();
    static {
        RATE_UNIT.put(&quot;Rate  B/s&quot;, 1);
        RATE_UNIT.put(&quot;Rate KB/s&quot;, 1024);
        RATE_UNIT.put(&quot;Rate MB/s&quot;, 1024 * 1024);
        RATE_UNIT.put(&quot;Rate GB/s&quot;, 1024 * 1024 * 1024);
    }

    /**
     * Default time measurement units.
     */
    private static final Map&lt;String, Integer&gt; TIME_UNIT = new HashMap&lt;String, Integer&gt;();
    static {
        TIME_UNIT.put(&quot;Time ns&quot;, 1);
        TIME_UNIT.put(&quot;Time us&quot;, 1000);
        TIME_UNIT.put(&quot;Time ms&quot;, 1000 * 1000);
        TIME_UNIT.put(&quot;Time s &quot;, 1000 * 1000 * 1000);
    }

    /**
     * Default size measurement units.
     */
    private static final Map&lt;String, Integer&gt; SIZE_UNIT = new HashMap&lt;String, Integer&gt;();
    static {
        SIZE_UNIT.put(&quot;Size  B&quot;, 1);
        SIZE_UNIT.put(&quot;Size KB&quot;, 1024);
        SIZE_UNIT.put(&quot;Size MB&quot;, 1024 * 1024);
        SIZE_UNIT.put(&quot;Size GB&quot;, 1024 * 1024 * 1024);
    }
<A NAME="1"></A>
    private final Map&lt;Long, Measurement&gt; rateMap = new HashMap&lt;Long, Measurement&gt;();
    private final Map&lt;Long, Measurement&gt; timeMap = new HashMap&lt;Long, Measurement&gt;();
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match523998-1.html#1',3,'match523998-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private final Map&lt;Long, Measurement&gt; sizeMap = new HashMap&lt;Long, Measurement&gt;();

    private final MetricsRegistry metrics = new MetricsRegistry();

    private final Meter rate = metrics.newMeter(getClass(), &quot;rate&quot;, &quot;bytes&quot;,
            TimeUnit.SECONDS);

    private final Timer time = metrics.newTimer(getClass</B></FONT>(), &quot;time&quot;,
            TimeUnit.NANOSECONDS, TimeUnit.SECONDS);

    private final SizeGuage size = new SizeGuage();
    {
        metrics.newGauge(getClass(), &quot;&quot;, size);
    }

    /**
     * Rate meter.
     */
    public Meter rate() {
        return rate;
    }

    /**
     * Time meter.
     */
    public Timer time() {
        return time;
    }

    /**
     * Size meter.
     */
    public SizeGuage size() {
        return size;
    }

    /**
     * Workaround: zero breaks gwt web app.
     */
    private static double filter(final double value) {
        if (value &lt;= 0.0) {
            return 1.0;
        } else {
            return value;
        }
    }

    /**
     * Perform measurement; convert from metrics into caliper.
     */
    @SuppressWarnings(&quot;FloatingPointEquality&quot;)
    public void mark() {
        final double rateValue = filter(rate.oneMinuteRate());
        final double timeValue = filter(time.mean());
        final double sizeValue = filter(size.value());
        if (rateValue == 1.0 &amp;&amp; timeValue == 1.0 &amp;&amp; sizeValue == 1.0) {
            /** ignore complete blank entries */
            return;
        }

        final Measurement markRate = new Measurement(RATE_UNIT, rateValue,
                rateValue);
        rateMap.put(System.nanoTime(), markRate);

        final Measurement markTime = new Measurement(TIME_UNIT, timeValue,
                timeValue);
        timeMap.put(System.nanoTime(), markTime);

        final Measurement markSize = new Measurement(SIZE_UNIT, sizeValue,
                sizeValue);
        sizeMap.put(System.nanoTime(), markSize);
    }

    private final Map&lt;String, String&gt; variables = new HashMap&lt;String, String&gt;();

    /**
     * Caliper scenario variables.
     */
    public Map&lt;String, String&gt; variables() {
        return variables;
    }

    private static MeasurementSet measurementSet(final Map&lt;Long, Measurement&gt; map) {
        final Measurement[] array = map.values().toArray(new Measurement[0]);
        return new MeasurementSet(array);
    }

    /**
     * Attach this measure to parent caliper run.
     */
    public void appendTo(final Run run) {

        final Scenario scenario = new Scenario(variables());

        /** display rate as caliper durations */
        final MeasurementSet timeSet = measurementSet(rateMap);
        final String timeLog = null;

        /** display time as caliper instances */
        final MeasurementSet instSet = measurementSet(timeMap);
        final String instLog = null;

        /** display size as caliper memory */
        final MeasurementSet heapSet = measurementSet(sizeMap);
        final String heapLog = null;

        final ScenarioResult scenarioResult = new ScenarioResult(timeSet,
                timeLog, instSet, instLog, heapSet, heapLog);

        final Map&lt;Scenario, ScenarioResult&gt; measurements = run
                .getMeasurements();

        measurements.put(scenario, scenarioResult);
    }

    /**
     * Terminate metrics resources.
     */
    public void shutdown() {
        rate.stop();
        time.stop();
        metrics.shutdown();
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashedWheelTimerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2013 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
<A NAME="0"></A> * License for the specific language governing permissions and limitations
 * under the License.
 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match523998-0.html#0',2,'match523998-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.netty.util;

import org.junit.jupiter.api.Test;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

publi</B></FONT>c class HashedWheelTimerTest {

    @Test
    public void testScheduleTimeoutShouldNotRunBeforeDelay() throws InterruptedException {
        final Timer timer = new HashedWheelTimer();
        final CountDownLatch barrier = new CountDownLatch(1);
        final Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                fail(&quot;This should not have run&quot;);
                barrier.countDown();
            }
        }, 10, TimeUnit.SECONDS);
        assertFalse(barrier.await(3, TimeUnit.SECONDS));
        assertFalse(timeout.isExpired(), &quot;timer should not expire&quot;);
        timer.stop();
    }

    @Test
    public void testScheduleTimeoutShouldRunAfterDelay() throws InterruptedException {
        final Timer timer = new HashedWheelTimer();
        final CountDownLatch barrier = new CountDownLatch(1);
        final Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                barrier.countDown();
            }
        }, 2, TimeUnit.SECONDS);
        assertTrue(barrier.await(3, TimeUnit.SECONDS));
        assertTrue(timeout.isExpired(), &quot;timer should expire&quot;);
        timer.stop();
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testStopTimer() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(3);
        final Timer timerProcessed = new HashedWheelTimer();
        for (int i = 0; i &lt; 3; i ++) {
            timerProcessed.newTimeout(new TimerTask() {
                @Override
                public void run(final Timeout timeout) throws Exception {
                    latch.countDown();
                }
            }, 1, TimeUnit.MILLISECONDS);
        }

        latch.await();
        assertEquals(0, timerProcessed.stop().size(), &quot;Number of unprocessed timeouts should be 0&quot;);

        final Timer timerUnprocessed = new HashedWheelTimer();
        for (int i = 0; i &lt; 5; i ++) {
            timerUnprocessed.newTimeout(new TimerTask() {
                @Override
                public void run(Timeout timeout) throws Exception {
                }
            }, 5, TimeUnit.SECONDS);
        }
        Thread.sleep(1000L); // sleep for a second
        assertFalse(timerUnprocessed.stop().isEmpty(), &quot;Number of unprocessed timeouts should be greater than 0&quot;);
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testTimerShouldThrowExceptionAfterShutdownForNewTimeouts() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(3);
        final Timer timer = new HashedWheelTimer();
        for (int i = 0; i &lt; 3; i ++) {
            timer.newTimeout(new TimerTask() {
                @Override
                public void run(Timeout timeout) throws Exception {
                    latch.countDown();
                }
            }, 1, TimeUnit.MILLISECONDS);
        }

        latch.await();
        timer.stop();

        try {
            timer.newTimeout(createNoOpTimerTask(), 1, TimeUnit.MILLISECONDS);
            fail(&quot;Expected exception didn't occur.&quot;);
        } catch (IllegalStateException ignored) {
            // expected
        }
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void testTimerOverflowWheelLength() throws InterruptedException {
        final HashedWheelTimer timer = new HashedWheelTimer(
            Executors.defaultThreadFactory(), 100, TimeUnit.MILLISECONDS, 32);
        final CountDownLatch latch = new CountDownLatch(3);

        timer.newTimeout(new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                timer.newTimeout(this, 100, TimeUnit.MILLISECONDS);
                latch.countDown();
            }
        }, 100, TimeUnit.MILLISECONDS);

        latch.await();
        assertFalse(timer.stop().isEmpty());
    }

    @Test
    public void testExecutionOnTime() throws InterruptedException {
        int tickDuration = 200;
        int timeout = 125;
        int maxTimeout = 2 * (tickDuration + timeout);
        final HashedWheelTimer timer = new HashedWheelTimer(tickDuration, TimeUnit.MILLISECONDS);
        final BlockingQueue&lt;Long&gt; queue = new LinkedBlockingQueue&lt;Long&gt;();

        int scheduledTasks = 100000;
        for (int i = 0; i &lt; scheduledTasks; i++) {
            final long start = System.nanoTime();
            timer.newTimeout(new TimerTask() {
                @Override
                public void run(final Timeout timeout) throws Exception {
                    queue.add(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
                }
            }, timeout, TimeUnit.MILLISECONDS);
        }

        for (int i = 0; i &lt; scheduledTasks; i++) {
            long delay = queue.take();
            assertTrue(delay &gt;= timeout &amp;&amp; delay &lt; maxTimeout,
                &quot;Timeout + &quot; + scheduledTasks + &quot; delay &quot; + delay + &quot; must be &quot; + timeout + &quot; &lt; &quot; + maxTimeout);
        }

        timer.stop();
    }

    @Test
    public void testExecutionOnTaskExecutor() throws InterruptedException {
        int timeout = 10;

        final CountDownLatch latch = new CountDownLatch(1);
        final CountDownLatch timeoutLatch = new CountDownLatch(1);
        Executor executor = new Executor() {
            @Override
            public void execute(Runnable command) {
                try {
                    command.run();
                } finally {
                    latch.countDown();
                }
            }
        };
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 100,
                TimeUnit.MILLISECONDS, 32, true, 2, executor);
        timer.newTimeout(new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                timeoutLatch.countDown();
            }
        }, timeout, TimeUnit.MILLISECONDS);

        latch.await();
        timeoutLatch.await();
        timer.stop();
    }

    @Test
    public void testRejectedExecutionExceptionWhenTooManyTimeoutsAreAddedBackToBack() {
        HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 100,
            TimeUnit.MILLISECONDS, 32, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        try {
            timer.newTimeout(createNoOpTimerTask(), 1, TimeUnit.MILLISECONDS);
            fail(&quot;Timer allowed adding 3 timeouts when maxPendingTimeouts was 2&quot;);
        } catch (RejectedExecutionException e) {
            // Expected
        } finally {
            timer.stop();
        }
    }

    @Test
    public void testNewTimeoutShouldStopThrowingRejectedExecutionExceptionWhenExistingTimeoutIsCancelled()
        throws InterruptedException {
        final int tickDurationMs = 100;
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), tickDurationMs,
            TimeUnit.MILLISECONDS, 32, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        Timeout timeoutToCancel = timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        assertTrue(timeoutToCancel.cancel());

        Thread.sleep(tickDurationMs * 5);

        final CountDownLatch secondLatch = new CountDownLatch(1);
        timer.newTimeout(createCountDownLatchTimerTask(secondLatch), 90, TimeUnit.MILLISECONDS);

        secondLatch.await();
        timer.stop();
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testNewTimeoutShouldStopThrowingRejectedExecutionExceptionWhenExistingTimeoutIsExecuted()
        throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 25,
            TimeUnit.MILLISECONDS, 4, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        timer.newTimeout(createCountDownLatchTimerTask(latch), 90, TimeUnit.MILLISECONDS);

        latch.await();

        final CountDownLatch secondLatch = new CountDownLatch(1);
        timer.newTimeout(createCountDownLatchTimerTask(secondLatch), 90, TimeUnit.MILLISECONDS);

        secondLatch.await();
        timer.stop();
    }
<A NAME="1"></A>
    @Test()
    public void reportPendingTimeouts() throws InterruptedException {
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match523998-0.html#1',2,'match523998-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final CountDownLatch latch = new CountDownLatch(1);
        final HashedWheelTimer timer = new HashedWheelTimer();
        final Timeout t1 = timer.newTimeout(createNoOpTimerTask(), 100, TimeUnit.MINUTES);
        final Timeout t2 = timer.newTimeout(createNoOpTimerTask</B></FONT>(), 100, TimeUnit.MINUTES);
        timer.newTimeout(createCountDownLatchTimerTask(latch), 90, TimeUnit.MILLISECONDS);

        assertEquals(3, timer.pendingTimeouts());
        t1.cancel();
        t2.cancel();
        latch.await();

        assertEquals(0, timer.pendingTimeouts());
        timer.stop();
    }

    @Test
    public void testOverflow() throws InterruptedException  {
        final HashedWheelTimer timer = new HashedWheelTimer();
        final CountDownLatch latch = new CountDownLatch(1);
        Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) {
                latch.countDown();
            }
        }, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
        assertFalse(latch.await(1, TimeUnit.SECONDS));
        timeout.cancel();
        timer.stop();
    }

    private static TimerTask createNoOpTimerTask() {
        return new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
            }
        };
    }

    private static TimerTask createCountDownLatchTimerTask(final CountDownLatch latch) {
        return new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                latch.countDown();
            }
        };
    }
}
</PRE>
</div>
  </div>
</body>
</html>
