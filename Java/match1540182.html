<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ForwardingWrapperTester.java &amp; Iterators_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ForwardingWrapperTester.java &amp; Iterators_1.java
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ForwardingWrapperTester.java (12.380953%)<th>Iterators_1.java (2.5275438%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-55)<td><a href="#" name="0">(35-70)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(229-235)<td><a href="#" name="1">(1186-1192)</a><td align="center"><font color="#860000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(66-77)<td><a href="#" name="2">(762-778)</a><td align="center"><font color="#860000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingWrapperTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.testing;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
4 import static com.google.common.base.Preconditions.checkNotNull;
5 import static com.google.common.base.Throwables.throwIfUnchecked;
6 import static junit.framework.Assert.assertEquals;
7 import static junit.framework.Assert.fail;
8 import com.google.common.annotations.GwtIncompatible;
9 import com.google.common.base.Function;
10 import com.google.common.base.Throwables;
11 import com.google.common.collect.Lists;
12 import com.google.common.reflect.AbstractInvocationHandler;
13 import com.google.common.reflect.Reflection;
14 import java.lang.reflect.AccessibleObject;
15 import java.lang.reflect.InvocationTargetException;
16 import java.lang.reflect.Method;
17 import java.lang.reflect.Modifier;
18 import java.util.List;
19 import java.util.concurrent.atomic.AtomicInteger;
20 @</b></font>GwtIncompatible
21 public final class ForwardingWrapperTester {
22   private boolean testsEquals = false;
23   public ForwardingWrapperTester includingEquals() {
24     this.testsEquals = true;
25     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
26   }
27   public &lt;T&gt; void testForwarding(
28       Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
29     checkNotNull(wrapperFunction);
30     checkArgument</b></font>(interfaceType.isInterface(), "%s isn't an interface", interfaceType);
31     Method[] methods = getMostConcreteMethods(interfaceType);
32     AccessibleObject.setAccessible(methods, true);
33     for (Method method : methods) {
34       if (!Modifier.isAbstract(method.getModifiers())) {
35         continue;
36       }
37       if (method.getName().equals("equals")
38           &amp;&amp; method.getParameterTypes().length == 1
39           &amp;&amp; method.getParameterTypes()[0] == Object.class) {
40         continue;
41       }
42       if (method.getName().equals("hashCode") &amp;&amp; method.getParameterTypes().length == 0) {
43         continue;
44       }
45       if (method.getName().equals("toString") &amp;&amp; method.getParameterTypes().length == 0) {
46         continue;
47       }
48       testSuccessfulForwarding(interfaceType, method, wrapperFunction);
49       testExceptionPropagation(interfaceType, method, wrapperFunction);
50     }
51     if (testsEquals) {
52       testEquals(interfaceType, wrapperFunction);
53     }
54     testToString(interfaceType, wrapperFunction);
55   }
56   private static Method[] getMostConcreteMethods(Class&lt;?&gt; type) {
57     Method[] methods = type.getMethods();
58     for (int i = 0; i &lt; methods.length; i++) {
59       try {
60         methods[i] = type.getMethod(methods[i].getName(), methods[i].getParameterTypes());
61       } catch (Exception e) {
62         throwIfUnchecked(e);
63         throw new RuntimeException(e);
64       }
65     }
66     return methods;
67   }
68   private static &lt;T&gt; void testSuccessfulForwarding(
69       Class&lt;T&gt; interfaceType, Method method, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
70     new InteractionTester&lt;T&gt;(interfaceType, method).testInteraction(wrapperFunction);
71   }
72   private static &lt;T&gt; void testExceptionPropagation(
73       Class&lt;T&gt; interfaceType, Method method, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
74     RuntimeException exception = new RuntimeException();
75     T proxy =
76         Reflection.newProxy(
77             interfaceType,
78             new AbstractInvocationHandler() {
79               @Override
80               protected Object handleInvocation(Object p, Method m, Object[] args)
81                   throws Throwable {
82                 throw exception;
83               }
84             });
85     T wrapper = wrapperFunction.apply(proxy);
86     try {
87       method.invoke(wrapper, getParameterValues(method));
88       fail(method + " failed to throw exception as is.");
89     } catch (InvocationTargetException e) {
90       if (exception != e.getCause()) {
91         throw new RuntimeException(e);
92       }
93     } catch (IllegalAccessException e) {
94       throw new AssertionError(e);
95     }
96   }
97   private static &lt;T&gt; void testEquals(
98       Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
99     FreshValueGenerator generator = new FreshValueGenerator();
100     T instance = generator.newFreshProxy(interfaceType);
101     new EqualsTester()
102         .addEqualityGroup(wrapperFunction.apply(instance), wrapperFunction.apply(instance))
103         .addEqualityGroup(wrapperFunction.apply(generator.newFreshProxy(interfaceType)))
104         .testEquals();
105   }
106   private static &lt;T&gt; void testToString(
107       Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
108     T proxy = new FreshValueGenerator().newFreshProxy(interfaceType);
109     assertEquals(
110         "toString() isn't properly forwarded",
111         proxy.toString(),
112         wrapperFunction.apply(proxy).toString());
113   }
114   private static Object[] getParameterValues(Method method) {
115     FreshValueGenerator paramValues = new FreshValueGenerator();
116     List&lt;Object&gt; passedArgs = Lists.newArrayList();
117     for (Class&lt;?&gt; paramType : method.getParameterTypes()) {
118       passedArgs.add(paramValues.generateFresh(paramType));
119     }
120     return passedArgs.toArray();
121   }
122   private static final class InteractionTester&lt;T&gt; extends AbstractInvocationHandler {
123     private final Class&lt;T&gt; interfaceType;
124     private final Method method;
125     private final Object[] passedArgs;
126     private final Object returnValue;
127     private final AtomicInteger called = new AtomicInteger();
128     InteractionTester(Class&lt;T&gt; interfaceType, Method method) {
129       this.interfaceType = interfaceType;
130       this.method = method;
131       this.passedArgs = getParameterValues(method);
132       this.returnValue = new FreshValueGenerator().generateFresh(method.getReturnType());
133     }
134     @Override
135     protected Object handleInvocation(Object p, Method calledMethod, Object[] args)
136         throws Throwable {
137       assertEquals(method, calledMethod);
138       assertEquals(method + " invoked more than once.", 0, called.get());
139       for (int i = 0; i &lt; passedArgs.length; i++) {
140         assertEquals(
141             "Parameter #" + i + " of " + method + " not forwarded", passedArgs[i], args[i]);
142       }
143       called.getAndIncrement();
144       return returnValue;
145     }
146     void testInteraction(Function&lt;? super T, ? extends T&gt; wrapperFunction) {
147       T proxy = Reflection.newProxy(interfaceType, this);
148       T wrapper = wrapperFunction.apply(proxy);
149       boolean isPossibleChainingCall = interfaceType.isAssignableFrom(method.getReturnType());
150       try {
151         Object actualReturnValue = method.invoke(wrapper, passedArgs);
152         if (!isPossibleChainingCall || wrapper != actualReturnValue) {
153           assertEquals(
154               "Return value of " + method + " not forwarded", returnValue, actualReturnValue);
155         }
156       } catch (IllegalAccessException e) {
157         throw new RuntimeException(e);
158 <a name="1"></a>      } catch (InvocationTargetException e) {
159         throw Throwables.propagate(e.getCause());
160       }
161       assertEquals("Failed to forward to " + method, 1, <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>called.get());
162     }
163     @Override
164     public String toString() {
165       return "dummy " + interfaceType.getSimpleName();
166     }</b></font>
167   }
168 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Iterators_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.base.Preconditions.checkState;
5 import static com.google.common.base.Predicates.instanceOf;
6 import static com.google.common.collect.CollectPreconditions.checkRemove;
7 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
8 import static java.util.Objects.requireNonNull;
9 import com.google.common.annotations.Beta;
10 import com.google.common.annotations.GwtCompatible;
11 import com.google.common.annotations.GwtIncompatible;
12 import com.google.common.base.Function;
13 import com.google.common.base.Objects;
14 <a name="0"></a>import com.google.common.base.Optional;
15 import com.google.common.base.Preconditions;
16 import com.google.common.base.Predicate;
17 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.primitives.Ints;
18 import com.google.errorprone.annotations.CanIgnoreReturnValue;
19 import java.util.ArrayDeque;
20 import java.util.Arrays;
21 import java.util.Collection;
22 import java.util.Collections;
23 import java.util.Comparator;
24 import java.util.Deque;
25 import java.util.Enumeration;
26 import java.util.Iterator;
27 import java.util.List;
28 import java.util.ListIterator;
29 import java.util.NoSuchElementException;
30 import java.util.PriorityQueue;
31 import java.util.Queue;
32 import javax.annotation.CheckForNull;
33 import org.checkerframework.checker.nullness.qual.Nullable;
34 @</b></font>GwtCompatible(emulated = true)
35 @ElementTypesAreNonnullByDefault
36 public final class Iterators {
37   private Iterators() {}
38   static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; emptyIterator() {
39     return emptyListIterator();
40   }
41   @SuppressWarnings("unchecked")
42   static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; emptyListIterator() {
43     return (UnmodifiableListIterator&lt;T&gt;) ArrayItr.EMPTY;
44   }
45   private enum EmptyModifiableIterator implements Iterator&lt;Object&gt; {
46     INSTANCE;
47     @Override
48     public boolean hasNext() {
49       return false;
50     }
51     @Override
52     public Object next() {
53       throw new NoSuchElementException();
54     }
55     @Override
56     public void remove() {
57       checkRemove(false);
58     }
59   }
60   @SuppressWarnings("unchecked")
61   static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; emptyModifiableIterator() {
62     return (Iterator&lt;T&gt;) EmptyModifiableIterator.INSTANCE;
63   }
64   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
65       Iterator&lt;? extends T&gt; iterator) {
66     checkNotNull(iterator);
67     if (iterator instanceof UnmodifiableIterator) {
68       @SuppressWarnings("unchecked")       UnmodifiableIterator&lt;T&gt; result = (UnmodifiableIterator&lt;T&gt;) iterator;
69       return result;
70     }
71     return new UnmodifiableIterator&lt;T&gt;() {
72       @Override
73       public boolean hasNext() {
74         return iterator.hasNext();
75       }
76       @Override
77       @ParametricNullness
78       public T next() {
79         return iterator.next();
80       }
81     };
82   }
83   @Deprecated
84   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
85       UnmodifiableIterator&lt;T&gt; iterator) {
86     return checkNotNull(iterator);
87   }
88   public static int size(Iterator&lt;?&gt; iterator) {
89     long count = 0L;
90     while (iterator.hasNext()) {
91       iterator.next();
92       count++;
93     }
94     return Ints.saturatedCast(count);
95   }
96   public static boolean contains(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
97     if (element == null) {
98       while (iterator.hasNext()) {
99         if (iterator.next() == null) {
100           return true;
101         }
102       }
103     } else {
104       while (iterator.hasNext()) {
105         if (element.equals(iterator.next())) {
106           return true;
107         }
108       }
109     }
110     return false;
111   }
112   @CanIgnoreReturnValue
113   public static boolean removeAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRemove) {
114     checkNotNull(elementsToRemove);
115     boolean result = false;
116     while (removeFrom.hasNext()) {
117       if (elementsToRemove.contains(removeFrom.next())) {
118         removeFrom.remove();
119         result = true;
120       }
121     }
122     return result;
123   }
124   @CanIgnoreReturnValue
125   public static &lt;T extends @Nullable Object&gt; boolean removeIf(
126       Iterator&lt;T&gt; removeFrom, Predicate&lt;? super T&gt; predicate) {
127     checkNotNull(predicate);
128     boolean modified = false;
129     while (removeFrom.hasNext()) {
130       if (predicate.apply(removeFrom.next())) {
131         removeFrom.remove();
132         modified = true;
133       }
134     }
135     return modified;
136   }
137   @CanIgnoreReturnValue
138   public static boolean retainAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRetain) {
139     checkNotNull(elementsToRetain);
140     boolean result = false;
141     while (removeFrom.hasNext()) {
142       if (!elementsToRetain.contains(removeFrom.next())) {
143         removeFrom.remove();
144         result = true;
145       }
146     }
147     return result;
148   }
149   public static boolean elementsEqual(Iterator&lt;?&gt; iterator1, Iterator&lt;?&gt; iterator2) {
150     while (iterator1.hasNext()) {
151       if (!iterator2.hasNext()) {
152         return false;
153       }
154       Object o1 = iterator1.next();
155       Object o2 = iterator2.next();
156       if (!Objects.equal(o1, o2)) {
157         return false;
158       }
159     }
160     return !iterator2.hasNext();
161   }
162   public static String toString(Iterator&lt;?&gt; iterator) {
163     StringBuilder sb = new StringBuilder().append('[');
164     boolean first = true;
165     while (iterator.hasNext()) {
166       if (!first) {
167         sb.append(", ");
168       }
169       first = false;
170       sb.append(iterator.next());
171     }
172     return sb.append(']').toString();
173   }
174   @ParametricNullness
175   public static &lt;T extends @Nullable Object&gt; T getOnlyElement(Iterator&lt;T&gt; iterator) {
176     T first = iterator.next();
177     if (!iterator.hasNext()) {
178       return first;
179     }
180     StringBuilder sb = new StringBuilder().append("expected one element but was: &lt;").append(first);
181     for (int i = 0; i &lt; 4 &amp;&amp; iterator.hasNext(); i++) {
182       sb.append(", ").append(iterator.next());
183     }
184     if (iterator.hasNext()) {
185       sb.append(", ...");
186     }
187     sb.append('&gt;');
188     throw new IllegalArgumentException(sb.toString());
189   }
190   @ParametricNullness
191   public static &lt;T extends @Nullable Object&gt; T getOnlyElement(
192       Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
193     return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
194   }
195   @GwtIncompatible   public static &lt;T&gt; @Nullable T[] toArray(Iterator&lt;? extends @Nullable T&gt; iterator, Class&lt;T&gt; type) {
196     List&lt;@Nullable T&gt; list = Lists.newArrayList(iterator);
197     return Iterables.toArray(list, type);
198   }
199   @CanIgnoreReturnValue
200   public static &lt;T extends @Nullable Object&gt; boolean addAll(
201       Collection&lt;T&gt; addTo, Iterator&lt;? extends T&gt; iterator) {
202     checkNotNull(addTo);
203     checkNotNull(iterator);
204     boolean wasModified = false;
205     while (iterator.hasNext()) {
206       wasModified |= addTo.add(iterator.next());
207     }
208     return wasModified;
209   }
210   public static int frequency(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
211     int count = 0;
212     while (contains(iterator, element)) {
213       count++;
214     }
215     return count;
216   }
217   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; cycle(Iterable&lt;T&gt; iterable) {
218     checkNotNull(iterable);
219     return new Iterator&lt;T&gt;() {
220       Iterator&lt;T&gt; iterator = emptyModifiableIterator();
221       @Override
222       public boolean hasNext() {
223         return iterator.hasNext() || iterable.iterator().hasNext();
224       }
225       @Override
226       @ParametricNullness
227       public T next() {
228         if (!iterator.hasNext()) {
229           iterator = iterable.iterator();
230           if (!iterator.hasNext()) {
231             throw new NoSuchElementException();
232           }
233         }
234         return iterator.next();
235       }
236       @Override
237       public void remove() {
238         iterator.remove();
239       }
240     };
241   }
242   @SafeVarargs
243   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; cycle(T... elements) {
244     return cycle(Lists.newArrayList(elements));
245   }
246   private static &lt;I extends Iterator&lt;?&gt;&gt; Iterator&lt;I&gt; consumingForArray(@Nullable I... elements) {
247     return new UnmodifiableIterator&lt;I&gt;() {
248       int index = 0;
249       @Override
250       public boolean hasNext() {
251         return index &lt; elements.length;
252       }
253       @Override
254       public I next() {
255         if (!hasNext()) {
256           throw new NoSuchElementException();
257         }
258         I result = requireNonNull(elements[index]);
259         elements[index] = null;
260         index++;
261         return result;
262       }
263     };
264   }
265   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
266       Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b) {
267     checkNotNull(a);
268     checkNotNull(b);
269     return concat(consumingForArray(a, b));
270   }
271   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
272       Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b, Iterator&lt;? extends T&gt; c) {
273     checkNotNull(a);
274     checkNotNull(b);
275     checkNotNull(c);
276     return concat(consumingForArray(a, b, c));
277   }
278   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
279       Iterator&lt;? extends T&gt; a,
280       Iterator&lt;? extends T&gt; b,
281       Iterator&lt;? extends T&gt; c,
282       Iterator&lt;? extends T&gt; d) {
283     checkNotNull(a);
284     checkNotNull(b);
285     checkNotNull(c);
286     checkNotNull(d);
287     return concat(consumingForArray(a, b, c, d));
288   }
289   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(Iterator&lt;? extends T&gt;... inputs) {
290     return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
291   }
292   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
293       Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; inputs) {
294     return new ConcatenatedIterator&lt;&gt;(inputs);
295   }
296   static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concatNoDefensiveCopy(
297       Iterator&lt;? extends T&gt;... inputs) {
298     for (Iterator&lt;? extends T&gt; input : checkNotNull(inputs)) {
299       checkNotNull(input);
300     }
301     return concat(consumingForArray(inputs));
302   }
303   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;T&gt;&gt; partition(
304       Iterator&lt;T&gt; iterator, int size) {
305     return partitionImpl(iterator, size, false);
306   }
307   public static &lt;T extends @Nullable Object&gt;
308       UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; paddedPartition(Iterator&lt;T&gt; iterator, int size) {
309     return partitionImpl(iterator, size, true);
310   }
311   private static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; partitionImpl(
312       Iterator&lt;T&gt; iterator, int size, boolean pad) {
313     checkNotNull(iterator);
314     checkArgument(size &gt; 0);
315     return new UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt;() {
316       @Override
317       public boolean hasNext() {
318         return iterator.hasNext();
319       }
320       @Override
321       public List&lt;@Nullable T&gt; next() {
322         if (!hasNext()) {
323           throw new NoSuchElementException();
324         }
325         @SuppressWarnings("unchecked")         @Nullable
326         T[] array = (@Nullable T[]) new Object[size];
327         int count = 0;
328         for (; count &lt; size &amp;&amp; iterator.hasNext(); count++) {
329           array[count] = iterator.next();
330         }
331         for (int i = count; i &lt; size; i++) {
332           array[i] = null;         }
333         List&lt;@Nullable T&gt; list = Collections.unmodifiableList(Arrays.asList(array));
334         if (pad || count == size) {
335           return list;
336         } else {
337           return list.subList(0, count);
338         }
339       }
340     };
341   }
342   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; filter(
343       Iterator&lt;T&gt; unfiltered, Predicate&lt;? super T&gt; retainIfTrue) {
344     checkNotNull(unfiltered);
345     checkNotNull(retainIfTrue);
346     return new AbstractIterator&lt;T&gt;() {
347       @Override
348       @CheckForNull
349       protected T computeNext() {
350         while (unfiltered.hasNext()) {
351           T element = unfiltered.next();
352           if (retainIfTrue.apply(element)) {
353             return element;
354           }
355         }
356         return endOfData();
357       }
358     };
359   }
360   @SuppressWarnings("unchecked")   @GwtIncompatible   public static &lt;T&gt; UnmodifiableIterator&lt;T&gt; filter(Iterator&lt;?&gt; unfiltered, Class&lt;T&gt; desiredType) {
361     return (UnmodifiableIterator&lt;T&gt;) filter(unfiltered, instanceOf(desiredType));
362   }
363   public static &lt;T extends @Nullable Object&gt; boolean any(
364       Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
365     return indexOf(iterator, predicate) != -1;
366   }
367   public static &lt;T extends @Nullable Object&gt; boolean all(
368       Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
369     checkNotNull(predicate);
370     while (iterator.hasNext()) {
371       T element = iterator.next();
372       if (!predicate.apply(element)) {
373         return false;
374       }
375     }
376     return true;
377   }
378   @ParametricNullness
379   public static &lt;T extends @Nullable Object&gt; T find(
380       Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
381     checkNotNull(iterator);
382     checkNotNull(predicate);
383     while (iterator.hasNext()) {
384       T t = iterator.next();
385       if (predicate.apply(t)) {
386         return t;
387       }
388     }
389     throw new NoSuchElementException();
390   }
391   @CheckForNull
392   public static &lt;T extends @Nullable Object&gt; T find(
393       Iterator&lt;? extends T&gt; iterator,
394       Predicate&lt;? super T&gt; predicate,
395       @CheckForNull T defaultValue) {
396     checkNotNull(iterator);
397     checkNotNull(predicate);
398     while (iterator.hasNext()) {
399       T t = iterator.next();
400       if (predicate.apply(t)) {
401 <a name="2"></a>        return t;
402       }
403     }
404     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return defaultValue;
405   }
406   public static &lt;T&gt; Optional&lt;T&gt; tryFind(Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
407     checkNotNull(iterator);
408     checkNotNull</b></font>(predicate);
409     while (iterator.hasNext()) {
410       T t = iterator.next();
411       if (predicate.apply(t)) {
412         return Optional.of(t);
413       }
414     }
415     return Optional.absent();
416   }
417   public static &lt;T extends @Nullable Object&gt; int indexOf(
418       Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
419     checkNotNull(predicate, "predicate");
420     for (int i = 0; iterator.hasNext(); i++) {
421       T current = iterator.next();
422       if (predicate.apply(current)) {
423         return i;
424       }
425     }
426     return -1;
427   }
428   public static &lt;F extends @Nullable Object, T extends @Nullable Object&gt; Iterator&lt;T&gt; transform(
429       Iterator&lt;F&gt; fromIterator, Function&lt;? super F, ? extends T&gt; function) {
430     checkNotNull(function);
431     return new TransformedIterator&lt;F, T&gt;(fromIterator) {
432       @ParametricNullness
433       @Override
434       T transform(@ParametricNullness F from) {
435         return function.apply(from);
436       }
437     };
438   }
439   @ParametricNullness
440   public static &lt;T extends @Nullable Object&gt; T get(Iterator&lt;T&gt; iterator, int position) {
441     checkNonnegative(position);
442     int skipped = advance(iterator, position);
443     if (!iterator.hasNext()) {
444       throw new IndexOutOfBoundsException(
445           "position ("
446               + position
447               + ") must be less than the number of elements that remained ("
448               + skipped
449               + ")");
450     }
451     return iterator.next();
452   }
453   @ParametricNullness
454   public static &lt;T extends @Nullable Object&gt; T get(
455       Iterator&lt;? extends T&gt; iterator, int position, @ParametricNullness T defaultValue) {
456     checkNonnegative(position);
457     advance(iterator, position);
458     return getNext(iterator, defaultValue);
459   }
460   static void checkNonnegative(int position) {
461     if (position &lt; 0) {
462       throw new IndexOutOfBoundsException("position (" + position + ") must not be negative");
463     }
464   }
465   @ParametricNullness
466   public static &lt;T extends @Nullable Object&gt; T getNext(
467       Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
468     return iterator.hasNext() ? iterator.next() : defaultValue;
469   }
470   @ParametricNullness
471   public static &lt;T extends @Nullable Object&gt; T getLast(Iterator&lt;T&gt; iterator) {
472     while (true) {
473       T current = iterator.next();
474       if (!iterator.hasNext()) {
475         return current;
476       }
477     }
478   }
479   @ParametricNullness
480   public static &lt;T extends @Nullable Object&gt; T getLast(
481       Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
482     return iterator.hasNext() ? getLast(iterator) : defaultValue;
483   }
484   @CanIgnoreReturnValue
485   public static int advance(Iterator&lt;?&gt; iterator, int numberToAdvance) {
486     checkNotNull(iterator);
487     checkArgument(numberToAdvance &gt;= 0, "numberToAdvance must be nonnegative");
488     int i;
489     for (i = 0; i &lt; numberToAdvance &amp;&amp; iterator.hasNext(); i++) {
490       iterator.next();
491     }
492     return i;
493   }
494   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; limit(
495       Iterator&lt;T&gt; iterator, int limitSize) {
496     checkNotNull(iterator);
497     checkArgument(limitSize &gt;= 0, "limit is negative");
498     return new Iterator&lt;T&gt;() {
499       private int count;
500       @Override
501       public boolean hasNext() {
502         return count &lt; limitSize &amp;&amp; iterator.hasNext();
503       }
504       @Override
505       @ParametricNullness
506       public T next() {
507         if (!hasNext()) {
508           throw new NoSuchElementException();
509         }
510         count++;
511         return iterator.next();
512       }
513       @Override
514       public void remove() {
515         iterator.remove();
516       }
517     };
518   }
519   public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; consumingIterator(Iterator&lt;T&gt; iterator) {
520     checkNotNull(iterator);
521     return new UnmodifiableIterator&lt;T&gt;() {
522       @Override
523       public boolean hasNext() {
524         return iterator.hasNext();
525       }
526       @Override
527       @ParametricNullness
528       public T next() {
529         T next = iterator.next();
530         iterator.remove();
531         return next;
532       }
533       @Override
534       public String toString() {
535         return "Iterators.consumingIterator(...)";
536       }
537     };
538   }
539   @CheckForNull
540   static &lt;T extends @Nullable Object&gt; T pollNext(Iterator&lt;T&gt; iterator) {
541     if (iterator.hasNext()) {
542       T result = iterator.next();
543       iterator.remove();
544       return result;
545     } else {
546       return null;
547     }
548   }
549   static void clear(Iterator&lt;?&gt; iterator) {
550     checkNotNull(iterator);
551     while (iterator.hasNext()) {
552       iterator.next();
553       iterator.remove();
554     }
555   }
556   @SafeVarargs
557   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forArray(T... array) {
558     return forArray(array, 0, array.length, 0);
559   }
560   static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; forArray(
561       T[] array, int offset, int length, int index) {
562     checkArgument(length &gt;= 0);
563     int end = offset + length;
564     Preconditions.checkPositionIndexes(offset, end, array.length);
565     Preconditions.checkPositionIndex(index, length);
566     if (length == 0) {
567       return emptyListIterator();
568     }
569     return new ArrayItr&lt;&gt;(array, offset, length, index);
570   }
571   private static final class ArrayItr&lt;T extends @Nullable Object&gt;
572       extends AbstractIndexedListIterator&lt;T&gt; {
573     static final UnmodifiableListIterator&lt;Object&gt; EMPTY = new ArrayItr&lt;&gt;(new Object[0], 0, 0, 0);
574     private final T[] array;
575     private final int offset;
576     ArrayItr(T[] array, int offset, int length, int index) {
577       super(length, index);
578       this.array = array;
579       this.offset = offset;
580     }
581     @Override
582     @ParametricNullness
583     protected T get(int index) {
584       return array[offset + index];
585     }
586   }
587   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; singletonIterator(
588       @ParametricNullness T value) {
589     return new UnmodifiableIterator&lt;T&gt;() {
590       boolean done;
591       @Override
592       public boolean hasNext() {
593         return !done;
594       }
595       @Override
596       @ParametricNullness
597       public T next() {
598         if (done) {
599           throw new NoSuchElementException();
600         }
601         done = true;
602         return value;
603       }
604     };
605   }
606   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forEnumeration(
607       Enumeration&lt;T&gt; enumeration) {
608     checkNotNull(enumeration);
609     return new UnmodifiableIterator&lt;T&gt;() {
610       @Override
611       public boolean hasNext() {
612         return enumeration.hasMoreElements();
613       }
614       @Override
615       @ParametricNullness
616       public T next() {
617         return enumeration.nextElement();
618       }
619     };
620   }
621   public static &lt;T extends @Nullable Object&gt; Enumeration&lt;T&gt; asEnumeration(Iterator&lt;T&gt; iterator) {
622     checkNotNull(iterator);
623     return new Enumeration&lt;T&gt;() {
624       @Override
625       public boolean hasMoreElements() {
626         return iterator.hasNext();
627       }
628       @Override
629       @ParametricNullness
630       public T nextElement() {
631         return iterator.next();
632       }
633     };
634   }
635   private static class PeekingImpl&lt;E extends @Nullable Object&gt; implements PeekingIterator&lt;E&gt; {
636     private final Iterator&lt;? extends E&gt; iterator;
637     private boolean hasPeeked;
638 <a name="1"></a>    @CheckForNull private E peekedElement;
639     public PeekingImpl(Iterator&lt;? extends E&gt; iterator) {
640       this.iterator = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>checkNotNull(iterator);
641     }
642     @Override
643     public boolean hasNext() {
644       return hasPeeked || iterator.hasNext();
645     }</b></font>
646     @Override
647     @ParametricNullness
648     public E next() {
649       if (!hasPeeked) {
650         return iterator.next();
651       }
652       E result = uncheckedCastNullableTToT(peekedElement);
653       hasPeeked = false;
654       peekedElement = null;
655       return result;
656     }
657     @Override
658     public void remove() {
659       checkState(!hasPeeked, "Can't remove after you've peeked at next");
660       iterator.remove();
661     }
662     @Override
663     @ParametricNullness
664     public E peek() {
665       if (!hasPeeked) {
666         peekedElement = iterator.next();
667         hasPeeked = true;
668       }
669       return uncheckedCastNullableTToT(peekedElement);
670     }
671   }
672   public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
673       Iterator&lt;? extends T&gt; iterator) {
674     if (iterator instanceof PeekingImpl) {
675       @SuppressWarnings("unchecked")
676       PeekingImpl&lt;T&gt; peeking = (PeekingImpl&lt;T&gt;) iterator;
677       return peeking;
678     }
679     return new PeekingImpl&lt;&gt;(iterator);
680   }
681   @Deprecated
682   public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
683       PeekingIterator&lt;T&gt; iterator) {
684     return checkNotNull(iterator);
685   }
686   @Beta
687   public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; mergeSorted(
688       Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; comparator) {
689     checkNotNull(iterators, "iterators");
690     checkNotNull(comparator, "comparator");
691     return new MergingIterator&lt;&gt;(iterators, comparator);
692   }
693   private static class MergingIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
694     final Queue&lt;PeekingIterator&lt;T&gt;&gt; queue;
695     public MergingIterator(
696         Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; itemComparator) {
697       Comparator&lt;PeekingIterator&lt;T&gt;&gt; heapComparator =
698           (PeekingIterator&lt;T&gt; o1, PeekingIterator&lt;T&gt; o2) -&gt;
699               itemComparator.compare(o1.peek(), o2.peek());
700       queue = new PriorityQueue&lt;&gt;(2, heapComparator);
701       for (Iterator&lt;? extends T&gt; iterator : iterators) {
702         if (iterator.hasNext()) {
703           queue.add(Iterators.peekingIterator(iterator));
704         }
705       }
706     }
707     @Override
708     public boolean hasNext() {
709       return !queue.isEmpty();
710     }
711     @Override
712     @ParametricNullness
713     public T next() {
714       PeekingIterator&lt;T&gt; nextIter = queue.remove();
715       T next = nextIter.next();
716       if (nextIter.hasNext()) {
717         queue.add(nextIter);
718       }
719       return next;
720     }
721   }
722   private static class ConcatenatedIterator&lt;T extends @Nullable Object&gt; implements Iterator&lt;T&gt; {
723     @CheckForNull private Iterator&lt;? extends T&gt; toRemove;
724     private Iterator&lt;? extends T&gt; iterator;
725     /*
726      * We track the "meta iterators," the iterators-of-iterators, below.  Usually, topMetaIterator
727      * is the only one in use, but if we encounter nested concatenations, we start a deque of
728      * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each
729      * operation O(1).
730      */
731     @CheckForNull private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; topMetaIterator;
732     @CheckForNull private Deque&lt;Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt;&gt; metaIterators;
733     ConcatenatedIterator(Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; metaIterator) {
734       iterator = emptyIterator();
735       topMetaIterator = checkNotNull(metaIterator);
736     }
737     @CheckForNull
738     private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; getTopMetaIterator() {
739       while (topMetaIterator == null || !topMetaIterator.hasNext()) {
740         if (metaIterators != null &amp;&amp; !metaIterators.isEmpty()) {
741           topMetaIterator = metaIterators.removeFirst();
742         } else {
743           return null;
744         }
745       }
746       return topMetaIterator;
747     }
748     @Override
749     public boolean hasNext() {
750       while (!checkNotNull(iterator).hasNext()) {
751         topMetaIterator = getTopMetaIterator();
752         if (topMetaIterator == null) {
753           return false;
754         }
755         iterator = topMetaIterator.next();
756         if (iterator instanceof ConcatenatedIterator) {
757           @SuppressWarnings("unchecked")
758           ConcatenatedIterator&lt;T&gt; topConcat = (ConcatenatedIterator&lt;T&gt;) iterator;
759           iterator = topConcat.iterator;
760           if (this.metaIterators == null) {
761             this.metaIterators = new ArrayDeque&lt;&gt;();
762           }
763           this.metaIterators.addFirst(this.topMetaIterator);
764           if (topConcat.metaIterators != null) {
765             while (!topConcat.metaIterators.isEmpty()) {
766               this.metaIterators.addFirst(topConcat.metaIterators.removeLast());
767             }
768           }
769           this.topMetaIterator = topConcat.topMetaIterator;
770         }
771       }
772       return true;
773     }
774     @Override
775     @ParametricNullness
776     public T next() {
777       if (hasNext()) {
778         toRemove = iterator;
779         return iterator.next();
780       } else {
781         throw new NoSuchElementException();
782       }
783     }
784     @Override
785     public void remove() {
786       if (toRemove == null) {
787         throw new IllegalStateException("no calls to next() since the last call to remove()");
788       }
789       toRemove.remove();
790       toRemove = null;
791     }
792   }
793   static &lt;T extends @Nullable Object&gt; ListIterator&lt;T&gt; cast(Iterator&lt;T&gt; iterator) {
794     return (ListIterator&lt;T&gt;) iterator;
795   }
796 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
