<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ForwardingWrapperTester.java &amp; Iterators_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ForwardingWrapperTester.java &amp; Iterators_1.java
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ForwardingWrapperTester.java (12.380953%)<th>Iterators_1.java (2.5275438%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-55)<td><a href="#" name="0">(35-70)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(229-235)<td><a href="#" name="1">(1186-1192)</a><td align="center"><font color="#860000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(66-77)<td><a href="#" name="2">(762-778)</a><td align="center"><font color="#860000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingWrapperTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.testing;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.throwIfUnchecked;
import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.fail;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Throwables;
import com.google.common.collect.Lists;
import com.google.common.reflect.AbstractInvocationHandler;
import com.google.common.reflect.Reflection;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
@</b></font>GwtIncompatible
public final class ForwardingWrapperTester {
  private boolean testsEquals = false;
  public ForwardingWrapperTester includingEquals() {
    this.testsEquals = true;
    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
  }
  public &lt;T&gt; void testForwarding(
      Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
    checkNotNull(wrapperFunction);
    checkArgument</b></font>(interfaceType.isInterface(), "%s isn't an interface", interfaceType);
    Method[] methods = getMostConcreteMethods(interfaceType);
    AccessibleObject.setAccessible(methods, true);
    for (Method method : methods) {
      if (!Modifier.isAbstract(method.getModifiers())) {
        continue;
      }
      if (method.getName().equals("equals")
          &amp;&amp; method.getParameterTypes().length == 1
          &amp;&amp; method.getParameterTypes()[0] == Object.class) {
        continue;
      }
      if (method.getName().equals("hashCode") &amp;&amp; method.getParameterTypes().length == 0) {
        continue;
      }
      if (method.getName().equals("toString") &amp;&amp; method.getParameterTypes().length == 0) {
        continue;
      }
      testSuccessfulForwarding(interfaceType, method, wrapperFunction);
      testExceptionPropagation(interfaceType, method, wrapperFunction);
    }
    if (testsEquals) {
      testEquals(interfaceType, wrapperFunction);
    }
    testToString(interfaceType, wrapperFunction);
  }
  private static Method[] getMostConcreteMethods(Class&lt;?&gt; type) {
    Method[] methods = type.getMethods();
    for (int i = 0; i &lt; methods.length; i++) {
      try {
        methods[i] = type.getMethod(methods[i].getName(), methods[i].getParameterTypes());
      } catch (Exception e) {
        throwIfUnchecked(e);
        throw new RuntimeException(e);
      }
    }
    return methods;
  }
  private static &lt;T&gt; void testSuccessfulForwarding(
      Class&lt;T&gt; interfaceType, Method method, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
    new InteractionTester&lt;T&gt;(interfaceType, method).testInteraction(wrapperFunction);
  }
  private static &lt;T&gt; void testExceptionPropagation(
      Class&lt;T&gt; interfaceType, Method method, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
    RuntimeException exception = new RuntimeException();
    T proxy =
        Reflection.newProxy(
            interfaceType,
            new AbstractInvocationHandler() {
              @Override
              protected Object handleInvocation(Object p, Method m, Object[] args)
                  throws Throwable {
                throw exception;
              }
            });
    T wrapper = wrapperFunction.apply(proxy);
    try {
      method.invoke(wrapper, getParameterValues(method));
      fail(method + " failed to throw exception as is.");
    } catch (InvocationTargetException e) {
      if (exception != e.getCause()) {
        throw new RuntimeException(e);
      }
    } catch (IllegalAccessException e) {
      throw new AssertionError(e);
    }
  }
  private static &lt;T&gt; void testEquals(
      Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
    FreshValueGenerator generator = new FreshValueGenerator();
    T instance = generator.newFreshProxy(interfaceType);
    new EqualsTester()
        .addEqualityGroup(wrapperFunction.apply(instance), wrapperFunction.apply(instance))
        .addEqualityGroup(wrapperFunction.apply(generator.newFreshProxy(interfaceType)))
        .testEquals();
  }
  private static &lt;T&gt; void testToString(
      Class&lt;T&gt; interfaceType, Function&lt;? super T, ? extends T&gt; wrapperFunction) {
    T proxy = new FreshValueGenerator().newFreshProxy(interfaceType);
    assertEquals(
        "toString() isn't properly forwarded",
        proxy.toString(),
        wrapperFunction.apply(proxy).toString());
  }
  private static Object[] getParameterValues(Method method) {
    FreshValueGenerator paramValues = new FreshValueGenerator();
    List&lt;Object&gt; passedArgs = Lists.newArrayList();
    for (Class&lt;?&gt; paramType : method.getParameterTypes()) {
      passedArgs.add(paramValues.generateFresh(paramType));
    }
    return passedArgs.toArray();
  }
  private static final class InteractionTester&lt;T&gt; extends AbstractInvocationHandler {
    private final Class&lt;T&gt; interfaceType;
    private final Method method;
    private final Object[] passedArgs;
    private final Object returnValue;
    private final AtomicInteger called = new AtomicInteger();
    InteractionTester(Class&lt;T&gt; interfaceType, Method method) {
      this.interfaceType = interfaceType;
      this.method = method;
      this.passedArgs = getParameterValues(method);
      this.returnValue = new FreshValueGenerator().generateFresh(method.getReturnType());
    }
    @Override
    protected Object handleInvocation(Object p, Method calledMethod, Object[] args)
        throws Throwable {
      assertEquals(method, calledMethod);
      assertEquals(method + " invoked more than once.", 0, called.get());
      for (int i = 0; i &lt; passedArgs.length; i++) {
        assertEquals(
            "Parameter #" + i + " of " + method + " not forwarded", passedArgs[i], args[i]);
      }
      called.getAndIncrement();
      return returnValue;
    }
    void testInteraction(Function&lt;? super T, ? extends T&gt; wrapperFunction) {
      T proxy = Reflection.newProxy(interfaceType, this);
      T wrapper = wrapperFunction.apply(proxy);
      boolean isPossibleChainingCall = interfaceType.isAssignableFrom(method.getReturnType());
      try {
        Object actualReturnValue = method.invoke(wrapper, passedArgs);
        if (!isPossibleChainingCall || wrapper != actualReturnValue) {
          assertEquals(
              "Return value of " + method + " not forwarded", returnValue, actualReturnValue);
        }
      } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
<a name="1"></a>      } catch (InvocationTargetException e) {
        throw Throwables.propagate(e.getCause());
      }
      assertEquals("Failed to forward to " + method, 1, <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>called.get());
    }
    @Override
    public String toString() {
      return "dummy " + interfaceType.getSimpleName();
    }</b></font>
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Iterators_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.base.Predicates.instanceOf;
import static com.google.common.collect.CollectPreconditions.checkRemove;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import static java.util.Objects.requireNonNull;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Objects;
<a name="0"></a>import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@</b></font>GwtCompatible(emulated = true)
@ElementTypesAreNonnullByDefault
public final class Iterators {
  private Iterators() {}
  static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; emptyIterator() {
    return emptyListIterator();
  }
  @SuppressWarnings("unchecked")
  static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; emptyListIterator() {
    return (UnmodifiableListIterator&lt;T&gt;) ArrayItr.EMPTY;
  }
  private enum EmptyModifiableIterator implements Iterator&lt;Object&gt; {
    INSTANCE;
    @Override
    public boolean hasNext() {
      return false;
    }
    @Override
    public Object next() {
      throw new NoSuchElementException();
    }
    @Override
    public void remove() {
      checkRemove(false);
    }
  }
  @SuppressWarnings("unchecked")
  static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; emptyModifiableIterator() {
    return (Iterator&lt;T&gt;) EmptyModifiableIterator.INSTANCE;
  }
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
      Iterator&lt;? extends T&gt; iterator) {
    checkNotNull(iterator);
    if (iterator instanceof UnmodifiableIterator) {
      @SuppressWarnings("unchecked")       UnmodifiableIterator&lt;T&gt; result = (UnmodifiableIterator&lt;T&gt;) iterator;
      return result;
    }
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }
      @Override
      @ParametricNullness
      public T next() {
        return iterator.next();
      }
    };
  }
  @Deprecated
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
      UnmodifiableIterator&lt;T&gt; iterator) {
    return checkNotNull(iterator);
  }
  public static int size(Iterator&lt;?&gt; iterator) {
    long count = 0L;
    while (iterator.hasNext()) {
      iterator.next();
      count++;
    }
    return Ints.saturatedCast(count);
  }
  public static boolean contains(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
    if (element == null) {
      while (iterator.hasNext()) {
        if (iterator.next() == null) {
          return true;
        }
      }
    } else {
      while (iterator.hasNext()) {
        if (element.equals(iterator.next())) {
          return true;
        }
      }
    }
    return false;
  }
  @CanIgnoreReturnValue
  public static boolean removeAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRemove) {
    checkNotNull(elementsToRemove);
    boolean result = false;
    while (removeFrom.hasNext()) {
      if (elementsToRemove.contains(removeFrom.next())) {
        removeFrom.remove();
        result = true;
      }
    }
    return result;
  }
  @CanIgnoreReturnValue
  public static &lt;T extends @Nullable Object&gt; boolean removeIf(
      Iterator&lt;T&gt; removeFrom, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate);
    boolean modified = false;
    while (removeFrom.hasNext()) {
      if (predicate.apply(removeFrom.next())) {
        removeFrom.remove();
        modified = true;
      }
    }
    return modified;
  }
  @CanIgnoreReturnValue
  public static boolean retainAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRetain) {
    checkNotNull(elementsToRetain);
    boolean result = false;
    while (removeFrom.hasNext()) {
      if (!elementsToRetain.contains(removeFrom.next())) {
        removeFrom.remove();
        result = true;
      }
    }
    return result;
  }
  public static boolean elementsEqual(Iterator&lt;?&gt; iterator1, Iterator&lt;?&gt; iterator2) {
    while (iterator1.hasNext()) {
      if (!iterator2.hasNext()) {
        return false;
      }
      Object o1 = iterator1.next();
      Object o2 = iterator2.next();
      if (!Objects.equal(o1, o2)) {
        return false;
      }
    }
    return !iterator2.hasNext();
  }
  public static String toString(Iterator&lt;?&gt; iterator) {
    StringBuilder sb = new StringBuilder().append('[');
    boolean first = true;
    while (iterator.hasNext()) {
      if (!first) {
        sb.append(", ");
      }
      first = false;
      sb.append(iterator.next());
    }
    return sb.append(']').toString();
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getOnlyElement(Iterator&lt;T&gt; iterator) {
    T first = iterator.next();
    if (!iterator.hasNext()) {
      return first;
    }
    StringBuilder sb = new StringBuilder().append("expected one element but was: &lt;").append(first);
    for (int i = 0; i &lt; 4 &amp;&amp; iterator.hasNext(); i++) {
      sb.append(", ").append(iterator.next());
    }
    if (iterator.hasNext()) {
      sb.append(", ...");
    }
    sb.append('&gt;');
    throw new IllegalArgumentException(sb.toString());
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getOnlyElement(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
  }
  @GwtIncompatible   public static &lt;T&gt; @Nullable T[] toArray(Iterator&lt;? extends @Nullable T&gt; iterator, Class&lt;T&gt; type) {
    List&lt;@Nullable T&gt; list = Lists.newArrayList(iterator);
    return Iterables.toArray(list, type);
  }
  @CanIgnoreReturnValue
  public static &lt;T extends @Nullable Object&gt; boolean addAll(
      Collection&lt;T&gt; addTo, Iterator&lt;? extends T&gt; iterator) {
    checkNotNull(addTo);
    checkNotNull(iterator);
    boolean wasModified = false;
    while (iterator.hasNext()) {
      wasModified |= addTo.add(iterator.next());
    }
    return wasModified;
  }
  public static int frequency(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
    int count = 0;
    while (contains(iterator, element)) {
      count++;
    }
    return count;
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; cycle(Iterable&lt;T&gt; iterable) {
    checkNotNull(iterable);
    return new Iterator&lt;T&gt;() {
      Iterator&lt;T&gt; iterator = emptyModifiableIterator();
      @Override
      public boolean hasNext() {
        return iterator.hasNext() || iterable.iterator().hasNext();
      }
      @Override
      @ParametricNullness
      public T next() {
        if (!iterator.hasNext()) {
          iterator = iterable.iterator();
          if (!iterator.hasNext()) {
            throw new NoSuchElementException();
          }
        }
        return iterator.next();
      }
      @Override
      public void remove() {
        iterator.remove();
      }
    };
  }
  @SafeVarargs
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; cycle(T... elements) {
    return cycle(Lists.newArrayList(elements));
  }
  private static &lt;I extends Iterator&lt;?&gt;&gt; Iterator&lt;I&gt; consumingForArray(@Nullable I... elements) {
    return new UnmodifiableIterator&lt;I&gt;() {
      int index = 0;
      @Override
      public boolean hasNext() {
        return index &lt; elements.length;
      }
      @Override
      public I next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        I result = requireNonNull(elements[index]);
        elements[index] = null;
        index++;
        return result;
      }
    };
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b) {
    checkNotNull(a);
    checkNotNull(b);
    return concat(consumingForArray(a, b));
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b, Iterator&lt;? extends T&gt; c) {
    checkNotNull(a);
    checkNotNull(b);
    checkNotNull(c);
    return concat(consumingForArray(a, b, c));
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a,
      Iterator&lt;? extends T&gt; b,
      Iterator&lt;? extends T&gt; c,
      Iterator&lt;? extends T&gt; d) {
    checkNotNull(a);
    checkNotNull(b);
    checkNotNull(c);
    checkNotNull(d);
    return concat(consumingForArray(a, b, c, d));
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(Iterator&lt;? extends T&gt;... inputs) {
    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; inputs) {
    return new ConcatenatedIterator&lt;&gt;(inputs);
  }
  static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concatNoDefensiveCopy(
      Iterator&lt;? extends T&gt;... inputs) {
    for (Iterator&lt;? extends T&gt; input : checkNotNull(inputs)) {
      checkNotNull(input);
    }
    return concat(consumingForArray(inputs));
  }
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;T&gt;&gt; partition(
      Iterator&lt;T&gt; iterator, int size) {
    return partitionImpl(iterator, size, false);
  }
  public static &lt;T extends @Nullable Object&gt;
      UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; paddedPartition(Iterator&lt;T&gt; iterator, int size) {
    return partitionImpl(iterator, size, true);
  }
  private static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; partitionImpl(
      Iterator&lt;T&gt; iterator, int size, boolean pad) {
    checkNotNull(iterator);
    checkArgument(size &gt; 0);
    return new UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }
      @Override
      public List&lt;@Nullable T&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        @SuppressWarnings("unchecked")         @Nullable
        T[] array = (@Nullable T[]) new Object[size];
        int count = 0;
        for (; count &lt; size &amp;&amp; iterator.hasNext(); count++) {
          array[count] = iterator.next();
        }
        for (int i = count; i &lt; size; i++) {
          array[i] = null;         }
        List&lt;@Nullable T&gt; list = Collections.unmodifiableList(Arrays.asList(array));
        if (pad || count == size) {
          return list;
        } else {
          return list.subList(0, count);
        }
      }
    };
  }
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; filter(
      Iterator&lt;T&gt; unfiltered, Predicate&lt;? super T&gt; retainIfTrue) {
    checkNotNull(unfiltered);
    checkNotNull(retainIfTrue);
    return new AbstractIterator&lt;T&gt;() {
      @Override
      @CheckForNull
      protected T computeNext() {
        while (unfiltered.hasNext()) {
          T element = unfiltered.next();
          if (retainIfTrue.apply(element)) {
            return element;
          }
        }
        return endOfData();
      }
    };
  }
  @SuppressWarnings("unchecked")   @GwtIncompatible   public static &lt;T&gt; UnmodifiableIterator&lt;T&gt; filter(Iterator&lt;?&gt; unfiltered, Class&lt;T&gt; desiredType) {
    return (UnmodifiableIterator&lt;T&gt;) filter(unfiltered, instanceOf(desiredType));
  }
  public static &lt;T extends @Nullable Object&gt; boolean any(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    return indexOf(iterator, predicate) != -1;
  }
  public static &lt;T extends @Nullable Object&gt; boolean all(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T element = iterator.next();
      if (!predicate.apply(element)) {
        return false;
      }
    }
    return true;
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T find(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return t;
      }
    }
    throw new NoSuchElementException();
  }
  @CheckForNull
  public static &lt;T extends @Nullable Object&gt; T find(
      Iterator&lt;? extends T&gt; iterator,
      Predicate&lt;? super T&gt; predicate,
      @CheckForNull T defaultValue) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
<a name="2"></a>        return t;
      }
    }
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return defaultValue;
  }
  public static &lt;T&gt; Optional&lt;T&gt; tryFind(Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(iterator);
    checkNotNull</b></font>(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return Optional.of(t);
      }
    }
    return Optional.absent();
  }
  public static &lt;T extends @Nullable Object&gt; int indexOf(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate, "predicate");
    for (int i = 0; iterator.hasNext(); i++) {
      T current = iterator.next();
      if (predicate.apply(current)) {
        return i;
      }
    }
    return -1;
  }
  public static &lt;F extends @Nullable Object, T extends @Nullable Object&gt; Iterator&lt;T&gt; transform(
      Iterator&lt;F&gt; fromIterator, Function&lt;? super F, ? extends T&gt; function) {
    checkNotNull(function);
    return new TransformedIterator&lt;F, T&gt;(fromIterator) {
      @ParametricNullness
      @Override
      T transform(@ParametricNullness F from) {
        return function.apply(from);
      }
    };
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T get(Iterator&lt;T&gt; iterator, int position) {
    checkNonnegative(position);
    int skipped = advance(iterator, position);
    if (!iterator.hasNext()) {
      throw new IndexOutOfBoundsException(
          "position ("
              + position
              + ") must be less than the number of elements that remained ("
              + skipped
              + ")");
    }
    return iterator.next();
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T get(
      Iterator&lt;? extends T&gt; iterator, int position, @ParametricNullness T defaultValue) {
    checkNonnegative(position);
    advance(iterator, position);
    return getNext(iterator, defaultValue);
  }
  static void checkNonnegative(int position) {
    if (position &lt; 0) {
      throw new IndexOutOfBoundsException("position (" + position + ") must not be negative");
    }
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getNext(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return iterator.hasNext() ? iterator.next() : defaultValue;
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getLast(Iterator&lt;T&gt; iterator) {
    while (true) {
      T current = iterator.next();
      if (!iterator.hasNext()) {
        return current;
      }
    }
  }
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getLast(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return iterator.hasNext() ? getLast(iterator) : defaultValue;
  }
  @CanIgnoreReturnValue
  public static int advance(Iterator&lt;?&gt; iterator, int numberToAdvance) {
    checkNotNull(iterator);
    checkArgument(numberToAdvance &gt;= 0, "numberToAdvance must be nonnegative");
    int i;
    for (i = 0; i &lt; numberToAdvance &amp;&amp; iterator.hasNext(); i++) {
      iterator.next();
    }
    return i;
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; limit(
      Iterator&lt;T&gt; iterator, int limitSize) {
    checkNotNull(iterator);
    checkArgument(limitSize &gt;= 0, "limit is negative");
    return new Iterator&lt;T&gt;() {
      private int count;
      @Override
      public boolean hasNext() {
        return count &lt; limitSize &amp;&amp; iterator.hasNext();
      }
      @Override
      @ParametricNullness
      public T next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        count++;
        return iterator.next();
      }
      @Override
      public void remove() {
        iterator.remove();
      }
    };
  }
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; consumingIterator(Iterator&lt;T&gt; iterator) {
    checkNotNull(iterator);
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }
      @Override
      @ParametricNullness
      public T next() {
        T next = iterator.next();
        iterator.remove();
        return next;
      }
      @Override
      public String toString() {
        return "Iterators.consumingIterator(...)";
      }
    };
  }
  @CheckForNull
  static &lt;T extends @Nullable Object&gt; T pollNext(Iterator&lt;T&gt; iterator) {
    if (iterator.hasNext()) {
      T result = iterator.next();
      iterator.remove();
      return result;
    } else {
      return null;
    }
  }
  static void clear(Iterator&lt;?&gt; iterator) {
    checkNotNull(iterator);
    while (iterator.hasNext()) {
      iterator.next();
      iterator.remove();
    }
  }
  @SafeVarargs
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forArray(T... array) {
    return forArray(array, 0, array.length, 0);
  }
  static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; forArray(
      T[] array, int offset, int length, int index) {
    checkArgument(length &gt;= 0);
    int end = offset + length;
    Preconditions.checkPositionIndexes(offset, end, array.length);
    Preconditions.checkPositionIndex(index, length);
    if (length == 0) {
      return emptyListIterator();
    }
    return new ArrayItr&lt;&gt;(array, offset, length, index);
  }
  private static final class ArrayItr&lt;T extends @Nullable Object&gt;
      extends AbstractIndexedListIterator&lt;T&gt; {
    static final UnmodifiableListIterator&lt;Object&gt; EMPTY = new ArrayItr&lt;&gt;(new Object[0], 0, 0, 0);
    private final T[] array;
    private final int offset;
    ArrayItr(T[] array, int offset, int length, int index) {
      super(length, index);
      this.array = array;
      this.offset = offset;
    }
    @Override
    @ParametricNullness
    protected T get(int index) {
      return array[offset + index];
    }
  }
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; singletonIterator(
      @ParametricNullness T value) {
    return new UnmodifiableIterator&lt;T&gt;() {
      boolean done;
      @Override
      public boolean hasNext() {
        return !done;
      }
      @Override
      @ParametricNullness
      public T next() {
        if (done) {
          throw new NoSuchElementException();
        }
        done = true;
        return value;
      }
    };
  }
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forEnumeration(
      Enumeration&lt;T&gt; enumeration) {
    checkNotNull(enumeration);
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return enumeration.hasMoreElements();
      }
      @Override
      @ParametricNullness
      public T next() {
        return enumeration.nextElement();
      }
    };
  }
  public static &lt;T extends @Nullable Object&gt; Enumeration&lt;T&gt; asEnumeration(Iterator&lt;T&gt; iterator) {
    checkNotNull(iterator);
    return new Enumeration&lt;T&gt;() {
      @Override
      public boolean hasMoreElements() {
        return iterator.hasNext();
      }
      @Override
      @ParametricNullness
      public T nextElement() {
        return iterator.next();
      }
    };
  }
  private static class PeekingImpl&lt;E extends @Nullable Object&gt; implements PeekingIterator&lt;E&gt; {
    private final Iterator&lt;? extends E&gt; iterator;
    private boolean hasPeeked;
<a name="1"></a>    @CheckForNull private E peekedElement;
    public PeekingImpl(Iterator&lt;? extends E&gt; iterator) {
      this.iterator = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>checkNotNull(iterator);
    }
    @Override
    public boolean hasNext() {
      return hasPeeked || iterator.hasNext();
    }</b></font>
    @Override
    @ParametricNullness
    public E next() {
      if (!hasPeeked) {
        return iterator.next();
      }
      E result = uncheckedCastNullableTToT(peekedElement);
      hasPeeked = false;
      peekedElement = null;
      return result;
    }
    @Override
    public void remove() {
      checkState(!hasPeeked, "Can't remove after you've peeked at next");
      iterator.remove();
    }
    @Override
    @ParametricNullness
    public E peek() {
      if (!hasPeeked) {
        peekedElement = iterator.next();
        hasPeeked = true;
      }
      return uncheckedCastNullableTToT(peekedElement);
    }
  }
  public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
      Iterator&lt;? extends T&gt; iterator) {
    if (iterator instanceof PeekingImpl) {
      @SuppressWarnings("unchecked")
      PeekingImpl&lt;T&gt; peeking = (PeekingImpl&lt;T&gt;) iterator;
      return peeking;
    }
    return new PeekingImpl&lt;&gt;(iterator);
  }
  @Deprecated
  public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
      PeekingIterator&lt;T&gt; iterator) {
    return checkNotNull(iterator);
  }
  @Beta
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; mergeSorted(
      Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; comparator) {
    checkNotNull(iterators, "iterators");
    checkNotNull(comparator, "comparator");
    return new MergingIterator&lt;&gt;(iterators, comparator);
  }
  private static class MergingIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
    final Queue&lt;PeekingIterator&lt;T&gt;&gt; queue;
    public MergingIterator(
        Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; itemComparator) {
      Comparator&lt;PeekingIterator&lt;T&gt;&gt; heapComparator =
          (PeekingIterator&lt;T&gt; o1, PeekingIterator&lt;T&gt; o2) -&gt;
              itemComparator.compare(o1.peek(), o2.peek());
      queue = new PriorityQueue&lt;&gt;(2, heapComparator);
      for (Iterator&lt;? extends T&gt; iterator : iterators) {
        if (iterator.hasNext()) {
          queue.add(Iterators.peekingIterator(iterator));
        }
      }
    }
    @Override
    public boolean hasNext() {
      return !queue.isEmpty();
    }
    @Override
    @ParametricNullness
    public T next() {
      PeekingIterator&lt;T&gt; nextIter = queue.remove();
      T next = nextIter.next();
      if (nextIter.hasNext()) {
        queue.add(nextIter);
      }
      return next;
    }
  }
  private static class ConcatenatedIterator&lt;T extends @Nullable Object&gt; implements Iterator&lt;T&gt; {
    @CheckForNull private Iterator&lt;? extends T&gt; toRemove;
    private Iterator&lt;? extends T&gt; iterator;
    /*
     * We track the "meta iterators," the iterators-of-iterators, below.  Usually, topMetaIterator
     * is the only one in use, but if we encounter nested concatenations, we start a deque of
     * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each
     * operation O(1).
     */
    @CheckForNull private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; topMetaIterator;
    @CheckForNull private Deque&lt;Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt;&gt; metaIterators;
    ConcatenatedIterator(Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; metaIterator) {
      iterator = emptyIterator();
      topMetaIterator = checkNotNull(metaIterator);
    }
    @CheckForNull
    private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; getTopMetaIterator() {
      while (topMetaIterator == null || !topMetaIterator.hasNext()) {
        if (metaIterators != null &amp;&amp; !metaIterators.isEmpty()) {
          topMetaIterator = metaIterators.removeFirst();
        } else {
          return null;
        }
      }
      return topMetaIterator;
    }
    @Override
    public boolean hasNext() {
      while (!checkNotNull(iterator).hasNext()) {
        topMetaIterator = getTopMetaIterator();
        if (topMetaIterator == null) {
          return false;
        }
        iterator = topMetaIterator.next();
        if (iterator instanceof ConcatenatedIterator) {
          @SuppressWarnings("unchecked")
          ConcatenatedIterator&lt;T&gt; topConcat = (ConcatenatedIterator&lt;T&gt;) iterator;
          iterator = topConcat.iterator;
          if (this.metaIterators == null) {
            this.metaIterators = new ArrayDeque&lt;&gt;();
          }
          this.metaIterators.addFirst(this.topMetaIterator);
          if (topConcat.metaIterators != null) {
            while (!topConcat.metaIterators.isEmpty()) {
              this.metaIterators.addFirst(topConcat.metaIterators.removeLast());
            }
          }
          this.topMetaIterator = topConcat.topMetaIterator;
        }
      }
      return true;
    }
    @Override
    @ParametricNullness
    public T next() {
      if (hasNext()) {
        toRemove = iterator;
        return iterator.next();
      } else {
        throw new NoSuchElementException();
      }
    }
    @Override
    public void remove() {
      if (toRemove == null) {
        throw new IllegalStateException("no calls to next() since the last call to remove()");
      }
      toRemove.remove();
      toRemove = null;
    }
  }
  static &lt;T extends @Nullable Object&gt; ListIterator&lt;T&gt; cast(Iterator&lt;T&gt; iterator) {
    return (ListIterator&lt;T&gt;) iterator;
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
