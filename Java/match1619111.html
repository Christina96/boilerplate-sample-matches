<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Utf8Test_1.java &amp; MapMakerInternalMap_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Utf8Test_1.java &amp; MapMakerInternalMap_1.java
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Utf8Test_1.java (22.189348%)<th>MapMakerInternalMap_1.java (2.0701077%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-42)<td><a href="#" name="0">(37-67)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(192-206)<td><a href="#" name="1">(2072-2083)</a><td align="center"><font color="#ef0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(251-258)<td><a href="#" name="2">(1234-1241)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(306-321)<td><a href="#" name="3">(460-470)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(115-119)<td><a href="#" name="4">(1304-1308)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(102-104)<td><a href="#" name="5">(2424-2426)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Utf8Test_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.base;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.truth.Truth.assertThat;
4 import static java.lang.Character.MAX_CODE_POINT;
5 import static java.lang.Character.MAX_HIGH_SURROGATE;
6 import static java.lang.Character.MAX_LOW_SURROGATE;
7 import static java.lang.Character.MIN_HIGH_SURROGATE;
8 import static java.lang.Character.MIN_LOW_SURROGATE;
9 import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;
10 import com.google.common.annotations.GwtCompatible;
11 import com.google.common.annotations.GwtIncompatible;
12 import com.google.common.collect.ImmutableList;
13 import java.util.Arrays;
14 import java.util.HashMap;
15 import java.util.Random;
16 import junit.framework.TestCase;
17 @</b></font>GwtCompatible(emulated = true)
18 public class Utf8Test extends TestCase {
19   private static final ImmutableList&lt;String&gt; ILL_FORMED_STRINGS;
20   static {
21     ImmutableList.Builder&lt;String&gt; builder = ImmutableList.builder();
22     char[] surrogates = {
23       MAX_LOW_SURROGATE, MAX_HIGH_SURROGATE, MIN_LOW_SURROGATE, MIN_HIGH_SURROGATE,
24     };
25     for (char surrogate : surrogates) {
26       builder.add(newString(surrogate));
27       builder.add(newString(surrogate, 'n'));
28       builder.add(newString('n', surrogate));
29       builder.add(newString(surrogate, surrogate));
30     }
31     builder.add(newString(MIN_LOW_SURROGATE, MAX_HIGH_SURROGATE));
32     ILL_FORMED_STRINGS = builder.build();
33   }
34   public void testEncodedLength_validStrings() {
35     assertEquals(0, Utf8.encodedLength(""));
36     assertEquals(11, Utf8.encodedLength("Hello world"));
37     assertEquals(8, Utf8.encodedLength("Résumé"));
38     assertEquals(
39         461,
40         Utf8.encodedLength(
41             "威廉·莎士比亞（William Shakespeare，"
42                 + "1564年4月26號—1616年4月23號[1]）係隻英國嗰演員、劇作家同詩人，"
43                 + "有時間佢簡稱莎翁；中國清末民初哈拕翻譯做舌克斯毕、沙斯皮耳、筛斯比耳、"
44                 + "莎基斯庇尔、索士比尔、夏克思芘尔、希哀苦皮阿、叶斯壁、沙克皮尔、"
45                 + "狹斯丕爾。[2]莎士比亞編寫過好多作品，佢嗰劇作響西洋文學好有影響，"
46                 + "哈都拕人翻譯做好多話。"));
47     assertEquals(4, Utf8.encodedLength(newString(MIN_HIGH_SURROGATE, MIN_LOW_SURROGATE)));
48   }
49   public void testEncodedLength_validStrings2() {
50     HashMap&lt;Integer, Integer&gt; utf8Lengths = new HashMap&lt;&gt;();
51     utf8Lengths.put(0x00, 1);
52     utf8Lengths.put(0x7f, 1);
53     utf8Lengths.put(0x80, 2);
54     utf8Lengths.put(0x7ff, 2);
55     utf8Lengths.put(0x800, 3);
56     utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT - 1, 3);
57     utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT, 4);
58     utf8Lengths.put(MAX_CODE_POINT, 4);
59     Integer[] codePoints = utf8Lengths.keySet().toArray(new Integer[] {});
60     StringBuilder sb = new StringBuilder();
61     Random rnd = new Random();
62     for (int trial = 0; trial &lt; 100; trial++) {
63       sb.setLength(0);
64       int utf8Length = 0;
65       for (int i = 0; i &lt; 6; i++) {
66         Integer randomCodePoint = codePoints[rnd.nextInt(codePoints.length)];
67         sb.appendCodePoint(randomCodePoint);
68 <a name="5"></a>        utf8Length += utf8Lengths.get(randomCodePoint);
69         if (utf8Length != Utf8.encodedLength(sb)) {
70           StringBuilder repro = new StringBuilder();
71           <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int j = 0; j &lt; sb.length(); j++) {
72             repro.append(" ").append((int) sb.charAt(j));           }</b></font>
73           assertEquals(repro.toString(), utf8Length, Utf8.encodedLength(sb));
74         }
75       }
76     }
77   }
78   public void testEncodedLength_invalidStrings() {
79 <a name="4"></a>    testEncodedLengthFails(newString(MIN_HIGH_SURROGATE), 0);
80     testEncodedLengthFails("foobar" + newString(MIN_HIGH_SURROGATE), 6);
81     testEncodedLengthFails(newString(MIN_LOW_SURROGATE), 0);
82     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>testEncodedLengthFails("foobar" + newString(MIN_LOW_SURROGATE), 6);
83     testEncodedLengthFails(newString(MIN_HIGH_SURROGATE, MIN_HIGH_SURROGATE), 0);
84   }
85   private static void testEncodedLengthFails(String invalidString, int invalidCodePointIndex) {</b></font>
86     try {
87       Utf8.encodedLength(invalidString);
88       fail();
89     } catch (IllegalArgumentException expected) {
90       assertThat(expected)
91           .hasMessageThat()
92           .isEqualTo("Unpaired surrogate at index " + invalidCodePointIndex);
93     }
94   }
95   private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x007f - 0x0000 + 1;
96   private static final long EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT =
97       ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS;
98   private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x07FF - 0x0080 + 1;
99   private static final long EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT =
100       (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 2)
101           +
102           TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS;
103   private static final long THREE_BYTE_SURROGATES = 2 * 1024;
104   private static final long THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS =
105       0xFFFF - 0x0800 + 1 - THREE_BYTE_SURROGATES;
106   private static final long EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT =
107       (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 3)
108           +
109           2 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS
110           +
111           THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS;
112   private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS = 0x10FFFF - 0x10000L + 1;
113   private static final long EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT =
114       (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 4)
115           +
116           2 * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS
117           +
118           TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS
119           +
120           3
121               * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS
122               * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS
123               * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS
124           +
125           FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS;
126 <a name="1"></a>    @GwtIncompatible   public void testIsWellFormed_1Byte() {
127     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>testBytes(1, EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT);
128   }
129   @GwtIncompatible   public void testIsWellFormed_2Bytes() {
130     testBytes(2, EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT);
131   }
132   @GwtIncompatible 
133   public void testIsWellFormed_3Bytes() {
134     testBytes(3, EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT);
135   }</b></font>
136   public void testIsWellFormed_4BytesSamples() {
137     assertWellFormed(0xF0, 0xA4, 0xAD, 0xA2);
138     assertNotWellFormed(0xF0, 0xA4, 0xAD, 0x7F);
139     assertNotWellFormed(0xF0, 0xA4, 0xAD, 0xC0);
140     assertNotWellFormed(0xF0, 0x8F, 0xAD, 0xA2);
141     assertNotWellFormed(0xF4, 0x90, 0xAD, 0xA2);
142   }
143   public void testSomeSequences() {
144     assertWellFormed();
145     assertWellFormed(0x00, 0x61, 0x62, 0x63, 0x7F);     assertWellFormed(0xC2, 0xA2, 0xC2, 0xA2);     assertWellFormed(0xc8, 0x8a, 0x63, 0xc8, 0x8a, 0x63);     assertWellFormed(0xc9, 0x8b, 0x36, 0x32, 0xc9, 0x8b, 0x36, 0x32);
146     assertWellFormed(
147         0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30, 0x32, 0x34, 0x42, 0x36, 0x32,
148         0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63, 0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);
149     assertNotWellFormed(-1, 0, -1, 0);
150   }
151   public void testShardsHaveExpectedRoundTrippables() {
152     long actual = 0;
153 <a name="2"></a>    for (long expected : generateFourByteShardsExpectedRunnables()) {
154       actual += expected;
155     }
156     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT, actual);
157   }
158   private static String newString(char... chars) {
159     return new String(chars);
160   }
161   private static byte[] toByteArray(int... bytes) {</b></font>
162     byte[] realBytes = new byte[bytes.length];
163     for (int i = 0; i &lt; bytes.length; i++) {
164       realBytes[i] = (byte) bytes[i];
165     }
166     return realBytes;
167   }
168   private static void assertWellFormed(int... bytes) {
169     assertTrue(Utf8.isWellFormed(toByteArray(bytes)));
170   }
171   private static void assertNotWellFormed(int... bytes) {
172     assertFalse(Utf8.isWellFormed(toByteArray(bytes)));
173   }
174   private static long[] generateFourByteShardsExpectedRunnables() {
175     long[] expected = new long[128];
176     for (int i = 0; i &lt;= 63; i++) {
177       expected[i] = 5300224;
178     }
179     for (int i = 97; i &lt;= 111; i++) {
180       expected[i] = 2342912;
181     }
182     for (int i = 113; i &lt;= 117; i++) {
183       expected[i] = 1048576;
184     }
185     expected[112] = 786432;
186     expected[118] = 786432;
187     expected[119] = 1048576;
188     expected[120] = 458752;
189     expected[121] = 524288;
190     expected[122] = 65536;
191     return expected;
192   }
193   @GwtIncompatible   private static void testBytes(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int numBytes, long expectedCount) {
194     testBytes(numBytes, expectedCount, 0, -1);
195   }
196   @GwtIncompatible   private static void testBytes(int numBytes, long expectedCount, long start, long lim</b></font>) {
197     byte[] bytes = new byte[numBytes];
198     if (lim == -1) {
199       lim = 1L &lt;&lt; (numBytes * 8);
200     }
201     long countRoundTripped = 0;
202     for (long byteChar = start; byteChar &lt; lim; byteChar++) {
203       long tmpByteChar = byteChar;
204       for (int i = 0; i &lt; numBytes; i++) {
205         bytes[bytes.length - i - 1] = (byte) tmpByteChar;
206         tmpByteChar = tmpByteChar &gt;&gt; 8;
207       }
208       boolean isRoundTrippable = Utf8.isWellFormed(bytes);
209       assertEquals(isRoundTrippable, Utf8.isWellFormed(bytes, 0, numBytes));
210       String s = new String(bytes, Charsets.UTF_8);
211       byte[] bytesReencoded = s.getBytes(Charsets.UTF_8);
212       boolean bytesEqual = Arrays.equals(bytes, bytesReencoded);
213       if (bytesEqual != isRoundTrippable) {
214         fail();
215       }
216       if (isRoundTrippable) {
217         countRoundTripped++;
218       }
219     }
220     assertEquals(expectedCount, countRoundTripped);
221   }
222 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapMakerInternalMap_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkNotNull;
3 import static com.google.common.collect.CollectPreconditions.checkRemove;
4 import com.google.common.annotations.GwtIncompatible;
5 import com.google.common.annotations.VisibleForTesting;
6 import com.google.common.base.Equivalence;
7 import com.google.common.collect.MapMaker.Dummy;
8 import com.google.common.primitives.Ints;
9 import com.google.errorprone.annotations.CanIgnoreReturnValue;
10 import com.google.errorprone.annotations.concurrent.GuardedBy;
11 import com.google.j2objc.annotations.Weak;
12 import com.google.j2objc.annotations.WeakOuter;
13 import java.io.IOException;
14 import java.io.ObjectInputStream;
15 import java.io.ObjectOutputStream;
16 import java.io.Serializable;
17 import java.lang.ref.Reference;
18 <a name="0"></a>import java.lang.ref.ReferenceQueue;
19 import java.lang.ref.WeakReference;
20 import java.util.AbstractCollection;
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.AbstractMap;
22 import java.util.AbstractSet;
23 import java.util.ArrayList;
24 import java.util.Collection;
25 import java.util.Iterator;
26 import java.util.Map;
27 import java.util.NoSuchElementException;
28 import java.util.Set;
29 import java.util.concurrent.CancellationException;
30 import java.util.concurrent.ConcurrentMap;
31 import java.util.concurrent.atomic.AtomicInteger;
32 import java.util.concurrent.atomic.AtomicReferenceArray;
33 import java.util.concurrent.locks.ReentrantLock;
34 import org.checkerframework.checker.nullness.qual.Nullable;
35 @</b></font>GwtIncompatible
36 @SuppressWarnings({
37   "GuardedBy",   "nullness", })
38 class MapMakerInternalMap&lt;
39         K,
40         V,
41         E extends MapMakerInternalMap.InternalEntry&lt;K, V, E&gt;,
42         S extends MapMakerInternalMap.Segment&lt;K, V, E, S&gt;&gt;
43     extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable {
44   static final int MAXIMUM_CAPACITY = Ints.MAX_POWER_OF_TWO;
45   static final int MAX_SEGMENTS = 1 &lt;&lt; 16; 
46   static final int CONTAINS_VALUE_RETRIES = 3;
47   static final int DRAIN_THRESHOLD = 0x3F;
48   static final int DRAIN_MAX = 16;
49   static final long CLEANUP_EXECUTOR_DELAY_SECS = 60;
50   final transient int segmentMask;
51   final transient int segmentShift;
52   final transient Segment&lt;K, V, E, S&gt;[] segments;
53   final int concurrencyLevel;
54   final Equivalence&lt;Object&gt; keyEquivalence;
55   final transient InternalEntryHelper&lt;K, V, E, S&gt; entryHelper;
56   private MapMakerInternalMap(MapMaker builder, InternalEntryHelper&lt;K, V, E, S&gt; entryHelper) {
57     concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);
58     keyEquivalence = builder.getKeyEquivalence();
59     this.entryHelper = entryHelper;
60     int initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);
61     int segmentShift = 0;
62     int segmentCount = 1;
63     while (segmentCount &lt; concurrencyLevel) {
64       ++segmentShift;
65       segmentCount &lt;&lt;= 1;
66     }
67     this.segmentShift = 32 - segmentShift;
68     segmentMask = segmentCount - 1;
69     this.segments = newSegmentArray(segmentCount);
70     int segmentCapacity = initialCapacity / segmentCount;
71     if (segmentCapacity * segmentCount &lt; initialCapacity) {
72       ++segmentCapacity;
73     }
74     int segmentSize = 1;
75     while (segmentSize &lt; segmentCapacity) {
76       segmentSize &lt;&lt;= 1;
77     }
78     for (int i = 0; i &lt; this.segments.length; ++i) {
79       this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);
80     }
81   }
82   static &lt;K, V&gt; MapMakerInternalMap&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;, ?&gt; create(
83       MapMaker builder) {
84     if (builder.getKeyStrength() == Strength.STRONG
85         &amp;&amp; builder.getValueStrength() == Strength.STRONG) {
86       return new MapMakerInternalMap&lt;&gt;(builder, StrongKeyStrongValueEntry.Helper.&lt;K, V&gt;instance());
87     }
88     if (builder.getKeyStrength() == Strength.STRONG
89         &amp;&amp; builder.getValueStrength() == Strength.WEAK) {
90       return new MapMakerInternalMap&lt;&gt;(builder, StrongKeyWeakValueEntry.Helper.&lt;K, V&gt;instance());
91     }
92     if (builder.getKeyStrength() == Strength.WEAK
93         &amp;&amp; builder.getValueStrength() == Strength.STRONG) {
94       return new MapMakerInternalMap&lt;&gt;(builder, WeakKeyStrongValueEntry.Helper.&lt;K, V&gt;instance());
95     }
96     if (builder.getKeyStrength() == Strength.WEAK &amp;&amp; builder.getValueStrength() == Strength.WEAK) {
97       return new MapMakerInternalMap&lt;&gt;(builder, WeakKeyWeakValueEntry.Helper.&lt;K, V&gt;instance());
98     }
99     throw new AssertionError();
100   }
101   static &lt;K&gt;
102       MapMakerInternalMap&lt;K, Dummy, ? extends InternalEntry&lt;K, Dummy, ?&gt;, ?&gt; createWithDummyValues(
103           MapMaker builder) {
104     if (builder.getKeyStrength() == Strength.STRONG
105         &amp;&amp; builder.getValueStrength() == Strength.STRONG) {
106       return new MapMakerInternalMap&lt;&gt;(builder, StrongKeyDummyValueEntry.Helper.&lt;K&gt;instance());
107     }
108     if (builder.getKeyStrength() == Strength.WEAK
109         &amp;&amp; builder.getValueStrength() == Strength.STRONG) {
110       return new MapMakerInternalMap&lt;&gt;(builder, WeakKeyDummyValueEntry.Helper.&lt;K&gt;instance());
111     }
112     if (builder.getValueStrength() == Strength.WEAK) {
113       throw new IllegalArgumentException("Map cannot have both weak and dummy values");
114     }
115     throw new AssertionError();
116   }
117   enum Strength {
118     STRONG {
119       @Override
120       Equivalence&lt;Object&gt; defaultEquivalence() {
121         return Equivalence.equals();
122       }
123     },
124     WEAK {
125       @Override
126       Equivalence&lt;Object&gt; defaultEquivalence() {
127         return Equivalence.identity();
128       }
129     };
130     abstract Equivalence&lt;Object&gt; defaultEquivalence();
131   }
132   interface InternalEntryHelper&lt;
133       K, V, E extends InternalEntry&lt;K, V, E&gt;, S extends Segment&lt;K, V, E, S&gt;&gt; {
134     Strength keyStrength();
135     Strength valueStrength();
136     S newSegment(MapMakerInternalMap&lt;K, V, E, S&gt; map, int initialCapacity, int maxSegmentSize);
137     E newEntry(S segment, K key, int hash, @Nullable E next);
138     E copy(S segment, E entry, @Nullable E newNext);
139     void setValue(S segment, E entry, V value);
140   }
141   interface InternalEntry&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt; {
142     E getNext();
143     int getHash();
144     K getKey();
145     V getValue();
146   }
147   abstract static class AbstractStrongKeyEntry&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt;
148       implements InternalEntry&lt;K, V, E&gt; {
149     final K key;
150     final int hash;
151     final @Nullable E next;
152     AbstractStrongKeyEntry(K key, int hash, @Nullable E next) {
153       this.key = key;
154       this.hash = hash;
155       this.next = next;
156     }
157     @Override
158     public K getKey() {
159       return this.key;
160     }
161     @Override
162     public int getHash() {
163       return hash;
164     }
165     @Override
166     public E getNext() {
167       return next;
168     }
169   }
170   interface StrongValueEntry&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt;
171       extends InternalEntry&lt;K, V, E&gt; {}
172   interface WeakValueEntry&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt; extends InternalEntry&lt;K, V, E&gt; {
173     WeakValueReference&lt;K, V, E&gt; getValueReference();
174     void clearValue();
175   }
176   @SuppressWarnings("unchecked")   static &lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt;
177       WeakValueReference&lt;K, V, E&gt; unsetWeakValueReference() {
178     return (WeakValueReference&lt;K, V, E&gt;) UNSET_WEAK_VALUE_REFERENCE;
179   }
180   static final class StrongKeyStrongValueEntry&lt;K, V&gt;
181       extends AbstractStrongKeyEntry&lt;K, V, StrongKeyStrongValueEntry&lt;K, V&gt;&gt;
182       implements StrongValueEntry&lt;K, V, StrongKeyStrongValueEntry&lt;K, V&gt;&gt; {
183     private volatile @Nullable V value = null;
184     StrongKeyStrongValueEntry(K key, int hash, @Nullable StrongKeyStrongValueEntry&lt;K, V&gt; next) {
185       super(key, hash, next);
186     }
187     @Override
188     public @Nullable V getValue() {
189       return value;
190     }
191     void setValue(V value) {
192       this.value = value;
193     }
194     StrongKeyStrongValueEntry&lt;K, V&gt; copy(StrongKeyStrongValueEntry&lt;K, V&gt; newNext) {
195       StrongKeyStrongValueEntry&lt;K, V&gt; newEntry =
196           new StrongKeyStrongValueEntry&lt;&gt;(this.key, this.hash, newNext);
197       newEntry.value = this.value;
198       return newEntry;
199     }
200     static final class Helper&lt;K, V&gt;
201         implements InternalEntryHelper&lt;
202             K, V, StrongKeyStrongValueEntry&lt;K, V&gt;, StrongKeyStrongValueSegment&lt;K, V&gt;&gt; {
203       private static final Helper&lt;?, ?&gt; INSTANCE = new Helper&lt;&gt;();
204       @SuppressWarnings("unchecked")
205       static &lt;K, V&gt; Helper&lt;K, V&gt; instance() {
206         return (Helper&lt;K, V&gt;) INSTANCE;
207       }
208       @Override
209       public Strength keyStrength() {
210         return Strength.STRONG;
211       }
212       @Override
213       public Strength valueStrength() {
214         return Strength.STRONG;
215       }
216       @Override
217       public StrongKeyStrongValueSegment&lt;K, V&gt; newSegment(
218           MapMakerInternalMap&lt;
219                   K, V, StrongKeyStrongValueEntry&lt;K, V&gt;, StrongKeyStrongValueSegment&lt;K, V&gt;&gt;
220               map,
221           int initialCapacity,
222           int maxSegmentSize) {
223         return new StrongKeyStrongValueSegment&lt;&gt;(map, initialCapacity, maxSegmentSize);
224       }
225       @Override
226       public StrongKeyStrongValueEntry&lt;K, V&gt; copy(
227           StrongKeyStrongValueSegment&lt;K, V&gt; segment,
228           StrongKeyStrongValueEntry&lt;K, V&gt; entry,
229           @Nullable StrongKeyStrongValueEntry&lt;K, V&gt; newNext) {
230         return entry.copy(newNext);
231       }
232 <a name="3"></a>      @Override
233       public void setValue(
234           StrongKeyStrongValueSegment&lt;K, V&gt; segment,
235           <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>StrongKeyStrongValueEntry&lt;K, V&gt; entry,
236           V value) {
237         entry.setValue(value);
238       }
239       @Override
240       public StrongKeyStrongValueEntry&lt;K, V&gt; newEntry(
241           StrongKeyStrongValueSegment&lt;K, V&gt; segment,
242           K key,
243           int hash,
244           @Nullable StrongKeyStrongValueEntry&lt;K, V&gt; next</b></font>) {
245         return new StrongKeyStrongValueEntry&lt;&gt;(key, hash, next);
246       }
247     }
248   }
249   static final class StrongKeyWeakValueEntry&lt;K, V&gt;
250       extends AbstractStrongKeyEntry&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt;
251       implements WeakValueEntry&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; {
252     private volatile WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; valueReference =
253         unsetWeakValueReference();
254     StrongKeyWeakValueEntry(K key, int hash, @Nullable StrongKeyWeakValueEntry&lt;K, V&gt; next) {
255       super(key, hash, next);
256     }
257     @Override
258     public V getValue() {
259       return valueReference.get();
260     }
261     @Override
262     public void clearValue() {
263       valueReference.clear();
264     }
265     void setValue(V value, ReferenceQueue&lt;V&gt; queueForValues) {
266       WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; previous = this.valueReference;
267       this.valueReference = new WeakValueReferenceImpl&lt;&gt;(queueForValues, value, this);
268       previous.clear();
269     }
270     StrongKeyWeakValueEntry&lt;K, V&gt; copy(
271         ReferenceQueue&lt;V&gt; queueForValues, StrongKeyWeakValueEntry&lt;K, V&gt; newNext) {
272       StrongKeyWeakValueEntry&lt;K, V&gt; newEntry = new StrongKeyWeakValueEntry&lt;&gt;(key, hash, newNext);
273       newEntry.valueReference = valueReference.copyFor(queueForValues, newEntry);
274       return newEntry;
275     }
276     @Override
277     public WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; getValueReference() {
278       return valueReference;
279     }
280     static final class Helper&lt;K, V&gt;
281         implements InternalEntryHelper&lt;
282             K, V, StrongKeyWeakValueEntry&lt;K, V&gt;, StrongKeyWeakValueSegment&lt;K, V&gt;&gt; {
283       private static final Helper&lt;?, ?&gt; INSTANCE = new Helper&lt;&gt;();
284       @SuppressWarnings("unchecked")
285       static &lt;K, V&gt; Helper&lt;K, V&gt; instance() {
286         return (Helper&lt;K, V&gt;) INSTANCE;
287       }
288       @Override
289       public Strength keyStrength() {
290         return Strength.STRONG;
291       }
292       @Override
293       public Strength valueStrength() {
294         return Strength.WEAK;
295       }
296       @Override
297       public StrongKeyWeakValueSegment&lt;K, V&gt; newSegment(
298           MapMakerInternalMap&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;, StrongKeyWeakValueSegment&lt;K, V&gt;&gt;
299               map,
300           int initialCapacity,
301           int maxSegmentSize) {
302         return new StrongKeyWeakValueSegment&lt;&gt;(map, initialCapacity, maxSegmentSize);
303       }
304       @Override
305       public StrongKeyWeakValueEntry&lt;K, V&gt; copy(
306           StrongKeyWeakValueSegment&lt;K, V&gt; segment,
307           StrongKeyWeakValueEntry&lt;K, V&gt; entry,
308           @Nullable StrongKeyWeakValueEntry&lt;K, V&gt; newNext) {
309         if (Segment.isCollected(entry)) {
310           return null;
311         }
312         return entry.copy(segment.queueForValues, newNext);
313       }
314       @Override
315       public void setValue(
316           StrongKeyWeakValueSegment&lt;K, V&gt; segment, StrongKeyWeakValueEntry&lt;K, V&gt; entry, V value) {
317         entry.setValue(value, segment.queueForValues);
318       }
319       @Override
320       public StrongKeyWeakValueEntry&lt;K, V&gt; newEntry(
321           StrongKeyWeakValueSegment&lt;K, V&gt; segment,
322           K key,
323           int hash,
324           @Nullable StrongKeyWeakValueEntry&lt;K, V&gt; next) {
325         return new StrongKeyWeakValueEntry&lt;&gt;(key, hash, next);
326       }
327     }
328   }
329   static final class StrongKeyDummyValueEntry&lt;K&gt;
330       extends AbstractStrongKeyEntry&lt;K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;&gt;
331       implements StrongValueEntry&lt;K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;&gt; {
332     StrongKeyDummyValueEntry(K key, int hash, @Nullable StrongKeyDummyValueEntry&lt;K&gt; next) {
333       super(key, hash, next);
334     }
335     @Override
336     public Dummy getValue() {
337       return Dummy.VALUE;
338     }
339     void setValue(Dummy value) {}
340     StrongKeyDummyValueEntry&lt;K&gt; copy(StrongKeyDummyValueEntry&lt;K&gt; newNext) {
341       return new StrongKeyDummyValueEntry&lt;K&gt;(this.key, this.hash, newNext);
342     }
343     static final class Helper&lt;K&gt;
344         implements InternalEntryHelper&lt;
345             K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;, StrongKeyDummyValueSegment&lt;K&gt;&gt; {
346       private static final Helper&lt;?&gt; INSTANCE = new Helper&lt;&gt;();
347       @SuppressWarnings("unchecked")
348       static &lt;K&gt; Helper&lt;K&gt; instance() {
349         return (Helper&lt;K&gt;) INSTANCE;
350       }
351       @Override
352       public Strength keyStrength() {
353         return Strength.STRONG;
354       }
355       @Override
356       public Strength valueStrength() {
357         return Strength.STRONG;
358       }
359       @Override
360       public StrongKeyDummyValueSegment&lt;K&gt; newSegment(
361           MapMakerInternalMap&lt;K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;, StrongKeyDummyValueSegment&lt;K&gt;&gt;
362               map,
363           int initialCapacity,
364           int maxSegmentSize) {
365         return new StrongKeyDummyValueSegment&lt;K&gt;(map, initialCapacity, maxSegmentSize);
366       }
367       @Override
368       public StrongKeyDummyValueEntry&lt;K&gt; copy(
369           StrongKeyDummyValueSegment&lt;K&gt; segment,
370           StrongKeyDummyValueEntry&lt;K&gt; entry,
371           @Nullable StrongKeyDummyValueEntry&lt;K&gt; newNext) {
372         return entry.copy(newNext);
373       }
374       @Override
375       public void setValue(
376           StrongKeyDummyValueSegment&lt;K&gt; segment, StrongKeyDummyValueEntry&lt;K&gt; entry, Dummy value) {}
377       @Override
378       public StrongKeyDummyValueEntry&lt;K&gt; newEntry(
379           StrongKeyDummyValueSegment&lt;K&gt; segment,
380           K key,
381           int hash,
382           @Nullable StrongKeyDummyValueEntry&lt;K&gt; next) {
383         return new StrongKeyDummyValueEntry&lt;K&gt;(key, hash, next);
384       }
385     }
386   }
387   abstract static class AbstractWeakKeyEntry&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt;
388       extends WeakReference&lt;K&gt; implements InternalEntry&lt;K, V, E&gt; {
389     final int hash;
390     final @Nullable E next;
391     AbstractWeakKeyEntry(ReferenceQueue&lt;K&gt; queue, K key, int hash, @Nullable E next) {
392       super(key, queue);
393       this.hash = hash;
394       this.next = next;
395     }
396     @Override
397     public K getKey() {
398       return get();
399     }
400     @Override
401     public int getHash() {
402       return hash;
403     }
404     @Override
405     public E getNext() {
406       return next;
407     }
408   }
409   static final class WeakKeyDummyValueEntry&lt;K&gt;
410       extends AbstractWeakKeyEntry&lt;K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;&gt;
411       implements StrongValueEntry&lt;K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;&gt; {
412     WeakKeyDummyValueEntry(
413         ReferenceQueue&lt;K&gt; queue, K key, int hash, @Nullable WeakKeyDummyValueEntry&lt;K&gt; next) {
414       super(queue, key, hash, next);
415     }
416     @Override
417     public Dummy getValue() {
418       return Dummy.VALUE;
419     }
420     void setValue(Dummy value) {}
421     WeakKeyDummyValueEntry&lt;K&gt; copy(
422         ReferenceQueue&lt;K&gt; queueForKeys, WeakKeyDummyValueEntry&lt;K&gt; newNext) {
423       return new WeakKeyDummyValueEntry&lt;K&gt;(queueForKeys, getKey(), this.hash, newNext);
424     }
425     static final class Helper&lt;K&gt;
426         implements InternalEntryHelper&lt;
427             K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;, WeakKeyDummyValueSegment&lt;K&gt;&gt; {
428       private static final Helper&lt;?&gt; INSTANCE = new Helper&lt;&gt;();
429       @SuppressWarnings("unchecked")
430       static &lt;K&gt; Helper&lt;K&gt; instance() {
431         return (Helper&lt;K&gt;) INSTANCE;
432       }
433       @Override
434       public Strength keyStrength() {
435         return Strength.WEAK;
436       }
437       @Override
438       public Strength valueStrength() {
439         return Strength.STRONG;
440       }
441       @Override
442       public WeakKeyDummyValueSegment&lt;K&gt; newSegment(
443           MapMakerInternalMap&lt;K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;, WeakKeyDummyValueSegment&lt;K&gt;&gt; map,
444           int initialCapacity,
445           int maxSegmentSize) {
446         return new WeakKeyDummyValueSegment&lt;K&gt;(map, initialCapacity, maxSegmentSize);
447       }
448       @Override
449       public WeakKeyDummyValueEntry&lt;K&gt; copy(
450           WeakKeyDummyValueSegment&lt;K&gt; segment,
451           WeakKeyDummyValueEntry&lt;K&gt; entry,
452           @Nullable WeakKeyDummyValueEntry&lt;K&gt; newNext) {
453         if (entry.getKey() == null) {
454           return null;
455         }
456         return entry.copy(segment.queueForKeys, newNext);
457       }
458       @Override
459       public void setValue(
460           WeakKeyDummyValueSegment&lt;K&gt; segment, WeakKeyDummyValueEntry&lt;K&gt; entry, Dummy value) {}
461       @Override
462       public WeakKeyDummyValueEntry&lt;K&gt; newEntry(
463           WeakKeyDummyValueSegment&lt;K&gt; segment,
464           K key,
465           int hash,
466           @Nullable WeakKeyDummyValueEntry&lt;K&gt; next) {
467         return new WeakKeyDummyValueEntry&lt;K&gt;(segment.queueForKeys, key, hash, next);
468       }
469     }
470   }
471   static final class WeakKeyStrongValueEntry&lt;K, V&gt;
472       extends AbstractWeakKeyEntry&lt;K, V, WeakKeyStrongValueEntry&lt;K, V&gt;&gt;
473       implements StrongValueEntry&lt;K, V, WeakKeyStrongValueEntry&lt;K, V&gt;&gt; {
474     private volatile @Nullable V value = null;
475     WeakKeyStrongValueEntry(
476         ReferenceQueue&lt;K&gt; queue, K key, int hash, @Nullable WeakKeyStrongValueEntry&lt;K, V&gt; next) {
477       super(queue, key, hash, next);
478     }
479     @Override
480     public @Nullable V getValue() {
481       return value;
482     }
483     void setValue(V value) {
484       this.value = value;
485     }
486     WeakKeyStrongValueEntry&lt;K, V&gt; copy(
487         ReferenceQueue&lt;K&gt; queueForKeys, WeakKeyStrongValueEntry&lt;K, V&gt; newNext) {
488       WeakKeyStrongValueEntry&lt;K, V&gt; newEntry =
489           new WeakKeyStrongValueEntry&lt;&gt;(queueForKeys, getKey(), this.hash, newNext);
490       newEntry.setValue(value);
491       return newEntry;
492     }
493     static final class Helper&lt;K, V&gt;
494         implements InternalEntryHelper&lt;
495             K, V, WeakKeyStrongValueEntry&lt;K, V&gt;, WeakKeyStrongValueSegment&lt;K, V&gt;&gt; {
496       private static final Helper&lt;?, ?&gt; INSTANCE = new Helper&lt;&gt;();
497       @SuppressWarnings("unchecked")
498       static &lt;K, V&gt; Helper&lt;K, V&gt; instance() {
499         return (Helper&lt;K, V&gt;) INSTANCE;
500       }
501       @Override
502       public Strength keyStrength() {
503         return Strength.WEAK;
504       }
505       @Override
506       public Strength valueStrength() {
507         return Strength.STRONG;
508       }
509       @Override
510       public WeakKeyStrongValueSegment&lt;K, V&gt; newSegment(
511           MapMakerInternalMap&lt;K, V, WeakKeyStrongValueEntry&lt;K, V&gt;, WeakKeyStrongValueSegment&lt;K, V&gt;&gt;
512               map,
513           int initialCapacity,
514           int maxSegmentSize) {
515         return new WeakKeyStrongValueSegment&lt;&gt;(map, initialCapacity, maxSegmentSize);
516       }
517       @Override
518       public WeakKeyStrongValueEntry&lt;K, V&gt; copy(
519           WeakKeyStrongValueSegment&lt;K, V&gt; segment,
520           WeakKeyStrongValueEntry&lt;K, V&gt; entry,
521           @Nullable WeakKeyStrongValueEntry&lt;K, V&gt; newNext) {
522         if (entry.getKey() == null) {
523           return null;
524         }
525         return entry.copy(segment.queueForKeys, newNext);
526       }
527       @Override
528       public void setValue(
529           WeakKeyStrongValueSegment&lt;K, V&gt; segment, WeakKeyStrongValueEntry&lt;K, V&gt; entry, V value) {
530         entry.setValue(value);
531       }
532       @Override
533       public WeakKeyStrongValueEntry&lt;K, V&gt; newEntry(
534           WeakKeyStrongValueSegment&lt;K, V&gt; segment,
535           K key,
536           int hash,
537           @Nullable WeakKeyStrongValueEntry&lt;K, V&gt; next) {
538         return new WeakKeyStrongValueEntry&lt;&gt;(segment.queueForKeys, key, hash, next);
539       }
540     }
541   }
542   static final class WeakKeyWeakValueEntry&lt;K, V&gt;
543       extends AbstractWeakKeyEntry&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt;
544       implements WeakValueEntry&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; {
545     private volatile WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; valueReference =
546         unsetWeakValueReference();
547     WeakKeyWeakValueEntry(
548         ReferenceQueue&lt;K&gt; queue, K key, int hash, @Nullable WeakKeyWeakValueEntry&lt;K, V&gt; next) {
549       super(queue, key, hash, next);
550     }
551     @Override
552     public V getValue() {
553       return valueReference.get();
554     }
555     WeakKeyWeakValueEntry&lt;K, V&gt; copy(
556         ReferenceQueue&lt;K&gt; queueForKeys,
557         ReferenceQueue&lt;V&gt; queueForValues,
558         WeakKeyWeakValueEntry&lt;K, V&gt; newNext) {
559       WeakKeyWeakValueEntry&lt;K, V&gt; newEntry =
560           new WeakKeyWeakValueEntry&lt;&gt;(queueForKeys, getKey(), this.hash, newNext);
561       newEntry.valueReference = valueReference.copyFor(queueForValues, newEntry);
562       return newEntry;
563     }
564     @Override
565     public void clearValue() {
566       valueReference.clear();
567     }
568     void setValue(V value, ReferenceQueue&lt;V&gt; queueForValues) {
569       WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; previous = this.valueReference;
570       this.valueReference = new WeakValueReferenceImpl&lt;&gt;(queueForValues, value, this);
571       previous.clear();
572     }
573     @Override
574     public WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; getValueReference() {
575       return valueReference;
576     }
577     static final class Helper&lt;K, V&gt;
578         implements InternalEntryHelper&lt;
579             K, V, WeakKeyWeakValueEntry&lt;K, V&gt;, WeakKeyWeakValueSegment&lt;K, V&gt;&gt; {
580       private static final Helper&lt;?, ?&gt; INSTANCE = new Helper&lt;&gt;();
581       @SuppressWarnings("unchecked")
582       static &lt;K, V&gt; Helper&lt;K, V&gt; instance() {
583         return (Helper&lt;K, V&gt;) INSTANCE;
584       }
585       @Override
586       public Strength keyStrength() {
587         return Strength.WEAK;
588       }
589       @Override
590       public Strength valueStrength() {
591         return Strength.WEAK;
592       }
593       @Override
594       public WeakKeyWeakValueSegment&lt;K, V&gt; newSegment(
595           MapMakerInternalMap&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;, WeakKeyWeakValueSegment&lt;K, V&gt;&gt; map,
596           int initialCapacity,
597           int maxSegmentSize) {
598         return new WeakKeyWeakValueSegment&lt;&gt;(map, initialCapacity, maxSegmentSize);
599       }
600       @Override
601       public WeakKeyWeakValueEntry&lt;K, V&gt; copy(
602           WeakKeyWeakValueSegment&lt;K, V&gt; segment,
603           WeakKeyWeakValueEntry&lt;K, V&gt; entry,
604           @Nullable WeakKeyWeakValueEntry&lt;K, V&gt; newNext) {
605         if (entry.getKey() == null) {
606           return null;
607         }
608         if (Segment.isCollected(entry)) {
609           return null;
610         }
611         return entry.copy(segment.queueForKeys, segment.queueForValues, newNext);
612       }
613       @Override
614       public void setValue(
615           WeakKeyWeakValueSegment&lt;K, V&gt; segment, WeakKeyWeakValueEntry&lt;K, V&gt; entry, V value) {
616         entry.setValue(value, segment.queueForValues);
617       }
618       @Override
619       public WeakKeyWeakValueEntry&lt;K, V&gt; newEntry(
620           WeakKeyWeakValueSegment&lt;K, V&gt; segment,
621           K key,
622           int hash,
623           @Nullable WeakKeyWeakValueEntry&lt;K, V&gt; next) {
624         return new WeakKeyWeakValueEntry&lt;&gt;(segment.queueForKeys, key, hash, next);
625       }
626     }
627   }
628   interface WeakValueReference&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt; {
629     @Nullable
630     V get();
631     E getEntry();
632     void clear();
633     WeakValueReference&lt;K, V, E&gt; copyFor(ReferenceQueue&lt;V&gt; queue, E entry);
634   }
635   static final class DummyInternalEntry
636       implements InternalEntry&lt;Object, Object, DummyInternalEntry&gt; {
637     private DummyInternalEntry() {
638       throw new AssertionError();
639     }
640     @Override
641     public DummyInternalEntry getNext() {
642       throw new AssertionError();
643     }
644     @Override
645     public int getHash() {
646       throw new AssertionError();
647     }
648     @Override
649     public Object getKey() {
650       throw new AssertionError();
651     }
652     @Override
653     public Object getValue() {
654       throw new AssertionError();
655     }
656   }
657   static final WeakValueReference&lt;Object, Object, DummyInternalEntry&gt; UNSET_WEAK_VALUE_REFERENCE =
658       new WeakValueReference&lt;Object, Object, DummyInternalEntry&gt;() {
659         @Override
660         public DummyInternalEntry getEntry() {
661           return null;
662         }
663         @Override
664         public void clear() {}
665         @Override
666         public Object get() {
667           return null;
668         }
669         @Override
670         public WeakValueReference&lt;Object, Object, DummyInternalEntry&gt; copyFor(
671             ReferenceQueue&lt;Object&gt; queue, DummyInternalEntry entry) {
672           return this;
673         }
674       };
675   static final class WeakValueReferenceImpl&lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt;
676       extends WeakReference&lt;V&gt; implements WeakValueReference&lt;K, V, E&gt; {
677     @Weak final E entry;
678     WeakValueReferenceImpl(ReferenceQueue&lt;V&gt; queue, V referent, E entry) {
679       super(referent, queue);
680       this.entry = entry;
681     }
682     @Override
683     public E getEntry() {
684       return entry;
685     }
686     @Override
687     public WeakValueReference&lt;K, V, E&gt; copyFor(ReferenceQueue&lt;V&gt; queue, E entry) {
688       return new WeakValueReferenceImpl&lt;&gt;(queue, get(), entry);
689     }
690   }
691   static int rehash(int h) {
692     h += (h &lt;&lt; 15) ^ 0xffffcd7d;
693     h ^= (h &gt;&gt;&gt; 10);
694     h += (h &lt;&lt; 3);
695     h ^= (h &gt;&gt;&gt; 6);
696     h += (h &lt;&lt; 2) + (h &lt;&lt; 14);
697     return h ^ (h &gt;&gt;&gt; 16);
698   }
699   @VisibleForTesting
700   E copyEntry(E original, E newNext) {
701     int hash = original.getHash();
702     return segmentFor(hash).copyEntry(original, newNext);
703   }
704   int hash(Object key) {
705     int h = keyEquivalence.hash(key);
706     return rehash(h);
707   }
708   void reclaimValue(WeakValueReference&lt;K, V, E&gt; valueReference) {
709     E entry = valueReference.getEntry();
710     int hash = entry.getHash();
711     segmentFor(hash).reclaimValue(entry.getKey(), hash, valueReference);
712   }
713   void reclaimKey(E entry) {
714     int hash = entry.getHash();
715     segmentFor(hash).reclaimKey(entry, hash);
716   }
717   @VisibleForTesting
718   boolean isLiveForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
719     return segmentFor(entry.getHash()).getLiveValueForTesting(entry) != null;
720   }
721   Segment&lt;K, V, E, S&gt; segmentFor(int hash) {
722     return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
723   }
724   Segment&lt;K, V, E, S&gt; createSegment(int initialCapacity, int maxSegmentSize) {
725     return entryHelper.newSegment(this, initialCapacity, maxSegmentSize);
726   }
727   V getLiveValue(E entry) {
728     if (entry.getKey() == null) {
729       return null;
730     }
731     return entry.getValue();
732   }
733   @SuppressWarnings("unchecked")
734   final Segment&lt;K, V, E, S&gt;[] newSegmentArray(int ssize) {
735     return new Segment[ssize];
736   }
737   @SuppressWarnings("serial")   abstract static class Segment&lt;
738           K, V, E extends InternalEntry&lt;K, V, E&gt;, S extends Segment&lt;K, V, E, S&gt;&gt;
739       extends ReentrantLock {
740     @Weak final MapMakerInternalMap&lt;K, V, E, S&gt; map;
741     volatile int count;
742     int modCount;
743     int threshold;
744     volatile @Nullable AtomicReferenceArray&lt;E&gt; table;
745     final int maxSegmentSize;
746     final AtomicInteger readCount = new AtomicInteger();
747     Segment(MapMakerInternalMap&lt;K, V, E, S&gt; map, int initialCapacity, int maxSegmentSize) {
748       this.map = map;
749       this.maxSegmentSize = maxSegmentSize;
750       initTable(newEntryArray(initialCapacity));
751     }
752     abstract S self();
753     @GuardedBy("this")
754     void maybeDrainReferenceQueues() {}
755     void maybeClearReferenceQueues() {}
756     void setValue(E entry, V value) {
757       this.map.entryHelper.setValue(self(), entry, value);
758     }
759 <a name="2"></a>
760     E copyEntry(E original, E newNext) {
761       return this.map.entryHelper.copy(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>self(), original, newNext);
762     }
763     AtomicReferenceArray&lt;E&gt; newEntryArray(int size) {
764       return new AtomicReferenceArray&lt;E&gt;(size);
765     }
766     void initTable(AtomicReferenceArray&lt;E&gt; newTable) {</b></font>
767       this.threshold = newTable.length() * 3 / 4;       if (this.threshold == maxSegmentSize) {
768         this.threshold++;
769       }
770       this.table = newTable;
771     }
772     abstract E castForTesting(InternalEntry&lt;K, V, ?&gt; entry);
773     ReferenceQueue&lt;K&gt; getKeyReferenceQueueForTesting() {
774       throw new AssertionError();
775     }
776     ReferenceQueue&lt;V&gt; getValueReferenceQueueForTesting() {
777       throw new AssertionError();
778     }
779     WeakValueReference&lt;K, V, E&gt; getWeakValueReferenceForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
780       throw new AssertionError();
781     }
782     WeakValueReference&lt;K, V, E&gt; newWeakValueReferenceForTesting(
783         InternalEntry&lt;K, V, ?&gt; entry, V value) {
784       throw new AssertionError();
785     }
786     void setWeakValueReferenceForTesting(
787         InternalEntry&lt;K, V, ?&gt; entry,
788         WeakValueReference&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;&gt; valueReference) {
789       throw new AssertionError();
790     }
791     void setTableEntryForTesting(int i, InternalEntry&lt;K, V, ?&gt; entry) {
792       table.set(i, castForTesting(entry));
793     }
794 <a name="4"></a>
795     E copyForTesting(InternalEntry&lt;K, V, ?&gt; entry, @Nullable InternalEntry&lt;K, V, ?&gt; newNext) {
796       return <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>this.map.entryHelper.copy(self(), castForTesting(entry), castForTesting(newNext));
797     }
798     void setValueForTesting(InternalEntry&lt;K, V, ?&gt; entry, V value) {</b></font>
799       this.map.entryHelper.setValue(self(), castForTesting(entry), value);
800     }
801     E newEntryForTesting(K key, int hash, @Nullable InternalEntry&lt;K, V, ?&gt; next) {
802       return this.map.entryHelper.newEntry(self(), key, hash, castForTesting(next));
803     }
804     @CanIgnoreReturnValue
805     boolean removeTableEntryForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
806       return removeEntryForTesting(castForTesting(entry));
807     }
808     E removeFromChainForTesting(InternalEntry&lt;K, V, ?&gt; first, InternalEntry&lt;K, V, ?&gt; entry) {
809       return removeFromChain(castForTesting(first), castForTesting(entry));
810     }
811     @Nullable
812     V getLiveValueForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
813       return getLiveValue(castForTesting(entry));
814     }
815     void tryDrainReferenceQueues() {
816       if (tryLock()) {
817         try {
818           maybeDrainReferenceQueues();
819         } finally {
820           unlock();
821         }
822       }
823     }
824     @GuardedBy("this")
825     void drainKeyReferenceQueue(ReferenceQueue&lt;K&gt; keyReferenceQueue) {
826       Reference&lt;? extends K&gt; ref;
827       int i = 0;
828       while ((ref = keyReferenceQueue.poll()) != null) {
829         @SuppressWarnings("unchecked")
830         E entry = (E) ref;
831         map.reclaimKey(entry);
832         if (++i == DRAIN_MAX) {
833           break;
834         }
835       }
836     }
837     @GuardedBy("this")
838     void drainValueReferenceQueue(ReferenceQueue&lt;V&gt; valueReferenceQueue) {
839       Reference&lt;? extends V&gt; ref;
840       int i = 0;
841       while ((ref = valueReferenceQueue.poll()) != null) {
842         @SuppressWarnings("unchecked")
843         WeakValueReference&lt;K, V, E&gt; valueReference = (WeakValueReference&lt;K, V, E&gt;) ref;
844         map.reclaimValue(valueReference);
845         if (++i == DRAIN_MAX) {
846           break;
847         }
848       }
849     }
850     &lt;T&gt; void clearReferenceQueue(ReferenceQueue&lt;T&gt; referenceQueue) {
851       while (referenceQueue.poll() != null) {}
852     }
853     E getFirst(int hash) {
854       AtomicReferenceArray&lt;E&gt; table = this.table;
855       return table.get(hash &amp; (table.length() - 1));
856     }
857     E getEntry(Object key, int hash) {
858       if (count != 0) {         for (E e = getFirst(hash); e != null; e = e.getNext()) {
859           if (e.getHash() != hash) {
860             continue;
861           }
862           K entryKey = e.getKey();
863           if (entryKey == null) {
864             tryDrainReferenceQueues();
865             continue;
866           }
867           if (map.keyEquivalence.equivalent(key, entryKey)) {
868             return e;
869           }
870         }
871       }
872       return null;
873     }
874     E getLiveEntry(Object key, int hash) {
875       return getEntry(key, hash);
876     }
877     V get(Object key, int hash) {
878       try {
879         E e = getLiveEntry(key, hash);
880         if (e == null) {
881           return null;
882         }
883         V value = e.getValue();
884         if (value == null) {
885           tryDrainReferenceQueues();
886         }
887         return value;
888       } finally {
889         postReadCleanup();
890       }
891     }
892     boolean containsKey(Object key, int hash) {
893       try {
894         if (count != 0) {           E e = getLiveEntry(key, hash);
895           return e != null &amp;&amp; e.getValue() != null;
896         }
897         return false;
898       } finally {
899         postReadCleanup();
900       }
901     }
902     @VisibleForTesting
903     boolean containsValue(Object value) {
904       try {
905         if (count != 0) {           AtomicReferenceArray&lt;E&gt; table = this.table;
906           int length = table.length();
907           for (int i = 0; i &lt; length; ++i) {
908             for (E e = table.get(i); e != null; e = e.getNext()) {
909               V entryValue = getLiveValue(e);
910               if (entryValue == null) {
911                 continue;
912               }
913               if (map.valueEquivalence().equivalent(value, entryValue)) {
914                 return true;
915               }
916             }
917           }
918         }
919         return false;
920       } finally {
921         postReadCleanup();
922       }
923     }
924     V put(K key, int hash, V value, boolean onlyIfAbsent) {
925       lock();
926       try {
927         preWriteCleanup();
928         int newCount = this.count + 1;
929         if (newCount &gt; this.threshold) {           expand();
930           newCount = this.count + 1;
931         }
932         AtomicReferenceArray&lt;E&gt; table = this.table;
933         int index = hash &amp; (table.length() - 1);
934         E first = table.get(index);
935         for (E e = first; e != null; e = e.getNext()) {
936           K entryKey = e.getKey();
937           if (e.getHash() == hash
938               &amp;&amp; entryKey != null
939               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
940             V entryValue = e.getValue();
941             if (entryValue == null) {
942               ++modCount;
943               setValue(e, value);
944               newCount = this.count;               this.count = newCount;               return null;
945             } else if (onlyIfAbsent) {
946               return entryValue;
947             } else {
948               ++modCount;
949               setValue(e, value);
950               return entryValue;
951             }
952           }
953         }
954         ++modCount;
955         E newEntry = map.entryHelper.newEntry(self(), key, hash, first);
956         setValue(newEntry, value);
957         table.set(index, newEntry);
958         this.count = newCount;         return null;
959       } finally {
960         unlock();
961       }
962     }
963     @GuardedBy("this")
964     void expand() {
965       AtomicReferenceArray&lt;E&gt; oldTable = table;
966       int oldCapacity = oldTable.length();
967       if (oldCapacity &gt;= MAXIMUM_CAPACITY) {
968         return;
969       }
970       int newCount = count;
971       AtomicReferenceArray&lt;E&gt; newTable = newEntryArray(oldCapacity &lt;&lt; 1);
972       threshold = newTable.length() * 3 / 4;
973       int newMask = newTable.length() - 1;
974       for (int oldIndex = 0; oldIndex &lt; oldCapacity; ++oldIndex) {
975         E head = oldTable.get(oldIndex);
976         if (head != null) {
977           E next = head.getNext();
978           int headIndex = head.getHash() &amp; newMask;
979           if (next == null) {
980             newTable.set(headIndex, head);
981           } else {
982             E tail = head;
983             int tailIndex = headIndex;
984             for (E e = next; e != null; e = e.getNext()) {
985               int newIndex = e.getHash() &amp; newMask;
986               if (newIndex != tailIndex) {
987                 tailIndex = newIndex;
988                 tail = e;
989               }
990             }
991             newTable.set(tailIndex, tail);
992             for (E e = head; e != tail; e = e.getNext()) {
993               int newIndex = e.getHash() &amp; newMask;
994               E newNext = newTable.get(newIndex);
995               E newFirst = copyEntry(e, newNext);
996               if (newFirst != null) {
997                 newTable.set(newIndex, newFirst);
998               } else {
999                 newCount--;
1000               }
1001             }
1002           }
1003         }
1004       }
1005       table = newTable;
1006       this.count = newCount;
1007     }
1008     boolean replace(K key, int hash, V oldValue, V newValue) {
1009       lock();
1010       try {
1011         preWriteCleanup();
1012         AtomicReferenceArray&lt;E&gt; table = this.table;
1013         int index = hash &amp; (table.length() - 1);
1014         E first = table.get(index);
1015         for (E e = first; e != null; e = e.getNext()) {
1016           K entryKey = e.getKey();
1017           if (e.getHash() == hash
1018               &amp;&amp; entryKey != null
1019               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1020             V entryValue = e.getValue();
1021             if (entryValue == null) {
1022               if (isCollected(e)) {
1023                 int newCount = this.count - 1;
1024                 ++modCount;
1025                 E newFirst = removeFromChain(first, e);
1026                 newCount = this.count - 1;
1027                 table.set(index, newFirst);
1028                 this.count = newCount;               }
1029               return false;
1030             }
1031             if (map.valueEquivalence().equivalent(oldValue, entryValue)) {
1032               ++modCount;
1033               setValue(e, newValue);
1034               return true;
1035             } else {
1036               return false;
1037             }
1038           }
1039         }
1040         return false;
1041       } finally {
1042         unlock();
1043       }
1044     }
1045     V replace(K key, int hash, V newValue) {
1046       lock();
1047       try {
1048         preWriteCleanup();
1049         AtomicReferenceArray&lt;E&gt; table = this.table;
1050         int index = hash &amp; (table.length() - 1);
1051         E first = table.get(index);
1052         for (E e = first; e != null; e = e.getNext()) {
1053           K entryKey = e.getKey();
1054           if (e.getHash() == hash
1055               &amp;&amp; entryKey != null
1056               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1057             V entryValue = e.getValue();
1058             if (entryValue == null) {
1059               if (isCollected(e)) {
1060                 int newCount = this.count - 1;
1061                 ++modCount;
1062                 E newFirst = removeFromChain(first, e);
1063                 newCount = this.count - 1;
1064                 table.set(index, newFirst);
1065                 this.count = newCount;               }
1066               return null;
1067             }
1068             ++modCount;
1069             setValue(e, newValue);
1070             return entryValue;
1071           }
1072         }
1073         return null;
1074       } finally {
1075         unlock();
1076       }
1077     }
1078     @CanIgnoreReturnValue
1079     V remove(Object key, int hash) {
1080       lock();
1081       try {
1082         preWriteCleanup();
1083         int newCount = this.count - 1;
1084         AtomicReferenceArray&lt;E&gt; table = this.table;
1085         int index = hash &amp; (table.length() - 1);
1086         E first = table.get(index);
1087         for (E e = first; e != null; e = e.getNext()) {
1088           K entryKey = e.getKey();
1089           if (e.getHash() == hash
1090               &amp;&amp; entryKey != null
1091               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1092             V entryValue = e.getValue();
1093             if (entryValue != null) {
1094             } else if (isCollected(e)) {
1095             } else {
1096               return null;
1097             }
1098             ++modCount;
1099             E newFirst = removeFromChain(first, e);
1100             newCount = this.count - 1;
1101             table.set(index, newFirst);
1102             this.count = newCount;             return entryValue;
1103           }
1104         }
1105         return null;
1106       } finally {
1107         unlock();
1108       }
1109     }
1110     boolean remove(Object key, int hash, Object value) {
1111       lock();
1112       try {
1113         preWriteCleanup();
1114         int newCount = this.count - 1;
1115         AtomicReferenceArray&lt;E&gt; table = this.table;
1116         int index = hash &amp; (table.length() - 1);
1117         E first = table.get(index);
1118         for (E e = first; e != null; e = e.getNext()) {
1119           K entryKey = e.getKey();
1120           if (e.getHash() == hash
1121               &amp;&amp; entryKey != null
1122               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1123             V entryValue = e.getValue();
1124             boolean explicitRemoval = false;
1125             if (map.valueEquivalence().equivalent(value, entryValue)) {
1126               explicitRemoval = true;
1127             } else if (isCollected(e)) {
1128             } else {
1129               return false;
1130             }
1131             ++modCount;
1132             E newFirst = removeFromChain(first, e);
1133             newCount = this.count - 1;
1134             table.set(index, newFirst);
1135             this.count = newCount;             return explicitRemoval;
1136           }
1137         }
1138         return false;
1139       } finally {
1140         unlock();
1141       }
1142     }
1143     void clear() {
1144       if (count != 0) {
1145         lock();
1146         try {
1147           AtomicReferenceArray&lt;E&gt; table = this.table;
1148           for (int i = 0; i &lt; table.length(); ++i) {
1149             table.set(i, null);
1150           }
1151           maybeClearReferenceQueues();
1152           readCount.set(0);
1153           ++modCount;
1154           count = 0;         } finally {
1155           unlock();
1156         }
1157       }
1158     }
1159     @GuardedBy("this")
1160     E removeFromChain(E first, E entry) {
1161       int newCount = count;
1162       E newFirst = entry.getNext();
1163       for (E e = first; e != entry; e = e.getNext()) {
1164         E next = copyEntry(e, newFirst);
1165         if (next != null) {
1166           newFirst = next;
1167         } else {
1168           newCount--;
1169         }
1170       }
1171       this.count = newCount;
1172       return newFirst;
1173     }
1174     @CanIgnoreReturnValue
1175     boolean reclaimKey(E entry, int hash) {
1176       lock();
1177       try {
1178         int newCount = count - 1;
1179         AtomicReferenceArray&lt;E&gt; table = this.table;
1180         int index = hash &amp; (table.length() - 1);
1181         E first = table.get(index);
1182         for (E e = first; e != null; e = e.getNext()) {
1183           if (e == entry) {
1184             ++modCount;
1185             E newFirst = removeFromChain(first, e);
1186             newCount = this.count - 1;
1187             table.set(index, newFirst);
1188             this.count = newCount;             return true;
1189           }
1190         }
1191         return false;
1192       } finally {
1193         unlock();
1194       }
1195     }
1196     @CanIgnoreReturnValue
1197     boolean reclaimValue(K key, int hash, WeakValueReference&lt;K, V, E&gt; valueReference) {
1198       lock();
1199       try {
1200         int newCount = this.count - 1;
1201         AtomicReferenceArray&lt;E&gt; table = this.table;
1202         int index = hash &amp; (table.length() - 1);
1203         E first = table.get(index);
1204         for (E e = first; e != null; e = e.getNext()) {
1205           K entryKey = e.getKey();
1206           if (e.getHash() == hash
1207               &amp;&amp; entryKey != null
1208               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1209             WeakValueReference&lt;K, V, E&gt; v = ((WeakValueEntry&lt;K, V, E&gt;) e).getValueReference();
1210             if (v == valueReference) {
1211               ++modCount;
1212               E newFirst = removeFromChain(first, e);
1213               newCount = this.count - 1;
1214               table.set(index, newFirst);
1215               this.count = newCount;               return true;
1216             }
1217             return false;
1218           }
1219         }
1220         return false;
1221       } finally {
1222         unlock();
1223       }
1224     }
1225     @CanIgnoreReturnValue
1226     boolean clearValueForTesting(
1227         K key,
1228         int hash,
1229         WeakValueReference&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;&gt; valueReference) {
1230       lock();
1231       try {
1232         AtomicReferenceArray&lt;E&gt; table = this.table;
1233         int index = hash &amp; (table.length() - 1);
1234         E first = table.get(index);
1235         for (E e = first; e != null; e = e.getNext()) {
1236           K entryKey = e.getKey();
1237           if (e.getHash() == hash
1238               &amp;&amp; entryKey != null
1239               &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) {
1240             WeakValueReference&lt;K, V, E&gt; v = ((WeakValueEntry&lt;K, V, E&gt;) e).getValueReference();
1241             if (v == valueReference) {
1242               E newFirst = removeFromChain(first, e);
1243               table.set(index, newFirst);
1244               return true;
1245             }
1246             return false;
1247           }
1248         }
1249         return false;
1250       } finally {
1251         unlock();
1252       }
1253     }
1254     @GuardedBy("this")
1255     boolean removeEntryForTesting(E entry) {
1256       int hash = entry.getHash();
1257       int newCount = this.count - 1;
1258       AtomicReferenceArray&lt;E&gt; table = this.table;
1259       int index = hash &amp; (table.length() - 1);
1260       E first = table.get(index);
1261       for (E e = first; e != null; e = e.getNext()) {
1262         if (e == entry) {
1263           ++modCount;
1264           E newFirst = removeFromChain(first, e);
1265           newCount = this.count - 1;
1266           table.set(index, newFirst);
1267           this.count = newCount;           return true;
1268         }
1269       }
1270       return false;
1271     }
1272     static &lt;K, V, E extends InternalEntry&lt;K, V, E&gt;&gt; boolean isCollected(E entry) {
1273       return entry.getValue() == null;
1274     }
1275     @Nullable
1276     V getLiveValue(E entry) {
1277       if (entry.getKey() == null) {
1278         tryDrainReferenceQueues();
1279         return null;
1280       }
1281       V value = entry.getValue();
1282       if (value == null) {
1283         tryDrainReferenceQueues();
1284         return null;
1285       }
1286       return value;
1287     }
1288     void postReadCleanup() {
1289       if ((readCount.incrementAndGet() &amp; DRAIN_THRESHOLD) == 0) {
1290         runCleanup();
1291       }
1292     }
1293     @GuardedBy("this")
1294     void preWriteCleanup() {
1295       runLockedCleanup();
1296     }
1297     void runCleanup() {
1298       runLockedCleanup();
1299     }
1300     void runLockedCleanup() {
1301       if (tryLock()) {
1302         try {
1303           maybeDrainReferenceQueues();
1304           readCount.set(0);
1305         } finally {
1306           unlock();
1307         }
1308       }
1309     }
1310   }
1311   static final class StrongKeyStrongValueSegment&lt;K, V&gt;
1312       extends Segment&lt;K, V, StrongKeyStrongValueEntry&lt;K, V&gt;, StrongKeyStrongValueSegment&lt;K, V&gt;&gt; {
1313     StrongKeyStrongValueSegment(
1314         MapMakerInternalMap&lt;
1315                 K, V, StrongKeyStrongValueEntry&lt;K, V&gt;, StrongKeyStrongValueSegment&lt;K, V&gt;&gt;
1316             map,
1317         int initialCapacity,
1318         int maxSegmentSize) {
1319       super(map, initialCapacity, maxSegmentSize);
1320     }
1321     @Override
1322     StrongKeyStrongValueSegment&lt;K, V&gt; self() {
1323       return this;
1324     }
1325     @SuppressWarnings("unchecked")
1326     @Override
1327     public StrongKeyStrongValueEntry&lt;K, V&gt; castForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
1328       return (StrongKeyStrongValueEntry&lt;K, V&gt;) entry;
1329     }
1330   }
1331   static final class StrongKeyWeakValueSegment&lt;K, V&gt;
1332       extends Segment&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;, StrongKeyWeakValueSegment&lt;K, V&gt;&gt; {
1333     private final ReferenceQueue&lt;V&gt; queueForValues = new ReferenceQueue&lt;V&gt;();
1334     StrongKeyWeakValueSegment(
1335         MapMakerInternalMap&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;, StrongKeyWeakValueSegment&lt;K, V&gt;&gt;
1336             map,
1337         int initialCapacity,
1338         int maxSegmentSize) {
1339       super(map, initialCapacity, maxSegmentSize);
1340     }
1341     @Override
1342     StrongKeyWeakValueSegment&lt;K, V&gt; self() {
1343       return this;
1344     }
1345     @Override
1346     ReferenceQueue&lt;V&gt; getValueReferenceQueueForTesting() {
1347       return queueForValues;
1348     }
1349     @SuppressWarnings("unchecked")
1350     @Override
1351     public StrongKeyWeakValueEntry&lt;K, V&gt; castForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
1352       return (StrongKeyWeakValueEntry&lt;K, V&gt;) entry;
1353     }
1354     @Override
1355     public WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; getWeakValueReferenceForTesting(
1356         InternalEntry&lt;K, V, ?&gt; e) {
1357       return castForTesting(e).getValueReference();
1358     }
1359     @Override
1360     public WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; newWeakValueReferenceForTesting(
1361         InternalEntry&lt;K, V, ?&gt; e, V value) {
1362       return new WeakValueReferenceImpl&lt;&gt;(queueForValues, value, castForTesting(e));
1363     }
1364     @Override
1365     public void setWeakValueReferenceForTesting(
1366         InternalEntry&lt;K, V, ?&gt; e,
1367         WeakValueReference&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;&gt; valueReference) {
1368       StrongKeyWeakValueEntry&lt;K, V&gt; entry = castForTesting(e);
1369       @SuppressWarnings("unchecked")
1370       WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; newValueReference =
1371 <a name="1"></a>          (WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt;) valueReference;
1372       WeakValueReference&lt;K, V, StrongKeyWeakValueEntry&lt;K, V&gt;&gt; previous = entry.valueReference;
1373       entry.valueReference = newValueReference;
1374       <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>previous.clear();
1375     }
1376     @Override
1377     void maybeDrainReferenceQueues() {
1378       drainValueReferenceQueue(queueForValues);
1379     }
1380     @Override
1381     void maybeClearReferenceQueues() {
1382       clearReferenceQueue(queueForValues);
1383     }</b></font>
1384   }
1385   static final class StrongKeyDummyValueSegment&lt;K&gt;
1386       extends Segment&lt;K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;, StrongKeyDummyValueSegment&lt;K&gt;&gt; {
1387     StrongKeyDummyValueSegment(
1388         MapMakerInternalMap&lt;K, Dummy, StrongKeyDummyValueEntry&lt;K&gt;, StrongKeyDummyValueSegment&lt;K&gt;&gt;
1389             map,
1390         int initialCapacity,
1391         int maxSegmentSize) {
1392       super(map, initialCapacity, maxSegmentSize);
1393     }
1394     @Override
1395     StrongKeyDummyValueSegment&lt;K&gt; self() {
1396       return this;
1397     }
1398     @SuppressWarnings("unchecked")
1399     @Override
1400     public StrongKeyDummyValueEntry&lt;K&gt; castForTesting(InternalEntry&lt;K, Dummy, ?&gt; entry) {
1401       return (StrongKeyDummyValueEntry&lt;K&gt;) entry;
1402     }
1403   }
1404   static final class WeakKeyStrongValueSegment&lt;K, V&gt;
1405       extends Segment&lt;K, V, WeakKeyStrongValueEntry&lt;K, V&gt;, WeakKeyStrongValueSegment&lt;K, V&gt;&gt; {
1406     private final ReferenceQueue&lt;K&gt; queueForKeys = new ReferenceQueue&lt;K&gt;();
1407     WeakKeyStrongValueSegment(
1408         MapMakerInternalMap&lt;K, V, WeakKeyStrongValueEntry&lt;K, V&gt;, WeakKeyStrongValueSegment&lt;K, V&gt;&gt;
1409             map,
1410         int initialCapacity,
1411         int maxSegmentSize) {
1412       super(map, initialCapacity, maxSegmentSize);
1413     }
1414     @Override
1415     WeakKeyStrongValueSegment&lt;K, V&gt; self() {
1416       return this;
1417     }
1418     @Override
1419     ReferenceQueue&lt;K&gt; getKeyReferenceQueueForTesting() {
1420       return queueForKeys;
1421     }
1422     @SuppressWarnings("unchecked")
1423     @Override
1424     public WeakKeyStrongValueEntry&lt;K, V&gt; castForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
1425       return (WeakKeyStrongValueEntry&lt;K, V&gt;) entry;
1426     }
1427     @Override
1428     void maybeDrainReferenceQueues() {
1429       drainKeyReferenceQueue(queueForKeys);
1430     }
1431     @Override
1432     void maybeClearReferenceQueues() {
1433       clearReferenceQueue(queueForKeys);
1434     }
1435   }
1436   static final class WeakKeyWeakValueSegment&lt;K, V&gt;
1437       extends Segment&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;, WeakKeyWeakValueSegment&lt;K, V&gt;&gt; {
1438     private final ReferenceQueue&lt;K&gt; queueForKeys = new ReferenceQueue&lt;K&gt;();
1439     private final ReferenceQueue&lt;V&gt; queueForValues = new ReferenceQueue&lt;V&gt;();
1440     WeakKeyWeakValueSegment(
1441         MapMakerInternalMap&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;, WeakKeyWeakValueSegment&lt;K, V&gt;&gt; map,
1442         int initialCapacity,
1443         int maxSegmentSize) {
1444       super(map, initialCapacity, maxSegmentSize);
1445     }
1446     @Override
1447     WeakKeyWeakValueSegment&lt;K, V&gt; self() {
1448       return this;
1449     }
1450     @Override
1451     ReferenceQueue&lt;K&gt; getKeyReferenceQueueForTesting() {
1452       return queueForKeys;
1453     }
1454     @Override
1455     ReferenceQueue&lt;V&gt; getValueReferenceQueueForTesting() {
1456       return queueForValues;
1457     }
1458     @SuppressWarnings("unchecked")
1459     @Override
1460     public WeakKeyWeakValueEntry&lt;K, V&gt; castForTesting(InternalEntry&lt;K, V, ?&gt; entry) {
1461       return (WeakKeyWeakValueEntry&lt;K, V&gt;) entry;
1462     }
1463     @Override
1464     public WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; getWeakValueReferenceForTesting(
1465         InternalEntry&lt;K, V, ?&gt; e) {
1466       return castForTesting(e).getValueReference();
1467     }
1468     @Override
1469     public WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; newWeakValueReferenceForTesting(
1470         InternalEntry&lt;K, V, ?&gt; e, V value) {
1471       return new WeakValueReferenceImpl&lt;&gt;(queueForValues, value, castForTesting(e));
1472     }
1473     @Override
1474     public void setWeakValueReferenceForTesting(
1475         InternalEntry&lt;K, V, ?&gt; e,
1476         WeakValueReference&lt;K, V, ? extends InternalEntry&lt;K, V, ?&gt;&gt; valueReference) {
1477       WeakKeyWeakValueEntry&lt;K, V&gt; entry = castForTesting(e);
1478       @SuppressWarnings("unchecked")
1479       WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; newValueReference =
1480           (WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt;) valueReference;
1481       WeakValueReference&lt;K, V, WeakKeyWeakValueEntry&lt;K, V&gt;&gt; previous = entry.valueReference;
1482       entry.valueReference = newValueReference;
1483       previous.clear();
1484     }
1485     @Override
1486     void maybeDrainReferenceQueues() {
1487       drainKeyReferenceQueue(queueForKeys);
1488       drainValueReferenceQueue(queueForValues);
1489     }
1490     @Override
1491     void maybeClearReferenceQueues() {
1492       clearReferenceQueue(queueForKeys);
1493     }
1494   }
1495   static final class WeakKeyDummyValueSegment&lt;K&gt;
1496       extends Segment&lt;K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;, WeakKeyDummyValueSegment&lt;K&gt;&gt; {
1497     private final ReferenceQueue&lt;K&gt; queueForKeys = new ReferenceQueue&lt;K&gt;();
1498     WeakKeyDummyValueSegment(
1499         MapMakerInternalMap&lt;K, Dummy, WeakKeyDummyValueEntry&lt;K&gt;, WeakKeyDummyValueSegment&lt;K&gt;&gt; map,
1500         int initialCapacity,
1501         int maxSegmentSize) {
1502       super(map, initialCapacity, maxSegmentSize);
1503     }
1504     @Override
1505     WeakKeyDummyValueSegment&lt;K&gt; self() {
1506       return this;
1507     }
1508     @Override
1509     ReferenceQueue&lt;K&gt; getKeyReferenceQueueForTesting() {
1510       return queueForKeys;
1511     }
1512     @SuppressWarnings("unchecked")
1513     @Override
1514     public WeakKeyDummyValueEntry&lt;K&gt; castForTesting(InternalEntry&lt;K, Dummy, ?&gt; entry) {
1515       return (WeakKeyDummyValueEntry&lt;K&gt;) entry;
1516     }
1517     @Override
1518     void maybeDrainReferenceQueues() {
1519       drainKeyReferenceQueue(queueForKeys);
1520     }
1521     @Override
1522     void maybeClearReferenceQueues() {
1523       clearReferenceQueue(queueForKeys);
1524     }
1525   }
1526   static final class CleanupMapTask implements Runnable {
1527     final WeakReference&lt;MapMakerInternalMap&lt;?, ?, ?, ?&gt;&gt; mapReference;
1528     public CleanupMapTask(MapMakerInternalMap&lt;?, ?, ?, ?&gt; map) {
1529       this.mapReference = new WeakReference&lt;MapMakerInternalMap&lt;?, ?, ?, ?&gt;&gt;(map);
1530     }
1531     @Override
1532     public void run() {
1533       MapMakerInternalMap&lt;?, ?, ?, ?&gt; map = mapReference.get();
1534       if (map == null) {
1535         throw new CancellationException();
1536       }
1537       for (Segment&lt;?, ?, ?, ?&gt; segment : map.segments) {
1538         segment.runCleanup();
1539       }
1540     }
1541   }
1542   @VisibleForTesting
1543   Strength keyStrength() {
1544     return entryHelper.keyStrength();
1545   }
1546   @VisibleForTesting
1547   Strength valueStrength() {
1548     return entryHelper.valueStrength();
1549   }
1550   @VisibleForTesting
1551   Equivalence&lt;Object&gt; valueEquivalence() {
1552     return entryHelper.valueStrength().defaultEquivalence();
1553   }
1554   @Override
1555   public boolean isEmpty() {
1556     long sum = 0L;
1557     Segment&lt;K, V, E, S&gt;[] segments = this.segments;
1558     for (int i = 0; i &lt; segments.length; ++i) {
1559       if (segments[i].count != 0) {
1560         return false;
1561       }
1562       sum += segments[i].modCount;
1563     }
1564     if (sum != 0L) {       for (int i = 0; i &lt; segments.length; ++i) {
1565         if (segments[i].count != 0) {
1566           return false;
1567         }
1568         sum -= segments[i].modCount;
1569       }
1570       return sum == 0L;
1571     }
1572     return true;
1573   }
1574   @Override
1575   public int size() {
1576     Segment&lt;K, V, E, S&gt;[] segments = this.segments;
1577     long sum = 0;
1578     for (int i = 0; i &lt; segments.length; ++i) {
1579       sum += segments[i].count;
1580     }
1581     return Ints.saturatedCast(sum);
1582   }
1583   @Override
1584   public V get(@Nullable Object key) {
1585     if (key == null) {
1586       return null;
1587     }
1588     int hash = hash(key);
1589     return segmentFor(hash).get(key, hash);
1590   }
1591   E getEntry(@Nullable Object key) {
1592     if (key == null) {
1593       return null;
1594     }
1595     int hash = hash(key);
1596     return segmentFor(hash).getEntry(key, hash);
1597   }
1598   @Override
1599   public boolean containsKey(@Nullable Object key) {
1600     if (key == null) {
1601       return false;
1602     }
1603     int hash = hash(key);
1604     return segmentFor(hash).containsKey(key, hash);
1605   }
1606   @Override
1607   public boolean containsValue(@Nullable Object value) {
1608     if (value == null) {
1609       return false;
1610     }
1611     final Segment&lt;K, V, E, S&gt;[] segments = this.segments;
1612     long last = -1L;
1613     for (int i = 0; i &lt; CONTAINS_VALUE_RETRIES; i++) {
1614       long sum = 0L;
1615       for (Segment&lt;K, V, E, S&gt; segment : segments) {
1616         int unused = segment.count; 
1617         AtomicReferenceArray&lt;E&gt; table = segment.table;
1618         for (int j = 0; j &lt; table.length(); j++) {
1619           for (E e = table.get(j); e != null; e = e.getNext()) {
1620             V v = segment.getLiveValue(e);
1621             if (v != null &amp;&amp; valueEquivalence().equivalent(value, v)) {
1622               return true;
1623             }
1624           }
1625         }
1626         sum += segment.modCount;
1627       }
1628       if (sum == last) {
1629         break;
1630       }
1631       last = sum;
1632     }
1633     return false;
1634   }
1635   @CanIgnoreReturnValue
1636   @Override
1637   public V put(K key, V value) {
1638     checkNotNull(key);
1639     checkNotNull(value);
1640     int hash = hash(key);
1641     return segmentFor(hash).put(key, hash, value, false);
1642   }
1643   @CanIgnoreReturnValue
1644   @Override
1645   public V putIfAbsent(K key, V value) {
1646     checkNotNull(key);
1647     checkNotNull(value);
1648     int hash = hash(key);
1649     return segmentFor(hash).put(key, hash, value, true);
1650   }
1651 <a name="5"></a>
1652   @Override
1653   public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
1654     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
1655       put(e.getKey(), e.getValue());
1656     }</b></font>
1657   }
1658   @CanIgnoreReturnValue
1659   @Override
1660   public V remove(@Nullable Object key) {
1661     if (key == null) {
1662       return null;
1663     }
1664     int hash = hash(key);
1665     return segmentFor(hash).remove(key, hash);
1666   }
1667   @CanIgnoreReturnValue
1668   @Override
1669   public boolean remove(@Nullable Object key, @Nullable Object value) {
1670     if (key == null || value == null) {
1671       return false;
1672     }
1673     int hash = hash(key);
1674     return segmentFor(hash).remove(key, hash, value);
1675   }
1676   @CanIgnoreReturnValue
1677   @Override
1678   public boolean replace(K key, @Nullable V oldValue, V newValue) {
1679     checkNotNull(key);
1680     checkNotNull(newValue);
1681     if (oldValue == null) {
1682       return false;
1683     }
1684     int hash = hash(key);
1685     return segmentFor(hash).replace(key, hash, oldValue, newValue);
1686   }
1687   @CanIgnoreReturnValue
1688   @Override
1689   public V replace(K key, V value) {
1690     checkNotNull(key);
1691     checkNotNull(value);
1692     int hash = hash(key);
1693     return segmentFor(hash).replace(key, hash, value);
1694   }
1695   @Override
1696   public void clear() {
1697     for (Segment&lt;K, V, E, S&gt; segment : segments) {
1698       segment.clear();
1699     }
1700   }
1701   transient @Nullable Set&lt;K&gt; keySet;
1702   @Override
1703   public Set&lt;K&gt; keySet() {
1704     Set&lt;K&gt; ks = keySet;
1705     return (ks != null) ? ks : (keySet = new KeySet());
1706   }
1707   transient @Nullable Collection&lt;V&gt; values;
1708   @Override
1709   public Collection&lt;V&gt; values() {
1710     Collection&lt;V&gt; vs = values;
1711     return (vs != null) ? vs : (values = new Values());
1712   }
1713   transient @Nullable Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
1714   @Override
1715   public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
1716     Set&lt;Entry&lt;K, V&gt;&gt; es = entrySet;
1717     return (es != null) ? es : (entrySet = new EntrySet());
1718   }
1719   abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; {
1720     int nextSegmentIndex;
1721     int nextTableIndex;
1722     @Nullable Segment&lt;K, V, E, S&gt; currentSegment;
1723     @Nullable AtomicReferenceArray&lt;E&gt; currentTable;
1724     @Nullable E nextEntry;
1725     @Nullable WriteThroughEntry nextExternal;
1726     @Nullable WriteThroughEntry lastReturned;
1727     HashIterator() {
1728       nextSegmentIndex = segments.length - 1;
1729       nextTableIndex = -1;
1730       advance();
1731     }
1732     @Override
1733     public abstract T next();
1734     final void advance() {
1735       nextExternal = null;
1736       if (nextInChain()) {
1737         return;
1738       }
1739       if (nextInTable()) {
1740         return;
1741       }
1742       while (nextSegmentIndex &gt;= 0) {
1743         currentSegment = segments[nextSegmentIndex--];
1744         if (currentSegment.count != 0) {
1745           currentTable = currentSegment.table;
1746           nextTableIndex = currentTable.length() - 1;
1747           if (nextInTable()) {
1748             return;
1749           }
1750         }
1751       }
1752     }
1753     boolean nextInChain() {
1754       if (nextEntry != null) {
1755         for (nextEntry = nextEntry.getNext(); nextEntry != null; nextEntry = nextEntry.getNext()) {
1756           if (advanceTo(nextEntry)) {
1757             return true;
1758           }
1759         }
1760       }
1761       return false;
1762     }
1763     boolean nextInTable() {
1764       while (nextTableIndex &gt;= 0) {
1765         if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {
1766           if (advanceTo(nextEntry) || nextInChain()) {
1767             return true;
1768           }
1769         }
1770       }
1771       return false;
1772     }
1773     boolean advanceTo(E entry) {
1774       try {
1775         K key = entry.getKey();
1776         V value = getLiveValue(entry);
1777         if (value != null) {
1778           nextExternal = new WriteThroughEntry(key, value);
1779           return true;
1780         } else {
1781           return false;
1782         }
1783       } finally {
1784         currentSegment.postReadCleanup();
1785       }
1786     }
1787     @Override
1788     public boolean hasNext() {
1789       return nextExternal != null;
1790     }
1791     WriteThroughEntry nextEntry() {
1792       if (nextExternal == null) {
1793         throw new NoSuchElementException();
1794       }
1795       lastReturned = nextExternal;
1796       advance();
1797       return lastReturned;
1798     }
1799     @Override
1800     public void remove() {
1801       checkRemove(lastReturned != null);
1802       MapMakerInternalMap.this.remove(lastReturned.getKey());
1803       lastReturned = null;
1804     }
1805   }
1806   final class KeyIterator extends HashIterator&lt;K&gt; {
1807     @Override
1808     public K next() {
1809       return nextEntry().getKey();
1810     }
1811   }
1812   final class ValueIterator extends HashIterator&lt;V&gt; {
1813     @Override
1814     public V next() {
1815       return nextEntry().getValue();
1816     }
1817   }
1818   final class WriteThroughEntry extends AbstractMapEntry&lt;K, V&gt; {
1819     final K key;     V value; 
1820     WriteThroughEntry(K key, V value) {
1821       this.key = key;
1822       this.value = value;
1823     }
1824     @Override
1825     public K getKey() {
1826       return key;
1827     }
1828     @Override
1829     public V getValue() {
1830       return value;
1831     }
1832     @Override
1833     public boolean equals(@Nullable Object object) {
1834       if (object instanceof Entry) {
1835         Entry&lt;?, ?&gt; that = (Entry&lt;?, ?&gt;) object;
1836         return key.equals(that.getKey()) &amp;&amp; value.equals(that.getValue());
1837       }
1838       return false;
1839     }
1840     @Override
1841     public int hashCode() {
1842       return key.hashCode() ^ value.hashCode();
1843     }
1844     @Override
1845     public V setValue(V newValue) {
1846       V oldValue = put(key, newValue);
1847       value = newValue;       return oldValue;
1848     }
1849   }
1850   final class EntryIterator extends HashIterator&lt;Entry&lt;K, V&gt;&gt; {
1851     @Override
1852     public Entry&lt;K, V&gt; next() {
1853       return nextEntry();
1854     }
1855   }
1856   @WeakOuter
1857   final class KeySet extends SafeToArraySet&lt;K&gt; {
1858     @Override
1859     public Iterator&lt;K&gt; iterator() {
1860       return new KeyIterator();
1861     }
1862     @Override
1863     public int size() {
1864       return MapMakerInternalMap.this.size();
1865     }
1866     @Override
1867     public boolean isEmpty() {
1868       return MapMakerInternalMap.this.isEmpty();
1869     }
1870     @Override
1871     public boolean contains(Object o) {
1872       return MapMakerInternalMap.this.containsKey(o);
1873     }
1874     @Override
1875     public boolean remove(Object o) {
1876       return MapMakerInternalMap.this.remove(o) != null;
1877     }
1878     @Override
1879     public void clear() {
1880       MapMakerInternalMap.this.clear();
1881     }
1882   }
1883   @WeakOuter
1884   final class Values extends AbstractCollection&lt;V&gt; {
1885     @Override
1886     public Iterator&lt;V&gt; iterator() {
1887       return new ValueIterator();
1888     }
1889     @Override
1890     public int size() {
1891       return MapMakerInternalMap.this.size();
1892     }
1893     @Override
1894     public boolean isEmpty() {
1895       return MapMakerInternalMap.this.isEmpty();
1896     }
1897     @Override
1898     public boolean contains(Object o) {
1899       return MapMakerInternalMap.this.containsValue(o);
1900     }
1901     @Override
1902     public void clear() {
1903       MapMakerInternalMap.this.clear();
1904     }
1905     @Override
1906     public Object[] toArray() {
1907       return toArrayList(this).toArray();
1908     }
1909     @Override
1910     public &lt;T&gt; T[] toArray(T[] a) {
1911       return toArrayList(this).toArray(a);
1912     }
1913   }
1914   @WeakOuter
1915   final class EntrySet extends SafeToArraySet&lt;Entry&lt;K, V&gt;&gt; {
1916     @Override
1917     public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
1918       return new EntryIterator();
1919     }
1920     @Override
1921     public boolean contains(Object o) {
1922       if (!(o instanceof Entry)) {
1923         return false;
1924       }
1925       Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;
1926       Object key = e.getKey();
1927       if (key == null) {
1928         return false;
1929       }
1930       V v = MapMakerInternalMap.this.get(key);
1931       return v != null &amp;&amp; valueEquivalence().equivalent(e.getValue(), v);
1932     }
1933     @Override
1934     public boolean remove(Object o) {
1935       if (!(o instanceof Entry)) {
1936         return false;
1937       }
1938       Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;
1939       Object key = e.getKey();
1940       return key != null &amp;&amp; MapMakerInternalMap.this.remove(key, e.getValue());
1941     }
1942     @Override
1943     public int size() {
1944       return MapMakerInternalMap.this.size();
1945     }
1946     @Override
1947     public boolean isEmpty() {
1948       return MapMakerInternalMap.this.isEmpty();
1949     }
1950     @Override
1951     public void clear() {
1952       MapMakerInternalMap.this.clear();
1953     }
1954   }
1955   private abstract static class SafeToArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; {
1956     @Override
1957     public Object[] toArray() {
1958       return toArrayList(this).toArray();
1959     }
1960     @Override
1961     public &lt;T&gt; T[] toArray(T[] a) {
1962       return toArrayList(this).toArray(a);
1963     }
1964   }
1965   private static &lt;E&gt; ArrayList&lt;E&gt; toArrayList(Collection&lt;E&gt; c) {
1966     ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;(c.size());
1967     Iterators.addAll(result, c.iterator());
1968     return result;
1969   }
1970   private static final long serialVersionUID = 5;
1971   Object writeReplace() {
1972     return new SerializationProxy&lt;&gt;(
1973         entryHelper.keyStrength(),
1974         entryHelper.valueStrength(),
1975         keyEquivalence,
1976         entryHelper.valueStrength().defaultEquivalence(),
1977         concurrencyLevel,
1978         this);
1979   }
1980   abstract static class AbstractSerializationProxy&lt;K, V&gt; extends ForwardingConcurrentMap&lt;K, V&gt;
1981       implements Serializable {
1982     private static final long serialVersionUID = 3;
1983     final Strength keyStrength;
1984     final Strength valueStrength;
1985     final Equivalence&lt;Object&gt; keyEquivalence;
1986     final Equivalence&lt;Object&gt; valueEquivalence;
1987     final int concurrencyLevel;
1988     transient ConcurrentMap&lt;K, V&gt; delegate;
1989     AbstractSerializationProxy(
1990         Strength keyStrength,
1991         Strength valueStrength,
1992         Equivalence&lt;Object&gt; keyEquivalence,
1993         Equivalence&lt;Object&gt; valueEquivalence,
1994         int concurrencyLevel,
1995         ConcurrentMap&lt;K, V&gt; delegate) {
1996       this.keyStrength = keyStrength;
1997       this.valueStrength = valueStrength;
1998       this.keyEquivalence = keyEquivalence;
1999       this.valueEquivalence = valueEquivalence;
2000       this.concurrencyLevel = concurrencyLevel;
2001       this.delegate = delegate;
2002     }
2003     @Override
2004     protected ConcurrentMap&lt;K, V&gt; delegate() {
2005       return delegate;
2006     }
2007     void writeMapTo(ObjectOutputStream out) throws IOException {
2008       out.writeInt(delegate.size());
2009       for (Entry&lt;K, V&gt; entry : delegate.entrySet()) {
2010         out.writeObject(entry.getKey());
2011         out.writeObject(entry.getValue());
2012       }
2013       out.writeObject(null);     }
2014     @SuppressWarnings("deprecation")     MapMaker readMapMaker(ObjectInputStream in) throws IOException {
2015       int size = in.readInt();
2016       return new MapMaker()
2017           .initialCapacity(size)
2018           .setKeyStrength(keyStrength)
2019           .setValueStrength(valueStrength)
2020           .keyEquivalence(keyEquivalence)
2021           .concurrencyLevel(concurrencyLevel);
2022     }
2023     @SuppressWarnings("unchecked")
2024     void readEntries(ObjectInputStream in) throws IOException, ClassNotFoundException {
2025       while (true) {
2026         K key = (K) in.readObject();
2027         if (key == null) {
2028           break;         }
2029         V value = (V) in.readObject();
2030         delegate.put(key, value);
2031       }
2032     }
2033   }
2034   private static final class SerializationProxy&lt;K, V&gt; extends AbstractSerializationProxy&lt;K, V&gt; {
2035     private static final long serialVersionUID = 3;
2036     SerializationProxy(
2037         Strength keyStrength,
2038         Strength valueStrength,
2039         Equivalence&lt;Object&gt; keyEquivalence,
2040         Equivalence&lt;Object&gt; valueEquivalence,
2041         int concurrencyLevel,
2042         ConcurrentMap&lt;K, V&gt; delegate) {
2043       super(
2044           keyStrength, valueStrength, keyEquivalence, valueEquivalence, concurrencyLevel, delegate);
2045     }
2046     private void writeObject(ObjectOutputStream out) throws IOException {
2047       out.defaultWriteObject();
2048       writeMapTo(out);
2049     }
2050     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
2051       in.defaultReadObject();
2052       MapMaker mapMaker = readMapMaker(in);
2053       delegate = mapMaker.makeMap();
2054       readEntries(in);
2055     }
2056     private Object readResolve() {
2057       return delegate;
2058     }
2059   }
2060 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
