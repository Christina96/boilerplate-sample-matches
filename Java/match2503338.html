<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for RemoteDigestBlob.java &amp; HashInnerJoinBatchIterator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RemoteDigestBlob.java &amp; HashInnerJoinBatchIterator.java
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RemoteDigestBlob.java (11.515152%)<th>HashInnerJoinBatchIterator.java (7.45098%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(79-87)<td><a href="#" name="0">(95-104)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(22-32)<td><a href="#" name="1">(22-31)</a><td align="center"><font color="#e50000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RemoteDigestBlob.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="1"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.blob;

import io.crate.common.Hex;
import io.netty.buffer.ByteBuf;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.client.Client;
import org.apache.logging.log4j.LogManager;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.transport.netty4.Netty4Utils;

import</b></font> java.util.UUID;

public class RemoteDigestBlob {

    public enum Status {
        FULL((byte) 0),
        PARTIAL((byte) 1),
        MISMATCH((byte) 2),
        EXISTS((byte) 3),
        FAILED((byte) 4);


        private final byte id;

        Status(byte id) {
            this.id = id;
        }

        /**
         * The internal representation of the status.
         */
        public byte id() {
            return id;
        }

        public static Status fromId(byte id) {
            switch (id) {
                case 0:
                    return FULL;
                case 1:
                    return PARTIAL;
                case 2:
                    return MISMATCH;
                case 3:
                    return EXISTS;
                case 4:
                    return FAILED;
                default:
                    throw new IllegalArgumentException("No status match for [" + id + "]");
            }
        }
    }


<a name="0"></a>    private static final Logger LOGGER = LogManager.getLogger(RemoteDigestBlob.class);

    private final ShardId shardId;
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final String digest;
    private final Client client;
    private long size;
    private StartBlobResponse startResponse;
    private UUID transferId;
    private Status status;


    public RemoteDigestBlob(Client client, ShardId shardId, String digest</b></font>) {
        this.digest = digest;
        this.client = client;
        this.size = 0;
        this.shardId = shardId;
    }

    public Status status() {
        return status;
    }

    public boolean delete() {
        LOGGER.trace("delete");
        assert transferId == null : "transferId should be null";
        DeleteBlobRequest request = new DeleteBlobRequest(
            shardId,
            Hex.decodeHex(digest)
        );

        return client.execute(DeleteBlobAction.INSTANCE, request).actionGet().deleted;
    }

    private Status start(ByteBuf buffer, boolean last) {
        LOGGER.trace("start blob upload");
        assert transferId == null : "transferId should be null";
        StartBlobRequest request = new StartBlobRequest(
            shardId,
            Hex.decodeHex(digest),
            Netty4Utils.toBytesReference(buffer),
            last
        );
        transferId = request.transferId();
        size += buffer.readableBytes();

        startResponse = client.execute(StartBlobAction.INSTANCE, request).actionGet();
        status = startResponse.status();
        return status;
    }

    private Status chunk(ByteBuf buffer, boolean last) {
        assert transferId != null : "transferId should not be null";
        PutChunkRequest request = new PutChunkRequest(
            shardId,
            Hex.decodeHex(digest),
            transferId,
            Netty4Utils.toBytesReference(buffer),
            size,
            last
        );
        size += buffer.readableBytes();
        PutChunkResponse putChunkResponse = client.execute(PutChunkAction.INSTANCE, request).actionGet();
        return putChunkResponse.status();
    }

    public Status addContent(ByteBuf buffer, boolean last) {
        if (startResponse == null) {
            // this is the first call to addContent
            return start(buffer, last);
        } else if (status == Status.EXISTS) {
            // client probably doesn't support 100-continue and is sending chunked requests
            // need to ignore the content.
            return status;
        } else if (status != Status.PARTIAL) {
            throw new IllegalStateException("Expected Status.PARTIAL for chunk but got: " + status);
        } else {
            return chunk(buffer, last);
        }
    }

    public long size() {
        return size;
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashInnerJoinBatchIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="1"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.execution.engine.join;

import io.crate.breaker.RowAccounting;
import io.crate.data.BatchIterator;
import io.crate.data.Paging;
import io.crate.data.Row;
import io.crate.data.UnsafeArrayRow;
import io.crate.data.join.CombinedRow;
import io.crate.data.join.JoinBatchIterator;
import</b></font> io.netty.util.collection.IntObjectHashMap;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CompletionStage;
import java.util.function.IntSupplier;
import java.util.function.Predicate;
import java.util.function.ToIntFunction;

/**
 * &lt;pre&gt;
 *     Build Phase:
 *     for (leftRow in left) {
 *         calculate hash and put in Buffer (HashMap) until the blockSize is reached
 *     }
 *
 *     Probe Phase:
 *     // We iterate on the right until we find a matching row or the right side needs to be loaded a next batch of data
 *     for (rightRow in right) {
 *         if (hash(rightRow) found in Buffer {
 *            for (row in matchedInBuffer) { // Handle duplicate values from left and hash collisions
 *                if (joinCondition matches) {
 *                    // We need to check that the joinCondition matches as we can have a hash collision
 *                    // or the join condition can contain more operators.
 *                    //
 *                    // Row-lookup-by-hash-code can only work by the EQ operators of a join condition,
 *                    // all other possible operators must be checked afterwards.
 *                    emmit(combinedRow)
 *                }
 *            }
 *         }
 *     }
 *
 *     When the right side is all loaded, we reset the right iterator to start, clear the buffer and switch back to
 *     iterate the next elements in the left side and re-build the buffer based on the next items in the left until we
 *     reach the blockSize again.
 *
 *     Repeat until both sides are all loaded and processed.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The caller of the constructor needs to pass two functions {@link #hashBuilderForLeft} and {@link #hashBuilderForRight}.
 * Those functions are called on each row of the left and right side respectively and they return the hash value of
 * the relevant columns of the row.
 * &lt;p&gt;
 * This information is not available for the {@link HashInnerJoinBatchIterator}, so it's the responsibility of the
 * caller to provide those two functions that operate on the left and right rows accordingly and return the hash values.
 */
public class HashInnerJoinBatchIterator extends JoinBatchIterator&lt;Row, Row, Row&gt; {

    private final RowAccounting&lt;Object[]&gt; leftRowAccounting;
    private final Predicate&lt;Row&gt; joinCondition;

    /**
     * Used to avoid instantiating multiple times RowN in {@link #findMatchingRows()}
     */
    private final UnsafeArrayRow leftRow = new UnsafeArrayRow();
    private final ToIntFunction&lt;Row&gt; hashBuilderForLeft;
    private final ToIntFunction&lt;Row&gt; hashBuilderForRight;
    private final IntSupplier calculateBlockSize;
    private final IntObjectHashMap&lt;List&lt;Object[]&gt;&gt; buffer;
<a name="0"></a>
    private final UnsafeArrayRow unsafeArrayRow = new UnsafeArrayRow();

    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private int blockSize;
    private int numberOfRowsInBuffer = 0;
    private boolean leftBatchHasItems = false;
    private int numberOfLeftBatchesForBlock;
    private int numberOfLeftBatchesLoadedForBlock;
    private Iterator&lt;Object[]&gt; leftMatchingRowsIterator;

    public HashInnerJoinBatchIterator(BatchIterator&lt;Row&gt; left,
                                      BatchIterator&lt;Row&gt; right,
                                      RowAccounting&lt;Object[]&gt; leftRowAccounting</b></font>,
                                      CombinedRow combiner,
                                      Predicate&lt;Row&gt; joinCondition,
                                      ToIntFunction&lt;Row&gt; hashBuilderForLeft,
                                      ToIntFunction&lt;Row&gt; hashBuilderForRight,
                                      IntSupplier calculateBlockSize) {
        super(left, right, combiner);
        this.leftRowAccounting = leftRowAccounting;
        this.joinCondition = joinCondition;
        this.hashBuilderForLeft = hashBuilderForLeft;
        this.hashBuilderForRight = hashBuilderForRight;
        this.calculateBlockSize = calculateBlockSize;
        // resized upon block size calculation
        this.buffer = new IntObjectHashMap&lt;&gt;();
        resetBuffer();
        numberOfLeftBatchesLoadedForBlock = 0;
        this.activeIt = left;
    }

    @Override
    public Row currentElement() {
        return combiner.currentElement();
    }

    @Override
    public void moveToStart() {
        left.moveToStart();
        right.moveToStart();
        activeIt = left;
        resetBuffer();
        leftMatchingRowsIterator = null;
    }

    @Override
    public CompletionStage&lt;?&gt; loadNextBatch() throws Exception {
        if (activeIt == left) {
            numberOfLeftBatchesLoadedForBlock++;
        }
        return super.loadNextBatch();
    }

    @Override
    public boolean moveNext() {
        while (buildBufferAndMatchRight() == false) {
            if (right.allLoaded() &amp;&amp; leftBatchHasItems == false &amp;&amp; left.allLoaded()) {
                // both sides are fully loaded, we're done here
                return false;
            } else if (activeIt == left) {
                // left needs the next batch loaded
                return false;
            } else if (right.allLoaded()) {
                right.moveToStart();
                activeIt = left;
                resetBuffer();
            } else {
                return false;
            }
        }

        // match found
        return true;
    }

    private void resetBuffer() {
        blockSize = calculateBlockSize.getAsInt();
        buffer.clear();
        numberOfRowsInBuffer = 0;
        leftRowAccounting.release();

        // A batch is not guaranteed to deliver PAGE_SIZE number of rows. It could be more or less.
        // So we cannot rely on that to decide if processing 1 block is done, we must also know and track how much
        // batches should be required for processing 1 block.
        numberOfLeftBatchesForBlock = Math.max(1, (int) Math.ceil((double) blockSize / Paging.PAGE_SIZE));
        numberOfLeftBatchesLoadedForBlock = leftBatchHasItems ? 1 : 0;
    }

    private boolean buildBufferAndMatchRight() {
        if (activeIt == left) {
            while (leftBatchHasItems = left.moveNext()) {
                Object[] leftRow = left.currentElement().materialize();
                leftRowAccounting.accountForAndMaybeBreak(leftRow);
                int hash = hashBuilderForLeft.applyAsInt(unsafeArrayRow.cells(leftRow));
                addToBuffer(leftRow, hash);
                if (numberOfRowsInBuffer == blockSize) {
                    break;
                }
            }

            if (mustLoadLeftNextBatch()) {
                // we should load the left side
                return false;
            }

            if (mustSwitchToRight()) {
                activeIt = right;
            }
        }

        // In case of multiple matches on the left side (duplicate values or hash collisions)
        if (leftMatchingRowsIterator != null &amp;&amp; findMatchingRows()) {
            return true;
        }
        leftMatchingRowsIterator = null;
        while (right.moveNext()) {
            int rightHash = hashBuilderForRight.applyAsInt(right.currentElement());
            List&lt;Object[]&gt; leftMatchingRows = buffer.get(rightHash);
            if (leftMatchingRows != null) {
                leftMatchingRowsIterator = leftMatchingRows.iterator();
                combiner.setRight(right.currentElement());
                if (findMatchingRows()) {
                    return true;
                }
            }
        }

        // need to load the next batch of the right relation
        return false;
    }

    private void addToBuffer(Object[] currentRow, int hash) {
        List&lt;Object[]&gt; existingRows = buffer.get(hash);
        if (existingRows == null) {
            existingRows = new ArrayList&lt;&gt;();
            buffer.put(hash, existingRows);
        }
        existingRows.add(currentRow);
        numberOfRowsInBuffer++;
    }

    private boolean findMatchingRows() {
        while (leftMatchingRowsIterator.hasNext()) {
            leftRow.cells(leftMatchingRowsIterator.next());
            combiner.setLeft(leftRow);
            if (joinCondition.test(combiner.currentElement())) {
                return true;
            }
        }
        return false;
    }

    private boolean mustSwitchToRight() {
        return left.allLoaded()
               || numberOfRowsInBuffer == blockSize
               || (leftBatchHasItems == false &amp;&amp; numberOfLeftBatchesLoadedForBlock == numberOfLeftBatchesForBlock);
    }

    private boolean mustLoadLeftNextBatch() {
        return leftBatchHasItems == false
               &amp;&amp; left.allLoaded() == false
               &amp;&amp; numberOfRowsInBuffer &lt; blockSize
               &amp;&amp; numberOfLeftBatchesLoadedForBlock &lt; numberOfLeftBatchesForBlock;
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
