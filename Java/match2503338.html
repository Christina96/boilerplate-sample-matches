<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RemoteDigestBlob.java &amp; HashInnerJoinBatchIterator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RemoteDigestBlob.java &amp; HashInnerJoinBatchIterator.java
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RemoteDigestBlob.java (11.515152%)<th>HashInnerJoinBatchIterator.java (7.45098%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(79-87)<td><a href="#" name="0">(95-104)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(22-32)<td><a href="#" name="1">(22-31)</a><td align="center"><font color="#e50000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RemoteDigestBlob.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.blob;
2 import io.crate.common.Hex;
3 import io.netty.buffer.ByteBuf;
4 import org.apache.logging.log4j.Logger;
5 import org.elasticsearch.client.Client;
6 import org.apache.logging.log4j.LogManager;
7 import org.elasticsearch.index.shard.ShardId;
8 import org.elasticsearch.transport.netty4.Netty4Utils;
9 import</b></font> java.util.UUID;
10 public class RemoteDigestBlob {
11     public enum Status {
12         FULL((byte) 0),
13         PARTIAL((byte) 1),
14         MISMATCH((byte) 2),
15         EXISTS((byte) 3),
16         FAILED((byte) 4);
17         private final byte id;
18         Status(byte id) {
19             this.id = id;
20         }
21         public byte id() {
22             return id;
23         }
24         public static Status fromId(byte id) {
25             switch (id) {
26                 case 0:
27                     return FULL;
28                 case 1:
29                     return PARTIAL;
30                 case 2:
31                     return MISMATCH;
32                 case 3:
33                     return EXISTS;
34                 case 4:
35                     return FAILED;
36                 default:
37                     throw new IllegalArgumentException("No status match for [" + id + "]");
38             }
39         }
40     }
41 <a name="0"></a>    private static final Logger LOGGER = LogManager.getLogger(RemoteDigestBlob.class);
42     private final ShardId shardId;
43     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final String digest;
44     private final Client client;
45     private long size;
46     private StartBlobResponse startResponse;
47     private UUID transferId;
48     private Status status;
49     public RemoteDigestBlob(Client client, ShardId shardId, String digest</b></font>) {
50         this.digest = digest;
51         this.client = client;
52         this.size = 0;
53         this.shardId = shardId;
54     }
55     public Status status() {
56         return status;
57     }
58     public boolean delete() {
59         LOGGER.trace("delete");
60         assert transferId == null : "transferId should be null";
61         DeleteBlobRequest request = new DeleteBlobRequest(
62             shardId,
63             Hex.decodeHex(digest)
64         );
65         return client.execute(DeleteBlobAction.INSTANCE, request).actionGet().deleted;
66     }
67     private Status start(ByteBuf buffer, boolean last) {
68         LOGGER.trace("start blob upload");
69         assert transferId == null : "transferId should be null";
70         StartBlobRequest request = new StartBlobRequest(
71             shardId,
72             Hex.decodeHex(digest),
73             Netty4Utils.toBytesReference(buffer),
74             last
75         );
76         transferId = request.transferId();
77         size += buffer.readableBytes();
78         startResponse = client.execute(StartBlobAction.INSTANCE, request).actionGet();
79         status = startResponse.status();
80         return status;
81     }
82     private Status chunk(ByteBuf buffer, boolean last) {
83         assert transferId != null : "transferId should not be null";
84         PutChunkRequest request = new PutChunkRequest(
85             shardId,
86             Hex.decodeHex(digest),
87             transferId,
88             Netty4Utils.toBytesReference(buffer),
89             size,
90             last
91         );
92         size += buffer.readableBytes();
93         PutChunkResponse putChunkResponse = client.execute(PutChunkAction.INSTANCE, request).actionGet();
94         return putChunkResponse.status();
95     }
96     public Status addContent(ByteBuf buffer, boolean last) {
97         if (startResponse == null) {
98             return start(buffer, last);
99         } else if (status == Status.EXISTS) {
100             return status;
101         } else if (status != Status.PARTIAL) {
102             throw new IllegalStateException("Expected Status.PARTIAL for chunk but got: " + status);
103         } else {
104             return chunk(buffer, last);
105         }
106     }
107     public long size() {
108         return size;
109     }
110 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashInnerJoinBatchIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.execution.engine.join;
2 import io.crate.breaker.RowAccounting;
3 import io.crate.data.BatchIterator;
4 import io.crate.data.Paging;
5 import io.crate.data.Row;
6 import io.crate.data.UnsafeArrayRow;
7 import io.crate.data.join.CombinedRow;
8 import io.crate.data.join.JoinBatchIterator;
9 import</b></font> io.netty.util.collection.IntObjectHashMap;
10 import java.util.ArrayList;
11 import java.util.Iterator;
12 import java.util.List;
13 import java.util.concurrent.CompletionStage;
14 import java.util.function.IntSupplier;
15 import java.util.function.Predicate;
16 import java.util.function.ToIntFunction;
17 public class HashInnerJoinBatchIterator extends JoinBatchIterator&lt;Row, Row, Row&gt; {
18     private final RowAccounting&lt;Object[]&gt; leftRowAccounting;
19     private final Predicate&lt;Row&gt; joinCondition;
20     private final UnsafeArrayRow leftRow = new UnsafeArrayRow();
21     private final ToIntFunction&lt;Row&gt; hashBuilderForLeft;
22     private final ToIntFunction&lt;Row&gt; hashBuilderForRight;
23     private final IntSupplier calculateBlockSize;
24     private final IntObjectHashMap&lt;List&lt;Object[]&gt;&gt; buffer;
25 <a name="0"></a>
26     private final UnsafeArrayRow unsafeArrayRow = new UnsafeArrayRow();
27     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private int blockSize;
28     private int numberOfRowsInBuffer = 0;
29     private boolean leftBatchHasItems = false;
30     private int numberOfLeftBatchesForBlock;
31     private int numberOfLeftBatchesLoadedForBlock;
32     private Iterator&lt;Object[]&gt; leftMatchingRowsIterator;
33     public HashInnerJoinBatchIterator(BatchIterator&lt;Row&gt; left,
34                                       BatchIterator&lt;Row&gt; right,
35                                       RowAccounting&lt;Object[]&gt; leftRowAccounting</b></font>,
36                                       CombinedRow combiner,
37                                       Predicate&lt;Row&gt; joinCondition,
38                                       ToIntFunction&lt;Row&gt; hashBuilderForLeft,
39                                       ToIntFunction&lt;Row&gt; hashBuilderForRight,
40                                       IntSupplier calculateBlockSize) {
41         super(left, right, combiner);
42         this.leftRowAccounting = leftRowAccounting;
43         this.joinCondition = joinCondition;
44         this.hashBuilderForLeft = hashBuilderForLeft;
45         this.hashBuilderForRight = hashBuilderForRight;
46         this.calculateBlockSize = calculateBlockSize;
47         this.buffer = new IntObjectHashMap&lt;&gt;();
48         resetBuffer();
49         numberOfLeftBatchesLoadedForBlock = 0;
50         this.activeIt = left;
51     }
52     @Override
53     public Row currentElement() {
54         return combiner.currentElement();
55     }
56     @Override
57     public void moveToStart() {
58         left.moveToStart();
59         right.moveToStart();
60         activeIt = left;
61         resetBuffer();
62         leftMatchingRowsIterator = null;
63     }
64     @Override
65     public CompletionStage&lt;?&gt; loadNextBatch() throws Exception {
66         if (activeIt == left) {
67             numberOfLeftBatchesLoadedForBlock++;
68         }
69         return super.loadNextBatch();
70     }
71     @Override
72     public boolean moveNext() {
73         while (buildBufferAndMatchRight() == false) {
74             if (right.allLoaded() &amp;&amp; leftBatchHasItems == false &amp;&amp; left.allLoaded()) {
75                 return false;
76             } else if (activeIt == left) {
77                 return false;
78             } else if (right.allLoaded()) {
79                 right.moveToStart();
80                 activeIt = left;
81                 resetBuffer();
82             } else {
83                 return false;
84             }
85         }
86         return true;
87     }
88     private void resetBuffer() {
89         blockSize = calculateBlockSize.getAsInt();
90         buffer.clear();
91         numberOfRowsInBuffer = 0;
92         leftRowAccounting.release();
93         numberOfLeftBatchesForBlock = Math.max(1, (int) Math.ceil((double) blockSize / Paging.PAGE_SIZE));
94         numberOfLeftBatchesLoadedForBlock = leftBatchHasItems ? 1 : 0;
95     }
96     private boolean buildBufferAndMatchRight() {
97         if (activeIt == left) {
98             while (leftBatchHasItems = left.moveNext()) {
99                 Object[] leftRow = left.currentElement().materialize();
100                 leftRowAccounting.accountForAndMaybeBreak(leftRow);
101                 int hash = hashBuilderForLeft.applyAsInt(unsafeArrayRow.cells(leftRow));
102                 addToBuffer(leftRow, hash);
103                 if (numberOfRowsInBuffer == blockSize) {
104                     break;
105                 }
106             }
107             if (mustLoadLeftNextBatch()) {
108                 return false;
109             }
110             if (mustSwitchToRight()) {
111                 activeIt = right;
112             }
113         }
114         if (leftMatchingRowsIterator != null &amp;&amp; findMatchingRows()) {
115             return true;
116         }
117         leftMatchingRowsIterator = null;
118         while (right.moveNext()) {
119             int rightHash = hashBuilderForRight.applyAsInt(right.currentElement());
120             List&lt;Object[]&gt; leftMatchingRows = buffer.get(rightHash);
121             if (leftMatchingRows != null) {
122                 leftMatchingRowsIterator = leftMatchingRows.iterator();
123                 combiner.setRight(right.currentElement());
124                 if (findMatchingRows()) {
125                     return true;
126                 }
127             }
128         }
129         return false;
130     }
131     private void addToBuffer(Object[] currentRow, int hash) {
132         List&lt;Object[]&gt; existingRows = buffer.get(hash);
133         if (existingRows == null) {
134             existingRows = new ArrayList&lt;&gt;();
135             buffer.put(hash, existingRows);
136         }
137         existingRows.add(currentRow);
138         numberOfRowsInBuffer++;
139     }
140     private boolean findMatchingRows() {
141         while (leftMatchingRowsIterator.hasNext()) {
142             leftRow.cells(leftMatchingRowsIterator.next());
143             combiner.setLeft(leftRow);
144             if (joinCondition.test(combiner.currentElement())) {
145                 return true;
146             }
147         }
148         return false;
149     }
150     private boolean mustSwitchToRight() {
151         return left.allLoaded()
152                || numberOfRowsInBuffer == blockSize
153                || (leftBatchHasItems == false &amp;&amp; numberOfLeftBatchesLoadedForBlock == numberOfLeftBatchesForBlock);
154     }
155     private boolean mustLoadLeftNextBatch() {
156         return leftBatchHasItems == false
157                &amp;&amp; left.allLoaded() == false
158                &amp;&amp; numberOfRowsInBuffer &lt; blockSize
159                &amp;&amp; numberOfLeftBatchesLoadedForBlock &lt; numberOfLeftBatchesForBlock;
160     }
161 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
