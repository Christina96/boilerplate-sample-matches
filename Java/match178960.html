<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ImmutableTableTest.java & MapInterfaceTest_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ImmutableTableTest.java & MapInterfaceTest_1.java
      </h3>
      <h1 align="center">
        21.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ImmutableTableTest.java (50.813007%)<TH>MapInterfaceTest_1.java (13.6861315%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#0',2,'match178960-1.html#0',3)" NAME="0">(241-250)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#0',2,'match178960-1.html#0',3)" NAME="0">(170-177)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#1',2,'match178960-1.html#1',3)" NAME="1">(311-318)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#1',2,'match178960-1.html#1',3)" NAME="1">(831-840)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#2',2,'match178960-1.html#2',3)" NAME="2">(191-197)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#2',2,'match178960-1.html#2',3)" NAME="2">(900-909)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#3',2,'match178960-1.html#3',3)" NAME="3">(327-333)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#3',2,'match178960-1.html#3',3)" NAME="3">(807-815)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#4',2,'match178960-1.html#4',3)" NAME="4">(259-270)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#4',2,'match178960-1.html#4',3)" NAME="4">(227-234)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#5',2,'match178960-1.html#5',3)" NAME="5">(147-158)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#5',2,'match178960-1.html#5',3)" NAME="5">(388-395)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#6',2,'match178960-1.html#6',3)" NAME="6">(201-208)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#6',2,'match178960-1.html#6',3)" NAME="6">(182-189)</A><TD ALIGN=center><FONT COLOR="#d40000">15</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#7',2,'match178960-1.html#7',3)" NAME="7">(212-224)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#7',2,'match178960-1.html#7',3)" NAME="7">(848-855)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#8',2,'match178960-1.html#8',3)" NAME="8">(360-364)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#8',2,'match178960-1.html#8',3)" NAME="8">(1075-1082)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#9',2,'match178960-1.html#9',3)" NAME="9">(344-348)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#9',2,'match178960-1.html#9',3)" NAME="9">(989-996)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#10',2,'match178960-1.html#10',3)" NAME="10">(280-290)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#10',2,'match178960-1.html#10',3)" NAME="10">(200-205)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#11',2,'match178960-1.html#11',3)" NAME="11">(73-81)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#11',2,'match178960-1.html#11',3)" NAME="11">(416-423)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#12',2,'match178960-1.html#12',3)" NAME="12">(47-55)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#12',2,'match178960-1.html#12',3)" NAME="12">(593-600)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#13',2,'match178960-1.html#13',3)" NAME="13">(367-375)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#13',2,'match178960-1.html#13',3)" NAME="13">(1226-1234)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#14',2,'match178960-1.html#14',3)" NAME="14">(300-309)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#14',2,'match178960-1.html#14',3)" NAME="14">(1134-1140)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#15',2,'match178960-1.html#15',3)" NAME="15">(270-274)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#15',2,'match178960-1.html#15',3)" NAME="15">(190-194)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#16',2,'match178960-1.html#16',3)" NAME="16">(225-235)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#16',2,'match178960-1.html#16',3)" NAME="16">(1018-1024)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#17',2,'match178960-1.html#17',3)" NAME="17">(100-106)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#17',2,'match178960-1.html#17',3)" NAME="17">(480-486)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#18',2,'match178960-1.html#18',3)" NAME="18">(296-298)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#18',2,'match178960-1.html#18',3)" NAME="18">(1107-1113)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#19',2,'match178960-1.html#19',3)" NAME="19">(172-178)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#19',2,'match178960-1.html#19',3)" NAME="19">(279-284)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#20',2,'match178960-1.html#20',3)" NAME="20">(94-99)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#20',2,'match178960-1.html#20',3)" NAME="20">(1274-1278)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#21',2,'match178960-1.html#21',3)" NAME="21">(88-93)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#21',2,'match178960-1.html#21',3)" NAME="21">(780-785)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#22',2,'match178960-1.html#22',3)" NAME="22">(350-357)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#22',2,'match178960-1.html#22',3)" NAME="22">(1268-1272)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#23',2,'match178960-1.html#23',3)" NAME="23">(334-341)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#23',2,'match178960-1.html#23',3)" NAME="23">(465-473)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#24',2,'match178960-1.html#24',3)" NAME="24">(166-171)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#24',2,'match178960-1.html#24',3)" NAME="24">(656-660)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#25',2,'match178960-1.html#25',3)" NAME="25">(160-165)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#25',2,'match178960-1.html#25',3)" NAME="25">(474-478)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#26',2,'match178960-1.html#26',3)" NAME="26">(58-67)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#26',2,'match178960-1.html#26',3)" NAME="26">(537-543)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#27',2,'match178960-1.html#27',3)" NAME="27">(251-253)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#27',2,'match178960-1.html#27',3)" NAME="27">(1047-1052)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
<TR><TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#28',2,'match178960-1.html#28',3)" NAME="28">(82-86)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#28',2,'match178960-1.html#28',3)" NAME="28">(564-569)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
<TR><TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT><TD><A HREF="javascript:ZweiFrames('match178960-0.html#29',2,'match178960-1.html#29',3)" NAME="29">(19-33)<TD><A HREF="javascript:ZweiFrames('match178960-0.html#29',2,'match178960-1.html#29',3)" NAME="29">(24-44)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableTableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="29"></A>
package com.google.common.collect;

<FONT color="#af7a82"><A HREF="javascript:ZweiFrames('match178960-1.html#29',3,'match178960-top.html#29',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.truth.Truth.assertThat;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.Table.Cell;
import com.google.common.testing.CollectorTester;
import com.google.common.testing.SerializableTester;
import java.util.stream.Collector;

/**
 * Tests common methods in {@link ImmutableTable}
 *
 * @author Gregory Kick
 */
@</B></FONT>GwtCompatible(emulated = true)
public class ImmutableTableTest extends AbstractTableReadTest {
  @Override
  protected Table&lt;String, Integer, Character&gt; create(Object... data) {
    ImmutableTable.Builder&lt;String, Integer, Character&gt; builder = ImmutableTable.builder();
    for (int i = 0; i &lt; data.length; i = i + 3) {
      builder.put((String) data[i], (Integer) data[i + 1], (Character) data[i + 2]);
    }
    return builder.build();
  }

<A NAME="12"></A>  // The bulk of the toImmutableTable tests can be found in TableCollectorsTest.
  // This gives minimal coverage to the forwarding functions
  public void testToImmutableTableSanityTest() {
    <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match178960-1.html#12',3,'match178960-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Collector&lt;Cell&lt;String, String, Integer&gt;, ?, ImmutableTable&lt;String, String, Integer&gt;&gt; collector =
        TableCollectors.toImmutableTable(Cell::getRowKey, Cell::getColumnKey, Cell::getValue);
    CollectorTester.of(collector)
        .expectCollects(ImmutableTable.of())
        .expectCollects(ImmutableTable.of(&quot;one&quot;, &quot;uno&quot;, 1), Tables.immutableCell(&quot;one&quot;, &quot;uno&quot;, 1));
  }

  public void testToImmutableTableMergingSanityTest() {
<A NAME="26"></A>    Collector&lt;Cell&lt;String, String, Integer&gt;, ?, ImmutableTable&lt;String, String, Integer&gt;&gt; collector =</B></FONT>
        TableCollectors.toImmutableTable(
            Cell::getRowKey, Cell::getColumnKey, Cell::getValue, Integer::sum);
    <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match178960-1.html#26',3,'match178960-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>CollectorTester.of(collector)
        .expectCollects(ImmutableTable.of())
        .expectCollects(
            ImmutableTable.of(&quot;one&quot;, &quot;uno&quot;, 3),
            Tables.immutableCell(&quot;one&quot;, &quot;uno&quot;, 1),
            Tables.immutableCell(&quot;one&quot;, &quot;uno&quot;, 2));
  }

  public void testBuilder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = new ImmutableTable.Builder&lt;&gt;()</B></FONT>;
    assertEquals(ImmutableTable.of(), builder.build());
    assertEquals(ImmutableTable.of('a', 1, &quot;foo&quot;), builder.put('a', 1, &quot;foo&quot;).build());
<A NAME="11"></A>    Table&lt;Character, Integer, String&gt; expectedTable = HashBasedTable.create();
    expectedTable.put('a', 1, &quot;foo&quot;);
    expectedTable.put('b', 1, &quot;bar&quot;);
    <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match178960-1.html#11',3,'match178960-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>expectedTable.put('a', 2, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; otherTable = HashBasedTable.create();
    otherTable.put('b', 1, &quot;bar&quot;);
    otherTable.put('a', 2, &quot;baz&quot;);
    assertEquals(expectedTable, builder.putAll(otherTable).build());
  }
<A NAME="28"></A>
  public void testBuilder_withImmutableCell() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = new ImmutableTable.Builder&lt;&gt;()</B></FONT>;
    <FONT color="#717d7d"><A HREF="javascript:ZweiFrames('match178960-1.html#28',3,'match178960-top.html#28',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(
        ImmutableTable.of('a', 1, &quot;foo&quot;), builder.put(Tables.immutableCell('a', 1, &quot;foo&quot;)).build());
  }
<A NAME="21"></A>
  public void testBuilder_withImmutableCellAndNullContents() {</B></FONT>
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = new ImmutableTable.Builder&lt;&gt;();
    <FONT color="#947010"><A HREF="javascript:ZweiFrames('match178960-1.html#21',3,'match178960-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put(Tables.immutableCell((Character) null, 1, &quot;foo&quot;));
      fail();
<A NAME="20"></A>    } catch (NullPointerException e) {
      // success
    }</B></FONT>
    <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match178960-1.html#20',3,'match178960-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put(Tables.immutableCell('a', (Integer) null, &quot;foo&quot;));
      fail();
<A NAME="17"></A>    } catch (NullPointerException e) {
      // success
    }</B></FONT>
    <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match178960-1.html#17',3,'match178960-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put(Tables.immutableCell('a', 1, (String) null));
      fail();
    } catch (NullPointerException e) {
      // success
    }
  }</B></FONT>

  private static class StringHolder {
    String string;
  }

  public void testBuilder_withMutableCell() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = new ImmutableTable.Builder&lt;&gt;();

    final StringHolder holder = new StringHolder();
    holder.string = &quot;foo&quot;;
    Table.Cell&lt;Character, Integer, String&gt; mutableCell =
        new Tables.AbstractCell&lt;Character, Integer, String&gt;() {
          @Override
          public Character getRowKey() {
            return 'K';
          }

          @Override
          public Integer getColumnKey() {
            return 42;
          }

          @Override
          public String getValue() {
            return holder.string;
          }
        };

    // Add the mutable cell to the builder
    builder.put(mutableCell);

    // Mutate the value
    holder.string = &quot;bar&quot;;

    // Make sure it uses the original value.
    assertEquals(ImmutableTable.of('K', 42, &quot;foo&quot;), builder.build());
  }
<A NAME="5"></A>
  public void testBuilder_noDuplicates() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder =
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match178960-1.html#5',3,'match178960-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ImmutableTable.Builder&lt;Character, Integer, String&gt;()
            .put('a', 1, &quot;foo&quot;)
            .put('a', 1, &quot;bar&quot;);
    try {
      builder.build();
      fail();
    } catch (IllegalArgumentException e) {
      // success
    }
  }
<A NAME="25"></A>
  public void testBuilder_noNulls() {</B></FONT>
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = new ImmutableTable.Builder&lt;&gt;();
    <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match178960-1.html#25',3,'match178960-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put(null, 1, &quot;foo&quot;);
      fail();
<A NAME="24"></A>    } catch (NullPointerException e) {
      // success
    }</B></FONT>
    <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match178960-1.html#24',3,'match178960-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put('a', null, &quot;foo&quot;);
      fail();
<A NAME="19"></A>    } catch (NullPointerException e) {
      // success
    }</B></FONT>
    <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match178960-1.html#19',3,'match178960-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      builder.put('a', 1, null);
      fail();
    } catch (NullPointerException e) {
      // success
    }
  }</B></FONT>

  private static &lt;R, C, V&gt; void validateTableCopies(Table&lt;R, C, V&gt; original) {
    Table&lt;R, C, V&gt; copy = ImmutableTable.copyOf(original);
    assertEquals(original, copy);
    validateViewOrdering(original, copy);

    Table&lt;R, C, V&gt; built = ImmutableTable.&lt;R, C, V&gt;builder().putAll(original).build();
    assertEquals(original, built);
    validateViewOrdering(original, built);
<A NAME="2"></A>  }

  private static &lt;R, C, V&gt; void validateViewOrdering(Table&lt;R, C, V&gt; original, Table&lt;R, C, V&gt; copy) {
    assertThat(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match178960-1.html#2',3,'match178960-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>copy.cellSet()).containsExactlyElementsIn(original.cellSet()).inOrder();
    assertThat(copy.rowKeySet()).containsExactlyElementsIn(original.rowKeySet()).inOrder();
    assertThat(copy.values()).containsExactlyElementsIn(original.values()).inOrder();
  }

  public void testCopyOf() {
    Table&lt;Character, Integer, String&gt; table = TreeBasedTable.create()</B></FONT>;
<A NAME="6"></A>    validateTableCopies(table);
    table.put('b', 2, &quot;foo&quot;);
    validateTableCopies(table);
    <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match178960-1.html#6',3,'match178960-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>table.put('b', 1, &quot;bar&quot;);
    table.put('a', 2, &quot;baz&quot;);
    validateTableCopies(table);
    // Even though rowKeySet, columnKeySet, and cellSet have the same
    // iteration ordering, row has an inconsistent ordering.
    assertThat(table.row('b').keySet()).containsExactly(1, 2).inOrder();
    assertThat(ImmutableTable.copyOf(table).row('b').keySet()).containsExactly(2, 1).inOrder();
  }</B></FONT>
<A NAME="7"></A>
  public void testCopyOfSparse() {
    Table&lt;Character, Integer, String&gt; table = TreeBasedTable.create();
    <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match178960-1.html#7',3,'match178960-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>table.put('x', 2, &quot;foo&quot;);
    table.put('r', 1, &quot;bar&quot;);
    table.put('c', 3, &quot;baz&quot;);
    table.put('b', 7, &quot;cat&quot;);
    table.put('e', 5, &quot;dog&quot;);
    table.put('c', 0, &quot;axe&quot;);
    table.put('e', 3, &quot;tub&quot;);
    table.put('r', 4, &quot;foo&quot;);
    table.put('x', 5, &quot;bar&quot;);
    validateTableCopies(table);
<A NAME="16"></A>  }

  public void testCopyOfDense() {</B></FONT>
    <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match178960-1.html#16',3,'match178960-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Table&lt;Character, Integer, String&gt; table = TreeBasedTable.create();
    table.put('c', 3, &quot;foo&quot;);
    table.put('c', 2, &quot;bar&quot;);
    table.put('c', 1, &quot;baz&quot;);
    table.put('b', 3, &quot;cat&quot;);
    table.put('b', 1, &quot;dog&quot;);
    table.put('a', 3, &quot;foo&quot;);
    table.put('a', 2, &quot;bar&quot;);
    table.put('a', 1, &quot;baz&quot;);
    validateTableCopies(table);
  }</B></FONT>

  public void testBuilder_orderRowsAndColumnsBy_putAll() {
<A NAME="0"></A>    Table&lt;Character, Integer, String&gt; table = HashBasedTable.create();
    table.put('b', 2, &quot;foo&quot;);
    table.put('b', 1, &quot;bar&quot;);
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match178960-1.html#0',3,'match178960-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>table.put('a', 2, &quot;baz&quot;);
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    Table&lt;Character, Integer, String&gt; copy =
        builder
            .orderRowsBy(Ordering.natural())
            .orderColumnsBy(Ordering.natural())
            .putAll(table)
<A NAME="27"></A>            .build();
    assertThat(copy.rowKeySet()).containsExactly('a', 'b').inOrder();
    assertThat(copy.columnKeySet</B></FONT>()).containsExactly(1, 2).inOrder();
    <FONT color="#e77471"><A HREF="javascript:ZweiFrames('match178960-1.html#27',3,'match178960-top.html#27',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(copy.values()).containsExactly(&quot;baz&quot;, &quot;bar&quot;, &quot;foo&quot;).inOrder();
    assertThat(copy.row('b').keySet()).containsExactly(1, 2).inOrder();
  }</B></FONT>

  public void testBuilder_orderRowsAndColumnsBy_sparse() {
<A NAME="4"></A>    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.orderColumnsBy(Ordering.natural());
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match178960-1.html#4',3,'match178960-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder.put('x', 2, &quot;foo&quot;);
    builder.put('r', 1, &quot;bar&quot;);
    builder.put('c', 3, &quot;baz&quot;);
    builder.put('b', 7, &quot;cat&quot;);
    builder.put('e', 5, &quot;dog&quot;);
    builder.put('c', 0, &quot;axe&quot;);
    builder.put('e', 3, &quot;tub&quot;);
    builder.put('r', 4, &quot;foo&quot;);
<A NAME="15"></A>    builder.put('x', 5, &quot;bar&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();
    <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match178960-1.html#15',3,'match178960-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder</B></FONT>();
    assertThat(table.values())
        .containsExactly(&quot;cat&quot;, &quot;axe&quot;, &quot;baz&quot;, &quot;tub&quot;, &quot;dog&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;)
        .inOrder();
    assertThat(table.row</B></FONT>('c').keySet()).containsExactly(0, 3).inOrder();
    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();
  }
<A NAME="10"></A>
  public void testBuilder_orderRowsAndColumnsBy_dense() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match178960-1.html#10',3,'match178960-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Ordering.natural());
    builder.orderColumnsBy(Ordering.natural());
    builder.put('c', 3, &quot;foo&quot;);
    builder.put('c', 2, &quot;bar&quot;);
    builder.put('c', 1, &quot;baz&quot;);
    builder.put('b', 3, &quot;cat&quot;);
    builder.put('b', 1, &quot;dog&quot;);
    builder.put('a', 3, &quot;foo&quot;);
    builder.put('a', 2, &quot;bar&quot;);
    builder.put('a', 1, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build</B></FONT>();
    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();
    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();
<A NAME="18"></A>    assertThat(table.values())
        .containsExactly(&quot;baz&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;dog&quot;, &quot;cat&quot;, &quot;baz&quot;, &quot;bar&quot;, &quot;foo&quot;)
        .inOrder();
    <FONT color="#800517"><A HREF="javascript:ZweiFrames('match178960-1.html#18',3,'match178960-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();
<A NAME="14"></A>    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();
  }</B></FONT>

  public void testBuilder_orderRowsBy_sparse() <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match178960-1.html#14',3,'match178960-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.put('x', 2, &quot;foo&quot;);
    builder.put('r', 1, &quot;bar&quot;);
    builder.put('c', 3, &quot;baz&quot;);
    builder.put('b', 7, &quot;cat&quot;);
    builder.put('e', 5, &quot;dog&quot;);
<A NAME="1"></A>    builder.put('c', 0, &quot;axe&quot;);
    builder.put</B></FONT>('e', 3, &quot;tub&quot;);
    builder.put('r', 4, &quot;foo&quot;);
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match178960-1.html#1',3,'match178960-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder.put('x', 5, &quot;bar&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();
    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();
  }

  public void testBuilder_orderRowsBy_dense() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder()</B></FONT>;
    builder.orderRowsBy(Ordering.natural());
    builder.put('c', 3, &quot;foo&quot;);
    builder.put('c', 2, &quot;bar&quot;);
    builder.put('c', 1, &quot;baz&quot;);
    builder.put('b', 3, &quot;cat&quot;);
<A NAME="3"></A>    builder.put('b', 1, &quot;dog&quot;);
    builder.put('a', 3, &quot;foo&quot;);
    builder.put('a', 2, &quot;bar&quot;);
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match178960-1.html#3',3,'match178960-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder.put('a', 1, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();
    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();
<A NAME="23"></A>  }

  public void testBuilder_orderColumnsBy_sparse() {</B></FONT>
    <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match178960-1.html#23',3,'match178960-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.natural());
    builder.put('x', 2, &quot;foo&quot;);
    builder.put('r', 1, &quot;bar&quot;);
    builder.put('c', 3, &quot;baz&quot;);
    builder.put('b', 7, &quot;cat&quot;);
    builder.put('e', 5, &quot;dog&quot;);
<A NAME="9"></A>    builder.put</B></FONT>('c', 0, &quot;axe&quot;);
    builder.put('e', 3, &quot;tub&quot;);
    builder.put('r', 4, &quot;foo&quot;);
    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match178960-1.html#9',3,'match178960-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder.put('x', 5, &quot;bar&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder();
<A NAME="22"></A>    assertThat(table.row('c').keySet()).containsExactly(0, 3).inOrder();
  }</B></FONT>

  public void testBuilder_orderColumnsBy_dense() <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match178960-1.html#22',3,'match178960-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.natural());
    builder.put('c', 3, &quot;foo&quot;);
    builder.put('c', 2, &quot;bar&quot;);
    builder.put('c', 1, &quot;baz&quot;);
    builder.put('b', 3, &quot;cat&quot;);
<A NAME="8"></A>    builder.put</B></FONT>('b', 1, &quot;dog&quot;);
    builder.put('a', 3, &quot;foo&quot;);
    builder.put('a', 2, &quot;bar&quot;);
    <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match178960-1.html#8',3,'match178960-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder.put('a', 1, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();
    assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();
<A NAME="13"></A>  }</B></FONT>

  public void testSerialization_empty() {
    validateReserialization(<FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match178960-1.html#13',3,'match178960-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ImmutableTable.of());
  }

  public void testSerialization_singleElement() {
    validateReserialization(ImmutableTable.of('a', 2, &quot;foo&quot;));
  }

  public void testDenseSerialization_manualOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder()</B></FONT>;
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }

  public void testDenseSerialization_rowOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.&lt;Character&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }

  public void testDenseSerialization_columnOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.&lt;Integer&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }

  public void testDenseSerialization_bothOrders() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.&lt;Character&gt;natural());
    builder.orderColumnsBy(Ordering.&lt;Integer&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }

  public void testSparseSerialization_manualOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    builder.put('c', 3, &quot;cat&quot;);
    builder.put('d', 4, &quot;dog&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }

  public void testSparseSerialization_rowOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.&lt;Character&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    builder.put('c', 3, &quot;cat&quot;);
    builder.put('d', 4, &quot;dog&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }

  public void testSparseSerialization_columnOrder() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.&lt;Integer&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    builder.put('c', 3, &quot;cat&quot;);
    builder.put('d', 4, &quot;dog&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }

  public void testSparseSerialization_bothOrders() {
    ImmutableTable.Builder&lt;Character, Integer, String&gt; builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.&lt;Character&gt;natural());
    builder.orderColumnsBy(Ordering.&lt;Integer&gt;natural());
    builder.put('b', 2, &quot;foo&quot;);
    builder.put('b', 1, &quot;bar&quot;);
    builder.put('a', 2, &quot;baz&quot;);
    builder.put('c', 3, &quot;cat&quot;);
    builder.put('d', 4, &quot;dog&quot;);
    Table&lt;Character, Integer, String&gt; table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }

  private static &lt;R, C, V&gt; void validateReserialization(Table&lt;R, C, V&gt; original) {
    Table&lt;R, C, V&gt; copy = SerializableTester.reserializeAndAssert(original);
    assertThat(copy.cellSet()).containsExactlyElementsIn(original.cellSet()).inOrder();
    assertThat(copy.rowKeySet()).containsExactlyElementsIn(original.rowKeySet()).inOrder();
    assertThat(copy.columnKeySet()).containsExactlyElementsIn(original.columnKeySet()).inOrder();
  }

  @GwtIncompatible // Mind-bogglingly slow in GWT
  @AndroidIncompatible // slow
  public void testOverflowCondition() {
    // See https://code.google.com/p/guava-libraries/issues/detail?id=1322 for details.
    ImmutableTable.Builder&lt;Integer, Integer, String&gt; builder = ImmutableTable.builder();
    for (int i = 1; i &lt; 0x10000; i++) {
      builder.put(i, 0, &quot;foo&quot;);
      builder.put(0, i, &quot;bar&quot;);
    }
    assertTrue(builder.build() instanceof SparseImmutableTable);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapInterfaceTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect.testing;

import static java.util.Collections.singleton;

<A NAME="29"></A>import com.google.common.annotations.GwtCompatible;
import java.util.Arrays;
import java.util.Collection;
<FONT color="#af7a82"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#29',2,'match178960-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import junit.framework.TestCase;

/**
 * Tests representing the contract of {@link Map}. Concrete subclasses of this base class test
 * conformance of concrete {@link Map} subclasses to that contract.
 *
 * @param &lt;K&gt; the type of keys used by the maps under test
 * @param &lt;V&gt; the type of mapped values used the maps under test
 * @author George van den Driessche
 */
// TODO: Descriptive assertion messages, with hints as to probable fixes.
// TODO: Add another constructor parameter indicating whether the class under test is ordered, and
// check the order if so.
// TODO: Refactor to share code with SetTestBuilder etc.
@</B></FONT>GwtCompatible
public abstract class MapInterfaceTest&lt;K, V&gt; extends TestCase {

  /** A key type that is not assignable to any classes but Object. */
  private static final class IncompatibleKeyType {
    @Override
    public String toString() {
      return &quot;IncompatibleKeyType&quot;;
    }
  }

  protected final boolean supportsPut;
  protected final boolean supportsRemove;
  protected final boolean supportsClear;
  protected final boolean allowsNullKeys;
  protected final boolean allowsNullValues;
  protected final boolean supportsIteratorRemove;

  /**
   * Creates a new, empty instance of the class under test.
   *
   * @return a new, empty map instance.
   * @throws UnsupportedOperationException if it's not possible to make an empty instance of the
   *     class under test.
   */
  protected abstract Map&lt;K, V&gt; makeEmptyMap() throws UnsupportedOperationException;

  /**
   * Creates a new, non-empty instance of the class under test.
   *
   * @return a new, non-empty map instance.
   * @throws UnsupportedOperationException if it's not possible to make a non-empty instance of the
   *     class under test.
   */
  protected abstract Map&lt;K, V&gt; makePopulatedMap() throws UnsupportedOperationException;

  /**
   * Creates a new key that is not expected to be found in {@link #makePopulatedMap()}.
   *
   * @return a key.
   * @throws UnsupportedOperationException if it's not possible to make a key that will not be found
   *     in the map.
   */
  protected abstract K getKeyNotInPopulatedMap() throws UnsupportedOperationException;

  /**
   * Creates a new value that is not expected to be found in {@link #makePopulatedMap()}.
   *
   * @return a value.
   * @throws UnsupportedOperationException if it's not possible to make a value that will not be
   *     found in the map.
   */
  protected abstract V getValueNotInPopulatedMap() throws UnsupportedOperationException;

  /**
   * Constructor that assigns {@code supportsIteratorRemove} the same value as {@code
   * supportsRemove}.
   */
  protected MapInterfaceTest(
      boolean allowsNullKeys,
      boolean allowsNullValues,
      boolean supportsPut,
      boolean supportsRemove,
      boolean supportsClear) {
    this(
        allowsNullKeys,
        allowsNullValues,
        supportsPut,
        supportsRemove,
        supportsClear,
        supportsRemove);
  }

  /** Constructor with an explicit {@code supportsIteratorRemove} parameter. */
  protected MapInterfaceTest(
      boolean allowsNullKeys,
      boolean allowsNullValues,
      boolean supportsPut,
      boolean supportsRemove,
      boolean supportsClear,
      boolean supportsIteratorRemove) {
    this.supportsPut = supportsPut;
    this.supportsRemove = supportsRemove;
    this.supportsClear = supportsClear;
    this.allowsNullKeys = allowsNullKeys;
    this.allowsNullValues = allowsNullValues;
    this.supportsIteratorRemove = supportsIteratorRemove;
  }

  /**
   * Used by tests that require a map, but don't care whether it's populated or not.
   *
   * @return a new map instance.
   */
  protected Map&lt;K, V&gt; makeEitherMap() {
    try {
      return makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return makeEmptyMap();
    }
  }

  protected final boolean supportsValuesHashCode(Map&lt;K, V&gt; map) {
    // get the first non-null value
    Collection&lt;V&gt; values = map.values();
    for (V value : values) {
      if (value != null) {
        try {
          int unused = value.hashCode();
        } catch (Exception e) {
          return false;
        }
        return true;
      }
    }
    return true;
  }

  /**
   * Checks all the properties that should always hold of a map. Also calls {@link
   * #assertMoreInvariants} to check invariants that are peculiar to specific implementations.
   *
   * @see #assertMoreInvariants
<A NAME="0"></A>   * @param map the map to check.
   */
  protected final void assertInvariants(Map&lt;K, V&gt; map) {
    Set&lt;K&gt; keySet = <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#0',2,'match178960-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.keySet();
    Collection&lt;V&gt; valueCollection = map.values();
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();

    assertEquals(map.size() == 0, map.isEmpty());
    assertEquals(map.size(), keySet.size());
    assertEquals(keySet.size() == 0, keySet.isEmpty());
    assertEquals(!keySet.isEmpty(), keySet.iterator</B></FONT>().hasNext());

<A NAME="6"></A>    int expectedKeySetHash = 0;
    for (K key : keySet) {
      V value = map.get(key);
      expectedKeySetHash += key != null ? <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#6',2,'match178960-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>key.hashCode() : 0;
      assertTrue(map.containsKey(key));
      assertTrue(map.containsValue(value));
      assertTrue(valueCollection.contains(value));
      assertTrue(valueCollection.containsAll(Collections.singleton(value)));
<A NAME="15"></A>      assertTrue(entrySet.contains(mapEntry(key, value)));
      assertTrue(allowsNullKeys || (key != null));
    }</B></FONT>
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#15',2,'match178960-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(expectedKeySetHash, keySet.hashCode());

    assertEquals(map.size(), valueCollection.size());
    assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());
    assertEquals(!valueCollection.isEmpty(), valueCollection.iterator</B></FONT>().hasNext());
    for (V value : valueCollection) {
      assertTrue(map.containsValue(value));
<A NAME="10"></A>      assertTrue(allowsNullValues || (value != null));
    }

    <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#10',2,'match178960-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(map.size(), entrySet.size());
    assertEquals(entrySet.size() == 0, entrySet.isEmpty());
    assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());
    assertEntrySetNotContainsString(entrySet);

    boolean supportsValuesHashCode = supportsValuesHashCode</B></FONT>(map);
    if (supportsValuesHashCode) {
      int expectedEntrySetHash = 0;
      for (Entry&lt;K, V&gt; entry : entrySet) {
        assertTrue(map.containsKey(entry.getKey()));
        assertTrue(map.containsValue(entry.getValue()));
        int expectedHash =
            (entry.getKey() == null ? 0 : entry.getKey().hashCode())
                ^ (entry.getValue() == null ? 0 : entry.getValue().hashCode());
        assertEquals(expectedHash, entry.hashCode());
        expectedEntrySetHash += expectedHash;
      }
      assertEquals(expectedEntrySetHash, entrySet.hashCode());
      assertTrue(entrySet.containsAll(new HashSet&lt;Entry&lt;K, V&gt;&gt;(entrySet)));
      assertTrue(entrySet.equals(new HashSet&lt;Entry&lt;K, V&gt;&gt;(entrySet)));
    }

    Object[] entrySetToArray1 = entrySet.toArray();
    assertEquals(map.size(), entrySetToArray1.length);
<A NAME="4"></A>    assertTrue(Arrays.asList(entrySetToArray1).containsAll(entrySet));

    Entry&lt;?, ?&gt;[] entrySetToArray2 = new Entry&lt;?, ?&gt;[map.size() + 2];
    entrySetToArray2[<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#4',2,'match178960-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.size()] = mapEntry(&quot;foo&quot;, 1);
    assertSame(entrySetToArray2, entrySet.toArray(entrySetToArray2));
    assertNull(entrySetToArray2[map.size()]);
    assertTrue(Arrays.asList(entrySetToArray2).containsAll(entrySet));

    Object[] valuesToArray1 = valueCollection.toArray();
    assertEquals(map.size(), valuesToArray1.length);
    assertTrue(Arrays.asList</B></FONT>(valuesToArray1).containsAll(valueCollection));

    Object[] valuesToArray2 = new Object[map.size() + 2];
    valuesToArray2[map.size()] = &quot;foo&quot;;
    assertSame(valuesToArray2, valueCollection.toArray(valuesToArray2));
    assertNull(valuesToArray2[map.size()]);
    assertTrue(Arrays.asList(valuesToArray2).containsAll(valueCollection));

    if (supportsValuesHashCode) {
      int expectedHash = 0;
      for (Entry&lt;K, V&gt; entry : entrySet) {
        expectedHash += entry.hashCode();
      }
      assertEquals(expectedHash, map.hashCode());
    }

    assertMoreInvariants(map);
  }

  @SuppressWarnings(&quot;CollectionIncompatibleType&quot;)
  private void assertEntrySetNotContainsString(Set&lt;Entry&lt;K, V&gt;&gt; entrySet) {
    // Very unlikely that a buggy collection would ever return true. It might accidentally throw.
    assertFalse(entrySet.contains(&quot;foo&quot;));
  }

  /**
   * Override this to check invariants which should hold true for a particular implementation, but
   * which are not generally applicable to every instance of Map.
   *
   * @param map the map whose additional invariants to check.
   */
  protected void assertMoreInvariants(Map&lt;K, V&gt; map) {}

  public void testClear() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    if (supportsClear) {
<A NAME="19"></A>      map.clear();
      assertTrue(map.isEmpty());
    } else {
      <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#19',2,'match178960-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
        map.clear();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }</B></FONT>
    assertInvariants(map);
  }

  public void testContainsKey() {
    Map&lt;K, V&gt; map;
    K unmappedKey;
    try {
      map = makePopulatedMap();
      unmappedKey = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertFalse(map.containsKey(unmappedKey));
    try {
      assertFalse(map.containsKey(new IncompatibleKeyType()));
    } catch (ClassCastException tolerated) {
    }
    assertTrue(map.containsKey(map.keySet().iterator().next()));
    if (allowsNullKeys) {
      boolean unused = map.containsKey(null);
    } else {
      try {
        boolean unused2 = map.containsKey(null);
      } catch (NullPointerException optional) {
      }
    }
    assertInvariants(map);
  }

  public void testContainsValue() {
    Map&lt;K, V&gt; map;
    V unmappedValue;
    try {
      map = makePopulatedMap();
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertFalse(map.containsValue(unmappedValue));
    assertTrue(map.containsValue(map.values().iterator().next()));
    if (allowsNullValues) {
      boolean unused = map.containsValue(null);
    } else {
      try {
        boolean unused2 = map.containsKey(null);
      } catch (NullPointerException optional) {
      }
    }
    assertInvariants(map);
  }

  public void testEntrySet() {
    Map&lt;K, V&gt; map;
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    entrySet = map.entrySet();
    K unmappedKey;
    V unmappedValue;
    try {
      unmappedKey = getKeyNotInPopulatedMap();
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    for (Entry&lt;K, V&gt; entry : entrySet) {
      assertFalse(unmappedKey.equals(entry.getKey()));
      assertFalse(unmappedValue.equals(entry.getValue()));
    }
  }

  public void testEntrySetForEmptyMap() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);
  }

  public void testEntrySetContainsEntryIncompatibleKey() {
    Map&lt;K, V&gt; map;
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    entrySet = map.entrySet();
    V unmappedValue;
    try {
      unmappedValue = getValueNotInPopulatedMap();
<A NAME="5"></A>    } catch (UnsupportedOperationException e) {
      return;
    }
    Entry&lt;IncompatibleKeyType, V&gt; entry = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#5',2,'match178960-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>mapEntry(new IncompatibleKeyType(), unmappedValue);
    try {
      assertFalse(entrySet.contains(entry));
    } catch (ClassCastException tolerated) {
    }
  }

  public void testEntrySetContainsEntryNullKeyPresent() {</B></FONT>
    if (!allowsNullKeys || !supportsPut) {
      return;
    }
    Map&lt;K, V&gt; map;
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    entrySet = map.entrySet();
    V unmappedValue;
    try {
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
<A NAME="11"></A>      return;
    }

    <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#11',2,'match178960-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.put(null, unmappedValue);
    Entry&lt;K, V&gt; entry = mapEntry(null, unmappedValue);
    assertTrue(entrySet.contains(entry));
    assertFalse(entrySet.contains(mapEntry(null, null)));
  }

  public void testEntrySetContainsEntryNullKeyMissing() {
    Map&lt;K, V&gt; map</B></FONT>;
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    entrySet = map.entrySet();
    V unmappedValue;
    try {
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    Entry&lt;K, V&gt; entry = mapEntry(null, unmappedValue);
    try {
      assertFalse(entrySet.contains(entry));
    } catch (NullPointerException e) {
      assertFalse(allowsNullKeys);
    }
    try {
      assertFalse(entrySet.contains(mapEntry(null, null)));
    } catch (NullPointerException e) {
      assertFalse(allowsNullKeys &amp;&amp; allowsNullValues);
    }
  }

  public void testEntrySetIteratorRemove() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Iterator&lt;Entry&lt;K, V&gt;&gt; iterator = entrySet.iterator();
<A NAME="23"></A>    if (supportsIteratorRemove) {
      int initialSize = map.size();
      Entry&lt;K, V&gt; entry = iterator.next();
      <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#23',2,'match178960-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Entry&lt;K, V&gt; entryCopy = Helpers.mapEntry(entry.getKey(), entry.getValue());

      iterator.remove();
      assertEquals(initialSize - 1, map.size());

      // Use &quot;entryCopy&quot; instead of &quot;entry&quot; because &quot;entry&quot; might be invalidated after
<A NAME="25"></A>      // iterator.remove().
      assertFalse(entrySet.contains(entryCopy));
      assertInvariants</B></FONT>(map);
      <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#25',2,'match178960-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
        iterator.remove();
        fail(&quot;Expected IllegalStateException.&quot;);
<A NAME="17"></A>      } catch (IllegalStateException expected) {
      }</B></FONT>
    } else {
      <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#17',2,'match178960-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
        iterator.next();
        iterator.remove();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }</B></FONT>
    assertInvariants(map);
  }

  public void testEntrySetRemove() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    if (supportsRemove) {
      int initialSize = map.size();
      boolean didRemove = entrySet.remove(entrySet.iterator().next());
      assertTrue(didRemove);
      assertEquals(initialSize - 1, map.size());
    } else {
      try {
        entrySet.remove(entrySet.iterator().next());
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testEntrySetRemoveMissingKey() {
    Map&lt;K, V&gt; map;
    K key;
    try {
      map = makeEitherMap();
      key = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Entry&lt;K, V&gt; entry = mapEntry(key, getValueNotInPopulatedMap());
    int initialSize = map.size();
    if (supportsRemove) {
      boolean didRemove = entrySet.remove(entry);
      assertFalse(didRemove);
    } else {
      try {
        boolean didRemove = entrySet.remove(entry);
        assertFalse(didRemove);
<A NAME="26"></A>      } catch (UnsupportedOperationException optional) {
      }
    }
    <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#26',2,'match178960-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(initialSize, map.size());
    assertFalse(map.containsKey(key));
    assertInvariants(map);
  }

  public void testEntrySetRemoveDifferentValue() {
    Map&lt;K, V&gt; map</B></FONT>;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    K key = map.keySet().iterator().next();
    Entry&lt;K, V&gt; entry = mapEntry(key, getValueNotInPopulatedMap());
    int initialSize = map.size();
    if (supportsRemove) {
      boolean didRemove = entrySet.remove(entry);
      assertFalse(didRemove);
    } else {
      try {
        boolean didRemove = entrySet.remove(entry);
        assertFalse(didRemove);
<A NAME="28"></A>      } catch (UnsupportedOperationException optional) {
      }
    }
    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#28',2,'match178960-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(initialSize, map.size());
    assertTrue(map.containsKey(key));
    assertInvariants(map);
  }

  public void testEntrySetRemoveNullKeyPresent() {</B></FONT>
    if (!allowsNullKeys || !supportsPut || !supportsRemove) {
      return;
    }
    Map&lt;K, V&gt; map;
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    entrySet = map.entrySet();
    V unmappedValue;
    try {
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

<A NAME="12"></A>    map.put(null, unmappedValue);
    assertEquals(unmappedValue, map.get(null));
    assertTrue(map.containsKey(null));
    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#12',2,'match178960-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Entry&lt;K, V&gt; entry = mapEntry(null, unmappedValue);
    assertTrue(entrySet.remove(entry));
    assertNull(map.get(null));
    assertFalse(map.containsKey(null));
  }

  public void testEntrySetRemoveNullKeyMissing() {
    Map&lt;K, V&gt; map</B></FONT>;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Entry&lt;K, V&gt; entry = mapEntry(null, getValueNotInPopulatedMap());
    int initialSize = map.size();
    if (supportsRemove) {
      try {
        boolean didRemove = entrySet.remove(entry);
        assertFalse(didRemove);
      } catch (NullPointerException e) {
        assertFalse(allowsNullKeys);
      }
    } else {
      try {
        boolean didRemove = entrySet.remove(entry);
        assertFalse(didRemove);
      } catch (UnsupportedOperationException optional) {
      }
    }
    assertEquals(initialSize, map.size());
    assertInvariants(map);
  }

  public void testEntrySetRemoveAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();

    Entry&lt;K, V&gt; entryToRemove = entrySet.iterator().next();
    Set&lt;Entry&lt;K, V&gt;&gt; entriesToRemove = singleton(entryToRemove);
    if (supportsRemove) {
      // We use a copy of &quot;entryToRemove&quot; in the assertion because &quot;entryToRemove&quot; might be
      // invalidated and have undefined behavior after entrySet.removeAll(entriesToRemove),
      // for example entryToRemove.getValue() might be null.
      Entry&lt;K, V&gt; entryToRemoveCopy =
          Helpers.mapEntry(entryToRemove.getKey(), entryToRemove.getValue());

      int initialSize = map.size();
      boolean didRemove = entrySet.removeAll(entriesToRemove);
      assertTrue(didRemove);
      assertEquals(initialSize - entriesToRemove.size(), map.size());

      // Use &quot;entryToRemoveCopy&quot; instead of &quot;entryToRemove&quot; because it might be invalidated and
<A NAME="24"></A>      // have undefined behavior after entrySet.removeAll(entriesToRemove),
      assertFalse(entrySet.contains(entryToRemoveCopy));
    } else {
      <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#24',2,'match178960-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
        entrySet.removeAll(entriesToRemove);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }</B></FONT>
    }
    assertInvariants(map);
  }

  public void testEntrySetRemoveAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    if (supportsRemove) {
      try {
        entrySet.removeAll(null);
        fail(&quot;Expected NullPointerException.&quot;);
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        entrySet.removeAll(null);
        fail(&quot;Expected UnsupportedOperationException or NullPointerException.&quot;);
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testEntrySetRetainAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Set&lt;Entry&lt;K, V&gt;&gt; entriesToRetain = singleton(entrySet.iterator().next());
    if (supportsRemove) {
      boolean shouldRemove = (entrySet.size() &gt; entriesToRetain.size());
      boolean didRemove = entrySet.retainAll(entriesToRetain);
      assertEquals(shouldRemove, didRemove);
      assertEquals(entriesToRetain.size(), map.size());
      for (Entry&lt;K, V&gt; entry : entriesToRetain) {
        assertTrue(entrySet.contains(entry));
      }
    } else {
      try {
        entrySet.retainAll(entriesToRetain);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testEntrySetRetainAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    if (supportsRemove) {
      try {
        entrySet.retainAll(null);
        // Returning successfully is not ideal, but tolerated.
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        entrySet.retainAll(null);
        // We have to tolerate a successful return (Sun bug 4802647)
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testEntrySetClear() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    if (supportsClear) {
      entrySet.clear();
      assertTrue(entrySet.isEmpty());
    } else {
      try {
        entrySet.clear();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testEntrySetAddAndAddAll() {
    Map&lt;K, V&gt; map = makeEitherMap();

    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Entry&lt;K, V&gt; entryToAdd = mapEntry(null, null);
    try {
      entrySet.add(entryToAdd);
      fail(&quot;Expected UnsupportedOperationException or NullPointerException.&quot;);
    } catch (UnsupportedOperationException | NullPointerException e) {
      // Expected.
<A NAME="21"></A>    }
    assertInvariants(map);

    <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#21',2,'match178960-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      entrySet.addAll(singleton(entryToAdd));
      fail(&quot;Expected UnsupportedOperationException or NullPointerException.&quot;);
    } catch (UnsupportedOperationException | NullPointerException e) {
      // Expected.
    }</B></FONT>
    assertInvariants(map);
  }

  public void testEntrySetSetValue() {
    // TODO: Investigate the extent to which, in practice, maps that support
    // put() also support Entry.setValue().
    if (!supportsPut) {
      return;
    }

    Map&lt;K, V&gt; map;
    V valueToSet;
    try {
      map = makePopulatedMap();
      valueToSet = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
<A NAME="3"></A>
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Entry&lt;K, V&gt; entry = entrySet.iterator().next();
    V oldValue = <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#3',2,'match178960-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>entry.getValue();
    V returnedValue = entry.setValue(valueToSet);
    assertEquals(oldValue, returnedValue);
    assertTrue(entrySet.contains(mapEntry(entry.getKey(), valueToSet)));
    assertEquals(valueToSet, map.get(entry.getKey()));
    assertInvariants(map);
  }

  public void testEntrySetSetValueSameValue() {</B></FONT>
    // TODO: Investigate the extent to which, in practice, maps that support
    // put() also support Entry.setValue().
    if (!supportsPut) {
      return;
    }

    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
<A NAME="1"></A>
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet = map.entrySet();
    Entry&lt;K, V&gt; entry = entrySet.iterator().next();
    V oldValue = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#1',2,'match178960-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>entry.getValue();
    V returnedValue = entry.setValue(oldValue);
    assertEquals(oldValue, returnedValue);
    assertTrue(entrySet.contains(mapEntry(entry.getKey(), oldValue)));
    assertEquals(oldValue, map.get(entry.getKey()));
    assertInvariants(map);
  }

  public void testEqualsForEqualMap() {
    Map&lt;K, V&gt; map</B></FONT>;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
<A NAME="7"></A>    }

    // Explicitly call `equals`; `assertEquals` might return fast
    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#7',2,'match178960-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertTrue(map.equals(map));
    assertTrue(makePopulatedMap().equals(map));
    assertFalse(map.equals(Collections.emptyMap()));
    // no-inspection ObjectEqualsNull
    assertFalse(map.equals(null));
  }

  public void testEqualsForLargerMap() {</B></FONT>
    if (!supportsPut) {
      return;
    }

    Map&lt;K, V&gt; map;
    Map&lt;K, V&gt; largerMap;
    try {
      map = makePopulatedMap();
      largerMap = makePopulatedMap();
      largerMap.put(getKeyNotInPopulatedMap(), getValueNotInPopulatedMap());
    } catch (UnsupportedOperationException e) {
      return;
    }

    assertFalse(map.equals(largerMap));
  }

  public void testEqualsForSmallerMap() {
    if (!supportsRemove) {
      return;
    }

    Map&lt;K, V&gt; map;
    Map&lt;K, V&gt; smallerMap;
    try {
      map = makePopulatedMap();
      smallerMap = makePopulatedMap();
      smallerMap.remove(smallerMap.keySet().iterator().next());
    } catch (UnsupportedOperationException e) {
      return;
    }

    assertFalse(map.equals(smallerMap));
  }

  public void testEqualsForEmptyMap() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
<A NAME="2"></A>    }

    // Explicitly call `equals`; `assertEquals` might return fast
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#2',2,'match178960-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertTrue(map.equals(map));
    assertTrue(makeEmptyMap().equals(map));
    assertEquals(Collections.emptyMap(), map);
    assertFalse(map.equals(Collections.emptySet()));
    // noinspection ObjectEqualsNull
    assertFalse(map.equals(null));
  }

  public void testGet() {
    Map&lt;K, V&gt; map</B></FONT>;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    for (Entry&lt;K, V&gt; entry : map.entrySet()) {
      assertEquals(entry.getValue(), map.get(entry.getKey()));
    }

    K unmappedKey = null;
    try {
      unmappedKey = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertNull(map.get(unmappedKey));
  }

  public void testGetForEmptyMap() {
    Map&lt;K, V&gt; map;
    K unmappedKey = null;
    try {
      map = makeEmptyMap();
      unmappedKey = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertNull(map.get(unmappedKey));
  }

  public void testGetNull() {
    Map&lt;K, V&gt; map = makeEitherMap();
    if (allowsNullKeys) {
      if (allowsNullValues) {
        // TODO: decide what to test here.
      } else {
        assertEquals(map.containsKey(null), map.get(null) != null);
      }
    } else {
      try {
        map.get(null);
      } catch (NullPointerException optional) {
      }
    }
    assertInvariants(map);
  }

  public void testHashCode() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);
  }

  public void testHashCodeForEmptyMap() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);
  }

  public void testPutNewKey() {
    Map&lt;K, V&gt; map = makeEitherMap();
    K keyToPut;
    V valueToPut;
    try {
      keyToPut = getKeyNotInPopulatedMap();
      valueToPut = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
<A NAME="9"></A>      return;
    }
    if (supportsPut) {
      int initialSize = <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#9',2,'match178960-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.size();
      V oldValue = map.put(keyToPut, valueToPut);
      assertEquals(valueToPut, map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(valueToPut));
      assertEquals(initialSize + 1, map.size());
      assertNull(oldValue);
    }</B></FONT> else {
      try {
        map.put(keyToPut, valueToPut);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutExistingKey() {
    Map&lt;K, V&gt; map;
    K keyToPut;
    V valueToPut;
    try {
      map = makePopulatedMap();
      valueToPut = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
<A NAME="16"></A>    }
    keyToPut = map.keySet().iterator().next();
    if (supportsPut) {
      <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#16',2,'match178960-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int initialSize = map.size();
      map.put(keyToPut, valueToPut);
      assertEquals(valueToPut, map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(valueToPut));
      assertEquals(initialSize, map.size());
    }</B></FONT> else {
      try {
        map.put(keyToPut, valueToPut);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutNullKey() {
    if (!supportsPut) {
      return;
    }
    Map&lt;K, V&gt; map = makeEitherMap();
    V valueToPut;
    try {
      valueToPut = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
<A NAME="27"></A>    }
    if (allowsNullKeys) {
      V oldValue = map.get(null);
      V returnedValue = <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#27',2,'match178960-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.put(null, valueToPut);
      assertEquals(oldValue, returnedValue);
      assertEquals(valueToPut, map.get(null));
      assertTrue(map.containsKey(null));
      assertTrue(map.containsValue(valueToPut));
    }</B></FONT> else {
      try {
        map.put(null, valueToPut);
        fail(&quot;Expected RuntimeException&quot;);
      } catch (RuntimeException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutNullValue() {
    if (!supportsPut) {
      return;
    }
    Map&lt;K, V&gt; map = makeEitherMap();
    K keyToPut;
    try {
      keyToPut = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
<A NAME="8"></A>    }
    if (allowsNullValues) {
      int initialSize = map.size();
      V oldValue = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#8',2,'match178960-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.get(keyToPut);
      V returnedValue = map.put(keyToPut, null);
      assertEquals(oldValue, returnedValue);
      assertNull(map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(null));
      assertEquals(initialSize + 1, map.size());
    }</B></FONT> else {
      try {
        map.put(keyToPut, null);
        fail(&quot;Expected RuntimeException&quot;);
      } catch (RuntimeException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutNullValueForExistingKey() {
    if (!supportsPut) {
      return;
    }
    Map&lt;K, V&gt; map;
    K keyToPut;
    try {
      map = makePopulatedMap();
      keyToPut = map.keySet().iterator().next();
    } catch (UnsupportedOperationException e) {
      return;
    }
<A NAME="18"></A>    if (allowsNullValues) {
      int initialSize = map.size();
      V oldValue = map.get(keyToPut);
      V returnedValue = <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#18',2,'match178960-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.put(keyToPut, null);
      assertEquals(oldValue, returnedValue);
      assertNull(map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(null));
      assertEquals(initialSize, map.size());
    }</B></FONT> else {
      try {
        map.put(keyToPut, null);
        fail(&quot;Expected RuntimeException&quot;);
      } catch (RuntimeException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutAllNewKey() {
    Map&lt;K, V&gt; map = makeEitherMap();
    K keyToPut;
    V valueToPut;
    try {
      keyToPut = getKeyNotInPopulatedMap();
      valueToPut = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
<A NAME="14"></A>      return;
    }
    Map&lt;K, V&gt; mapToPut = Collections.singletonMap(keyToPut, valueToPut);
    if (supportsPut) <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#14',2,'match178960-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
      int initialSize = map.size();
      map.putAll(mapToPut);
      assertEquals(valueToPut, map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(valueToPut));
      assertEquals(initialSize + 1, map.size</B></FONT>());
    } else {
      try {
        map.putAll(mapToPut);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testPutAllExistingKey() {
    Map&lt;K, V&gt; map;
    K keyToPut;
    V valueToPut;
    try {
      map = makePopulatedMap();
      valueToPut = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    keyToPut = map.keySet().iterator().next();
    Map&lt;K, V&gt; mapToPut = Collections.singletonMap(keyToPut, valueToPut);
    int initialSize = map.size();
    if (supportsPut) {
      map.putAll(mapToPut);
      assertEquals(valueToPut, map.get(keyToPut));
      assertTrue(map.containsKey(keyToPut));
      assertTrue(map.containsValue(valueToPut));
    } else {
      try {
        map.putAll(mapToPut);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertEquals(initialSize, map.size());
    assertInvariants(map);
  }

  public void testRemove() {
    Map&lt;K, V&gt; map;
    K keyToRemove;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    keyToRemove = map.keySet().iterator().next();
    if (supportsRemove) {
      int initialSize = map.size();
      V expectedValue = map.get(keyToRemove);
      V oldValue = map.remove(keyToRemove);
      assertEquals(expectedValue, oldValue);
      assertFalse(map.containsKey(keyToRemove));
      assertEquals(initialSize - 1, map.size());
    } else {
      try {
        map.remove(keyToRemove);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testRemoveMissingKey() {
    Map&lt;K, V&gt; map;
    K keyToRemove;
    try {
      map = makePopulatedMap();
      keyToRemove = getKeyNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    if (supportsRemove) {
      int initialSize = map.size();
      assertNull(map.remove(keyToRemove));
      assertEquals(initialSize, map.size());
    } else {
      try {
        map.remove(keyToRemove);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
<A NAME="13"></A>      } catch (UnsupportedOperationException expected) {
      }
    }
    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#13',2,'match178960-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertInvariants(map);
  }

  public void testSize() {
    assertInvariants(makeEitherMap());
  }

  public void testKeySetRemove() {
    Map&lt;K, V&gt; map</B></FONT>;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;K&gt; keys = map.keySet();
    K key = keys.iterator().next();
    if (supportsRemove) {
      int initialSize = map.size();
      keys.remove(key);
      assertEquals(initialSize - 1, map.size());
      assertFalse(map.containsKey(key));
    } else {
      try {
        keys.remove(key);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testKeySetRemoveAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
<A NAME="22"></A>
    Set&lt;K&gt; keys = map.keySet();
    K key = keys.iterator().next();
    if (supportsRemove) <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#22',2,'match178960-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
      int initialSize = map.size();
      assertTrue(keys.removeAll(Collections.singleton(key)));
<A NAME="20"></A>      assertEquals(initialSize - 1, map.size());
      assertFalse(map.containsKey</B></FONT>(key));
    } else {
      <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178960-0.html#20',2,'match178960-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
        keys.removeAll(Collections.singleton(key));
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }</B></FONT>
    }
    assertInvariants(map);
  }

  public void testKeySetRetainAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;K&gt; keys = map.keySet();
    K key = keys.iterator().next();
    if (supportsRemove) {
      keys.retainAll(Collections.singleton(key));
      assertEquals(1, map.size());
      assertTrue(map.containsKey(key));
    } else {
      try {
        keys.retainAll(Collections.singleton(key));
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testKeySetClear() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEitherMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;K&gt; keySet = map.keySet();
    if (supportsClear) {
      keySet.clear();
      assertTrue(keySet.isEmpty());
    } else {
      try {
        keySet.clear();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testKeySetRemoveAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;K&gt; keySet = map.keySet();
    if (supportsRemove) {
      try {
        keySet.removeAll(null);
        fail(&quot;Expected NullPointerException.&quot;);
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        keySet.removeAll(null);
        fail(&quot;Expected UnsupportedOperationException or NullPointerException.&quot;);
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testKeySetRetainAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Set&lt;K&gt; keySet = map.keySet();
    if (supportsRemove) {
      try {
        keySet.retainAll(null);
        // Returning successfully is not ideal, but tolerated.
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        keySet.retainAll(null);
        // We have to tolerate a successful return (Sun bug 4802647)
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testValues() {
    Map&lt;K, V&gt; map;
    Collection&lt;V&gt; valueCollection;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    assertInvariants(map);

    valueCollection = map.values();
    V unmappedValue;
    try {
      unmappedValue = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }
    for (V value : valueCollection) {
      assertFalse(unmappedValue.equals(value));
    }
  }

  public void testValuesIteratorRemove() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    Iterator&lt;V&gt; iterator = valueCollection.iterator();
    if (supportsIteratorRemove) {
      int initialSize = map.size();
      iterator.next();
      iterator.remove();
      assertEquals(initialSize - 1, map.size());
      // (We can't assert that the values collection no longer contains the
      // removed value, because the underlying map can have multiple mappings
      // to the same value.)
      assertInvariants(map);
      try {
        iterator.remove();
        fail(&quot;Expected IllegalStateException.&quot;);
      } catch (IllegalStateException expected) {
      }
    } else {
      try {
        iterator.next();
        iterator.remove();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testValuesRemove() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    if (supportsRemove) {
      int initialSize = map.size();
      valueCollection.remove(valueCollection.iterator().next());
      assertEquals(initialSize - 1, map.size());
      // (We can't assert that the values collection no longer contains the
      // removed value, because the underlying map can have multiple mappings
      // to the same value.)
    } else {
      try {
        valueCollection.remove(valueCollection.iterator().next());
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testValuesRemoveMissing() {
    Map&lt;K, V&gt; map;
    V valueToRemove;
    try {
      map = makeEitherMap();
      valueToRemove = getValueNotInPopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    int initialSize = map.size();
    if (supportsRemove) {
      assertFalse(valueCollection.remove(valueToRemove));
    } else {
      try {
        assertFalse(valueCollection.remove(valueToRemove));
      } catch (UnsupportedOperationException e) {
        // Tolerated.
      }
    }
    assertEquals(initialSize, map.size());
    assertInvariants(map);
  }

  public void testValuesRemoveAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    Set&lt;V&gt; valuesToRemove = singleton(valueCollection.iterator().next());
    if (supportsRemove) {
      valueCollection.removeAll(valuesToRemove);
      for (V value : valuesToRemove) {
        assertFalse(valueCollection.contains(value));
      }
      for (V value : valueCollection) {
        assertFalse(valuesToRemove.contains(value));
      }
    } else {
      try {
        valueCollection.removeAll(valuesToRemove);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testValuesRemoveAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; values = map.values();
    if (supportsRemove) {
      try {
        values.removeAll(null);
        // Returning successfully is not ideal, but tolerated.
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        values.removeAll(null);
        // We have to tolerate a successful return (Sun bug 4802647)
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testValuesRetainAll() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    Set&lt;V&gt; valuesToRetain = singleton(valueCollection.iterator().next());
    if (supportsRemove) {
      valueCollection.retainAll(valuesToRetain);
      for (V value : valuesToRetain) {
        assertTrue(valueCollection.contains(value));
      }
      for (V value : valueCollection) {
        assertTrue(valuesToRetain.contains(value));
      }
    } else {
      try {
        valueCollection.retainAll(valuesToRetain);
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  public void testValuesRetainAllNullFromEmpty() {
    Map&lt;K, V&gt; map;
    try {
      map = makeEmptyMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; values = map.values();
    if (supportsRemove) {
      try {
        values.retainAll(null);
        // Returning successfully is not ideal, but tolerated.
      } catch (NullPointerException expected) {
      }
    } else {
      try {
        values.retainAll(null);
        // We have to tolerate a successful return (Sun bug 4802647)
      } catch (UnsupportedOperationException | NullPointerException e) {
        // Expected.
      }
    }
    assertInvariants(map);
  }

  public void testValuesClear() {
    Map&lt;K, V&gt; map;
    try {
      map = makePopulatedMap();
    } catch (UnsupportedOperationException e) {
      return;
    }

    Collection&lt;V&gt; valueCollection = map.values();
    if (supportsClear) {
      valueCollection.clear();
      assertTrue(valueCollection.isEmpty());
    } else {
      try {
        valueCollection.clear();
        fail(&quot;Expected UnsupportedOperationException.&quot;);
      } catch (UnsupportedOperationException expected) {
      }
    }
    assertInvariants(map);
  }

  static &lt;K, V&gt; Entry&lt;K, V&gt; mapEntry(K key, V value) {
    return Collections.singletonMap(key, value).entrySet().iterator().next();
  }
}
</PRE>
</div>
  </div>
</body>
</html>
