
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager.dataholder.worlds;
2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.IOException;
5  import java.io.InputStream;
6  import java.util.ArrayList;
7  import java.util.HashMap;
8  import java.util.HashSet;
9  import java.util.List;
10  import java.util.Map;
11  import java.util.Properties;
12  import java.util.logging.Level;
13  import java.util.logging.Logger;
14  import org.anjocaido.groupmanager.GroupManager;
15  import org.anjocaido.groupmanager.dataholder.WorldDataHolder;
16  import org.anjocaido.groupmanager.dataholder.OverloadedWorldHolder;
17  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.bukkit.World;
20  import org.bukkit.entity.Player;
21  public class WorldsHolder {
22  	private Map&lt;String, OverloadedWorldHolder&gt; worldsData = new HashMap&lt;String, OverloadedWorldHolder&gt;();
23  	private Map&lt;String, String&gt; mirrorsGroup = new HashMap&lt;String, String&gt;();
24  	private Map&lt;String, String&gt; mirrorsUser = new HashMap&lt;String, String&gt;();
25  	private String serverDefaultWorldName;
26  	private GroupManager plugin;
27  	private File worldsFolder;
28  	public WorldsHolder(GroupManager plugin) {
29  		this.plugin = plugin;
30  		resetWorldsHolder();
31  	}
32  	public Map&lt;String, String&gt; getMirrorsGroup() {
33  		return mirrorsGroup;
34  	}
35  	public Map&lt;String, String&gt; getMirrorsUser() {
36  		return mirrorsUser;
37  	}
38  	public boolean isWorldKnown(String name) {
39  		return worldsData.containsKey(name.toLowerCase());
40  	}
41  	public void resetWorldsHolder() {
42  		worldsData = new HashMap&lt;String, OverloadedWorldHolder&gt;();
43  		mirrorsGroup = new HashMap&lt;String, String&gt;();
44  		mirrorsUser = new HashMap&lt;String, String&gt;();
45  		verifyFirstRun();
46  		initialLoad();
47  		if (serverDefaultWorldName == null)
48  			throw new IllegalStateException(&quot;There is no default group! OMG!&quot;);
49  	}
50  	private void initialLoad() {
51  		initialWorldLoading();
52  		mirrorSetUp();
53  		loadAllSearchedWorlds();
54  	}
55  	private void initialWorldLoading() {
56  		loadWorld(serverDefaultWorldName);
57  	}
58  	private void loadAllSearchedWorlds() {
59  		for (World world : plugin.getServer().getWorlds()) {
60  			GroupManager.logger.log(Level.FINE, &quot;Checking data for &quot; + world.getName() + &quot;.&quot;);
61  			if ((!worldsData.containsKey(world.getName().toLowerCase())) &amp;&amp; ((!mirrorsGroup.containsKey(world.getName().toLowerCase())) || (!mirrorsUser.containsKey(world.getName().toLowerCase())))) {
62  				if (worldsData.containsKey(&quot;all_unnamed_worlds&quot;)) {
63  					String usersMirror = mirrorsUser.get(&quot;all_unnamed_worlds&quot;);
64  					String groupsMirror = mirrorsGroup.get(&quot;all_unnamed_worlds&quot;);
65  					if (usersMirror != null)
66  						mirrorsUser.put(world.getName().toLowerCase(), usersMirror);
67  					if (groupsMirror != null)
68  						mirrorsGroup.put(world.getName().toLowerCase(), groupsMirror);
69  				}
70  				GroupManager.logger.log(Level.FINE, &quot;Creating folders for &quot; + world.getName() + &quot;.&quot;);
71  				setupWorldFolder(world.getName());
72  			}
73  		}
74  		for (File folder : worldsFolder.listFiles()) {
75  			if (folder.isDirectory() &amp;&amp; !folder.getName().startsWith(&quot;.&quot;)) {
76  				GroupManager.logger.info(&quot;World Found: &quot; + folder.getName());
77  				if (!worldsData.containsKey(folder.getName().toLowerCase()) &amp;&amp; ((!mirrorsGroup.containsKey(folder.getName().toLowerCase())) || (!mirrorsUser.containsKey(folder.getName().toLowerCase())))) {
78  					setupWorldFolder(folder.getName());
79  					loadWorld(folder.getName().toLowerCase());
80  				}
81  			}
82  		}
83  	}
84  	@SuppressWarnings(&quot;rawtypes&quot;)
85  	public void mirrorSetUp() {
86  		mirrorsGroup.clear();
87  		mirrorsUser.clear();
88  		Map&lt;String, Object&gt; mirrorsMap = plugin.getGMConfig().getMirrorsMap();
89  		HashSet&lt;String&gt; mirroredWorlds = new HashSet&lt;String&gt;();
90  		if (mirrorsMap != null) {
91  			for (String source : mirrorsMap.keySet()) {
92  				setupWorldFolder(source);
93  				if (!worldsData.containsKey(source.toLowerCase()))
94  					loadWorld(source);
95  				if (mirrorsMap.get(source) instanceof ArrayList) {
96  					ArrayList mirrorList = (ArrayList) mirrorsMap.get(source);
97  					for (Object o : mirrorList) {
98  						String world = o.toString().toLowerCase();
99  						if (!world.equalsIgnoreCase(serverDefaultWorldName)) {
100  							try {
101  								mirrorsGroup.remove(world);
102  								mirrorsUser.remove(world);
103  							} catch (Exception e) {
104  							}
105  							mirrorsGroup.put(world, getWorldData(source).getName());
106  							mirrorsUser.put(world, getWorldData(source).getName());
107  							mirroredWorlds.add(o.toString());
108  						} else
109  							GroupManager.logger.log(Level.WARNING, &quot;Mirroring error with &quot; + o.toString() + &quot;. Recursive loop detected!&quot;);
110  					}
111  				} else if (mirrorsMap.get(source) instanceof Map) {
112  					Map subSection = (Map) mirrorsMap.get(source);
113  					for (Object key : subSection.keySet()) {
114  						if (!((String)key).equalsIgnoreCase(serverDefaultWorldName)) {
115  							if (subSection.get(key) instanceof ArrayList) {
116  								ArrayList mirrorList = (ArrayList) subSection.get(key);
117  								for (Object o : mirrorList) {
118  									String type = o.toString().toLowerCase();
119  									try {
120  										if (type.equals(&quot;groups&quot;))
121  											mirrorsGroup.remove(((String)key).toLowerCase());
122  										if (type.equals(&quot;users&quot;))
123  											mirrorsUser.remove(((String)key).toLowerCase());
124  									} catch (Exception e) {
125  									}
126  									if (type.equals(&quot;groups&quot;)) {
127  										mirrorsGroup.put(((String)key).toLowerCase(), getWorldData(source).getName());
128  										GroupManager.logger.log(Level.FINE, &quot;Adding groups mirror for &quot; + key + &quot;.&quot;);
129  									}
130  									if (type.equals(&quot;users&quot;)) {
131  										mirrorsUser.put(((String)key).toLowerCase(), getWorldData(source).getName());
132  										GroupManager.logger.log(Level.FINE, &quot;Adding users mirror for &quot; + key + &quot;.&quot;);
133  									}
134  								}
135  								mirroredWorlds.add((String)key);
136  							} else
137  								throw new IllegalStateException(&quot;Unknown mirroring format for &quot; + (String)key);
138  						} else {
139  							GroupManager.logger.log(Level.WARNING, &quot;Mirroring error with &quot; + (String)key + &quot;. Recursive loop detected!&quot;);
140  						}
141  					}
142  				}
143  			}
144  			for (String world : mirroredWorlds) {
145  				if (!worldsData.containsKey(world.toLowerCase())) {
146  					GroupManager.logger.log(Level.FINE, &quot;No data for &quot; + world + &quot;.&quot;);
147  					setupWorldFolder(world);
148  					loadWorld(world, true);
149  				}
150  			}
151  		}
152  	}
153  	public void reloadAll() {
154  		GroupManager.getGlobalGroups().load();
155  		ArrayList&lt;WorldDataHolder&gt; alreadyDone = new ArrayList&lt;WorldDataHolder&gt;();
156  		for (WorldDataHolder w : worldsData.values()) {
157  			if (alreadyDone.contains(w)) {
158  				continue;
159  			}
160  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
161  				w.reloadGroups();
162  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
163  				w.reloadUsers();
164  			alreadyDone.add(w);
165  		}
166  	}
167  	public void reloadWorld(String worldName) {
168  		if (!mirrorsGroup.containsKey(worldName.toLowerCase()))
169  			getWorldData(worldName).reloadGroups();
170  		if (!mirrorsUser.containsKey(worldName.toLowerCase()))
171  			getWorldData(worldName).reloadUsers();
172  	}
173  	public void saveChanges() {
174  		saveChanges(true);
175  	}
176  	public boolean saveChanges(boolean overwrite) {
177  		boolean changed = false;
178  		ArrayList&lt;WorldDataHolder&gt; alreadyDone = new ArrayList&lt;WorldDataHolder&gt;();
179  		Tasks.removeOldFiles(plugin, plugin.getBackupFolder());
180  		if (GroupManager.getGlobalGroups().haveGroupsChanged()) {
181  			GroupManager.getGlobalGroups().writeGroups(overwrite);
182  		} else {
183  			if (GroupManager.getGlobalGroups().getTimeStampGroups() &lt; GroupManager.getGlobalGroups().getGlobalGroupsFile().lastModified()) {
184  				System.out.print(&quot;Newer GlobalGroups file found (Loading changes)!&quot;);
185  				GroupManager.getGlobalGroups().load();
186  			}
187  		}
188  		for (OverloadedWorldHolder w : worldsData.values()) {
189  			if (alreadyDone.contains(w)) {
190  				continue;
191  			}
192  			if (w == null) {
193  				GroupManager.logger.severe(&quot;WHAT HAPPENED?&quot;);
194  				continue;
195  			}
196  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
197  				if (w.haveGroupsChanged()) {
198  					if (overwrite || (!overwrite &amp;&amp; (w.getTimeStampGroups() &gt;= w.getGroupsFile().lastModified()))) {
199  						backupFile(w, true);
200  						WorldDataHolder.writeGroups(w, w.getGroupsFile());
201  						changed = true;
202  					} else {
203  						GroupManager.logger.log(Level.WARNING, &quot;Newer Groups file found for &quot; + w.getName() + &quot;, but we have local changes!&quot;);
204  						throw new IllegalStateException(&quot;Unable to save unless you issue a &#x27;/mansave force&#x27;&quot;);
205  					}
206  				} else {
207  					if (w.getTimeStampGroups() &lt; w.getGroupsFile().lastModified()) {
208  						System.out.print(&quot;Newer Groups file found (Loading changes)!&quot;);
209  						backupFile(w, true);
210  						w.reloadGroups();
211  						changed = true;
212  					}
213  				}
214  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
215  				if (w.haveUsersChanged()) {
216  					if (overwrite || (!overwrite &amp;&amp; (w.getTimeStampUsers() &gt;= w.getUsersFile().lastModified()))) {
217  						backupFile(w, false);
218  						WorldDataHolder.writeUsers(w, w.getUsersFile());
219  						changed = true;
220  					} else {
221  						GroupManager.logger.log(Level.WARNING, &quot;Newer Users file found for &quot; + w.getName() + &quot;, but we have local changes!&quot;);
222  						throw new IllegalStateException(&quot;Unable to save unless you issue a &#x27;/mansave force&#x27;&quot;);
223  					}
224  				} else {
225  					if (w.getTimeStampUsers() &lt; w.getUsersFile().lastModified()) {
226  						System.out.print(&quot;Newer Users file found (Loading changes)!&quot;);
227  						backupFile(w, false);
228  						w.reloadUsers();
229  						changed = true;
230  					}
231  				}
232  			alreadyDone.add(w);
233  		}
234  		return changed;
235  	}
236  	private void backupFile(OverloadedWorldHolder w, Boolean groups) {
237  		File backupFile = new File(plugin.getBackupFolder(), &quot;bkp_&quot; + w.getName() + (groups ? &quot;_g_&quot; : &quot;_u_&quot;) + Tasks.getDateString() + &quot;.yml&quot;);
238  		try {
239  			Tasks.copy((groups ? w.getGroupsFile() : w.getUsersFile()), backupFile);
240  		} catch (IOException ex) {
<span onclick='openModal()' class='match'>241  			GroupManager.logger.log(Level.SEVERE, null, ex);
242  		}
243  	}
244  	public OverloadedWorldHolder getWorldData(String worldName) {
</span>245  		String worldNameLowered = worldName.toLowerCase();
246  		if (worldsData.containsKey(worldNameLowered))
247  			return getUpdatedWorldData(worldNameLowered);
248  		if (worldsData.containsKey(&quot;all_unnamed_worlds&quot;)) {
249  			GroupManager.logger.finest(&quot;Requested world &quot; + worldName + &quot; not found or badly mirrored. Returning all_unnamed_worlds world...&quot;);
250  			return getUpdatedWorldData(&quot;all_unnamed_worlds&quot;);
251  		}
252  		GroupManager.logger.finest(&quot;Requested world &quot; + worldName + &quot; not found or badly mirrored. Returning default world...&quot;);
253  		return getDefaultWorld();
254  	}
255  	private OverloadedWorldHolder getUpdatedWorldData(String worldName) {
256  		String worldNameLowered = worldName.toLowerCase();
257  		if (worldsData.containsKey(worldNameLowered)) {
258  			OverloadedWorldHolder data = worldsData.get(worldNameLowered);
259  			data.updateDataSource();
260  			return data;
261  		}
262  		return null;
263  	}
264  	public OverloadedWorldHolder getWorldDataByPlayerName(String playerName) {
265  		List&lt;Player&gt; matchPlayer = plugin.getServer().matchPlayer(playerName);
266  		if (matchPlayer.size() == 1) {
267  			return getWorldData(matchPlayer.get(0));
268  		}
269  		return null;
270  	}
271  	public OverloadedWorldHolder getWorldData(Player player) {
272  		return getWorldData(player.getWorld().getName());
273  	}
274  	public AnjoPermissionsHandler getWorldPermissions(String worldName) {
275  		return getWorldData(worldName).getPermissionsHandler();
276  	}
277  	public AnjoPermissionsHandler getWorldPermissions(Player player) {
278  		return getWorldData(player).getPermissionsHandler();
279  	}
280  	public AnjoPermissionsHandler getWorldPermissionsByPlayerName(String playerName) {
281  		WorldDataHolder dh = getWorldDataByPlayerName(playerName);
282  		if (dh != null) {
283  			return dh.getPermissionsHandler();
284  		}
285  		return null;
286  	}
287  	private void verifyFirstRun() {
288  		if (plugin.getServer().getName().equalsIgnoreCase(&quot;BukkitForge&quot;)) {
289  			serverDefaultWorldName = &quot;overworld&quot;;
290  		} else {
291  			Properties server = new Properties();
292  			try {
293  				server.load(new FileInputStream(new File(&quot;server.properties&quot;)));
294  				serverDefaultWorldName = server.getProperty(&quot;level-name&quot;).toLowerCase();
295  			} catch (IOException ex) {
296  				GroupManager.logger.log(Level.SEVERE, null, ex);
297  			}
298  		}
299  		setupWorldFolder(serverDefaultWorldName);
300  	}
301  	public void setupWorldFolder(String worldName) {
302  		String worldNameLowered = worldName.toLowerCase();
303  		worldsFolder = new File(plugin.getDataFolder(), &quot;worlds&quot;);
304  		if (!worldsFolder.exists()) {
305  			worldsFolder.mkdirs();
306  		}
307  		File defaultWorldFolder = new File(worldsFolder, worldNameLowered);
308  		if ((!defaultWorldFolder.exists()) &amp;&amp; ((!mirrorsGroup.containsKey(worldNameLowered))) || (!mirrorsUser.containsKey(worldNameLowered))) {
309  			File casedWorldFolder = new File(worldsFolder, worldName);
310  			if ((casedWorldFolder.exists()) &amp;&amp; (casedWorldFolder.getName().toLowerCase().equals(worldNameLowered))) {
311  				casedWorldFolder.renameTo(new File(worldsFolder, worldNameLowered));
312  			} else {
313  				defaultWorldFolder.mkdirs();
314  			}
315  		}
316  		if (defaultWorldFolder.exists()) {
317  			if (!mirrorsGroup.containsKey(worldNameLowered)) {
318  				File groupsFile = new File(defaultWorldFolder, &quot;groups.yml&quot;);
319  				if (!groupsFile.exists() || groupsFile.length() == 0) {
320  					InputStream template = plugin.getResourceAsStream(&quot;groups.yml&quot;);
321  					try {
322  						Tasks.copy(template, groupsFile);
323  					} catch (IOException ex) {
324  						GroupManager.logger.log(Level.SEVERE, null, ex);
325  					}
326  				}
327  			}
328  			if (!mirrorsUser.containsKey(worldNameLowered)) {
329  				File usersFile = new File(defaultWorldFolder, &quot;users.yml&quot;);
330  				if (!usersFile.exists() || usersFile.length() == 0) {
331  					InputStream template = plugin.getResourceAsStream(&quot;users.yml&quot;);
332  					try {
333  						Tasks.copy(template, usersFile);
334  					} catch (IOException ex) {
335  						GroupManager.logger.log(Level.SEVERE, null, ex);
336  					}
337  				}
338  			}
339  		}
340  	}
341  	public boolean cloneWorld(String fromWorld, String toWorld) {
342  		File fromWorldFolder = new File(worldsFolder, fromWorld.toLowerCase());
343  		File toWorldFolder = new File(worldsFolder, toWorld.toLowerCase());
344  		if (toWorldFolder.exists() || !fromWorldFolder.exists()) {
345  			return false;
346  		}
347  		File fromWorldGroups = new File(fromWorldFolder, &quot;groups.yml&quot;);
348  		File fromWorldUsers = new File(fromWorldFolder, &quot;users.yml&quot;);
349  		if (!fromWorldGroups.exists() || !fromWorldUsers.exists()) {
350  			return false;
351  		}
352  		File toWorldGroups = new File(toWorldFolder, &quot;groups.yml&quot;);
353  		File toWorldUsers = new File(toWorldFolder, &quot;users.yml&quot;);
354  		toWorldFolder.mkdirs();
355  		try {
356  			Tasks.copy(fromWorldGroups, toWorldGroups);
357  			Tasks.copy(fromWorldUsers, toWorldUsers);
358  		} catch (IOException ex) {
359  			Logger.getLogger(WorldsHolder.class.getName()).log(Level.SEVERE, null, ex);
360  			return false;
361  		}
362  		return true;
363  	}
364  	public void loadWorld(String worldName) {
365  		loadWorld(worldName, false);
366  	}
367  	public void loadWorld(String worldName, Boolean isMirror) {
368  		String worldNameLowered = worldName.toLowerCase();
369  		if (worldsData.containsKey(worldNameLowered)) {
370  			worldsData.get(worldNameLowered).reload();
371  			return;
372  		}
373  		GroupManager.logger.finest(&quot;Trying to load world &quot; + worldName + &quot;...&quot;);
374  		File thisWorldFolder = new File(worldsFolder, worldNameLowered);
375  		if ((isMirror) || (thisWorldFolder.exists() &amp;&amp; thisWorldFolder.isDirectory())) {
376  			File groupsFile = (mirrorsGroup.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, &quot;groups.yml&quot;);
377  			File usersFile = (mirrorsUser.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, &quot;users.yml&quot;);
378  			if ((groupsFile != null) &amp;&amp; (!groupsFile.exists())) {
379  				throw new IllegalArgumentException(&quot;Groups file for world &#x27;&quot; + worldName + &quot;&#x27; doesnt exist: &quot; + groupsFile.getPath());
380  			}
381  			if ((usersFile != null) &amp;&amp; (!usersFile.exists())) {
382  				throw new IllegalArgumentException(&quot;Users file for world &#x27;&quot; + worldName + &quot;&#x27; doesnt exist: &quot; + usersFile.getPath());
383  			}
384  			WorldDataHolder tempHolder = new WorldDataHolder(worldNameLowered);
385  			if (mirrorsGroup.containsKey(worldNameLowered))
386  				tempHolder.setGroupsObject(this.getWorldData(mirrorsGroup.get(worldNameLowered)).getGroupsObject());
387  			else
388  				tempHolder.loadGroups(groupsFile);
389  			if (mirrorsUser.containsKey(worldNameLowered))
390  				tempHolder.setUsersObject(this.getWorldData(mirrorsUser.get(worldNameLowered)).getUsersObject());
391  			else
392  				tempHolder.loadUsers(usersFile);
393  			OverloadedWorldHolder thisWorldData = new OverloadedWorldHolder(tempHolder);
394  			tempHolder = null;
395  			thisWorldData.setTimeStamps();
396  			if (thisWorldData != null) {
397  				GroupManager.logger.finest(&quot;Successful load of world &quot; + worldName + &quot;...&quot;);
398  				worldsData.put(worldNameLowered, thisWorldData);
399  				return;
400  			}
401  		}
402  	}
403  	public boolean isInList(String worldName) {
404  		if (worldsData.containsKey(worldName.toLowerCase()) || mirrorsGroup.containsKey(worldName.toLowerCase()) || mirrorsUser.containsKey(worldName.toLowerCase())) {
405  			return true;
406  		}
407  		return false;
408  	}
409  	public boolean hasOwnData(String worldName) {
410  		if (worldsData.containsKey(worldName.toLowerCase()) &amp;&amp; (!mirrorsGroup.containsKey(worldName.toLowerCase()) || !mirrorsUser.containsKey(worldName.toLowerCase()))) {
411  			return true;
412  		}
413  		return false;
414  	}
415  	public OverloadedWorldHolder getDefaultWorld() {
416  		return getUpdatedWorldData(serverDefaultWorldName);
417  	}
418  	public ArrayList&lt;OverloadedWorldHolder&gt; allWorldsDataList() {
419  		ArrayList&lt;OverloadedWorldHolder&gt; list = new ArrayList&lt;OverloadedWorldHolder&gt;();
420  		for (String world : worldsData.keySet()) {
421  			if (!world.equalsIgnoreCase(&quot;all_unnamed_worlds&quot;)) {
422  				OverloadedWorldHolder data = getWorldData(world);
423  				if (!list.contains(data)) {
424  					String worldNameLowered = data.getName().toLowerCase();
425  					String usersMirror = mirrorsUser.get(worldNameLowered);
426  					String groupsMirror = mirrorsGroup.get(worldNameLowered);
427  					if (usersMirror != null) {
428  						if (groupsMirror != null) {
429  							if (usersMirror == groupsMirror) {
430  								data = getWorldData(usersMirror.toLowerCase());
431  								if (!list.contains(data))
432  									list.add(data);
433  								continue;
434  							}
435  						}
436  					}
437  					list.add(data);
438  				}
439  			}
440  		}
441  		return list;
442  	}
443  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager.dataholder.worlds;
2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.IOException;
5  import java.io.InputStream;
6  import java.util.ArrayList;
7  import java.util.HashMap;
8  import java.util.HashSet;
9  import java.util.List;
10  import java.util.Map;
11  import java.util.Properties;
12  import java.util.logging.Level;
13  import java.util.logging.Logger;
14  import org.anjocaido.groupmanager.GroupManager;
15  import org.anjocaido.groupmanager.dataholder.WorldDataHolder;
16  import org.anjocaido.groupmanager.dataholder.OverloadedWorldHolder;
17  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.bukkit.World;
20  import org.bukkit.entity.Player;
21  public class WorldsHolder {
22  	private Map&lt;String, OverloadedWorldHolder&gt; worldsData = new HashMap&lt;String, OverloadedWorldHolder&gt;();
23  	private Map&lt;String, String&gt; mirrorsGroup = new HashMap&lt;String, String&gt;();
24  	private Map&lt;String, String&gt; mirrorsUser = new HashMap&lt;String, String&gt;();
25  	private String serverDefaultWorldName;
26  	private GroupManager plugin;
27  	private File worldsFolder;
28  	public WorldsHolder(GroupManager plugin) {
29  		this.plugin = plugin;
30  		resetWorldsHolder();
31  	}
32  	public Map&lt;String, String&gt; getMirrorsGroup() {
33  		return mirrorsGroup;
34  	}
35  	public Map&lt;String, String&gt; getMirrorsUser() {
36  		return mirrorsUser;
37  	}
38  	public boolean isWorldKnown(String name) {
39  		return worldsData.containsKey(name.toLowerCase());
40  	}
41  	public void resetWorldsHolder() {
42  		worldsData = new HashMap&lt;String, OverloadedWorldHolder&gt;();
43  		mirrorsGroup = new HashMap&lt;String, String&gt;();
44  		mirrorsUser = new HashMap&lt;String, String&gt;();
45  		verifyFirstRun();
46  		initialLoad();
47  		if (serverDefaultWorldName == null)
48  			throw new IllegalStateException(&quot;There is no default group! OMG!&quot;);
49  	}
50  	private void initialLoad() {
51  		initialWorldLoading();
52  		mirrorSetUp();
53  		loadAllSearchedWorlds();
54  	}
55  	private void initialWorldLoading() {
56  		loadWorld(serverDefaultWorldName);
57  	}
58  	private void loadAllSearchedWorlds() {
59  		for (World world : plugin.getServer().getWorlds()) {
60  			GroupManager.logger.log(Level.FINE, &quot;Checking data for &quot; + world.getName() + &quot;.&quot;);
61  			if ((!worldsData.containsKey(world.getName().toLowerCase())) &amp;&amp; ((!mirrorsGroup.containsKey(world.getName().toLowerCase())) || (!mirrorsUser.containsKey(world.getName().toLowerCase())))) {
62  				if (worldsData.containsKey(&quot;all_unnamed_worlds&quot;)) {
63  					String usersMirror = mirrorsUser.get(&quot;all_unnamed_worlds&quot;);
64  					String groupsMirror = mirrorsGroup.get(&quot;all_unnamed_worlds&quot;);
65  					if (usersMirror != null)
66  						mirrorsUser.put(world.getName().toLowerCase(), usersMirror);
67  					if (groupsMirror != null)
68  						mirrorsGroup.put(world.getName().toLowerCase(), groupsMirror);
69  				}
70  				GroupManager.logger.log(Level.FINE, &quot;Creating folders for &quot; + world.getName() + &quot;.&quot;);
71  				setupWorldFolder(world.getName());
72  			}
73  		}
74  		for (File folder : worldsFolder.listFiles()) {
75  			if (folder.isDirectory() &amp;&amp; !folder.getName().startsWith(&quot;.&quot;)) {
76  				GroupManager.logger.info(&quot;World Found: &quot; + folder.getName());
77  				if (!worldsData.containsKey(folder.getName().toLowerCase()) &amp;&amp; ((!mirrorsGroup.containsKey(folder.getName().toLowerCase())) || (!mirrorsUser.containsKey(folder.getName().toLowerCase())))) {
78  					setupWorldFolder(folder.getName());
79  					loadWorld(folder.getName().toLowerCase());
80  				}
81  			}
82  		}
83  	}
84  	@SuppressWarnings(&quot;rawtypes&quot;)
85  	public void mirrorSetUp() {
86  		mirrorsGroup.clear();
87  		mirrorsUser.clear();
88  		Map&lt;String, Object&gt; mirrorsMap = plugin.getGMConfig().getMirrorsMap();
89  		HashSet&lt;String&gt; mirroredWorlds = new HashSet&lt;String&gt;();
90  		if (mirrorsMap != null) {
91  			for (String source : mirrorsMap.keySet()) {
92  				setupWorldFolder(source);
93  				if (!worldsData.containsKey(source.toLowerCase()))
94  					loadWorld(source);
95  				if (mirrorsMap.get(source) instanceof ArrayList) {
96  					ArrayList mirrorList = (ArrayList) mirrorsMap.get(source);
97  					for (Object o : mirrorList) {
98  						String world = o.toString().toLowerCase();
99  						if (!world.equalsIgnoreCase(serverDefaultWorldName)) {
100  							try {
101  								mirrorsGroup.remove(world);
102  								mirrorsUser.remove(world);
103  							} catch (Exception e) {
104  							}
105  							mirrorsGroup.put(world, getWorldData(source).getName());
106  							mirrorsUser.put(world, getWorldData(source).getName());
107  							mirroredWorlds.add(o.toString());
108  						} else
109  							GroupManager.logger.log(Level.WARNING, &quot;Mirroring error with &quot; + o.toString() + &quot;. Recursive loop detected!&quot;);
110  					}
111  				} else if (mirrorsMap.get(source) instanceof Map) {
112  					Map subSection = (Map) mirrorsMap.get(source);
113  					for (Object key : subSection.keySet()) {
114  						if (!((String)key).equalsIgnoreCase(serverDefaultWorldName)) {
115  							if (subSection.get(key) instanceof ArrayList) {
116  								ArrayList mirrorList = (ArrayList) subSection.get(key);
117  								for (Object o : mirrorList) {
118  									String type = o.toString().toLowerCase();
119  									try {
120  										if (type.equals(&quot;groups&quot;))
121  											mirrorsGroup.remove(((String)key).toLowerCase());
122  										if (type.equals(&quot;users&quot;))
123  											mirrorsUser.remove(((String)key).toLowerCase());
124  									} catch (Exception e) {
125  									}
126  									if (type.equals(&quot;groups&quot;)) {
127  										mirrorsGroup.put(((String)key).toLowerCase(), getWorldData(source).getName());
128  										GroupManager.logger.log(Level.FINE, &quot;Adding groups mirror for &quot; + key + &quot;.&quot;);
129  									}
130  									if (type.equals(&quot;users&quot;)) {
131  										mirrorsUser.put(((String)key).toLowerCase(), getWorldData(source).getName());
132  										GroupManager.logger.log(Level.FINE, &quot;Adding users mirror for &quot; + key + &quot;.&quot;);
133  									}
134  								}
135  								mirroredWorlds.add((String)key);
136  							} else
137  								throw new IllegalStateException(&quot;Unknown mirroring format for &quot; + (String)key);
138  						} else {
139  							GroupManager.logger.log(Level.WARNING, &quot;Mirroring error with &quot; + (String)key + &quot;. Recursive loop detected!&quot;);
140  						}
141  					}
142  				}
143  			}
144  			for (String world : mirroredWorlds) {
145  				if (!worldsData.containsKey(world.toLowerCase())) {
146  					GroupManager.logger.log(Level.FINE, &quot;No data for &quot; + world + &quot;.&quot;);
147  					setupWorldFolder(world);
148  					loadWorld(world, true);
149  				}
150  			}
151  		}
152  	}
153  	public void reloadAll() {
154  		GroupManager.getGlobalGroups().load();
155  		ArrayList&lt;WorldDataHolder&gt; alreadyDone = new ArrayList&lt;WorldDataHolder&gt;();
156  		for (WorldDataHolder w : worldsData.values()) {
157  			if (alreadyDone.contains(w)) {
158  				continue;
159  			}
160  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
161  				w.reloadGroups();
162  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
163  				w.reloadUsers();
164  			alreadyDone.add(w);
165  		}
166  	}
167  	public void reloadWorld(String worldName) {
168  		if (!mirrorsGroup.containsKey(worldName.toLowerCase()))
169  			getWorldData(worldName).reloadGroups();
170  		if (!mirrorsUser.containsKey(worldName.toLowerCase()))
171  			getWorldData(worldName).reloadUsers();
172  	}
173  	public void saveChanges() {
174  		saveChanges(true);
175  	}
176  	public boolean saveChanges(boolean overwrite) {
177  		boolean changed = false;
178  		ArrayList&lt;WorldDataHolder&gt; alreadyDone = new ArrayList&lt;WorldDataHolder&gt;();
179  		Tasks.removeOldFiles(plugin, plugin.getBackupFolder());
180  		if (GroupManager.getGlobalGroups().haveGroupsChanged()) {
181  			GroupManager.getGlobalGroups().writeGroups(overwrite);
182  		} else {
183  			if (GroupManager.getGlobalGroups().getTimeStampGroups() &lt; GroupManager.getGlobalGroups().getGlobalGroupsFile().lastModified()) {
184  				System.out.print(&quot;Newer GlobalGroups file found (Loading changes)!&quot;);
185  				GroupManager.getGlobalGroups().load();
186  			}
187  		}
188  		for (OverloadedWorldHolder w : worldsData.values()) {
189  			if (alreadyDone.contains(w)) {
190  				continue;
191  			}
192  			if (w == null) {
193  				GroupManager.logger.severe(&quot;WHAT HAPPENED?&quot;);
194  				continue;
195  			}
196  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
197  				if (w.haveGroupsChanged()) {
198  					if (overwrite || (!overwrite &amp;&amp; (w.getTimeStampGroups() &gt;= w.getGroupsFile().lastModified()))) {
199  						backupFile(w, true);
200  						WorldDataHolder.writeGroups(w, w.getGroupsFile());
201  						changed = true;
202  					} else {
203  						GroupManager.logger.log(Level.WARNING, &quot;Newer Groups file found for &quot; + w.getName() + &quot;, but we have local changes!&quot;);
204  						throw new IllegalStateException(&quot;Unable to save unless you issue a &#x27;/mansave force&#x27;&quot;);
205  					}
206  				} else {
207  					if (w.getTimeStampGroups() &lt; w.getGroupsFile().lastModified()) {
208  						System.out.print(&quot;Newer Groups file found (Loading changes)!&quot;);
209  						backupFile(w, true);
210  						w.reloadGroups();
211  						changed = true;
212  					}
213  				}
214  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
215  				if (w.haveUsersChanged()) {
216  					if (overwrite || (!overwrite &amp;&amp; (w.getTimeStampUsers() &gt;= w.getUsersFile().lastModified()))) {
217  						backupFile(w, false);
218  						WorldDataHolder.writeUsers(w, w.getUsersFile());
219  						changed = true;
220  					} else {
221  						GroupManager.logger.log(Level.WARNING, &quot;Newer Users file found for &quot; + w.getName() + &quot;, but we have local changes!&quot;);
222  						throw new IllegalStateException(&quot;Unable to save unless you issue a &#x27;/mansave force&#x27;&quot;);
223  					}
224  				} else {
225  					if (w.getTimeStampUsers() &lt; w.getUsersFile().lastModified()) {
226  						System.out.print(&quot;Newer Users file found (Loading changes)!&quot;);
227  						backupFile(w, false);
228  						w.reloadUsers();
229  						changed = true;
230  					}
231  				}
232  			alreadyDone.add(w);
233  		}
234  		return changed;
235  	}
236  	private void backupFile(OverloadedWorldHolder w, Boolean groups) {
237  		File backupFile = new File(plugin.getBackupFolder(), &quot;bkp_&quot; + w.getName() + (groups ? &quot;_g_&quot; : &quot;_u_&quot;) + Tasks.getDateString() + &quot;.yml&quot;);
238  		try {
239  			Tasks.copy((groups ? w.getGroupsFile() : w.getUsersFile()), backupFile);
240  		} catch (IOException ex) {
241  			GroupManager.logger.log(Level.SEVERE, null, ex);
242  		}
243  	}
244  	public OverloadedWorldHolder getWorldData(String worldName) {
245  		String worldNameLowered = worldName.toLowerCase();
246  		if (worldsData.containsKey(worldNameLowered))
247  			return getUpdatedWorldData(worldNameLowered);
248  		if (worldsData.containsKey(&quot;all_unnamed_worlds&quot;)) {
249  			GroupManager.logger.finest(&quot;Requested world &quot; + worldName + &quot; not found or badly mirrored. Returning all_unnamed_worlds world...&quot;);
250  			return getUpdatedWorldData(&quot;all_unnamed_worlds&quot;);
251  		}
252  		GroupManager.logger.finest(&quot;Requested world &quot; + worldName + &quot; not found or badly mirrored. Returning default world...&quot;);
253  		return getDefaultWorld();
254  	}
255  	private OverloadedWorldHolder getUpdatedWorldData(String worldName) {
256  		String worldNameLowered = worldName.toLowerCase();
257  		if (worldsData.containsKey(worldNameLowered)) {
258  			OverloadedWorldHolder data = worldsData.get(worldNameLowered);
259  			data.updateDataSource();
260  			return data;
261  		}
262  		return null;
263  	}
264  	public OverloadedWorldHolder getWorldDataByPlayerName(String playerName) {
265  		List&lt;Player&gt; matchPlayer = plugin.getServer().matchPlayer(playerName);
266  		if (matchPlayer.size() == 1) {
267  			return getWorldData(matchPlayer.get(0));
268  		}
269  		return null;
270  	}
271  	public OverloadedWorldHolder getWorldData(Player player) {
272  		return getWorldData(player.getWorld().getName());
273  	}
274  	public AnjoPermissionsHandler getWorldPermissions(String worldName) {
275  		return getWorldData(worldName).getPermissionsHandler();
276  	}
277  	public AnjoPermissionsHandler getWorldPermissions(Player player) {
278  		return getWorldData(player).getPermissionsHandler();
279  	}
280  	public AnjoPermissionsHandler getWorldPermissionsByPlayerName(String playerName) {
281  		WorldDataHolder dh = getWorldDataByPlayerName(playerName);
282  		if (dh != null) {
283  			return dh.getPermissionsHandler();
284  		}
285  		return null;
286  	}
287  	private void verifyFirstRun() {
288  		if (plugin.getServer().getName().equalsIgnoreCase(&quot;BukkitForge&quot;)) {
289  			serverDefaultWorldName = &quot;overworld&quot;;
290  		} else {
291  			Properties server = new Properties();
292  			try {
293  				server.load(new FileInputStream(new File(&quot;server.properties&quot;)));
294  				serverDefaultWorldName = server.getProperty(&quot;level-name&quot;).toLowerCase();
295  			} catch (IOException ex) {
296  				GroupManager.logger.log(Level.SEVERE, null, ex);
297  			}
298  		}
299  		setupWorldFolder(serverDefaultWorldName);
300  	}
301  	public void setupWorldFolder(String worldName) {
302  		String worldNameLowered = worldName.toLowerCase();
303  		worldsFolder = new File(plugin.getDataFolder(), &quot;worlds&quot;);
304  		if (!worldsFolder.exists()) {
305  			worldsFolder.mkdirs();
306  		}
307  		File defaultWorldFolder = new File(worldsFolder, worldNameLowered);
308  		if ((!defaultWorldFolder.exists()) &amp;&amp; ((!mirrorsGroup.containsKey(worldNameLowered))) || (!mirrorsUser.containsKey(worldNameLowered))) {
309  			File casedWorldFolder = new File(worldsFolder, worldName);
310  			if ((casedWorldFolder.exists()) &amp;&amp; (casedWorldFolder.getName().toLowerCase().equals(worldNameLowered))) {
311  				casedWorldFolder.renameTo(new File(worldsFolder, worldNameLowered));
312  			} else {
313  				defaultWorldFolder.mkdirs();
314  			}
315  		}
316  		if (defaultWorldFolder.exists()) {
317  			if (!mirrorsGroup.containsKey(worldNameLowered)) {
318  				File groupsFile = new File(defaultWorldFolder, &quot;groups.yml&quot;);
319  				if (!groupsFile.exists() || groupsFile.length() == 0) {
320  					InputStream template = plugin.getResourceAsStream(&quot;groups.yml&quot;);
321  					try {
322  						Tasks.copy(template, groupsFile);
323  					} catch (IOException ex) {
324  						GroupManager.logger.log(Level.SEVERE, null, ex);
325  					}
326  				}
327  			}
328  			if (!mirrorsUser.containsKey(worldNameLowered)) {
329  				File usersFile = new File(defaultWorldFolder, &quot;users.yml&quot;);
330  				if (!usersFile.exists() || usersFile.length() == 0) {
331  					InputStream template = plugin.getResourceAsStream(&quot;users.yml&quot;);
332  					try {
333  						Tasks.copy(template, usersFile);
334  					} catch (IOException ex) {
<span onclick='openModal()' class='match'>335  						GroupManager.logger.log(Level.SEVERE, null, ex);
336  					}
337  				}
338  			}
</span>339  		}
340  	}
341  	public boolean cloneWorld(String fromWorld, String toWorld) {
342  		File fromWorldFolder = new File(worldsFolder, fromWorld.toLowerCase());
343  		File toWorldFolder = new File(worldsFolder, toWorld.toLowerCase());
344  		if (toWorldFolder.exists() || !fromWorldFolder.exists()) {
345  			return false;
346  		}
347  		File fromWorldGroups = new File(fromWorldFolder, &quot;groups.yml&quot;);
348  		File fromWorldUsers = new File(fromWorldFolder, &quot;users.yml&quot;);
349  		if (!fromWorldGroups.exists() || !fromWorldUsers.exists()) {
350  			return false;
351  		}
352  		File toWorldGroups = new File(toWorldFolder, &quot;groups.yml&quot;);
353  		File toWorldUsers = new File(toWorldFolder, &quot;users.yml&quot;);
354  		toWorldFolder.mkdirs();
355  		try {
356  			Tasks.copy(fromWorldGroups, toWorldGroups);
357  			Tasks.copy(fromWorldUsers, toWorldUsers);
358  		} catch (IOException ex) {
359  			Logger.getLogger(WorldsHolder.class.getName()).log(Level.SEVERE, null, ex);
360  			return false;
361  		}
362  		return true;
363  	}
364  	public void loadWorld(String worldName) {
365  		loadWorld(worldName, false);
366  	}
367  	public void loadWorld(String worldName, Boolean isMirror) {
368  		String worldNameLowered = worldName.toLowerCase();
369  		if (worldsData.containsKey(worldNameLowered)) {
370  			worldsData.get(worldNameLowered).reload();
371  			return;
372  		}
373  		GroupManager.logger.finest(&quot;Trying to load world &quot; + worldName + &quot;...&quot;);
374  		File thisWorldFolder = new File(worldsFolder, worldNameLowered);
375  		if ((isMirror) || (thisWorldFolder.exists() &amp;&amp; thisWorldFolder.isDirectory())) {
376  			File groupsFile = (mirrorsGroup.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, &quot;groups.yml&quot;);
377  			File usersFile = (mirrorsUser.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, &quot;users.yml&quot;);
378  			if ((groupsFile != null) &amp;&amp; (!groupsFile.exists())) {
379  				throw new IllegalArgumentException(&quot;Groups file for world &#x27;&quot; + worldName + &quot;&#x27; doesnt exist: &quot; + groupsFile.getPath());
380  			}
381  			if ((usersFile != null) &amp;&amp; (!usersFile.exists())) {
382  				throw new IllegalArgumentException(&quot;Users file for world &#x27;&quot; + worldName + &quot;&#x27; doesnt exist: &quot; + usersFile.getPath());
383  			}
384  			WorldDataHolder tempHolder = new WorldDataHolder(worldNameLowered);
385  			if (mirrorsGroup.containsKey(worldNameLowered))
386  				tempHolder.setGroupsObject(this.getWorldData(mirrorsGroup.get(worldNameLowered)).getGroupsObject());
387  			else
388  				tempHolder.loadGroups(groupsFile);
389  			if (mirrorsUser.containsKey(worldNameLowered))
390  				tempHolder.setUsersObject(this.getWorldData(mirrorsUser.get(worldNameLowered)).getUsersObject());
391  			else
392  				tempHolder.loadUsers(usersFile);
393  			OverloadedWorldHolder thisWorldData = new OverloadedWorldHolder(tempHolder);
394  			tempHolder = null;
395  			thisWorldData.setTimeStamps();
396  			if (thisWorldData != null) {
397  				GroupManager.logger.finest(&quot;Successful load of world &quot; + worldName + &quot;...&quot;);
398  				worldsData.put(worldNameLowered, thisWorldData);
399  				return;
400  			}
401  		}
402  	}
403  	public boolean isInList(String worldName) {
404  		if (worldsData.containsKey(worldName.toLowerCase()) || mirrorsGroup.containsKey(worldName.toLowerCase()) || mirrorsUser.containsKey(worldName.toLowerCase())) {
405  			return true;
406  		}
407  		return false;
408  	}
409  	public boolean hasOwnData(String worldName) {
410  		if (worldsData.containsKey(worldName.toLowerCase()) &amp;&amp; (!mirrorsGroup.containsKey(worldName.toLowerCase()) || !mirrorsUser.containsKey(worldName.toLowerCase()))) {
411  			return true;
412  		}
413  		return false;
414  	}
415  	public OverloadedWorldHolder getDefaultWorld() {
416  		return getUpdatedWorldData(serverDefaultWorldName);
417  	}
418  	public ArrayList&lt;OverloadedWorldHolder&gt; allWorldsDataList() {
419  		ArrayList&lt;OverloadedWorldHolder&gt; list = new ArrayList&lt;OverloadedWorldHolder&gt;();
420  		for (String world : worldsData.keySet()) {
421  			if (!world.equalsIgnoreCase(&quot;all_unnamed_worlds&quot;)) {
422  				OverloadedWorldHolder data = getWorldData(world);
423  				if (!list.contains(data)) {
424  					String worldNameLowered = data.getName().toLowerCase();
425  					String usersMirror = mirrorsUser.get(worldNameLowered);
426  					String groupsMirror = mirrorsGroup.get(worldNameLowered);
427  					if (usersMirror != null) {
428  						if (groupsMirror != null) {
429  							if (usersMirror == groupsMirror) {
430  								data = getWorldData(usersMirror.toLowerCase());
431  								if (!list.contains(data))
432  									list.add(data);
433  								continue;
434  							}
435  						}
436  					}
437  					list.add(data);
438  				}
439  			}
440  		}
441  		return list;
442  	}
443  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</div>
                </div>
                <div class="column column_space"><pre><code>241  			GroupManager.logger.log(Level.SEVERE, null, ex);
242  		}
243  	}
244  	public OverloadedWorldHolder getWorldData(String worldName) {
</pre></code></div>
                <div class="column column_space"><pre><code>335  						GroupManager.logger.log(Level.SEVERE, null, ex);
336  					}
337  				}
338  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    