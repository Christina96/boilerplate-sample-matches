<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for StoreRecovery.java & ScopedSettingsTests.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for StoreRecovery.java & ScopedSettingsTests.java
      </h3>
      <h1 align="center">
        11.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>StoreRecovery.java (18.81068%)<TH>ScopedSettingsTests.java (8.031088%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#0',2,'match1907819-1.html#0',3)" NAME="0">(20-57)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#0',2,'match1907819-1.html#0',3)" NAME="0">(21-60)</A><TD ALIGN=center><FONT COLOR="#ff0000">36</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#1',2,'match1907819-1.html#1',3)" NAME="1">(335-343)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#1',2,'match1907819-1.html#1',3)" NAME="1">(299-317)</A><TD ALIGN=center><FONT COLOR="#bf0000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#2',2,'match1907819-1.html#2',3)" NAME="2">(132-150)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#2',2,'match1907819-1.html#2',3)" NAME="2">(947-956)</A><TD ALIGN=center><FONT COLOR="#8d0000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#3',2,'match1907819-1.html#3',3)" NAME="3">(435-441)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#3',2,'match1907819-1.html#3',3)" NAME="3">(1082-1088)</A><TD ALIGN=center><FONT COLOR="#5c0000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#4',2,'match1907819-1.html#4',3)" NAME="4">(521-525)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#4',2,'match1907819-1.html#4',3)" NAME="4">(75-79)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#5',2,'match1907819-1.html#5',3)" NAME="5">(486-493)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#5',2,'match1907819-1.html#5',3)" NAME="5">(113-116)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#6',2,'match1907819-1.html#6',3)" NAME="6">(443-447)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#6',2,'match1907819-1.html#6',3)" NAME="6">(440-442)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#7',2,'match1907819-1.html#7',3)" NAME="7">(330-332)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#7',2,'match1907819-1.html#7',3)" NAME="7">(71-75)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#8',2,'match1907819-1.html#8',3)" NAME="8">(328-329)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#8',2,'match1907819-1.html#8',3)" NAME="8">(632-636)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match1907819-0.html#9',2,'match1907819-1.html#9',3)" NAME="9">(196-200)<TD><A HREF="javascript:ZweiFrames('match1907819-0.html#9',2,'match1907819-1.html#9',3)" NAME="9">(788-791)</A><TD ALIGN=center><FONT COLOR="#3f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>StoreRecovery.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1907819-1.html#0',3,'match1907819-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.index.shard;

import org.apache.logging.log4j.Logger;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.NoMergePolicy;
import org.apache.lucene.index.SegmentInfos;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.FilterDirectory;
import org.apache.lucene.store.IOContext;
import org.apache.lucene.store.IndexInput;
import org.elasticsearch.ExceptionsHelper;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.MappingMetadata;
import org.elasticsearch.cluster.routing.RecoverySource;
import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.unit.ByteSizeValue;
import io.crate.common.unit.TimeValue;
import org.elasticsearch.index.Index;
import org.elasticsearch.index.engine.Engine;
import org.elasticsearch.index.engine.EngineException;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.index.seqno.SequenceNumbers;
import org.elasticsearch.index.snapshots.IndexShardRestoreFailedException;
import org.elasticsearch.index.store.Store;
import org.elasticsearch.index.translog.Translog;
import org.elasticsearch.indices.recovery.RecoveryState;
import org.elasticsearch.repositories.IndexId;
import org.elasticsearch.repositories.Repository;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import</B></FONT> java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static io.crate.common.unit.TimeValue.timeValueMillis;

/**
 * This package private utility class encapsulates the logic to recover an index shard from either an existing index on
 * disk or from a snapshot in a repository.
 */
final class StoreRecovery {

    private final Logger logger;
    private final ShardId shardId;

    StoreRecovery(ShardId shardId, Logger logger) {
        this.logger = logger;
        this.shardId = shardId;
    }

    /**
     * Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should
     * exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index
     * files / transaction logs. This
     *
     * @param indexShard the index shard instance to recovery the shard into
     * @param listener resolves to &lt;code&gt;true&lt;/code&gt; if the shard has been recovered successfully, &lt;code&gt;false&lt;/code&gt; if the recovery
     *                 has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.
     * @see Store
     */
    void recoverFromStore(final IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
        if (canRecover(indexShard)) {
            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
            assert
                recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :
                &quot;expected store recovery type but was: &quot; + recoveryType;
            ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
                logger.debug(&quot;starting recovery from store ...&quot;);
                internalRecoverFromStore(indexShard);
                return true;
            });
        } else {
            listener.onResponse(false);
        }
    }

    void recoverFromLocalShards(Consumer&lt;MappingMetadata&gt; mappingUpdateConsumer,
                                IndexShard indexShard,
                                List&lt;LocalShardSnapshot&gt; shards,
                                ActionListener&lt;Boolean&gt; listener) {
        if (canRecover(indexShard)) {
            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
            assert
                recoveryType == RecoverySource.Type.LOCAL_SHARDS :
                &quot;expected local shards recovery type: &quot; + recoveryType;
            if (shards.isEmpty()) {
                throw new IllegalArgumentException(&quot;shards must not be empty&quot;);
            }
            Set&lt;Index&gt; indices = shards.stream().map((s) -&gt; s.getIndex()).collect(Collectors.toSet());
            if (indices.size() &gt; 1) {
                throw new IllegalArgumentException(&quot;can't add shards from more than one index&quot;);
            }
            IndexMetadata sourceMetadata = shards.get(0).getIndexMetadata();
            if (sourceMetadata.mapping() != null) {
                mappingUpdateConsumer.accept(sourceMetadata.mapping());
            }
            indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);
            // now that the mapping is merged we can validate the index sort configuration.
            final boolean isSplit = sourceMetadata.getNumberOfShards() &lt; indexShard.indexSettings().getNumberOfShards();
            ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
                logger.debug(&quot;starting recovery from local shards {}&quot;, shards);
<A NAME="2"></A>                try {
                    final Directory directory = indexShard.store().directory(); // don't close this directory!!
                    final Directory[] sources = shards.stream().map(LocalShardSnapshot::getSnapshotDirectory).toArray(Directory[]::new);
                    final long maxSeqNo = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1907819-1.html#2',3,'match1907819-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>shards.stream().mapToLong(LocalShardSnapshot::maxSeqNo).max().getAsLong();
                    final long maxUnsafeAutoIdTimestamp = shards.stream()
                        .mapToLong(LocalShardSnapshot::maxUnsafeAutoIdTimestamp)
                        .max()
                        .getAsLong();
                    addIndices(
                        indexShard.recoveryState().getIndex(),
                        directory,
                        sources,
                        maxSeqNo,
                        maxUnsafeAutoIdTimestamp,
                        indexShard.indexSettings().getIndexMetadata(),
                        indexShard.shardId().id(),
                        isSplit
                    );
                    internalRecoverFromStore(indexShard);
                    // just trigger a merge to do housekeeping on the
                    // copied segments - we will also see them in stats etc.
                    indexShard.getEngine().forceMerge(false, -1, false, false, false, UUIDs.randomBase64UUID</B></FONT>());
                    return true;
                } catch (IOException ex) {
                    throw new IndexShardRecoveryException(indexShard.shardId(), &quot;failed to recover from local shards&quot;, ex);
                }
            });
        } else {
            listener.onResponse(false);
        }
    }

    void addIndices(final RecoveryState.Index indexRecoveryStats,
                    final Directory target,
                    final Directory[] sources,
                    final long maxSeqNo,
                    final long maxUnsafeAutoIdTimestamp,
                    IndexMetadata indexMetadata,
                    int shardId,
                    boolean split) throws IOException {

        assert sources.length &gt; 0;
        final int luceneIndexCreatedVersionMajor = Lucene.readSegmentInfos(sources[0]).getIndexCreatedVersionMajor();

        final Directory hardLinkOrCopyTarget = new org.apache.lucene.store.HardlinkCopyDirectoryWrapper(target);

        IndexWriterConfig iwc = new IndexWriterConfig(null)
            .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)
            .setCommitOnClose(false)
            // we don't want merges to happen here - we call maybe merge on the engine
            // later once we stared it up otherwise we would need to wait for it here
            // we also don't specify a codec here and merges should use the engines for this index
            .setMergePolicy(NoMergePolicy.INSTANCE)
            .setOpenMode(IndexWriterConfig.OpenMode.CREATE)
            .setIndexCreatedVersionMajor(luceneIndexCreatedVersionMajor);

        try (IndexWriter writer = new IndexWriter(new StatsDirectoryWrapper(hardLinkOrCopyTarget, indexRecoveryStats), iwc)) {
            writer.addIndexes(sources);
            indexRecoveryStats.setFileDetailsComplete();
            if (split) {
                writer.deleteDocuments(new ShardSplittingQuery(indexMetadata, shardId));
            }
            /*
             * We set the maximum sequence number and the local checkpoint on the target to the maximum of the maximum sequence numbers on
<A NAME="9"></A>             * the source shards. This ensures that history after this maximum sequence number can advance and we have correct
             * document-level semantics.
             */
            writer.setLiveCommitData(() -&gt; <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match1907819-1.html#9',3,'match1907819-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
                final HashMap&lt;String, String&gt; liveCommitData = new HashMap&lt;&gt;(3);
                liveCommitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(maxSeqNo));
                liveCommitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(maxSeqNo));
                liveCommitData.put(Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString</B></FONT>(maxUnsafeAutoIdTimestamp));
                return liveCommitData.entrySet().iterator();
            });
            writer.commit();
        }
    }

    /**
     * Directory wrapper that records copy process for recovery statistics
     */
    static final class StatsDirectoryWrapper extends FilterDirectory {
        private final RecoveryState.Index index;

        StatsDirectoryWrapper(Directory in, RecoveryState.Index indexRecoveryStats) {
            super(in);
            this.index = indexRecoveryStats;
        }

        @Override
        public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
            final long l = from.fileLength(src);
            final AtomicBoolean copies = new AtomicBoolean(false);
            // here we wrap the index input form the source directory to report progress of file copy for the recovery stats.
            // we increment the num bytes recovered in the readBytes method below, if users pull statistics they can see immediately
            // how much has been recovered.
            in.copyFrom(new FilterDirectory(from) {
                @Override
                public IndexInput openInput(String name, IOContext context) throws IOException {
                    index.addFileDetail(dest, l, false);
                    copies.set(true);
                    final IndexInput input = in.openInput(name, context);
                    return new IndexInput(&quot;StatsDirectoryWrapper(&quot; + input.toString() + &quot;)&quot;) {
                        @Override
                        public void close() throws IOException {
                            input.close();
                        }

                        @Override
                        public long getFilePointer() {
                            throw new UnsupportedOperationException(&quot;only straight copies are supported&quot;);
                        }

                        @Override
                        public void seek(long pos) throws IOException {
                            throw new UnsupportedOperationException(&quot;seeks are not supported&quot;);
                        }

                        @Override
                        public long length() {
                            return input.length();
                        }

                        @Override
                        public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
                            throw new UnsupportedOperationException(&quot;slices are not supported&quot;);
                        }

                        @Override
                        public byte readByte() throws IOException {
                            throw new UnsupportedOperationException(&quot;use a buffer if you wanna perform well&quot;);
                        }

                        @Override
                        public void readBytes(byte[] b, int offset, int len) throws IOException {
                            // we rely on the fact that copyFrom uses a buffer
                            input.readBytes(b, offset, len);
                            index.addRecoveredBytesToFile(dest, len);
                        }
                    };
                }
            }, src, dest, context);
            if (copies.get() == false) {
                index.addFileDetail(dest, l, true); // hardlinked - we treat it as reused since the file was already somewhat there
            } else {
                assert index.getFileDetails(dest) != null : &quot;File [&quot; + dest + &quot;] has no file details&quot;;
                assert index.getFileDetails(dest).recovered() == l : index.getFileDetails(dest).toString();
            }
        }
    }

    /**
     * Recovers an index from a given {@link Repository}. This method restores a
     * previously created index snapshot into an existing initializing shard.
     *
     * @param indexShard the index shard instance to recovery the snapshot from
     * @param repository the repository holding the physical files the shard should be recovered from
     * @param listener resolves to &lt;code&gt;true&lt;/code&gt; if the shard has been recovered successfully, &lt;code&gt;false&lt;/code&gt; if the recovery
     *                 has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.
     */
    void recoverFromRepository(final IndexShard indexShard, Repository repository, ActionListener&lt;Boolean&gt; listener) {
        try {
            if (canRecover(indexShard)) {
                RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
                assert recoveryType == RecoverySource.Type.SNAPSHOT : &quot;expected snapshot recovery type: &quot; + recoveryType;
                SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource();
                restore(indexShard, repository, recoverySource, recoveryListener(indexShard, listener));
            } else {
                listener.onResponse(false);
            }
        } catch (Exception e) {
            listener.onFailure(e);
        }
    }

    private boolean canRecover(IndexShard indexShard) {
        if (indexShard.state() == IndexShardState.CLOSED) {
            // got closed on us, just ignore this recovery
            return false;
        }
        if (indexShard.routingEntry().primary() == false) {
            throw new IndexShardRecoveryException(shardId, &quot;Trying to recover when the shard is in backup state&quot;, null);
        }
        return true;
    }

    private ActionListener&lt;Boolean&gt; recoveryListener(IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
        return ActionListener.wrap(
            res -&gt; {
                if (res) {
                    // Check that the gateway didn't leave the shard in init or recovering stage. it is up to the gateway
                    // to call post recovery.
                    final IndexShardState shardState = indexShard.state();
                    final RecoveryState recoveryState = indexShard.recoveryState();
                    assert shardState != IndexShardState.CREATED &amp;&amp; shardState != IndexShardState.RECOVERING :
                        &quot;recovery process of &quot; + shardId + &quot; didn't get to post_recovery. shardState [&quot; + shardState + &quot;]&quot;;
<A NAME="8"></A>
                    if (logger.isTraceEnabled()) {
<A NAME="7"></A>                        RecoveryState.Index index = recoveryState.getIndex();
                        <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match1907819-1.html#8',3,'match1907819-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>StringBuilder sb = new StringBuilder();
                        sb.append(&quot;    index    : files           [&quot;).append(index.totalFileCount</B></FONT>()).append(&quot;] with total_size [&quot;)
                            .append(<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match1907819-1.html#7',3,'match1907819-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ByteSizeValue(index.totalBytes())).append(&quot;], took[&quot;)
                            .append(TimeValue.timeValueMillis(index.time())).append(&quot;]\n&quot;);
<A NAME="1"></A>                        sb.append(&quot;             : recovered_files [&quot;).append(index.recoveredFileCount</B></FONT>()).append(&quot;] with total_size [&quot;)
                            .append(new ByteSizeValue(index.recoveredBytes())).append(&quot;]\n&quot;);
                        sb.append(&quot;             : reusing_files   [&quot;).append(index.reusedFileCount()).append(&quot;] with total_size [&quot;)
                            .append(new ByteSizeValue(<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1907819-1.html#1',3,'match1907819-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>index.reusedBytes())).append(&quot;]\n&quot;);
                        sb.append(&quot;    verify_index    : took [&quot;)
                            .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append(&quot;], check_index [&quot;)
                            .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append(&quot;]\n&quot;);
                        sb.append(&quot;    translog : number_of_operations [&quot;).append(recoveryState.getTranslog().recoveredOperations())
                            .append(&quot;], took [&quot;).append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append(&quot;]&quot;);
                        logger.trace(&quot;recovery completed from [shard_store], took [{}]\n{}&quot;,
                            timeValueMillis(recoveryState.getTimer().time()), sb);
                    }</B></FONT> else if (logger.isDebugEnabled()) {
                        logger.debug(&quot;recovery completed from [shard_store], took [{}]&quot;, timeValueMillis(recoveryState.getTimer().time()));
                    }
                }
                listener.onResponse(res);
            },
            ex -&gt; {
                if (ex instanceof IndexShardRecoveryException) {
                    if (indexShard.state() == IndexShardState.CLOSED) {
                        // got closed on us, just ignore this recovery
                        listener.onResponse(false);
                        return;
                    }
                    if ((ex.getCause() instanceof IndexShardClosedException) || (ex.getCause() instanceof IndexShardNotStartedException)) {
                        // got closed on us, just ignore this recovery
                        listener.onResponse(false);
                        return;
                    }
                    listener.onFailure(ex);
                } else if (ex instanceof IndexShardClosedException || ex instanceof IndexShardNotStartedException) {
                    listener.onResponse(false);
                } else {
                    if (indexShard.state() == IndexShardState.CLOSED) {
                        // got closed on us, just ignore this recovery
                        listener.onResponse(false);
                    } else {
                        listener.onFailure(new IndexShardRecoveryException(shardId, &quot;failed recovery&quot;, ex));
                    }
                }
            }
        );
    }

    /**
     * Recovers the state of the shard from the store.
     */
    private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {
        final RecoveryState recoveryState = indexShard.recoveryState();
        final boolean indexShouldExists =
            recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE;
        indexShard.prepareForIndexRecovery();
        SegmentInfos si = null;
        final Store store = indexShard.store();
        store.incRef();
        try {
            try {
                store.failIfCorrupted();
                try {
                    si = store.readLastCommittedSegmentsInfo();
                } catch (Exception e) {
                    String files = &quot;_unknown_&quot;;
                    try {
                        files = Arrays.toString(store.directory().listAll());
                    } catch (Exception inner) {
                        files += &quot; (failure=&quot; + ExceptionsHelper.stackTrace(inner) + &quot;)&quot;;
                    }
                    if (indexShouldExists) {
                        throw new IndexShardRecoveryException(shardId,
                            &quot;shard allocated for local recovery (post api), should exist, but doesn't, current files: &quot; +
                            files, e);
                    }
                }
                if (si != null &amp;&amp; indexShouldExists == false) {
                    // it exists on the directory, but shouldn't exist on the FS, its a leftover (possibly dangling)
                    // its a &quot;new index create&quot; API, we have to do something, so better to clean it than use same data
                    logger.trace(&quot;cleaning existing shard, shouldn't exists&quot;);
                    Lucene.cleanLuceneIndex(store.directory());
                    si = null;
                }
            } catch (Exception e) {
                throw new IndexShardRecoveryException(shardId, &quot;failed to fetch index version after copying it over&quot;, e);
            }
            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {
                assert indexShouldExists;
                bootstrap(indexShard, store);
                writeEmptyRetentionLeasesFile(indexShard);
            } else if (indexShouldExists) {
                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {
                    store.bootstrapNewHistory();
                    writeEmptyRetentionLeasesFile(indexShard);
                }
                // since we recover from local, just fill the files and size
                final RecoveryState.Index index = recoveryState.getIndex();
                try {
                    if (si != null) {
                        addRecoveredFileDetails(si, store, index);
                    }
                } catch (IOException e) {
                    logger.debug(&quot;failed to list file details&quot;, e);
<A NAME="3"></A>                }
                index.setFileDetailsComplete();
            } else {
                <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1907819-1.html#3',3,'match1907819-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion);
                final String translogUUID = Translog.createEmptyTranslog(
                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,
                    indexShard.getPendingPrimaryTerm());
                store.associateIndexWithNewTranslog(translogUUID);
<A NAME="6"></A>                writeEmptyRetentionLeasesFile(indexShard);
                indexShard.recoveryState</B></FONT>().getIndex().setFileDetailsComplete();
            }
            <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match1907819-1.html#6',3,'match1907819-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>indexShard.openEngineAndRecoverFromTranslog();
            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
            indexShard.finalizeRecovery();
            indexShard.postRecovery(&quot;post recovery from shard_store&quot;);
        } catch (EngineException | IOException e) {</B></FONT>
            throw new IndexShardRecoveryException(shardId, &quot;failed to recover from gateway&quot;, e);
        } finally {
            store.decRef();
        }
    }

    private static void writeEmptyRetentionLeasesFile(IndexShard indexShard) throws IOException {
        assert indexShard.getRetentionLeases().leases().isEmpty() : indexShard.getRetentionLeases(); // not loaded yet
        indexShard.persistRetentionLeases();
        assert indexShard.loadRetentionLeases().leases().isEmpty();
    }

    private void addRecoveredFileDetails(SegmentInfos si, Store store, RecoveryState.Index index) throws IOException {
        final Directory directory = store.directory();
        for (String name : Lucene.files(si)) {
            long length = directory.fileLength(name);
            index.addFileDetail(name, length, true);
        }
    }

    /**
     * Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table
     */
    private void restore(IndexShard indexShard, Repository repository, SnapshotRecoverySource restoreSource,
                         ActionListener&lt;Boolean&gt; listener) {
        logger.debug(&quot;restoring from {} ...&quot;, indexShard.recoveryState().getRecoverySource());
        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog();
        if (restoreSource == null) {
            listener.onFailure(new IndexShardRestoreFailedException(shardId, &quot;empty restore source&quot;));
            return;
        }
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;[{}] restoring shard [{}]&quot;, restoreSource.snapshot(), shardId);
        }
        final ActionListener&lt;Void&gt; restoreListener = ActionListener.wrap(
<A NAME="5"></A>            v -&gt; {
                final Store store = indexShard.store();
                bootstrap(indexShard, store);
                assert <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1907819-1.html#5',3,'match1907819-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>indexShard.shardRouting.primary() : &quot;only primary shards can recover from store&quot;;
                writeEmptyRetentionLeasesFile(indexShard);
                indexShard.openEngineAndRecoverFromTranslog();
                indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
                indexShard.finalizeRecovery();
                indexShard.postRecovery(&quot;restore done&quot;);
                listener.onResponse(true);
            }</B></FONT>, e -&gt; listener.onFailure(new IndexShardRestoreFailedException(shardId, &quot;restore failed&quot;, e))
        );
        try {
            translogState.totalOperations(0);
            translogState.totalOperationsOnStart(0);
            indexShard.prepareForIndexRecovery();
            final ShardId snapshotShardId;
            final String indexName = restoreSource.index();
            if (!shardId.getIndexName().equals(indexName)) {
                snapshotShardId = new ShardId(indexName, IndexMetadata.INDEX_UUID_NA_VALUE, shardId.id());
            } else {
                snapshotShardId = shardId;
            }
            repository.getRepositoryData(ActionListener.wrap(
                repositoryData -&gt; {
                    final IndexId indexId = repositoryData.resolveIndexId(indexName);
                    assert indexShard.getEngineOrNull() == null;
                    repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,
                        indexShard.recoveryState(), restoreListener);
                }, restoreListener::onFailure
            ));
        } catch (Exception e) {
            restoreListener.onFailure(e);
        }
    }
<A NAME="4"></A>
    private void bootstrap(final IndexShard indexShard, final Store store) throws IOException {
        store.bootstrapNewHistory();
        final SegmentInfos segmentInfos = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1907819-1.html#4',3,'match1907819-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>store.readLastCommittedSegmentsInfo();
        final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
        final String translogUUID = Translog.createEmptyTranslog(
            indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());
        store.associateIndexWithNewTranslog</B></FONT>(translogUUID);
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScopedSettingsTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
<A NAME="0"></A> * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#0',2,'match1907819-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.common.settings;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.Matchers.hasToString;
import static org.hamcrest.Matchers.sameInstance;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.elasticsearch.Version;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;
import org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider;
import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocationDecider;
import org.elasticsearch.common.logging.Loggers;
import org.elasticsearch.common.settings.Setting.Property;
import org.elasticsearch.index.IndexModule;
import org.elasticsearch.test.ESTestCase;
import org.elasticsearch.transport.TransportSettings;
import org.junit.Test;

import io.crate.types.ArrayType;
import</B></FONT> io.crate.types.DataTypes;

public class ScopedSettingsTests extends ESTestCase {

    @Test
    public void testResetSetting() {
        Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting(&quot;some.dyn.setting&quot;, 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; staticSetting = Setting.intSetting(&quot;some.static.setting&quot;, 1, Property.NodeScope);
<A NAME="7"></A>        Settings currentSettings = Settings.builder().put(&quot;some.dyn.setting&quot;, 5).put(&quot;some.static.setting&quot;, 6).put(&quot;archived.foo.bar&quot;, 9)
            .build();
        ClusterSettings service = new ClusterSettings(currentSettings
            , <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#7',2,'match1907819-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, staticSetting)));
<A NAME="4"></A>
        expectThrows(IllegalArgumentException.class, () -&gt;
        service.updateDynamicSettings(Settings.builder().put(&quot;some.dyn.setting&quot;, 8).putNull(&quot;some.static.setting&quot;).build(),
            Settings.builder</B></FONT>().put(currentSettings), <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#4',2,'match1907819-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Settings.builder(), &quot;node&quot;));

        Settings.Builder target = Settings.builder().put(currentSettings);
        Settings.Builder update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().put</B></FONT>(&quot;some.dyn.setting&quot;, 8).build(),
            target, update, &quot;node&quot;));
        assertEquals(8, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt(&quot;archived.foo.bar&quot;, null).intValue());

        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull(&quot;some.dyn.setting&quot;).build(),
            target, update, &quot;node&quot;));
        assertEquals(1, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt(&quot;archived.foo.bar&quot;, null).intValue());

        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull(&quot;archived.foo.bar&quot;).build(),
            target, update, &quot;node&quot;));
        assertEquals(5, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertNull(target.build().getAsInt(&quot;archived.foo.bar&quot;, null));

        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull(&quot;some.*&quot;).build(),
            target, update, &quot;node&quot;));
        assertEquals(1, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt(&quot;archived.foo.bar&quot;, null).intValue());

        target = Settings.builder().put(currentSettings);
<A NAME="5"></A>        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull(&quot;*&quot;).build(),
            target, update, &quot;node&quot;));
        assertEquals(1, <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#5',2,'match1907819-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertNull(target.build().getAsInt(&quot;archived.foo.bar&quot;, null));
    }</B></FONT>

    @Test
    public void testResetSettingWithIPValidator() {
        Settings currentSettings = Settings.builder().put(&quot;index.routing.allocation.require._ip&quot;, &quot;192.168.0.1,127.0.0.1&quot;)
            .put(&quot;index.some.dyn.setting&quot;, 1)
            .build();
        Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting(&quot;index.some.dyn.setting&quot;, 1, Property.Dynamic, Property.IndexScope);

        IndexScopedSettings settings = new IndexScopedSettings(currentSettings,
            new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING)));
        Map&lt;String, String&gt; s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
        assertEquals(1, s.size());
        assertEquals(&quot;192.168.0.1,127.0.0.1&quot;, s.get(&quot;_ip&quot;));
        Settings.Builder builder = Settings.builder();
        Settings updates = Settings.builder().putNull(&quot;index.routing.allocation.require._ip&quot;)
            .put(&quot;index.some.dyn.setting&quot;, 1).build();
        settings.validate(updates, false);
        settings.updateDynamicSettings(updates,
            Settings.builder().put(currentSettings), builder, &quot;node&quot;);
        currentSettings = builder.build();
        s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
        assertEquals(0, s.size());
        assertEquals(1, dynamicSetting.get(currentSettings).intValue());
        assertEquals(1, currentSettings.size());
    }

    @Test
    public void testAddConsumer() {
        Setting&lt;Integer&gt; testSetting = Setting.intSetting(&quot;foo.bar&quot;, 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; testSetting2 = Setting.intSetting(&quot;foo.bar.baz&quot;, 1, Property.Dynamic, Property.NodeScope);
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, Collections.singleton(testSetting));

        AtomicInteger consumer = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, consumer::set);
        AtomicInteger consumer2 = new AtomicInteger();
        try {
            service.addSettingsUpdateConsumer(testSetting2, consumer2::set);
            fail(&quot;setting not registered&quot;);
        } catch (IllegalArgumentException ex) {
            assertEquals(&quot;Setting is not registered for key [foo.bar.baz]&quot;, ex.getMessage());
        }

        try {
            service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
                consumer.set(a);
                consumer2.set(b);
            });
            fail(&quot;setting not registered&quot;);
        } catch (IllegalArgumentException ex) {
            assertEquals(&quot;Setting is not registered for key [foo.bar.baz]&quot;, ex.getMessage());
        }
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        service.applySettings(Settings.builder().put(&quot;foo.bar&quot;, 2).put(&quot;foo.bar.baz&quot;, 15).build());
        assertEquals(2, consumer.get());
        assertEquals(0, consumer2.get());
    }

    @Test
    public void testDependentSettings() {
        Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;name&quot;,
            (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;bar&quot;,
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope), () -&gt; stringSetting);

        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));

        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
            () -&gt; service.validate(Settings.builder().put(&quot;foo.test.bar&quot;, 7).build(), true));
        assertEquals(&quot;missing required setting [foo.test.name] for setting [foo.test.bar]&quot;, iae.getMessage());

        service.validate(Settings.builder()
            .put(&quot;foo.test.name&quot;, &quot;test&quot;)
            .put(&quot;foo.test.bar&quot;, 7)
            .build(), true);

        service.validate(Settings.builder().put(&quot;foo.test.bar&quot;, 7).build(), false);
    }

    @Test
    public void testDependentSettingsValidate() {
        Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting(
            &quot;foo.&quot;,
            &quot;name&quot;,
            (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(
            &quot;foo.&quot;,
            &quot;bar&quot;,
            (k) -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
            new Setting.AffixSettingDependency() {

                @Override
                public Setting.AffixSetting getSetting() {
                    return stringSetting;
                }

                @Override
                public void validate(final String key, final Object value, final Object dependency) {
                    if (&quot;valid&quot;.equals(dependency) == false) {
                        throw new SettingsException(&quot;[&quot; + key + &quot;] is set but [name] is [&quot; + dependency + &quot;]&quot;);
                    }
                }
            });

        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));

        SettingsException iae = expectThrows(
            SettingsException.class,
            () -&gt; service.validate(Settings.builder().put(&quot;foo.test.bar&quot;, 7).put(&quot;foo.test.name&quot;, &quot;invalid&quot;).build(), true));
        assertEquals(&quot;[foo.test.bar] is set but [name] is [invalid]&quot;, iae.getMessage());

        service.validate(Settings.builder()
                .put(&quot;foo.test.bar&quot;, 7)
                .put(&quot;foo.test.name&quot;, &quot;valid&quot;)
                .build(),
            true);

        service.validate(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 7)
            .put(&quot;foo.test.name&quot;, &quot;invalid&quot;)
            .build(),
            false);
    }

    public void testDependentSettingsWithFallback() {
        Setting.AffixSetting&lt;String&gt; nameFallbackSetting =
                Setting.affixKeySetting(&quot;fallback.&quot;, &quot;name&quot;, k -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;String&gt; nameSetting = Setting.affixKeySetting(
                &quot;foo.&quot;,
                &quot;name&quot;,
                k -&gt; Setting.simpleString(
                        k,
                        &quot;_na_&quot;.equals(k)
                                ? nameFallbackSetting.getConcreteSettingForNamespace(k)
                                : nameFallbackSetting.getConcreteSetting(k.replaceAll(&quot;^foo&quot;, &quot;fallback&quot;)),
                        Property.Dynamic,
                        Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; barSetting = Setting.affixKeySetting(
            &quot;foo.&quot;,
            &quot;bar&quot;,
            k -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
            () -&gt; nameSetting);

        final AbstractScopedSettings service =
                new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(nameFallbackSetting, nameSetting, barSetting)));

        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; service.validate(Settings.builder().put(&quot;foo.test.bar&quot;, 7).build(), true));
        assertThat(e, hasToString(containsString(&quot;missing required setting [foo.test.name] for setting [foo.test.bar]&quot;)));

        service.validate(Settings.builder().put(&quot;foo.test.name&quot;, &quot;test&quot;).put(&quot;foo.test.bar&quot;, 7).build(), true);
        service.validate(Settings.builder().put(&quot;fallback.test.name&quot;, &quot;test&quot;).put(&quot;foo.test.bar&quot;, 7).build(), true);
    }

    @Test
    public void testAddConsumerAffix() {
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;bar&quot;,
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;list&quot;,
            (k) -&gt; Setting.listSetting(k, Arrays.asList(&quot;1&quot;), Integer::parseInt, new ArrayType&lt;&gt;(DataTypes.INTEGER), Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
        Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();

        BiConsumer&lt;String, Integer&gt; intConsumer = intResults::put;
        BiConsumer&lt;String, List&lt;Integer&gt;&gt; listConsumer = listResults::put;

        service.addAffixUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
        service.addAffixUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
        assertEquals(0, listResults.size());
        assertEquals(0, intResults.size());
        service.applySettings(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 2)
            .put(&quot;foo.test_1.bar&quot;, 7)
            .putList(&quot;foo.test_list.list&quot;, &quot;16&quot;, &quot;17&quot;)
            .putList(&quot;foo.test_list_1.list&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;)
            .build());
        assertEquals(2, intResults.get(&quot;test&quot;).intValue());
<A NAME="1"></A>        assertEquals(7, intResults.get(&quot;test_1&quot;).intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get(&quot;test_list&quot;));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get(&quot;test_list_1&quot;));
        assertEquals(2, <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#1',2,'match1907819-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>listResults.size());
        assertEquals(2, intResults.size());

        listResults.clear();
        intResults.clear();

        service.applySettings(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 2)
            .put(&quot;foo.test_1.bar&quot;, 8)
            .putList(&quot;foo.test_list.list&quot;, &quot;16&quot;, &quot;17&quot;)
            .putNull(&quot;foo.test_list_1.list&quot;)
            .build());
        assertNull(&quot;test wasn't changed&quot;, intResults.get(&quot;test&quot;));
        assertEquals(8, intResults.get(&quot;test_1&quot;).intValue());
        assertNull(&quot;test_list wasn't changed&quot;, listResults.get(&quot;test_list&quot;));
        assertEquals(Arrays.asList(1), listResults.get(&quot;test_list_1&quot;)); // reset to default
        assertEquals(1, listResults.size());
        assertEquals(1, intResults.size());
    }</B></FONT>


    @Test
    public void testAddConsumerAffixMap() {
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;bar&quot;,
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting(&quot;foo.&quot;, &quot;list&quot;,
            (k) -&gt; Setting.listSetting(k, Arrays.asList(&quot;1&quot;), Integer::parseInt, DataTypes.INTEGER_ARRAY, Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
        Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();

        Consumer&lt;Map&lt;String,Integer&gt;&gt; intConsumer = (map) -&gt; {
            intResults.clear();
            intResults.putAll(map);
        };
        Consumer&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt; listConsumer = (map) -&gt; {
            listResults.clear();
            listResults.putAll(map);
        };
        service.addAffixMapUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
        service.addAffixMapUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
        assertEquals(0, listResults.size());
        assertEquals(0, intResults.size());
        service.applySettings(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 2)
            .put(&quot;foo.test_1.bar&quot;, 7)
            .putList(&quot;foo.test_list.list&quot;, &quot;16&quot;, &quot;17&quot;)
            .putList(&quot;foo.test_list_1.list&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;)
            .build());
        assertEquals(2, intResults.get(&quot;test&quot;).intValue());
        assertEquals(7, intResults.get(&quot;test_1&quot;).intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get(&quot;test_list&quot;));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get(&quot;test_list_1&quot;));
        assertEquals(2, listResults.size());
        assertEquals(2, intResults.size());

        service.applySettings(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 2)
            .put(&quot;foo.test_1.bar&quot;, 7)
            .putList(&quot;foo.test_list.list&quot;, &quot;16&quot;, &quot;17&quot;)
            .putList(&quot;foo.test_list_1.list&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;)
            .build());

        assertEquals(2, intResults.get(&quot;test&quot;).intValue());
        assertEquals(7, intResults.get(&quot;test_1&quot;).intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get(&quot;test_list&quot;));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get(&quot;test_list_1&quot;));
        assertEquals(2, listResults.size());
        assertEquals(2, intResults.size());

        listResults.clear();
        intResults.clear();

        service.applySettings(Settings.builder()
            .put(&quot;foo.test.bar&quot;, 2)
            .put(&quot;foo.test_1.bar&quot;, 8)
            .putList(&quot;foo.test_list.list&quot;, &quot;16&quot;, &quot;17&quot;)
            .putNull(&quot;foo.test_list_1.list&quot;)
            .build());
        assertNull(&quot;test wasn't changed&quot;, intResults.get(&quot;test&quot;));
        assertEquals(8, intResults.get(&quot;test_1&quot;).intValue());
        assertNull(&quot;test_list wasn't changed&quot;, listResults.get(&quot;test_list&quot;));
        assertEquals(Arrays.asList(1), listResults.get(&quot;test_list_1&quot;)); // reset to default
        assertEquals(1, listResults.size());
        assertEquals(1, intResults.size());
    }

    @Test
    public void testAffixMapConsumerNotCalledWithNull() {
        Setting.AffixSetting&lt;Integer&gt; prefixSetting = Setting.prefixKeySetting(&quot;eggplant.&quot;,
                (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; otherSetting = Setting.prefixKeySetting(&quot;other.&quot;,
                (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(prefixSetting, otherSetting)));
        Map&lt;String, Integer&gt; affixResults = new HashMap&lt;&gt;();

        Consumer&lt;Map&lt;String,Integer&gt;&gt; consumer = (map) -&gt; {
            logger.info(&quot;--&gt; consuming settings {}&quot;, map);
            affixResults.clear();
            affixResults.putAll(map);
        };
        service.addAffixMapUpdateConsumer(prefixSetting, consumer, (s, k) -&gt; {});
        assertEquals(0, affixResults.size());
        service.applySettings(Settings.builder()
                .put(&quot;eggplant._name&quot;, 2)
                .build());
        assertThat(affixResults.size(), equalTo(1));
        assertThat(affixResults.get(&quot;_name&quot;), equalTo(2));

        service.applySettings(Settings.builder()
                .put(&quot;eggplant._name&quot;, 2)
                .put(&quot;other.thing&quot;, 3)
                .build());

        assertThat(affixResults.get(&quot;_name&quot;), equalTo(2));
    }


    @Test
    public void testApply() {
        Setting&lt;Integer&gt; testSetting = Setting.intSetting(&quot;foo.bar&quot;, 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; testSetting2 = Setting.intSetting(&quot;foo.bar.baz&quot;, 1, Property.Dynamic, Property.NodeScope);
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(testSetting, testSetting2)));

        AtomicInteger consumer = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, consumer::set);
        AtomicInteger consumer2 = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting2, consumer2::set, (s) -&gt; assertTrue(s &gt; 0));

        AtomicInteger aC = new AtomicInteger();
        AtomicInteger bC = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
            aC.set(a);
            bC.set(b);
        });

        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
<A NAME="6"></A>        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        try {
            <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#6',2,'match1907819-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>service.applySettings(Settings.builder().put(&quot;foo.bar&quot;, 2).put(&quot;foo.bar.baz&quot;, -15).build());
            fail(&quot;invalid value&quot;);
        } catch (IllegalArgumentException ex) {</B></FONT>
            assertEquals(&quot;illegal value can't update [foo.bar.baz] from [1] to [-15]&quot;, ex.getMessage());
        }
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        try {
            service.validateUpdate(Settings.builder().put(&quot;foo.bar&quot;, 2).put(&quot;foo.bar.baz&quot;, -15).build());
            fail(&quot;invalid value&quot;);
        } catch (IllegalArgumentException ex) {
            assertEquals(&quot;illegal value can't update [foo.bar.baz] from [1] to [-15]&quot;, ex.getMessage());
        }

        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        service.validateUpdate(Settings.builder().put(&quot;foo.bar&quot;, 2).put(&quot;foo.bar.baz&quot;, 15).build());
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());

        service.applySettings(Settings.builder().put(&quot;foo.bar&quot;, 2).put(&quot;foo.bar.baz&quot;, 15).build());
        assertEquals(2, consumer.get());
        assertEquals(15, consumer2.get());
        assertEquals(2, aC.get());
        assertEquals(15, bC.get());
    }

    @Test
    public void testGet() {
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        // affix setting - complex matcher
        Setting setting = settings.get(&quot;cluster.routing.allocation.require.value&quot;);
        assertEquals(setting,
            FilterAllocationDecider.CLUSTER_ROUTING_REQUIRE_GROUP_SETTING.getConcreteSetting(&quot;cluster.routing.allocation.require.value&quot;));

        setting = settings.get(&quot;cluster.routing.allocation.total_shards_per_node&quot;);
        assertEquals(setting, ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING);

        // array settings - complex matcher
        assertNotNull(settings.get(&quot;transport.tracer.include.&quot; + randomIntBetween(1, 100)));
        assertSame(TransportSettings.TRACE_LOG_INCLUDE_SETTING, settings.get(&quot;transport.tracer.include.&quot; + randomIntBetween(1, 100)));

        // array settings - complex matcher - only accepts numbers
        assertNull(settings.get(&quot;transport.tracer.include.FOO&quot;));
    }

    @Test
    public void testIsDynamic(){
        ClusterSettings settings =
            new ClusterSettings(Settings.EMPTY,
                new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting(&quot;foo.bar&quot;, 1, Property.Dynamic, Property.NodeScope),
                    Setting.intSetting(&quot;foo.bar.baz&quot;, 1, Property.NodeScope))));
        assertFalse(settings.isDynamicSetting(&quot;foo.bar.baz&quot;));
        assertTrue(settings.isDynamicSetting(&quot;foo.bar&quot;));
        assertNotNull(settings.get(&quot;foo.bar.baz&quot;));
        settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        assertTrue(settings.isDynamicSetting(&quot;transport.tracer.include.&quot; + randomIntBetween(1, 100)));
        assertFalse(settings.isDynamicSetting(&quot;transport.tracer.include.BOOM&quot;));
        assertTrue(settings.isDynamicSetting(&quot;cluster.routing.allocation.require.value&quot;));
    }

    @Test
    public void testIsFinal() {
        ClusterSettings settings =
            new ClusterSettings(Settings.EMPTY,
                new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting(&quot;foo.int&quot;, 1, Property.Final, Property.NodeScope),
                    Setting.groupSetting(&quot;foo.group.&quot;,  Property.Final, Property.NodeScope),
                    Setting.groupSetting(&quot;foo.list.&quot;,  Property.Final, Property.NodeScope),
                    Setting.intSetting(&quot;foo.int.baz&quot;, 1, Property.NodeScope))));

        assertFalse(settings.isFinalSetting(&quot;foo.int.baz&quot;));
        assertTrue(settings.isFinalSetting(&quot;foo.int&quot;));

        assertFalse(settings.isFinalSetting(&quot;foo.list&quot;));
        assertTrue(settings.isFinalSetting(&quot;foo.list.0.key&quot;));
        assertTrue(settings.isFinalSetting(&quot;foo.list.key&quot;));

        assertFalse(settings.isFinalSetting(&quot;foo.group&quot;));
        assertTrue(settings.isFinalSetting(&quot;foo.group.key&quot;));
    }

    @Test
    public void testDiff() throws IOException {
        Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting(&quot;foo.bar.baz&quot;, 1, Property.NodeScope);
        Setting&lt;Integer&gt; fooBar = Setting.intSetting(&quot;foo.bar&quot;, 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Settings&gt; someGroup = Setting.groupSetting(&quot;some.group.&quot;, Property.Dynamic, Property.NodeScope);
        Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting(&quot;some.prefix.&quot;, &quot;somekey&quot;, (key) -&gt; Setting.boolSetting(key, true,
            Property.NodeScope));
        Setting&lt;List&lt;String&gt;&gt; foorBarQuux =
                Setting.listSetting(&quot;foo.bar.quux&quot;, Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), Function.identity(), DataTypes.STRING, Property.NodeScope);
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
            someGroup, someAffix)));
        Settings diff = settings.diff(Settings.builder().put(&quot;foo.bar&quot;, 5).build(), Settings.EMPTY);
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));

        diff = settings.diff(
                Settings.builder().put(&quot;foo.bar&quot;, 5).build(),
                Settings.builder().put(&quot;foo.bar.baz&quot;, 17).putList(&quot;foo.bar.quux&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;).build());
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(17));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));

        diff = settings.diff(
            Settings.builder().put(&quot;some.group.foo&quot;, 5).build(),
            Settings.builder().put(&quot;some.group.foobar&quot;, 17).put(&quot;some.group.foo&quot;, 25).build());
        assertEquals(4, diff.size());
        assertThat(diff.getAsInt(&quot;some.group.foobar&quot;, null), equalTo(17));
        assertNull(diff.get(&quot;some.group.foo&quot;));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertThat(diff.getAsInt(&quot;foo.bar&quot;, null), equalTo(1));

        diff = settings.diff(
            Settings.builder().put(&quot;some.prefix.foo.somekey&quot;, 5).build(),
            Settings.builder().put(&quot;some.prefix.foobar.somekey&quot;, 17).put(&quot;some.prefix.foo.somekey&quot;, 18).build());
        assertEquals(4, diff.size());
        assertThat(diff.getAsInt(&quot;some.prefix.foobar.somekey&quot;, null), equalTo(17));
        assertNull(diff.get(&quot;some.prefix.foo.somekey&quot;));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertThat(diff.getAsInt(&quot;foo.bar&quot;, null), equalTo(1));
    }

    @Test
    public void testDiffWithAffixAndComplexMatcher() {
        Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting(&quot;foo.bar.baz&quot;, 1, Property.NodeScope);
        Setting&lt;Integer&gt; fooBar = Setting.intSetting(&quot;foo.bar&quot;, 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Settings&gt; someGroup = Setting.groupSetting(&quot;some.group.&quot;, Property.Dynamic, Property.NodeScope);
        Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting(&quot;some.prefix.&quot;, &quot;somekey&quot;, (key) -&gt; Setting.boolSetting(key, true,
            Property.NodeScope));
        Setting&lt;List&lt;String&gt;&gt; foorBarQuux = Setting.affixKeySetting(&quot;foo.&quot;, &quot;quux&quot;,
            (key) -&gt; Setting.listSetting(key,  Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope));
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
            someGroup, someAffix)));
        Settings diff = settings.diff(Settings.builder().put(&quot;foo.bar&quot;, 5).build(), Settings.EMPTY);
        assertEquals(1, diff.size());
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertNull(diff.getAsList(&quot;foo.bar.quux&quot;, null)); // affix settings don't know their concrete keys

        diff = settings.diff(
            Settings.builder().put(&quot;foo.bar&quot;, 5).build(),
            Settings.builder().put(&quot;foo.bar.baz&quot;, 17).putList(&quot;foo.bar.quux&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;).build());
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(17));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));

        diff = settings.diff(
            Settings.builder().put(&quot;some.group.foo&quot;, 5).build(),
            Settings.builder().put(&quot;some.group.foobar&quot;, 17).put(&quot;some.group.foo&quot;, 25).build());
        assertEquals(3, diff.size());
        assertThat(diff.getAsInt(&quot;some.group.foobar&quot;, null), equalTo(17));
        assertNull(diff.get(&quot;some.group.foo&quot;));
        assertNull(diff.getAsList(&quot;foo.bar.quux&quot;, null)); // affix settings don't know their concrete keys
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertThat(diff.getAsInt(&quot;foo.bar&quot;, null), equalTo(1));

        diff = settings.diff(
            Settings.builder().put(&quot;some.prefix.foo.somekey&quot;, 5).build(),
            Settings.builder().put(&quot;some.prefix.foobar.somekey&quot;, 17).put(&quot;some.prefix.foo.somekey&quot;, 18).build());
        assertEquals(3, diff.size());
        assertThat(diff.getAsInt(&quot;some.prefix.foobar.somekey&quot;, null), equalTo(17));
        assertNull(diff.get(&quot;some.prefix.foo.somekey&quot;));
        assertNull(diff.getAsList(&quot;foo.bar.quux&quot;, null)); // affix settings don't know their concrete keys
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertThat(diff.getAsInt(&quot;foo.bar&quot;, null), equalTo(1));

        diff = settings.diff(
            Settings.builder().put(&quot;some.prefix.foo.somekey&quot;, 5).build(),
            Settings.builder().put(&quot;some.prefix.foobar.somekey&quot;, 17).put(&quot;some.prefix.foo.somekey&quot;, 18)
            .putList(&quot;foo.bar.quux&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
            .putList(&quot;foo.baz.quux&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;)
                .build());
        assertEquals(5, diff.size());
        assertThat(diff.getAsInt(&quot;some.prefix.foobar.somekey&quot;, null), equalTo(17));
        assertNull(diff.get(&quot;some.prefix.foo.somekey&quot;));
        assertEquals(diff.getAsList(&quot;foo.bar.quux&quot;, null), Arrays.asList(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
        assertEquals(diff.getAsList(&quot;foo.baz.quux&quot;, null), Arrays.asList(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));
        assertThat(diff.getAsInt(&quot;foo.bar.baz&quot;, null), equalTo(1));
        assertThat(diff.getAsInt(&quot;foo.bar&quot;, null), equalTo(1));
    }

<A NAME="8"></A>    @Test
    public void testUpdateTracer() {
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#8',2,'match1907819-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>AtomicReference&lt;List&lt;String&gt;&gt; ref = new AtomicReference&lt;&gt;();
        settings.addSettingsUpdateConsumer(TransportSettings.TRACE_LOG_INCLUDE_SETTING, ref::set);
        settings.applySettings(Settings.builder()
                .putList(&quot;transport.tracer.include&quot;, &quot;internal:index/shard/recovery/*&quot;, &quot;internal:gateway/local*&quot;).build());
        assertNotNull(ref.get</B></FONT>().size());
        assertEquals(ref.get().size(), 2);
        assertTrue(ref.get().contains(&quot;internal:index/shard/recovery/*&quot;));
        assertTrue(ref.get().contains(&quot;internal:gateway/local*&quot;));
    }

    @Test
    public void testGetSetting() {
        IndexScopedSettings settings = new IndexScopedSettings(
           Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IndexScopedSettings copy = settings.copy(Settings.builder().put(&quot;index.store.type&quot;, &quot;boom&quot;).build(),
                newIndexMeta(&quot;foo&quot;, Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 3).build()));
        assertEquals(3, copy.get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING).intValue());
        assertEquals(1, copy.get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING).intValue());
        assertEquals(&quot;boom&quot;, copy.get(IndexModule.INDEX_STORE_TYPE_SETTING)); // test fallback to node settings
    }

    @Test
    public void testValidateWithSuggestion() {
        IndexScopedSettings settings = new IndexScopedSettings(
            Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
            () -&gt; settings.validate(Settings.builder().put(&quot;index.numbe_of_replica&quot;, &quot;1&quot;).build(), false));
        assertEquals(iae.getMessage(), &quot;unknown setting [index.numbe_of_replica] did you mean [index.number_of_replicas]?&quot;);
    }

    @Test
    public void testValidate() {
        IndexScopedSettings settings = new IndexScopedSettings(
            Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        String unknownMsgSuffix = &quot; please check that any required plugins are installed, or check the breaking changes documentation for&quot; +
            &quot; removed settings&quot;;
        settings.validate(Settings.builder().put(&quot;index.store.type&quot;, &quot;boom&quot;).build(), false);

        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate(Settings.builder().put(&quot;index.store.type&quot;, &quot;boom&quot;).put(&quot;i.am.not.a.setting&quot;, true).build(), false));
        assertEquals(&quot;unknown setting [i.am.not.a.setting]&quot; + unknownMsgSuffix, e.getMessage());

        e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate(Settings.builder().put(&quot;index.store.type&quot;, &quot;boom&quot;).put(&quot;index.number_of_replicas&quot;, true).build(), false));
        assertEquals(&quot;Failed to parse value [true] for setting [index.number_of_replicas]&quot;, e.getMessage());

        e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate(&quot;index.number_of_replicas&quot;, Settings.builder().put(&quot;index.number_of_replicas&quot;, &quot;true&quot;).build(), false));
        assertEquals(&quot;Failed to parse value [true] for setting [index.number_of_replicas]&quot;, e.getMessage());
    }

    public static IndexMetadata newIndexMeta(String name, Settings indexSettings) {
        Settings build = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)
            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1)
            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)
            .put(indexSettings)
            .build();
        IndexMetadata metadata = IndexMetadata.builder(name).settings(build).build();
        return metadata;
    }

    @Test
    public void testKeyPattern() {
        assertTrue(AbstractScopedSettings.isValidKey(&quot;a.b.c-b.d&quot;));
        assertTrue(AbstractScopedSettings.isValidKey(&quot;a.b.c.d&quot;));
        assertTrue(AbstractScopedSettings.isValidKey(&quot;a.b_012.c_b.d&quot;));
        assertTrue(AbstractScopedSettings.isValidKey(&quot;a&quot;));
        assertFalse(AbstractScopedSettings.isValidKey(&quot;a b&quot;));
        assertFalse(AbstractScopedSettings.isValidKey(&quot;&quot;));
        assertFalse(AbstractScopedSettings.isValidKey(&quot;\&quot;&quot;));

        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.groupSetting(&quot;foo.bar.&quot;, Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals(&quot;illegal settings key: [foo.bar.] must start with [index.]&quot;, e.getMessage());
        }

        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.simpleString(&quot;foo.bar&quot;, Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals(&quot;illegal settings key: [foo.bar] must start with [index.]&quot;, e.getMessage());
        }

        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.groupSetting(&quot;index. foo.&quot;, Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals(&quot;illegal settings key: [index. foo.]&quot;, e.getMessage());
        }
        new IndexScopedSettings(
            Settings.EMPTY, Collections.singleton(Setting.groupSetting(&quot;index.&quot;, Property.IndexScope)));
        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.boolSetting(&quot;index.&quot;, true, Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals(&quot;illegal settings key: [index.]&quot;, e.getMessage());
        }
        new IndexScopedSettings(
            Settings.EMPTY, Collections.singleton(Setting.boolSetting(&quot;index.boo&quot;, true, Property.IndexScope)));

        new ClusterSettings(
            Settings.EMPTY, Collections.singleton(Setting.boolSetting(&quot;index.boo&quot;, true, Property.NodeScope)));
    }

    @Test
    public void testAffixKeyPattern() {
        assertTrue(AbstractScopedSettings.isValidAffixKey(&quot;prefix.*.suffix&quot;));
        assertTrue(AbstractScopedSettings.isValidAffixKey(&quot;prefix.*.split.suffix&quot;));
        assertTrue(AbstractScopedSettings.isValidAffixKey(&quot;split.prefix.*.split.suffix&quot;));
        assertFalse(AbstractScopedSettings.isValidAffixKey(&quot;prefix.*.suffix.&quot;));
        assertFalse(AbstractScopedSettings.isValidAffixKey(&quot;prefix.*&quot;));
        assertFalse(AbstractScopedSettings.isValidAffixKey(&quot;*.suffix&quot;));
        assertFalse(AbstractScopedSettings.isValidAffixKey(&quot;*&quot;));
        assertFalse(AbstractScopedSettings.isValidAffixKey(&quot;&quot;));
    }

    @Test
    public void testLoggingUpdates() {
        final Level level = LogManager.getRootLogger().getLevel();
        final Level testLevel = LogManager.getLogger(&quot;test&quot;).getLevel();
        Level property = randomFrom(Level.values());
        Settings.Builder builder = Settings.builder().put(&quot;logger.level&quot;, property);
        try {
            ClusterSettings settings = new ClusterSettings(builder.build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
            IllegalArgumentException ex =
                expectThrows(
                    IllegalArgumentException.class,
                    () -&gt; settings.validate(Settings.builder().put(&quot;logger._root&quot;, &quot;boom&quot;).build(), false));
            assertEquals(&quot;Unknown level constant [BOOM].&quot;, ex.getMessage());
            assertEquals(level, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().put(&quot;logger._root&quot;, &quot;TRACE&quot;).build());
            assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().build());
            assertEquals(property, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().put(&quot;logger.test&quot;, &quot;TRACE&quot;).build());
            assertEquals(Level.TRACE, LogManager.getLogger(&quot;test&quot;).getLevel());
            settings.applySettings(Settings.builder().build());
            assertEquals(property, LogManager.getLogger(&quot;test&quot;).getLevel());
        } finally {
            Loggers.setLevel(LogManager.getRootLogger(), level);
            Loggers.setLevel(LogManager.getLogger(&quot;test&quot;), testLevel);
        }
    }

<A NAME="9"></A>    @Test
    public void testFallbackToLoggerLevel() {
        final Level level = LogManager.getRootLogger().getLevel();
        try <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#9',2,'match1907819-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            ClusterSettings settings =
                new ClusterSettings(Settings.builder().put(&quot;logger.level&quot;, &quot;ERROR&quot;).build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
            assertEquals(level, LogManager.getRootLogger</B></FONT>().getLevel());
            settings.applySettings(Settings.builder().put(&quot;logger._root&quot;, &quot;TRACE&quot;).build());
            assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().build()); // here we fall back to 'logger.level' which is our default.
            assertEquals(Level.ERROR, LogManager.getRootLogger().getLevel());
        } finally {
            Loggers.setLevel(LogManager.getRootLogger(), level);
        }
    }

    @Test
    public void testOverlappingComplexMatchSettings() {
        Set&lt;Setting&lt;?&gt;&gt; settings = new LinkedHashSet&lt;&gt;(2);
        final boolean groupFirst = randomBoolean();
        final Setting&lt;?&gt; groupSetting = Setting.groupSetting(&quot;foo.&quot;, Property.NodeScope);
        final Setting&lt;?&gt; listSetting =
            Setting.listSetting(&quot;foo.bar&quot;, Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
        settings.add(groupFirst ? groupSetting : listSetting);
        settings.add(groupFirst ? listSetting : groupSetting);

        try {
            new ClusterSettings(Settings.EMPTY, settings);
            fail(&quot;an exception should have been thrown because settings overlap&quot;);
        } catch (IllegalArgumentException e) {
            if (groupFirst) {
                assertEquals(&quot;complex setting key: [foo.bar] overlaps existing setting key: [foo.]&quot;, e.getMessage());
            } else {
                assertEquals(&quot;complex setting key: [foo.] overlaps existing setting key: [foo.bar]&quot;, e.getMessage());
            }
        }
    }

    @Test
    public void testUpdateNumberOfShardsFail() {
        IndexScopedSettings settings = new IndexScopedSettings(Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
            () -&gt; settings.updateSettings(Settings.builder().put(&quot;index.number_of_shards&quot;, 8).build(),
                Settings.builder(), Settings.builder(), &quot;index&quot;));
        assertThat(ex.getMessage(),
            containsString(&quot;final index setting [index.number_of_shards], not updateable&quot;));
    }

    @Test
    public void testFinalSettingUpdateFail() {
        Setting&lt;Integer&gt; finalSetting = Setting.intSetting(&quot;some.final.setting&quot;, 1, Property.Final, Property.NodeScope);
        Setting&lt;Settings&gt; finalGroupSetting = Setting.groupSetting(&quot;some.final.group.&quot;, Property.Final, Property.NodeScope);
        Settings currentSettings = Settings.builder()
            .put(&quot;some.final.setting&quot;, 9)
            .put(&quot;some.final.group.foo&quot;, 7)
            .build();
        ClusterSettings service = new ClusterSettings(currentSettings
            , new HashSet&lt;&gt;(Arrays.asList(finalSetting, finalGroupSetting)));

        IllegalArgumentException exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateDynamicSettings(Settings.builder().put(&quot;some.final.setting&quot;, 8).build(),
                Settings.builder().put(currentSettings), Settings.builder(), &quot;node&quot;));
        assertThat(exc.getMessage(), containsString(&quot;final node setting [some.final.setting]&quot;));

        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateDynamicSettings(Settings.builder().putNull(&quot;some.final.setting&quot;).build(),
                Settings.builder().put(currentSettings), Settings.builder(), &quot;node&quot;));
        assertThat(exc.getMessage(), containsString(&quot;final node setting [some.final.setting]&quot;));

        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateSettings(Settings.builder().put(&quot;some.final.group.new&quot;, 8).build(),
                Settings.builder().put(currentSettings), Settings.builder(), &quot;node&quot;));
        assertThat(exc.getMessage(), containsString(&quot;final node setting [some.final.group.new]&quot;));

        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateSettings(Settings.builder().put(&quot;some.final.group.foo&quot;, 5).build(),
                Settings.builder().put(currentSettings), Settings.builder(), &quot;node&quot;));
        assertThat(exc.getMessage(), containsString(&quot;final node setting [some.final.group.foo]&quot;));
    }

    @Test
    public void testInternalIndexSettingsFailsValidation() {
        final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString(&quot;index.internal&quot;, Property.InternalIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; {
                    final Settings settings = Settings.builder().put(&quot;index.internal&quot;, &quot;internal&quot;).build();
                    indexScopedSettings.validate(settings, false, /* validateInternalOrPrivateIndex */ true);
                });
        final String message = &quot;can not update internal setting [index.internal]; this setting is managed via a dedicated API&quot;;
        assertThat(e, hasToString(containsString(message)));
    }

    @Test
    public void testPrivateIndexSettingsFailsValidation() {
        final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString(&quot;index.private&quot;, Property.PrivateIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; {
                    final Settings settings = Settings.builder().put(&quot;index.private&quot;, &quot;private&quot;).build();
                    indexScopedSettings.validate(settings, false, /* validateInternalOrPrivateIndex */ true);
                });
        final String message = &quot;can not update private setting [index.private]; this setting is managed by CrateDB&quot;;
        assertThat(e, hasToString(containsString(message)));
    }

    @Test
    public void testInternalIndexSettingsSkipValidation() {
        final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString(&quot;index.internal&quot;, Property.InternalIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
        // nothing should happen, validation should not throw an exception
        final Settings settings = Settings.builder().put(&quot;index.internal&quot;, &quot;internal&quot;).build();
        indexScopedSettings.validate(settings, false, /* validateInternalOrPrivateIndex */ false);
    }

    @Test
    public void testPrivateIndexSettingsSkipValidation() {
        final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString(&quot;index.private&quot;, Property.PrivateIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
        // nothing should happen, validation should not throw an exception
        final Settings settings = Settings.builder().put(&quot;index.private&quot;, &quot;private&quot;).build();
        indexScopedSettings.validate(settings, false, /* validateInternalOrPrivateIndex */ false);
    }

    @Test
    public void testUpgradeSetting() {
        final Setting&lt;String&gt; oldSetting = Setting.simpleString(&quot;foo.old&quot;, Property.NodeScope);
        final Setting&lt;String&gt; newSetting = Setting.simpleString(&quot;foo.new&quot;, Property.NodeScope);
        final Setting&lt;String&gt; remainingSetting = Setting.simpleString(&quot;foo.remaining&quot;, Property.NodeScope);

        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {

                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }

                            @Override
                            public String getKey(final String key) {
                                return &quot;foo.new&quot;;
                            }

                            @Override
                            public String getValue(final String value) {
                                return &quot;new.&quot; + value;
                            }

<A NAME="2"></A>                        }));

        final Settings settings =
                <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#2',2,'match1907819-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Settings.builder()
                        .put(&quot;foo.old&quot;, randomAlphaOfLength(8))
                        .put(&quot;foo.remaining&quot;, randomAlphaOfLength(8))
                        .build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertFalse(oldSetting.exists(upgradedSettings));
        assertTrue(newSetting.exists(upgradedSettings));
        assertThat(newSetting.get(upgradedSettings), equalTo(&quot;new.&quot; + oldSetting.get(settings)));
        assertTrue(remainingSetting.exists(upgradedSettings));
        assertThat(remainingSetting.get(upgradedSettings), equalTo(remainingSetting.get</B></FONT>(settings)));
    }

    @Test
    public void testUpgradeSettingsNoChangesPreservesInstance() {
        final Setting&lt;String&gt; oldSetting = Setting.simpleString(&quot;foo.old&quot;, Property.NodeScope);
        final Setting&lt;String&gt; newSetting = Setting.simpleString(&quot;foo.new&quot;, Property.NodeScope);
        final Setting&lt;String&gt; remainingSetting = Setting.simpleString(&quot;foo.remaining&quot;, Property.NodeScope);

        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {

                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }

                            @Override
                            public String getKey(final String key) {
                                return &quot;foo.new&quot;;
                            }

                        }));

        final Settings settings = Settings.builder().put(&quot;foo.remaining&quot;, randomAlphaOfLength(8)).build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertThat(upgradedSettings, sameInstance(settings));
    }

    @Test
    public void testUpgradeComplexSetting() {
        final Setting.AffixSetting&lt;String&gt; oldSetting =
                Setting.affixKeySetting(&quot;foo.old.&quot;, &quot;suffix&quot;, key -&gt; Setting.simpleString(key, Property.NodeScope));
        final Setting.AffixSetting&lt;String&gt; newSetting =
                Setting.affixKeySetting(&quot;foo.new.&quot;, &quot;suffix&quot;, key -&gt; Setting.simpleString(key, Property.NodeScope));
        final Setting.AffixSetting&lt;String&gt; remainingSetting =
                Setting.affixKeySetting(&quot;foo.remaining.&quot;, &quot;suffix&quot;, key -&gt; Setting.simpleString(key, Property.NodeScope));

        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {

                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }

                            @Override
                            public String getKey(final String key) {
                                return key.replaceFirst(&quot;^foo\\.old&quot;, &quot;foo\\.new&quot;);
                            }

                            @Override
                            public String getValue(final String value) {
                                return &quot;new.&quot; + value;
                            }

                        }));

        final int count = randomIntBetween(1, 8);
        final List&lt;String&gt; concretes = new ArrayList&lt;&gt;(count);
        final Settings.Builder builder = Settings.builder();
        for (int i = 0; i &lt; count; i++) {
            final String concrete = randomAlphaOfLength(8);
            concretes.add(concrete);
            builder.put(&quot;foo.old.&quot; + concrete + &quot;.suffix&quot;, randomAlphaOfLength(8));
            builder.put(&quot;foo.remaining.&quot; + concrete + &quot;.suffix&quot;, randomAlphaOfLength(8));
        }
        final Settings settings = builder.build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        for (final String concrete : concretes) {
            assertFalse(oldSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertTrue(newSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertThat(
                    newSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
                    equalTo(&quot;new.&quot; + oldSetting.getConcreteSettingForNamespace(concrete).get(settings)));
            assertTrue(remainingSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertThat(
                    remainingSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
                    equalTo(remainingSetting.getConcreteSettingForNamespace(concrete).get(settings)));
        }
    }

    @Test
    public void testUpgradeListSetting() {
        final Setting&lt;List&lt;String&gt;&gt; oldSetting =
                Setting.listSetting(&quot;foo.old&quot;, Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
        final Setting&lt;List&lt;String&gt;&gt; newSetting =
                Setting.listSetting(&quot;foo.new&quot;, Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);

        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting)),
                        Collections.singleton(new SettingUpgrader&lt;List&lt;String&gt;&gt;() {

                            @Override
                            public Setting&lt;List&lt;String&gt;&gt; getSetting() {
                                return oldSetting;
                            }

                            @Override
                            public String getKey(final String key) {
                                return &quot;foo.new&quot;;
                            }

                            @Override
                            public List&lt;String&gt; getListValue(final List&lt;String&gt; value) {
                                return value.stream().map(s -&gt; &quot;new.&quot; + s).collect(Collectors.toList());
                            }
                        }));

        final int length = randomIntBetween(0, 16);
        final List&lt;String&gt; values = length == 0 ? Collections.emptyList() : new ArrayList&lt;&gt;(length);
        for (int i = 0; i &lt; length; i++) {
<A NAME="3"></A>            values.add(randomAlphaOfLength(8));
        }

        final Settings settings = <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1907819-0.html#3',2,'match1907819-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Settings.builder().putList(&quot;foo.old&quot;, values).build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertFalse(oldSetting.exists(upgradedSettings));
        assertTrue(newSetting.exists(upgradedSettings));
        assertThat(
                newSetting.get(upgradedSettings),
                equalTo(oldSetting.get(settings).stream().map(s -&gt; &quot;new.&quot; + s).collect</B></FONT>(Collectors.toList())));
    }

    @Test
    public void test_update_setting_with_dependency() throws Exception {
        Setting&lt;String&gt; low = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING;
        Setting&lt;String&gt; high = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING;
        Setting&lt;String&gt; flood = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING;

        ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, Set.of(low, high, flood));
        Settings.Builder target = Settings.builder();
        clusterSettings.updateDynamicSettings(
            Settings.builder().put(high.getKey(), &quot;95%&quot;).build(),
            target,
            Settings.builder(),
            &quot;update high to 95%&quot;
        );
        clusterSettings.applySettings(target.build());
        clusterSettings.updateDynamicSettings(
            Settings.builder().put(low.getKey(), &quot;91%&quot;).build(),
            Settings.builder(),
            Settings.builder(),
            &quot;update low to 91%&quot;
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
