<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for StoreRecovery.java &amp; ScopedSettingsTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for StoreRecovery.java &amp; ScopedSettingsTests.java
      </h3>
<h1 align="center">
        11.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>StoreRecovery.java (18.81068%)<th>ScopedSettingsTests.java (8.031088%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-57)<td><a href="#" name="0">(21-60)</a><td align="center"><font color="#ff0000">36</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(335-343)<td><a href="#" name="1">(299-317)</a><td align="center"><font color="#bf0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(132-150)<td><a href="#" name="2">(947-956)</a><td align="center"><font color="#8d0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(435-441)<td><a href="#" name="3">(1082-1088)</a><td align="center"><font color="#5c0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(521-525)<td><a href="#" name="4">(75-79)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(486-493)<td><a href="#" name="5">(113-116)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(443-447)<td><a href="#" name="6">(440-442)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(330-332)<td><a href="#" name="7">(71-75)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(328-329)<td><a href="#" name="8">(632-636)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(196-200)<td><a href="#" name="9">(788-791)</a><td align="center"><font color="#3f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>StoreRecovery.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.index.shard;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.NoMergePolicy;
import org.apache.lucene.index.SegmentInfos;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.FilterDirectory;
import org.apache.lucene.store.IOContext;
import org.apache.lucene.store.IndexInput;
import org.elasticsearch.ExceptionsHelper;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.MappingMetadata;
import org.elasticsearch.cluster.routing.RecoverySource;
import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.unit.ByteSizeValue;
import io.crate.common.unit.TimeValue;
import org.elasticsearch.index.Index;
import org.elasticsearch.index.engine.Engine;
import org.elasticsearch.index.engine.EngineException;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.index.seqno.SequenceNumbers;
import org.elasticsearch.index.snapshots.IndexShardRestoreFailedException;
import org.elasticsearch.index.store.Store;
import org.elasticsearch.index.translog.Translog;
import org.elasticsearch.indices.recovery.RecoveryState;
import org.elasticsearch.repositories.IndexId;
import org.elasticsearch.repositories.Repository;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import</b></font> java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import static io.crate.common.unit.TimeValue.timeValueMillis;
final class StoreRecovery {
    private final Logger logger;
    private final ShardId shardId;
    StoreRecovery(ShardId shardId, Logger logger) {
        this.logger = logger;
        this.shardId = shardId;
    }
    void recoverFromStore(final IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
        if (canRecover(indexShard)) {
            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
            assert
                recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :
                "expected store recovery type but was: " + recoveryType;
            ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
                logger.debug("starting recovery from store ...");
                internalRecoverFromStore(indexShard);
                return true;
            });
        } else {
            listener.onResponse(false);
        }
    }
    void recoverFromLocalShards(Consumer&lt;MappingMetadata&gt; mappingUpdateConsumer,
                                IndexShard indexShard,
                                List&lt;LocalShardSnapshot&gt; shards,
                                ActionListener&lt;Boolean&gt; listener) {
        if (canRecover(indexShard)) {
            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
            assert
                recoveryType == RecoverySource.Type.LOCAL_SHARDS :
                "expected local shards recovery type: " + recoveryType;
            if (shards.isEmpty()) {
                throw new IllegalArgumentException("shards must not be empty");
            }
            Set&lt;Index&gt; indices = shards.stream().map((s) -&gt; s.getIndex()).collect(Collectors.toSet());
            if (indices.size() &gt; 1) {
                throw new IllegalArgumentException("can't add shards from more than one index");
            }
            IndexMetadata sourceMetadata = shards.get(0).getIndexMetadata();
            if (sourceMetadata.mapping() != null) {
                mappingUpdateConsumer.accept(sourceMetadata.mapping());
            }
            indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);
            final boolean isSplit = sourceMetadata.getNumberOfShards() &lt; indexShard.indexSettings().getNumberOfShards();
            ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
                logger.debug("starting recovery from local shards {}", shards);
<a name="2"></a>                try {
                    final Directory directory = indexShard.store().directory();                     final Directory[] sources = shards.stream().map(LocalShardSnapshot::getSnapshotDirectory).toArray(Directory[]::new);
                    final long maxSeqNo = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>shards.stream().mapToLong(LocalShardSnapshot::maxSeqNo).max().getAsLong();
                    final long maxUnsafeAutoIdTimestamp = shards.stream()
                        .mapToLong(LocalShardSnapshot::maxUnsafeAutoIdTimestamp)
                        .max()
                        .getAsLong();
                    addIndices(
                        indexShard.recoveryState().getIndex(),
                        directory,
                        sources,
                        maxSeqNo,
                        maxUnsafeAutoIdTimestamp,
                        indexShard.indexSettings().getIndexMetadata(),
                        indexShard.shardId().id(),
                        isSplit
                    );
                    internalRecoverFromStore(indexShard);
                    indexShard.getEngine().forceMerge(false, -1, false, false, false, UUIDs.randomBase64UUID</b></font>());
                    return true;
                } catch (IOException ex) {
                    throw new IndexShardRecoveryException(indexShard.shardId(), "failed to recover from local shards", ex);
                }
            });
        } else {
            listener.onResponse(false);
        }
    }
    void addIndices(final RecoveryState.Index indexRecoveryStats,
                    final Directory target,
                    final Directory[] sources,
                    final long maxSeqNo,
                    final long maxUnsafeAutoIdTimestamp,
                    IndexMetadata indexMetadata,
                    int shardId,
                    boolean split) throws IOException {
        assert sources.length &gt; 0;
        final int luceneIndexCreatedVersionMajor = Lucene.readSegmentInfos(sources[0]).getIndexCreatedVersionMajor();
        final Directory hardLinkOrCopyTarget = new org.apache.lucene.store.HardlinkCopyDirectoryWrapper(target);
        IndexWriterConfig iwc = new IndexWriterConfig(null)
            .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)
            .setCommitOnClose(false)
            .setMergePolicy(NoMergePolicy.INSTANCE)
            .setOpenMode(IndexWriterConfig.OpenMode.CREATE)
            .setIndexCreatedVersionMajor(luceneIndexCreatedVersionMajor);
        try (IndexWriter writer = new IndexWriter(new StatsDirectoryWrapper(hardLinkOrCopyTarget, indexRecoveryStats), iwc)) {
            writer.addIndexes(sources);
            indexRecoveryStats.setFileDetailsComplete();
            if (split) {
                writer.deleteDocuments(new ShardSplittingQuery(indexMetadata, shardId));
            }
            writer.setLiveCommitData(() -&gt; <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
                final HashMap&lt;String, String&gt; liveCommitData = new HashMap&lt;&gt;(3);
                liveCommitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(maxSeqNo));
                liveCommitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(maxSeqNo));
                liveCommitData.put(Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString</b></font>(maxUnsafeAutoIdTimestamp));
                return liveCommitData.entrySet().iterator();
            });
            writer.commit();
        }
    }
    static final class StatsDirectoryWrapper extends FilterDirectory {
        private final RecoveryState.Index index;
        StatsDirectoryWrapper(Directory in, RecoveryState.Index indexRecoveryStats) {
            super(in);
            this.index = indexRecoveryStats;
        }
        @Override
        public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
            final long l = from.fileLength(src);
            final AtomicBoolean copies = new AtomicBoolean(false);
            in.copyFrom(new FilterDirectory(from) {
                @Override
                public IndexInput openInput(String name, IOContext context) throws IOException {
                    index.addFileDetail(dest, l, false);
                    copies.set(true);
                    final IndexInput input = in.openInput(name, context);
                    return new IndexInput("StatsDirectoryWrapper(" + input.toString() + ")") {
                        @Override
                        public void close() throws IOException {
                            input.close();
                        }
                        @Override
                        public long getFilePointer() {
                            throw new UnsupportedOperationException("only straight copies are supported");
                        }
                        @Override
                        public void seek(long pos) throws IOException {
                            throw new UnsupportedOperationException("seeks are not supported");
                        }
                        @Override
                        public long length() {
                            return input.length();
                        }
                        @Override
                        public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
                            throw new UnsupportedOperationException("slices are not supported");
                        }
                        @Override
                        public byte readByte() throws IOException {
                            throw new UnsupportedOperationException("use a buffer if you wanna perform well");
                        }
                        @Override
                        public void readBytes(byte[] b, int offset, int len) throws IOException {
                            input.readBytes(b, offset, len);
                            index.addRecoveredBytesToFile(dest, len);
                        }
                    };
                }
            }, src, dest, context);
            if (copies.get() == false) {
                index.addFileDetail(dest, l, true);             } else {
                assert index.getFileDetails(dest) != null : "File [" + dest + "] has no file details";
                assert index.getFileDetails(dest).recovered() == l : index.getFileDetails(dest).toString();
            }
        }
    }
    void recoverFromRepository(final IndexShard indexShard, Repository repository, ActionListener&lt;Boolean&gt; listener) {
        try {
            if (canRecover(indexShard)) {
                RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
                assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType;
                SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource();
                restore(indexShard, repository, recoverySource, recoveryListener(indexShard, listener));
            } else {
                listener.onResponse(false);
            }
        } catch (Exception e) {
            listener.onFailure(e);
        }
    }
    private boolean canRecover(IndexShard indexShard) {
        if (indexShard.state() == IndexShardState.CLOSED) {
            return false;
        }
        if (indexShard.routingEntry().primary() == false) {
            throw new IndexShardRecoveryException(shardId, "Trying to recover when the shard is in backup state", null);
        }
        return true;
    }
    private ActionListener&lt;Boolean&gt; recoveryListener(IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
        return ActionListener.wrap(
            res -&gt; {
                if (res) {
                    final IndexShardState shardState = indexShard.state();
                    final RecoveryState recoveryState = indexShard.recoveryState();
                    assert shardState != IndexShardState.CREATED &amp;&amp; shardState != IndexShardState.RECOVERING :
                        "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]";
<a name="8"></a>
                    if (logger.isTraceEnabled()) {
<a name="7"></a>                        RecoveryState.Index index = recoveryState.getIndex();
                        <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>StringBuilder sb = new StringBuilder();
                        sb.append("    index    : files           [").append(index.totalFileCount</b></font>()).append("] with total_size [")
                            .append(<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ByteSizeValue(index.totalBytes())).append("], took[")
                            .append(TimeValue.timeValueMillis(index.time())).append("]\n");
<a name="1"></a>                        sb.append("             : recovered_files [").append(index.recoveredFileCount</b></font>()).append("] with total_size [")
                            .append(new ByteSizeValue(index.recoveredBytes())).append("]\n");
                        sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")
                            .append(new ByteSizeValue(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>index.reusedBytes())).append("]\n");
                        sb.append("    verify_index    : took [")
                            .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")
                            .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n");
                        sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())
                            .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]");
                        logger.trace("recovery completed from [shard_store], took [{}]\n{}",
                            timeValueMillis(recoveryState.getTimer().time()), sb);
                    }</b></font> else if (logger.isDebugEnabled()) {
                        logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()));
                    }
                }
                listener.onResponse(res);
            },
            ex -&gt; {
                if (ex instanceof IndexShardRecoveryException) {
                    if (indexShard.state() == IndexShardState.CLOSED) {
                        listener.onResponse(false);
                        return;
                    }
                    if ((ex.getCause() instanceof IndexShardClosedException) || (ex.getCause() instanceof IndexShardNotStartedException)) {
                        listener.onResponse(false);
                        return;
                    }
                    listener.onFailure(ex);
                } else if (ex instanceof IndexShardClosedException || ex instanceof IndexShardNotStartedException) {
                    listener.onResponse(false);
                } else {
                    if (indexShard.state() == IndexShardState.CLOSED) {
                        listener.onResponse(false);
                    } else {
                        listener.onFailure(new IndexShardRecoveryException(shardId, "failed recovery", ex));
                    }
                }
            }
        );
    }
    private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {
        final RecoveryState recoveryState = indexShard.recoveryState();
        final boolean indexShouldExists =
            recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE;
        indexShard.prepareForIndexRecovery();
        SegmentInfos si = null;
        final Store store = indexShard.store();
        store.incRef();
        try {
            try {
                store.failIfCorrupted();
                try {
                    si = store.readLastCommittedSegmentsInfo();
                } catch (Exception e) {
                    String files = "_unknown_";
                    try {
                        files = Arrays.toString(store.directory().listAll());
                    } catch (Exception inner) {
                        files += " (failure=" + ExceptionsHelper.stackTrace(inner) + ")";
                    }
                    if (indexShouldExists) {
                        throw new IndexShardRecoveryException(shardId,
                            "shard allocated for local recovery (post api), should exist, but doesn't, current files: " +
                            files, e);
                    }
                }
                if (si != null &amp;&amp; indexShouldExists == false) {
                    logger.trace("cleaning existing shard, shouldn't exists");
                    Lucene.cleanLuceneIndex(store.directory());
                    si = null;
                }
            } catch (Exception e) {
                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e);
            }
            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {
                assert indexShouldExists;
                bootstrap(indexShard, store);
                writeEmptyRetentionLeasesFile(indexShard);
            } else if (indexShouldExists) {
                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {
                    store.bootstrapNewHistory();
                    writeEmptyRetentionLeasesFile(indexShard);
                }
                final RecoveryState.Index index = recoveryState.getIndex();
                try {
                    if (si != null) {
                        addRecoveredFileDetails(si, store, index);
                    }
                } catch (IOException e) {
                    logger.debug("failed to list file details", e);
<a name="3"></a>                }
                index.setFileDetailsComplete();
            } else {
                <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion);
                final String translogUUID = Translog.createEmptyTranslog(
                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,
                    indexShard.getPendingPrimaryTerm());
                store.associateIndexWithNewTranslog(translogUUID);
<a name="6"></a>                writeEmptyRetentionLeasesFile(indexShard);
                indexShard.recoveryState</b></font>().getIndex().setFileDetailsComplete();
            }
            <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>indexShard.openEngineAndRecoverFromTranslog();
            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
            indexShard.finalizeRecovery();
            indexShard.postRecovery("post recovery from shard_store");
        } catch (EngineException | IOException e) {</b></font>
            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e);
        } finally {
            store.decRef();
        }
    }
    private static void writeEmptyRetentionLeasesFile(IndexShard indexShard) throws IOException {
        assert indexShard.getRetentionLeases().leases().isEmpty() : indexShard.getRetentionLeases();         indexShard.persistRetentionLeases();
        assert indexShard.loadRetentionLeases().leases().isEmpty();
    }
    private void addRecoveredFileDetails(SegmentInfos si, Store store, RecoveryState.Index index) throws IOException {
        final Directory directory = store.directory();
        for (String name : Lucene.files(si)) {
            long length = directory.fileLength(name);
            index.addFileDetail(name, length, true);
        }
    }
    private void restore(IndexShard indexShard, Repository repository, SnapshotRecoverySource restoreSource,
                         ActionListener&lt;Boolean&gt; listener) {
        logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource());
        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog();
        if (restoreSource == null) {
            listener.onFailure(new IndexShardRestoreFailedException(shardId, "empty restore source"));
            return;
        }
        if (logger.isTraceEnabled()) {
            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId);
        }
        final ActionListener&lt;Void&gt; restoreListener = ActionListener.wrap(
<a name="5"></a>            v -&gt; {
                final Store store = indexShard.store();
                bootstrap(indexShard, store);
                assert <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>indexShard.shardRouting.primary() : "only primary shards can recover from store";
                writeEmptyRetentionLeasesFile(indexShard);
                indexShard.openEngineAndRecoverFromTranslog();
                indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
                indexShard.finalizeRecovery();
                indexShard.postRecovery("restore done");
                listener.onResponse(true);
            }</b></font>, e -&gt; listener.onFailure(new IndexShardRestoreFailedException(shardId, "restore failed", e))
        );
        try {
            translogState.totalOperations(0);
            translogState.totalOperationsOnStart(0);
            indexShard.prepareForIndexRecovery();
            final ShardId snapshotShardId;
            final String indexName = restoreSource.index();
            if (!shardId.getIndexName().equals(indexName)) {
                snapshotShardId = new ShardId(indexName, IndexMetadata.INDEX_UUID_NA_VALUE, shardId.id());
            } else {
                snapshotShardId = shardId;
            }
            repository.getRepositoryData(ActionListener.wrap(
                repositoryData -&gt; {
                    final IndexId indexId = repositoryData.resolveIndexId(indexName);
                    assert indexShard.getEngineOrNull() == null;
                    repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,
                        indexShard.recoveryState(), restoreListener);
                }, restoreListener::onFailure
            ));
        } catch (Exception e) {
            restoreListener.onFailure(e);
        }
    }
<a name="4"></a>
    private void bootstrap(final IndexShard indexShard, final Store store) throws IOException {
        store.bootstrapNewHistory();
        final SegmentInfos segmentInfos = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>store.readLastCommittedSegmentsInfo();
        final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
        final String translogUUID = Translog.createEmptyTranslog(
            indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());
        store.associateIndexWithNewTranslog</b></font>(translogUUID);
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScopedSettingsTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
<a name="0"></a> * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.common.settings;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.Matchers.hasToString;
import static org.hamcrest.Matchers.sameInstance;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.elasticsearch.Version;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;
import org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider;
import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocationDecider;
import org.elasticsearch.common.logging.Loggers;
import org.elasticsearch.common.settings.Setting.Property;
import org.elasticsearch.index.IndexModule;
import org.elasticsearch.test.ESTestCase;
import org.elasticsearch.transport.TransportSettings;
import org.junit.Test;
import io.crate.types.ArrayType;
import</b></font> io.crate.types.DataTypes;
public class ScopedSettingsTests extends ESTestCase {
    @Test
    public void testResetSetting() {
        Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting("some.dyn.setting", 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; staticSetting = Setting.intSetting("some.static.setting", 1, Property.NodeScope);
<a name="7"></a>        Settings currentSettings = Settings.builder().put("some.dyn.setting", 5).put("some.static.setting", 6).put("archived.foo.bar", 9)
            .build();
        ClusterSettings service = new ClusterSettings(currentSettings
            , <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, staticSetting)));
<a name="4"></a>
        expectThrows(IllegalArgumentException.class, () -&gt;
        service.updateDynamicSettings(Settings.builder().put("some.dyn.setting", 8).putNull("some.static.setting").build(),
            Settings.builder</b></font>().put(currentSettings), <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder(), "node"));
        Settings.Builder target = Settings.builder().put(currentSettings);
        Settings.Builder update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().put</b></font>("some.dyn.setting", 8).build(),
            target, update, "node"));
        assertEquals(8, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.dyn.setting").build(),
            target, update, "node"));
        assertEquals(1, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("archived.foo.bar").build(),
            target, update, "node"));
        assertEquals(5, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertNull(target.build().getAsInt("archived.foo.bar", null));
        target = Settings.builder().put(currentSettings);
        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.*").build(),
            target, update, "node"));
        assertEquals(1, dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
        target = Settings.builder().put(currentSettings);
<a name="5"></a>        update = Settings.builder();
        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("*").build(),
            target, update, "node"));
        assertEquals(1, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>dynamicSetting.get(target.build()).intValue());
        assertEquals(6, staticSetting.get(target.build()).intValue());
        assertNull(target.build().getAsInt("archived.foo.bar", null));
    }</b></font>
    @Test
    public void testResetSettingWithIPValidator() {
        Settings currentSettings = Settings.builder().put("index.routing.allocation.require._ip", "192.168.0.1,127.0.0.1")
            .put("index.some.dyn.setting", 1)
            .build();
        Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting("index.some.dyn.setting", 1, Property.Dynamic, Property.IndexScope);
        IndexScopedSettings settings = new IndexScopedSettings(currentSettings,
            new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING)));
        Map&lt;String, String&gt; s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
        assertEquals(1, s.size());
        assertEquals("192.168.0.1,127.0.0.1", s.get("_ip"));
        Settings.Builder builder = Settings.builder();
        Settings updates = Settings.builder().putNull("index.routing.allocation.require._ip")
            .put("index.some.dyn.setting", 1).build();
        settings.validate(updates, false);
        settings.updateDynamicSettings(updates,
            Settings.builder().put(currentSettings), builder, "node");
        currentSettings = builder.build();
        s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
        assertEquals(0, s.size());
        assertEquals(1, dynamicSetting.get(currentSettings).intValue());
        assertEquals(1, currentSettings.size());
    }
    @Test
    public void testAddConsumer() {
        Setting&lt;Integer&gt; testSetting = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; testSetting2 = Setting.intSetting("foo.bar.baz", 1, Property.Dynamic, Property.NodeScope);
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, Collections.singleton(testSetting));
        AtomicInteger consumer = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, consumer::set);
        AtomicInteger consumer2 = new AtomicInteger();
        try {
            service.addSettingsUpdateConsumer(testSetting2, consumer2::set);
            fail("setting not registered");
        } catch (IllegalArgumentException ex) {
            assertEquals("Setting is not registered for key [foo.bar.baz]", ex.getMessage());
        }
        try {
            service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
                consumer.set(a);
                consumer2.set(b);
            });
            fail("setting not registered");
        } catch (IllegalArgumentException ex) {
            assertEquals("Setting is not registered for key [foo.bar.baz]", ex.getMessage());
        }
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
        assertEquals(2, consumer.get());
        assertEquals(0, consumer2.get());
    }
    @Test
    public void testDependentSettings() {
        Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting("foo.", "name",
            (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope), () -&gt; stringSetting);
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));
        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
            () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).build(), true));
        assertEquals("missing required setting [foo.test.name] for setting [foo.test.bar]", iae.getMessage());
        service.validate(Settings.builder()
            .put("foo.test.name", "test")
            .put("foo.test.bar", 7)
            .build(), true);
        service.validate(Settings.builder().put("foo.test.bar", 7).build(), false);
    }
    @Test
    public void testDependentSettingsValidate() {
        Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting(
            "foo.",
            "name",
            (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(
            "foo.",
            "bar",
            (k) -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
            new Setting.AffixSettingDependency() {
                @Override
                public Setting.AffixSetting getSetting() {
                    return stringSetting;
                }
                @Override
                public void validate(final String key, final Object value, final Object dependency) {
                    if ("valid".equals(dependency) == false) {
                        throw new SettingsException("[" + key + "] is set but [name] is [" + dependency + "]");
                    }
                }
            });
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));
        SettingsException iae = expectThrows(
            SettingsException.class,
            () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).put("foo.test.name", "invalid").build(), true));
        assertEquals("[foo.test.bar] is set but [name] is [invalid]", iae.getMessage());
        service.validate(Settings.builder()
                .put("foo.test.bar", 7)
                .put("foo.test.name", "valid")
                .build(),
            true);
        service.validate(Settings.builder()
            .put("foo.test.bar", 7)
            .put("foo.test.name", "invalid")
            .build(),
            false);
    }
    public void testDependentSettingsWithFallback() {
        Setting.AffixSetting&lt;String&gt; nameFallbackSetting =
                Setting.affixKeySetting("fallback.", "name", k -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;String&gt; nameSetting = Setting.affixKeySetting(
                "foo.",
                "name",
                k -&gt; Setting.simpleString(
                        k,
                        "_na_".equals(k)
                                ? nameFallbackSetting.getConcreteSettingForNamespace(k)
                                : nameFallbackSetting.getConcreteSetting(k.replaceAll("^foo", "fallback")),
                        Property.Dynamic,
                        Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; barSetting = Setting.affixKeySetting(
            "foo.",
            "bar",
            k -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
            () -&gt; nameSetting);
        final AbstractScopedSettings service =
                new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(nameFallbackSetting, nameSetting, barSetting)));
        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).build(), true));
        assertThat(e, hasToString(containsString("missing required setting [foo.test.name] for setting [foo.test.bar]")));
        service.validate(Settings.builder().put("foo.test.name", "test").put("foo.test.bar", 7).build(), true);
        service.validate(Settings.builder().put("fallback.test.name", "test").put("foo.test.bar", 7).build(), true);
    }
    @Test
    public void testAddConsumerAffix() {
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting("foo.", "list",
            (k) -&gt; Setting.listSetting(k, Arrays.asList("1"), Integer::parseInt, new ArrayType&lt;&gt;(DataTypes.INTEGER), Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
        Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();
        BiConsumer&lt;String, Integer&gt; intConsumer = intResults::put;
        BiConsumer&lt;String, List&lt;Integer&gt;&gt; listConsumer = listResults::put;
        service.addAffixUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
        service.addAffixUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
        assertEquals(0, listResults.size());
        assertEquals(0, intResults.size());
        service.applySettings(Settings.builder()
            .put("foo.test.bar", 2)
            .put("foo.test_1.bar", 7)
            .putList("foo.test_list.list", "16", "17")
            .putList("foo.test_list_1.list", "18", "19", "20")
            .build());
        assertEquals(2, intResults.get("test").intValue());
<a name="1"></a>        assertEquals(7, intResults.get("test_1").intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
        assertEquals(2, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>listResults.size());
        assertEquals(2, intResults.size());
        listResults.clear();
        intResults.clear();
        service.applySettings(Settings.builder()
            .put("foo.test.bar", 2)
            .put("foo.test_1.bar", 8)
            .putList("foo.test_list.list", "16", "17")
            .putNull("foo.test_list_1.list")
            .build());
        assertNull("test wasn't changed", intResults.get("test"));
        assertEquals(8, intResults.get("test_1").intValue());
        assertNull("test_list wasn't changed", listResults.get("test_list"));
        assertEquals(Arrays.asList(1), listResults.get("test_list_1"));         assertEquals(1, listResults.size());
        assertEquals(1, intResults.size());
    }</b></font>
    @Test
    public void testAddConsumerAffixMap() {
        Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
            (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting("foo.", "list",
            (k) -&gt; Setting.listSetting(k, Arrays.asList("1"), Integer::parseInt, DataTypes.INTEGER_ARRAY, Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
        Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();
        Consumer&lt;Map&lt;String,Integer&gt;&gt; intConsumer = (map) -&gt; {
            intResults.clear();
            intResults.putAll(map);
        };
        Consumer&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt; listConsumer = (map) -&gt; {
            listResults.clear();
            listResults.putAll(map);
        };
        service.addAffixMapUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
        service.addAffixMapUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
        assertEquals(0, listResults.size());
        assertEquals(0, intResults.size());
        service.applySettings(Settings.builder()
            .put("foo.test.bar", 2)
            .put("foo.test_1.bar", 7)
            .putList("foo.test_list.list", "16", "17")
            .putList("foo.test_list_1.list", "18", "19", "20")
            .build());
        assertEquals(2, intResults.get("test").intValue());
        assertEquals(7, intResults.get("test_1").intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
        assertEquals(2, listResults.size());
        assertEquals(2, intResults.size());
        service.applySettings(Settings.builder()
            .put("foo.test.bar", 2)
            .put("foo.test_1.bar", 7)
            .putList("foo.test_list.list", "16", "17")
            .putList("foo.test_list_1.list", "18", "19", "20")
            .build());
        assertEquals(2, intResults.get("test").intValue());
        assertEquals(7, intResults.get("test_1").intValue());
        assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
        assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
        assertEquals(2, listResults.size());
        assertEquals(2, intResults.size());
        listResults.clear();
        intResults.clear();
        service.applySettings(Settings.builder()
            .put("foo.test.bar", 2)
            .put("foo.test_1.bar", 8)
            .putList("foo.test_list.list", "16", "17")
            .putNull("foo.test_list_1.list")
            .build());
        assertNull("test wasn't changed", intResults.get("test"));
        assertEquals(8, intResults.get("test_1").intValue());
        assertNull("test_list wasn't changed", listResults.get("test_list"));
        assertEquals(Arrays.asList(1), listResults.get("test_list_1"));         assertEquals(1, listResults.size());
        assertEquals(1, intResults.size());
    }
    @Test
    public void testAffixMapConsumerNotCalledWithNull() {
        Setting.AffixSetting&lt;Integer&gt; prefixSetting = Setting.prefixKeySetting("eggplant.",
                (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        Setting.AffixSetting&lt;Integer&gt; otherSetting = Setting.prefixKeySetting("other.",
                (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(prefixSetting, otherSetting)));
        Map&lt;String, Integer&gt; affixResults = new HashMap&lt;&gt;();
        Consumer&lt;Map&lt;String,Integer&gt;&gt; consumer = (map) -&gt; {
            logger.info("--&gt; consuming settings {}", map);
            affixResults.clear();
            affixResults.putAll(map);
        };
        service.addAffixMapUpdateConsumer(prefixSetting, consumer, (s, k) -&gt; {});
        assertEquals(0, affixResults.size());
        service.applySettings(Settings.builder()
                .put("eggplant._name", 2)
                .build());
        assertThat(affixResults.size(), equalTo(1));
        assertThat(affixResults.get("_name"), equalTo(2));
        service.applySettings(Settings.builder()
                .put("eggplant._name", 2)
                .put("other.thing", 3)
                .build());
        assertThat(affixResults.get("_name"), equalTo(2));
    }
    @Test
    public void testApply() {
        Setting&lt;Integer&gt; testSetting = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Integer&gt; testSetting2 = Setting.intSetting("foo.bar.baz", 1, Property.Dynamic, Property.NodeScope);
        AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(testSetting, testSetting2)));
        AtomicInteger consumer = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, consumer::set);
        AtomicInteger consumer2 = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting2, consumer2::set, (s) -&gt; assertTrue(s &gt; 0));
        AtomicInteger aC = new AtomicInteger();
        AtomicInteger bC = new AtomicInteger();
        service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
            aC.set(a);
            bC.set(b);
        });
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
<a name="6"></a>        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        try {
            <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", -15).build());
            fail("invalid value");
        } catch (IllegalArgumentException ex) {</b></font>
            assertEquals("illegal value can't update [foo.bar.baz] from [1] to [-15]", ex.getMessage());
        }
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        try {
            service.validateUpdate(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", -15).build());
            fail("invalid value");
        } catch (IllegalArgumentException ex) {
            assertEquals("illegal value can't update [foo.bar.baz] from [1] to [-15]", ex.getMessage());
        }
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        service.validateUpdate(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
        assertEquals(0, consumer.get());
        assertEquals(0, consumer2.get());
        assertEquals(0, aC.get());
        assertEquals(0, bC.get());
        service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
        assertEquals(2, consumer.get());
        assertEquals(15, consumer2.get());
        assertEquals(2, aC.get());
        assertEquals(15, bC.get());
    }
    @Test
    public void testGet() {
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        Setting setting = settings.get("cluster.routing.allocation.require.value");
        assertEquals(setting,
            FilterAllocationDecider.CLUSTER_ROUTING_REQUIRE_GROUP_SETTING.getConcreteSetting("cluster.routing.allocation.require.value"));
        setting = settings.get("cluster.routing.allocation.total_shards_per_node");
        assertEquals(setting, ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING);
        assertNotNull(settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
        assertSame(TransportSettings.TRACE_LOG_INCLUDE_SETTING, settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
        assertNull(settings.get("transport.tracer.include.FOO"));
    }
    @Test
    public void testIsDynamic(){
        ClusterSettings settings =
            new ClusterSettings(Settings.EMPTY,
                new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope),
                    Setting.intSetting("foo.bar.baz", 1, Property.NodeScope))));
        assertFalse(settings.isDynamicSetting("foo.bar.baz"));
        assertTrue(settings.isDynamicSetting("foo.bar"));
        assertNotNull(settings.get("foo.bar.baz"));
        settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        assertTrue(settings.isDynamicSetting("transport.tracer.include." + randomIntBetween(1, 100)));
        assertFalse(settings.isDynamicSetting("transport.tracer.include.BOOM"));
        assertTrue(settings.isDynamicSetting("cluster.routing.allocation.require.value"));
    }
    @Test
    public void testIsFinal() {
        ClusterSettings settings =
            new ClusterSettings(Settings.EMPTY,
                new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting("foo.int", 1, Property.Final, Property.NodeScope),
                    Setting.groupSetting("foo.group.",  Property.Final, Property.NodeScope),
                    Setting.groupSetting("foo.list.",  Property.Final, Property.NodeScope),
                    Setting.intSetting("foo.int.baz", 1, Property.NodeScope))));
        assertFalse(settings.isFinalSetting("foo.int.baz"));
        assertTrue(settings.isFinalSetting("foo.int"));
        assertFalse(settings.isFinalSetting("foo.list"));
        assertTrue(settings.isFinalSetting("foo.list.0.key"));
        assertTrue(settings.isFinalSetting("foo.list.key"));
        assertFalse(settings.isFinalSetting("foo.group"));
        assertTrue(settings.isFinalSetting("foo.group.key"));
    }
    @Test
    public void testDiff() throws IOException {
        Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting("foo.bar.baz", 1, Property.NodeScope);
        Setting&lt;Integer&gt; fooBar = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Settings&gt; someGroup = Setting.groupSetting("some.group.", Property.Dynamic, Property.NodeScope);
        Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting("some.prefix.", "somekey", (key) -&gt; Setting.boolSetting(key, true,
            Property.NodeScope));
        Setting&lt;List&lt;String&gt;&gt; foorBarQuux =
                Setting.listSetting("foo.bar.quux", Arrays.asList("a", "b", "c"), Function.identity(), DataTypes.STRING, Property.NodeScope);
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
            someGroup, someAffix)));
        Settings diff = settings.diff(Settings.builder().put("foo.bar", 5).build(), Settings.EMPTY);
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
        diff = settings.diff(
                Settings.builder().put("foo.bar", 5).build(),
                Settings.builder().put("foo.bar.baz", 17).putList("foo.bar.quux", "d", "e", "f").build());
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("d", "e", "f"));
        diff = settings.diff(
            Settings.builder().put("some.group.foo", 5).build(),
            Settings.builder().put("some.group.foobar", 17).put("some.group.foo", 25).build());
        assertEquals(4, diff.size());
        assertThat(diff.getAsInt("some.group.foobar", null), equalTo(17));
        assertNull(diff.get("some.group.foo"));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
        diff = settings.diff(
            Settings.builder().put("some.prefix.foo.somekey", 5).build(),
            Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18).build());
        assertEquals(4, diff.size());
        assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
        assertNull(diff.get("some.prefix.foo.somekey"));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
    }
    @Test
    public void testDiffWithAffixAndComplexMatcher() {
        Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting("foo.bar.baz", 1, Property.NodeScope);
        Setting&lt;Integer&gt; fooBar = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
        Setting&lt;Settings&gt; someGroup = Setting.groupSetting("some.group.", Property.Dynamic, Property.NodeScope);
        Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting("some.prefix.", "somekey", (key) -&gt; Setting.boolSetting(key, true,
            Property.NodeScope));
        Setting&lt;List&lt;String&gt;&gt; foorBarQuux = Setting.affixKeySetting("foo.", "quux",
            (key) -&gt; Setting.listSetting(key,  Arrays.asList("a", "b", "c"), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope));
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
            someGroup, someAffix)));
        Settings diff = settings.diff(Settings.builder().put("foo.bar", 5).build(), Settings.EMPTY);
        assertEquals(1, diff.size());
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertNull(diff.getAsList("foo.bar.quux", null)); 
        diff = settings.diff(
            Settings.builder().put("foo.bar", 5).build(),
            Settings.builder().put("foo.bar.baz", 17).putList("foo.bar.quux", "d", "e", "f").build());
        assertEquals(2, diff.size());
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("d", "e", "f"));
        diff = settings.diff(
            Settings.builder().put("some.group.foo", 5).build(),
            Settings.builder().put("some.group.foobar", 17).put("some.group.foo", 25).build());
        assertEquals(3, diff.size());
        assertThat(diff.getAsInt("some.group.foobar", null), equalTo(17));
        assertNull(diff.get("some.group.foo"));
        assertNull(diff.getAsList("foo.bar.quux", null));         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
        diff = settings.diff(
            Settings.builder().put("some.prefix.foo.somekey", 5).build(),
            Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18).build());
        assertEquals(3, diff.size());
        assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
        assertNull(diff.get("some.prefix.foo.somekey"));
        assertNull(diff.getAsList("foo.bar.quux", null));         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
        diff = settings.diff(
            Settings.builder().put("some.prefix.foo.somekey", 5).build(),
            Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18)
            .putList("foo.bar.quux", "x", "y", "z")
            .putList("foo.baz.quux", "d", "e", "f")
                .build());
        assertEquals(5, diff.size());
        assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
        assertNull(diff.get("some.prefix.foo.somekey"));
        assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("x", "y", "z"));
        assertEquals(diff.getAsList("foo.baz.quux", null), Arrays.asList("d", "e", "f"));
        assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
        assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
    }
<a name="8"></a>    @Test
    public void testUpdateTracer() {
        ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>AtomicReference&lt;List&lt;String&gt;&gt; ref = new AtomicReference&lt;&gt;();
        settings.addSettingsUpdateConsumer(TransportSettings.TRACE_LOG_INCLUDE_SETTING, ref::set);
        settings.applySettings(Settings.builder()
                .putList("transport.tracer.include", "internal:index/shard/recovery/*", "internal:gateway/local*").build());
        assertNotNull(ref.get</b></font>().size());
        assertEquals(ref.get().size(), 2);
        assertTrue(ref.get().contains("internal:index/shard/recovery/*"));
        assertTrue(ref.get().contains("internal:gateway/local*"));
    }
    @Test
    public void testGetSetting() {
        IndexScopedSettings settings = new IndexScopedSettings(
           Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IndexScopedSettings copy = settings.copy(Settings.builder().put("index.store.type", "boom").build(),
                newIndexMeta("foo", Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 3).build()));
        assertEquals(3, copy.get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING).intValue());
        assertEquals(1, copy.get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING).intValue());
        assertEquals("boom", copy.get(IndexModule.INDEX_STORE_TYPE_SETTING));     }
    @Test
    public void testValidateWithSuggestion() {
        IndexScopedSettings settings = new IndexScopedSettings(
            Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
            () -&gt; settings.validate(Settings.builder().put("index.numbe_of_replica", "1").build(), false));
        assertEquals(iae.getMessage(), "unknown setting [index.numbe_of_replica] did you mean [index.number_of_replicas]?");
    }
    @Test
    public void testValidate() {
        IndexScopedSettings settings = new IndexScopedSettings(
            Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        String unknownMsgSuffix = " please check that any required plugins are installed, or check the breaking changes documentation for" +
            " removed settings";
        settings.validate(Settings.builder().put("index.store.type", "boom").build(), false);
        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate(Settings.builder().put("index.store.type", "boom").put("i.am.not.a.setting", true).build(), false));
        assertEquals("unknown setting [i.am.not.a.setting]" + unknownMsgSuffix, e.getMessage());
        e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate(Settings.builder().put("index.store.type", "boom").put("index.number_of_replicas", true).build(), false));
        assertEquals("Failed to parse value [true] for setting [index.number_of_replicas]", e.getMessage());
        e = expectThrows(IllegalArgumentException.class, () -&gt;
            settings.validate("index.number_of_replicas", Settings.builder().put("index.number_of_replicas", "true").build(), false));
        assertEquals("Failed to parse value [true] for setting [index.number_of_replicas]", e.getMessage());
    }
    public static IndexMetadata newIndexMeta(String name, Settings indexSettings) {
        Settings build = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)
            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1)
            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)
            .put(indexSettings)
            .build();
        IndexMetadata metadata = IndexMetadata.builder(name).settings(build).build();
        return metadata;
    }
    @Test
    public void testKeyPattern() {
        assertTrue(AbstractScopedSettings.isValidKey("a.b.c-b.d"));
        assertTrue(AbstractScopedSettings.isValidKey("a.b.c.d"));
        assertTrue(AbstractScopedSettings.isValidKey("a.b_012.c_b.d"));
        assertTrue(AbstractScopedSettings.isValidKey("a"));
        assertFalse(AbstractScopedSettings.isValidKey("a b"));
        assertFalse(AbstractScopedSettings.isValidKey(""));
        assertFalse(AbstractScopedSettings.isValidKey("\""));
        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.groupSetting("foo.bar.", Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals("illegal settings key: [foo.bar.] must start with [index.]", e.getMessage());
        }
        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.simpleString("foo.bar", Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals("illegal settings key: [foo.bar] must start with [index.]", e.getMessage());
        }
        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.groupSetting("index. foo.", Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals("illegal settings key: [index. foo.]", e.getMessage());
        }
        new IndexScopedSettings(
            Settings.EMPTY, Collections.singleton(Setting.groupSetting("index.", Property.IndexScope)));
        try {
            new IndexScopedSettings(
                Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.", true, Property.IndexScope)));
            fail();
        } catch (IllegalArgumentException e) {
            assertEquals("illegal settings key: [index.]", e.getMessage());
        }
        new IndexScopedSettings(
            Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.boo", true, Property.IndexScope)));
        new ClusterSettings(
            Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.boo", true, Property.NodeScope)));
    }
    @Test
    public void testAffixKeyPattern() {
        assertTrue(AbstractScopedSettings.isValidAffixKey("prefix.*.suffix"));
        assertTrue(AbstractScopedSettings.isValidAffixKey("prefix.*.split.suffix"));
        assertTrue(AbstractScopedSettings.isValidAffixKey("split.prefix.*.split.suffix"));
        assertFalse(AbstractScopedSettings.isValidAffixKey("prefix.*.suffix."));
        assertFalse(AbstractScopedSettings.isValidAffixKey("prefix.*"));
        assertFalse(AbstractScopedSettings.isValidAffixKey("*.suffix"));
        assertFalse(AbstractScopedSettings.isValidAffixKey("*"));
        assertFalse(AbstractScopedSettings.isValidAffixKey(""));
    }
    @Test
    public void testLoggingUpdates() {
        final Level level = LogManager.getRootLogger().getLevel();
        final Level testLevel = LogManager.getLogger("test").getLevel();
        Level property = randomFrom(Level.values());
        Settings.Builder builder = Settings.builder().put("logger.level", property);
        try {
            ClusterSettings settings = new ClusterSettings(builder.build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
            IllegalArgumentException ex =
                expectThrows(
                    IllegalArgumentException.class,
                    () -&gt; settings.validate(Settings.builder().put("logger._root", "boom").build(), false));
            assertEquals("Unknown level constant [BOOM].", ex.getMessage());
            assertEquals(level, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
            assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().build());
            assertEquals(property, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().put("logger.test", "TRACE").build());
            assertEquals(Level.TRACE, LogManager.getLogger("test").getLevel());
            settings.applySettings(Settings.builder().build());
            assertEquals(property, LogManager.getLogger("test").getLevel());
        } finally {
            Loggers.setLevel(LogManager.getRootLogger(), level);
            Loggers.setLevel(LogManager.getLogger("test"), testLevel);
        }
    }
<a name="9"></a>    @Test
    public void testFallbackToLoggerLevel() {
        final Level level = LogManager.getRootLogger().getLevel();
        try <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
            ClusterSettings settings =
                new ClusterSettings(Settings.builder().put("logger.level", "ERROR").build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
            assertEquals(level, LogManager.getRootLogger</b></font>().getLevel());
            settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
            assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
            settings.applySettings(Settings.builder().build());             assertEquals(Level.ERROR, LogManager.getRootLogger().getLevel());
        } finally {
            Loggers.setLevel(LogManager.getRootLogger(), level);
        }
    }
    @Test
    public void testOverlappingComplexMatchSettings() {
        Set&lt;Setting&lt;?&gt;&gt; settings = new LinkedHashSet&lt;&gt;(2);
        final boolean groupFirst = randomBoolean();
        final Setting&lt;?&gt; groupSetting = Setting.groupSetting("foo.", Property.NodeScope);
        final Setting&lt;?&gt; listSetting =
            Setting.listSetting("foo.bar", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
        settings.add(groupFirst ? groupSetting : listSetting);
        settings.add(groupFirst ? listSetting : groupSetting);
        try {
            new ClusterSettings(Settings.EMPTY, settings);
            fail("an exception should have been thrown because settings overlap");
        } catch (IllegalArgumentException e) {
            if (groupFirst) {
                assertEquals("complex setting key: [foo.bar] overlaps existing setting key: [foo.]", e.getMessage());
            } else {
                assertEquals("complex setting key: [foo.] overlaps existing setting key: [foo.bar]", e.getMessage());
            }
        }
    }
    @Test
    public void testUpdateNumberOfShardsFail() {
        IndexScopedSettings settings = new IndexScopedSettings(Settings.EMPTY,
            IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
            () -&gt; settings.updateSettings(Settings.builder().put("index.number_of_shards", 8).build(),
                Settings.builder(), Settings.builder(), "index"));
        assertThat(ex.getMessage(),
            containsString("final index setting [index.number_of_shards], not updateable"));
    }
    @Test
    public void testFinalSettingUpdateFail() {
        Setting&lt;Integer&gt; finalSetting = Setting.intSetting("some.final.setting", 1, Property.Final, Property.NodeScope);
        Setting&lt;Settings&gt; finalGroupSetting = Setting.groupSetting("some.final.group.", Property.Final, Property.NodeScope);
        Settings currentSettings = Settings.builder()
            .put("some.final.setting", 9)
            .put("some.final.group.foo", 7)
            .build();
        ClusterSettings service = new ClusterSettings(currentSettings
            , new HashSet&lt;&gt;(Arrays.asList(finalSetting, finalGroupSetting)));
        IllegalArgumentException exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateDynamicSettings(Settings.builder().put("some.final.setting", 8).build(),
                Settings.builder().put(currentSettings), Settings.builder(), "node"));
        assertThat(exc.getMessage(), containsString("final node setting [some.final.setting]"));
        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateDynamicSettings(Settings.builder().putNull("some.final.setting").build(),
                Settings.builder().put(currentSettings), Settings.builder(), "node"));
        assertThat(exc.getMessage(), containsString("final node setting [some.final.setting]"));
        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateSettings(Settings.builder().put("some.final.group.new", 8).build(),
                Settings.builder().put(currentSettings), Settings.builder(), "node"));
        assertThat(exc.getMessage(), containsString("final node setting [some.final.group.new]"));
        exc = expectThrows(IllegalArgumentException.class, () -&gt;
            service.updateSettings(Settings.builder().put("some.final.group.foo", 5).build(),
                Settings.builder().put(currentSettings), Settings.builder(), "node"));
        assertThat(exc.getMessage(), containsString("final node setting [some.final.group.foo]"));
    }
    @Test
    public void testInternalIndexSettingsFailsValidation() {
        final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString("index.internal", Property.InternalIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; {
                    final Settings settings = Settings.builder().put("index.internal", "internal").build();
                    indexScopedSettings.validate(settings, false,                 });
        final String message = "can not update internal setting [index.internal]; this setting is managed via a dedicated API";
        assertThat(e, hasToString(containsString(message)));
    }
    @Test
    public void testPrivateIndexSettingsFailsValidation() {
        final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString("index.private", Property.PrivateIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
        final IllegalArgumentException e = expectThrows(
                IllegalArgumentException.class,
                () -&gt; {
                    final Settings settings = Settings.builder().put("index.private", "private").build();
                    indexScopedSettings.validate(settings, false,                 });
        final String message = "can not update private setting [index.private]; this setting is managed by CrateDB";
        assertThat(e, hasToString(containsString(message)));
    }
    @Test
    public void testInternalIndexSettingsSkipValidation() {
        final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString("index.internal", Property.InternalIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
        final Settings settings = Settings.builder().put("index.internal", "internal").build();
        indexScopedSettings.validate(settings, false,     }
    @Test
    public void testPrivateIndexSettingsSkipValidation() {
        final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString("index.private", Property.PrivateIndex, Property.IndexScope);
        final IndexScopedSettings indexScopedSettings =
                new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
        final Settings settings = Settings.builder().put("index.private", "private").build();
        indexScopedSettings.validate(settings, false,     }
    @Test
    public void testUpgradeSetting() {
        final Setting&lt;String&gt; oldSetting = Setting.simpleString("foo.old", Property.NodeScope);
        final Setting&lt;String&gt; newSetting = Setting.simpleString("foo.new", Property.NodeScope);
        final Setting&lt;String&gt; remainingSetting = Setting.simpleString("foo.remaining", Property.NodeScope);
        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {
                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }
                            @Override
                            public String getKey(final String key) {
                                return "foo.new";
                            }
                            @Override
                            public String getValue(final String value) {
                                return "new." + value;
                            }
<a name="2"></a>                        }));
        final Settings settings =
                <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder()
                        .put("foo.old", randomAlphaOfLength(8))
                        .put("foo.remaining", randomAlphaOfLength(8))
                        .build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertFalse(oldSetting.exists(upgradedSettings));
        assertTrue(newSetting.exists(upgradedSettings));
        assertThat(newSetting.get(upgradedSettings), equalTo("new." + oldSetting.get(settings)));
        assertTrue(remainingSetting.exists(upgradedSettings));
        assertThat(remainingSetting.get(upgradedSettings), equalTo(remainingSetting.get</b></font>(settings)));
    }
    @Test
    public void testUpgradeSettingsNoChangesPreservesInstance() {
        final Setting&lt;String&gt; oldSetting = Setting.simpleString("foo.old", Property.NodeScope);
        final Setting&lt;String&gt; newSetting = Setting.simpleString("foo.new", Property.NodeScope);
        final Setting&lt;String&gt; remainingSetting = Setting.simpleString("foo.remaining", Property.NodeScope);
        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {
                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }
                            @Override
                            public String getKey(final String key) {
                                return "foo.new";
                            }
                        }));
        final Settings settings = Settings.builder().put("foo.remaining", randomAlphaOfLength(8)).build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertThat(upgradedSettings, sameInstance(settings));
    }
    @Test
    public void testUpgradeComplexSetting() {
        final Setting.AffixSetting&lt;String&gt; oldSetting =
                Setting.affixKeySetting("foo.old.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
        final Setting.AffixSetting&lt;String&gt; newSetting =
                Setting.affixKeySetting("foo.new.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
        final Setting.AffixSetting&lt;String&gt; remainingSetting =
                Setting.affixKeySetting("foo.remaining.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
                        Collections.singleton(new SettingUpgrader&lt;String&gt;() {
                            @Override
                            public Setting&lt;String&gt; getSetting() {
                                return oldSetting;
                            }
                            @Override
                            public String getKey(final String key) {
                                return key.replaceFirst("^foo\\.old", "foo\\.new");
                            }
                            @Override
                            public String getValue(final String value) {
                                return "new." + value;
                            }
                        }));
        final int count = randomIntBetween(1, 8);
        final List&lt;String&gt; concretes = new ArrayList&lt;&gt;(count);
        final Settings.Builder builder = Settings.builder();
        for (int i = 0; i &lt; count; i++) {
            final String concrete = randomAlphaOfLength(8);
            concretes.add(concrete);
            builder.put("foo.old." + concrete + ".suffix", randomAlphaOfLength(8));
            builder.put("foo.remaining." + concrete + ".suffix", randomAlphaOfLength(8));
        }
        final Settings settings = builder.build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        for (final String concrete : concretes) {
            assertFalse(oldSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertTrue(newSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertThat(
                    newSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
                    equalTo("new." + oldSetting.getConcreteSettingForNamespace(concrete).get(settings)));
            assertTrue(remainingSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
            assertThat(
                    remainingSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
                    equalTo(remainingSetting.getConcreteSettingForNamespace(concrete).get(settings)));
        }
    }
    @Test
    public void testUpgradeListSetting() {
        final Setting&lt;List&lt;String&gt;&gt; oldSetting =
                Setting.listSetting("foo.old", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
        final Setting&lt;List&lt;String&gt;&gt; newSetting =
                Setting.listSetting("foo.new", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
        final AbstractScopedSettings service =
                new ClusterSettings(
                        Settings.EMPTY,
                        List.of(),
                        new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting)),
                        Collections.singleton(new SettingUpgrader&lt;List&lt;String&gt;&gt;() {
                            @Override
                            public Setting&lt;List&lt;String&gt;&gt; getSetting() {
                                return oldSetting;
                            }
                            @Override
                            public String getKey(final String key) {
                                return "foo.new";
                            }
                            @Override
                            public List&lt;String&gt; getListValue(final List&lt;String&gt; value) {
                                return value.stream().map(s -&gt; "new." + s).collect(Collectors.toList());
                            }
                        }));
        final int length = randomIntBetween(0, 16);
        final List&lt;String&gt; values = length == 0 ? Collections.emptyList() : new ArrayList&lt;&gt;(length);
        for (int i = 0; i &lt; length; i++) {
<a name="3"></a>            values.add(randomAlphaOfLength(8));
        }
        final Settings settings = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder().putList("foo.old", values).build();
        final Settings upgradedSettings = service.upgradeSettings(settings);
        assertFalse(oldSetting.exists(upgradedSettings));
        assertTrue(newSetting.exists(upgradedSettings));
        assertThat(
                newSetting.get(upgradedSettings),
                equalTo(oldSetting.get(settings).stream().map(s -&gt; "new." + s).collect</b></font>(Collectors.toList())));
    }
    @Test
    public void test_update_setting_with_dependency() throws Exception {
        Setting&lt;String&gt; low = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING;
        Setting&lt;String&gt; high = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING;
        Setting&lt;String&gt; flood = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING;
        ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, Set.of(low, high, flood));
        Settings.Builder target = Settings.builder();
        clusterSettings.updateDynamicSettings(
            Settings.builder().put(high.getKey(), "95%").build(),
            target,
            Settings.builder(),
            "update high to 95%"
        );
        clusterSettings.applySettings(target.build());
        clusterSettings.updateDynamicSettings(
            Settings.builder().put(low.getKey(), "91%").build(),
            Settings.builder(),
            Settings.builder(),
            "update low to 91%"
        );
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
