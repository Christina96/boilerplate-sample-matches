<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for StoreRecovery.java &amp; ScopedSettingsTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for StoreRecovery.java &amp; ScopedSettingsTests.java
      </h3>
<h1 align="center">
        11.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>StoreRecovery.java (18.81068%)<th>ScopedSettingsTests.java (8.031088%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-57)<td><a href="#" name="0">(21-60)</a><td align="center"><font color="#ff0000">36</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(335-343)<td><a href="#" name="1">(299-317)</a><td align="center"><font color="#bf0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(132-150)<td><a href="#" name="2">(947-956)</a><td align="center"><font color="#8d0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(435-441)<td><a href="#" name="3">(1082-1088)</a><td align="center"><font color="#5c0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(521-525)<td><a href="#" name="4">(75-79)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(486-493)<td><a href="#" name="5">(113-116)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(443-447)<td><a href="#" name="6">(440-442)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(330-332)<td><a href="#" name="7">(71-75)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(328-329)<td><a href="#" name="8">(632-636)</a><td align="center"><font color="#460000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(196-200)<td><a href="#" name="9">(788-791)</a><td align="center"><font color="#3f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>StoreRecovery.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.index.shard;
2 import org.apache.logging.log4j.Logger;
3 import org.apache.lucene.index.IndexWriter;
4 import org.apache.lucene.index.IndexWriterConfig;
5 import org.apache.lucene.index.NoMergePolicy;
6 import org.apache.lucene.index.SegmentInfos;
7 import org.apache.lucene.store.Directory;
8 import org.apache.lucene.store.FilterDirectory;
9 import org.apache.lucene.store.IOContext;
10 import org.apache.lucene.store.IndexInput;
11 import org.elasticsearch.ExceptionsHelper;
12 import org.elasticsearch.action.ActionListener;
13 import org.elasticsearch.cluster.metadata.IndexMetadata;
14 import org.elasticsearch.cluster.metadata.MappingMetadata;
15 import org.elasticsearch.cluster.routing.RecoverySource;
16 import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;
17 import org.elasticsearch.common.UUIDs;
18 import org.elasticsearch.common.lucene.Lucene;
19 import org.elasticsearch.common.unit.ByteSizeValue;
20 import io.crate.common.unit.TimeValue;
21 import org.elasticsearch.index.Index;
22 import org.elasticsearch.index.engine.Engine;
23 import org.elasticsearch.index.engine.EngineException;
24 import org.elasticsearch.index.mapper.MapperService;
25 import org.elasticsearch.index.seqno.SequenceNumbers;
26 import org.elasticsearch.index.snapshots.IndexShardRestoreFailedException;
27 import org.elasticsearch.index.store.Store;
28 import org.elasticsearch.index.translog.Translog;
29 import org.elasticsearch.indices.recovery.RecoveryState;
30 import org.elasticsearch.repositories.IndexId;
31 import org.elasticsearch.repositories.Repository;
32 import java.io.IOException;
33 import java.util.Arrays;
34 import java.util.HashMap;
35 import java.util.List;
36 import</b></font> java.util.Set;
37 import java.util.concurrent.atomic.AtomicBoolean;
38 import java.util.function.Consumer;
39 import java.util.stream.Collectors;
40 import static io.crate.common.unit.TimeValue.timeValueMillis;
41 final class StoreRecovery {
42     private final Logger logger;
43     private final ShardId shardId;
44     StoreRecovery(ShardId shardId, Logger logger) {
45         this.logger = logger;
46         this.shardId = shardId;
47     }
48     void recoverFromStore(final IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
49         if (canRecover(indexShard)) {
50             RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
51             assert
52                 recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :
53                 "expected store recovery type but was: " + recoveryType;
54             ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
55                 logger.debug("starting recovery from store ...");
56                 internalRecoverFromStore(indexShard);
57                 return true;
58             });
59         } else {
60             listener.onResponse(false);
61         }
62     }
63     void recoverFromLocalShards(Consumer&lt;MappingMetadata&gt; mappingUpdateConsumer,
64                                 IndexShard indexShard,
65                                 List&lt;LocalShardSnapshot&gt; shards,
66                                 ActionListener&lt;Boolean&gt; listener) {
67         if (canRecover(indexShard)) {
68             RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
69             assert
70                 recoveryType == RecoverySource.Type.LOCAL_SHARDS :
71                 "expected local shards recovery type: " + recoveryType;
72             if (shards.isEmpty()) {
73                 throw new IllegalArgumentException("shards must not be empty");
74             }
75             Set&lt;Index&gt; indices = shards.stream().map((s) -&gt; s.getIndex()).collect(Collectors.toSet());
76             if (indices.size() &gt; 1) {
77                 throw new IllegalArgumentException("can't add shards from more than one index");
78             }
79             IndexMetadata sourceMetadata = shards.get(0).getIndexMetadata();
80             if (sourceMetadata.mapping() != null) {
81                 mappingUpdateConsumer.accept(sourceMetadata.mapping());
82             }
83             indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);
84             final boolean isSplit = sourceMetadata.getNumberOfShards() &lt; indexShard.indexSettings().getNumberOfShards();
85             ActionListener.completeWith(recoveryListener(indexShard, listener), () -&gt; {
86                 logger.debug("starting recovery from local shards {}", shards);
87 <a name="2"></a>                try {
88                     final Directory directory = indexShard.store().directory();                     final Directory[] sources = shards.stream().map(LocalShardSnapshot::getSnapshotDirectory).toArray(Directory[]::new);
89                     final long maxSeqNo = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>shards.stream().mapToLong(LocalShardSnapshot::maxSeqNo).max().getAsLong();
90                     final long maxUnsafeAutoIdTimestamp = shards.stream()
91                         .mapToLong(LocalShardSnapshot::maxUnsafeAutoIdTimestamp)
92                         .max()
93                         .getAsLong();
94                     addIndices(
95                         indexShard.recoveryState().getIndex(),
96                         directory,
97                         sources,
98                         maxSeqNo,
99                         maxUnsafeAutoIdTimestamp,
100                         indexShard.indexSettings().getIndexMetadata(),
101                         indexShard.shardId().id(),
102                         isSplit
103                     );
104                     internalRecoverFromStore(indexShard);
105                     indexShard.getEngine().forceMerge(false, -1, false, false, false, UUIDs.randomBase64UUID</b></font>());
106                     return true;
107                 } catch (IOException ex) {
108                     throw new IndexShardRecoveryException(indexShard.shardId(), "failed to recover from local shards", ex);
109                 }
110             });
111         } else {
112             listener.onResponse(false);
113         }
114     }
115     void addIndices(final RecoveryState.Index indexRecoveryStats,
116                     final Directory target,
117                     final Directory[] sources,
118                     final long maxSeqNo,
119                     final long maxUnsafeAutoIdTimestamp,
120                     IndexMetadata indexMetadata,
121                     int shardId,
122                     boolean split) throws IOException {
123         assert sources.length &gt; 0;
124         final int luceneIndexCreatedVersionMajor = Lucene.readSegmentInfos(sources[0]).getIndexCreatedVersionMajor();
125         final Directory hardLinkOrCopyTarget = new org.apache.lucene.store.HardlinkCopyDirectoryWrapper(target);
126         IndexWriterConfig iwc = new IndexWriterConfig(null)
127             .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)
128             .setCommitOnClose(false)
129             .setMergePolicy(NoMergePolicy.INSTANCE)
130             .setOpenMode(IndexWriterConfig.OpenMode.CREATE)
131             .setIndexCreatedVersionMajor(luceneIndexCreatedVersionMajor);
132         try (IndexWriter writer = new IndexWriter(new StatsDirectoryWrapper(hardLinkOrCopyTarget, indexRecoveryStats), iwc)) {
133             writer.addIndexes(sources);
134             indexRecoveryStats.setFileDetailsComplete();
135             if (split) {
136                 writer.deleteDocuments(new ShardSplittingQuery(indexMetadata, shardId));
137             }
138             writer.setLiveCommitData(() -&gt; <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
139                 final HashMap&lt;String, String&gt; liveCommitData = new HashMap&lt;&gt;(3);
140                 liveCommitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(maxSeqNo));
141                 liveCommitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(maxSeqNo));
142                 liveCommitData.put(Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString</b></font>(maxUnsafeAutoIdTimestamp));
143                 return liveCommitData.entrySet().iterator();
144             });
145             writer.commit();
146         }
147     }
148     static final class StatsDirectoryWrapper extends FilterDirectory {
149         private final RecoveryState.Index index;
150         StatsDirectoryWrapper(Directory in, RecoveryState.Index indexRecoveryStats) {
151             super(in);
152             this.index = indexRecoveryStats;
153         }
154         @Override
155         public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
156             final long l = from.fileLength(src);
157             final AtomicBoolean copies = new AtomicBoolean(false);
158             in.copyFrom(new FilterDirectory(from) {
159                 @Override
160                 public IndexInput openInput(String name, IOContext context) throws IOException {
161                     index.addFileDetail(dest, l, false);
162                     copies.set(true);
163                     final IndexInput input = in.openInput(name, context);
164                     return new IndexInput("StatsDirectoryWrapper(" + input.toString() + ")") {
165                         @Override
166                         public void close() throws IOException {
167                             input.close();
168                         }
169                         @Override
170                         public long getFilePointer() {
171                             throw new UnsupportedOperationException("only straight copies are supported");
172                         }
173                         @Override
174                         public void seek(long pos) throws IOException {
175                             throw new UnsupportedOperationException("seeks are not supported");
176                         }
177                         @Override
178                         public long length() {
179                             return input.length();
180                         }
181                         @Override
182                         public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
183                             throw new UnsupportedOperationException("slices are not supported");
184                         }
185                         @Override
186                         public byte readByte() throws IOException {
187                             throw new UnsupportedOperationException("use a buffer if you wanna perform well");
188                         }
189                         @Override
190                         public void readBytes(byte[] b, int offset, int len) throws IOException {
191                             input.readBytes(b, offset, len);
192                             index.addRecoveredBytesToFile(dest, len);
193                         }
194                     };
195                 }
196             }, src, dest, context);
197             if (copies.get() == false) {
198                 index.addFileDetail(dest, l, true);             } else {
199                 assert index.getFileDetails(dest) != null : "File [" + dest + "] has no file details";
200                 assert index.getFileDetails(dest).recovered() == l : index.getFileDetails(dest).toString();
201             }
202         }
203     }
204     void recoverFromRepository(final IndexShard indexShard, Repository repository, ActionListener&lt;Boolean&gt; listener) {
205         try {
206             if (canRecover(indexShard)) {
207                 RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType();
208                 assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType;
209                 SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource();
210                 restore(indexShard, repository, recoverySource, recoveryListener(indexShard, listener));
211             } else {
212                 listener.onResponse(false);
213             }
214         } catch (Exception e) {
215             listener.onFailure(e);
216         }
217     }
218     private boolean canRecover(IndexShard indexShard) {
219         if (indexShard.state() == IndexShardState.CLOSED) {
220             return false;
221         }
222         if (indexShard.routingEntry().primary() == false) {
223             throw new IndexShardRecoveryException(shardId, "Trying to recover when the shard is in backup state", null);
224         }
225         return true;
226     }
227     private ActionListener&lt;Boolean&gt; recoveryListener(IndexShard indexShard, ActionListener&lt;Boolean&gt; listener) {
228         return ActionListener.wrap(
229             res -&gt; {
230                 if (res) {
231                     final IndexShardState shardState = indexShard.state();
232                     final RecoveryState recoveryState = indexShard.recoveryState();
233                     assert shardState != IndexShardState.CREATED &amp;&amp; shardState != IndexShardState.RECOVERING :
234                         "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]";
235 <a name="8"></a>
236                     if (logger.isTraceEnabled()) {
237 <a name="7"></a>                        RecoveryState.Index index = recoveryState.getIndex();
238                         <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>StringBuilder sb = new StringBuilder();
239                         sb.append("    index    : files           [").append(index.totalFileCount</b></font>()).append("] with total_size [")
240                             .append(<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ByteSizeValue(index.totalBytes())).append("], took[")
241                             .append(TimeValue.timeValueMillis(index.time())).append("]\n");
242 <a name="1"></a>                        sb.append("             : recovered_files [").append(index.recoveredFileCount</b></font>()).append("] with total_size [")
243                             .append(new ByteSizeValue(index.recoveredBytes())).append("]\n");
244                         sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")
245                             .append(new ByteSizeValue(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>index.reusedBytes())).append("]\n");
246                         sb.append("    verify_index    : took [")
247                             .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")
248                             .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n");
249                         sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())
250                             .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]");
251                         logger.trace("recovery completed from [shard_store], took [{}]\n{}",
252                             timeValueMillis(recoveryState.getTimer().time()), sb);
253                     }</b></font> else if (logger.isDebugEnabled()) {
254                         logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()));
255                     }
256                 }
257                 listener.onResponse(res);
258             },
259             ex -&gt; {
260                 if (ex instanceof IndexShardRecoveryException) {
261                     if (indexShard.state() == IndexShardState.CLOSED) {
262                         listener.onResponse(false);
263                         return;
264                     }
265                     if ((ex.getCause() instanceof IndexShardClosedException) || (ex.getCause() instanceof IndexShardNotStartedException)) {
266                         listener.onResponse(false);
267                         return;
268                     }
269                     listener.onFailure(ex);
270                 } else if (ex instanceof IndexShardClosedException || ex instanceof IndexShardNotStartedException) {
271                     listener.onResponse(false);
272                 } else {
273                     if (indexShard.state() == IndexShardState.CLOSED) {
274                         listener.onResponse(false);
275                     } else {
276                         listener.onFailure(new IndexShardRecoveryException(shardId, "failed recovery", ex));
277                     }
278                 }
279             }
280         );
281     }
282     private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {
283         final RecoveryState recoveryState = indexShard.recoveryState();
284         final boolean indexShouldExists =
285             recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE;
286         indexShard.prepareForIndexRecovery();
287         SegmentInfos si = null;
288         final Store store = indexShard.store();
289         store.incRef();
290         try {
291             try {
292                 store.failIfCorrupted();
293                 try {
294                     si = store.readLastCommittedSegmentsInfo();
295                 } catch (Exception e) {
296                     String files = "_unknown_";
297                     try {
298                         files = Arrays.toString(store.directory().listAll());
299                     } catch (Exception inner) {
300                         files += " (failure=" + ExceptionsHelper.stackTrace(inner) + ")";
301                     }
302                     if (indexShouldExists) {
303                         throw new IndexShardRecoveryException(shardId,
304                             "shard allocated for local recovery (post api), should exist, but doesn't, current files: " +
305                             files, e);
306                     }
307                 }
308                 if (si != null &amp;&amp; indexShouldExists == false) {
309                     logger.trace("cleaning existing shard, shouldn't exists");
310                     Lucene.cleanLuceneIndex(store.directory());
311                     si = null;
312                 }
313             } catch (Exception e) {
314                 throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e);
315             }
316             if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {
317                 assert indexShouldExists;
318                 bootstrap(indexShard, store);
319                 writeEmptyRetentionLeasesFile(indexShard);
320             } else if (indexShouldExists) {
321                 if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {
322                     store.bootstrapNewHistory();
323                     writeEmptyRetentionLeasesFile(indexShard);
324                 }
325                 final RecoveryState.Index index = recoveryState.getIndex();
326                 try {
327                     if (si != null) {
328                         addRecoveredFileDetails(si, store, index);
329                     }
330                 } catch (IOException e) {
331                     logger.debug("failed to list file details", e);
332 <a name="3"></a>                }
333                 index.setFileDetailsComplete();
334             } else {
335                 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion);
336                 final String translogUUID = Translog.createEmptyTranslog(
337                     indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,
338                     indexShard.getPendingPrimaryTerm());
339                 store.associateIndexWithNewTranslog(translogUUID);
340 <a name="6"></a>                writeEmptyRetentionLeasesFile(indexShard);
341                 indexShard.recoveryState</b></font>().getIndex().setFileDetailsComplete();
342             }
343             <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>indexShard.openEngineAndRecoverFromTranslog();
344             indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
345             indexShard.finalizeRecovery();
346             indexShard.postRecovery("post recovery from shard_store");
347         } catch (EngineException | IOException e) {</b></font>
348             throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e);
349         } finally {
350             store.decRef();
351         }
352     }
353     private static void writeEmptyRetentionLeasesFile(IndexShard indexShard) throws IOException {
354         assert indexShard.getRetentionLeases().leases().isEmpty() : indexShard.getRetentionLeases();         indexShard.persistRetentionLeases();
355         assert indexShard.loadRetentionLeases().leases().isEmpty();
356     }
357     private void addRecoveredFileDetails(SegmentInfos si, Store store, RecoveryState.Index index) throws IOException {
358         final Directory directory = store.directory();
359         for (String name : Lucene.files(si)) {
360             long length = directory.fileLength(name);
361             index.addFileDetail(name, length, true);
362         }
363     }
364     private void restore(IndexShard indexShard, Repository repository, SnapshotRecoverySource restoreSource,
365                          ActionListener&lt;Boolean&gt; listener) {
366         logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource());
367         final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog();
368         if (restoreSource == null) {
369             listener.onFailure(new IndexShardRestoreFailedException(shardId, "empty restore source"));
370             return;
371         }
372         if (logger.isTraceEnabled()) {
373             logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId);
374         }
375         final ActionListener&lt;Void&gt; restoreListener = ActionListener.wrap(
376 <a name="5"></a>            v -&gt; {
377                 final Store store = indexShard.store();
378                 bootstrap(indexShard, store);
379                 assert <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>indexShard.shardRouting.primary() : "only primary shards can recover from store";
380                 writeEmptyRetentionLeasesFile(indexShard);
381                 indexShard.openEngineAndRecoverFromTranslog();
382                 indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm());
383                 indexShard.finalizeRecovery();
384                 indexShard.postRecovery("restore done");
385                 listener.onResponse(true);
386             }</b></font>, e -&gt; listener.onFailure(new IndexShardRestoreFailedException(shardId, "restore failed", e))
387         );
388         try {
389             translogState.totalOperations(0);
390             translogState.totalOperationsOnStart(0);
391             indexShard.prepareForIndexRecovery();
392             final ShardId snapshotShardId;
393             final String indexName = restoreSource.index();
394             if (!shardId.getIndexName().equals(indexName)) {
395                 snapshotShardId = new ShardId(indexName, IndexMetadata.INDEX_UUID_NA_VALUE, shardId.id());
396             } else {
397                 snapshotShardId = shardId;
398             }
399             repository.getRepositoryData(ActionListener.wrap(
400                 repositoryData -&gt; {
401                     final IndexId indexId = repositoryData.resolveIndexId(indexName);
402                     assert indexShard.getEngineOrNull() == null;
403                     repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,
404                         indexShard.recoveryState(), restoreListener);
405                 }, restoreListener::onFailure
406             ));
407         } catch (Exception e) {
408             restoreListener.onFailure(e);
409         }
410     }
411 <a name="4"></a>
412     private void bootstrap(final IndexShard indexShard, final Store store) throws IOException {
413         store.bootstrapNewHistory();
414         final SegmentInfos segmentInfos = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>store.readLastCommittedSegmentsInfo();
415         final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
416         final String translogUUID = Translog.createEmptyTranslog(
417             indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());
418         store.associateIndexWithNewTranslog</b></font>(translogUUID);
419     }
420 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScopedSettingsTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18 <a name="0"></a> * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.common.settings;
22 import static org.hamcrest.CoreMatchers.containsString;
23 import static org.hamcrest.CoreMatchers.equalTo;
24 import static org.hamcrest.Matchers.hasToString;
25 import static org.hamcrest.Matchers.sameInstance;
26 import java.io.IOException;
27 import java.util.ArrayList;
28 import java.util.Arrays;
29 import java.util.Collections;
30 import java.util.HashMap;
31 import java.util.HashSet;
32 import java.util.LinkedHashSet;
33 import java.util.List;
34 import java.util.Map;
35 import java.util.Set;
36 import java.util.concurrent.atomic.AtomicInteger;
37 import java.util.concurrent.atomic.AtomicReference;
38 import java.util.function.BiConsumer;
39 import java.util.function.Consumer;
40 import java.util.function.Function;
41 import java.util.stream.Collectors;
42 import org.apache.logging.log4j.Level;
43 import org.apache.logging.log4j.LogManager;
44 import org.elasticsearch.Version;
45 import org.elasticsearch.cluster.metadata.IndexMetadata;
46 import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;
47 import org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider;
48 import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocationDecider;
49 import org.elasticsearch.common.logging.Loggers;
50 import org.elasticsearch.common.settings.Setting.Property;
51 import org.elasticsearch.index.IndexModule;
52 import org.elasticsearch.test.ESTestCase;
53 import org.elasticsearch.transport.TransportSettings;
54 import org.junit.Test;
55 import io.crate.types.ArrayType;
56 import</b></font> io.crate.types.DataTypes;
57 public class ScopedSettingsTests extends ESTestCase {
58     @Test
59     public void testResetSetting() {
60         Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting("some.dyn.setting", 1, Property.Dynamic, Property.NodeScope);
61         Setting&lt;Integer&gt; staticSetting = Setting.intSetting("some.static.setting", 1, Property.NodeScope);
62 <a name="7"></a>        Settings currentSettings = Settings.builder().put("some.dyn.setting", 5).put("some.static.setting", 6).put("archived.foo.bar", 9)
63             .build();
64         ClusterSettings service = new ClusterSettings(currentSettings
65             , <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, staticSetting)));
66 <a name="4"></a>
67         expectThrows(IllegalArgumentException.class, () -&gt;
68         service.updateDynamicSettings(Settings.builder().put("some.dyn.setting", 8).putNull("some.static.setting").build(),
69             Settings.builder</b></font>().put(currentSettings), <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder(), "node"));
70         Settings.Builder target = Settings.builder().put(currentSettings);
71         Settings.Builder update = Settings.builder();
72         assertTrue(service.updateDynamicSettings(Settings.builder().put</b></font>("some.dyn.setting", 8).build(),
73             target, update, "node"));
74         assertEquals(8, dynamicSetting.get(target.build()).intValue());
75         assertEquals(6, staticSetting.get(target.build()).intValue());
76         assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
77         target = Settings.builder().put(currentSettings);
78         update = Settings.builder();
79         assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.dyn.setting").build(),
80             target, update, "node"));
81         assertEquals(1, dynamicSetting.get(target.build()).intValue());
82         assertEquals(6, staticSetting.get(target.build()).intValue());
83         assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
84         target = Settings.builder().put(currentSettings);
85         update = Settings.builder();
86         assertTrue(service.updateDynamicSettings(Settings.builder().putNull("archived.foo.bar").build(),
87             target, update, "node"));
88         assertEquals(5, dynamicSetting.get(target.build()).intValue());
89         assertEquals(6, staticSetting.get(target.build()).intValue());
90         assertNull(target.build().getAsInt("archived.foo.bar", null));
91         target = Settings.builder().put(currentSettings);
92         update = Settings.builder();
93         assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.*").build(),
94             target, update, "node"));
95         assertEquals(1, dynamicSetting.get(target.build()).intValue());
96         assertEquals(6, staticSetting.get(target.build()).intValue());
97         assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());
98         target = Settings.builder().put(currentSettings);
99 <a name="5"></a>        update = Settings.builder();
100         assertTrue(service.updateDynamicSettings(Settings.builder().putNull("*").build(),
101             target, update, "node"));
102         assertEquals(1, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>dynamicSetting.get(target.build()).intValue());
103         assertEquals(6, staticSetting.get(target.build()).intValue());
104         assertNull(target.build().getAsInt("archived.foo.bar", null));
105     }</b></font>
106     @Test
107     public void testResetSettingWithIPValidator() {
108         Settings currentSettings = Settings.builder().put("index.routing.allocation.require._ip", "192.168.0.1,127.0.0.1")
109             .put("index.some.dyn.setting", 1)
110             .build();
111         Setting&lt;Integer&gt; dynamicSetting = Setting.intSetting("index.some.dyn.setting", 1, Property.Dynamic, Property.IndexScope);
112         IndexScopedSettings settings = new IndexScopedSettings(currentSettings,
113             new HashSet&lt;&gt;(Arrays.asList(dynamicSetting, IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING)));
114         Map&lt;String, String&gt; s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
115         assertEquals(1, s.size());
116         assertEquals("192.168.0.1,127.0.0.1", s.get("_ip"));
117         Settings.Builder builder = Settings.builder();
118         Settings updates = Settings.builder().putNull("index.routing.allocation.require._ip")
119             .put("index.some.dyn.setting", 1).build();
120         settings.validate(updates, false);
121         settings.updateDynamicSettings(updates,
122             Settings.builder().put(currentSettings), builder, "node");
123         currentSettings = builder.build();
124         s = IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(currentSettings);
125         assertEquals(0, s.size());
126         assertEquals(1, dynamicSetting.get(currentSettings).intValue());
127         assertEquals(1, currentSettings.size());
128     }
129     @Test
130     public void testAddConsumer() {
131         Setting&lt;Integer&gt; testSetting = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
132         Setting&lt;Integer&gt; testSetting2 = Setting.intSetting("foo.bar.baz", 1, Property.Dynamic, Property.NodeScope);
133         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, Collections.singleton(testSetting));
134         AtomicInteger consumer = new AtomicInteger();
135         service.addSettingsUpdateConsumer(testSetting, consumer::set);
136         AtomicInteger consumer2 = new AtomicInteger();
137         try {
138             service.addSettingsUpdateConsumer(testSetting2, consumer2::set);
139             fail("setting not registered");
140         } catch (IllegalArgumentException ex) {
141             assertEquals("Setting is not registered for key [foo.bar.baz]", ex.getMessage());
142         }
143         try {
144             service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
145                 consumer.set(a);
146                 consumer2.set(b);
147             });
148             fail("setting not registered");
149         } catch (IllegalArgumentException ex) {
150             assertEquals("Setting is not registered for key [foo.bar.baz]", ex.getMessage());
151         }
152         assertEquals(0, consumer.get());
153         assertEquals(0, consumer2.get());
154         service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
155         assertEquals(2, consumer.get());
156         assertEquals(0, consumer2.get());
157     }
158     @Test
159     public void testDependentSettings() {
160         Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting("foo.", "name",
161             (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
162         Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
163             (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope), () -&gt; stringSetting);
164         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));
165         IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
166             () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).build(), true));
167         assertEquals("missing required setting [foo.test.name] for setting [foo.test.bar]", iae.getMessage());
168         service.validate(Settings.builder()
169             .put("foo.test.name", "test")
170             .put("foo.test.bar", 7)
171             .build(), true);
172         service.validate(Settings.builder().put("foo.test.bar", 7).build(), false);
173     }
174     @Test
175     public void testDependentSettingsValidate() {
176         Setting.AffixSetting&lt;String&gt; stringSetting = Setting.affixKeySetting(
177             "foo.",
178             "name",
179             (k) -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
180         Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting(
181             "foo.",
182             "bar",
183             (k) -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
184             new Setting.AffixSettingDependency() {
185                 @Override
186                 public Setting.AffixSetting getSetting() {
187                     return stringSetting;
188                 }
189                 @Override
190                 public void validate(final String key, final Object value, final Object dependency) {
191                     if ("valid".equals(dependency) == false) {
192                         throw new SettingsException("[" + key + "] is set but [name] is [" + dependency + "]");
193                     }
194                 }
195             });
196         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(intSetting, stringSetting)));
197         SettingsException iae = expectThrows(
198             SettingsException.class,
199             () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).put("foo.test.name", "invalid").build(), true));
200         assertEquals("[foo.test.bar] is set but [name] is [invalid]", iae.getMessage());
201         service.validate(Settings.builder()
202                 .put("foo.test.bar", 7)
203                 .put("foo.test.name", "valid")
204                 .build(),
205             true);
206         service.validate(Settings.builder()
207             .put("foo.test.bar", 7)
208             .put("foo.test.name", "invalid")
209             .build(),
210             false);
211     }
212     public void testDependentSettingsWithFallback() {
213         Setting.AffixSetting&lt;String&gt; nameFallbackSetting =
214                 Setting.affixKeySetting("fallback.", "name", k -&gt; Setting.simpleString(k, Property.Dynamic, Property.NodeScope));
215         Setting.AffixSetting&lt;String&gt; nameSetting = Setting.affixKeySetting(
216                 "foo.",
217                 "name",
218                 k -&gt; Setting.simpleString(
219                         k,
220                         "_na_".equals(k)
221                                 ? nameFallbackSetting.getConcreteSettingForNamespace(k)
222                                 : nameFallbackSetting.getConcreteSetting(k.replaceAll("^foo", "fallback")),
223                         Property.Dynamic,
224                         Property.NodeScope));
225         Setting.AffixSetting&lt;Integer&gt; barSetting = Setting.affixKeySetting(
226             "foo.",
227             "bar",
228             k -&gt; Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope),
229             () -&gt; nameSetting);
230         final AbstractScopedSettings service =
231                 new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(nameFallbackSetting, nameSetting, barSetting)));
232         final IllegalArgumentException e = expectThrows(
233                 IllegalArgumentException.class,
234                 () -&gt; service.validate(Settings.builder().put("foo.test.bar", 7).build(), true));
235         assertThat(e, hasToString(containsString("missing required setting [foo.test.name] for setting [foo.test.bar]")));
236         service.validate(Settings.builder().put("foo.test.name", "test").put("foo.test.bar", 7).build(), true);
237         service.validate(Settings.builder().put("fallback.test.name", "test").put("foo.test.bar", 7).build(), true);
238     }
239     @Test
240     public void testAddConsumerAffix() {
241         Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
242             (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
243         Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting("foo.", "list",
244             (k) -&gt; Setting.listSetting(k, Arrays.asList("1"), Integer::parseInt, new ArrayType&lt;&gt;(DataTypes.INTEGER), Property.Dynamic, Property.NodeScope));
245         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
246         Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
247         Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();
248         BiConsumer&lt;String, Integer&gt; intConsumer = intResults::put;
249         BiConsumer&lt;String, List&lt;Integer&gt;&gt; listConsumer = listResults::put;
250         service.addAffixUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
251         service.addAffixUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
252         assertEquals(0, listResults.size());
253         assertEquals(0, intResults.size());
254         service.applySettings(Settings.builder()
255             .put("foo.test.bar", 2)
256             .put("foo.test_1.bar", 7)
257             .putList("foo.test_list.list", "16", "17")
258             .putList("foo.test_list_1.list", "18", "19", "20")
259             .build());
260         assertEquals(2, intResults.get("test").intValue());
261 <a name="1"></a>        assertEquals(7, intResults.get("test_1").intValue());
262         assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
263         assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
264         assertEquals(2, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>listResults.size());
265         assertEquals(2, intResults.size());
266         listResults.clear();
267         intResults.clear();
268         service.applySettings(Settings.builder()
269             .put("foo.test.bar", 2)
270             .put("foo.test_1.bar", 8)
271             .putList("foo.test_list.list", "16", "17")
272             .putNull("foo.test_list_1.list")
273             .build());
274         assertNull("test wasn't changed", intResults.get("test"));
275         assertEquals(8, intResults.get("test_1").intValue());
276         assertNull("test_list wasn't changed", listResults.get("test_list"));
277         assertEquals(Arrays.asList(1), listResults.get("test_list_1"));         assertEquals(1, listResults.size());
278         assertEquals(1, intResults.size());
279     }</b></font>
280     @Test
281     public void testAddConsumerAffixMap() {
282         Setting.AffixSetting&lt;Integer&gt; intSetting = Setting.affixKeySetting("foo.", "bar",
283             (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
284         Setting.AffixSetting&lt;List&lt;Integer&gt;&gt; listSetting = Setting.affixKeySetting("foo.", "list",
285             (k) -&gt; Setting.listSetting(k, Arrays.asList("1"), Integer::parseInt, DataTypes.INTEGER_ARRAY, Property.Dynamic, Property.NodeScope));
286         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(intSetting, listSetting)));
287         Map&lt;String, List&lt;Integer&gt;&gt; listResults = new HashMap&lt;&gt;();
288         Map&lt;String, Integer&gt; intResults = new HashMap&lt;&gt;();
289         Consumer&lt;Map&lt;String,Integer&gt;&gt; intConsumer = (map) -&gt; {
290             intResults.clear();
291             intResults.putAll(map);
292         };
293         Consumer&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt; listConsumer = (map) -&gt; {
294             listResults.clear();
295             listResults.putAll(map);
296         };
297         service.addAffixMapUpdateConsumer(listSetting, listConsumer, (s, k) -&gt; {});
298         service.addAffixMapUpdateConsumer(intSetting, intConsumer, (s, k) -&gt; {});
299         assertEquals(0, listResults.size());
300         assertEquals(0, intResults.size());
301         service.applySettings(Settings.builder()
302             .put("foo.test.bar", 2)
303             .put("foo.test_1.bar", 7)
304             .putList("foo.test_list.list", "16", "17")
305             .putList("foo.test_list_1.list", "18", "19", "20")
306             .build());
307         assertEquals(2, intResults.get("test").intValue());
308         assertEquals(7, intResults.get("test_1").intValue());
309         assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
310         assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
311         assertEquals(2, listResults.size());
312         assertEquals(2, intResults.size());
313         service.applySettings(Settings.builder()
314             .put("foo.test.bar", 2)
315             .put("foo.test_1.bar", 7)
316             .putList("foo.test_list.list", "16", "17")
317             .putList("foo.test_list_1.list", "18", "19", "20")
318             .build());
319         assertEquals(2, intResults.get("test").intValue());
320         assertEquals(7, intResults.get("test_1").intValue());
321         assertEquals(Arrays.asList(16, 17), listResults.get("test_list"));
322         assertEquals(Arrays.asList(18, 19, 20), listResults.get("test_list_1"));
323         assertEquals(2, listResults.size());
324         assertEquals(2, intResults.size());
325         listResults.clear();
326         intResults.clear();
327         service.applySettings(Settings.builder()
328             .put("foo.test.bar", 2)
329             .put("foo.test_1.bar", 8)
330             .putList("foo.test_list.list", "16", "17")
331             .putNull("foo.test_list_1.list")
332             .build());
333         assertNull("test wasn't changed", intResults.get("test"));
334         assertEquals(8, intResults.get("test_1").intValue());
335         assertNull("test_list wasn't changed", listResults.get("test_list"));
336         assertEquals(Arrays.asList(1), listResults.get("test_list_1"));         assertEquals(1, listResults.size());
337         assertEquals(1, intResults.size());
338     }
339     @Test
340     public void testAffixMapConsumerNotCalledWithNull() {
341         Setting.AffixSetting&lt;Integer&gt; prefixSetting = Setting.prefixKeySetting("eggplant.",
342                 (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
343         Setting.AffixSetting&lt;Integer&gt; otherSetting = Setting.prefixKeySetting("other.",
344                 (k) -&gt;  Setting.intSetting(k, 1, Property.Dynamic, Property.NodeScope));
345         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY,new HashSet&lt;&gt;(Arrays.asList(prefixSetting, otherSetting)));
346         Map&lt;String, Integer&gt; affixResults = new HashMap&lt;&gt;();
347         Consumer&lt;Map&lt;String,Integer&gt;&gt; consumer = (map) -&gt; {
348             logger.info("--&gt; consuming settings {}", map);
349             affixResults.clear();
350             affixResults.putAll(map);
351         };
352         service.addAffixMapUpdateConsumer(prefixSetting, consumer, (s, k) -&gt; {});
353         assertEquals(0, affixResults.size());
354         service.applySettings(Settings.builder()
355                 .put("eggplant._name", 2)
356                 .build());
357         assertThat(affixResults.size(), equalTo(1));
358         assertThat(affixResults.get("_name"), equalTo(2));
359         service.applySettings(Settings.builder()
360                 .put("eggplant._name", 2)
361                 .put("other.thing", 3)
362                 .build());
363         assertThat(affixResults.get("_name"), equalTo(2));
364     }
365     @Test
366     public void testApply() {
367         Setting&lt;Integer&gt; testSetting = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
368         Setting&lt;Integer&gt; testSetting2 = Setting.intSetting("foo.bar.baz", 1, Property.Dynamic, Property.NodeScope);
369         AbstractScopedSettings service = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(testSetting, testSetting2)));
370         AtomicInteger consumer = new AtomicInteger();
371         service.addSettingsUpdateConsumer(testSetting, consumer::set);
372         AtomicInteger consumer2 = new AtomicInteger();
373         service.addSettingsUpdateConsumer(testSetting2, consumer2::set, (s) -&gt; assertTrue(s &gt; 0));
374         AtomicInteger aC = new AtomicInteger();
375         AtomicInteger bC = new AtomicInteger();
376         service.addSettingsUpdateConsumer(testSetting, testSetting2, (a, b) -&gt; {
377             aC.set(a);
378             bC.set(b);
379         });
380         assertEquals(0, consumer.get());
381         assertEquals(0, consumer2.get());
382 <a name="6"></a>        assertEquals(0, aC.get());
383         assertEquals(0, bC.get());
384         try {
385             <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", -15).build());
386             fail("invalid value");
387         } catch (IllegalArgumentException ex) {</b></font>
388             assertEquals("illegal value can't update [foo.bar.baz] from [1] to [-15]", ex.getMessage());
389         }
390         assertEquals(0, consumer.get());
391         assertEquals(0, consumer2.get());
392         assertEquals(0, aC.get());
393         assertEquals(0, bC.get());
394         try {
395             service.validateUpdate(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", -15).build());
396             fail("invalid value");
397         } catch (IllegalArgumentException ex) {
398             assertEquals("illegal value can't update [foo.bar.baz] from [1] to [-15]", ex.getMessage());
399         }
400         assertEquals(0, consumer.get());
401         assertEquals(0, consumer2.get());
402         assertEquals(0, aC.get());
403         assertEquals(0, bC.get());
404         service.validateUpdate(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
405         assertEquals(0, consumer.get());
406         assertEquals(0, consumer2.get());
407         assertEquals(0, aC.get());
408         assertEquals(0, bC.get());
409         service.applySettings(Settings.builder().put("foo.bar", 2).put("foo.bar.baz", 15).build());
410         assertEquals(2, consumer.get());
411         assertEquals(15, consumer2.get());
412         assertEquals(2, aC.get());
413         assertEquals(15, bC.get());
414     }
415     @Test
416     public void testGet() {
417         ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
418         Setting setting = settings.get("cluster.routing.allocation.require.value");
419         assertEquals(setting,
420             FilterAllocationDecider.CLUSTER_ROUTING_REQUIRE_GROUP_SETTING.getConcreteSetting("cluster.routing.allocation.require.value"));
421         setting = settings.get("cluster.routing.allocation.total_shards_per_node");
422         assertEquals(setting, ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING);
423         assertNotNull(settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
424         assertSame(TransportSettings.TRACE_LOG_INCLUDE_SETTING, settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
425         assertNull(settings.get("transport.tracer.include.FOO"));
426     }
427     @Test
428     public void testIsDynamic(){
429         ClusterSettings settings =
430             new ClusterSettings(Settings.EMPTY,
431                 new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope),
432                     Setting.intSetting("foo.bar.baz", 1, Property.NodeScope))));
433         assertFalse(settings.isDynamicSetting("foo.bar.baz"));
434         assertTrue(settings.isDynamicSetting("foo.bar"));
435         assertNotNull(settings.get("foo.bar.baz"));
436         settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
437         assertTrue(settings.isDynamicSetting("transport.tracer.include." + randomIntBetween(1, 100)));
438         assertFalse(settings.isDynamicSetting("transport.tracer.include.BOOM"));
439         assertTrue(settings.isDynamicSetting("cluster.routing.allocation.require.value"));
440     }
441     @Test
442     public void testIsFinal() {
443         ClusterSettings settings =
444             new ClusterSettings(Settings.EMPTY,
445                 new HashSet&lt;&gt;(Arrays.asList(Setting.intSetting("foo.int", 1, Property.Final, Property.NodeScope),
446                     Setting.groupSetting("foo.group.",  Property.Final, Property.NodeScope),
447                     Setting.groupSetting("foo.list.",  Property.Final, Property.NodeScope),
448                     Setting.intSetting("foo.int.baz", 1, Property.NodeScope))));
449         assertFalse(settings.isFinalSetting("foo.int.baz"));
450         assertTrue(settings.isFinalSetting("foo.int"));
451         assertFalse(settings.isFinalSetting("foo.list"));
452         assertTrue(settings.isFinalSetting("foo.list.0.key"));
453         assertTrue(settings.isFinalSetting("foo.list.key"));
454         assertFalse(settings.isFinalSetting("foo.group"));
455         assertTrue(settings.isFinalSetting("foo.group.key"));
456     }
457     @Test
458     public void testDiff() throws IOException {
459         Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting("foo.bar.baz", 1, Property.NodeScope);
460         Setting&lt;Integer&gt; fooBar = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
461         Setting&lt;Settings&gt; someGroup = Setting.groupSetting("some.group.", Property.Dynamic, Property.NodeScope);
462         Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting("some.prefix.", "somekey", (key) -&gt; Setting.boolSetting(key, true,
463             Property.NodeScope));
464         Setting&lt;List&lt;String&gt;&gt; foorBarQuux =
465                 Setting.listSetting("foo.bar.quux", Arrays.asList("a", "b", "c"), Function.identity(), DataTypes.STRING, Property.NodeScope);
466         ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
467             someGroup, someAffix)));
468         Settings diff = settings.diff(Settings.builder().put("foo.bar", 5).build(), Settings.EMPTY);
469         assertEquals(2, diff.size());
470         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
471         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
472         diff = settings.diff(
473                 Settings.builder().put("foo.bar", 5).build(),
474                 Settings.builder().put("foo.bar.baz", 17).putList("foo.bar.quux", "d", "e", "f").build());
475         assertEquals(2, diff.size());
476         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
477         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("d", "e", "f"));
478         diff = settings.diff(
479             Settings.builder().put("some.group.foo", 5).build(),
480             Settings.builder().put("some.group.foobar", 17).put("some.group.foo", 25).build());
481         assertEquals(4, diff.size());
482         assertThat(diff.getAsInt("some.group.foobar", null), equalTo(17));
483         assertNull(diff.get("some.group.foo"));
484         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
485         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
486         assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
487         diff = settings.diff(
488             Settings.builder().put("some.prefix.foo.somekey", 5).build(),
489             Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18).build());
490         assertEquals(4, diff.size());
491         assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
492         assertNull(diff.get("some.prefix.foo.somekey"));
493         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("a", "b", "c"));
494         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
495         assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
496     }
497     @Test
498     public void testDiffWithAffixAndComplexMatcher() {
499         Setting&lt;Integer&gt; fooBarBaz = Setting.intSetting("foo.bar.baz", 1, Property.NodeScope);
500         Setting&lt;Integer&gt; fooBar = Setting.intSetting("foo.bar", 1, Property.Dynamic, Property.NodeScope);
501         Setting&lt;Settings&gt; someGroup = Setting.groupSetting("some.group.", Property.Dynamic, Property.NodeScope);
502         Setting&lt;Boolean&gt; someAffix = Setting.affixKeySetting("some.prefix.", "somekey", (key) -&gt; Setting.boolSetting(key, true,
503             Property.NodeScope));
504         Setting&lt;List&lt;String&gt;&gt; foorBarQuux = Setting.affixKeySetting("foo.", "quux",
505             (key) -&gt; Setting.listSetting(key,  Arrays.asList("a", "b", "c"), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope));
506         ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet&lt;&gt;(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
507             someGroup, someAffix)));
508         Settings diff = settings.diff(Settings.builder().put("foo.bar", 5).build(), Settings.EMPTY);
509         assertEquals(1, diff.size());
510         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
511         assertNull(diff.getAsList("foo.bar.quux", null)); 
512         diff = settings.diff(
513             Settings.builder().put("foo.bar", 5).build(),
514             Settings.builder().put("foo.bar.baz", 17).putList("foo.bar.quux", "d", "e", "f").build());
515         assertEquals(2, diff.size());
516         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
517         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("d", "e", "f"));
518         diff = settings.diff(
519             Settings.builder().put("some.group.foo", 5).build(),
520             Settings.builder().put("some.group.foobar", 17).put("some.group.foo", 25).build());
521         assertEquals(3, diff.size());
522         assertThat(diff.getAsInt("some.group.foobar", null), equalTo(17));
523         assertNull(diff.get("some.group.foo"));
524         assertNull(diff.getAsList("foo.bar.quux", null));         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
525         assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
526         diff = settings.diff(
527             Settings.builder().put("some.prefix.foo.somekey", 5).build(),
528             Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18).build());
529         assertEquals(3, diff.size());
530         assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
531         assertNull(diff.get("some.prefix.foo.somekey"));
532         assertNull(diff.getAsList("foo.bar.quux", null));         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
533         assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
534         diff = settings.diff(
535             Settings.builder().put("some.prefix.foo.somekey", 5).build(),
536             Settings.builder().put("some.prefix.foobar.somekey", 17).put("some.prefix.foo.somekey", 18)
537             .putList("foo.bar.quux", "x", "y", "z")
538             .putList("foo.baz.quux", "d", "e", "f")
539                 .build());
540         assertEquals(5, diff.size());
541         assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
542         assertNull(diff.get("some.prefix.foo.somekey"));
543         assertEquals(diff.getAsList("foo.bar.quux", null), Arrays.asList("x", "y", "z"));
544         assertEquals(diff.getAsList("foo.baz.quux", null), Arrays.asList("d", "e", "f"));
545         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
546         assertThat(diff.getAsInt("foo.bar", null), equalTo(1));
547     }
548 <a name="8"></a>    @Test
549     public void testUpdateTracer() {
550         ClusterSettings settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
551         <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>AtomicReference&lt;List&lt;String&gt;&gt; ref = new AtomicReference&lt;&gt;();
552         settings.addSettingsUpdateConsumer(TransportSettings.TRACE_LOG_INCLUDE_SETTING, ref::set);
553         settings.applySettings(Settings.builder()
554                 .putList("transport.tracer.include", "internal:index/shard/recovery/*", "internal:gateway/local*").build());
555         assertNotNull(ref.get</b></font>().size());
556         assertEquals(ref.get().size(), 2);
557         assertTrue(ref.get().contains("internal:index/shard/recovery/*"));
558         assertTrue(ref.get().contains("internal:gateway/local*"));
559     }
560     @Test
561     public void testGetSetting() {
562         IndexScopedSettings settings = new IndexScopedSettings(
563            Settings.EMPTY,
564             IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
565         IndexScopedSettings copy = settings.copy(Settings.builder().put("index.store.type", "boom").build(),
566                 newIndexMeta("foo", Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 3).build()));
567         assertEquals(3, copy.get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING).intValue());
568         assertEquals(1, copy.get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING).intValue());
569         assertEquals("boom", copy.get(IndexModule.INDEX_STORE_TYPE_SETTING));     }
570     @Test
571     public void testValidateWithSuggestion() {
572         IndexScopedSettings settings = new IndexScopedSettings(
573             Settings.EMPTY,
574             IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
575         IllegalArgumentException iae = expectThrows(IllegalArgumentException.class,
576             () -&gt; settings.validate(Settings.builder().put("index.numbe_of_replica", "1").build(), false));
577         assertEquals(iae.getMessage(), "unknown setting [index.numbe_of_replica] did you mean [index.number_of_replicas]?");
578     }
579     @Test
580     public void testValidate() {
581         IndexScopedSettings settings = new IndexScopedSettings(
582             Settings.EMPTY,
583             IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
584         String unknownMsgSuffix = " please check that any required plugins are installed, or check the breaking changes documentation for" +
585             " removed settings";
586         settings.validate(Settings.builder().put("index.store.type", "boom").build(), false);
587         IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -&gt;
588             settings.validate(Settings.builder().put("index.store.type", "boom").put("i.am.not.a.setting", true).build(), false));
589         assertEquals("unknown setting [i.am.not.a.setting]" + unknownMsgSuffix, e.getMessage());
590         e = expectThrows(IllegalArgumentException.class, () -&gt;
591             settings.validate(Settings.builder().put("index.store.type", "boom").put("index.number_of_replicas", true).build(), false));
592         assertEquals("Failed to parse value [true] for setting [index.number_of_replicas]", e.getMessage());
593         e = expectThrows(IllegalArgumentException.class, () -&gt;
594             settings.validate("index.number_of_replicas", Settings.builder().put("index.number_of_replicas", "true").build(), false));
595         assertEquals("Failed to parse value [true] for setting [index.number_of_replicas]", e.getMessage());
596     }
597     public static IndexMetadata newIndexMeta(String name, Settings indexSettings) {
598         Settings build = Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)
599             .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1)
600             .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)
601             .put(indexSettings)
602             .build();
603         IndexMetadata metadata = IndexMetadata.builder(name).settings(build).build();
604         return metadata;
605     }
606     @Test
607     public void testKeyPattern() {
608         assertTrue(AbstractScopedSettings.isValidKey("a.b.c-b.d"));
609         assertTrue(AbstractScopedSettings.isValidKey("a.b.c.d"));
610         assertTrue(AbstractScopedSettings.isValidKey("a.b_012.c_b.d"));
611         assertTrue(AbstractScopedSettings.isValidKey("a"));
612         assertFalse(AbstractScopedSettings.isValidKey("a b"));
613         assertFalse(AbstractScopedSettings.isValidKey(""));
614         assertFalse(AbstractScopedSettings.isValidKey("\""));
615         try {
616             new IndexScopedSettings(
617                 Settings.EMPTY, Collections.singleton(Setting.groupSetting("foo.bar.", Property.IndexScope)));
618             fail();
619         } catch (IllegalArgumentException e) {
620             assertEquals("illegal settings key: [foo.bar.] must start with [index.]", e.getMessage());
621         }
622         try {
623             new IndexScopedSettings(
624                 Settings.EMPTY, Collections.singleton(Setting.simpleString("foo.bar", Property.IndexScope)));
625             fail();
626         } catch (IllegalArgumentException e) {
627             assertEquals("illegal settings key: [foo.bar] must start with [index.]", e.getMessage());
628         }
629         try {
630             new IndexScopedSettings(
631                 Settings.EMPTY, Collections.singleton(Setting.groupSetting("index. foo.", Property.IndexScope)));
632             fail();
633         } catch (IllegalArgumentException e) {
634             assertEquals("illegal settings key: [index. foo.]", e.getMessage());
635         }
636         new IndexScopedSettings(
637             Settings.EMPTY, Collections.singleton(Setting.groupSetting("index.", Property.IndexScope)));
638         try {
639             new IndexScopedSettings(
640                 Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.", true, Property.IndexScope)));
641             fail();
642         } catch (IllegalArgumentException e) {
643             assertEquals("illegal settings key: [index.]", e.getMessage());
644         }
645         new IndexScopedSettings(
646             Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.boo", true, Property.IndexScope)));
647         new ClusterSettings(
648             Settings.EMPTY, Collections.singleton(Setting.boolSetting("index.boo", true, Property.NodeScope)));
649     }
650     @Test
651     public void testAffixKeyPattern() {
652         assertTrue(AbstractScopedSettings.isValidAffixKey("prefix.*.suffix"));
653         assertTrue(AbstractScopedSettings.isValidAffixKey("prefix.*.split.suffix"));
654         assertTrue(AbstractScopedSettings.isValidAffixKey("split.prefix.*.split.suffix"));
655         assertFalse(AbstractScopedSettings.isValidAffixKey("prefix.*.suffix."));
656         assertFalse(AbstractScopedSettings.isValidAffixKey("prefix.*"));
657         assertFalse(AbstractScopedSettings.isValidAffixKey("*.suffix"));
658         assertFalse(AbstractScopedSettings.isValidAffixKey("*"));
659         assertFalse(AbstractScopedSettings.isValidAffixKey(""));
660     }
661     @Test
662     public void testLoggingUpdates() {
663         final Level level = LogManager.getRootLogger().getLevel();
664         final Level testLevel = LogManager.getLogger("test").getLevel();
665         Level property = randomFrom(Level.values());
666         Settings.Builder builder = Settings.builder().put("logger.level", property);
667         try {
668             ClusterSettings settings = new ClusterSettings(builder.build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
669             IllegalArgumentException ex =
670                 expectThrows(
671                     IllegalArgumentException.class,
672                     () -&gt; settings.validate(Settings.builder().put("logger._root", "boom").build(), false));
673             assertEquals("Unknown level constant [BOOM].", ex.getMessage());
674             assertEquals(level, LogManager.getRootLogger().getLevel());
675             settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
676             assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
677             settings.applySettings(Settings.builder().build());
678             assertEquals(property, LogManager.getRootLogger().getLevel());
679             settings.applySettings(Settings.builder().put("logger.test", "TRACE").build());
680             assertEquals(Level.TRACE, LogManager.getLogger("test").getLevel());
681             settings.applySettings(Settings.builder().build());
682             assertEquals(property, LogManager.getLogger("test").getLevel());
683         } finally {
684             Loggers.setLevel(LogManager.getRootLogger(), level);
685             Loggers.setLevel(LogManager.getLogger("test"), testLevel);
686         }
687     }
688 <a name="9"></a>    @Test
689     public void testFallbackToLoggerLevel() {
690         final Level level = LogManager.getRootLogger().getLevel();
691         try <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
692             ClusterSettings settings =
693                 new ClusterSettings(Settings.builder().put("logger.level", "ERROR").build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
694             assertEquals(level, LogManager.getRootLogger</b></font>().getLevel());
695             settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
696             assertEquals(Level.TRACE, LogManager.getRootLogger().getLevel());
697             settings.applySettings(Settings.builder().build());             assertEquals(Level.ERROR, LogManager.getRootLogger().getLevel());
698         } finally {
699             Loggers.setLevel(LogManager.getRootLogger(), level);
700         }
701     }
702     @Test
703     public void testOverlappingComplexMatchSettings() {
704         Set&lt;Setting&lt;?&gt;&gt; settings = new LinkedHashSet&lt;&gt;(2);
705         final boolean groupFirst = randomBoolean();
706         final Setting&lt;?&gt; groupSetting = Setting.groupSetting("foo.", Property.NodeScope);
707         final Setting&lt;?&gt; listSetting =
708             Setting.listSetting("foo.bar", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
709         settings.add(groupFirst ? groupSetting : listSetting);
710         settings.add(groupFirst ? listSetting : groupSetting);
711         try {
712             new ClusterSettings(Settings.EMPTY, settings);
713             fail("an exception should have been thrown because settings overlap");
714         } catch (IllegalArgumentException e) {
715             if (groupFirst) {
716                 assertEquals("complex setting key: [foo.bar] overlaps existing setting key: [foo.]", e.getMessage());
717             } else {
718                 assertEquals("complex setting key: [foo.] overlaps existing setting key: [foo.bar]", e.getMessage());
719             }
720         }
721     }
722     @Test
723     public void testUpdateNumberOfShardsFail() {
724         IndexScopedSettings settings = new IndexScopedSettings(Settings.EMPTY,
725             IndexScopedSettings.BUILT_IN_INDEX_SETTINGS);
726         IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
727             () -&gt; settings.updateSettings(Settings.builder().put("index.number_of_shards", 8).build(),
728                 Settings.builder(), Settings.builder(), "index"));
729         assertThat(ex.getMessage(),
730             containsString("final index setting [index.number_of_shards], not updateable"));
731     }
732     @Test
733     public void testFinalSettingUpdateFail() {
734         Setting&lt;Integer&gt; finalSetting = Setting.intSetting("some.final.setting", 1, Property.Final, Property.NodeScope);
735         Setting&lt;Settings&gt; finalGroupSetting = Setting.groupSetting("some.final.group.", Property.Final, Property.NodeScope);
736         Settings currentSettings = Settings.builder()
737             .put("some.final.setting", 9)
738             .put("some.final.group.foo", 7)
739             .build();
740         ClusterSettings service = new ClusterSettings(currentSettings
741             , new HashSet&lt;&gt;(Arrays.asList(finalSetting, finalGroupSetting)));
742         IllegalArgumentException exc = expectThrows(IllegalArgumentException.class, () -&gt;
743             service.updateDynamicSettings(Settings.builder().put("some.final.setting", 8).build(),
744                 Settings.builder().put(currentSettings), Settings.builder(), "node"));
745         assertThat(exc.getMessage(), containsString("final node setting [some.final.setting]"));
746         exc = expectThrows(IllegalArgumentException.class, () -&gt;
747             service.updateDynamicSettings(Settings.builder().putNull("some.final.setting").build(),
748                 Settings.builder().put(currentSettings), Settings.builder(), "node"));
749         assertThat(exc.getMessage(), containsString("final node setting [some.final.setting]"));
750         exc = expectThrows(IllegalArgumentException.class, () -&gt;
751             service.updateSettings(Settings.builder().put("some.final.group.new", 8).build(),
752                 Settings.builder().put(currentSettings), Settings.builder(), "node"));
753         assertThat(exc.getMessage(), containsString("final node setting [some.final.group.new]"));
754         exc = expectThrows(IllegalArgumentException.class, () -&gt;
755             service.updateSettings(Settings.builder().put("some.final.group.foo", 5).build(),
756                 Settings.builder().put(currentSettings), Settings.builder(), "node"));
757         assertThat(exc.getMessage(), containsString("final node setting [some.final.group.foo]"));
758     }
759     @Test
760     public void testInternalIndexSettingsFailsValidation() {
761         final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString("index.internal", Property.InternalIndex, Property.IndexScope);
762         final IndexScopedSettings indexScopedSettings =
763                 new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
764         final IllegalArgumentException e = expectThrows(
765                 IllegalArgumentException.class,
766                 () -&gt; {
767                     final Settings settings = Settings.builder().put("index.internal", "internal").build();
768                     indexScopedSettings.validate(settings, false,                 });
769         final String message = "can not update internal setting [index.internal]; this setting is managed via a dedicated API";
770         assertThat(e, hasToString(containsString(message)));
771     }
772     @Test
773     public void testPrivateIndexSettingsFailsValidation() {
774         final Setting&lt;String&gt; indexInternalSetting = Setting.simpleString("index.private", Property.PrivateIndex, Property.IndexScope);
775         final IndexScopedSettings indexScopedSettings =
776                 new IndexScopedSettings(Settings.EMPTY, Collections.singleton(indexInternalSetting));
777         final IllegalArgumentException e = expectThrows(
778                 IllegalArgumentException.class,
779                 () -&gt; {
780                     final Settings settings = Settings.builder().put("index.private", "private").build();
781                     indexScopedSettings.validate(settings, false,                 });
782         final String message = "can not update private setting [index.private]; this setting is managed by CrateDB";
783         assertThat(e, hasToString(containsString(message)));
784     }
785     @Test
786     public void testInternalIndexSettingsSkipValidation() {
787         final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString("index.internal", Property.InternalIndex, Property.IndexScope);
788         final IndexScopedSettings indexScopedSettings =
789                 new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
790         final Settings settings = Settings.builder().put("index.internal", "internal").build();
791         indexScopedSettings.validate(settings, false,     }
792     @Test
793     public void testPrivateIndexSettingsSkipValidation() {
794         final Setting&lt;String&gt; internalIndexSetting = Setting.simpleString("index.private", Property.PrivateIndex, Property.IndexScope);
795         final IndexScopedSettings indexScopedSettings =
796                 new IndexScopedSettings(Settings.EMPTY, Collections.singleton(internalIndexSetting));
797         final Settings settings = Settings.builder().put("index.private", "private").build();
798         indexScopedSettings.validate(settings, false,     }
799     @Test
800     public void testUpgradeSetting() {
801         final Setting&lt;String&gt; oldSetting = Setting.simpleString("foo.old", Property.NodeScope);
802         final Setting&lt;String&gt; newSetting = Setting.simpleString("foo.new", Property.NodeScope);
803         final Setting&lt;String&gt; remainingSetting = Setting.simpleString("foo.remaining", Property.NodeScope);
804         final AbstractScopedSettings service =
805                 new ClusterSettings(
806                         Settings.EMPTY,
807                         List.of(),
808                         new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
809                         Collections.singleton(new SettingUpgrader&lt;String&gt;() {
810                             @Override
811                             public Setting&lt;String&gt; getSetting() {
812                                 return oldSetting;
813                             }
814                             @Override
815                             public String getKey(final String key) {
816                                 return "foo.new";
817                             }
818                             @Override
819                             public String getValue(final String value) {
820                                 return "new." + value;
821                             }
822 <a name="2"></a>                        }));
823         final Settings settings =
824                 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder()
825                         .put("foo.old", randomAlphaOfLength(8))
826                         .put("foo.remaining", randomAlphaOfLength(8))
827                         .build();
828         final Settings upgradedSettings = service.upgradeSettings(settings);
829         assertFalse(oldSetting.exists(upgradedSettings));
830         assertTrue(newSetting.exists(upgradedSettings));
831         assertThat(newSetting.get(upgradedSettings), equalTo("new." + oldSetting.get(settings)));
832         assertTrue(remainingSetting.exists(upgradedSettings));
833         assertThat(remainingSetting.get(upgradedSettings), equalTo(remainingSetting.get</b></font>(settings)));
834     }
835     @Test
836     public void testUpgradeSettingsNoChangesPreservesInstance() {
837         final Setting&lt;String&gt; oldSetting = Setting.simpleString("foo.old", Property.NodeScope);
838         final Setting&lt;String&gt; newSetting = Setting.simpleString("foo.new", Property.NodeScope);
839         final Setting&lt;String&gt; remainingSetting = Setting.simpleString("foo.remaining", Property.NodeScope);
840         final AbstractScopedSettings service =
841                 new ClusterSettings(
842                         Settings.EMPTY,
843                         List.of(),
844                         new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
845                         Collections.singleton(new SettingUpgrader&lt;String&gt;() {
846                             @Override
847                             public Setting&lt;String&gt; getSetting() {
848                                 return oldSetting;
849                             }
850                             @Override
851                             public String getKey(final String key) {
852                                 return "foo.new";
853                             }
854                         }));
855         final Settings settings = Settings.builder().put("foo.remaining", randomAlphaOfLength(8)).build();
856         final Settings upgradedSettings = service.upgradeSettings(settings);
857         assertThat(upgradedSettings, sameInstance(settings));
858     }
859     @Test
860     public void testUpgradeComplexSetting() {
861         final Setting.AffixSetting&lt;String&gt; oldSetting =
862                 Setting.affixKeySetting("foo.old.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
863         final Setting.AffixSetting&lt;String&gt; newSetting =
864                 Setting.affixKeySetting("foo.new.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
865         final Setting.AffixSetting&lt;String&gt; remainingSetting =
866                 Setting.affixKeySetting("foo.remaining.", "suffix", key -&gt; Setting.simpleString(key, Property.NodeScope));
867         final AbstractScopedSettings service =
868                 new ClusterSettings(
869                         Settings.EMPTY,
870                         List.of(),
871                         new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting, remainingSetting)),
872                         Collections.singleton(new SettingUpgrader&lt;String&gt;() {
873                             @Override
874                             public Setting&lt;String&gt; getSetting() {
875                                 return oldSetting;
876                             }
877                             @Override
878                             public String getKey(final String key) {
879                                 return key.replaceFirst("^foo\\.old", "foo\\.new");
880                             }
881                             @Override
882                             public String getValue(final String value) {
883                                 return "new." + value;
884                             }
885                         }));
886         final int count = randomIntBetween(1, 8);
887         final List&lt;String&gt; concretes = new ArrayList&lt;&gt;(count);
888         final Settings.Builder builder = Settings.builder();
889         for (int i = 0; i &lt; count; i++) {
890             final String concrete = randomAlphaOfLength(8);
891             concretes.add(concrete);
892             builder.put("foo.old." + concrete + ".suffix", randomAlphaOfLength(8));
893             builder.put("foo.remaining." + concrete + ".suffix", randomAlphaOfLength(8));
894         }
895         final Settings settings = builder.build();
896         final Settings upgradedSettings = service.upgradeSettings(settings);
897         for (final String concrete : concretes) {
898             assertFalse(oldSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
899             assertTrue(newSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
900             assertThat(
901                     newSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
902                     equalTo("new." + oldSetting.getConcreteSettingForNamespace(concrete).get(settings)));
903             assertTrue(remainingSetting.getConcreteSettingForNamespace(concrete).exists(upgradedSettings));
904             assertThat(
905                     remainingSetting.getConcreteSettingForNamespace(concrete).get(upgradedSettings),
906                     equalTo(remainingSetting.getConcreteSettingForNamespace(concrete).get(settings)));
907         }
908     }
909     @Test
910     public void testUpgradeListSetting() {
911         final Setting&lt;List&lt;String&gt;&gt; oldSetting =
912                 Setting.listSetting("foo.old", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
913         final Setting&lt;List&lt;String&gt;&gt; newSetting =
914                 Setting.listSetting("foo.new", Collections.emptyList(), Function.identity(), DataTypes.STRING_ARRAY, Property.NodeScope);
915         final AbstractScopedSettings service =
916                 new ClusterSettings(
917                         Settings.EMPTY,
918                         List.of(),
919                         new HashSet&lt;&gt;(Arrays.asList(oldSetting, newSetting)),
920                         Collections.singleton(new SettingUpgrader&lt;List&lt;String&gt;&gt;() {
921                             @Override
922                             public Setting&lt;List&lt;String&gt;&gt; getSetting() {
923                                 return oldSetting;
924                             }
925                             @Override
926                             public String getKey(final String key) {
927                                 return "foo.new";
928                             }
929                             @Override
930                             public List&lt;String&gt; getListValue(final List&lt;String&gt; value) {
931                                 return value.stream().map(s -&gt; "new." + s).collect(Collectors.toList());
932                             }
933                         }));
934         final int length = randomIntBetween(0, 16);
935         final List&lt;String&gt; values = length == 0 ? Collections.emptyList() : new ArrayList&lt;&gt;(length);
936         for (int i = 0; i &lt; length; i++) {
937 <a name="3"></a>            values.add(randomAlphaOfLength(8));
938         }
939         final Settings settings = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder().putList("foo.old", values).build();
940         final Settings upgradedSettings = service.upgradeSettings(settings);
941         assertFalse(oldSetting.exists(upgradedSettings));
942         assertTrue(newSetting.exists(upgradedSettings));
943         assertThat(
944                 newSetting.get(upgradedSettings),
945                 equalTo(oldSetting.get(settings).stream().map(s -&gt; "new." + s).collect</b></font>(Collectors.toList())));
946     }
947     @Test
948     public void test_update_setting_with_dependency() throws Exception {
949         Setting&lt;String&gt; low = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING;
950         Setting&lt;String&gt; high = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING;
951         Setting&lt;String&gt; flood = DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING;
952         ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, Set.of(low, high, flood));
953         Settings.Builder target = Settings.builder();
954         clusterSettings.updateDynamicSettings(
955             Settings.builder().put(high.getKey(), "95%").build(),
956             target,
957             Settings.builder(),
958             "update high to 95%"
959         );
960         clusterSettings.applySettings(target.build());
961         clusterSettings.updateDynamicSettings(
962             Settings.builder().put(low.getKey(), "91%").build(),
963             Settings.builder(),
964             Settings.builder(),
965             "update low to 91%"
966         );
967     }
968 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
