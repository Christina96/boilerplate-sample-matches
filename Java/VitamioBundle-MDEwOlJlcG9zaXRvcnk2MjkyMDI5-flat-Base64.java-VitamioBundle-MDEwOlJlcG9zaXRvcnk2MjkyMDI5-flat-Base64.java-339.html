
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</h3>
            <pre><code>1  package io.vov.vitamio.utils;
2  import java.io.UnsupportedEncodingException;
3  public class Base64 {
4      public static final int DEFAULT = 0;
5      public static final int NO_PADDING = 1;
6      public static final int NO_WRAP = 2;
7      public static final int CRLF = 4;
8      public static final int URL_SAFE = 8;
9      public static final int NO_CLOSE = 16;
10       static abstract class Coder {
11          public byte[] output;
12          public int op;
13          public abstract boolean process(byte[] input, int offset, int len, boolean finish);
14          public abstract int maxOutputSize(int len);
15      }
16      public static byte[] decode(String str, int flags) {
17          return decode(str.getBytes(), flags);
18      }
19      public static byte[] decode(byte[] input, int flags) {
20          return decode(input, 0, input.length, flags);
21      }
22      public static byte[] decode(byte[] input, int offset, int len, int flags) {
23          Decoder decoder = new Decoder(flags, new byte[len*3/4]);
24          if (!decoder.process(input, offset, len, true)) {
25              throw new IllegalArgumentException(&quot;bad base-64&quot;);
26          }
27          if (decoder.op == decoder.output.length) {
28              return decoder.output;
29          }
30          byte[] temp = new byte[decoder.op];
31          System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
32          return temp;
33      }
34       static class Decoder extends Coder {
35          private static final int DECODE[] = {
36              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
37              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
38              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
39              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
40              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
41              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
42              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
43              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
44              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
45              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
46              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
47              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
48              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
49              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
50              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
51              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
52          };
53          private static final int DECODE_WEBSAFE[] = {
54              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
55              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
56              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
57              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
58              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
59              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
60              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
61              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
62              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
63              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
64              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
65              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
66              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
67              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
68              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
69              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
70          };
71          private static final int SKIP = -1;
72          private static final int EQUALS = -2;
73          private int state;   
74          private int value;
75          final private int[] alphabet;
76          public Decoder(int flags, byte[] output) {
77              this.output = output;
78              alphabet = ((flags &amp; URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
79              state = 0;
80              value = 0;
81          }
82          public int maxOutputSize(int len) {
83              return len * 3/4 + 10;
84          }
85          public boolean process(byte[] input, int offset, int len, boolean finish) {
86              if (this.state == 6) return false;
87              int p = offset;
88              len += offset;
89              int state = this.state;
90              int value = this.value;
91              int op = 0;
92              final byte[] output = this.output;
93              final int[] alphabet = this.alphabet;
94              while (p &lt; len) {
95                  if (state == 0) {
96                      while (p+4 &lt;= len &amp;&amp;
97                             (value = ((alphabet[input[p] &amp; 0xff] &lt;&lt; 18) |
98                                       (alphabet[input[p+1] &amp; 0xff] &lt;&lt; 12) |
99                                       (alphabet[input[p+2] &amp; 0xff] &lt;&lt; 6) |
100                                       (alphabet[input[p+3] &amp; 0xff]))) &gt;= 0) {
<span onclick='openModal()' class='match'>101                          output[op+2] = (byte) value;
102                          output[op+1] = (byte) (value &gt;&gt; 8);
103                          output[op] = (byte) (value &gt;&gt; 16);
104                          op += 3;
105                          p += 4;
</span>106                      }
107                      if (p &gt;= len) break;
108                  }
109                  int d = alphabet[input[p++] &amp; 0xff];
110                  switch (state) {
111                  case 0:
112                      if (d &gt;= 0) {
113                          value = d;
114                          ++state;
115                      } else if (d != SKIP) {
116                          this.state = 6;
117                          return false;
118                      }
119                      break;
120                  case 1:
121                      if (d &gt;= 0) {
122                          value = (value &lt;&lt; 6) | d;
123                          ++state;
124                      } else if (d != SKIP) {
125                          this.state = 6;
126                          return false;
127                      }
128                      break;
129                  case 2:
130                      if (d &gt;= 0) {
131                          value = (value &lt;&lt; 6) | d;
132                          ++state;
133                      } else if (d == EQUALS) {
134                          output[op++] = (byte) (value &gt;&gt; 4);
135                          state = 4;
136                      } else if (d != SKIP) {
137                          this.state = 6;
138                          return false;
139                      }
140                      break;
141                  case 3:
142                      if (d &gt;= 0) {
143                          value = (value &lt;&lt; 6) | d;
144                          output[op+2] = (byte) value;
145                          output[op+1] = (byte) (value &gt;&gt; 8);
146                          output[op] = (byte) (value &gt;&gt; 16);
147                          op += 3;
148                          state = 0;
149                      } else if (d == EQUALS) {
150                          output[op+1] = (byte) (value &gt;&gt; 2);
151                          output[op] = (byte) (value &gt;&gt; 10);
152                          op += 2;
153                          state = 5;
154                      } else if (d != SKIP) {
155                          this.state = 6;
156                          return false;
157                      }
158                      break;
159                  case 4:
160                      if (d == EQUALS) {
161                          ++state;
162                      } else if (d != SKIP) {
163                          this.state = 6;
164                          return false;
165                      }
166                      break;
167                  case 5:
168                      if (d != SKIP) {
169                          this.state = 6;
170                          return false;
171                      }
172                      break;
173                  }
174              }
175              if (!finish) {
176                  this.state = state;
177                  this.value = value;
178                  this.op = op;
179                  return true;
180              }
181              switch (state) {
182              case 0:
183                  break;
184              case 1:
185                  this.state = 6;
186                  return false;
187              case 2:
188                  output[op++] = (byte) (value &gt;&gt; 4);
189                  break;
190              case 3:
191                  output[op++] = (byte) (value &gt;&gt; 10);
192                  output[op++] = (byte) (value &gt;&gt; 2);
193                  break;
194              case 4:
195                  this.state = 6;
196                  return false;
197              case 5:
198                  break;
199              }
200              this.state = state;
201              this.op = op;
202              return true;
203          }
204      }
205      public static String encodeToString(byte[] input, int flags) {
206          try {
207              return new String(encode(input, flags), &quot;US-ASCII&quot;);
208          } catch (UnsupportedEncodingException e) {
209              throw new AssertionError(e);
210          }
211      }
212      public static String encodeToString(byte[] input, int offset, int len, int flags) {
213          try {
214              return new String(encode(input, offset, len, flags), &quot;US-ASCII&quot;);
215          } catch (UnsupportedEncodingException e) {
216              throw new AssertionError(e);
217          }
218      }
219      public static byte[] encode(byte[] input, int flags) {
220          return encode(input, 0, input.length, flags);
221      }
222      public static byte[] encode(byte[] input, int offset, int len, int flags) {
223          Encoder encoder = new Encoder(flags, null);
224          int output_len = len / 3 * 4;
225          if (encoder.do_padding) {
226              if (len % 3 &gt; 0) {
227                  output_len += 4;
228              }
229          } else {
230              switch (len % 3) {
231                  case 0: break;
232                  case 1: output_len += 2; break;
233                  case 2: output_len += 3; break;
234              }
235          }
236          if (encoder.do_newline &amp;&amp; len &gt; 0) {
237              output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
238                  (encoder.do_cr ? 2 : 1);
239          }
240          encoder.output = new byte[output_len];
241          encoder.process(input, offset, len, true);
242          assert encoder.op == output_len;
243          return encoder.output;
244      }
245       static class Encoder extends Coder {
246          public static final int LINE_GROUPS = 19;
247          private static final byte ENCODE[] = {
248              &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,
249              &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,
250              &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
251              &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;,
252          };
253          private static final byte ENCODE_WEBSAFE[] = {
254              &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,
255              &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,
256              &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
257              &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;-&#x27;, &#x27;_&#x27;,
258          };
259          final private byte[] tail;
260           int tailLen;
261          private int count;
262          final public boolean do_padding;
263          final public boolean do_newline;
264          final public boolean do_cr;
265          final private byte[] alphabet;
266          public Encoder(int flags, byte[] output) {
267              this.output = output;
268              do_padding = (flags &amp; NO_PADDING) == 0;
269              do_newline = (flags &amp; NO_WRAP) == 0;
270              do_cr = (flags &amp; CRLF) != 0;
271              alphabet = ((flags &amp; URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
272              tail = new byte[2];
273              tailLen = 0;
274              count = do_newline ? LINE_GROUPS : -1;
275          }
276          public int maxOutputSize(int len) {
277              return len * 8/5 + 10;
278          }
279          public boolean process(byte[] input, int offset, int len, boolean finish) {
280              final byte[] alphabet = this.alphabet;
281              final byte[] output = this.output;
282              int op = 0;
283              int count = this.count;
284              int p = offset;
285              len += offset;
286              int v = -1;
287              switch (tailLen) {
288                  case 0:
289                      break;
290                  case 1:
291                      if (p+2 &lt;= len) {
292                          v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |
293                              ((input[p++] &amp; 0xff) &lt;&lt; 8) |
294                              (input[p++] &amp; 0xff);
295                          tailLen = 0;
296                      };
297                      break;
298                  case 2:
299                      if (p+1 &lt;= len) {
300                          v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |
301                              ((tail[1] &amp; 0xff) &lt;&lt; 8) |
302                              (input[p++] &amp; 0xff);
303                          tailLen = 0;
304                      }
305                      break;
306              }
307              if (v != -1) {
308                  output[op++] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];
309                  output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
310                  output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
311                  output[op++] = alphabet[v &amp; 0x3f];
312                  if (--count == 0) {
313                      if (do_cr) output[op++] = &#x27;\r&#x27;;
314                      output[op++] = &#x27;\n&#x27;;
315                      count = LINE_GROUPS;
316                  }
317              }
318              while (p+3 &lt;= len) {
319                  v = ((input[p] &amp; 0xff) &lt;&lt; 16) |
320                      ((input[p+1] &amp; 0xff) &lt;&lt; 8) |
321                      (input[p+2] &amp; 0xff);
322                  output[op] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];
323                  output[op+1] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
324                  output[op+2] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
325                  output[op+3] = alphabet[v &amp; 0x3f];
326                  p += 3;
327                  op += 4;
328                  if (--count == 0) {
329                      if (do_cr) output[op++] = &#x27;\r&#x27;;
330                      output[op++] = &#x27;\n&#x27;;
331                      count = LINE_GROUPS;
332                  }
333              }
334              if (finish) {
335                  if (p-tailLen == len-1) {
336                      int t = 0;
337                      v = ((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 4;
338                      tailLen -= t;
339                      output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
340                      output[op++] = alphabet[v &amp; 0x3f];
341                      if (do_padding) {
342                          output[op++] = &#x27;=&#x27;;
343                          output[op++] = &#x27;=&#x27;;
344                      }
345                      if (do_newline) {
346                          if (do_cr) output[op++] = &#x27;\r&#x27;;
347                          output[op++] = &#x27;\n&#x27;;
348                      }
349                  } else if (p-tailLen == len-2) {
350                      int t = 0;
351                      v = (((tailLen &gt; 1 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 10) |
352                          (((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 2);
353                      tailLen -= t;
354                      output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
355                      output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
356                      output[op++] = alphabet[v &amp; 0x3f];
357                      if (do_padding) {
358                          output[op++] = &#x27;=&#x27;;
359                      }
360                      if (do_newline) {
361                          if (do_cr) output[op++] = &#x27;\r&#x27;;
362                          output[op++] = &#x27;\n&#x27;;
363                      }
364                  } else if (do_newline &amp;&amp; op &gt; 0 &amp;&amp; count != LINE_GROUPS) {
365                      if (do_cr) output[op++] = &#x27;\r&#x27;;
366                      output[op++] = &#x27;\n&#x27;;
367                  }
368                  assert tailLen == 0;
369                  assert p == len;
370              } else {
371                  if (p == len-1) {
372                      tail[tailLen++] = input[p];
373                  } else if (p == len-2) {
374                      tail[tailLen++] = input[p];
375                      tail[tailLen++] = input[p+1];
376                  }
377              }
378              this.op = op;
379              this.count = count;
380              return true;
381          }
382      }
383      private Base64() { }   
384  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</h3>
            <pre><code>1  package io.vov.vitamio.utils;
2  import java.io.UnsupportedEncodingException;
3  public class Base64 {
4      public static final int DEFAULT = 0;
5      public static final int NO_PADDING = 1;
6      public static final int NO_WRAP = 2;
7      public static final int CRLF = 4;
8      public static final int URL_SAFE = 8;
9      public static final int NO_CLOSE = 16;
10       static abstract class Coder {
11          public byte[] output;
12          public int op;
13          public abstract boolean process(byte[] input, int offset, int len, boolean finish);
14          public abstract int maxOutputSize(int len);
15      }
16      public static byte[] decode(String str, int flags) {
17          return decode(str.getBytes(), flags);
18      }
19      public static byte[] decode(byte[] input, int flags) {
20          return decode(input, 0, input.length, flags);
21      }
22      public static byte[] decode(byte[] input, int offset, int len, int flags) {
23          Decoder decoder = new Decoder(flags, new byte[len*3/4]);
24          if (!decoder.process(input, offset, len, true)) {
25              throw new IllegalArgumentException(&quot;bad base-64&quot;);
26          }
27          if (decoder.op == decoder.output.length) {
28              return decoder.output;
29          }
30          byte[] temp = new byte[decoder.op];
31          System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
32          return temp;
33      }
34       static class Decoder extends Coder {
35          private static final int DECODE[] = {
36              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
37              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
38              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
39              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
40              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
41              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
42              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
43              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
44              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
45              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
46              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
47              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
48              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
49              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
50              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
51              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
52          };
53          private static final int DECODE_WEBSAFE[] = {
54              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
55              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
56              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
57              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
58              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
59              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
60              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
61              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
62              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
63              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
64              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
65              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
66              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
67              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
68              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
69              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
70          };
71          private static final int SKIP = -1;
72          private static final int EQUALS = -2;
73          private int state;   
74          private int value;
75          final private int[] alphabet;
76          public Decoder(int flags, byte[] output) {
77              this.output = output;
78              alphabet = ((flags &amp; URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
79              state = 0;
80              value = 0;
81          }
82          public int maxOutputSize(int len) {
83              return len * 3/4 + 10;
84          }
85          public boolean process(byte[] input, int offset, int len, boolean finish) {
86              if (this.state == 6) return false;
87              int p = offset;
88              len += offset;
89              int state = this.state;
90              int value = this.value;
91              int op = 0;
92              final byte[] output = this.output;
93              final int[] alphabet = this.alphabet;
94              while (p &lt; len) {
95                  if (state == 0) {
96                      while (p+4 &lt;= len &amp;&amp;
97                             (value = ((alphabet[input[p] &amp; 0xff] &lt;&lt; 18) |
98                                       (alphabet[input[p+1] &amp; 0xff] &lt;&lt; 12) |
99                                       (alphabet[input[p+2] &amp; 0xff] &lt;&lt; 6) |
100                                       (alphabet[input[p+3] &amp; 0xff]))) &gt;= 0) {
101                          output[op+2] = (byte) value;
102                          output[op+1] = (byte) (value &gt;&gt; 8);
103                          output[op] = (byte) (value &gt;&gt; 16);
104                          op += 3;
105                          p += 4;
106                      }
107                      if (p &gt;= len) break;
108                  }
109                  int d = alphabet[input[p++] &amp; 0xff];
110                  switch (state) {
111                  case 0:
112                      if (d &gt;= 0) {
113                          value = d;
114                          ++state;
115                      } else if (d != SKIP) {
116                          this.state = 6;
117                          return false;
118                      }
119                      break;
120                  case 1:
121                      if (d &gt;= 0) {
122                          value = (value &lt;&lt; 6) | d;
123                          ++state;
124                      } else if (d != SKIP) {
125                          this.state = 6;
126                          return false;
127                      }
128                      break;
129                  case 2:
130                      if (d &gt;= 0) {
131                          value = (value &lt;&lt; 6) | d;
132                          ++state;
133                      } else if (d == EQUALS) {
134                          output[op++] = (byte) (value &gt;&gt; 4);
135                          state = 4;
136                      } else if (d != SKIP) {
137                          this.state = 6;
138                          return false;
139                      }
140                      break;
141                  case 3:
142                      if (d &gt;= 0) {
143                          value = (value &lt;&lt; 6) | d;
<span onclick='openModal()' class='match'>144                          output[op+2] = (byte) value;
145                          output[op+1] = (byte) (value &gt;&gt; 8);
146                          output[op] = (byte) (value &gt;&gt; 16);
147                          op += 3;
148                          state = 0;
</span>149                      } else if (d == EQUALS) {
150                          output[op+1] = (byte) (value &gt;&gt; 2);
151                          output[op] = (byte) (value &gt;&gt; 10);
152                          op += 2;
153                          state = 5;
154                      } else if (d != SKIP) {
155                          this.state = 6;
156                          return false;
157                      }
158                      break;
159                  case 4:
160                      if (d == EQUALS) {
161                          ++state;
162                      } else if (d != SKIP) {
163                          this.state = 6;
164                          return false;
165                      }
166                      break;
167                  case 5:
168                      if (d != SKIP) {
169                          this.state = 6;
170                          return false;
171                      }
172                      break;
173                  }
174              }
175              if (!finish) {
176                  this.state = state;
177                  this.value = value;
178                  this.op = op;
179                  return true;
180              }
181              switch (state) {
182              case 0:
183                  break;
184              case 1:
185                  this.state = 6;
186                  return false;
187              case 2:
188                  output[op++] = (byte) (value &gt;&gt; 4);
189                  break;
190              case 3:
191                  output[op++] = (byte) (value &gt;&gt; 10);
192                  output[op++] = (byte) (value &gt;&gt; 2);
193                  break;
194              case 4:
195                  this.state = 6;
196                  return false;
197              case 5:
198                  break;
199              }
200              this.state = state;
201              this.op = op;
202              return true;
203          }
204      }
205      public static String encodeToString(byte[] input, int flags) {
206          try {
207              return new String(encode(input, flags), &quot;US-ASCII&quot;);
208          } catch (UnsupportedEncodingException e) {
209              throw new AssertionError(e);
210          }
211      }
212      public static String encodeToString(byte[] input, int offset, int len, int flags) {
213          try {
214              return new String(encode(input, offset, len, flags), &quot;US-ASCII&quot;);
215          } catch (UnsupportedEncodingException e) {
216              throw new AssertionError(e);
217          }
218      }
219      public static byte[] encode(byte[] input, int flags) {
220          return encode(input, 0, input.length, flags);
221      }
222      public static byte[] encode(byte[] input, int offset, int len, int flags) {
223          Encoder encoder = new Encoder(flags, null);
224          int output_len = len / 3 * 4;
225          if (encoder.do_padding) {
226              if (len % 3 &gt; 0) {
227                  output_len += 4;
228              }
229          } else {
230              switch (len % 3) {
231                  case 0: break;
232                  case 1: output_len += 2; break;
233                  case 2: output_len += 3; break;
234              }
235          }
236          if (encoder.do_newline &amp;&amp; len &gt; 0) {
237              output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
238                  (encoder.do_cr ? 2 : 1);
239          }
240          encoder.output = new byte[output_len];
241          encoder.process(input, offset, len, true);
242          assert encoder.op == output_len;
243          return encoder.output;
244      }
245       static class Encoder extends Coder {
246          public static final int LINE_GROUPS = 19;
247          private static final byte ENCODE[] = {
248              &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,
249              &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,
250              &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
251              &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;,
252          };
253          private static final byte ENCODE_WEBSAFE[] = {
254              &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,
255              &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,
256              &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
257              &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;-&#x27;, &#x27;_&#x27;,
258          };
259          final private byte[] tail;
260           int tailLen;
261          private int count;
262          final public boolean do_padding;
263          final public boolean do_newline;
264          final public boolean do_cr;
265          final private byte[] alphabet;
266          public Encoder(int flags, byte[] output) {
267              this.output = output;
268              do_padding = (flags &amp; NO_PADDING) == 0;
269              do_newline = (flags &amp; NO_WRAP) == 0;
270              do_cr = (flags &amp; CRLF) != 0;
271              alphabet = ((flags &amp; URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
272              tail = new byte[2];
273              tailLen = 0;
274              count = do_newline ? LINE_GROUPS : -1;
275          }
276          public int maxOutputSize(int len) {
277              return len * 8/5 + 10;
278          }
279          public boolean process(byte[] input, int offset, int len, boolean finish) {
280              final byte[] alphabet = this.alphabet;
281              final byte[] output = this.output;
282              int op = 0;
283              int count = this.count;
284              int p = offset;
285              len += offset;
286              int v = -1;
287              switch (tailLen) {
288                  case 0:
289                      break;
290                  case 1:
291                      if (p+2 &lt;= len) {
292                          v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |
293                              ((input[p++] &amp; 0xff) &lt;&lt; 8) |
294                              (input[p++] &amp; 0xff);
295                          tailLen = 0;
296                      };
297                      break;
298                  case 2:
299                      if (p+1 &lt;= len) {
300                          v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |
301                              ((tail[1] &amp; 0xff) &lt;&lt; 8) |
302                              (input[p++] &amp; 0xff);
303                          tailLen = 0;
304                      }
305                      break;
306              }
307              if (v != -1) {
308                  output[op++] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];
309                  output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
310                  output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
311                  output[op++] = alphabet[v &amp; 0x3f];
312                  if (--count == 0) {
313                      if (do_cr) output[op++] = &#x27;\r&#x27;;
314                      output[op++] = &#x27;\n&#x27;;
315                      count = LINE_GROUPS;
316                  }
317              }
318              while (p+3 &lt;= len) {
319                  v = ((input[p] &amp; 0xff) &lt;&lt; 16) |
320                      ((input[p+1] &amp; 0xff) &lt;&lt; 8) |
321                      (input[p+2] &amp; 0xff);
322                  output[op] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];
323                  output[op+1] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
324                  output[op+2] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
325                  output[op+3] = alphabet[v &amp; 0x3f];
326                  p += 3;
327                  op += 4;
328                  if (--count == 0) {
329                      if (do_cr) output[op++] = &#x27;\r&#x27;;
330                      output[op++] = &#x27;\n&#x27;;
331                      count = LINE_GROUPS;
332                  }
333              }
334              if (finish) {
335                  if (p-tailLen == len-1) {
336                      int t = 0;
337                      v = ((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 4;
338                      tailLen -= t;
339                      output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
340                      output[op++] = alphabet[v &amp; 0x3f];
341                      if (do_padding) {
342                          output[op++] = &#x27;=&#x27;;
343                          output[op++] = &#x27;=&#x27;;
344                      }
345                      if (do_newline) {
346                          if (do_cr) output[op++] = &#x27;\r&#x27;;
347                          output[op++] = &#x27;\n&#x27;;
348                      }
349                  } else if (p-tailLen == len-2) {
350                      int t = 0;
351                      v = (((tailLen &gt; 1 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 10) |
352                          (((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 2);
353                      tailLen -= t;
354                      output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];
355                      output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];
356                      output[op++] = alphabet[v &amp; 0x3f];
357                      if (do_padding) {
358                          output[op++] = &#x27;=&#x27;;
359                      }
360                      if (do_newline) {
361                          if (do_cr) output[op++] = &#x27;\r&#x27;;
362                          output[op++] = &#x27;\n&#x27;;
363                      }
364                  } else if (do_newline &amp;&amp; op &gt; 0 &amp;&amp; count != LINE_GROUPS) {
365                      if (do_cr) output[op++] = &#x27;\r&#x27;;
366                      output[op++] = &#x27;\n&#x27;;
367                  }
368                  assert tailLen == 0;
369                  assert p == len;
370              } else {
371                  if (p == len-1) {
372                      tail[tailLen++] = input[p];
373                  } else if (p == len-2) {
374                      tail[tailLen++] = input[p];
375                      tail[tailLen++] = input[p+1];
376                  }
377              }
378              this.op = op;
379              this.count = count;
380              return true;
381          }
382      }
383      private Base64() { }   
384  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</div>
                </div>
                <div class="column column_space"><pre><code>101                          output[op+2] = (byte) value;
102                          output[op+1] = (byte) (value &gt;&gt; 8);
103                          output[op] = (byte) (value &gt;&gt; 16);
104                          op += 3;
105                          p += 4;
</pre></code></div>
                <div class="column column_space"><pre><code>144                          output[op+2] = (byte) value;
145                          output[op+1] = (byte) (value &gt;&gt; 8);
146                          output[op] = (byte) (value &gt;&gt; 16);
147                          op += 3;
148                          state = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    