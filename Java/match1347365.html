<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Traverser.java &amp; ClassSanityTester.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Traverser.java &amp; ClassSanityTester.java
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Traverser.java (9.438775%)<th>ClassSanityTester.java (3.6132812%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-64)<td><a href="#" name="0">(43-82)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(227-242)<td><a href="#" name="1">(385-395)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(283-297)<td><a href="#" name="2">(711-719)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Traverser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.graph;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
4 import static com.google.common.base.Preconditions.checkNotNull;
5 import static java.util.Objects.requireNonNull;
6 import com.google.common.annotations.Beta;
7 import com.google.common.collect.AbstractIterator;
8 import com.google.common.collect.ImmutableSet;
9 import com.google.errorprone.annotations.DoNotMock;
10 import java.util.ArrayDeque;
11 import java.util.Deque;
12 import java.util.HashSet;
13 import java.util.Iterator;
14 import java.util.Set;
15 import javax.annotation.CheckForNull;
16 @Beta
17 @</b></font>DoNotMock(
18     "Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with"
19         + " GraphBuilder)")
20 @ElementTypesAreNonnullByDefault
21 public abstract class Traverser&lt;N&gt; {
22   private final SuccessorsFunction&lt;N&gt; successorFunction;
23   private Traverser(SuccessorsFunction&lt;N&gt; successorFunction) {
24     this.successorFunction = checkNotNull(successorFunction);
25   }
26   public static &lt;N&gt; Traverser&lt;N&gt; forGraph(SuccessorsFunction&lt;N&gt; graph) {
27     return new Traverser&lt;N&gt;(graph) {
28       @Override
29       Traversal&lt;N&gt; newTraversal() {
30         return Traversal.inGraph(graph);
31       }
32     };
33   }
34   public static &lt;N&gt; Traverser&lt;N&gt; forTree(SuccessorsFunction&lt;N&gt; tree) {
35     if (tree instanceof BaseGraph) {
36       checkArgument(((BaseGraph&lt;?&gt;) tree).isDirected(), "Undirected graphs can never be trees.");
37     }
38     if (tree instanceof Network) {
39       checkArgument(((Network&lt;?, ?&gt;) tree).isDirected(), "Undirected networks can never be trees.");
40     }
41     return new Traverser&lt;N&gt;(tree) {
42       @Override
43       Traversal&lt;N&gt; newTraversal() {
44         return Traversal.inTree(tree);
45       }
46     };
47   }
48   public final Iterable&lt;N&gt; breadthFirst(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>N startNode) {
49     return breadthFirst(ImmutableSet.of(startNode));
50   }
51   public final Iterable&lt;N&gt; breadthFirst(Iterable&lt;? extends N&gt; startNodes) {
52     ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
53     return new Iterable&lt;N&gt;() {
54       @Override
55       public Iterator&lt;N&gt; iterator() {
56         return newTraversal().breadthFirst(validated.iterator());
57       }
58     };
59   }
60   public final Iterable&lt;N&gt; depthFirstPreOrder(N startNode) {
61     return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>depthFirstPreOrder(ImmutableSet.of(startNode));
62   }
63   public final Iterable&lt;N&gt; depthFirstPreOrder(Iterable&lt;? extends N&gt; startNodes) {
64     ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
65     return new Iterable&lt;N&gt;() {
66       @Override
67       public Iterator&lt;N&gt; iterator() {
68         return newTraversal().preOrder(validated.iterator());
69       }
70     };
71   }
72   public final Iterable&lt;N&gt; depthFirstPostOrder(N startNode) {
73     return depthFirstPostOrder(ImmutableSet.of(startNode));
74   }
75   public final Iterable&lt;N&gt; depthFirstPostOrder(Iterable&lt;? extends N&gt; startNodes) {
76     ImmutableSet&lt;N&gt; validated = validate(startNodes);
77     return new Iterable&lt;N&gt;() {
78       @Override
79       public Iterator&lt;N&gt; iterator() {
80         return newTraversal().postOrder(validated.iterator());
81       }
82     };
83   }
84   abstract Traversal&lt;N&gt; newTraversal();
85   @SuppressWarnings("CheckReturnValue")
86   private ImmutableSet&lt;N&gt; validate(Iterable&lt;? extends N&gt; startNodes) {
87     ImmutableSet&lt;N&gt; copy = ImmutableSet.copyOf(startNodes);
88     for (N node : copy) {
89       successorFunction.successors(node);     }
90     return copy;
91   }
92   private abstract static class Traversal&lt;N&gt; {
93     final SuccessorsFunction&lt;N&gt; successorFunction;
94     Traversal(SuccessorsFunction&lt;N&gt; successorFunction) {
95       this.successorFunction = successorFunction;
96     }
97     static &lt;N&gt; Traversal&lt;N&gt; inGraph(SuccessorsFunction&lt;N&gt; graph) {
98       Set&lt;N&gt; visited = new HashSet&lt;&gt;();
99       return new Traversal&lt;N&gt;(graph) {
100         @Override
101         @CheckForNull
102         N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
103           Iterator&lt;? extends N&gt; top = horizon.getFirst();
104           while (top.hasNext()) {
105             N element = top.next();
106             requireNonNull(element);
107             if (visited.add(element)) {
108               return element;
109             }
110           }
111           horizon.removeFirst();
112           return null;
113         }
114       };
115     }
116     static &lt;N&gt; Traversal&lt;N&gt; inTree(SuccessorsFunction&lt;N&gt; tree) {
117       return new Traversal&lt;N&gt;(tree) {
118         @CheckForNull
119         @Override
120         N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
121           Iterator&lt;? extends N&gt; top = horizon.getFirst();
122           if (top.hasNext()) {
123             return checkNotNull(top.next());
124           }
125           horizon.removeFirst();
126           return null;
127         }
128       };
129     }
130     final Iterator&lt;N&gt; breadthFirst(Iterator&lt;? extends N&gt; startNodes) {
131       return topDown(startNodes, InsertionOrder.BACK);
132     }
133     final Iterator&lt;N&gt; preOrder(Iterator&lt;? extends N&gt; startNodes) {
134       return topDown(startNodes, InsertionOrder.FRONT);
135     }
136     private Iterator&lt;N&gt; topDown(Iterator&lt;? extends N&gt; startNodes, InsertionOrder order) {
137       Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
138       horizon.add(startNodes);
139       return new AbstractIterator&lt;N&gt;() {
140         @Override
141         @CheckForNull
142         protected N computeNext() {
143           do {
144             N next = visitNext(horizon);
145             if (next != null) {
146               Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
147               if (successors.hasNext()) {
148                 order.insertInto(horizon, successors);
149               }
150               return next;
151             }
152           } while (!horizon.isEmpty());
153           return endOfData();
154         }
155       };
156     }
157     final Iterator&lt;N&gt; postOrder(Iterator&lt;? extends N&gt; startNodes) {
158       Deque&lt;N&gt; ancestorStack = new ArrayDeque&lt;&gt;();
159       Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
160       horizon.add(startNodes);
161       return new AbstractIterator&lt;N&gt;() {
162         @Override
163         @CheckForNull
164         protected N computeNext() {
165           for (N next = visitNext(horizon); next != null; next = visitNext(horizon)) {
166             Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
167             if (!successors.hasNext()) {
168               return next;
169             }
170             horizon.addFirst(successors);
171             ancestorStack.push(next);
172           }
173           if (!ancestorStack.isEmpty()) {
174             return ancestorStack.pop();
175           }
176           return endOfData();
177         }
178       };
179     }
180     @CheckForNull
181     abstract N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon);
182   }
183   private enum InsertionOrder {
184     FRONT {
185       @Override
186       &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
187         deque.addFirst(value);
188       }
189     },
190     BACK {
191       @Override
192       &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
193         deque.addLast(value);
194       }
195     };
196     abstract &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value);
197   }
198 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClassSanityTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.testing;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.base.Throwables.throwIfUnchecked;
5 import static com.google.common.testing.NullPointerTester.isNullable;
6 import com.google.common.annotations.Beta;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.annotations.VisibleForTesting;
9 import com.google.common.base.Joiner;
10 import com.google.common.base.Objects;
11 import com.google.common.collect.ArrayListMultimap;
12 import com.google.common.collect.ImmutableList;
13 import com.google.common.collect.ListMultimap;
14 import com.google.common.collect.Lists;
15 import com.google.common.collect.MutableClassToInstanceMap;
16 import com.google.common.collect.Ordering;
17 import com.google.common.collect.Sets;
18 import com.google.common.primitives.Ints;
19 import com.google.common.reflect.Invokable;
20 import com.google.common.reflect.Parameter;
21 import com.google.common.reflect.Reflection;
22 <a name="0"></a>import com.google.common.reflect.TypeToken;
23 import com.google.common.testing.NullPointerTester.Visibility;
24 import com.google.common.testing.RelationshipTester.Item;
25 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.testing.RelationshipTester.ItemReporter;
26 import java.io.Serializable;
27 import java.lang.reflect.Constructor;
28 import java.lang.reflect.InvocationTargetException;
29 import java.lang.reflect.Method;
30 import java.lang.reflect.Modifier;
31 import java.util.Collection;
32 import java.util.List;
33 import java.util.Map.Entry;
34 import java.util.Set;
35 import junit.framework.Assert;
36 import junit.framework.AssertionFailedError;
37 import org.checkerframework.checker.nullness.qual.Nullable;
38 @Beta
39 @</b></font>GwtIncompatible
40 public final class ClassSanityTester {
41   private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_METHOD_NAME =
42       new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
43         @Override
44         public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
45           return left.getName().compareTo(right.getName());
46         }
47       };
48   private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_PARAMETERS =
49       new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
50         @Override
51         public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
52           return Ordering.usingToString().compare(left.getParameters(), right.getParameters());
53         }
54       };
55   private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_NUMBER_OF_PARAMETERS =
56       new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
57         @Override
58         public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
59           return Ints.compare(left.getParameters().size(), right.getParameters().size());
60         }
61       };
62   private final MutableClassToInstanceMap&lt;Object&gt; defaultValues =
63       MutableClassToInstanceMap.create();
64   private final ListMultimap&lt;Class&lt;?&gt;, Object&gt; distinctValues = ArrayListMultimap.create();
65   private final NullPointerTester nullPointerTester = new NullPointerTester();
66   public ClassSanityTester() {
67     setDefault(byte.class, (byte) 1);
68     setDefault(Byte.class, (byte) 1);
69     setDefault(short.class, (short) 1);
70     setDefault(Short.class, (short) 1);
71     setDefault(int.class, 1);
72     setDefault(Integer.class, 1);
73     setDefault(long.class, 1L);
74     setDefault(Long.class, 1L);
75     setDefault(float.class, 1F);
76     setDefault(Float.class, 1F);
77     setDefault(double.class, 1D);
78     setDefault(Double.class, 1D);
79     setDefault(Class.class, Class.class);
80   }
81   public &lt;T&gt; ClassSanityTester setDefault(Class&lt;T&gt; type, T value) {
82     nullPointerTester.setDefault(type, value);
83     defaultValues.putInstance(type, value);
84     return this;
85   }
86   public &lt;T&gt; ClassSanityTester setDistinctValues(Class&lt;T&gt; type, T value1, T value2) {
87     checkNotNull(type);
88     checkNotNull(value1);
89     checkNotNull(value2);
90     checkArgument(!Objects.equal(value1, value2), "Duplicate value provided.");
91     distinctValues.replaceValues(type, ImmutableList.of(value1, value2));
92     setDefault(type, value1);
93     return this;
94   }
95   public void testNulls(Class&lt;?&gt; cls) {
96     try {
97       doTestNulls(cls, Visibility.PACKAGE);
98     } catch (Exception e) {
99       throwIfUnchecked(e);
100       throw new RuntimeException(e);
101     }
102   }
103   void doTestNulls(Class&lt;?&gt; cls, Visibility visibility)
104       throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
105           FactoryMethodReturnsNullException {
106     if (!Modifier.isAbstract(cls.getModifiers())) {
107       nullPointerTester.testConstructors(cls, visibility);
108     }
109     nullPointerTester.testStaticMethods(cls, visibility);
110     if (hasInstanceMethodToTestNulls(cls, visibility)) {
111       Object instance = instantiate(cls);
112       if (instance != null) {
113         nullPointerTester.testInstanceMethods(instance, visibility);
114       }
115     }
116   }
117   private boolean hasInstanceMethodToTestNulls(Class&lt;?&gt; c, Visibility visibility) {
118     for (Method method : nullPointerTester.getInstanceMethodsToTest(c, visibility)) {
119       for (Parameter param : Invokable.from(method).getParameters()) {
120         if (!NullPointerTester.isPrimitiveOrNullable(param)) {
121           return true;
122         }
123       }
124     }
125     return false;
126   }
127   public void testEquals(Class&lt;?&gt; cls) {
128     try {
129       doTestEquals(cls);
130     } catch (Exception e) {
131       throwIfUnchecked(e);
132       throw new RuntimeException(e);
133     }
134   }
135   void doTestEquals(Class&lt;?&gt; cls)
136       throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
137           IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
138     if (cls.isEnum()) {
139       return;
140     }
141     List&lt;? extends Invokable&lt;?, ?&gt;&gt; factories = Lists.reverse(getFactories(TypeToken.of(cls)));
142     if (factories.isEmpty()) {
143       return;
144     }
145     int numberOfParameters = factories.get(0).getParameters().size();
146     List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
147     List&lt;ParameterHasNoDistinctValueException&gt; distinctValueErrors = Lists.newArrayList();
148     List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
149     List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
150     for (Invokable&lt;?, ?&gt; factory : factories) {
151       if (factory.getParameters().size() == numberOfParameters) {
152         try {
153           testEqualsUsing(factory);
154           return;
155         } catch (ParameterNotInstantiableException e) {
156           paramErrors.add(e);
157         } catch (ParameterHasNoDistinctValueException e) {
158           distinctValueErrors.add(e);
159         } catch (InvocationTargetException e) {
160           instantiationExceptions.add(e);
161         } catch (FactoryMethodReturnsNullException e) {
162           nullErrors.add(e);
163         }
164       }
165     }
166     throwFirst(paramErrors);
167     throwFirst(distinctValueErrors);
168     throwFirst(instantiationExceptions);
169     throwFirst(nullErrors);
170   }
171   &lt;T&gt; @Nullable T instantiate(Class&lt;T&gt; cls)
172       throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
173           FactoryMethodReturnsNullException {
174     if (cls.isEnum()) {
175       T[] constants = cls.getEnumConstants();
176       if (constants.length &gt; 0) {
177         return constants[0];
178       } else {
179         return null;
180       }
181     }
182     TypeToken&lt;T&gt; type = TypeToken.of(cls);
183     List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
184     List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
185     List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
186     for (Invokable&lt;?, ? extends T&gt; factory : getFactories(type)) {
187       T instance;
188       try {
189         instance = instantiate(factory);
190       } catch (ParameterNotInstantiableException e) {
191         paramErrors.add(e);
192         continue;
193       } catch (InvocationTargetException e) {
194         instantiationExceptions.add(e);
195         continue;
196       }
197       if (instance == null) {
198         nullErrors.add(new FactoryMethodReturnsNullException(factory));
199       } else {
200         return instance;
201       }
202     }
203     throwFirst(paramErrors);
204     throwFirst(instantiationExceptions);
205     throwFirst(nullErrors);
206     return null;
207   }
208   private &lt;T&gt; @Nullable T instantiate(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Invokable&lt;?, ? extends T&gt; factory)
209       throws ParameterNotInstantiableException, InvocationTargetException, IllegalAccessException {
210     return invoke(factory, getDummyArguments(factory));
211   }
212   public FactoryMethodReturnValueTester forAllPublicStaticMethods(Class&lt;?&gt; cls) {
213     ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder</b></font>();
214     for (Method method : cls.getDeclaredMethods()) {
215       Invokable&lt;?, ?&gt; invokable = Invokable.from(method);
216       invokable.setAccessible(true);
217       if (invokable.isPublic() &amp;&amp; invokable.isStatic() &amp;&amp; !invokable.isSynthetic()) {
218         builder.add(invokable);
219       }
220     }
221     return new FactoryMethodReturnValueTester(cls, builder.build(), "public static methods");
222   }
223   public final class FactoryMethodReturnValueTester {
224     private final Set&lt;String&gt; packagesToTest = Sets.newHashSet();
225     private final Class&lt;?&gt; declaringClass;
226     private final ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories;
227     private final String factoryMethodsDescription;
228     private Class&lt;?&gt; returnTypeToTest = Object.class;
229     private FactoryMethodReturnValueTester(
230         Class&lt;?&gt; declaringClass,
231         ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories,
232         String factoryMethodsDescription) {
233       this.declaringClass = declaringClass;
234       this.factories = factories;
235       this.factoryMethodsDescription = factoryMethodsDescription;
236       packagesToTest.add(Reflection.getPackageName(declaringClass));
237     }
238     public FactoryMethodReturnValueTester thatReturn(Class&lt;?&gt; returnType) {
239       this.returnTypeToTest = returnType;
240       return this;
241     }
242     public FactoryMethodReturnValueTester testNulls() throws Exception {
243       for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
244         Object instance = instantiate(factory);
245         if (instance != null
246             &amp;&amp; packagesToTest.contains(Reflection.getPackageName(instance.getClass()))) {
247           try {
248             nullPointerTester.testAllPublicInstanceMethods(instance);
249           } catch (AssertionError e) {
250             AssertionError error =
251                 new AssertionFailedError("Null check failed on return value of " + factory);
252             error.initCause(e);
253             throw error;
254           }
255         }
256       }
257       return this;
258     }
259     public FactoryMethodReturnValueTester testEquals() throws Exception {
260       for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
261         try {
262           testEqualsUsing(factory);
263         } catch (FactoryMethodReturnsNullException e) {
264         }
265       }
266       return this;
267     }
268     public FactoryMethodReturnValueTester testSerializable() throws Exception {
269       for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
270         Object instance = instantiate(factory);
271         if (instance != null) {
272           try {
273             SerializableTester.reserialize(instance);
274           } catch (RuntimeException e) {
275             AssertionError error =
276                 new AssertionFailedError("Serialization failed on return value of " + factory);
277             error.initCause(e.getCause());
278             throw error;
279           }
280         }
281       }
282       return this;
283     }
284     public FactoryMethodReturnValueTester testEqualsAndSerializable() throws Exception {
285       for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
286         try {
287           testEqualsUsing(factory);
288         } catch (FactoryMethodReturnsNullException e) {
289         }
290         Object instance = instantiate(factory);
291         if (instance != null) {
292           try {
293             SerializableTester.reserializeAndAssert(instance);
294           } catch (RuntimeException e) {
295             AssertionError error =
296                 new AssertionFailedError("Serialization failed on return value of " + factory);
297             error.initCause(e.getCause());
298             throw error;
299           } catch (AssertionFailedError e) {
300             AssertionError error =
301                 new AssertionFailedError(
302                     "Return value of " + factory + " reserialized to an unequal value");
303             error.initCause(e);
304             throw error;
305           }
306         }
307       }
308       return this;
309     }
310     private ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; getFactoriesToTest() {
311       ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder();
312       for (Invokable&lt;?, ?&gt; factory : factories) {
313         if (returnTypeToTest.isAssignableFrom(factory.getReturnType().getRawType())) {
314           builder.add(factory);
315         }
316       }
317       ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factoriesToTest = builder.build();
318       Assert.assertFalse(
319           "No "
320               + factoryMethodsDescription
321               + " that return "
322               + returnTypeToTest.getName()
323               + " or subtype are found in "
324               + declaringClass
325               + ".",
326           factoriesToTest.isEmpty());
327       return factoriesToTest;
328     }
329   }
330   private void testEqualsUsing(final Invokable&lt;?, ?&gt; factory)
331       throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
332           IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
333     List&lt;Parameter&gt; params = factory.getParameters();
334     List&lt;FreshValueGenerator&gt; argGenerators = Lists.newArrayListWithCapacity(params.size());
335     List&lt;Object&gt; args = Lists.newArrayListWithCapacity(params.size());
336     for (Parameter param : params) {
337       FreshValueGenerator generator = newFreshValueGenerator();
338       argGenerators.add(generator);
339       args.add(generateDummyArg(param, generator));
340     }
341     Object instance = createInstance(factory, args);
342     List&lt;Object&gt; equalArgs = generateEqualFactoryArguments(factory, params, args);
343     final List&lt;List&lt;List&lt;Object&gt;&gt;&gt; argGroups = Lists.newArrayList();
344     argGroups.add(ImmutableList.of(args, equalArgs));
345     EqualsTester tester =
346         new EqualsTester(
347             new ItemReporter() {
348               @Override
349               String reportItem(Item&lt;?&gt; item) {
350                 List&lt;Object&gt; factoryArgs = argGroups.get(item.groupNumber).get(item.itemNumber);
351                 return factory.getName()
352                     + "("
353                     + Joiner.on(", ").useForNull("null").join(factoryArgs)
354                     + ")";
355               }
356             });
357     tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
358     for (int i = 0; i &lt; params.size(); i++) {
359       List&lt;Object&gt; newArgs = Lists.newArrayList(args);
360       Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());
361       if (newArg == null || Objects.equal(args.get(i), newArg)) {
362         if (params.get(i).getType().getRawType().isEnum()) {
363           continue;         }
364         throw new ParameterHasNoDistinctValueException(params.get(i));
365       }
366       newArgs.set(i, newArg);
367       tester.addEqualityGroup(createInstance(factory, newArgs));
368       argGroups.add(ImmutableList.of(newArgs));
369     }
370     tester.testEquals();
371   }
372   private List&lt;Object&gt; generateEqualFactoryArguments(
373       Invokable&lt;?, ?&gt; factory, List&lt;Parameter&gt; params, List&lt;Object&gt; args)
374       throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,
375           InvocationTargetException, IllegalAccessException {
376     List&lt;Object&gt; equalArgs = Lists.newArrayList(args);
377     for (int i = 0; i &lt; args.size(); i++) {
378       Parameter param = params.get(i);
379       Object arg = args.get(i);
380       Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());
381       if (arg != shouldBeEqualArg
382           &amp;&amp; Objects.equal(arg, shouldBeEqualArg)
383           &amp;&amp; hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg)
384           &amp;&amp; hashCodeInsensitiveToArgReference(
385               factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {
386         equalArgs.set(i, shouldBeEqualArg);
387       }
388     }
389     return equalArgs;
390   }
391   private static boolean hashCodeInsensitiveToArgReference(
392       Invokable&lt;?, ?&gt; factory, List&lt;Object&gt; args, int i, Object alternateArg)
393       throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
394     List&lt;Object&gt; tentativeArgs = Lists.newArrayList(args);
395     tentativeArgs.set(i, alternateArg);
396     return createInstance(factory, tentativeArgs).hashCode()
397         == createInstance(factory, args).hashCode();
398   }
399   @SuppressWarnings({"unchecked", "rawtypes"})
400   private FreshValueGenerator newFreshValueGenerator() {
401     FreshValueGenerator generator =
402         new FreshValueGenerator() {
403           @Override
404           Object interfaceMethodCalled(Class&lt;?&gt; interfaceType, Method method) {
405             return getDummyValue(TypeToken.of(interfaceType).method(method).getReturnType());
406           }
407         };
408     for (Entry&lt;Class&lt;?&gt;, Collection&lt;Object&gt;&gt; entry : distinctValues.asMap().entrySet()) {
409       generator.addSampleInstances((Class) entry.getKey(), entry.getValue());
410     }
411     return generator;
412   }
413   private static @Nullable Object generateDummyArg(Parameter param, FreshValueGenerator generator)
414       throws ParameterNotInstantiableException {
415     if (isNullable(param)) {
416       return null;
417     }
418     Object arg = generator.generateFresh(param.getType());
419     if (arg == null) {
420       throw new ParameterNotInstantiableException(param);
421     }
422     return arg;
423   }
424   private static &lt;X extends Throwable&gt; void throwFirst(List&lt;X&gt; exceptions) throws X {
425     if (!exceptions.isEmpty()) {
426       throw exceptions.get(0);
427     }
428   }
429   private static &lt;T&gt; ImmutableList&lt;Invokable&lt;?, ? extends T&gt;&gt; getFactories(TypeToken&lt;T&gt; type) {
430     List&lt;Invokable&lt;?, ? extends T&gt;&gt; factories = Lists.newArrayList();
431     for (Method method : type.getRawType().getDeclaredMethods()) {
432       Invokable&lt;?, ?&gt; invokable = type.method(method);
433       if (!invokable.isPrivate()
434           &amp;&amp; !invokable.isSynthetic()
435           &amp;&amp; invokable.isStatic()
436           &amp;&amp; type.isSupertypeOf(invokable.getReturnType())) {
437         @SuppressWarnings("unchecked")         Invokable&lt;?, ? extends T&gt; factory = (Invokable&lt;?, ? extends T&gt;) invokable;
438         factories.add(factory);
439       }
440     }
441     if (!Modifier.isAbstract(type.getRawType().getModifiers())) {
442       for (Constructor&lt;?&gt; constructor : type.getRawType().getDeclaredConstructors()) {
443         Invokable&lt;T, T&gt; invokable = type.constructor(constructor);
444         if (!invokable.isPrivate() &amp;&amp; !invokable.isSynthetic()) {
445           factories.add(invokable);
446         }
447       }
448     }
449     for (Invokable&lt;?, ?&gt; factory : factories) {
450       factory.setAccessible(true);
451     }
452 <a name="2"></a>        return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BY_NUMBER_OF_PARAMETERS
453         .compound(BY_METHOD_NAME)
454         .compound(BY_PARAMETERS)
455         .immutableSortedCopy(factories);
456   }
457   private List&lt;Object&gt; getDummyArguments(Invokable&lt;?, ?&gt; invokable)
458       throws ParameterNotInstantiableException {
459     List&lt;Object&gt; args = Lists.newArrayList</b></font>();
460     for (Parameter param : invokable.getParameters()) {
461       if (isNullable(param)) {
462         args.add(null);
463         continue;
464       }
465       Object defaultValue = getDummyValue(param.getType());
466       if (defaultValue == null) {
467         throw new ParameterNotInstantiableException(param);
468       }
469       args.add(defaultValue);
470     }
471     return args;
472   }
473   private &lt;T&gt; T getDummyValue(TypeToken&lt;T&gt; type) {
474     Class&lt;? super T&gt; rawType = type.getRawType();
475     @SuppressWarnings("unchecked")     T defaultValue = (T) defaultValues.getInstance(rawType);
476     if (defaultValue != null) {
477       return defaultValue;
478     }
479     @SuppressWarnings("unchecked")     T value = (T) ArbitraryInstances.get(rawType);
480     if (value != null) {
481       return value;
482     }
483     if (rawType.isInterface()) {
484       return new SerializableDummyProxy(this).newProxy(type);
485     }
486     return null;
487   }
488   private static &lt;T&gt; T createInstance(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
489       throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
490     T instance = invoke(factory, args);
491     if (instance == null) {
492       throw new FactoryMethodReturnsNullException(factory);
493     }
494     return instance;
495   }
496   private static &lt;T&gt; @Nullable T invoke(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
497       throws InvocationTargetException, IllegalAccessException {
498     T returnValue = factory.invoke(null, args.toArray());
499     if (returnValue == null) {
500       Assert.assertTrue(
501           factory + " returns null but it's not annotated with @Nullable", isNullable(factory));
502     }
503     return returnValue;
504   }
505   @VisibleForTesting
506   static class ParameterNotInstantiableException extends Exception {
507     public ParameterNotInstantiableException(Parameter parameter) {
508       super(
509           "Cannot determine value for parameter "
510               + parameter
511               + " of "
512               + parameter.getDeclaringInvokable());
513     }
514   }
515   @VisibleForTesting
516   static class ParameterHasNoDistinctValueException extends Exception {
517     ParameterHasNoDistinctValueException(Parameter parameter) {
518       super(
519           "Cannot generate distinct value for parameter "
520               + parameter
521               + " of "
522               + parameter.getDeclaringInvokable());
523     }
524   }
525   @VisibleForTesting
526   static class FactoryMethodReturnsNullException extends Exception {
527     public FactoryMethodReturnsNullException(Invokable&lt;?, ?&gt; factory) {
528       super(factory + " returns null and cannot be used to test instance methods.");
529     }
530   }
531   private static final class SerializableDummyProxy extends DummyProxy implements Serializable {
532     private final transient ClassSanityTester tester;
533     SerializableDummyProxy(ClassSanityTester tester) {
534       this.tester = tester;
535     }
536     @Override
537     &lt;R&gt; R dummyReturnValue(TypeToken&lt;R&gt; returnType) {
538       return tester.getDummyValue(returnType);
539     }
540     @Override
541     public boolean equals(Object obj) {
542       return obj instanceof SerializableDummyProxy;
543     }
544     @Override
545     public int hashCode() {
546       return 0;
547     }
548   }
549 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
