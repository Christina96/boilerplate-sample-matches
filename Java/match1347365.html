<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for Traverser.java &amp; ClassSanityTester.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Traverser.java &amp; ClassSanityTester.java
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Traverser.java (9.438775%)<th>ClassSanityTester.java (3.6132812%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-64)<td><a href="#" name="0">(43-82)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(227-242)<td><a href="#" name="1">(385-395)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(283-297)<td><a href="#" name="2">(711-719)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Traverser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2017 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="0"></a>
package com.google.common.graph;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.ImmutableSet;
import com.google.errorprone.annotations.DoNotMock;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.annotation.CheckForNull;

/**
 * An object that can traverse the nodes that are reachable from a specified (set of) start node(s)
 * using a specified {@link SuccessorsFunction}.
 *
 * &lt;p&gt;There are two entry points for creating a {@code Traverser}: {@link
 * #forTree(SuccessorsFunction)} and {@link #forGraph(SuccessorsFunction)}. You should choose one
 * based on your answers to the following questions:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;Is there only one path to any node that's reachable from any start node? (If so, the graph
 *       to be traversed is a tree or forest even if it is a subgraph of a graph which is neither.)
 *   &lt;li&gt;Are the node objects' implementations of {@code equals()}/{@code hashCode()} &lt;a
 *       href="https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness"&gt;recursive&lt;/a&gt;?
 * &lt;/ol&gt;
 *
 * &lt;p&gt;If your answers are:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;(1) "no" and (2) "no", use {@link #forGraph(SuccessorsFunction)}.
 *   &lt;li&gt;(1) "yes" and (2) "yes", use {@link #forTree(SuccessorsFunction)}.
 *   &lt;li&gt;(1) "yes" and (2) "no", you can use either, but {@code forTree()} will be more efficient.
 *   &lt;li&gt;(1) "no" and (2) "yes", &lt;b&gt;&lt;i&gt;neither will work&lt;/i&gt;&lt;/b&gt;, but if you transform your node
 *       objects into a non-recursive form, you can use {@code forGraph()}.
 * &lt;/ul&gt;
 *
 * @author Jens Nyman
 * @param &lt;N&gt; Node parameter type
 * @since 23.1
 */
@Beta
@</b></font>DoNotMock(
    "Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with"
        + " GraphBuilder)")
@ElementTypesAreNonnullByDefault
public abstract class Traverser&lt;N&gt; {
  private final SuccessorsFunction&lt;N&gt; successorFunction;

  private Traverser(SuccessorsFunction&lt;N&gt; successorFunction) {
    this.successorFunction = checkNotNull(successorFunction);
  }

  /**
   * Creates a new traverser for the given general {@code graph}.
   *
   * &lt;p&gt;Traversers created using this method are guaranteed to visit each node reachable from the
   * start node(s) at most once.
   *
   * &lt;p&gt;If you know that no node in {@code graph} is reachable by more than one path from the start
   * node(s), consider using {@link #forTree(SuccessorsFunction)} instead.
   *
   * &lt;p&gt;&lt;b&gt;Performance notes&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Traversals require &lt;i&gt;O(n)&lt;/i&gt; time (where &lt;i&gt;n&lt;/i&gt; is the number of nodes reachable from
   *       the start node), assuming that the node objects have &lt;i&gt;O(1)&lt;/i&gt; {@code equals()} and
   *       {@code hashCode()} implementations. (See the &lt;a
   *       href="https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys"&gt;
   *       notes on element objects&lt;/a&gt; for more information.)
   *   &lt;li&gt;While traversing, the traverser will use &lt;i&gt;O(n)&lt;/i&gt; space (where &lt;i&gt;n&lt;/i&gt; is the number
   *       of nodes that have thus far been visited), plus &lt;i&gt;O(H)&lt;/i&gt; space (where &lt;i&gt;H&lt;/i&gt; is the
   *       number of nodes that have been seen but not yet visited, that is, the "horizon").
   * &lt;/ul&gt;
   *
   * @param graph {@link SuccessorsFunction} representing a general graph that may have cycles.
   */
  public static &lt;N&gt; Traverser&lt;N&gt; forGraph(SuccessorsFunction&lt;N&gt; graph) {
    return new Traverser&lt;N&gt;(graph) {
      @Override
      Traversal&lt;N&gt; newTraversal() {
        return Traversal.inGraph(graph);
      }
    };
  }

  /**
   * Creates a new traverser for a directed acyclic graph that has at most one path from the start
   * node(s) to any node reachable from the start node(s), and has no paths from any start node to
   * any other start node, such as a tree or forest.
   *
   * &lt;p&gt;{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data
   * structure being traversed is, in addition to being a tree/forest, also defined &lt;a
   * href="https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness"&gt;recursively&lt;/a&gt;.
   * This is because the {@code forTree()}-based implementations don't keep track of visited nodes,
   * and therefore don't need to call `equals()` or `hashCode()` on the node objects; this saves
   * both time and space versus traversing the same graph using {@code forGraph()}.
   *
   * &lt;p&gt;Providing a graph to be traversed for which there is more than one path from the start
   * node(s) to any node may lead to:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Traversal not terminating (if the graph has cycles)
   *   &lt;li&gt;Nodes being visited multiple times (if multiple paths exist from any start node to any
   *       node reachable from any start node)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Performance notes&lt;/b&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Traversals require &lt;i&gt;O(n)&lt;/i&gt; time (where &lt;i&gt;n&lt;/i&gt; is the number of nodes reachable from
   *       the start node).
   *   &lt;li&gt;While traversing, the traverser will use &lt;i&gt;O(H)&lt;/i&gt; space (where &lt;i&gt;H&lt;/i&gt; is the number
   *       of nodes that have been seen but not yet visited, that is, the "horizon").
   * &lt;/ul&gt;
   *
   * &lt;p&gt;&lt;b&gt;Examples&lt;/b&gt; (all edges are directed facing downwards)
   *
   * &lt;p&gt;The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code
   * b} were &lt;i&gt;also&lt;/i&gt; a start node, then there would be multiple paths to reach {@code e} and
   * {@code h}.
   *
   * &lt;pre&gt;{@code
   *    a     b      c
   *   / \   / \     |
   *  /   \ /   \    |
   * d     e     f   g
   *       |
   *       |
   *       h
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;.
   *
   * &lt;p&gt;The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code
   * b} were a start node, there would be multiple paths to {@code f}.
   *
   * &lt;pre&gt;{@code
   *    a     b
   *   / \   / \
   *  /   \ /   \
   * c     d     e
   *        \   /
   *         \ /
   *          f
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;&lt;b&gt;Note on binary trees&lt;/b&gt;
   *
   * &lt;p&gt;This method can be used to traverse over a binary tree. Given methods {@code
   * leftChild(node)} and {@code rightChild(node)}, this method can be called as
   *
   * &lt;pre&gt;{@code
   * Traverser.forTree(node -&gt; ImmutableList.of(leftChild(node), rightChild(node)));
   * }&lt;/pre&gt;
   *
   * @param tree {@link SuccessorsFunction} representing a directed acyclic graph that has at most
   *     one path between any two nodes
   */
  public static &lt;N&gt; Traverser&lt;N&gt; forTree(SuccessorsFunction&lt;N&gt; tree) {
    if (tree instanceof BaseGraph) {
      checkArgument(((BaseGraph&lt;?&gt;) tree).isDirected(), "Undirected graphs can never be trees.");
    }
    if (tree instanceof Network) {
      checkArgument(((Network&lt;?, ?&gt;) tree).isDirected(), "Undirected networks can never be trees.");
    }
    return new Traverser&lt;N&gt;(tree) {
      @Override
      Traversal&lt;N&gt; newTraversal() {
        return Traversal.inTree(tree);
      }
    };
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
   * the order of a breadth-first traversal. That is, all the nodes of depth 0 are returned, then
   * depth 1, then 2, and so on.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; The following graph with {@code startNode} {@code a} would return nodes in
   * the order {@code abcdef} (assuming successors are returned in alphabetical order).
   *
   * &lt;pre&gt;{@code
   * b ---- a ---- d
   * |      |
   * |      |
   * e ---- c ---- f
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;The behavior of this method is undefined if the nodes, or the topology of the graph, change
   * while iteration is in progress.
   *
   * &lt;p&gt;The returned {@code Iterable} can be iterated over multiple times. Every iterator will
   * compute its next element on the fly. It is thus possible to limit the traversal to a certain
   * number of nodes as follows:
   *
   * &lt;pre&gt;{@code
   * Iterables.limit(Traverser.forGraph(graph).breadthFirst(node), maxNumberOfNodes);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;See &lt;a href="https://en.wikipedia.org/wiki/Breadth-first_search"&gt;Wikipedia&lt;/a&gt; for more
   * info.
<a name="1"></a>   *
   * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
   */
  public final Iterable&lt;N&gt; breadthFirst(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>N startNode) {
    return breadthFirst(ImmutableSet.of(startNode));
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
   * startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first
   * traversal of a graph with an additional root node whose successors are the listed {@code
   * startNodes}.
   *
   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
   * @see #breadthFirst(Object)
   * @since 24.1
   */
  public final Iterable&lt;N&gt; breadthFirst(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().breadthFirst(validated.iterator());
      }
    };
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
   * the order of a depth-first pre-order traversal. "Pre-order" implies that nodes appear in the
   * {@code Iterable} in the order in which they are first visited.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; The following graph with {@code startNode} {@code a} would return nodes in
   * the order {@code abecfd} (assuming successors are returned in alphabetical order).
   *
   * &lt;pre&gt;{@code
   * b ---- a ---- d
   * |      |
   * |      |
   * e ---- c ---- f
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;The behavior of this method is undefined if the nodes, or the topology of the graph, change
   * while iteration is in progress.
   *
   * &lt;p&gt;The returned {@code Iterable} can be iterated over multiple times. Every iterator will
   * compute its next element on the fly. It is thus possible to limit the traversal to a certain
   * number of nodes as follows:
   *
   * &lt;pre&gt;{@code
   * Iterables.limit(
   *     Traverser.forGraph(graph).depthFirstPreOrder(node), maxNumberOfNodes);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;See &lt;a href="https://en.wikipedia.org/wiki/Depth-first_search"&gt;Wikipedia&lt;/a&gt; for more info.
   *
<a name="2"></a>   * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
   */
  public final Iterable&lt;N&gt; depthFirstPreOrder(N startNode) {
    return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>depthFirstPreOrder(ImmutableSet.of(startNode));
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
   * startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a
   * depth-first pre-order traversal of a graph with an additional root node whose successors are
   * the listed {@code startNodes}.
   *
   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
   * @see #depthFirstPreOrder(Object)
   * @since 24.1
   */
  public final Iterable&lt;N&gt; depthFirstPreOrder(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().preOrder(validated.iterator());
      }
    };
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
   * the order of a depth-first post-order traversal. "Post-order" implies that nodes appear in the
   * {@code Iterable} in the order in which they are visited for the last time.
   *
   * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; The following graph with {@code startNode} {@code a} would return nodes in
   * the order {@code fcebda} (assuming successors are returned in alphabetical order).
   *
   * &lt;pre&gt;{@code
   * b ---- a ---- d
   * |      |
   * |      |
   * e ---- c ---- f
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;The behavior of this method is undefined if the nodes, or the topology of the graph, change
   * while iteration is in progress.
   *
   * &lt;p&gt;The returned {@code Iterable} can be iterated over multiple times. Every iterator will
   * compute its next element on the fly. It is thus possible to limit the traversal to a certain
   * number of nodes as follows:
   *
   * &lt;pre&gt;{@code
   * Iterables.limit(
   *     Traverser.forGraph(graph).depthFirstPostOrder(node), maxNumberOfNodes);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;See &lt;a href="https://en.wikipedia.org/wiki/Depth-first_search"&gt;Wikipedia&lt;/a&gt; for more info.
   *
   * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
   */
  public final Iterable&lt;N&gt; depthFirstPostOrder(N startNode) {
    return depthFirstPostOrder(ImmutableSet.of(startNode));
  }

  /**
   * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
   * startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a
   * depth-first post-order traversal of a graph with an additional root node whose successors are
   * the listed {@code startNodes}.
   *
   * @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
   * @see #depthFirstPostOrder(Object)
   * @since 24.1
   */
  public final Iterable&lt;N&gt; depthFirstPostOrder(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().postOrder(validated.iterator());
      }
    };
  }

  abstract Traversal&lt;N&gt; newTraversal();

  @SuppressWarnings("CheckReturnValue")
  private ImmutableSet&lt;N&gt; validate(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; copy = ImmutableSet.copyOf(startNodes);
    for (N node : copy) {
      successorFunction.successors(node); // Will throw if node doesn't exist
    }
    return copy;
  }

  /**
   * Abstracts away the difference between traversing a graph vs. a tree. For a tree, we just take
   * the next element from the next non-empty iterator; for graph, we need to loop through the next
   * non-empty iterator to find first unvisited node.
   */
  private abstract static class Traversal&lt;N&gt; {
    final SuccessorsFunction&lt;N&gt; successorFunction;

    Traversal(SuccessorsFunction&lt;N&gt; successorFunction) {
      this.successorFunction = successorFunction;
    }

    static &lt;N&gt; Traversal&lt;N&gt; inGraph(SuccessorsFunction&lt;N&gt; graph) {
      Set&lt;N&gt; visited = new HashSet&lt;&gt;();
      return new Traversal&lt;N&gt;(graph) {
        @Override
        @CheckForNull
        N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
          Iterator&lt;? extends N&gt; top = horizon.getFirst();
          while (top.hasNext()) {
            N element = top.next();
            // requireNonNull is safe because horizon contains only graph nodes.
            /*
             * TODO(cpovirk): Replace these two statements with one (`N element =
             * requireNonNull(top.next())`) once our checker supports it.
             *
             * (The problem is likely
             * https://github.com/jspecify/nullness-checker-for-checker-framework/blob/61aafa4ae52594830cfc2d61c8b113009dbdb045/src/main/java/com/google/jspecify/nullness/NullSpecAnnotatedTypeFactory.java#L896)
             */
            requireNonNull(element);
            if (visited.add(element)) {
              return element;
            }
          }
          horizon.removeFirst();
          return null;
        }
      };
    }

    static &lt;N&gt; Traversal&lt;N&gt; inTree(SuccessorsFunction&lt;N&gt; tree) {
      return new Traversal&lt;N&gt;(tree) {
        @CheckForNull
        @Override
        N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
          Iterator&lt;? extends N&gt; top = horizon.getFirst();
          if (top.hasNext()) {
            return checkNotNull(top.next());
          }
          horizon.removeFirst();
          return null;
        }
      };
    }

    final Iterator&lt;N&gt; breadthFirst(Iterator&lt;? extends N&gt; startNodes) {
      return topDown(startNodes, InsertionOrder.BACK);
    }

    final Iterator&lt;N&gt; preOrder(Iterator&lt;? extends N&gt; startNodes) {
      return topDown(startNodes, InsertionOrder.FRONT);
    }

    /**
     * In top-down traversal, an ancestor node is always traversed before any of its descendant
     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are
     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before
     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.
     */
    private Iterator&lt;N&gt; topDown(Iterator&lt;? extends N&gt; startNodes, InsertionOrder order) {
      Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
      horizon.add(startNodes);
      return new AbstractIterator&lt;N&gt;() {
        @Override
        @CheckForNull
        protected N computeNext() {
          do {
            N next = visitNext(horizon);
            if (next != null) {
              Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
              if (successors.hasNext()) {
                // BFS: horizon.addLast(successors)
                // Pre-order: horizon.addFirst(successors)
                order.insertInto(horizon, successors);
              }
              return next;
            }
          } while (!horizon.isEmpty());
          return endOfData();
        }
      };
    }

    final Iterator&lt;N&gt; postOrder(Iterator&lt;? extends N&gt; startNodes) {
      Deque&lt;N&gt; ancestorStack = new ArrayDeque&lt;&gt;();
      Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
      horizon.add(startNodes);
      return new AbstractIterator&lt;N&gt;() {
        @Override
        @CheckForNull
        protected N computeNext() {
          for (N next = visitNext(horizon); next != null; next = visitNext(horizon)) {
            Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
            if (!successors.hasNext()) {
              return next;
            }
            horizon.addFirst(successors);
            ancestorStack.push(next);
          }
          // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
          if (!ancestorStack.isEmpty()) {
            return ancestorStack.pop();
          }
          return endOfData();
        }
      };
    }

    /**
     * Visits the next node from the top iterator of {@code horizon} and returns the visited node.
     * Null is returned to indicate reaching the end of the top iterator.
     *
     * &lt;p&gt;For example, if horizon is {@code [[a, b], [c, d], [e]]}, {@code visitNext()} will return
     * {@code [a, b, null, c, d, null, e, null]} sequentially, encoding the topological structure.
     * (Note, however, that the callers of {@code visitNext()} often insert additional iterators
     * into {@code horizon} between calls to {@code visitNext()}. This causes them to receive
     * additional values interleaved with those shown above.)
     */
    @CheckForNull
    abstract N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon);
  }

  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */
  private enum InsertionOrder {
    FRONT {
      @Override
      &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
        deque.addFirst(value);
      }
    },
    BACK {
      @Override
      &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
        deque.addLast(value);
      }
    };

    abstract &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClassSanityTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.testing;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.throwIfUnchecked;
import static com.google.common.testing.NullPointerTester.isNullable;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Objects;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.MutableClassToInstanceMap;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;
import com.google.common.primitives.Ints;
import com.google.common.reflect.Invokable;
import com.google.common.reflect.Parameter;
import com.google.common.reflect.Reflection;
<a name="0"></a>import com.google.common.reflect.TypeToken;
import com.google.common.testing.NullPointerTester.Visibility;
import com.google.common.testing.RelationshipTester.Item;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.testing.RelationshipTester.ItemReporter;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import junit.framework.Assert;
import junit.framework.AssertionFailedError;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Tester that runs automated sanity tests for any given class. A typical use case is to test static
 * factory classes like:
 *
 * &lt;pre&gt;
 * interface Book {...}
 * public class Books {
 *   public static Book hardcover(String title) {...}
 *   public static Book paperback(String title) {...}
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;And all the created {@code Book} instances can be tested with:
 *
 * &lt;pre&gt;
 * new ClassSanityTester()
 *     .forAllPublicStaticMethods(Books.class)
 *     .thatReturn(Book.class)
 *     .testEquals(); // or testNulls(), testSerializable() etc.
 * &lt;/pre&gt;
 *
 * @author Ben Yu
 * @since 14.0
 */
@Beta
@</b></font>GwtIncompatible
public final class ClassSanityTester {

  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_METHOD_NAME =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return left.getName().compareTo(right.getName());
        }
      };

  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_PARAMETERS =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return Ordering.usingToString().compare(left.getParameters(), right.getParameters());
        }
      };

  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_NUMBER_OF_PARAMETERS =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return Ints.compare(left.getParameters().size(), right.getParameters().size());
        }
      };

  private final MutableClassToInstanceMap&lt;Object&gt; defaultValues =
      MutableClassToInstanceMap.create();
  private final ListMultimap&lt;Class&lt;?&gt;, Object&gt; distinctValues = ArrayListMultimap.create();
  private final NullPointerTester nullPointerTester = new NullPointerTester();

  public ClassSanityTester() {
    // TODO(benyu): bake these into ArbitraryInstances.
    setDefault(byte.class, (byte) 1);
    setDefault(Byte.class, (byte) 1);
    setDefault(short.class, (short) 1);
    setDefault(Short.class, (short) 1);
    setDefault(int.class, 1);
    setDefault(Integer.class, 1);
    setDefault(long.class, 1L);
    setDefault(Long.class, 1L);
    setDefault(float.class, 1F);
    setDefault(Float.class, 1F);
    setDefault(double.class, 1D);
    setDefault(Double.class, 1D);
    setDefault(Class.class, Class.class);
  }

  /**
   * Sets the default value for {@code type}. The default value isn't used in testing {@link
   * Object#equals} because more than one sample instances are needed for testing inequality. To set
   * distinct values for equality testing, use {@link #setDistinctValues} instead.
   */
  public &lt;T&gt; ClassSanityTester setDefault(Class&lt;T&gt; type, T value) {
    nullPointerTester.setDefault(type, value);
    defaultValues.putInstance(type, value);
    return this;
  }

  /**
   * Sets distinct values for {@code type}, so that when a class {@code Foo} is tested for {@link
   * Object#equals} and {@link Object#hashCode}, and its construction requires a parameter of {@code
   * type}, the distinct values of {@code type} can be passed as parameters to create {@code Foo}
   * instances that are unequal.
   *
   * &lt;p&gt;Calling {@code setDistinctValues(type, v1, v2)} also sets the default value for {@code type}
   * that's used for {@link #testNulls}.
   *
   * &lt;p&gt;Only necessary for types where {@link ClassSanityTester} doesn't already know how to create
   * distinct values.
   *
   * @return this tester instance
   * @since 17.0
   */
  public &lt;T&gt; ClassSanityTester setDistinctValues(Class&lt;T&gt; type, T value1, T value2) {
    checkNotNull(type);
    checkNotNull(value1);
    checkNotNull(value2);
    checkArgument(!Objects.equal(value1, value2), "Duplicate value provided.");
    distinctValues.replaceValues(type, ImmutableList.of(value1, value2));
    setDefault(type, value1);
    return this;
  }

  /**
   * Tests that {@code cls} properly checks null on all constructor and method parameters that
   * aren't annotated nullable (according to the rules of {@link NullPointerTester}). In details:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;All non-private static methods are checked such that passing null for any parameter
   *       that's not annotated nullable should throw {@link NullPointerException}.
   *   &lt;li&gt;If there is any non-private constructor or non-private static factory method declared by
   *       {@code cls}, all non-private instance methods will be checked too using the instance
   *       created by invoking the constructor or static factory method.
   *   &lt;li&gt;If there is any non-private constructor or non-private static factory method declared by
   *       {@code cls}:
   *       &lt;ul&gt;
   *         &lt;li&gt;Test will fail if default value for a parameter cannot be determined.
   *         &lt;li&gt;Test will fail if the factory method returns null so testing instance methods is
   *             impossible.
   *         &lt;li&gt;Test will fail if the constructor or factory method throws exception.
   *       &lt;/ul&gt;
   *   &lt;li&gt;If there is no non-private constructor or non-private static factory method declared by
   *       {@code cls}, instance methods are skipped for nulls test.
   *   &lt;li&gt;Nulls test is not performed on method return values unless the method is a non-private
   *       static factory method whose return type is {@code cls} or {@code cls}'s subtype.
   * &lt;/ul&gt;
   */
  public void testNulls(Class&lt;?&gt; cls) {
    try {
      doTestNulls(cls, Visibility.PACKAGE);
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }

  void doTestNulls(Class&lt;?&gt; cls, Visibility visibility)
      throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
          FactoryMethodReturnsNullException {
    if (!Modifier.isAbstract(cls.getModifiers())) {
      nullPointerTester.testConstructors(cls, visibility);
    }
    nullPointerTester.testStaticMethods(cls, visibility);
    if (hasInstanceMethodToTestNulls(cls, visibility)) {
      Object instance = instantiate(cls);
      if (instance != null) {
        nullPointerTester.testInstanceMethods(instance, visibility);
      }
    }
  }

  private boolean hasInstanceMethodToTestNulls(Class&lt;?&gt; c, Visibility visibility) {
    for (Method method : nullPointerTester.getInstanceMethodsToTest(c, visibility)) {
      for (Parameter param : Invokable.from(method).getParameters()) {
        if (!NullPointerTester.isPrimitiveOrNullable(param)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Tests the {@link Object#equals} and {@link Object#hashCode} of {@code cls}. In details:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;The non-private constructor or non-private static factory method with the most parameters
   *       is used to construct the sample instances. In case of tie, the candidate constructors or
   *       factories are tried one after another until one can be used to construct sample
   *       instances.
   *   &lt;li&gt;For the constructor or static factory method used to construct instances, it's checked
   *       that when equal parameters are passed, the result instance should also be equal; and vice
   *       versa.
   *   &lt;li&gt;If a non-private constructor or non-private static factory method exists:
   *       &lt;ul&gt;
   *         &lt;li&gt;Test will fail if default value for a parameter cannot be determined.
   *         &lt;li&gt;Test will fail if the factory method returns null so testing instance methods is
   *             impossible.
   *         &lt;li&gt;Test will fail if the constructor or factory method throws exception.
   *       &lt;/ul&gt;
   *   &lt;li&gt;If there is no non-private constructor or non-private static factory method declared by
   *       {@code cls}, no test is performed.
   *   &lt;li&gt;Equality test is not performed on method return values unless the method is a non-private
   *       static factory method whose return type is {@code cls} or {@code cls}'s subtype.
   *   &lt;li&gt;Inequality check is not performed against state mutation methods such as {@link
   *       List#add}, or functional update methods such as {@link
   *       com.google.common.base.Joiner#skipNulls}.
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Note that constructors taking a builder object cannot be tested effectively because
   * semantics of builder can be arbitrarily complex. Still, a factory class can be created in the
   * test to facilitate equality testing. For example:
   *
   * &lt;pre&gt;
   * public class FooTest {
   *
   *   private static class FooFactoryForTest {
   *     public static Foo create(String a, String b, int c, boolean d) {
   *       return Foo.builder()
   *           .setA(a)
   *           .setB(b)
   *           .setC(c)
   *           .setD(d)
   *           .build();
   *     }
   *   }
   *
   *   public void testEquals() {
   *     new ClassSanityTester()
   *       .forAllPublicStaticMethods(FooFactoryForTest.class)
   *       .thatReturn(Foo.class)
   *       .testEquals();
   *   }
   * }
   * &lt;/pre&gt;
   *
   * &lt;p&gt;It will test that Foo objects created by the {@code create(a, b, c, d)} factory method with
   * equal parameters are equal and vice versa, thus indirectly tests the builder equality.
   */
  public void testEquals(Class&lt;?&gt; cls) {
    try {
      doTestEquals(cls);
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }

  void doTestEquals(Class&lt;?&gt; cls)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    if (cls.isEnum()) {
      return;
    }
    List&lt;? extends Invokable&lt;?, ?&gt;&gt; factories = Lists.reverse(getFactories(TypeToken.of(cls)));
    if (factories.isEmpty()) {
      return;
    }
    int numberOfParameters = factories.get(0).getParameters().size();
    List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
    List&lt;ParameterHasNoDistinctValueException&gt; distinctValueErrors = Lists.newArrayList();
    List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
    List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
    // Try factories with the greatest number of parameters.
    for (Invokable&lt;?, ?&gt; factory : factories) {
      if (factory.getParameters().size() == numberOfParameters) {
        try {
          testEqualsUsing(factory);
          return;
        } catch (ParameterNotInstantiableException e) {
          paramErrors.add(e);
        } catch (ParameterHasNoDistinctValueException e) {
          distinctValueErrors.add(e);
        } catch (InvocationTargetException e) {
          instantiationExceptions.add(e);
        } catch (FactoryMethodReturnsNullException e) {
          nullErrors.add(e);
        }
      }
    }
    throwFirst(paramErrors);
    throwFirst(distinctValueErrors);
    throwFirst(instantiationExceptions);
    throwFirst(nullErrors);
  }

  /**
   * Instantiates {@code cls} by invoking one of its non-private constructors or non-private static
   * factory methods with the parameters automatically provided using dummy values.
   *
   * @return The instantiated instance, or {@code null} if the class has no non-private constructor
   *     or factory method to be constructed.
   */
  &lt;T&gt; @Nullable T instantiate(Class&lt;T&gt; cls)
      throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
          FactoryMethodReturnsNullException {
    if (cls.isEnum()) {
      T[] constants = cls.getEnumConstants();
      if (constants.length &gt; 0) {
        return constants[0];
      } else {
        return null;
      }
    }
    TypeToken&lt;T&gt; type = TypeToken.of(cls);
    List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
    List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
    List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
    for (Invokable&lt;?, ? extends T&gt; factory : getFactories(type)) {
      T instance;
      try {
        instance = instantiate(factory);
      } catch (ParameterNotInstantiableException e) {
        paramErrors.add(e);
        continue;
      } catch (InvocationTargetException e) {
        instantiationExceptions.add(e);
        continue;
      }
      if (instance == null) {
        nullErrors.add(new FactoryMethodReturnsNullException(factory));
      } else {
        return instance;
      }
    }
    throwFirst(paramErrors);
    throwFirst(instantiationExceptions);
    throwFirst(nullErrors);
    return null;
  }

  /**
   * Instantiates using {@code factory}. If {@code factory} is annotated nullable and returns null,
   * null will be returned.
   *
   * @throws ParameterNotInstantiableException if the static methods cannot be invoked because the
   *     default value of a parameter cannot be determined.
   * @throws IllegalAccessException if the class isn't public or is nested inside a non-public
<a name="1"></a>   *     class, preventing its methods from being accessible.
   * @throws InvocationTargetException if a static method threw exception.
   */
  private &lt;T&gt; @Nullable T instantiate(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Invokable&lt;?, ? extends T&gt; factory)
      throws ParameterNotInstantiableException, InvocationTargetException, IllegalAccessException {
    return invoke(factory, getDummyArguments(factory));
  }

  /**
   * Returns an object responsible for performing sanity tests against the return values of all
   * public static methods declared by {@code cls}, excluding superclasses.
   */
  public FactoryMethodReturnValueTester forAllPublicStaticMethods(Class&lt;?&gt; cls) {
    ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder</b></font>();
    for (Method method : cls.getDeclaredMethods()) {
      Invokable&lt;?, ?&gt; invokable = Invokable.from(method);
      invokable.setAccessible(true);
      if (invokable.isPublic() &amp;&amp; invokable.isStatic() &amp;&amp; !invokable.isSynthetic()) {
        builder.add(invokable);
      }
    }
    return new FactoryMethodReturnValueTester(cls, builder.build(), "public static methods");
  }

  /** Runs sanity tests against return values of static factory methods declared by a class. */
  public final class FactoryMethodReturnValueTester {
    private final Set&lt;String&gt; packagesToTest = Sets.newHashSet();
    private final Class&lt;?&gt; declaringClass;
    private final ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories;
    private final String factoryMethodsDescription;
    private Class&lt;?&gt; returnTypeToTest = Object.class;

    private FactoryMethodReturnValueTester(
        Class&lt;?&gt; declaringClass,
        ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories,
        String factoryMethodsDescription) {
      this.declaringClass = declaringClass;
      this.factories = factories;
      this.factoryMethodsDescription = factoryMethodsDescription;
      packagesToTest.add(Reflection.getPackageName(declaringClass));
    }

    /**
     * Specifies that only the methods that are declared to return {@code returnType} or its subtype
     * are tested.
     *
     * @return this tester object
     */
    public FactoryMethodReturnValueTester thatReturn(Class&lt;?&gt; returnType) {
      this.returnTypeToTest = returnType;
      return this;
    }

    /**
     * Tests null checks against the instance methods of the return values, if any.
     *
     * &lt;p&gt;Test fails if default value cannot be determined for a constructor or factory method
     * parameter, or if the constructor or factory method throws exception.
     *
     * @return this tester
     */
    public FactoryMethodReturnValueTester testNulls() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        Object instance = instantiate(factory);
        if (instance != null
            &amp;&amp; packagesToTest.contains(Reflection.getPackageName(instance.getClass()))) {
          try {
            nullPointerTester.testAllPublicInstanceMethods(instance);
          } catch (AssertionError e) {
            AssertionError error =
                new AssertionFailedError("Null check failed on return value of " + factory);
            error.initCause(e);
            throw error;
          }
        }
      }
      return this;
    }

    /**
     * Tests {@link Object#equals} and {@link Object#hashCode} against the return values of the
     * static methods, by asserting that when equal parameters are passed to the same static method,
     * the return value should also be equal; and vice versa.
     *
     * &lt;p&gt;Test fails if default value cannot be determined for a constructor or factory method
     * parameter, or if the constructor or factory method throws exception.
     *
     * @return this tester
     */
    public FactoryMethodReturnValueTester testEquals() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        try {
          testEqualsUsing(factory);
        } catch (FactoryMethodReturnsNullException e) {
          // If the factory returns null, we just skip it.
        }
      }
      return this;
    }

    /**
     * Runs serialization test on the return values of the static methods.
     *
     * &lt;p&gt;Test fails if default value cannot be determined for a constructor or factory method
     * parameter, or if the constructor or factory method throws exception.
     *
     * @return this tester
     */
    public FactoryMethodReturnValueTester testSerializable() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        Object instance = instantiate(factory);
        if (instance != null) {
          try {
            SerializableTester.reserialize(instance);
          } catch (RuntimeException e) {
            AssertionError error =
                new AssertionFailedError("Serialization failed on return value of " + factory);
            error.initCause(e.getCause());
            throw error;
          }
        }
      }
      return this;
    }

    /**
     * Runs equals and serialization test on the return values.
     *
     * &lt;p&gt;Test fails if default value cannot be determined for a constructor or factory method
     * parameter, or if the constructor or factory method throws exception.
     *
     * @return this tester
     */
    public FactoryMethodReturnValueTester testEqualsAndSerializable() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        try {
          testEqualsUsing(factory);
        } catch (FactoryMethodReturnsNullException e) {
          // If the factory returns null, we just skip it.
        }
        Object instance = instantiate(factory);
        if (instance != null) {
          try {
            SerializableTester.reserializeAndAssert(instance);
          } catch (RuntimeException e) {
            AssertionError error =
                new AssertionFailedError("Serialization failed on return value of " + factory);
            error.initCause(e.getCause());
            throw error;
          } catch (AssertionFailedError e) {
            AssertionError error =
                new AssertionFailedError(
                    "Return value of " + factory + " reserialized to an unequal value");
            error.initCause(e);
            throw error;
          }
        }
      }
      return this;
    }

    private ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; getFactoriesToTest() {
      ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder();
      for (Invokable&lt;?, ?&gt; factory : factories) {
        if (returnTypeToTest.isAssignableFrom(factory.getReturnType().getRawType())) {
          builder.add(factory);
        }
      }
      ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factoriesToTest = builder.build();
      Assert.assertFalse(
          "No "
              + factoryMethodsDescription
              + " that return "
              + returnTypeToTest.getName()
              + " or subtype are found in "
              + declaringClass
              + ".",
          factoriesToTest.isEmpty());
      return factoriesToTest;
    }
  }

  private void testEqualsUsing(final Invokable&lt;?, ?&gt; factory)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    List&lt;Parameter&gt; params = factory.getParameters();
    List&lt;FreshValueGenerator&gt; argGenerators = Lists.newArrayListWithCapacity(params.size());
    List&lt;Object&gt; args = Lists.newArrayListWithCapacity(params.size());
    for (Parameter param : params) {
      FreshValueGenerator generator = newFreshValueGenerator();
      argGenerators.add(generator);
      args.add(generateDummyArg(param, generator));
    }
    Object instance = createInstance(factory, args);
    List&lt;Object&gt; equalArgs = generateEqualFactoryArguments(factory, params, args);
    // Each group is a List of items, each item has a list of factory args.
    final List&lt;List&lt;List&lt;Object&gt;&gt;&gt; argGroups = Lists.newArrayList();
    argGroups.add(ImmutableList.of(args, equalArgs));
    EqualsTester tester =
        new EqualsTester(
            new ItemReporter() {
              @Override
              String reportItem(Item&lt;?&gt; item) {
                List&lt;Object&gt; factoryArgs = argGroups.get(item.groupNumber).get(item.itemNumber);
                return factory.getName()
                    + "("
                    + Joiner.on(", ").useForNull("null").join(factoryArgs)
                    + ")";
              }
            });
    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
    for (int i = 0; i &lt; params.size(); i++) {
      List&lt;Object&gt; newArgs = Lists.newArrayList(args);
      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());

      if (newArg == null || Objects.equal(args.get(i), newArg)) {
        if (params.get(i).getType().getRawType().isEnum()) {
          continue; // Nothing better we can do if it's single-value enum
        }
        throw new ParameterHasNoDistinctValueException(params.get(i));
      }
      newArgs.set(i, newArg);
      tester.addEqualityGroup(createInstance(factory, newArgs));
      argGroups.add(ImmutableList.of(newArgs));
    }
    tester.testEquals();
  }

  /**
   * Returns dummy factory arguments that are equal to {@code args} but may be different instances,
   * to be used to construct a second instance of the same equality group.
   */
  private List&lt;Object&gt; generateEqualFactoryArguments(
      Invokable&lt;?, ?&gt; factory, List&lt;Parameter&gt; params, List&lt;Object&gt; args)
      throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,
          InvocationTargetException, IllegalAccessException {
    List&lt;Object&gt; equalArgs = Lists.newArrayList(args);
    for (int i = 0; i &lt; args.size(); i++) {
      Parameter param = params.get(i);
      Object arg = args.get(i);
      // Use new fresh value generator because 'args' were populated with new fresh generator each.
      // Two newFreshValueGenerator() instances should normally generate equal value sequence.
      Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());
      if (arg != shouldBeEqualArg
          &amp;&amp; Objects.equal(arg, shouldBeEqualArg)
          &amp;&amp; hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg)
          &amp;&amp; hashCodeInsensitiveToArgReference(
              factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {
        // If the implementation uses identityHashCode(), referential equality is
        // probably intended. So no point in using an equal-but-different factory argument.
        // We check twice to avoid confusion caused by accidental hash collision.
        equalArgs.set(i, shouldBeEqualArg);
      }
    }
    return equalArgs;
  }

  private static boolean hashCodeInsensitiveToArgReference(
      Invokable&lt;?, ?&gt; factory, List&lt;Object&gt; args, int i, Object alternateArg)
      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
    List&lt;Object&gt; tentativeArgs = Lists.newArrayList(args);
    tentativeArgs.set(i, alternateArg);
    return createInstance(factory, tentativeArgs).hashCode()
        == createInstance(factory, args).hashCode();
  }

  // distinctValues is a type-safe class-values mapping, but we don't have a type-safe data
  // structure to hold the mappings.
  @SuppressWarnings({"unchecked", "rawtypes"})
  private FreshValueGenerator newFreshValueGenerator() {
    FreshValueGenerator generator =
        new FreshValueGenerator() {
          @Override
          Object interfaceMethodCalled(Class&lt;?&gt; interfaceType, Method method) {
            return getDummyValue(TypeToken.of(interfaceType).method(method).getReturnType());
          }
        };
    for (Entry&lt;Class&lt;?&gt;, Collection&lt;Object&gt;&gt; entry : distinctValues.asMap().entrySet()) {
      generator.addSampleInstances((Class) entry.getKey(), entry.getValue());
    }
    return generator;
  }

  private static @Nullable Object generateDummyArg(Parameter param, FreshValueGenerator generator)
      throws ParameterNotInstantiableException {
    if (isNullable(param)) {
      return null;
    }
    Object arg = generator.generateFresh(param.getType());
    if (arg == null) {
      throw new ParameterNotInstantiableException(param);
    }
    return arg;
  }

  private static &lt;X extends Throwable&gt; void throwFirst(List&lt;X&gt; exceptions) throws X {
    if (!exceptions.isEmpty()) {
      throw exceptions.get(0);
    }
  }

  /** Factories with the least number of parameters are listed first. */
  private static &lt;T&gt; ImmutableList&lt;Invokable&lt;?, ? extends T&gt;&gt; getFactories(TypeToken&lt;T&gt; type) {
    List&lt;Invokable&lt;?, ? extends T&gt;&gt; factories = Lists.newArrayList();
    for (Method method : type.getRawType().getDeclaredMethods()) {
      Invokable&lt;?, ?&gt; invokable = type.method(method);
      if (!invokable.isPrivate()
          &amp;&amp; !invokable.isSynthetic()
          &amp;&amp; invokable.isStatic()
          &amp;&amp; type.isSupertypeOf(invokable.getReturnType())) {
        @SuppressWarnings("unchecked") // guarded by isAssignableFrom()
        Invokable&lt;?, ? extends T&gt; factory = (Invokable&lt;?, ? extends T&gt;) invokable;
        factories.add(factory);
      }
    }
    if (!Modifier.isAbstract(type.getRawType().getModifiers())) {
      for (Constructor&lt;?&gt; constructor : type.getRawType().getDeclaredConstructors()) {
        Invokable&lt;T, T&gt; invokable = type.constructor(constructor);
        if (!invokable.isPrivate() &amp;&amp; !invokable.isSynthetic()) {
          factories.add(invokable);
        }
      }
    }
    for (Invokable&lt;?, ?&gt; factory : factories) {
      factory.setAccessible(true);
    }
<a name="2"></a>    // Sorts methods/constructors with least number of parameters first since it's likely easier to
    // fill dummy parameter values for them. Ties are broken by name then by the string form of the
    // parameter list.
    return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BY_NUMBER_OF_PARAMETERS
        .compound(BY_METHOD_NAME)
        .compound(BY_PARAMETERS)
        .immutableSortedCopy(factories);
  }

  private List&lt;Object&gt; getDummyArguments(Invokable&lt;?, ?&gt; invokable)
      throws ParameterNotInstantiableException {
    List&lt;Object&gt; args = Lists.newArrayList</b></font>();
    for (Parameter param : invokable.getParameters()) {
      if (isNullable(param)) {
        args.add(null);
        continue;
      }
      Object defaultValue = getDummyValue(param.getType());
      if (defaultValue == null) {
        throw new ParameterNotInstantiableException(param);
      }
      args.add(defaultValue);
    }
    return args;
  }

  private &lt;T&gt; T getDummyValue(TypeToken&lt;T&gt; type) {
    Class&lt;? super T&gt; rawType = type.getRawType();
    @SuppressWarnings("unchecked") // Assume all default values are generics safe.
    T defaultValue = (T) defaultValues.getInstance(rawType);
    if (defaultValue != null) {
      return defaultValue;
    }
    @SuppressWarnings("unchecked") // ArbitraryInstances always returns generics-safe dummies.
    T value = (T) ArbitraryInstances.get(rawType);
    if (value != null) {
      return value;
    }
    if (rawType.isInterface()) {
      return new SerializableDummyProxy(this).newProxy(type);
    }
    return null;
  }

  private static &lt;T&gt; T createInstance(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
    T instance = invoke(factory, args);
    if (instance == null) {
      throw new FactoryMethodReturnsNullException(factory);
    }
    return instance;
  }

  private static &lt;T&gt; @Nullable T invoke(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
      throws InvocationTargetException, IllegalAccessException {
    T returnValue = factory.invoke(null, args.toArray());
    if (returnValue == null) {
      Assert.assertTrue(
          factory + " returns null but it's not annotated with @Nullable", isNullable(factory));
    }
    return returnValue;
  }

  /**
   * Thrown if the test tries to invoke a constructor or static factory method but failed because
   * the dummy value of a constructor or method parameter is unknown.
   */
  @VisibleForTesting
  static class ParameterNotInstantiableException extends Exception {
    public ParameterNotInstantiableException(Parameter parameter) {
      super(
          "Cannot determine value for parameter "
              + parameter
              + " of "
              + parameter.getDeclaringInvokable());
    }
  }

  /**
   * Thrown if the test fails to generate two distinct non-null values of a constructor or factory
   * parameter in order to test {@link Object#equals} and {@link Object#hashCode} of the declaring
   * class.
   */
  @VisibleForTesting
  static class ParameterHasNoDistinctValueException extends Exception {
    ParameterHasNoDistinctValueException(Parameter parameter) {
      super(
          "Cannot generate distinct value for parameter "
              + parameter
              + " of "
              + parameter.getDeclaringInvokable());
    }
  }

  /**
   * Thrown if the test tries to invoke a static factory method to test instance methods but the
   * factory returned null.
   */
  @VisibleForTesting
  static class FactoryMethodReturnsNullException extends Exception {
    public FactoryMethodReturnsNullException(Invokable&lt;?, ?&gt; factory) {
      super(factory + " returns null and cannot be used to test instance methods.");
    }
  }

  private static final class SerializableDummyProxy extends DummyProxy implements Serializable {

    private final transient ClassSanityTester tester;

    SerializableDummyProxy(ClassSanityTester tester) {
      this.tester = tester;
    }

    @Override
    &lt;R&gt; R dummyReturnValue(TypeToken&lt;R&gt; returnType) {
      return tester.getDummyValue(returnType);
    }

    @Override
    public boolean equals(Object obj) {
      return obj instanceof SerializableDummyProxy;
    }

    @Override
    public int hashCode() {
      return 0;
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
