<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Traverser.java &amp; ClassSanityTester.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Traverser.java &amp; ClassSanityTester.java
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Traverser.java (9.438775%)<th>ClassSanityTester.java (3.6132812%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-64)<td><a href="#" name="0">(43-82)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(227-242)<td><a href="#" name="1">(385-395)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(283-297)<td><a href="#" name="2">(711-719)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Traverser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.graph;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static java.util.Objects.requireNonNull;
import com.google.common.annotations.Beta;
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.ImmutableSet;
import com.google.errorprone.annotations.DoNotMock;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.annotation.CheckForNull;
@Beta
@</b></font>DoNotMock(
    "Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with"
        + " GraphBuilder)")
@ElementTypesAreNonnullByDefault
public abstract class Traverser&lt;N&gt; {
  private final SuccessorsFunction&lt;N&gt; successorFunction;
  private Traverser(SuccessorsFunction&lt;N&gt; successorFunction) {
    this.successorFunction = checkNotNull(successorFunction);
  }
  public static &lt;N&gt; Traverser&lt;N&gt; forGraph(SuccessorsFunction&lt;N&gt; graph) {
    return new Traverser&lt;N&gt;(graph) {
      @Override
      Traversal&lt;N&gt; newTraversal() {
        return Traversal.inGraph(graph);
      }
    };
  }
  public static &lt;N&gt; Traverser&lt;N&gt; forTree(SuccessorsFunction&lt;N&gt; tree) {
    if (tree instanceof BaseGraph) {
      checkArgument(((BaseGraph&lt;?&gt;) tree).isDirected(), "Undirected graphs can never be trees.");
    }
    if (tree instanceof Network) {
      checkArgument(((Network&lt;?, ?&gt;) tree).isDirected(), "Undirected networks can never be trees.");
    }
    return new Traverser&lt;N&gt;(tree) {
      @Override
      Traversal&lt;N&gt; newTraversal() {
        return Traversal.inTree(tree);
      }
    };
  }
  public final Iterable&lt;N&gt; breadthFirst(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>N startNode) {
    return breadthFirst(ImmutableSet.of(startNode));
  }
  public final Iterable&lt;N&gt; breadthFirst(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().breadthFirst(validated.iterator());
      }
    };
  }
  public final Iterable&lt;N&gt; depthFirstPreOrder(N startNode) {
    return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>depthFirstPreOrder(ImmutableSet.of(startNode));
  }
  public final Iterable&lt;N&gt; depthFirstPreOrder(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate</b></font>(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().preOrder(validated.iterator());
      }
    };
  }
  public final Iterable&lt;N&gt; depthFirstPostOrder(N startNode) {
    return depthFirstPostOrder(ImmutableSet.of(startNode));
  }
  public final Iterable&lt;N&gt; depthFirstPostOrder(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; validated = validate(startNodes);
    return new Iterable&lt;N&gt;() {
      @Override
      public Iterator&lt;N&gt; iterator() {
        return newTraversal().postOrder(validated.iterator());
      }
    };
  }
  abstract Traversal&lt;N&gt; newTraversal();
  @SuppressWarnings("CheckReturnValue")
  private ImmutableSet&lt;N&gt; validate(Iterable&lt;? extends N&gt; startNodes) {
    ImmutableSet&lt;N&gt; copy = ImmutableSet.copyOf(startNodes);
    for (N node : copy) {
      successorFunction.successors(node);     }
    return copy;
  }
  private abstract static class Traversal&lt;N&gt; {
    final SuccessorsFunction&lt;N&gt; successorFunction;
    Traversal(SuccessorsFunction&lt;N&gt; successorFunction) {
      this.successorFunction = successorFunction;
    }
    static &lt;N&gt; Traversal&lt;N&gt; inGraph(SuccessorsFunction&lt;N&gt; graph) {
      Set&lt;N&gt; visited = new HashSet&lt;&gt;();
      return new Traversal&lt;N&gt;(graph) {
        @Override
        @CheckForNull
        N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
          Iterator&lt;? extends N&gt; top = horizon.getFirst();
          while (top.hasNext()) {
            N element = top.next();
            requireNonNull(element);
            if (visited.add(element)) {
              return element;
            }
          }
          horizon.removeFirst();
          return null;
        }
      };
    }
    static &lt;N&gt; Traversal&lt;N&gt; inTree(SuccessorsFunction&lt;N&gt; tree) {
      return new Traversal&lt;N&gt;(tree) {
        @CheckForNull
        @Override
        N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon) {
          Iterator&lt;? extends N&gt; top = horizon.getFirst();
          if (top.hasNext()) {
            return checkNotNull(top.next());
          }
          horizon.removeFirst();
          return null;
        }
      };
    }
    final Iterator&lt;N&gt; breadthFirst(Iterator&lt;? extends N&gt; startNodes) {
      return topDown(startNodes, InsertionOrder.BACK);
    }
    final Iterator&lt;N&gt; preOrder(Iterator&lt;? extends N&gt; startNodes) {
      return topDown(startNodes, InsertionOrder.FRONT);
    }
    private Iterator&lt;N&gt; topDown(Iterator&lt;? extends N&gt; startNodes, InsertionOrder order) {
      Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
      horizon.add(startNodes);
      return new AbstractIterator&lt;N&gt;() {
        @Override
        @CheckForNull
        protected N computeNext() {
          do {
            N next = visitNext(horizon);
            if (next != null) {
              Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
              if (successors.hasNext()) {
                order.insertInto(horizon, successors);
              }
              return next;
            }
          } while (!horizon.isEmpty());
          return endOfData();
        }
      };
    }
    final Iterator&lt;N&gt; postOrder(Iterator&lt;? extends N&gt; startNodes) {
      Deque&lt;N&gt; ancestorStack = new ArrayDeque&lt;&gt;();
      Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon = new ArrayDeque&lt;&gt;();
      horizon.add(startNodes);
      return new AbstractIterator&lt;N&gt;() {
        @Override
        @CheckForNull
        protected N computeNext() {
          for (N next = visitNext(horizon); next != null; next = visitNext(horizon)) {
            Iterator&lt;? extends N&gt; successors = successorFunction.successors(next).iterator();
            if (!successors.hasNext()) {
              return next;
            }
            horizon.addFirst(successors);
            ancestorStack.push(next);
          }
          if (!ancestorStack.isEmpty()) {
            return ancestorStack.pop();
          }
          return endOfData();
        }
      };
    }
    @CheckForNull
    abstract N visitNext(Deque&lt;Iterator&lt;? extends N&gt;&gt; horizon);
  }
  private enum InsertionOrder {
    FRONT {
      @Override
      &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
        deque.addFirst(value);
      }
    },
    BACK {
      @Override
      &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value) {
        deque.addLast(value);
      }
    };
    abstract &lt;T&gt; void insertInto(Deque&lt;T&gt; deque, T value);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClassSanityTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.testing;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.throwIfUnchecked;
import static com.google.common.testing.NullPointerTester.isNullable;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Objects;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.MutableClassToInstanceMap;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;
import com.google.common.primitives.Ints;
import com.google.common.reflect.Invokable;
import com.google.common.reflect.Parameter;
import com.google.common.reflect.Reflection;
<a name="0"></a>import com.google.common.reflect.TypeToken;
import com.google.common.testing.NullPointerTester.Visibility;
import com.google.common.testing.RelationshipTester.Item;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.testing.RelationshipTester.ItemReporter;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import junit.framework.Assert;
import junit.framework.AssertionFailedError;
import org.checkerframework.checker.nullness.qual.Nullable;
@Beta
@</b></font>GwtIncompatible
public final class ClassSanityTester {
  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_METHOD_NAME =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return left.getName().compareTo(right.getName());
        }
      };
  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_PARAMETERS =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return Ordering.usingToString().compare(left.getParameters(), right.getParameters());
        }
      };
  private static final Ordering&lt;Invokable&lt;?, ?&gt;&gt; BY_NUMBER_OF_PARAMETERS =
      new Ordering&lt;Invokable&lt;?, ?&gt;&gt;() {
        @Override
        public int compare(Invokable&lt;?, ?&gt; left, Invokable&lt;?, ?&gt; right) {
          return Ints.compare(left.getParameters().size(), right.getParameters().size());
        }
      };
  private final MutableClassToInstanceMap&lt;Object&gt; defaultValues =
      MutableClassToInstanceMap.create();
  private final ListMultimap&lt;Class&lt;?&gt;, Object&gt; distinctValues = ArrayListMultimap.create();
  private final NullPointerTester nullPointerTester = new NullPointerTester();
  public ClassSanityTester() {
    setDefault(byte.class, (byte) 1);
    setDefault(Byte.class, (byte) 1);
    setDefault(short.class, (short) 1);
    setDefault(Short.class, (short) 1);
    setDefault(int.class, 1);
    setDefault(Integer.class, 1);
    setDefault(long.class, 1L);
    setDefault(Long.class, 1L);
    setDefault(float.class, 1F);
    setDefault(Float.class, 1F);
    setDefault(double.class, 1D);
    setDefault(Double.class, 1D);
    setDefault(Class.class, Class.class);
  }
  public &lt;T&gt; ClassSanityTester setDefault(Class&lt;T&gt; type, T value) {
    nullPointerTester.setDefault(type, value);
    defaultValues.putInstance(type, value);
    return this;
  }
  public &lt;T&gt; ClassSanityTester setDistinctValues(Class&lt;T&gt; type, T value1, T value2) {
    checkNotNull(type);
    checkNotNull(value1);
    checkNotNull(value2);
    checkArgument(!Objects.equal(value1, value2), "Duplicate value provided.");
    distinctValues.replaceValues(type, ImmutableList.of(value1, value2));
    setDefault(type, value1);
    return this;
  }
  public void testNulls(Class&lt;?&gt; cls) {
    try {
      doTestNulls(cls, Visibility.PACKAGE);
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }
  void doTestNulls(Class&lt;?&gt; cls, Visibility visibility)
      throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
          FactoryMethodReturnsNullException {
    if (!Modifier.isAbstract(cls.getModifiers())) {
      nullPointerTester.testConstructors(cls, visibility);
    }
    nullPointerTester.testStaticMethods(cls, visibility);
    if (hasInstanceMethodToTestNulls(cls, visibility)) {
      Object instance = instantiate(cls);
      if (instance != null) {
        nullPointerTester.testInstanceMethods(instance, visibility);
      }
    }
  }
  private boolean hasInstanceMethodToTestNulls(Class&lt;?&gt; c, Visibility visibility) {
    for (Method method : nullPointerTester.getInstanceMethodsToTest(c, visibility)) {
      for (Parameter param : Invokable.from(method).getParameters()) {
        if (!NullPointerTester.isPrimitiveOrNullable(param)) {
          return true;
        }
      }
    }
    return false;
  }
  public void testEquals(Class&lt;?&gt; cls) {
    try {
      doTestEquals(cls);
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }
  void doTestEquals(Class&lt;?&gt; cls)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    if (cls.isEnum()) {
      return;
    }
    List&lt;? extends Invokable&lt;?, ?&gt;&gt; factories = Lists.reverse(getFactories(TypeToken.of(cls)));
    if (factories.isEmpty()) {
      return;
    }
    int numberOfParameters = factories.get(0).getParameters().size();
    List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
    List&lt;ParameterHasNoDistinctValueException&gt; distinctValueErrors = Lists.newArrayList();
    List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
    List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
    for (Invokable&lt;?, ?&gt; factory : factories) {
      if (factory.getParameters().size() == numberOfParameters) {
        try {
          testEqualsUsing(factory);
          return;
        } catch (ParameterNotInstantiableException e) {
          paramErrors.add(e);
        } catch (ParameterHasNoDistinctValueException e) {
          distinctValueErrors.add(e);
        } catch (InvocationTargetException e) {
          instantiationExceptions.add(e);
        } catch (FactoryMethodReturnsNullException e) {
          nullErrors.add(e);
        }
      }
    }
    throwFirst(paramErrors);
    throwFirst(distinctValueErrors);
    throwFirst(instantiationExceptions);
    throwFirst(nullErrors);
  }
  &lt;T&gt; @Nullable T instantiate(Class&lt;T&gt; cls)
      throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,
          FactoryMethodReturnsNullException {
    if (cls.isEnum()) {
      T[] constants = cls.getEnumConstants();
      if (constants.length &gt; 0) {
        return constants[0];
      } else {
        return null;
      }
    }
    TypeToken&lt;T&gt; type = TypeToken.of(cls);
    List&lt;ParameterNotInstantiableException&gt; paramErrors = Lists.newArrayList();
    List&lt;InvocationTargetException&gt; instantiationExceptions = Lists.newArrayList();
    List&lt;FactoryMethodReturnsNullException&gt; nullErrors = Lists.newArrayList();
    for (Invokable&lt;?, ? extends T&gt; factory : getFactories(type)) {
      T instance;
      try {
        instance = instantiate(factory);
      } catch (ParameterNotInstantiableException e) {
        paramErrors.add(e);
        continue;
      } catch (InvocationTargetException e) {
        instantiationExceptions.add(e);
        continue;
      }
      if (instance == null) {
        nullErrors.add(new FactoryMethodReturnsNullException(factory));
      } else {
        return instance;
      }
    }
    throwFirst(paramErrors);
    throwFirst(instantiationExceptions);
    throwFirst(nullErrors);
    return null;
  }
  private &lt;T&gt; @Nullable T instantiate(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Invokable&lt;?, ? extends T&gt; factory)
      throws ParameterNotInstantiableException, InvocationTargetException, IllegalAccessException {
    return invoke(factory, getDummyArguments(factory));
  }
  public FactoryMethodReturnValueTester forAllPublicStaticMethods(Class&lt;?&gt; cls) {
    ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder</b></font>();
    for (Method method : cls.getDeclaredMethods()) {
      Invokable&lt;?, ?&gt; invokable = Invokable.from(method);
      invokable.setAccessible(true);
      if (invokable.isPublic() &amp;&amp; invokable.isStatic() &amp;&amp; !invokable.isSynthetic()) {
        builder.add(invokable);
      }
    }
    return new FactoryMethodReturnValueTester(cls, builder.build(), "public static methods");
  }
  public final class FactoryMethodReturnValueTester {
    private final Set&lt;String&gt; packagesToTest = Sets.newHashSet();
    private final Class&lt;?&gt; declaringClass;
    private final ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories;
    private final String factoryMethodsDescription;
    private Class&lt;?&gt; returnTypeToTest = Object.class;
    private FactoryMethodReturnValueTester(
        Class&lt;?&gt; declaringClass,
        ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factories,
        String factoryMethodsDescription) {
      this.declaringClass = declaringClass;
      this.factories = factories;
      this.factoryMethodsDescription = factoryMethodsDescription;
      packagesToTest.add(Reflection.getPackageName(declaringClass));
    }
    public FactoryMethodReturnValueTester thatReturn(Class&lt;?&gt; returnType) {
      this.returnTypeToTest = returnType;
      return this;
    }
    public FactoryMethodReturnValueTester testNulls() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        Object instance = instantiate(factory);
        if (instance != null
            &amp;&amp; packagesToTest.contains(Reflection.getPackageName(instance.getClass()))) {
          try {
            nullPointerTester.testAllPublicInstanceMethods(instance);
          } catch (AssertionError e) {
            AssertionError error =
                new AssertionFailedError("Null check failed on return value of " + factory);
            error.initCause(e);
            throw error;
          }
        }
      }
      return this;
    }
    public FactoryMethodReturnValueTester testEquals() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        try {
          testEqualsUsing(factory);
        } catch (FactoryMethodReturnsNullException e) {
        }
      }
      return this;
    }
    public FactoryMethodReturnValueTester testSerializable() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        Object instance = instantiate(factory);
        if (instance != null) {
          try {
            SerializableTester.reserialize(instance);
          } catch (RuntimeException e) {
            AssertionError error =
                new AssertionFailedError("Serialization failed on return value of " + factory);
            error.initCause(e.getCause());
            throw error;
          }
        }
      }
      return this;
    }
    public FactoryMethodReturnValueTester testEqualsAndSerializable() throws Exception {
      for (Invokable&lt;?, ?&gt; factory : getFactoriesToTest()) {
        try {
          testEqualsUsing(factory);
        } catch (FactoryMethodReturnsNullException e) {
        }
        Object instance = instantiate(factory);
        if (instance != null) {
          try {
            SerializableTester.reserializeAndAssert(instance);
          } catch (RuntimeException e) {
            AssertionError error =
                new AssertionFailedError("Serialization failed on return value of " + factory);
            error.initCause(e.getCause());
            throw error;
          } catch (AssertionFailedError e) {
            AssertionError error =
                new AssertionFailedError(
                    "Return value of " + factory + " reserialized to an unequal value");
            error.initCause(e);
            throw error;
          }
        }
      }
      return this;
    }
    private ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; getFactoriesToTest() {
      ImmutableList.Builder&lt;Invokable&lt;?, ?&gt;&gt; builder = ImmutableList.builder();
      for (Invokable&lt;?, ?&gt; factory : factories) {
        if (returnTypeToTest.isAssignableFrom(factory.getReturnType().getRawType())) {
          builder.add(factory);
        }
      }
      ImmutableList&lt;Invokable&lt;?, ?&gt;&gt; factoriesToTest = builder.build();
      Assert.assertFalse(
          "No "
              + factoryMethodsDescription
              + " that return "
              + returnTypeToTest.getName()
              + " or subtype are found in "
              + declaringClass
              + ".",
          factoriesToTest.isEmpty());
      return factoriesToTest;
    }
  }
  private void testEqualsUsing(final Invokable&lt;?, ?&gt; factory)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    List&lt;Parameter&gt; params = factory.getParameters();
    List&lt;FreshValueGenerator&gt; argGenerators = Lists.newArrayListWithCapacity(params.size());
    List&lt;Object&gt; args = Lists.newArrayListWithCapacity(params.size());
    for (Parameter param : params) {
      FreshValueGenerator generator = newFreshValueGenerator();
      argGenerators.add(generator);
      args.add(generateDummyArg(param, generator));
    }
    Object instance = createInstance(factory, args);
    List&lt;Object&gt; equalArgs = generateEqualFactoryArguments(factory, params, args);
    final List&lt;List&lt;List&lt;Object&gt;&gt;&gt; argGroups = Lists.newArrayList();
    argGroups.add(ImmutableList.of(args, equalArgs));
    EqualsTester tester =
        new EqualsTester(
            new ItemReporter() {
              @Override
              String reportItem(Item&lt;?&gt; item) {
                List&lt;Object&gt; factoryArgs = argGroups.get(item.groupNumber).get(item.itemNumber);
                return factory.getName()
                    + "("
                    + Joiner.on(", ").useForNull("null").join(factoryArgs)
                    + ")";
              }
            });
    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
    for (int i = 0; i &lt; params.size(); i++) {
      List&lt;Object&gt; newArgs = Lists.newArrayList(args);
      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());
      if (newArg == null || Objects.equal(args.get(i), newArg)) {
        if (params.get(i).getType().getRawType().isEnum()) {
          continue;         }
        throw new ParameterHasNoDistinctValueException(params.get(i));
      }
      newArgs.set(i, newArg);
      tester.addEqualityGroup(createInstance(factory, newArgs));
      argGroups.add(ImmutableList.of(newArgs));
    }
    tester.testEquals();
  }
  private List&lt;Object&gt; generateEqualFactoryArguments(
      Invokable&lt;?, ?&gt; factory, List&lt;Parameter&gt; params, List&lt;Object&gt; args)
      throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,
          InvocationTargetException, IllegalAccessException {
    List&lt;Object&gt; equalArgs = Lists.newArrayList(args);
    for (int i = 0; i &lt; args.size(); i++) {
      Parameter param = params.get(i);
      Object arg = args.get(i);
      Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());
      if (arg != shouldBeEqualArg
          &amp;&amp; Objects.equal(arg, shouldBeEqualArg)
          &amp;&amp; hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg)
          &amp;&amp; hashCodeInsensitiveToArgReference(
              factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {
        equalArgs.set(i, shouldBeEqualArg);
      }
    }
    return equalArgs;
  }
  private static boolean hashCodeInsensitiveToArgReference(
      Invokable&lt;?, ?&gt; factory, List&lt;Object&gt; args, int i, Object alternateArg)
      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
    List&lt;Object&gt; tentativeArgs = Lists.newArrayList(args);
    tentativeArgs.set(i, alternateArg);
    return createInstance(factory, tentativeArgs).hashCode()
        == createInstance(factory, args).hashCode();
  }
  @SuppressWarnings({"unchecked", "rawtypes"})
  private FreshValueGenerator newFreshValueGenerator() {
    FreshValueGenerator generator =
        new FreshValueGenerator() {
          @Override
          Object interfaceMethodCalled(Class&lt;?&gt; interfaceType, Method method) {
            return getDummyValue(TypeToken.of(interfaceType).method(method).getReturnType());
          }
        };
    for (Entry&lt;Class&lt;?&gt;, Collection&lt;Object&gt;&gt; entry : distinctValues.asMap().entrySet()) {
      generator.addSampleInstances((Class) entry.getKey(), entry.getValue());
    }
    return generator;
  }
  private static @Nullable Object generateDummyArg(Parameter param, FreshValueGenerator generator)
      throws ParameterNotInstantiableException {
    if (isNullable(param)) {
      return null;
    }
    Object arg = generator.generateFresh(param.getType());
    if (arg == null) {
      throw new ParameterNotInstantiableException(param);
    }
    return arg;
  }
  private static &lt;X extends Throwable&gt; void throwFirst(List&lt;X&gt; exceptions) throws X {
    if (!exceptions.isEmpty()) {
      throw exceptions.get(0);
    }
  }
  private static &lt;T&gt; ImmutableList&lt;Invokable&lt;?, ? extends T&gt;&gt; getFactories(TypeToken&lt;T&gt; type) {
    List&lt;Invokable&lt;?, ? extends T&gt;&gt; factories = Lists.newArrayList();
    for (Method method : type.getRawType().getDeclaredMethods()) {
      Invokable&lt;?, ?&gt; invokable = type.method(method);
      if (!invokable.isPrivate()
          &amp;&amp; !invokable.isSynthetic()
          &amp;&amp; invokable.isStatic()
          &amp;&amp; type.isSupertypeOf(invokable.getReturnType())) {
        @SuppressWarnings("unchecked")         Invokable&lt;?, ? extends T&gt; factory = (Invokable&lt;?, ? extends T&gt;) invokable;
        factories.add(factory);
      }
    }
    if (!Modifier.isAbstract(type.getRawType().getModifiers())) {
      for (Constructor&lt;?&gt; constructor : type.getRawType().getDeclaredConstructors()) {
        Invokable&lt;T, T&gt; invokable = type.constructor(constructor);
        if (!invokable.isPrivate() &amp;&amp; !invokable.isSynthetic()) {
          factories.add(invokable);
        }
      }
    }
    for (Invokable&lt;?, ?&gt; factory : factories) {
      factory.setAccessible(true);
    }
<a name="2"></a>        return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BY_NUMBER_OF_PARAMETERS
        .compound(BY_METHOD_NAME)
        .compound(BY_PARAMETERS)
        .immutableSortedCopy(factories);
  }
  private List&lt;Object&gt; getDummyArguments(Invokable&lt;?, ?&gt; invokable)
      throws ParameterNotInstantiableException {
    List&lt;Object&gt; args = Lists.newArrayList</b></font>();
    for (Parameter param : invokable.getParameters()) {
      if (isNullable(param)) {
        args.add(null);
        continue;
      }
      Object defaultValue = getDummyValue(param.getType());
      if (defaultValue == null) {
        throw new ParameterNotInstantiableException(param);
      }
      args.add(defaultValue);
    }
    return args;
  }
  private &lt;T&gt; T getDummyValue(TypeToken&lt;T&gt; type) {
    Class&lt;? super T&gt; rawType = type.getRawType();
    @SuppressWarnings("unchecked")     T defaultValue = (T) defaultValues.getInstance(rawType);
    if (defaultValue != null) {
      return defaultValue;
    }
    @SuppressWarnings("unchecked")     T value = (T) ArbitraryInstances.get(rawType);
    if (value != null) {
      return value;
    }
    if (rawType.isInterface()) {
      return new SerializableDummyProxy(this).newProxy(type);
    }
    return null;
  }
  private static &lt;T&gt; T createInstance(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
      throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
    T instance = invoke(factory, args);
    if (instance == null) {
      throw new FactoryMethodReturnsNullException(factory);
    }
    return instance;
  }
  private static &lt;T&gt; @Nullable T invoke(Invokable&lt;?, ? extends T&gt; factory, List&lt;?&gt; args)
      throws InvocationTargetException, IllegalAccessException {
    T returnValue = factory.invoke(null, args.toArray());
    if (returnValue == null) {
      Assert.assertTrue(
          factory + " returns null but it's not annotated with @Nullable", isNullable(factory));
    }
    return returnValue;
  }
  @VisibleForTesting
  static class ParameterNotInstantiableException extends Exception {
    public ParameterNotInstantiableException(Parameter parameter) {
      super(
          "Cannot determine value for parameter "
              + parameter
              + " of "
              + parameter.getDeclaringInvokable());
    }
  }
  @VisibleForTesting
  static class ParameterHasNoDistinctValueException extends Exception {
    ParameterHasNoDistinctValueException(Parameter parameter) {
      super(
          "Cannot generate distinct value for parameter "
              + parameter
              + " of "
              + parameter.getDeclaringInvokable());
    }
  }
  @VisibleForTesting
  static class FactoryMethodReturnsNullException extends Exception {
    public FactoryMethodReturnsNullException(Invokable&lt;?, ?&gt; factory) {
      super(factory + " returns null and cannot be used to test instance methods.");
    }
  }
  private static final class SerializableDummyProxy extends DummyProxy implements Serializable {
    private final transient ClassSanityTester tester;
    SerializableDummyProxy(ClassSanityTester tester) {
      this.tester = tester;
    }
    @Override
    &lt;R&gt; R dummyReturnValue(TypeToken&lt;R&gt; returnType) {
      return tester.getDummyValue(returnType);
    }
    @Override
    public boolean equals(Object obj) {
      return obj instanceof SerializableDummyProxy;
    }
    @Override
    public int hashCode() {
      return 0;
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
