
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.780346820809249%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-XPendingParams.java</h3>
            <pre><code>1  package redis.clients.jedis.params;
<span onclick='openModal()' class='match'>2  import static redis.clients.jedis.args.RawableFactory.from;
3  import redis.clients.jedis.CommandArguments;
4  import redis.clients.jedis.Protocol.Keyword;
5  import redis.clients.jedis.StreamEntryID;
6  import redis.clients.jedis.args.Rawable;
7  public class XPendingParams implements IParams {
8    private Long idle;
9    private Rawable start;
10    private Rawable end;
11    private Integer count;
</span>12    private Rawable consumer;
13    public XPendingParams(StreamEntryID start, StreamEntryID end, int count) {
14      this(start.toString(), end.toString(), count);
15    }
16    public XPendingParams(String start, String end, int count) {
17      this(from(start), from(end), count);
18    }
19    public XPendingParams(byte[] start, byte[] end, int count) {
20      this(from(start), from(end), count);
21    }
22    private XPendingParams(Rawable start, Rawable end, Integer count) {
23      this.start = start;
24      this.end = end;
25      this.count = count;
26    }
27    public XPendingParams() {
28      this.start = null;
29      this.end = null;
30      this.count = null;
31    }
32    public static XPendingParams xPendingParams(StreamEntryID start, StreamEntryID end, int count) {
33      return new XPendingParams(start, end, count);
34    }
35    public static XPendingParams xPendingParams(String start, String end, int count) {
36      return new XPendingParams(start, end, count);
37    }
38    public static XPendingParams xPendingParams(byte[] start, byte[] end, int count) {
39      return new XPendingParams(start, end, count);
40    }
41    public static XPendingParams xPendingParams() {
42      return new XPendingParams();
43    }
44    public XPendingParams idle(long idle) {
45      this.idle = idle;
46      return this;
47    }
48    public XPendingParams start(StreamEntryID start) {
49      this.start = from(start.toString());
50      return this;
51    }
52    public XPendingParams end(StreamEntryID end) {
53      this.end = from(end.toString());
54      return this;
55    }
56    public XPendingParams count(int count) {
57      this.count = count;
58      return this;
59    }
60    public XPendingParams consumer(String consumer) {
61      this.consumer = from(consumer);
62      return this;
63    }
64    public XPendingParams consumer(byte[] consumer) {
65      this.consumer = from(consumer);
66      return this;
67    }
68    @Override
69    public void addParams(CommandArguments args) {
70      if (count == null) {
71        throw new IllegalArgumentException("start, end and count must be set.");
72      }
73      if (start == null) start = from("-");
74      if (end == null) end = from("+");
75      if (idle != null) {
76        args.add(Keyword.IDLE).add(idle);
77      }
78      args.add(start).add(end).add(count);
79      if (consumer != null) {
80        args.add(consumer);
81      }
82    }
83  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ResponseTimeWeightedRule.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import java.util.ArrayList;
3  import java.util.List;
4  import java.util.Random;
5  import java.util.Timer;
6  import java.util.TimerTask;
<span onclick='openModal()' class='match'>7  import java.util.concurrent.atomic.AtomicBoolean;
8  import org.slf4j.Logger;
9  import org.slf4j.LoggerFactory;
10  import com.netflix.client.config.IClientConfig;
11  import com.netflix.client.config.IClientConfigKey;
12  public class ResponseTimeWeightedRule extends RoundRobinRule {
13      public static final IClientConfigKey<Integer> WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY = WeightedResponseTimeRule.WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY;
14      public static final int DEFAULT_TIMER_INTERVAL = 30 * 1000;
15      private int serverWeightTaskTimerInterval = DEFAULT_TIMER_INTERVAL;
16      private static final Logger logger = LoggerFactory.getLogger(ResponseTimeWeightedRule.class);
</span>17      private volatile List<Double> accumulatedWeights = new ArrayList<Double>();
18      private final Random random = new Random();
19      protected Timer serverWeightTimer = null;
20      protected AtomicBoolean serverWeightAssignmentInProgress = new AtomicBoolean(false);
21      String name = "unknown";
22      public ResponseTimeWeightedRule() {
23          super();
24      }
25      public ResponseTimeWeightedRule(ILoadBalancer lb) {
26          super(lb);
27      }
28      @Override
29      public void setLoadBalancer(ILoadBalancer lb) {
30          super.setLoadBalancer(lb);
31          if (lb instanceof BaseLoadBalancer) {
32              name = ((BaseLoadBalancer) lb).getName();
33          }
34          initialize(lb);
35      }
36      void initialize(ILoadBalancer lb) {        
37          if (serverWeightTimer != null) {
38              serverWeightTimer.cancel();
39          }
40          serverWeightTimer = new Timer("NFLoadBalancer-serverWeightTimer-"
41                  + name, true);
42          serverWeightTimer.schedule(new DynamicServerWeightTask(), 0,
43                  serverWeightTaskTimerInterval);
44          ServerWeight sw = new ServerWeight();
45          sw.maintainWeights();
46          Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
47              public void run() {
48                  logger.info("Stopping NFLoadBalancer-serverWeightTimer-{}", name);
49                  serverWeightTimer.cancel();
50              }
51          }));
52      }
53      public void shutdown() {
54          if (serverWeightTimer != null) {
55              logger.info("Stopping NFLoadBalancer-serverWeightTimer-{}", name);
56              serverWeightTimer.cancel();
57          }
58      }
59      @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE")
60      @Override
61      public Server choose(ILoadBalancer lb, Object key) {
62          if (lb == null) {
63              return null;
64          }
65          Server server = null;
66          while (server == null) {
67              List<Double> currentWeights = accumulatedWeights;
68              if (Thread.interrupted()) {
69                  return null;
70              }
71              List<Server> allList = lb.getAllServers();
72              int serverCount = allList.size();
73              if (serverCount == 0) {
74                  return null;
75              }
76              int serverIndex = 0;
77              double maxTotalWeight = currentWeights.size() == 0 ? 0 : currentWeights.get(currentWeights.size() - 1); 
78              if (maxTotalWeight < 0.001d) {
79                  server =  super.choose(getLoadBalancer(), key); 
80              } else {
81                  double randomWeight = random.nextDouble() * maxTotalWeight;
82                  int n = 0;
83                  for (Double d : currentWeights) {
84                      if (d >= randomWeight) {
85                          serverIndex = n;
86                          break;
87                      } else {
88                          n++;
89                      }
90                  }
91                  server = allList.get(serverIndex);
92              }
93              if (server == null) {
94                  Thread.yield();
95                  continue;
96              }
97              if (server.isAlive()) {
98                  return (server);
99              }
100              server = null;
101          }
102          return server;
103      }
104      class DynamicServerWeightTask extends TimerTask {
105          public void run() {
106              ServerWeight serverWeight = new ServerWeight();
107              try {
108                  serverWeight.maintainWeights();
109              } catch (Exception e) {
110                  logger.error("Error running DynamicServerWeightTask for {}", name, e);
111              }
112          }
113      }
114      class ServerWeight {
115          public void maintainWeights() {
116              ILoadBalancer lb = getLoadBalancer();
117              if (lb == null) {
118                  return;
119              }
120              if (!serverWeightAssignmentInProgress.compareAndSet(false, true)) {
121                  return;
122              }
123              try {
124                  logger.info("Weight adjusting job started");
125                  AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb;
126                  LoadBalancerStats stats = nlb.getLoadBalancerStats();
127                  if (stats == null) {
128                      return;
129                  }
130                  double totalResponseTime = 0;
131                  for (Server server : nlb.getAllServers()) {
132                      ServerStats ss = stats.getSingleServerStat(server);
133                      totalResponseTime += ss.getResponseTimeAvg();
134                  }
135                  Double weightSoFar = 0.0;
136                  List<Double> finalWeights = new ArrayList<Double>();
137                  for (Server server : nlb.getAllServers()) {
138                      ServerStats ss = stats.getSingleServerStat(server);
139                      double weight = totalResponseTime - ss.getResponseTimeAvg();
140                      weightSoFar += weight;
141                      finalWeights.add(weightSoFar);   
142                  }
143                  setWeights(finalWeights);
144              } catch (Exception e) {
145                  logger.error("Error calculating server weights", e);
146              } finally {
147                  serverWeightAssignmentInProgress.set(false);
148              }
149          }
150      }
151      void setWeights(List<Double> weights) {
152          this.accumulatedWeights = weights;
153      }
154  	@Override
155  	public void initWithNiwsConfig(IClientConfig clientConfig) {
156  	    super.initWithNiwsConfig(clientConfig);
157  	    serverWeightTaskTimerInterval = clientConfig.get(WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY, DEFAULT_TIMER_INTERVAL);
158  	}
159  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-XPendingParams.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ResponseTimeWeightedRule.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import static redis.clients.jedis.args.RawableFactory.from;
3  import redis.clients.jedis.CommandArguments;
4  import redis.clients.jedis.Protocol.Keyword;
5  import redis.clients.jedis.StreamEntryID;
6  import redis.clients.jedis.args.Rawable;
7  public class XPendingParams implements IParams {
8    private Long idle;
9    private Rawable start;
10    private Rawable end;
11    private Integer count;
</pre></code></div>
                <div class="column column_space"><pre><code>7  import java.util.concurrent.atomic.AtomicBoolean;
8  import org.slf4j.Logger;
9  import org.slf4j.LoggerFactory;
10  import com.netflix.client.config.IClientConfig;
11  import com.netflix.client.config.IClientConfigKey;
12  public class ResponseTimeWeightedRule extends RoundRobinRule {
13      public static final IClientConfigKey<Integer> WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY = WeightedResponseTimeRule.WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY;
14      public static final int DEFAULT_TIMER_INTERVAL = 30 * 1000;
15      private int serverWeightTaskTimerInterval = DEFAULT_TIMER_INTERVAL;
16      private static final Logger logger = LoggerFactory.getLogger(ResponseTimeWeightedRule.class);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    