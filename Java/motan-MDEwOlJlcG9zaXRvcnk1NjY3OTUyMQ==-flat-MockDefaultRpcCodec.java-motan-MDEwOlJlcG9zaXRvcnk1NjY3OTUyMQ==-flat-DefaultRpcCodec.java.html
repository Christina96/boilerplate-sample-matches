
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MockDefaultRpcCodec.java</h3>
            <pre><code>1  package com.weibo.api.motan.transport.netty;
2  import java.io.IOException;
3  import com.weibo.api.motan.codec.AbstractCodec;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.core.extension.SpiMeta;
6  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
7  import com.weibo.api.motan.exception.MotanFrameworkException;
8  import com.weibo.api.motan.protocol.rpc.DefaultRpcCodec;
9  import com.weibo.api.motan.rpc.DefaultResponse;
10  import com.weibo.api.motan.rpc.Response;
11  import com.weibo.api.motan.transport.Channel;
12  @SpiMeta(name = "mockMotan")
13  public class MockDefaultRpcCodec extends AbstractCodec {
14      private DefaultRpcCodec codec = new DefaultRpcCodec();
<span onclick='openModal()' class='match'>15      private static final byte MASK = 0x07;
16      @Override
17      public byte[] encode(Channel channel, Object message) throws IOException {
18          return codec.encode(channel, message);
</span>19      }
20      @Override
21      public Object decode(Channel channel, String remoteIp, byte[] buffer) throws IOException {
22          Object result = codec.decode(channel, remoteIp, buffer);
23          if (result instanceof Response) {
24              DefaultResponse object = (DefaultResponse) result;
25              byte flag = buffer[3];
26              byte dataType = (byte) (flag & MASK);
27              boolean isResponse = (dataType != MotanConstants.FLAG_REQUEST);
28              if (object.getException() == null) {
29                  if (isResponse && object.getValue().equals("error")) {
30                      DefaultResponse response = (DefaultResponse) object;
31                      response.setException(new MotanFrameworkException("decode error: response dataType not support " + dataType,
32                              MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR));
33                      return response;
34                  } else {
35                      throw new MotanFrameworkException(MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
36                  }
37              }
38              return object;
39          }
40          return result;
41      }
42  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-DefaultRpcCodec.java</h3>
            <pre><code>1  package com.weibo.api.motan.protocol.rpc;
2  import com.weibo.api.motan.codec.AbstractCodec;
3  import com.weibo.api.motan.codec.Serialization;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.common.URLParamType;
6  import com.weibo.api.motan.core.extension.ExtensionLoader;
7  import com.weibo.api.motan.core.extension.SpiMeta;
8  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
9  import com.weibo.api.motan.exception.MotanFrameworkException;
10  import com.weibo.api.motan.rpc.DefaultRequest;
11  import com.weibo.api.motan.rpc.DefaultResponse;
12  import com.weibo.api.motan.rpc.Request;
13  import com.weibo.api.motan.rpc.Response;
14  import com.weibo.api.motan.transport.Channel;
15  import com.weibo.api.motan.util.ByteUtil;
16  import com.weibo.api.motan.util.ExceptionUtil;
17  import com.weibo.api.motan.util.ReflectUtil;
18  import java.io.*;
19  import java.util.HashMap;
20  import java.util.Map;
21  @SpiMeta(name = "motan")
22  public class DefaultRpcCodec extends AbstractCodec {
23      public static final short MAGIC = (short) 0xF0F0;
<span onclick='openModal()' class='match'>24      private static final byte MASK = 0x07;
25      @Override
26      public byte[] encode(Channel channel, Object message) throws IOException {
27          try {
</span>28              if (message instanceof Request) {
29                  return encodeRequest(channel, (Request) message);
30              } else if (message instanceof Response) {
31                  return encodeResponse(channel, (Response) message);
32              }
33          } catch (Exception e) {
34              if (ExceptionUtil.isMotanException(e)) {
35                  throw (RuntimeException) e;
36              } else {
37                  throw new MotanFrameworkException("encode error: isResponse=" + (message instanceof Response), e,
38                          MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
39              }
40          }
41          throw new MotanFrameworkException("encode error: message type not support, " + message.getClass(),
42                  MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
43      }
44      @Override
45      public Object decode(Channel channel, String remoteIp, byte[] data) throws IOException {
46          if (data.length <= RpcProtocolVersion.VERSION_1.getHeaderLength()) {
47              throw new MotanFrameworkException("decode error: format problem", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
48          }
49          short type = ByteUtil.bytes2short(data, 0);
50          if (type != MAGIC) {
51              throw new MotanFrameworkException("decode error: magic error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
52          }
53          if (data[2] != RpcProtocolVersion.VERSION_1.getVersion()) {
54              throw new MotanFrameworkException("decode error: version error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
55          }
56          int bodyLength = ByteUtil.bytes2int(data, 12);
57          if (RpcProtocolVersion.VERSION_1.getHeaderLength() + bodyLength != data.length) {
58              throw new MotanFrameworkException("decode error: content length error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
59          }
60          byte flag = data[3];
61          byte dataType = (byte) (flag & MASK);
62          boolean isResponse = (dataType != MotanConstants.FLAG_REQUEST);
63          byte[] body = new byte[bodyLength];
64          System.arraycopy(data, RpcProtocolVersion.VERSION_1.getHeaderLength(), body, 0, bodyLength);
65          long requestId = ByteUtil.bytes2long(data, 4);
66          Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization.class)
67                  .getExtension(channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
68          try {
69              if (isResponse) { 
70                  return decodeResponse(body, dataType, requestId, serialization);
71              } else {
72                  return decodeRequest(body, requestId, serialization);
73              }
74          } catch (ClassNotFoundException e) {
75              throw new MotanFrameworkException("decode " + (isResponse ? "response" : "request") + " error: class not found", e,
76                      MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
77          } catch (Exception e) {
78              if (ExceptionUtil.isMotanException(e)) {
79                  throw (RuntimeException) e;
80              } else {
81                  throw new MotanFrameworkException("decode error: isResponse=" + isResponse, e, MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
82              }
83          }
84      }
85      private byte[] encodeRequest(Channel channel, Request request) throws IOException {
86          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
87          ObjectOutput output = createOutput(outputStream);
88          output.writeUTF(request.getInterfaceName());
89          output.writeUTF(request.getMethodName());
90          output.writeUTF(request.getParamtersDesc());
91          Serialization serialization =
92                  ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
93                          channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
94          if (request.getArguments() != null && request.getArguments().length > 0) {
95              for (Object obj : request.getArguments()) {
96                  serialize(output, obj, serialization);
97              }
98          }
99          if (request.getAttachments() == null || request.getAttachments().isEmpty()) {
100              output.writeInt(0);
101          } else {
102              output.writeInt(request.getAttachments().size());
103              for (Map.Entry<String, String> entry : request.getAttachments().entrySet()) {
104                  output.writeUTF(entry.getKey());
105                  output.writeUTF(entry.getValue());
106              }
107          }
108          output.flush();
109          byte[] body = outputStream.toByteArray();
110          byte flag = MotanConstants.FLAG_REQUEST;
111          output.close();
112          return encode(body, flag, request.getRequestId());
113      }
114      private byte[] encodeResponse(Channel channel, Response value) throws IOException {
115          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
116          ObjectOutput output = createOutput(outputStream);
117          Serialization serialization =
118                  ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
119                          channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
120          byte flag = 0;
121          output.writeLong(value.getProcessTime());
122          if (value.getException() != null) {
123              output.writeUTF(value.getException().getClass().getName());
124              serialize(output, value.getException(), serialization);
125              flag = MotanConstants.FLAG_RESPONSE_EXCEPTION;
126          } else if (value.getValue() == null) {
127              flag = MotanConstants.FLAG_RESPONSE_VOID;
128          } else {
129              output.writeUTF(value.getValue().getClass().getName());
130              serialize(output, value.getValue(), serialization);
131              flag = MotanConstants.FLAG_RESPONSE;
132          }
133          output.flush();
134          byte[] body = outputStream.toByteArray();
135          output.close();
136          return encode(body, flag, value.getRequestId());
137      }
138      private byte[] encode(byte[] body, byte flag, long requestId) throws IOException {
139          byte[] header = new byte[RpcProtocolVersion.VERSION_1.getHeaderLength()];
140          int offset = 0;
141          ByteUtil.short2bytes(MAGIC, header, offset);
142          offset += 2;
143          header[offset++] = RpcProtocolVersion.VERSION_1.getVersion();
144          header[offset++] = flag;
145          ByteUtil.long2bytes(requestId, header, offset);
146          offset += 8;
147          ByteUtil.int2bytes(body.length, header, offset);
148          byte[] data = new byte[header.length + body.length];
149          System.arraycopy(header, 0, data, 0, header.length);
150          System.arraycopy(body, 0, data, header.length, body.length);
151          return data;
152      }
153      private Object decodeRequest(byte[] body, long requestId, Serialization serialization) throws IOException, ClassNotFoundException {
154          ByteArrayInputStream inputStream = new ByteArrayInputStream(body);
155          ObjectInput input = createInput(inputStream);
156          String interfaceName = input.readUTF();
157          String methodName = input.readUTF();
158          String paramtersDesc = input.readUTF();
159          DefaultRequest rpcRequest = new DefaultRequest();
160          rpcRequest.setRequestId(requestId);
161          rpcRequest.setInterfaceName(interfaceName);
162          rpcRequest.setMethodName(methodName);
163          rpcRequest.setParamtersDesc(paramtersDesc);
164          rpcRequest.setArguments(decodeRequestParameter(input, paramtersDesc, serialization));
165          rpcRequest.setAttachments(decodeRequestAttachments(input));
166          input.close();
167          return rpcRequest;
168      }
169      private Object[] decodeRequestParameter(ObjectInput input, String parameterDesc, Serialization serialization) throws IOException,
170              ClassNotFoundException {
171          if (parameterDesc == null || parameterDesc.equals("")) {
172              return null;
173          }
174          Class<?>[] classTypes = ReflectUtil.forNames(parameterDesc);
175          Object[] paramObjs = new Object[classTypes.length];
176          for (int i = 0; i < classTypes.length; i++) {
177              paramObjs[i] = deserialize((byte[]) input.readObject(), classTypes[i], serialization);
178          }
179          return paramObjs;
180      }
181      private Map<String, String> decodeRequestAttachments(ObjectInput input) throws IOException, ClassNotFoundException {
182          int size = input.readInt();
183          if (size <= 0) {
184              return null;
185          }
186          Map<String, String> attachments = new HashMap<String, String>();
187          for (int i = 0; i < size; i++) {
188              attachments.put(input.readUTF(), input.readUTF());
189          }
190          return attachments;
191      }
192      private Object decodeResponse(byte[] body, byte dataType, long requestId, Serialization serialization) throws IOException,
193              ClassNotFoundException {
194          ByteArrayInputStream inputStream = new ByteArrayInputStream(body);
195          ObjectInput input = createInput(inputStream);
196          long processTime = input.readLong();
197          DefaultResponse response = new DefaultResponse();
198          response.setRequestId(requestId);
199          response.setProcessTime(processTime);
200          if (dataType == MotanConstants.FLAG_RESPONSE_VOID) {
201              return response;
202          }
203          String className = input.readUTF();
204          Class<?> clz = ReflectUtil.forName(className);
205          Object result = deserialize((byte[]) input.readObject(), clz, serialization);
206          if (dataType == MotanConstants.FLAG_RESPONSE) {
207              response.setValue(result);
208          } else if (dataType == MotanConstants.FLAG_RESPONSE_EXCEPTION) {
209              response.setException((Exception) result);
210          } else {
211              throw new MotanFrameworkException("decode error: response dataType not support " + dataType,
212                      MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
213          }
214          response.setRequestId(requestId);
215          input.close();
216          return response;
217      }
218  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MockDefaultRpcCodec.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-DefaultRpcCodec.java</div>
                </div>
                <div class="column column_space"><pre><code>15      private static final byte MASK = 0x07;
16      @Override
17      public byte[] encode(Channel channel, Object message) throws IOException {
18          return codec.encode(channel, message);
</pre></code></div>
                <div class="column column_space"><pre><code>24      private static final byte MASK = 0x07;
25      @Override
26      public byte[] encode(Channel channel, Object message) throws IOException {
27          try {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    