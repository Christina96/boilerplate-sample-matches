
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.097447795823665%, Tokens: 14</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.transport.netty;
2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.common.URLParamType;
4  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
5  import com.weibo.api.motan.exception.MotanFrameworkException;
6  import com.weibo.api.motan.exception.MotanServiceException;
7  import com.weibo.api.motan.rpc.DefaultResponse;
8  import com.weibo.api.motan.rpc.Request;
9  import com.weibo.api.motan.rpc.Response;
10  import com.weibo.api.motan.rpc.RpcContext;
11  import com.weibo.api.motan.transport.Channel;
12  import com.weibo.api.motan.transport.MessageHandler;
13  import com.weibo.api.motan.util.LoggerUtil;
14  import com.weibo.api.motan.util.MotanFrameworkUtil;
</span>15  import com.weibo.api.motan.util.NetUtils;
16  import com.weibo.api.motan.util.StatisticCallback;
17  import org.jboss.netty.channel.*;
18  import java.util.concurrent.RejectedExecutionException;
19  import java.util.concurrent.ThreadPoolExecutor;
20  import java.util.concurrent.atomic.AtomicInteger;
21  public class NettyChannelHandler extends SimpleChannelHandler implements StatisticCallback {
22      private ThreadPoolExecutor threadPoolExecutor;
23      private MessageHandler messageHandler;
24      private Channel serverChannel;
25      private AtomicInteger rejectCounter = new AtomicInteger(0);
26      public NettyChannelHandler(Channel serverChannel) {
27          this.serverChannel = serverChannel;
28      }
29      public NettyChannelHandler(Channel serverChannel, MessageHandler messageHandler) {
30          this.serverChannel = serverChannel;
31          this.messageHandler = messageHandler;
32      }
33      public NettyChannelHandler(Channel serverChannel, MessageHandler messageHandler,
34                                 ThreadPoolExecutor threadPoolExecutor) {
35          this.serverChannel = serverChannel;
36          this.messageHandler = messageHandler;
37          this.threadPoolExecutor = threadPoolExecutor;
38      }
39      @Override
40      public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
41          LoggerUtil.info("NettyChannelHandler channelConnected: remote=" + ctx.getChannel().getRemoteAddress()
42                  + " local=" + ctx.getChannel().getLocalAddress() + " event=" + e.getClass().getSimpleName());
43      }
44      @Override
45      public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
46          LoggerUtil.info("NettyChannelHandler channelDisconnected: remote=" + ctx.getChannel().getRemoteAddress()
47                  + " local=" + ctx.getChannel().getLocalAddress() + " event=" + e.getClass().getSimpleName());
48      }
49      @Override
50      public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
51          Object message = e.getMessage();
52          if (message instanceof Request) {
53              processRequest(ctx, e);
54          } else if (message instanceof Response) {
55              processResponse(ctx, e);
56          } else {
57              LoggerUtil.error("NettyChannelHandler messageReceived type not support: class=" + message.getClass());
58              throw new MotanFrameworkException("NettyChannelHandler messageReceived type not support: class=" + message.getClass());
59          }
60      }
61      private void processRequest(final ChannelHandlerContext ctx, MessageEvent e) {
62          final Request request = (Request) e.getMessage();
63          request.setAttachment(URLParamType.host.getName(), NetUtils.getHostName(ctx.getChannel().getRemoteAddress()));
64          final long processStartTime = System.currentTimeMillis();
65          try {
66              threadPoolExecutor.execute(() -> {
67                  try {
68                      MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SEXECUTOR_START);
69                      RpcContext.init(request);
70                      processRequest(ctx, request, processStartTime);
71                  } finally {
72                      RpcContext.destroy();
73                  }
74              });
75          } catch (RejectedExecutionException rejectException) {
76              DefaultResponse response = MotanFrameworkUtil.buildErrorResponse(request, new MotanServiceException("process thread pool is full, reject",
77                      MotanErrorMsgConstant.SERVICE_REJECT, false));
78              response.setProcessTime(System.currentTimeMillis() - processStartTime);
79              e.getChannel().write(response);
80              LoggerUtil.warn("process thread pool is full, reject, active={} poolSize={} corePoolSize={} maxPoolSize={} taskCount={} requestId={}",
81                      threadPoolExecutor.getActiveCount(), threadPoolExecutor.getPoolSize(),
82                      threadPoolExecutor.getCorePoolSize(), threadPoolExecutor.getMaximumPoolSize(),
83                      threadPoolExecutor.getTaskCount(), request.getRequestId());
84              rejectCounter.incrementAndGet();
85          }
86      }
87      private void processRequest(final ChannelHandlerContext ctx, final Request request, long processStartTime) {
88          Object result;
89          try {
90              result = messageHandler.handle(serverChannel, request);
91          } catch (Exception e) {
92              LoggerUtil.error("NettyChannelHandler processRequest fail!request:" + MotanFrameworkUtil.toString(request), e);
93              result = MotanFrameworkUtil.buildErrorResponse(request, new MotanServiceException("process request fail. errMsg:" + e.getMessage()));
94          }
95          if (result instanceof Response) {
96              MotanFrameworkUtil.logEvent((Response) result, MotanConstants.TRACE_PROCESS);
97          }
98          final DefaultResponse response;
99          if (result instanceof DefaultResponse) {
100              response = (DefaultResponse) result;
101          } else {
102              response = new DefaultResponse(result);
103          }
104          response.setRpcProtocolVersion(request.getRpcProtocolVersion());
105          response.setRequestId(request.getRequestId());
106          response.setProcessTime(System.currentTimeMillis() - processStartTime);
107          ChannelFuture channelFuture = null;
108          if (ctx.getChannel().isConnected()) {
109              channelFuture = ctx.getChannel().write(response);
110          }
111          if (channelFuture != null) {
112              channelFuture.addListener(future -> {
113                  MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_SSEND, System.currentTimeMillis());
114                  response.onFinish();
115              });
116          } else { 
117              response.onFinish();
118          }
119      }
120      private void processResponse(ChannelHandlerContext ctx, MessageEvent e) {
121          messageHandler.handle(serverChannel, e.getMessage());
122      }
123      @Override
124      public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
125          LoggerUtil.error("NettyChannelHandler exceptionCaught: remote=" + ctx.getChannel().getRemoteAddress()
126                  + " local=" + ctx.getChannel().getLocalAddress() + " event=" + e.getCause(), e.getCause());
127          ctx.getChannel().close();
128      }
129      @Override
130      public String statisticCallback() {
131          int count = rejectCounter.getAndSet(0);
132          if (count > 0) {
133              return String.format("type: motan name: reject_request_pool total_count: %s reject_count: %s", threadPoolExecutor.getPoolSize(), count);
134          } else {
135              return null;
136          }
137      }
138  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterShardedPublishSubscribeCommandsTest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis.commands.jedis;
2  import static org.hamcrest.MatcherAssert.assertThat;
3  import static org.hamcrest.Matchers.hasItems;
4  import static org.junit.Assert.assertArrayEquals;
5  import static org.junit.Assert.assertEquals;
6  import java.util.HashMap;
7  import java.util.Map;
8  import org.junit.Test;
9  import redis.clients.jedis.BinaryJedisShardedPubSub;
10  import redis.clients.jedis.Connection;
11  import redis.clients.jedis.Jedis;
12  import redis.clients.jedis.JedisShardedPubSub;
13  import redis.clients.jedis.util.JedisClusterCRC16;
14  import redis.clients.jedis.util.SafeEncoder;
</span>15  public class ClusterShardedPublishSubscribeCommandsTest extends ClusterJedisCommandsTestBase {
16    private void publishOne(final String channel, final String message) {
17      Thread t = new Thread(() -> cluster.spublish(channel, message));
18      t.start();
19    }
20    @Test
21    public void subscribe() throws InterruptedException {
22      cluster.ssubscribe(new JedisShardedPubSub() {
23        @Override public void onSMessage(String channel, String message) {
24          assertEquals("foo", channel);
25          assertEquals("exit", message);
26          sunsubscribe();
27        }
28        @Override public void onSSubscribe(String channel, int subscribedChannels) {
29          assertEquals("foo", channel);
30          assertEquals(1, subscribedChannels);
31          publishOne("foo", "exit");
32        }
33        @Override public void onSUnsubscribe(String channel, int subscribedChannels) {
34          assertEquals("foo", channel);
35          assertEquals(0, subscribedChannels);
36        }
37      }, "foo");
38    }
39    @Test
40    public void subscribeMany() {
41      cluster.ssubscribe(new JedisShardedPubSub() {
42        @Override public void onSMessage(String channel, String message) {
43          sunsubscribe(channel);
44        }
45        @Override public void onSSubscribe(String channel, int subscribedChannels) {
46          publishOne(channel, "exit");
47        }
48      }, "{foo}", "{foo}bar");
49    }
50    @Test
51    public void pubSubChannels() {
52      cluster.ssubscribe(new JedisShardedPubSub() {
53        private int count = 0;
54        @Override public void onSSubscribe(String channel, int subscribedChannels) {
55          count++;
56          if (count == 3) {
57            try (Connection conn = cluster.getConnectionFromSlot(JedisClusterCRC16.getSlot("testchan"));
58                Jedis jedis = new Jedis(conn)) {
59              assertThat(jedis.pubsubShardChannels(),
60                  hasItems("{testchan}1", "{testchan}2", "{testchan}3"));
61            }
62            sunsubscribe();
63          }
64        }
65      }, "{testchan}1", "{testchan}2", "{testchan}3");
66    }
67    @Test
68    public void pubSubChannelsWithPattern() {
69      cluster.ssubscribe(new JedisShardedPubSub() {
70        private int count = 0;
71        @Override public void onSSubscribe(String channel, int subscribedChannels) {
72          count++;
73          if (count == 3) {
74            try (Connection conn = cluster.getConnectionFromSlot(JedisClusterCRC16.getSlot("testchan"));
75                Jedis otherJedis = new Jedis(conn)) {
76              assertThat(otherJedis.pubsubShardChannels("*testchan*"),
77                  hasItems("{testchan}1", "{testchan}2", "{testchan}3"));
78            }
79            sunsubscribe();
80          }
81        }
82      }, "{testchan}1", "{testchan}2", "{testchan}3");
83    }
84    @Test
85    public void pubSubNumSub() {
86      final Map<String, Long> expectedNumSub = new HashMap<>();
87      expectedNumSub.put("{testchannel}1", 1L);
88      expectedNumSub.put("{testchannel}2", 1L);
89      cluster.ssubscribe(new JedisShardedPubSub() {
90        private int count = 0;
91        @Override public void onSSubscribe(String channel, int subscribedChannels) {
92          count++;
93          if (count == 2) {
94            try (Connection conn = cluster.getConnectionFromSlot(JedisClusterCRC16.getSlot("testchannel"));
95                Jedis otherJedis = new Jedis(conn)) {
96              Map<String, Long> numSub = otherJedis.pubsubShardNumSub("{testchannel}1", "{testchannel}2");
97              assertEquals(expectedNumSub, numSub);
98            }
99            sunsubscribe();
100          }
101        }
102      }, "{testchannel}1", "{testchannel}2");
103    }
104    @Test
105    public void binarySubscribe() {
106      cluster.ssubscribe(new BinaryJedisShardedPubSub() {
107        @Override public void onSMessage(byte[] channel, byte[] message) {
108          assertArrayEquals(SafeEncoder.encode("foo"), channel);
109          assertArrayEquals(SafeEncoder.encode("exit"), message);
110          sunsubscribe();
111        }
112        @Override public void onSSubscribe(byte[] channel, int subscribedChannels) {
113          assertArrayEquals(SafeEncoder.encode("foo"), channel);
114          assertEquals(1, subscribedChannels);
115          publishOne(SafeEncoder.encode(channel), "exit");
116        }
117        @Override public void onSUnsubscribe(byte[] channel, int subscribedChannels) {
118          assertArrayEquals(SafeEncoder.encode("foo"), channel);
119          assertEquals(0, subscribedChannels);
120        }
121      }, SafeEncoder.encode("foo"));
122    }
123    @Test
124    public void binarySubscribeMany() {
125      cluster.ssubscribe(new BinaryJedisShardedPubSub() {
126        @Override public void onSMessage(byte[] channel, byte[] message) {
127          sunsubscribe(channel);
128        }
129        @Override public void onSSubscribe(byte[] channel, int subscribedChannels) {
130          publishOne(SafeEncoder.encode(channel), "exit");
131        }
132      }, SafeEncoder.encode("{foo}"), SafeEncoder.encode("{foo}bar"));
133    }
134  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterShardedPublishSubscribeCommandsTest.java</div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.transport.netty;
2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.common.URLParamType;
4  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
5  import com.weibo.api.motan.exception.MotanFrameworkException;
6  import com.weibo.api.motan.exception.MotanServiceException;
7  import com.weibo.api.motan.rpc.DefaultResponse;
8  import com.weibo.api.motan.rpc.Request;
9  import com.weibo.api.motan.rpc.Response;
10  import com.weibo.api.motan.rpc.RpcContext;
11  import com.weibo.api.motan.transport.Channel;
12  import com.weibo.api.motan.transport.MessageHandler;
13  import com.weibo.api.motan.util.LoggerUtil;
14  import com.weibo.api.motan.util.MotanFrameworkUtil;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis.commands.jedis;
2  import static org.hamcrest.MatcherAssert.assertThat;
3  import static org.hamcrest.Matchers.hasItems;
4  import static org.junit.Assert.assertArrayEquals;
5  import static org.junit.Assert.assertEquals;
6  import java.util.HashMap;
7  import java.util.Map;
8  import org.junit.Test;
9  import redis.clients.jedis.BinaryJedisShardedPubSub;
10  import redis.clients.jedis.Connection;
11  import redis.clients.jedis.Jedis;
12  import redis.clients.jedis.JedisShardedPubSub;
13  import redis.clients.jedis.util.JedisClusterCRC16;
14  import redis.clients.jedis.util.SafeEncoder;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    