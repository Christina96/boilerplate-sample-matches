
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.util;
2  import com.codahale.metrics.Histogram;
3  import com.codahale.metrics.MetricRegistry;
4  import com.codahale.metrics.Snapshot;
5  import com.weibo.api.motan.closable.Closable;
6  import com.weibo.api.motan.closable.ShutDownHook;
7  import com.weibo.api.motan.common.MotanConstants;
8  import com.weibo.api.motan.common.URLParamType;
9  import com.weibo.api.motan.util.StatsUtil.AccessStatus;
10  import org.apache.commons.lang3.StringUtils;
11  import java.text.DecimalFormat;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.concurrent.*;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import static com.weibo.api.motan.common.MotanConstants.APPLICATION_STATISTIC;
17  public class StatsUtil {
18      public static final String HISTOGRAM_NAME = MetricRegistry.name(AccessStatisticItem.class, &quot;costTimeMillis&quot;);
19      public static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
20      public static String SEPARATE = &quot;\\|&quot;;
21      protected static ConcurrentMap&lt;String, AccessStatisticItem&gt; accessStatistics = new ConcurrentHashMap&lt;&gt;();
22      protected static List&lt;StatisticCallback&gt; statisticCallbacks = new CopyOnWriteArrayList&lt;&gt;();
23      protected static ScheduledFuture&lt;?&gt; scheduledFuture;
24      static {
25          scheduledFuture = executorService.scheduleAtFixedRate(new Runnable() {
26              @Override
27              public void run() {
28                  logAccessStatistic(true);
29                  logMemoryStatistic();
30                  logStatisticCallback();
31              }
32          }, MotanConstants.STATISTIC_PEROID, MotanConstants.STATISTIC_PEROID, TimeUnit.SECONDS);
33          ShutDownHook.registerShutdownHook(new Closable() {
34              @Override
35              public void close() {
36                  if (!executorService.isShutdown()) {
37                      executorService.shutdown();
38                  }
39              }
40          });
41      }
42      public static void registryStatisticCallback(StatisticCallback callback) {
43          if (callback == null) {
44              LoggerUtil.warn(&quot;StatsUtil registryStatisticCallback is null&quot;);
45              return;
46          }
47          statisticCallbacks.add(callback);
48      }
49      public static void unRegistryStatisticCallback(StatisticCallback callback) {
50          if (callback == null) {
51              LoggerUtil.warn(&quot;StatsUtil unRegistryStatisticCallback is null&quot;);
52              return;
53          }
54          statisticCallbacks.remove(callback);
55      }
56      @Deprecated
57      public static void accessStatistic(String name, long currentTimeMillis, long costTimeMillis, long bizProcessTime,
58                                         AccessStatus accessStatus) {
59          accessStatistic(name, URLParamType.application.getValue(), URLParamType.module.getValue(), currentTimeMillis, costTimeMillis, bizProcessTime, accessStatus);
60      }
61      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
62                                         long bizProcessTime, AccessStatus accessStatus) {
63          accessStatistic(name, application, module, currentTimeMillis, costTimeMillis, bizProcessTime, MotanConstants.SLOW_COST, accessStatus);
64      }
65      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
66                                         long bizProcessTime, int slowCost, AccessStatus accessStatus) {
67          if (name == null || name.isEmpty()) {
68              return;
69          }
70          if (StringUtils.isBlank(application)) {
71              application = URLParamType.application.getValue();
72          }
73          if (StringUtils.isBlank(module)) {
74              module = URLParamType.module.getValue();
75          }
76          name = name + &quot;|&quot; + application + &quot;|&quot; + module;
77          try {
78              AccessStatisticItem item = getStatisticItem(name, currentTimeMillis);
79              item.statistic(currentTimeMillis, costTimeMillis, bizProcessTime, slowCost, accessStatus);
80          } catch (Exception e) {
81          }
82      }
83      public static AccessStatisticItem getStatisticItem(String name, long currentTime) {
84          AccessStatisticItem item = accessStatistics.get(name);
85          if (item == null) {
86              accessStatistics.putIfAbsent(name, new AccessStatisticItem(name, currentTime));
87              item = accessStatistics.get(name);
88          }
89          return item;
90      }
91      public static ConcurrentMap&lt;String, AccessStatisticResult&gt; getTotalAccessStatistic() {
92          return getTotalAccessStatistic(MotanConstants.STATISTIC_PEROID);
93      }
94      public static ConcurrentMap&lt;String, AccessStatisticResult&gt; getTotalAccessStatistic(int peroid) {
95          if (peroid &gt; MotanConstants.STATISTIC_PEROID) {
96              throw new RuntimeException(&quot;peroid need &lt;= &quot; + MotanConstants.STATISTIC_PEROID);
97          }
98          long currentTimeMillis = System.currentTimeMillis();
99          ConcurrentMap&lt;String, AccessStatisticResult&gt; totalResults = new ConcurrentHashMap&lt;&gt;();
100          for (Map.Entry&lt;String, AccessStatisticItem&gt; entry : accessStatistics.entrySet()) {
101              AccessStatisticItem item = entry.getValue();
102              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
103              String key = entry.getKey();
104              String[] keys = key.split(SEPARATE);
105              if (keys.length != 3) {
106                  continue;
107              }
108              String application = keys[1];
109              String module = keys[2];
110              key = application + &quot;|&quot; + module;
111              AccessStatisticResult appResult = totalResults.get(key);
112              if (appResult == null) {
113                  totalResults.putIfAbsent(key, new AccessStatisticResult());
114                  appResult = totalResults.get(key);
115              }
116              appResult.totalCount += result.totalCount;
117              appResult.bizExceptionCount += result.bizExceptionCount;
118              appResult.slowCount += result.slowCount;
119              appResult.costTime += result.costTime;
120              appResult.bizTime += result.bizTime;
121              appResult.otherExceptionCount += result.otherExceptionCount;
122          }
123          return totalResults;
124      }
125      public static void logAccessStatistic(boolean clear) {
126          DecimalFormat mbFormat = new DecimalFormat(&quot;#0.00&quot;);
127          long currentTimeMillis = System.currentTimeMillis();
128          ConcurrentMap&lt;String, AccessStatisticResult&gt; totalResults = new ConcurrentHashMap&lt;&gt;();
129          for (Map.Entry&lt;String, AccessStatisticItem&gt; entry : accessStatistics.entrySet()) {
130              AccessStatisticItem item = entry.getValue();
131              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
132              if (clear) {
133                  item.clearStatistic(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
134              }
135              String key = entry.getKey();
136              String[] keys = key.split(SEPARATE);
137              if (keys.length != 3) {
138                  continue;
139              }
140              String application = keys[1];
141              String module = keys[2];
142              key = application + &quot;|&quot; + module;
143              AccessStatisticResult appResult = totalResults.get(key);
144              if (appResult == null) {
145                  totalResults.putIfAbsent(key, new AccessStatisticResult());
146                  appResult = totalResults.get(key);
147              }
148              appResult.totalCount += result.totalCount;
149              appResult.bizExceptionCount += result.bizExceptionCount;
150              appResult.slowCount += result.slowCount;
151              appResult.costTime += result.costTime;
152              appResult.bizTime += result.bizTime;
153              appResult.otherExceptionCount += result.otherExceptionCount;
154              Snapshot snapshot = InternalMetricsFactory.getRegistryInstance(entry.getKey())
155                      .histogram(HISTOGRAM_NAME).getSnapshot();
156              if (application.equals(APPLICATION_STATISTIC)) {
157                  continue;
158              }
159              if (result.totalCount == 0) {
160                  LoggerUtil.accessStatsLog(&quot;[motan-accessStatistic] app: &quot; + application + &quot; module: &quot; + module + &quot; item: &quot; + keys[0]
161                          + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0 max_tps: 0 min_tps: 0&quot;);
162              } else {
163                  LoggerUtil.accessStatsLog(
164                          &quot;[motan-accessStatistic] app: {} module: {} item: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {} max_tps: {} min_tps: {} &quot;,
165                          application, module, keys[0], result.totalCount, result.slowCount,
166                          mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
167                          mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
168                          mbFormat.format(snapshot.get999thPercentile()), result.bizExceptionCount, result.otherExceptionCount,
169                          mbFormat.format(result.costTime / result.totalCount), mbFormat.format(result.bizTime / result.totalCount),
170                          (result.totalCount / MotanConstants.STATISTIC_PEROID), result.maxCount, result.minCount);
171              }
172          }
173          if (!totalResults.isEmpty()) {
174              for (Map.Entry&lt;String, AccessStatisticResult&gt; entry : totalResults.entrySet()) {
175                  String application = entry.getKey().split(SEPARATE)[0];
176                  String module = entry.getKey().split(SEPARATE)[1];
177                  AccessStatisticResult totalResult = entry.getValue();
178                  Snapshot snapshot =
179                          InternalMetricsFactory.getRegistryInstance(entry.getKey())
180                                  .histogram(HISTOGRAM_NAME).getSnapshot();
181                  if (totalResult.totalCount &gt; 0) {
182                      LoggerUtil.accessStatsLog(
183                              &quot;[motan-totalAccessStatistic] app: {} module: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {}&quot;,
184                              application, module, totalResult.totalCount, totalResult.slowCount,
185                              mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
186                              mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
187                              mbFormat.format(snapshot.get999thPercentile()), totalResult.bizExceptionCount,
188                              totalResult.otherExceptionCount, mbFormat.format(totalResult.costTime / totalResult.totalCount),
189                              mbFormat.format(totalResult.bizTime / totalResult.totalCount),
190                              (totalResult.totalCount / MotanConstants.STATISTIC_PEROID));
191                  } else {
192                      LoggerUtil.accessStatsLog(&quot;[motan-totalAccessStatistic] app: &quot; + application + &quot; module: &quot; + module
193                              + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0&quot;);
194                  }
195              }
196          } else {
197              LoggerUtil.accessStatsLog(&quot;[motan-totalAccessStatistic] app: &quot; + URLParamType.application.getValue() + &quot; module: &quot; + URLParamType.module.getValue()
198                      + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0&quot;);
199          }
200      }
201      public static void logMemoryStatistic() {
202          LoggerUtil.accessStatsLog(&quot;[motan-memoryStatistic] {} &quot;, memoryStatistic());
203      }
204      public static String memoryStatistic() {
205          Runtime runtime = Runtime.getRuntime();
206          double freeMemory = (double) runtime.freeMemory() / (1024 * 1024);
207          double maxMemory = (double) runtime.maxMemory() / (1024 * 1024);
208          double totalMemory = (double) runtime.totalMemory() / (1024 * 1024);
209          double usedMemory = totalMemory - freeMemory;
210          double percentFree = ((maxMemory - usedMemory) / maxMemory) * 100.0;
211          double percentUsed = 100 - percentFree;
212          DecimalFormat mbFormat = new DecimalFormat(&quot;#0.00&quot;);
213          DecimalFormat percentFormat = new DecimalFormat(&quot;#0.0&quot;);
214          StringBuilder sb = new StringBuilder();
215          sb.append(mbFormat.format(usedMemory)).append(&quot;MB of &quot;).append(mbFormat.format(maxMemory)).append(&quot; MB (&quot;)
216                  .append(percentFormat.format(percentUsed)).append(&quot;%) used&quot;);
217          return sb.toString();
218      }
219      public static void logStatisticCallback() {
220          for (StatisticCallback callback : statisticCallbacks) {
221              try {
222                  String msg = callback.statisticCallback();
223                  if (msg != null &amp;&amp; !msg.isEmpty()) {
224                      LoggerUtil.accessStatsLog(&quot;[motan-statisticCallback] {}&quot;, msg);
225                  }
226              } catch (Exception e) {
227                  LoggerUtil.error(&quot;StatsUtil logStatisticCallback Error: &quot; + e.getMessage(), e);
228              }
229          }
230      }
231      public enum AccessStatus {
232          NORMAL, BIZ_EXCEPTION, OTHER_EXCEPTION
233      }
234  }
235  class AccessStatisticItem {
236      private String name;
237      private int currentIndex;
238      private AtomicInteger[] costTimes = null;
239      private AtomicInteger[] bizProcessTimes = null;
240      private AtomicInteger[] totalCounter = null;
241      private AtomicInteger[] slowCounter = null;
242      private AtomicInteger[] bizExceptionCounter = null;
243      private AtomicInteger[] otherExceptionCounter = null;
244      private Histogram histogram = null;
245      private int length;
246      public AccessStatisticItem(String name, long currentTimeMillis) {
247          this(name, currentTimeMillis, MotanConstants.STATISTIC_PEROID * 2);
248      }
249      public AccessStatisticItem(String name, long currentTimeMillis, int length) {
250          this.name = name;
251          this.costTimes = initAtomicIntegerArr(length);
252          this.bizProcessTimes = initAtomicIntegerArr(length);
253          this.totalCounter = initAtomicIntegerArr(length);
254          this.slowCounter = initAtomicIntegerArr(length);
255          this.bizExceptionCounter = initAtomicIntegerArr(length);
256          this.otherExceptionCounter = initAtomicIntegerArr(length);
257          this.length = length;
258          this.currentIndex = getIndex(currentTimeMillis, length);
259          this.histogram =
260                  InternalMetricsFactory.getRegistryInstance(name)
261                          .histogram(StatsUtil.HISTOGRAM_NAME);
262      }
263      private AtomicInteger[] initAtomicIntegerArr(int size) {
264          AtomicInteger[] arrs = new AtomicInteger[size];
265          for (int i = 0; i &lt; arrs.length; i++) {
266              arrs[i] = new AtomicInteger(0);
267          }
268          return arrs;
269      }
270      void statistic(long currentTimeMillis, long costTimeMillis, long bizProcessTime, int slowCost, AccessStatus accessStatus) {
271          int tempIndex = getIndex(currentTimeMillis, length);
272          if (currentIndex != tempIndex) {
273              synchronized (this) {
274                  if (currentIndex != tempIndex) {
275                      reset(tempIndex);
276                      currentIndex = tempIndex;
277                  }
278              }
279          }
280          costTimes[currentIndex].addAndGet((int) costTimeMillis);
281          bizProcessTimes[currentIndex].addAndGet((int) bizProcessTime);
282          totalCounter[currentIndex].incrementAndGet();
283          if (costTimeMillis &gt;= slowCost) {
284              slowCounter[currentIndex].incrementAndGet();
285          }
286          if (accessStatus == AccessStatus.BIZ_EXCEPTION) {
287              bizExceptionCounter[currentIndex].incrementAndGet();
288          } else if (accessStatus == AccessStatus.OTHER_EXCEPTION) {
289              otherExceptionCounter[currentIndex].incrementAndGet();
290          }
291          histogram.update(costTimeMillis);
292          String[] names = name.split(&quot;\\|&quot;);
293          String appName = names[1] + &quot;|&quot; + names[2];
294          InternalMetricsFactory.getRegistryInstance(appName).histogram(StatsUtil.HISTOGRAM_NAME)
295                  .update(costTimeMillis);
296      }
297      private int getIndex(long currentTimeMillis, int periodSecond) {
298          return (int) ((currentTimeMillis / 1000) % periodSecond);
299      }
300      private void reset(int index) {
301          costTimes[index].set(0);
302          totalCounter[index].set(0);
303          bizProcessTimes[index].set(0);
304          slowCounter[index].set(0);
305          bizExceptionCounter[index].set(0);
306          otherExceptionCounter[index].set(0);
307      }
308      AccessStatisticResult getStatisticResult(long currentTimeMillis, int peroidSecond) {
309          long currentTimeSecond = currentTimeMillis / 1000;
<span onclick='openModal()' class='match'>310          currentTimeSecond--; 
311          int startIndex = getIndex(currentTimeSecond * 1000, length);
312          AccessStatisticResult result = new AccessStatisticResult();
</span>313          for (int i = 0; i &lt; peroidSecond; i++) {
314              int currentIndex = (startIndex - i + length) % length;
315              result.costTime += costTimes[currentIndex].get();
316              result.bizTime += bizProcessTimes[currentIndex].get();
317              result.totalCount += totalCounter[currentIndex].get();
318              result.slowCount += slowCounter[currentIndex].get();
319              result.bizExceptionCount += bizExceptionCounter[currentIndex].get();
320              result.otherExceptionCount += otherExceptionCounter[currentIndex].get();
321              if (totalCounter[currentIndex].get() &gt; result.maxCount) {
322                  result.maxCount = totalCounter[currentIndex].get();
323              } else if (totalCounter[currentIndex].get() &lt; result.minCount || result.minCount == -1) {
324                  result.minCount = totalCounter[currentIndex].get();
325              }
326          }
327          return result;
328      }
329      void clearStatistic(long currentTimeMillis, int peroidSecond) {
330          long currentTimeSecond = currentTimeMillis / 1000;
331          currentTimeSecond--; 
332          int startIndex = getIndex(currentTimeSecond * 1000, length);
333          for (int i = 0; i &lt; peroidSecond; i++) {
334              int currentIndex = (startIndex - i + length) % length;
335              reset(currentIndex);
336          }
337      }
338  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.util;
2  import com.codahale.metrics.Histogram;
3  import com.codahale.metrics.MetricRegistry;
4  import com.codahale.metrics.Snapshot;
5  import com.weibo.api.motan.closable.Closable;
6  import com.weibo.api.motan.closable.ShutDownHook;
7  import com.weibo.api.motan.common.MotanConstants;
8  import com.weibo.api.motan.common.URLParamType;
9  import com.weibo.api.motan.util.StatsUtil.AccessStatus;
10  import org.apache.commons.lang3.StringUtils;
11  import java.text.DecimalFormat;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.concurrent.*;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import static com.weibo.api.motan.common.MotanConstants.APPLICATION_STATISTIC;
17  public class StatsUtil {
18      public static final String HISTOGRAM_NAME = MetricRegistry.name(AccessStatisticItem.class, &quot;costTimeMillis&quot;);
19      public static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
20      public static String SEPARATE = &quot;\\|&quot;;
21      protected static ConcurrentMap&lt;String, AccessStatisticItem&gt; accessStatistics = new ConcurrentHashMap&lt;&gt;();
22      protected static List&lt;StatisticCallback&gt; statisticCallbacks = new CopyOnWriteArrayList&lt;&gt;();
23      protected static ScheduledFuture&lt;?&gt; scheduledFuture;
24      static {
25          scheduledFuture = executorService.scheduleAtFixedRate(new Runnable() {
26              @Override
27              public void run() {
28                  logAccessStatistic(true);
29                  logMemoryStatistic();
30                  logStatisticCallback();
31              }
32          }, MotanConstants.STATISTIC_PEROID, MotanConstants.STATISTIC_PEROID, TimeUnit.SECONDS);
33          ShutDownHook.registerShutdownHook(new Closable() {
34              @Override
35              public void close() {
36                  if (!executorService.isShutdown()) {
37                      executorService.shutdown();
38                  }
39              }
40          });
41      }
42      public static void registryStatisticCallback(StatisticCallback callback) {
43          if (callback == null) {
44              LoggerUtil.warn(&quot;StatsUtil registryStatisticCallback is null&quot;);
45              return;
46          }
47          statisticCallbacks.add(callback);
48      }
49      public static void unRegistryStatisticCallback(StatisticCallback callback) {
50          if (callback == null) {
51              LoggerUtil.warn(&quot;StatsUtil unRegistryStatisticCallback is null&quot;);
52              return;
53          }
54          statisticCallbacks.remove(callback);
55      }
56      @Deprecated
57      public static void accessStatistic(String name, long currentTimeMillis, long costTimeMillis, long bizProcessTime,
58                                         AccessStatus accessStatus) {
59          accessStatistic(name, URLParamType.application.getValue(), URLParamType.module.getValue(), currentTimeMillis, costTimeMillis, bizProcessTime, accessStatus);
60      }
61      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
62                                         long bizProcessTime, AccessStatus accessStatus) {
63          accessStatistic(name, application, module, currentTimeMillis, costTimeMillis, bizProcessTime, MotanConstants.SLOW_COST, accessStatus);
64      }
65      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
66                                         long bizProcessTime, int slowCost, AccessStatus accessStatus) {
67          if (name == null || name.isEmpty()) {
68              return;
69          }
70          if (StringUtils.isBlank(application)) {
71              application = URLParamType.application.getValue();
72          }
73          if (StringUtils.isBlank(module)) {
74              module = URLParamType.module.getValue();
75          }
76          name = name + &quot;|&quot; + application + &quot;|&quot; + module;
77          try {
78              AccessStatisticItem item = getStatisticItem(name, currentTimeMillis);
79              item.statistic(currentTimeMillis, costTimeMillis, bizProcessTime, slowCost, accessStatus);
80          } catch (Exception e) {
81          }
82      }
83      public static AccessStatisticItem getStatisticItem(String name, long currentTime) {
84          AccessStatisticItem item = accessStatistics.get(name);
85          if (item == null) {
86              accessStatistics.putIfAbsent(name, new AccessStatisticItem(name, currentTime));
87              item = accessStatistics.get(name);
88          }
89          return item;
90      }
91      public static ConcurrentMap&lt;String, AccessStatisticResult&gt; getTotalAccessStatistic() {
92          return getTotalAccessStatistic(MotanConstants.STATISTIC_PEROID);
93      }
94      public static ConcurrentMap&lt;String, AccessStatisticResult&gt; getTotalAccessStatistic(int peroid) {
95          if (peroid &gt; MotanConstants.STATISTIC_PEROID) {
96              throw new RuntimeException(&quot;peroid need &lt;= &quot; + MotanConstants.STATISTIC_PEROID);
97          }
98          long currentTimeMillis = System.currentTimeMillis();
99          ConcurrentMap&lt;String, AccessStatisticResult&gt; totalResults = new ConcurrentHashMap&lt;&gt;();
100          for (Map.Entry&lt;String, AccessStatisticItem&gt; entry : accessStatistics.entrySet()) {
101              AccessStatisticItem item = entry.getValue();
102              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
103              String key = entry.getKey();
104              String[] keys = key.split(SEPARATE);
105              if (keys.length != 3) {
106                  continue;
107              }
108              String application = keys[1];
109              String module = keys[2];
110              key = application + &quot;|&quot; + module;
111              AccessStatisticResult appResult = totalResults.get(key);
112              if (appResult == null) {
113                  totalResults.putIfAbsent(key, new AccessStatisticResult());
114                  appResult = totalResults.get(key);
115              }
116              appResult.totalCount += result.totalCount;
117              appResult.bizExceptionCount += result.bizExceptionCount;
118              appResult.slowCount += result.slowCount;
119              appResult.costTime += result.costTime;
120              appResult.bizTime += result.bizTime;
121              appResult.otherExceptionCount += result.otherExceptionCount;
122          }
123          return totalResults;
124      }
125      public static void logAccessStatistic(boolean clear) {
126          DecimalFormat mbFormat = new DecimalFormat(&quot;#0.00&quot;);
127          long currentTimeMillis = System.currentTimeMillis();
128          ConcurrentMap&lt;String, AccessStatisticResult&gt; totalResults = new ConcurrentHashMap&lt;&gt;();
129          for (Map.Entry&lt;String, AccessStatisticItem&gt; entry : accessStatistics.entrySet()) {
130              AccessStatisticItem item = entry.getValue();
131              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
132              if (clear) {
133                  item.clearStatistic(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
134              }
135              String key = entry.getKey();
136              String[] keys = key.split(SEPARATE);
137              if (keys.length != 3) {
138                  continue;
139              }
140              String application = keys[1];
141              String module = keys[2];
142              key = application + &quot;|&quot; + module;
143              AccessStatisticResult appResult = totalResults.get(key);
144              if (appResult == null) {
145                  totalResults.putIfAbsent(key, new AccessStatisticResult());
146                  appResult = totalResults.get(key);
147              }
148              appResult.totalCount += result.totalCount;
149              appResult.bizExceptionCount += result.bizExceptionCount;
150              appResult.slowCount += result.slowCount;
151              appResult.costTime += result.costTime;
152              appResult.bizTime += result.bizTime;
153              appResult.otherExceptionCount += result.otherExceptionCount;
154              Snapshot snapshot = InternalMetricsFactory.getRegistryInstance(entry.getKey())
155                      .histogram(HISTOGRAM_NAME).getSnapshot();
156              if (application.equals(APPLICATION_STATISTIC)) {
157                  continue;
158              }
159              if (result.totalCount == 0) {
160                  LoggerUtil.accessStatsLog(&quot;[motan-accessStatistic] app: &quot; + application + &quot; module: &quot; + module + &quot; item: &quot; + keys[0]
161                          + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0 max_tps: 0 min_tps: 0&quot;);
162              } else {
163                  LoggerUtil.accessStatsLog(
164                          &quot;[motan-accessStatistic] app: {} module: {} item: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {} max_tps: {} min_tps: {} &quot;,
165                          application, module, keys[0], result.totalCount, result.slowCount,
166                          mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
167                          mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
168                          mbFormat.format(snapshot.get999thPercentile()), result.bizExceptionCount, result.otherExceptionCount,
169                          mbFormat.format(result.costTime / result.totalCount), mbFormat.format(result.bizTime / result.totalCount),
170                          (result.totalCount / MotanConstants.STATISTIC_PEROID), result.maxCount, result.minCount);
171              }
172          }
173          if (!totalResults.isEmpty()) {
174              for (Map.Entry&lt;String, AccessStatisticResult&gt; entry : totalResults.entrySet()) {
175                  String application = entry.getKey().split(SEPARATE)[0];
176                  String module = entry.getKey().split(SEPARATE)[1];
177                  AccessStatisticResult totalResult = entry.getValue();
178                  Snapshot snapshot =
179                          InternalMetricsFactory.getRegistryInstance(entry.getKey())
180                                  .histogram(HISTOGRAM_NAME).getSnapshot();
181                  if (totalResult.totalCount &gt; 0) {
182                      LoggerUtil.accessStatsLog(
183                              &quot;[motan-totalAccessStatistic] app: {} module: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {}&quot;,
184                              application, module, totalResult.totalCount, totalResult.slowCount,
185                              mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
186                              mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
187                              mbFormat.format(snapshot.get999thPercentile()), totalResult.bizExceptionCount,
188                              totalResult.otherExceptionCount, mbFormat.format(totalResult.costTime / totalResult.totalCount),
189                              mbFormat.format(totalResult.bizTime / totalResult.totalCount),
190                              (totalResult.totalCount / MotanConstants.STATISTIC_PEROID));
191                  } else {
192                      LoggerUtil.accessStatsLog(&quot;[motan-totalAccessStatistic] app: &quot; + application + &quot; module: &quot; + module
193                              + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0&quot;);
194                  }
195              }
196          } else {
197              LoggerUtil.accessStatsLog(&quot;[motan-totalAccessStatistic] app: &quot; + URLParamType.application.getValue() + &quot; module: &quot; + URLParamType.module.getValue()
198                      + &quot; total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0&quot;);
199          }
200      }
201      public static void logMemoryStatistic() {
202          LoggerUtil.accessStatsLog(&quot;[motan-memoryStatistic] {} &quot;, memoryStatistic());
203      }
204      public static String memoryStatistic() {
205          Runtime runtime = Runtime.getRuntime();
206          double freeMemory = (double) runtime.freeMemory() / (1024 * 1024);
207          double maxMemory = (double) runtime.maxMemory() / (1024 * 1024);
208          double totalMemory = (double) runtime.totalMemory() / (1024 * 1024);
209          double usedMemory = totalMemory - freeMemory;
210          double percentFree = ((maxMemory - usedMemory) / maxMemory) * 100.0;
211          double percentUsed = 100 - percentFree;
212          DecimalFormat mbFormat = new DecimalFormat(&quot;#0.00&quot;);
213          DecimalFormat percentFormat = new DecimalFormat(&quot;#0.0&quot;);
214          StringBuilder sb = new StringBuilder();
215          sb.append(mbFormat.format(usedMemory)).append(&quot;MB of &quot;).append(mbFormat.format(maxMemory)).append(&quot; MB (&quot;)
216                  .append(percentFormat.format(percentUsed)).append(&quot;%) used&quot;);
217          return sb.toString();
218      }
219      public static void logStatisticCallback() {
220          for (StatisticCallback callback : statisticCallbacks) {
221              try {
222                  String msg = callback.statisticCallback();
223                  if (msg != null &amp;&amp; !msg.isEmpty()) {
224                      LoggerUtil.accessStatsLog(&quot;[motan-statisticCallback] {}&quot;, msg);
225                  }
226              } catch (Exception e) {
227                  LoggerUtil.error(&quot;StatsUtil logStatisticCallback Error: &quot; + e.getMessage(), e);
228              }
229          }
230      }
231      public enum AccessStatus {
232          NORMAL, BIZ_EXCEPTION, OTHER_EXCEPTION
233      }
234  }
235  class AccessStatisticItem {
236      private String name;
237      private int currentIndex;
238      private AtomicInteger[] costTimes = null;
239      private AtomicInteger[] bizProcessTimes = null;
240      private AtomicInteger[] totalCounter = null;
241      private AtomicInteger[] slowCounter = null;
242      private AtomicInteger[] bizExceptionCounter = null;
243      private AtomicInteger[] otherExceptionCounter = null;
244      private Histogram histogram = null;
245      private int length;
246      public AccessStatisticItem(String name, long currentTimeMillis) {
247          this(name, currentTimeMillis, MotanConstants.STATISTIC_PEROID * 2);
248      }
249      public AccessStatisticItem(String name, long currentTimeMillis, int length) {
250          this.name = name;
251          this.costTimes = initAtomicIntegerArr(length);
252          this.bizProcessTimes = initAtomicIntegerArr(length);
253          this.totalCounter = initAtomicIntegerArr(length);
254          this.slowCounter = initAtomicIntegerArr(length);
255          this.bizExceptionCounter = initAtomicIntegerArr(length);
256          this.otherExceptionCounter = initAtomicIntegerArr(length);
257          this.length = length;
258          this.currentIndex = getIndex(currentTimeMillis, length);
259          this.histogram =
260                  InternalMetricsFactory.getRegistryInstance(name)
261                          .histogram(StatsUtil.HISTOGRAM_NAME);
262      }
263      private AtomicInteger[] initAtomicIntegerArr(int size) {
264          AtomicInteger[] arrs = new AtomicInteger[size];
265          for (int i = 0; i &lt; arrs.length; i++) {
266              arrs[i] = new AtomicInteger(0);
267          }
268          return arrs;
269      }
270      void statistic(long currentTimeMillis, long costTimeMillis, long bizProcessTime, int slowCost, AccessStatus accessStatus) {
271          int tempIndex = getIndex(currentTimeMillis, length);
272          if (currentIndex != tempIndex) {
273              synchronized (this) {
274                  if (currentIndex != tempIndex) {
275                      reset(tempIndex);
276                      currentIndex = tempIndex;
277                  }
278              }
279          }
280          costTimes[currentIndex].addAndGet((int) costTimeMillis);
281          bizProcessTimes[currentIndex].addAndGet((int) bizProcessTime);
282          totalCounter[currentIndex].incrementAndGet();
283          if (costTimeMillis &gt;= slowCost) {
284              slowCounter[currentIndex].incrementAndGet();
285          }
286          if (accessStatus == AccessStatus.BIZ_EXCEPTION) {
287              bizExceptionCounter[currentIndex].incrementAndGet();
288          } else if (accessStatus == AccessStatus.OTHER_EXCEPTION) {
289              otherExceptionCounter[currentIndex].incrementAndGet();
290          }
291          histogram.update(costTimeMillis);
292          String[] names = name.split(&quot;\\|&quot;);
293          String appName = names[1] + &quot;|&quot; + names[2];
294          InternalMetricsFactory.getRegistryInstance(appName).histogram(StatsUtil.HISTOGRAM_NAME)
295                  .update(costTimeMillis);
296      }
297      private int getIndex(long currentTimeMillis, int periodSecond) {
298          return (int) ((currentTimeMillis / 1000) % periodSecond);
299      }
300      private void reset(int index) {
301          costTimes[index].set(0);
302          totalCounter[index].set(0);
303          bizProcessTimes[index].set(0);
304          slowCounter[index].set(0);
305          bizExceptionCounter[index].set(0);
306          otherExceptionCounter[index].set(0);
307      }
308      AccessStatisticResult getStatisticResult(long currentTimeMillis, int peroidSecond) {
309          long currentTimeSecond = currentTimeMillis / 1000;
310          currentTimeSecond--; 
311          int startIndex = getIndex(currentTimeSecond * 1000, length);
312          AccessStatisticResult result = new AccessStatisticResult();
313          for (int i = 0; i &lt; peroidSecond; i++) {
314              int currentIndex = (startIndex - i + length) % length;
315              result.costTime += costTimes[currentIndex].get();
316              result.bizTime += bizProcessTimes[currentIndex].get();
317              result.totalCount += totalCounter[currentIndex].get();
318              result.slowCount += slowCounter[currentIndex].get();
319              result.bizExceptionCount += bizExceptionCounter[currentIndex].get();
320              result.otherExceptionCount += otherExceptionCounter[currentIndex].get();
321              if (totalCounter[currentIndex].get() &gt; result.maxCount) {
322                  result.maxCount = totalCounter[currentIndex].get();
323              } else if (totalCounter[currentIndex].get() &lt; result.minCount || result.minCount == -1) {
324                  result.minCount = totalCounter[currentIndex].get();
325              }
326          }
327          return result;
328      }
329      void clearStatistic(long currentTimeMillis, int peroidSecond) {
330          long currentTimeSecond = currentTimeMillis / 1000;
<span onclick='openModal()' class='match'>331          currentTimeSecond--; 
332          int startIndex = getIndex(currentTimeSecond * 1000, length);
333          for (int i = 0; i &lt; peroidSecond; i++) {
</span>334              int currentIndex = (startIndex - i + length) % length;
335              reset(currentIndex);
336          }
337      }
338  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</div>
                </div>
                <div class="column column_space"><pre><code>310          currentTimeSecond--; 
311          int startIndex = getIndex(currentTimeSecond * 1000, length);
312          AccessStatisticResult result = new AccessStatisticResult();
</pre></code></div>
                <div class="column column_space"><pre><code>331          currentTimeSecond--; 
332          int startIndex = getIndex(currentTimeSecond * 1000, length);
333          for (int i = 0; i &lt; peroidSecond; i++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    