
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.535714285714286%, Tokens: 11</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ConfigurableWeightLoadBalance.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.cluster.loadbalance;
2  import com.weibo.api.motan.core.extension.SpiMeta;
3  import com.weibo.api.motan.rpc.Referer;
4  import com.weibo.api.motan.rpc.Request;
5  import com.weibo.api.motan.util.CollectionUtil;
6  import com.weibo.api.motan.util.LoggerUtil;
7  import com.weibo.api.motan.util.MathUtil;
8  import org.apache.commons.lang3.StringUtils;
9  import java.util.*;
10  import java.util.concurrent.ThreadLocalRandom;
11  import java.util.concurrent.atomic.AtomicInteger;
</span>12  @SpiMeta(name = "configurableWeight")
13  public class ConfigurableWeightLoadBalance<T> extends ActiveWeightLoadBalance<T> {
14      @SuppressWarnings("rawtypes")
15      private static final RefererListCacheHolder emptyHolder = new EmptyHolder();
16      @SuppressWarnings("unchecked")
17      private volatile RefererListCacheHolder<T> holder = emptyHolder;
18      private String weightString;
19      @SuppressWarnings("unchecked")
20      @Override
21      public void onRefresh(List<Referer<T>> referers) {
22          super.onRefresh(referers);
23          if (CollectionUtil.isEmpty(referers)) {
24              holder = emptyHolder;
25          } else if (StringUtils.isEmpty(weightString)) {
26              holder = new SingleGroupHolder<T>(referers);
27          } else {
28              holder = new MultiGroupHolder<T>(weightString, referers);
29          }
30      }
31      @Override
32      protected Referer<T> doSelect(Request request) {
33          if (holder == emptyHolder) {
34              return null;
35          }
36          RefererListCacheHolder<T> h = this.holder;
37          Referer<T> r = h.next();
38          if (!r.isAvailable()) {
39              int retryTimes = getReferers().size() - 1;
40              for (int i = 0; i < retryTimes; i++) {
41                  r = h.next();
42                  if (r.isAvailable()) {
43                      break;
44                  }
45              }
46          }
47          if (r.isAvailable()) {
48              return r;
49          } else {
50              noAvailableReferer();
51              return null;
52          }
53      }
54      @Override
55      protected void doSelectToHolder(Request request, List<Referer<T>> refersHolder) {
56          if (holder == emptyHolder) {
57              return;
58          }
59          RefererListCacheHolder<T> h = this.holder;
60          int i = 0, j = 0;
61          while (i++ < getReferers().size()) {
62              Referer<T> r = h.next();
63              if (r.isAvailable()) {
64                  refersHolder.add(r);
65                  if (++j == MAX_REFERER_COUNT) {
66                      return;
67                  }
68              }
69          }
70          if (refersHolder.isEmpty()) {
71              noAvailableReferer();
72          }
73      }
74      private void noAvailableReferer() {
75          LoggerUtil.error(this.getClass().getSimpleName() + " 当前没有可用连接, pool.size=" + getReferers().size());
76      }
77      @Override
78      public void setWeightString(String weightString) {
79          this.weightString = weightString;
80      }
81      static abstract class RefererListCacheHolder<T> {
82          abstract Referer<T> next();
83      }
84      static class EmptyHolder<T> extends RefererListCacheHolder<T> {
85          @Override
86          Referer<T> next() {
87              return null;
88          }
89      }
90      @SuppressWarnings("hiding")
91      class SingleGroupHolder<T> extends RefererListCacheHolder<T> {
92          private int size;
93          private List<Referer<T>> cache;
94          SingleGroupHolder(List<Referer<T>> list) {
95              cache = list;
96              size = list.size();
97              LoggerUtil.info("ConfigurableWeightLoadBalance build new SingleGroupHolder.");
98          }
99          @Override
100          Referer<T> next() {
101              return cache.get(ThreadLocalRandom.current().nextInt(size));
102          }
103      }
104      @SuppressWarnings("hiding")
105      class MultiGroupHolder<T> extends RefererListCacheHolder<T> {
106          private int randomKeySize = 0;
107          private List<String> randomKeyList = new ArrayList<String>();
108          private Map<String, AtomicInteger> cursors = new HashMap<String, AtomicInteger>();
109          private Map<String, List<Referer<T>>> groupReferers = new HashMap<String, List<Referer<T>>>();
110          MultiGroupHolder(String weights, List<Referer<T>> list) {
111              LoggerUtil.info("ConfigurableWeightLoadBalance build new MultiGroupHolder. weights:" + weights);
112              String[] groupsAndWeights = weights.split(",");
113              int[] weightsArr = new int[groupsAndWeights.length];
114              Map<String, Integer> weightsMap = new HashMap<String, Integer>(groupsAndWeights.length);
115              int i = 0;
116              for (String groupAndWeight : groupsAndWeights) {
117                  String[] gw = groupAndWeight.split(":");
118                  if (gw.length == 2) {
119                      Integer w = Integer.valueOf(gw[1]);
120                      weightsMap.put(gw[0], w);
121                      groupReferers.put(gw[0], new ArrayList<Referer<T>>());
122                      weightsArr[i++] = w;
123                  }
124              }
125              int weightGcd = findGcd(weightsArr);
126              if (weightGcd != 1) {
127                  for(Map.Entry<String,Integer> entry: weightsMap.entrySet()) {
128                      weightsMap.put(entry.getKey(),entry.getValue()/weightGcd);
129                  }
130              }
131              for (Map.Entry<String, Integer> entry : weightsMap.entrySet()) {
132                  for (int j = 0; j < entry.getValue(); j++) {
133                      randomKeyList.add(entry.getKey());
134                  }
135              }
136              Collections.shuffle(randomKeyList);
137              randomKeySize = randomKeyList.size();
138              for (String key : weightsMap.keySet()) {
139                  cursors.put(key, new AtomicInteger(0));
140              }
141              for (Referer<T> referer : list) {
142                  groupReferers.get(referer.getServiceUrl().getGroup()).add(referer);
143              }
144          }
145          @Override
146          Referer<T> next() {
147              String group = randomKeyList.get(ThreadLocalRandom.current().nextInt(randomKeySize));
148              AtomicInteger ai = cursors.get(group);
149              List<Referer<T>> referers = groupReferers.get(group);
150              return referers.get(MathUtil.getNonNegative(ai.getAndIncrement()) % referers.size());
151          }
152          private int findGcd(int n, int m) {
153              return (n == 0 || m == 0) ? n + m : findGcd(m, n % m);
154          }
155          private int findGcd(int[] arr) {
156              int i = 0;
157              for (; i < arr.length - 1; i++) {
158                  arr[i + 1] = findGcd(arr[i], arr[i + 1]);
159              }
160              return findGcd(arr[i], arr[i - 1]);
161          }
162      }
163  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-BungeeCord.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package net.md_5.bungee;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import com.google.common.base.Predicate;
5  import com.google.common.collect.Iterables;
6  import com.google.common.collect.Lists;
7  import com.google.common.collect.Sets;
8  import com.google.common.util.concurrent.ThreadFactoryBuilder;
9  import com.google.gson.Gson;
10  import com.google.gson.GsonBuilder;
11  import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
</span>12  import io.netty.bootstrap.ServerBootstrap;
13  import io.netty.channel.Channel;
14  import io.netty.channel.ChannelException;
15  import io.netty.channel.ChannelFuture;
16  import io.netty.channel.ChannelFutureListener;
17  import io.netty.channel.ChannelOption;
18  import io.netty.channel.EventLoopGroup;
19  import io.netty.util.ResourceLeakDetector;
20  import java.io.File;
21  import java.io.FileReader;
22  import java.io.IOException;
23  import java.io.PrintStream;
24  import java.net.InetSocketAddress;
25  import java.net.SocketAddress;
26  import java.text.Format;
27  import java.text.MessageFormat;
28  import java.util.ArrayList;
29  import java.util.Collection;
30  import java.util.Collections;
31  import java.util.Enumeration;
32  import java.util.HashMap;
33  import java.util.HashSet;
34  import java.util.Locale;
35  import java.util.Map;
36  import java.util.MissingResourceException;
37  import java.util.PropertyResourceBundle;
38  import java.util.ResourceBundle;
39  import java.util.Timer;
40  import java.util.TimerTask;
41  import java.util.UUID;
42  import java.util.concurrent.TimeUnit;
43  import java.util.concurrent.locks.ReadWriteLock;
44  import java.util.concurrent.locks.ReentrantLock;
45  import java.util.concurrent.locks.ReentrantReadWriteLock;
46  import java.util.logging.Handler;
47  import java.util.logging.Level;
48  import java.util.logging.Logger;
49  import jline.console.ConsoleReader;
50  import lombok.Getter;
51  import lombok.Setter;
52  import lombok.Synchronized;
53  import net.md_5.bungee.api.CommandSender;
54  import net.md_5.bungee.api.Favicon;
55  import net.md_5.bungee.api.ProxyServer;
56  import net.md_5.bungee.api.ReconnectHandler;
57  import net.md_5.bungee.api.ServerPing;
58  import net.md_5.bungee.api.Title;
59  import net.md_5.bungee.api.chat.BaseComponent;
60  import net.md_5.bungee.api.chat.KeybindComponent;
61  import net.md_5.bungee.api.chat.ScoreComponent;
62  import net.md_5.bungee.api.chat.SelectorComponent;
63  import net.md_5.bungee.api.chat.TextComponent;
64  import net.md_5.bungee.api.chat.TranslatableComponent;
65  import net.md_5.bungee.api.config.ConfigurationAdapter;
66  import net.md_5.bungee.api.config.ListenerInfo;
67  import net.md_5.bungee.api.config.ServerInfo;
68  import net.md_5.bungee.api.connection.ProxiedPlayer;
69  import net.md_5.bungee.api.plugin.Plugin;
70  import net.md_5.bungee.api.plugin.PluginManager;
71  import net.md_5.bungee.chat.ComponentSerializer;
72  import net.md_5.bungee.chat.KeybindComponentSerializer;
73  import net.md_5.bungee.chat.ScoreComponentSerializer;
74  import net.md_5.bungee.chat.SelectorComponentSerializer;
75  import net.md_5.bungee.chat.TextComponentSerializer;
76  import net.md_5.bungee.chat.TranslatableComponentSerializer;
77  import net.md_5.bungee.command.CommandBungee;
78  import net.md_5.bungee.command.CommandEnd;
79  import net.md_5.bungee.command.CommandIP;
80  import net.md_5.bungee.command.CommandPerms;
81  import net.md_5.bungee.command.CommandReload;
82  import net.md_5.bungee.command.ConsoleCommandCompleter;
83  import net.md_5.bungee.command.ConsoleCommandSender;
84  import net.md_5.bungee.compress.CompressFactory;
85  import net.md_5.bungee.conf.Configuration;
86  import net.md_5.bungee.conf.YamlConfig;
87  import net.md_5.bungee.forge.ForgeConstants;
88  import net.md_5.bungee.log.BungeeLogger;
89  import net.md_5.bungee.log.LoggingForwardHandler;
90  import net.md_5.bungee.log.LoggingOutputStream;
91  import net.md_5.bungee.module.ModuleManager;
92  import net.md_5.bungee.netty.PipelineUtils;
93  import net.md_5.bungee.protocol.DefinedPacket;
94  import net.md_5.bungee.protocol.ProtocolConstants;
95  import net.md_5.bungee.protocol.packet.PluginMessage;
96  import net.md_5.bungee.query.RemoteQuery;
97  import net.md_5.bungee.scheduler.BungeeScheduler;
98  import net.md_5.bungee.util.CaseInsensitiveMap;
99  import org.fusesource.jansi.AnsiConsole;
100  import org.slf4j.impl.JDK14LoggerFactory;
101  public class BungeeCord extends ProxyServer
102  {
103      public volatile boolean isRunning;
104      @Getter
105      public final Configuration config = new Configuration();
106      private Map<String, Format> messageFormats;
107      public EventLoopGroup eventLoops;
108      private final Timer saveThread = new Timer( "Reconnect Saver" );
109      private final Timer metricsThread = new Timer( "Metrics Thread" );
110      private final Collection<Channel> listeners = new HashSet<>();
111      private final Map<String, UserConnection> connections = new CaseInsensitiveMap<>();
112      private final Map<UUID, UserConnection> connectionsByOfflineUUID = new HashMap<>();
113      private final Map<UUID, UserConnection> connectionsByUUID = new HashMap<>();
114      private final ReadWriteLock connectionLock = new ReentrantReadWriteLock();
115      private final ReentrantLock shutdownLock = new ReentrantLock();
116      @Getter
117      public final PluginManager pluginManager;
118      @Getter
119      @Setter
120      private ReconnectHandler reconnectHandler;
121      @Getter
122      @Setter
123      private ConfigurationAdapter configurationAdapter = new YamlConfig();
124      private final Collection<String> pluginChannels = new HashSet<>();
125      @Getter
126      private final File pluginsFolder = new File( "plugins" );
127      @Getter
128      private final BungeeScheduler scheduler = new BungeeScheduler();
129      @Getter
130      private final ConsoleReader consoleReader;
131      @Getter
132      private final Logger logger;
133      public final Gson gson = new GsonBuilder()
134              .registerTypeAdapter( BaseComponent.class, new ComponentSerializer() )
135              .registerTypeAdapter( TextComponent.class, new TextComponentSerializer() )
136              .registerTypeAdapter( TranslatableComponent.class, new TranslatableComponentSerializer() )
137              .registerTypeAdapter( KeybindComponent.class, new KeybindComponentSerializer() )
138              .registerTypeAdapter( ScoreComponent.class, new ScoreComponentSerializer() )
139              .registerTypeAdapter( SelectorComponent.class, new SelectorComponentSerializer() )
140              .registerTypeAdapter( ServerPing.PlayerInfo.class, new PlayerInfoSerializer() )
141              .registerTypeAdapter( Favicon.class, Favicon.getFaviconTypeAdapter() ).create();
142      @Getter
143      private ConnectionThrottle connectionThrottle;
144      private final ModuleManager moduleManager = new ModuleManager();
145      {
146          registerChannel( "BungeeCord" );
147      }
148      public static BungeeCord getInstance()
149      {
150          return (BungeeCord) ProxyServer.getInstance();
151      }
152      @SuppressFBWarnings("DM_DEFAULT_ENCODING")
153      public BungeeCord() throws IOException
154      {
155          Preconditions.checkState( new File( "." ).getAbsolutePath().indexOf( '!' ) == -1, "Cannot use BungeeCord in directory with ! in path." );
156          reloadMessages();
157          System.setProperty( "library.jansi.version", "BungeeCord" );
158          AnsiConsole.systemInstall();
159          consoleReader = new ConsoleReader();
160          consoleReader.setExpandEvents( false );
161          consoleReader.addCompleter( new ConsoleCommandCompleter( this ) );
162          logger = new BungeeLogger( "BungeeCord", "proxy.log", consoleReader );
163          JDK14LoggerFactory.LOGGER = logger;
164          Logger rootLogger = Logger.getLogger( "" );
165          for ( Handler handler : rootLogger.getHandlers() )
166          {
167              rootLogger.removeHandler( handler );
168          }
169          rootLogger.addHandler( new LoggingForwardHandler( logger ) );
170          System.setErr( new PrintStream( new LoggingOutputStream( logger, Level.SEVERE ), true ) );
171          System.setOut( new PrintStream( new LoggingOutputStream( logger, Level.INFO ), true ) );
172          pluginManager = new PluginManager( this );
173          getPluginManager().registerCommand( null, new CommandReload() );
174          getPluginManager().registerCommand( null, new CommandEnd() );
175          getPluginManager().registerCommand( null, new CommandIP() );
176          getPluginManager().registerCommand( null, new CommandBungee() );
177          getPluginManager().registerCommand( null, new CommandPerms() );
178          if ( !Boolean.getBoolean( "net.md_5.bungee.native.disable" ) )
179          {
180              if ( EncryptionUtil.nativeFactory.load() )
181              {
182                  logger.info( "Using mbed TLS based native cipher." );
183              } else
184              {
185                  logger.info( "Using standard Java JCE cipher." );
186              }
187              if ( CompressFactory.zlib.load() )
188              {
189                  logger.info( "Using zlib based native compressor." );
190              } else
191              {
192                  logger.info( "Using standard Java compressor." );
193              }
194          }
195      }
196      @SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_BAD_PRACTICE")
197      public void start() throws Exception
198      {
199          System.setProperty( "io.netty.selectorAutoRebuildThreshold", "0" ); 
200          if ( System.getProperty( "io.netty.leakDetectionLevel" ) == null && System.getProperty( "io.netty.leakDetection.level" ) == null )
201          {
202              ResourceLeakDetector.setLevel( ResourceLeakDetector.Level.DISABLED ); 
203          }
204          eventLoops = PipelineUtils.newEventLoopGroup( 0, new ThreadFactoryBuilder().setNameFormat( "Netty IO Thread #%1$d" ).build() );
205          File moduleDirectory = new File( "modules" );
206          moduleManager.load( this, moduleDirectory );
207          pluginManager.detectPlugins( moduleDirectory );
208          pluginsFolder.mkdir();
209          pluginManager.detectPlugins( pluginsFolder );
210          pluginManager.loadPlugins();
211          config.load();
212          if ( config.isForgeSupport() )
213          {
214              registerChannel( ForgeConstants.FML_TAG );
215              registerChannel( ForgeConstants.FML_HANDSHAKE_TAG );
216              registerChannel( ForgeConstants.FORGE_REGISTER );
217              getLogger().warning( "MinecraftForge support is currently unmaintained and may have unresolved issues. Please use at your own risk." );
218          }
219          isRunning = true;
220          pluginManager.enablePlugins();
221          if ( config.getThrottle() > 0 )
222          {
223              connectionThrottle = new ConnectionThrottle( config.getThrottle(), config.getThrottleLimit() );
224          }
225          startListeners();
226          saveThread.scheduleAtFixedRate( new TimerTask()
227          {
228              @Override
229              public void run()
230              {
231                  if ( getReconnectHandler() != null )
232                  {
233                      getReconnectHandler().save();
234                  }
235              }
236          }, 0, TimeUnit.MINUTES.toMillis( 5 ) );
237          metricsThread.scheduleAtFixedRate( new Metrics(), 0, TimeUnit.MINUTES.toMillis( Metrics.PING_INTERVAL ) );
238          Runtime.getRuntime().addShutdownHook( new Thread()
239          {
240              @Override
241              public void run()
242              {
243                  independentThreadStop( getTranslation( "restart" ), false );
244              }
245          } );
246      }
247      public void startListeners()
248      {
249          for ( final ListenerInfo info : config.getListeners() )
250          {
251              if ( info.isProxyProtocol() )
252              {
253                  getLogger().log( Level.WARNING, "Using PROXY protocol for listener {0}, please ensure this listener is adequately firewalled.", info.getSocketAddress() );
254                  if ( connectionThrottle != null )
255                  {
256                      connectionThrottle = null;
257                      getLogger().log( Level.WARNING, "Since PROXY protocol is in use, internal connection throttle has been disabled." );
258                  }
259              }
260              ChannelFutureListener listener = new ChannelFutureListener()
261              {
262                  @Override
263                  public void operationComplete(ChannelFuture future) throws Exception
264                  {
265                      if ( future.isSuccess() )
266                      {
267                          listeners.add( future.channel() );
268                          getLogger().log( Level.INFO, "Listening on {0}", info.getSocketAddress() );
269                      } else
270                      {
271                          getLogger().log( Level.WARNING, "Could not bind to host " + info.getSocketAddress(), future.cause() );
272                      }
273                  }
274              };
275              new ServerBootstrap()
276                      .channel( PipelineUtils.getServerChannel( info.getSocketAddress() ) )
277                      .option( ChannelOption.SO_REUSEADDR, true ) 
278                      .childAttr( PipelineUtils.LISTENER, info )
279                      .childHandler( PipelineUtils.SERVER_CHILD )
280                      .group( eventLoops )
281                      .localAddress( info.getSocketAddress() )
282                      .bind().addListener( listener );
283              if ( info.isQueryEnabled() )
284              {
285                  Preconditions.checkArgument( info.getSocketAddress() instanceof InetSocketAddress, "Can only create query listener on UDP address" );
286                  ChannelFutureListener bindListener = new ChannelFutureListener()
287                  {
288                      @Override
289                      public void operationComplete(ChannelFuture future) throws Exception
290                      {
291                          if ( future.isSuccess() )
292                          {
293                              listeners.add( future.channel() );
294                              getLogger().log( Level.INFO, "Started query on {0}", future.channel().localAddress() );
295                          } else
296                          {
297                              getLogger().log( Level.WARNING, "Could not bind to host " + info.getSocketAddress(), future.cause() );
298                          }
299                      }
300                  };
301                  new RemoteQuery( this, info ).start( PipelineUtils.getDatagramChannel(), new InetSocketAddress( info.getHost().getAddress(), info.getQueryPort() ), eventLoops, bindListener );
302              }
303          }
304      }
305      public void stopListeners()
306      {
307          for ( Channel listener : listeners )
308          {
309              getLogger().log( Level.INFO, "Closing listener {0}", listener );
310              try
311              {
312                  listener.close().syncUninterruptibly();
313              } catch ( ChannelException ex )
314              {
315                  getLogger().severe( "Could not close listen thread" );
316              }
317          }
318          listeners.clear();
319      }
320      @Override
321      public void stop()
322      {
323          stop( getTranslation( "restart" ) );
324      }
325      @Override
326      public void stop(final String reason)
327      {
328          new Thread( "Shutdown Thread" )
329          {
330              @Override
331              public void run()
332              {
333                  independentThreadStop( reason, true );
334              }
335          }.start();
336      }
337      @SuppressFBWarnings("DM_EXIT")
338      @SuppressWarnings("TooBroadCatch")
339      private void independentThreadStop(final String reason, boolean callSystemExit)
340      {
341          shutdownLock.lock();
342          if ( !isRunning )
343          {
344              shutdownLock.unlock();
345              return;
346          }
347          isRunning = false;
348          stopListeners();
349          getLogger().info( "Closing pending connections" );
350          connectionLock.readLock().lock();
351          try
352          {
353              getLogger().log( Level.INFO, "Disconnecting {0} connections", connections.size() );
354              for ( UserConnection user : connections.values() )
355              {
356                  user.disconnect( reason );
357              }
358          } finally
359          {
360              connectionLock.readLock().unlock();
361          }
362          try
363          {
364              Thread.sleep( 500 );
365          } catch ( InterruptedException ex )
366          {
367          }
368          if ( reconnectHandler != null )
369          {
370              getLogger().info( "Saving reconnect locations" );
371              reconnectHandler.save();
372              reconnectHandler.close();
373          }
374          saveThread.cancel();
375          metricsThread.cancel();
376          getLogger().info( "Disabling plugins" );
377          for ( Plugin plugin : Lists.reverse( new ArrayList<>( pluginManager.getPlugins() ) ) )
378          {
379              try
380              {
381                  plugin.onDisable();
382                  for ( Handler handler : plugin.getLogger().getHandlers() )
383                  {
384                      handler.close();
385                  }
386              } catch ( Throwable t )
387              {
388                  getLogger().log( Level.SEVERE, "Exception disabling plugin " + plugin.getDescription().getName(), t );
389              }
390              getScheduler().cancel( plugin );
391              plugin.getExecutorService().shutdownNow();
392          }
393          getLogger().info( "Closing IO threads" );
394          eventLoops.shutdownGracefully();
395          try
396          {
397              eventLoops.awaitTermination( Long.MAX_VALUE, TimeUnit.NANOSECONDS );
398          } catch ( InterruptedException ex )
399          {
400          }
401          getLogger().info( "Thank you and goodbye" );
402          for ( Handler handler : getLogger().getHandlers() )
403          {
404              handler.close();
405          }
406          shutdownLock.unlock();
407          if ( callSystemExit )
408          {
409              System.exit( 0 );
410          }
411      }
412      public void broadcast(DefinedPacket packet)
413      {
414          connectionLock.readLock().lock();
415          try
416          {
417              for ( UserConnection con : connections.values() )
418              {
419                  con.unsafe().sendPacket( packet );
420              }
421          } finally
422          {
423              connectionLock.readLock().unlock();
424          }
425      }
426      @Override
427      public String getName()
428      {
429          return "BungeeCord";
430      }
431      @Override
432      public String getVersion()
433      {
434          return ( BungeeCord.class.getPackage().getImplementationVersion() == null ) ? "unknown" : BungeeCord.class.getPackage().getImplementationVersion();
435      }
436      public final void reloadMessages()
437      {
438          Map<String, Format> cachedFormats = new HashMap<>();
439          File file = new File( "messages.properties" );
440          if ( file.isFile() )
441          {
442              try ( FileReader rd = new FileReader( file ) )
443              {
444                  cacheResourceBundle( cachedFormats, new PropertyResourceBundle( rd ) );
445              } catch ( IOException ex )
446              {
447                  getLogger().log( Level.SEVERE, "Could not load custom messages.properties", ex );
448              }
449          }
450          ResourceBundle baseBundle;
451          try
452          {
453              baseBundle = ResourceBundle.getBundle( "messages" );
454          } catch ( MissingResourceException ex )
455          {
456              baseBundle = ResourceBundle.getBundle( "messages", Locale.ENGLISH );
457          }
458          cacheResourceBundle( cachedFormats, baseBundle );
459          messageFormats = Collections.unmodifiableMap( cachedFormats );
460      }
461      private void cacheResourceBundle(Map<String, Format> map, ResourceBundle resourceBundle)
462      {
463          Enumeration<String> keys = resourceBundle.getKeys();
464          while ( keys.hasMoreElements() )
465          {
466              map.computeIfAbsent( keys.nextElement(), (key) -> new MessageFormat( resourceBundle.getString( key ) ) );
467          }
468      }
469      @Override
470      public String getTranslation(String name, Object... args)
471      {
472          Format format = messageFormats.get( name );
473          return ( format != null ) ? format.format( args ) : "<translation '" + name + "' missing>";
474      }
475      @Override
476      @SuppressWarnings("unchecked")
477      public Collection<ProxiedPlayer> getPlayers()
478      {
479          connectionLock.readLock().lock();
480          try
481          {
482              return Collections.unmodifiableCollection( new HashSet( connections.values() ) );
483          } finally
484          {
485              connectionLock.readLock().unlock();
486          }
487      }
488      @Override
489      public int getOnlineCount()
490      {
491          return connections.size();
492      }
493      @Override
494      public ProxiedPlayer getPlayer(String name)
495      {
496          connectionLock.readLock().lock();
497          try
498          {
499              return connections.get( name );
500          } finally
501          {
502              connectionLock.readLock().unlock();
503          }
504      }
505      public UserConnection getPlayerByOfflineUUID(UUID uuid)
506      {
507          if ( uuid.version() != 3 )
508          {
509              return null;
510          }
511          connectionLock.readLock().lock();
512          try
513          {
514              return connectionsByOfflineUUID.get( uuid );
515          } finally
516          {
517              connectionLock.readLock().unlock();
518          }
519      }
520      @Override
521      public ProxiedPlayer getPlayer(UUID uuid)
522      {
523          connectionLock.readLock().lock();
524          try
525          {
526              return connectionsByUUID.get( uuid );
527          } finally
528          {
529              connectionLock.readLock().unlock();
530          }
531      }
532      @Override
533      public Map<String, ServerInfo> getServers()
534      {
535          return config.getServers();
536      }
537      @Override
538      public ServerInfo getServerInfo(String name)
539      {
540          return getServers().get( name );
541      }
542      @Override
543      @Synchronized("pluginChannels")
544      public void registerChannel(String channel)
545      {
546          pluginChannels.add( channel );
547      }
548      @Override
549      @Synchronized("pluginChannels")
550      public void unregisterChannel(String channel)
551      {
552          pluginChannels.remove( channel );
553      }
554      @Override
555      @Synchronized("pluginChannels")
556      public Collection<String> getChannels()
557      {
558          return Collections.unmodifiableCollection( pluginChannels );
559      }
560      public PluginMessage registerChannels(int protocolVersion)
561      {
562          if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 )
563          {
564              return new PluginMessage( "minecraft:register", String.join( "\00", Iterables.transform( pluginChannels, PluginMessage.MODERNISE ) ).getBytes( Charsets.UTF_8 ), false );
565          }
566          return new PluginMessage( "REGISTER", String.join( "\00", pluginChannels ).getBytes( Charsets.UTF_8 ), false );
567      }
568      @Override
569      public int getProtocolVersion()
570      {
571          return ProtocolConstants.SUPPORTED_VERSION_IDS.get( ProtocolConstants.SUPPORTED_VERSION_IDS.size() - 1 );
572      }
573      @Override
574      public String getGameVersion()
575      {
576          return ProtocolConstants.SUPPORTED_VERSIONS.get( 0 ) + "-" + ProtocolConstants.SUPPORTED_VERSIONS.get( ProtocolConstants.SUPPORTED_VERSIONS.size() - 1 );
577      }
578      @Override
579      public ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted)
580      {
581          return constructServerInfo( name, (SocketAddress) address, motd, restricted );
582      }
583      @Override
584      public ServerInfo constructServerInfo(String name, SocketAddress address, String motd, boolean restricted)
585      {
586          return new BungeeServerInfo( name, address, motd, restricted );
587      }
588      @Override
589      public CommandSender getConsole()
590      {
591          return ConsoleCommandSender.getInstance();
592      }
593      @Override
594      public void broadcast(String message)
595      {
596          broadcast( TextComponent.fromLegacyText( message ) );
597      }
598      @Override
599      public void broadcast(BaseComponent... message)
600      {
601          getConsole().sendMessage( BaseComponent.toLegacyText( message ) );
602          for ( ProxiedPlayer player : getPlayers() )
603          {
604              player.sendMessage( message );
605          }
606      }
607      @Override
608      public void broadcast(BaseComponent message)
609      {
610          getConsole().sendMessage( message.toLegacyText() );
611          for ( ProxiedPlayer player : getPlayers() )
612          {
613              player.sendMessage( message );
614          }
615      }
616      public void addConnection(UserConnection con)
617      {
618          UUID offlineId = con.getPendingConnection().getOfflineId();
619          if ( offlineId != null && offlineId.version() != 3 )
620          {
621              throw new IllegalArgumentException( "Offline UUID must be a name-based UUID" );
622          }
623          connectionLock.writeLock().lock();
624          try
625          {
626              connections.put( con.getName(), con );
627              connectionsByUUID.put( con.getUniqueId(), con );
628              connectionsByOfflineUUID.put( offlineId, con );
629          } finally
630          {
631              connectionLock.writeLock().unlock();
632          }
633      }
634      public void removeConnection(UserConnection con)
635      {
636          connectionLock.writeLock().lock();
637          try
638          {
639              if ( connections.get( con.getName() ) == con )
640              {
641                  connections.remove( con.getName() );
642                  connectionsByUUID.remove( con.getUniqueId() );
643                  connectionsByOfflineUUID.remove( con.getPendingConnection().getOfflineId() );
644              }
645          } finally
646          {
647              connectionLock.writeLock().unlock();
648          }
649      }
650      @Override
651      public Collection<String> getDisabledCommands()
652      {
653          return config.getDisabledCommands();
654      }
655      @Override
656      public Collection<ProxiedPlayer> matchPlayer(final String partialName)
657      {
658          Preconditions.checkNotNull( partialName, "partialName" );
659          ProxiedPlayer exactMatch = getPlayer( partialName );
660          if ( exactMatch != null )
661          {
662              return Collections.singleton( exactMatch );
663          }
664          return Sets.newHashSet( Iterables.filter( getPlayers(), new Predicate<ProxiedPlayer>()
665          {
666              @Override
667              public boolean apply(ProxiedPlayer input)
668              {
669                  return ( input == null ) ? false : input.getName().toLowerCase( Locale.ROOT ).startsWith( partialName.toLowerCase( Locale.ROOT ) );
670              }
671          } ) );
672      }
673      @Override
674      public Title createTitle()
675      {
676          return new BungeeTitle();
677      }
678  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ConfigurableWeightLoadBalance.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-BungeeCord.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.cluster.loadbalance;
2  import com.weibo.api.motan.core.extension.SpiMeta;
3  import com.weibo.api.motan.rpc.Referer;
4  import com.weibo.api.motan.rpc.Request;
5  import com.weibo.api.motan.util.CollectionUtil;
6  import com.weibo.api.motan.util.LoggerUtil;
7  import com.weibo.api.motan.util.MathUtil;
8  import org.apache.commons.lang3.StringUtils;
9  import java.util.*;
10  import java.util.concurrent.ThreadLocalRandom;
11  import java.util.concurrent.atomic.AtomicInteger;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package net.md_5.bungee;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import com.google.common.base.Predicate;
5  import com.google.common.collect.Iterables;
6  import com.google.common.collect.Lists;
7  import com.google.common.collect.Sets;
8  import com.google.common.util.concurrent.ThreadFactoryBuilder;
9  import com.google.gson.Gson;
10  import com.google.gson.GsonBuilder;
11  import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    