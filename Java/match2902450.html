<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AccessControlMaySeeTest.java &amp; IndicesQueryCache.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AccessControlMaySeeTest.java &amp; IndicesQueryCache.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AccessControlMaySeeTest.java (17.073172%)<th>IndicesQueryCache.java (5.0239234%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-49)<td><a href="#" name="0">(31-54)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AccessControlMaySeeTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <a name="0"></a>
22 package io.crate.auth;
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static org.hamcrest.Matchers.contains;
24 import static org.hamcrest.Matchers.hasItem;
25 import static org.hamcrest.core.Is.is;
26 import java.util.ArrayList;
27 import java.util.List;
28 import java.util.Set;
29 import org.elasticsearch.common.util.CollectionUtils;
30 import org.elasticsearch.test.ESTestCase;
31 import org.hamcrest.Matcher;
32 import org.junit.Before;
33 import org.junit.Test;
34 import io.crate.action.sql.SessionContext;
35 import io.crate.exceptions.RelationValidationException;
36 import io.crate.exceptions.SchemaUnknownException;
37 import io.crate.exceptions.UnhandledServerException;
38 import io.crate.exceptions.UnsupportedFeatureException;
39 import io.crate.metadata.RelationName;
40 import io.crate.user.Privilege;
41 import io.crate.user.User;
42 public class AccessControlMaySeeTest extends ESTestCase {
43     private List&lt;List&lt;Object&gt;&gt; validationCallArguments</b></font>;
44     private User user;
45     private AccessControl accessControl;
46     @Before
47     public void setUpUserAndValidator() {
48         validationCallArguments = new ArrayList&lt;&gt;();
49         user = new User("normal", Set.of(), Set.of(), null) {
50             @Override
51             public boolean hasAnyPrivilege(Privilege.Clazz clazz, String ident) {
52                 validationCallArguments.add(CollectionUtils.arrayAsArrayList(clazz, ident, user.name()));
53                 return true;
54             }
55         };
56         accessControl = new AccessControlImpl(userName -&gt; user, new SessionContext(user));
57     }
58     @SuppressWarnings("unchecked")
59     private void assertAskedAnyForCluster() {
60         Matcher&lt;Iterable&lt;?&gt;&gt; matcher = (Matcher) hasItem(contains(Privilege.Clazz.CLUSTER, null, user.name()));
61         assertThat(validationCallArguments, matcher);
62     }
63     @SuppressWarnings("unchecked")
64     private void assertAskedAnyForSchema(String ident) {
65         Matcher&lt;Iterable&lt;?&gt;&gt; matcher = (Matcher) hasItem(contains(Privilege.Clazz.SCHEMA, ident, user.name()));
66         assertThat(validationCallArguments, matcher);
67     }
68     @SuppressWarnings("unchecked")
69     private void assertAskedAnyForTable(String ident) {
70         Matcher&lt;Iterable&lt;?&gt;&gt; matcher = (Matcher) hasItem(contains(Privilege.Clazz.TABLE, ident, user.name()));
71         assertThat(validationCallArguments, matcher);
72     }
73     @Test
74     public void testTableScopeException() throws Exception {
75         accessControl.ensureMaySee(new RelationValidationException(List.of(
76             RelationName.fromIndexName("users"),
77             RelationName.fromIndexName("my_schema.foo")
78         ), "bla"));
79         assertAskedAnyForTable("doc.users");
80         assertAskedAnyForTable("my_schema.foo");
81     }
82     @Test
83     public void testSchemaScopeException() throws Exception {
84         accessControl.ensureMaySee(new SchemaUnknownException("my_schema"));
85         assertAskedAnyForSchema("my_schema");
86     }
87     @Test
88     public void testClusterScopeException() throws Exception {
89         accessControl.ensureMaySee(new UnsupportedFeatureException("unsupported"));
90         assertAskedAnyForCluster();
91     }
92     @Test
93     public void testUnscopedException() throws Exception {
94         accessControl.ensureMaySee(new UnhandledServerException("unhandled"));
95         assertThat(validationCallArguments.size(), is(0));
96     }
97 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IndicesQueryCache.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Elasticsearch under one or more contributor
3  * license agreements. See the NOTICE file distributed with
4  * this work for additional information regarding copyright
5  * ownership. Elasticsearch licenses this file to you under
6  * the Apache License, Version 2.0 (the "License"); you may
7  * not use this file except in compliance with the License.
8  * You may obtain a copy of the License at
9  *
10  *    http://www.apache.org/licenses/LICENSE-2.0
11  *
12  * Unless required by applicable law or agreed to in writing,
13  * software distributed under the License is distributed on an
14  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
15  * KIND, either express or implied.  See the License for the
16  * specific language governing permissions and limitations
17  * under the License.
18  */
19 package org.elasticsearch.indices;
20 import org.apache.logging.log4j.LogManager;
21 import org.apache.logging.log4j.Logger;
22 import org.apache.lucene.index.LeafReaderContext;
23 import org.apache.lucene.index.Term;
24 import org.apache.lucene.search.BulkScorer;
25 import org.apache.lucene.search.Explanation;
26 <a name="0"></a>import org.apache.lucene.search.LRUQueryCache;
27 import org.apache.lucene.search.Query;
28 import org.apache.lucene.search.QueryCache;
29 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.apache.lucene.search.QueryCachingPolicy;
30 import org.apache.lucene.search.Scorer;
31 import org.apache.lucene.search.ScorerSupplier;
32 import org.apache.lucene.search.Weight;
33 import org.elasticsearch.common.lucene.ShardCoreKeyMap;
34 import org.elasticsearch.common.settings.Setting;
35 import org.elasticsearch.common.settings.Setting.Property;
36 import org.elasticsearch.common.settings.Settings;
37 import org.elasticsearch.common.unit.ByteSizeValue;
38 import org.elasticsearch.index.cache.query.QueryCacheStats;
39 import org.elasticsearch.index.shard.ShardId;
40 import java.io.Closeable;
41 import java.io.IOException;
42 import java.util.HashMap;
43 import java.util.IdentityHashMap;
44 import java.util.Map;
45 import java.util.Set;
46 import java.util.concurrent.ConcurrentHashMap;
47 import java.util.function.Predicate;
48 public class IndicesQueryCache implements QueryCache, Closeable {
49     private static final Logger LOGGER = LogManager.getLogger(IndicesQueryCache.class)</b></font>;
50     public static final Setting&lt;ByteSizeValue&gt; INDICES_CACHE_QUERY_SIZE_SETTING =
51             Setting.memorySizeSetting("indices.queries.cache.size", "10%", Property.NodeScope);
52     public static final Setting&lt;Integer&gt; INDICES_CACHE_QUERY_COUNT_SETTING =
53             Setting.intSetting("indices.queries.cache.count", 10_000, 1, Property.NodeScope);
54     public static final Setting&lt;Boolean&gt; INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING =
55             Setting.boolSetting("indices.queries.cache.all_segments", false, Property.NodeScope);
56     private final LRUQueryCache cache;
57     private final ShardCoreKeyMap shardKeyMap = new ShardCoreKeyMap();
58     private final Map&lt;ShardId, Stats&gt; shardStats = new ConcurrentHashMap&lt;&gt;();
59     private volatile long sharedRamBytesUsed;
60     private final Map&lt;Object, StatsAndCount&gt; stats2 = new IdentityHashMap&lt;&gt;();
61     public IndicesQueryCache(Settings settings) {
62         final ByteSizeValue size = INDICES_CACHE_QUERY_SIZE_SETTING.get(settings);
63         final int count = INDICES_CACHE_QUERY_COUNT_SETTING.get(settings);
64         LOGGER.debug("using [node] query cache with size [{}] max filter count [{}]",
65                 size, count);
66         if (INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING.get(settings)) {
67             cache = new ElasticsearchLRUQueryCache(count, size.getBytes(), context -&gt; true, 1f);
68         } else {
69             cache = new ElasticsearchLRUQueryCache(count, size.getBytes());
70         }
71         sharedRamBytesUsed = 0;
72     }
73     public QueryCacheStats getStats(ShardId shard) {
74         final Map&lt;ShardId, QueryCacheStats&gt; stats = new HashMap&lt;&gt;();
75         for (Map.Entry&lt;ShardId, Stats&gt; entry : shardStats.entrySet()) {
76             stats.put(entry.getKey(), entry.getValue().toQueryCacheStats());
77         }
78         QueryCacheStats shardStats = new QueryCacheStats();
79         QueryCacheStats info = stats.get(shard);
80         if (info == null) {
81             info = new QueryCacheStats();
82         }
83         shardStats.add(info);
84         long totalSize = 0;
85         for (QueryCacheStats s : stats.values()) {
86             totalSize += s.getCacheSize();
87         }
88         final double weight = totalSize == 0
89                 ? 1d / stats.size()
90                 : ((double) shardStats.getCacheSize()) / totalSize;
91         final long additionalRamBytesUsed = Math.round(weight * sharedRamBytesUsed);
92         shardStats.add(new QueryCacheStats(additionalRamBytesUsed, 0, 0, 0, 0));
93         return shardStats;
94     }
95     @Override
96     public Weight doCache(Weight weight, QueryCachingPolicy policy) {
97         while (weight instanceof CachingWeightWrapper) {
98             weight = ((CachingWeightWrapper) weight).in;
99         }
100         final Weight in = cache.doCache(weight, policy);
101         return new CachingWeightWrapper(in);
102     }
103     private class CachingWeightWrapper extends Weight {
104         private final Weight in;
105         protected CachingWeightWrapper(Weight in) {
106             super(in.getQuery());
107             this.in = in;
108         }
109         @Override
110         public void extractTerms(Set&lt;Term&gt; terms) {
111             in.extractTerms(terms);
112         }
113         @Override
114         public Explanation explain(LeafReaderContext context, int doc) throws IOException {
115             shardKeyMap.add(context.reader());
116             return in.explain(context, doc);
117         }
118         @Override
119         public Scorer scorer(LeafReaderContext context) throws IOException {
120             shardKeyMap.add(context.reader());
121             return in.scorer(context);
122         }
123         @Override
124         public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {
125             shardKeyMap.add(context.reader());
126             return in.scorerSupplier(context);
127         }
128         @Override
129         public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
130             shardKeyMap.add(context.reader());
131             return in.bulkScorer(context);
132         }
133         @Override
134         public boolean isCacheable(LeafReaderContext ctx) {
135             return in.isCacheable(ctx);
136         }
137     }
138     public void clearIndex(String index) {
139         final Set&lt;Object&gt; coreCacheKeys = shardKeyMap.getCoreKeysForIndex(index);
140         for (Object coreKey : coreCacheKeys) {
141             cache.clearCoreCacheKey(coreKey);
142         }
143         if (cache.getCacheSize() == 0) {
144             cache.clear();
145         }
146     }
147     @Override
148     public void close() {
149         assert shardKeyMap.size() == 0 : shardKeyMap.size();
150         assert shardStats.isEmpty() : shardStats.keySet();
151         assert stats2.isEmpty() : stats2;
152         cache.clear();
153     }
154     private static class Stats implements Cloneable {
155         volatile long ramBytesUsed;
156         volatile long hitCount;
157         volatile long missCount;
158         volatile long cacheCount;
159         volatile long cacheSize;
160         QueryCacheStats toQueryCacheStats() {
161             return new QueryCacheStats(ramBytesUsed, hitCount, missCount, cacheCount, cacheSize);
162         }
163     }
164     private static class StatsAndCount {
165         int count;
166         final Stats stats;
167         StatsAndCount(Stats stats) {
168             this.stats = stats;
169             this.count = 0;
170         }
171     }
172     private boolean empty(Stats stats) {
173         if (stats == null) {
174             return true;
175         }
176         return stats.cacheSize == 0 &amp;&amp; stats.ramBytesUsed == 0;
177     }
178     public void onClose(ShardId shardId) {
179         assert empty(shardStats.get(shardId));
180         shardStats.remove(shardId);
181     }
182     private class ElasticsearchLRUQueryCache extends LRUQueryCache {
183         ElasticsearchLRUQueryCache(int maxSize, long maxRamBytesUsed, Predicate&lt;LeafReaderContext&gt; leavesToCache, float skipFactor) {
184             super(maxSize, maxRamBytesUsed, leavesToCache, skipFactor);
185         }
186         ElasticsearchLRUQueryCache(int maxSize, long maxRamBytesUsed) {
187             super(maxSize, maxRamBytesUsed);
188         }
189         private Stats getStats(Object coreKey) {
190             final ShardId shardId = shardKeyMap.getShardId(coreKey);
191             if (shardId == null) {
192                 return null;
193             }
194             return shardStats.get(shardId);
195         }
196         private Stats getOrCreateStats(Object coreKey) {
197             final ShardId shardId = shardKeyMap.getShardId(coreKey);
198             Stats stats = shardStats.get(shardId);
199             if (stats == null) {
200                 stats = new Stats();
201                 shardStats.put(shardId, stats);
202             }
203             return stats;
204         }
205         @Override
206         protected void onClear() {
207             super.onClear();
208             for (Stats stats : shardStats.values()) {
209                 stats.cacheSize = 0;
210                 stats.ramBytesUsed = 0;
211             }
212             sharedRamBytesUsed = 0;
213         }
214         @Override
215         protected void onQueryCache(Query filter, long ramBytesUsed) {
216             super.onQueryCache(filter, ramBytesUsed);
217             sharedRamBytesUsed += ramBytesUsed;
218         }
219         @Override
220         protected void onQueryEviction(Query filter, long ramBytesUsed) {
221             super.onQueryEviction(filter, ramBytesUsed);
222             sharedRamBytesUsed -= ramBytesUsed;
223         }
224         @Override
225         protected void onDocIdSetCache(Object readerCoreKey, long ramBytesUsed) {
226             super.onDocIdSetCache(readerCoreKey, ramBytesUsed);
227             final Stats shardStats = getOrCreateStats(readerCoreKey);
228             shardStats.cacheSize += 1;
229             shardStats.cacheCount += 1;
230             shardStats.ramBytesUsed += ramBytesUsed;
231             StatsAndCount statsAndCount = stats2.get(readerCoreKey);
232             if (statsAndCount == null) {
233                 statsAndCount = new StatsAndCount(shardStats);
234                 stats2.put(readerCoreKey, statsAndCount);
235             }
236             statsAndCount.count += 1;
237         }
238         @Override
239         protected void onDocIdSetEviction(Object readerCoreKey, int numEntries, long sumRamBytesUsed) {
240             super.onDocIdSetEviction(readerCoreKey, numEntries, sumRamBytesUsed);
241             if (numEntries &gt; 0) {
242                 final StatsAndCount statsAndCount = stats2.get(readerCoreKey);
243                 final Stats shardStats = statsAndCount.stats;
244                 shardStats.cacheSize -= numEntries;
245                 shardStats.ramBytesUsed -= sumRamBytesUsed;
246                 statsAndCount.count -= numEntries;
247                 if (statsAndCount.count == 0) {
248                     stats2.remove(readerCoreKey);
249                 }
250             }
251         }
252         @Override
253         protected void onHit(Object readerCoreKey, Query filter) {
254             super.onHit(readerCoreKey, filter);
255             final Stats shardStats = getStats(readerCoreKey);
256             shardStats.hitCount += 1;
257         }
258         @Override
259         protected void onMiss(Object readerCoreKey, Query filter) {
260             super.onMiss(readerCoreKey, filter);
261             final Stats shardStats = getOrCreateStats(readerCoreKey);
262             shardStats.missCount += 1;
263         }
264     }
265 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
