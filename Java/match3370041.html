<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RemoveCustomsCommandIT.java &amp; RestoreService.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RemoveCustomsCommandIT.java &amp; RestoreService.java
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RemoveCustomsCommandIT.java (26.05042%)<th>RestoreService.java (3.606748%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-57)<td><a href="#" name="0">(317-322)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(79-83)<td><a href="#" name="1">(291-299)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(83-86)<td><a href="#" name="2">(342-348)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(19-32)<td><a href="#" name="3">(20-31)</a><td align="center"><font color="#af0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(123-127)<td><a href="#" name="4">(910-917)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RemoveCustomsCommandIT.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.cluster.coordination;
2 import static org.hamcrest.Matchers.containsString;
3 import org.elasticsearch.ElasticsearchException;
4 import org.elasticsearch.cli.MockTerminal;
5 import org.elasticsearch.cli.UserException;
6 import org.elasticsearch.common.settings.Settings;
7 import org.elasticsearch.env.Environment;
8 import org.elasticsearch.env.TestEnvironment;
9 import org.elasticsearch.test.ESIntegTestCase;
10 import org.junit.Test;
11 import</b></font> joptsimple.OptionSet;
12 @ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0, autoManageMasterNodes = false)
13 public class RemoveCustomsCommandIT extends ESIntegTestCase {
14     @Test
15     public void testRemoveCustomsAbortedByUser() throws Exception {
16         internalCluster().setBootstrapMasterNodeIndex(0);
17         String node = internalCluster().startNode();
18         Settings dataPathSettings = internalCluster().dataPathSettings(node);
19         ensureStableCluster(1);
20         internalCluster().stopRandomDataNode();
21         Environment environment = TestEnvironment.newEnvironment(
22             Settings.builder().put(internalCluster().getDefaultSettings()).put(dataPathSettings).build());
23         expectThrows(() -&gt; removeCustoms(environment, true, new String[]{ "index-graveyard" }),
24             ElasticsearchNodeCommand.ABORTED_BY_USER_MSG);
25     }
26 <a name="0"></a>
27     @Test
28     public void testRemoveCustomsSuccessful() throws Exception {
29         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>internalCluster().setBootstrapMasterNodeIndex(0);
30         String node = internalCluster().startNode();
31         createIndex("test");
32         client().admin().indices().prepareDelete("test").get();
33         assertEquals(1, client().admin().cluster().prepareState().get().getState</b></font>().metadata().indexGraveyard().getTombstones().size());
34         Settings dataPathSettings = internalCluster().dataPathSettings(node);
35         ensureStableCluster(1);
36         internalCluster().stopRandomDataNode();
37         Environment environment = TestEnvironment.newEnvironment(
38             Settings.builder().put(internalCluster().getDefaultSettings()).put(dataPathSettings).build());
39         MockTerminal terminal = removeCustoms(environment, false,
40             randomBoolean() ?
41                 new String[]{ "index-graveyard" } :
42                 new String[]{ "index-*" }
43             );
44         assertThat(terminal.getOutput(), containsString(RemoveCustomsCommand.CUSTOMS_REMOVED_MSG));
45         assertThat(terminal.getOutput(), containsString("The following customs will be removed:"));
46         assertThat(terminal.getOutput(), containsString("index-graveyard"));
47         internalCluster().startNode(dataPathSettings);
48         assertEquals(0, client().admin().cluster().prepareState().get().getState().metadata().indexGraveyard().getTombstones().size());
49     }
50 <a name="1"></a>
51     @Test
52     public void testCustomDoesNotMatch() throws Exception {
53         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>internalCluster().setBootstrapMasterNodeIndex(0);
54 <a name="2"></a>        String node = internalCluster().startNode();
55         createIndex("test");
56         client().admin().indices().prepareDelete("test").get();
57         assertEquals(1, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>client().admin().cluster().prepareState().get().getState().metadata().indexGraveyard().getTombstones</b></font>().size());
58         Settings dataPathSettings = internalCluster().dataPathSettings(node);
59         ensureStableCluster(1);
60         internalCluster</b></font>().stopRandomDataNode();
61         Environment environment = TestEnvironment.newEnvironment(
62             Settings.builder().put(internalCluster().getDefaultSettings()).put(dataPathSettings).build());
63         UserException ex = expectThrows(UserException.class, () -&gt; removeCustoms(environment, false,
64             new String[]{ "index-greveyard-with-typos" }));
65         assertThat(ex.getMessage(), containsString("No custom metadata matching [index-greveyard-with-typos] were " +
66             "found on this node"));
67     }
68     private MockTerminal executeCommand(ElasticsearchNodeCommand command, Environment environment, boolean abort, String... args)
69         throws Exception {
70         final MockTerminal terminal = new MockTerminal();
71         final OptionSet options = command.getParser().parse(args);
72         final String input;
73         if (abort) {
74             input = randomValueOtherThanMany(c -&gt; c.equalsIgnoreCase("y"), () -&gt; randomAlphaOfLength(1));
75         } else {
76             input = randomBoolean() ? "y" : "Y";
77         }
78         terminal.addTextInput(input);
79         try {
80             command.execute(terminal, options, environment);
81         } finally {
82             assertThat(terminal.getOutput(), containsString(ElasticsearchNodeCommand.STOP_WARNING_MSG));
83         }
84         return terminal;
85     }
86     private MockTerminal removeCustoms(Environment environment, boolean abort, String... args) throws Exception {
87 <a name="4"></a>        final MockTerminal terminal = executeCommand(new RemoveCustomsCommand(), environment, abort, args);
88         assertThat(terminal.getOutput(), containsString(RemoveCustomsCommand.CONFIRMATION_MSG));
89         assertThat(terminal.getOutput(), containsString(RemoveCustomsCommand.CUSTOMS_REMOVED_MSG));
90         <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return terminal;
91     }
92     private void expectThrows(ThrowingRunnable runnable, String message) {
93         ElasticsearchException ex = expectThrows</b></font>(ElasticsearchException.class, runnable);
94         assertThat(ex.getMessage(), containsString(message));
95     }
96 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>RestoreService.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.snapshots;
2 import com.carrotsearch.hppc.IntHashSet;
3 import com.carrotsearch.hppc.IntSet;
4 import com.carrotsearch.hppc.cursors.ObjectCursor;
5 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
6 import org.apache.logging.log4j.LogManager;
7 import org.apache.logging.log4j.Logger;
8 import org.apache.logging.log4j.message.ParameterizedMessage;
9 import org.elasticsearch.ResourceNotFoundException;
10 import org.elasticsearch.Version;
11 import</b></font> org.elasticsearch.action.ActionListener;
12 import org.elasticsearch.action.support.IndicesOptions;
13 import org.elasticsearch.action.StepListener;
14 import org.elasticsearch.cluster.ClusterChangedEvent;
15 import org.elasticsearch.cluster.ClusterState;
16 import org.elasticsearch.cluster.ClusterStateApplier;
17 import org.elasticsearch.cluster.ClusterStateTaskConfig;
18 import org.elasticsearch.cluster.ClusterStateTaskExecutor;
19 import org.elasticsearch.cluster.ClusterStateTaskListener;
20 import org.elasticsearch.cluster.ClusterStateUpdateTask;
21 import org.elasticsearch.cluster.RestoreInProgress;
22 import org.elasticsearch.cluster.RestoreInProgress.ShardRestoreStatus;
23 import org.elasticsearch.cluster.SnapshotDeletionsInProgress;
24 import org.elasticsearch.cluster.block.ClusterBlocks;
25 import org.elasticsearch.cluster.metadata.AliasMetadata;
26 import org.elasticsearch.cluster.metadata.IndexMetadata;
27 import org.elasticsearch.cluster.metadata.IndexTemplateMetadata;
28 import org.elasticsearch.cluster.metadata.Metadata;
29 import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;
30 import org.elasticsearch.cluster.metadata.MetadataIndexUpgradeService;
31 import org.elasticsearch.cluster.metadata.RepositoriesMetadata;
32 import org.elasticsearch.cluster.routing.RecoverySource;
33 import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;
34 import org.elasticsearch.cluster.routing.RoutingChangesObserver;
35 import org.elasticsearch.cluster.routing.RoutingTable;
36 import org.elasticsearch.cluster.routing.ShardRouting;
37 import org.elasticsearch.cluster.routing.UnassignedInfo;
38 import org.elasticsearch.cluster.routing.allocation.AllocationService;
39 import org.elasticsearch.cluster.service.ClusterService;
40 import org.elasticsearch.common.Priority;
41 import org.elasticsearch.common.UUIDs;
42 import org.elasticsearch.common.collect.ImmutableOpenMap;
43 import org.elasticsearch.common.lucene.Lucene;
44 import org.elasticsearch.common.regex.Regex;
45 import org.elasticsearch.common.settings.ClusterSettings;
46 import org.elasticsearch.common.settings.Settings;
47 import io.crate.common.unit.TimeValue;
48 import org.elasticsearch.index.Index;
49 import org.elasticsearch.index.IndexSettings;
50 import org.elasticsearch.index.shard.IndexShard;
51 import org.elasticsearch.index.shard.ShardId;
52 import org.elasticsearch.indices.ShardLimitValidator;
53 import org.elasticsearch.repositories.RepositoriesService;
54 import org.elasticsearch.repositories.Repository;
55 import org.elasticsearch.repositories.RepositoryData;
56 import java.util.ArrayList;
57 import java.util.Arrays;
58 import java.util.Collection;
59 import java.util.Collections;
60 import java.util.HashMap;
61 import java.util.HashSet;
62 import java.util.List;
63 import java.util.Map;
64 import java.util.Objects;
65 import java.util.Optional;
66 import java.util.Set;
67 import java.util.function.Predicate;
68 import java.util.stream.Collectors;
69 import static java.util.Collections.emptySet;
70 import static java.util.Collections.unmodifiableSet;
71 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS;
72 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;
73 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_INDEX_UUID;
74 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;
75 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;
76 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;
77 import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_UPGRADED;
78 import static org.elasticsearch.snapshots.SnapshotUtils.filterIndices;
79 public class RestoreService implements ClusterStateApplier {
80     private static final Logger LOGGER = LogManager.getLogger(RestoreService.class);
81     private static final Set&lt;String&gt; UNMODIFIABLE_SETTINGS = Set.of(
82             SETTING_NUMBER_OF_SHARDS,
83             SETTING_VERSION_CREATED,
84             SETTING_INDEX_UUID,
85             SETTING_CREATION_DATE,
86             IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey());
87     private static final Set&lt;String&gt; UNREMOVABLE_SETTINGS;
88     static {
89         Set&lt;String&gt; unremovable = new HashSet&lt;&gt;(UNMODIFIABLE_SETTINGS.size() + 4);
90         unremovable.addAll(UNMODIFIABLE_SETTINGS);
91         unremovable.add(SETTING_NUMBER_OF_REPLICAS);
92         unremovable.add(SETTING_AUTO_EXPAND_REPLICAS);
93         unremovable.add(SETTING_VERSION_UPGRADED);
94         UNREMOVABLE_SETTINGS = unmodifiableSet(unremovable);
95     }
96     private final ClusterService clusterService;
97     private final RepositoriesService repositoriesService;
98     private final AllocationService allocationService;
99     private final MetadataCreateIndexService createIndexService;
100     private final MetadataIndexUpgradeService metadataIndexUpgradeService;
101     private final ClusterSettings clusterSettings;
102     private final CleanRestoreStateTaskExecutor cleanRestoreStateTaskExecutor;
103     private final ShardLimitValidator shardLimitValidator;
104     public RestoreService(ClusterService clusterService,
105                           RepositoriesService repositoriesService,
106                           AllocationService allocationService,
107                           MetadataCreateIndexService createIndexService,
108                           MetadataIndexUpgradeService metadataIndexUpgradeService,
109                           ClusterSettings clusterSettings,
110                           ShardLimitValidator shardLimitValidator) {
111         this.clusterService = clusterService;
112         this.repositoriesService = repositoriesService;
113         this.allocationService = allocationService;
114         this.createIndexService = createIndexService;
115         this.metadataIndexUpgradeService = metadataIndexUpgradeService;
116         clusterService.addStateApplier(this);
117         this.clusterSettings = clusterSettings;
118         this.cleanRestoreStateTaskExecutor = new CleanRestoreStateTaskExecutor(LOGGER);
119         this.shardLimitValidator = shardLimitValidator;
120     }
121     public void restoreSnapshot(final RestoreRequest request, final ActionListener&lt;RestoreCompletionResponse&gt; listener) {
122         try {
123             final String repositoryName = request.repositoryName;
124             Repository repository = repositoriesService.repository(repositoryName);
125             final StepListener&lt;RepositoryData&gt; repositoryDataListener = new StepListener&lt;&gt;();
126             repository.getRepositoryData(repositoryDataListener);
127             repositoryDataListener.whenComplete(repositoryData -&gt; {
128                 final String snapshotName = request.snapshotName;
129                 final Optional&lt;SnapshotId&gt; matchingSnapshotId = repositoryData.getSnapshotIds().stream()
130                     .filter(s -&gt; snapshotName.equals(s.getName())).findFirst();
131                 if (matchingSnapshotId.isPresent() == false) {
132                     throw new SnapshotRestoreException(repositoryName, snapshotName, "snapshot does not exist");
133                 }
134                 final SnapshotId snapshotId = matchingSnapshotId.get();
135                 repository.getSnapshotInfo(snapshotId, ActionListener.delegateFailure(
136                     listener,
137                     (delegate, snapshotInfo) -&gt; {
138                         final Snapshot snapshot = new Snapshot(repositoryName, snapshotId);
139                         validateSnapshotRestorable(repositoryName, snapshotInfo);
140                         final List&lt;String&gt; indicesInSnapshot = request.includeIndices()
141                             ? filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())
142                             : List.of();
143                         final StepListener&lt;Metadata&gt; globalMetadataListener = new StepListener&lt;&gt;();
144                         if (request.includeCustomMetadata()
145                             || request.includeGlobalSettings()
146                             || request.allTemplates()
147                             || (request.templates() != null &amp;&amp; request.templates().length &gt; 0)) {
148                             repository.getSnapshotGlobalMetadata(snapshotId, globalMetadataListener);
149                         } else {
150                             globalMetadataListener.onResponse(Metadata.EMPTY_METADATA);
151                         }
152                         globalMetadataListener.whenComplete(globalMetadata -&gt; {
153                             var metadataBuilder = Metadata.builder(globalMetadata);
154                             var indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot);
155                             var snapshotIndexMetadataListener = new StepListener&lt;Collection&lt;IndexMetadata&gt;&gt;();
156                             repository.getSnapshotIndexMetadata(snapshotId, indexIdsInSnapshot, snapshotIndexMetadataListener);
157                             snapshotIndexMetadataListener.whenComplete(snapshotIndexMetadata -&gt; {
158                                 for (IndexMetadata indexMetadata : snapshotIndexMetadata) {
159                                     metadataBuilder.put(indexMetadata, false);
160                                 }
161                                 final Metadata metadata = metadataBuilder.build();
162                                 final Map&lt;String, String&gt; indices = renamedIndices(request, indicesInSnapshot);
163                                 clusterService.submitStateUpdateTask("restore_snapshot[" + snapshotName + ']', new ClusterStateUpdateTask() {
164                                     final String restoreUUID = UUIDs.randomBase64UUID();
165                                     RestoreInfo restoreInfo = null;
166                                     @Override
167                                     public ClusterState execute(ClusterState currentState) {
168                                         RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE);
169                                         SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);
170                                         if (deletionsInProgress != null
171                                             &amp;&amp; deletionsInProgress.getEntries().stream().anyMatch(entry -&gt; entry.getSnapshot().equals(snapshot))) {
172                                             throw new ConcurrentSnapshotExecutionException(snapshot, "cannot restore a snapshot while a snapshot deletion is in-progress [" +
173                                                                                                      deletionsInProgress.getEntries().get(0).getSnapshot() + "]");
174                                         }
175                                         ClusterState.Builder builder = ClusterState.builder(currentState);
176                                         Metadata.Builder mdBuilder = Metadata.builder(currentState.metadata());
177                                         ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());
178                                         RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable());
179                                         ImmutableOpenMap&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shards;
180                                         Set&lt;String&gt; aliases = new HashSet&lt;&gt;();
181                                         if (indices.isEmpty() == false) {
182                                             ImmutableOpenMap.Builder&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shardsBuilder =
183                                                 ImmutableOpenMap.builder();
184                                             final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()
185                                                 .minimumIndexCompatibilityVersion();
186                                             for (Map.Entry&lt;String, String&gt; indexEntry : indices.entrySet()) {
187                                                 String index = indexEntry.getValue();
188                                                 boolean partial = checkPartial(index);
189                                                 SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index);
190                                                 String renamedIndexName = indexEntry.getKey();
191                                                 IndexMetadata snapshotIndexMetadata = metadata.index(index);
192                                                 snapshotIndexMetadata = updateIndexSettings(snapshotIndexMetadata,
193                                                                                             request.indexSettings(), request.ignoreIndexSettings());
194                                                 try {
195                                                     snapshotIndexMetadata = metadataIndexUpgradeService.upgradeIndexMetadata(snapshotIndexMetadata,
196                                                                                                                              minIndexCompatibilityVersion);
197                                                 } catch (Exception ex) {
198                                                     throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index +
199                                                                                                  "] because it cannot be upgraded", ex);
200                                                 }
201                                                 IndexMetadata currentIndexMetadata = currentState.metadata().index(renamedIndexName);
202                                                 IntSet ignoreShards = new IntHashSet();
203                                                 final Index renamedIndex;
204                                                 if (currentIndexMetadata == null) {
205 <a name="1"></a>                                                                                                        MetadataCreateIndexService.validateIndexName(renamedIndexName, currentState);
206                                                     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetadata.getSettings(), currentState, false);
207                                                     IndexMetadata.Builder indexMdBuilder = IndexMetadata.builder(snapshotIndexMetadata)
208                                                         .state(IndexMetadata.State.OPEN)
209                                                         .index(renamedIndexName);
210                                                     indexMdBuilder.settings(Settings.builder()
211                                                                                 .put(snapshotIndexMetadata.getSettings())
212                                                                                 .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()));
213                                                     shardLimitValidator.validateShardLimit(snapshotIndexMetadata.getSettings</b></font>(), currentState);
214                                                     if (!request.includeAliases() &amp;&amp; !snapshotIndexMetadata.getAliases().isEmpty()) {
215                                                         indexMdBuilder.removeAllAliases();
216                                                     } else {
217                                                         for (ObjectCursor&lt;String&gt; alias : snapshotIndexMetadata.getAliases().keys()) {
218                                                             aliases.add(alias.value);
219                                                         }
220                                                     }
221                                                     IndexMetadata updatedIndexMetadata = indexMdBuilder.build();
222                                                     if (partial) {
223                                                         populateIgnoredShards(index, ignoreShards);
224                                                     }
225                                                     rtBuilder.addAsNewRestore(updatedIndexMetadata, recoverySource, ignoreShards);
226                                                     blocks.addBlocks(updatedIndexMetadata);
227 <a name="0"></a>                                                    mdBuilder.put(updatedIndexMetadata, true);
228                                                     renamedIndex = updatedIndexMetadata.getIndex();
229                                                 } else {
230                                                     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>validateExistingIndex(currentIndexMetadata, snapshotIndexMetadata, renamedIndexName, partial);
231                                                     IndexMetadata.Builder indexMdBuilder = IndexMetadata.builder(snapshotIndexMetadata).state(IndexMetadata.State.OPEN);
232                                                     indexMdBuilder.version(Math.max(snapshotIndexMetadata.getVersion(), 1 + currentIndexMetadata.getVersion()));
233                                                     indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetadata.getMappingVersion(), 1 + currentIndexMetadata.getMappingVersion()));
234                                                     indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetadata.getSettingsVersion(), 1 + currentIndexMetadata.getSettingsVersion</b></font>()));
235                                                     for (int shard = 0; shard &lt; snapshotIndexMetadata.getNumberOfShards(); shard++) {
236                                                         indexMdBuilder.primaryTerm(shard, Math.max(snapshotIndexMetadata.primaryTerm(shard), currentIndexMetadata.primaryTerm(shard)));
237                                                     }
238                                                     if (!request.includeAliases()) {
239                                                         if (!snapshotIndexMetadata.getAliases().isEmpty()) {
240                                                             indexMdBuilder.removeAllAliases();
241                                                         }
242                                                         for (ObjectCursor&lt;AliasMetadata&gt; alias : currentIndexMetadata.getAliases().values()) {
243                                                             indexMdBuilder.putAlias(alias.value);
244                                                         }
245                                                     } else {
246                                                         for (ObjectCursor&lt;String&gt; alias : snapshotIndexMetadata.getAliases().keys()) {
247 <a name="2"></a>                                                            aliases.add(alias.value);
248                                                         }
249                                                     }
250                                                     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>indexMdBuilder.settings(Settings.builder()
251                                                                                 .put(snapshotIndexMetadata.getSettings())
252                                                                                 .put(IndexMetadata.SETTING_INDEX_UUID, currentIndexMetadata.getIndexUUID()));
253                                                     IndexMetadata updatedIndexMetadata = indexMdBuilder.index(renamedIndexName).build();
254                                                     rtBuilder.addAsRestore(updatedIndexMetadata, recoverySource);
255                                                     blocks.updateBlocks(updatedIndexMetadata);
256                                                     mdBuilder.put</b></font>(updatedIndexMetadata, true);
257                                                     renamedIndex = updatedIndexMetadata.getIndex();
258                                                 }
259                                                 for (int shard = 0; shard &lt; snapshotIndexMetadata.getNumberOfShards(); shard++) {
260                                                     if (!ignoreShards.contains(shard)) {
261                                                         shardsBuilder.put(new ShardId(renamedIndex, shard),
262                                                                           new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()));
263                                                     } else {
264                                                         shardsBuilder.put(new ShardId(renamedIndex, shard),
265                                                                           new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE));
266                                                     }
267                                                 }
268                                             }
269                                             shards = shardsBuilder.build();
270                                             RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(
271                                                 restoreUUID,
272                                                 snapshot,
273                                                 overallState(RestoreInProgress.State.INIT, shards),
274                                                 List.copyOf(indices.keySet()),
275                                                 shards
276                                             );
277                                             RestoreInProgress.Builder restoreInProgressBuilder;
278                                             if (restoreInProgress != null) {
279                                                 restoreInProgressBuilder = new RestoreInProgress.Builder(restoreInProgress);
280                                             } else {
281                                                 restoreInProgressBuilder = new RestoreInProgress.Builder();
282                                             }
283                                             builder.putCustom(RestoreInProgress.TYPE, restoreInProgressBuilder.add(restoreEntry).build());
284                                         } else {
285                                             shards = ImmutableOpenMap.of();
286                                         }
287                                         validateExistingTemplates();
288                                         checkAliasNameConflicts(indices, aliases);
289                                         restoreTemplates(mdBuilder, currentState);
290                                         if (request.includeGlobalSettings() &amp;&amp; metadata.persistentSettings() != null) {
291                                             Settings settings = metadata.persistentSettings();
292                                             if (request.globalSettings().length &gt; 0) {
293                                                 var filteredSettingBuilder = Settings.builder();
294                                                 for (String prefix : request.globalSettings()) {
295                                                     filteredSettingBuilder.put(settings.filter(s -&gt; s.startsWith(prefix)));
296                                                 }
297                                                 settings = filteredSettingBuilder.build();
298                                             }
299                                             clusterSettings.validateUpdate(settings);
300                                             mdBuilder.persistentSettings(settings);
301                                         }
302                                         if (request.includeCustomMetadata() &amp;&amp; metadata.customs() != null) {
303                                             List&lt;String&gt; customMetadataTypes = Arrays.asList(request.customMetadataTypes());
304                                             boolean includeAll = customMetadataTypes.size() == 0;
305                                             for (ObjectObjectCursor&lt;String, Metadata.Custom&gt; cursor : metadata.customs()) {
306                                                 if (!RepositoriesMetadata.TYPE.equals(cursor.key)) {
307                                                     if (includeAll || customMetadataTypes.contains(cursor.key)) {
308                                                         mdBuilder.putCustom(cursor.key, cursor.value);
309                                                     }
310                                                 }
311                                             }
312                                         }
313                                         if (completed(shards)) {
314                                             restoreInfo = new RestoreInfo(snapshotId.getName(), Collections.unmodifiableList(new ArrayList&lt;&gt;(indices.keySet())), shards.size(), shards.size() - failedShards(shards));
315                                         }
316                                         RoutingTable rt = rtBuilder.build();
317                                         ClusterState updatedState = builder.metadata(mdBuilder).blocks(blocks).routingTable(rt).build();
318                                         return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]");
319                                     }
320                                     private void checkAliasNameConflicts(Map&lt;String, String&gt; renamedIndices, Set&lt;String&gt; aliases) {
321                                         for (Map.Entry&lt;String, String&gt; renamedIndex : renamedIndices.entrySet()) {
322                                             if (aliases.contains(renamedIndex.getKey())) {
323                                                 throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() +
324                                                                                              "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name");
325                                             }
326                                         }
327                                     }
328                                     private void populateIgnoredShards(String index, IntSet ignoreShards) {
329                                         for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {
330                                             if (index.equals(failure.index())) {
331                                                 ignoreShards.add(failure.shardId());
332                                             }
333                                         }
334                                     }
335                                     private boolean checkPartial(String index) {
336                                         if (failed(snapshotInfo, index)) {
337                                             if (request.partial()) {
338                                                 return true;
339                                             } else {
340                                                 throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot " + "restore");
341                                             }
342                                         } else {
343                                             return false;
344                                         }
345                                     }
346                                     private void validateExistingIndex(
347                                         IndexMetadata currentIndexMetadata,
348                                         IndexMetadata snapshotIndexMetadata,
349                                         String renamedIndex,
350                                         boolean partial) {
351                                         if (currentIndexMetadata.getState() != IndexMetadata.State.CLOSE) {
352                                             throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index " +
353                                                                                          "with same name already exists in the cluster. Either close or delete the existing index or restore the " +
354                                                                                          "index under a different name by providing a rename pattern and replacement name");
355                                         }
356                                         if (partial) {
357                                             throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists");
358                                         }
359                                         if (currentIndexMetadata.getNumberOfShards() != snapshotIndexMetadata.getNumberOfShards()) {
360                                             throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetadata.getNumberOfShards() +
361                                                                                          "] shards from a snapshot of index [" + snapshotIndexMetadata.getIndex().getName() + "] with [" +
362                                                                                          snapshotIndexMetadata.getNumberOfShards() + "] shards");
363                                         }
364                                     }
365                                     private IndexMetadata updateIndexSettings(IndexMetadata indexMetadata,
366                                                                               Settings changeSettings,
367                                                                               String[] ignoreSettings) {
368                                         if (changeSettings.names().isEmpty() &amp;&amp; ignoreSettings.length == 0) {
369                                             return indexMetadata;
370                                         }
371                                         Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetadata.INDEX_SETTING_PREFIX).build();
372                                         IndexMetadata.Builder builder = IndexMetadata.builder(indexMetadata);
373                                         Settings settings = indexMetadata.getSettings();
374                                         Set&lt;String&gt; keyFilters = new HashSet&lt;&gt;();
375                                         List&lt;String&gt; simpleMatchPatterns = new ArrayList&lt;&gt;();
376                                         for (String ignoredSetting : ignoreSettings) {
377                                             if (!Regex.isSimpleMatchPattern(ignoredSetting)) {
378                                                 if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {
379                                                     throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore");
380                                                 } else {
381                                                     keyFilters.add(ignoredSetting);
382                                                 }
383                                             } else {
384                                                 simpleMatchPatterns.add(ignoredSetting);
385                                             }
386                                         }
387                                         Predicate&lt;String&gt; settingsFilter = k -&gt; {
388                                             if (UNREMOVABLE_SETTINGS.contains(k) == false) {
389                                                 for (String filterKey : keyFilters) {
390                                                     if (k.equals(filterKey)) {
391                                                         return false;
392                                                     }
393                                                 }
394                                                 for (String pattern : simpleMatchPatterns) {
395                                                     if (Regex.simpleMatch(pattern, k)) {
396                                                         return false;
397                                                     }
398                                                 }
399                                             }
400                                             return true;
401                                         };
402                                         Settings.Builder settingsBuilder = Settings.builder()
403                                             .put(settings.filter(settingsFilter))
404                                             .put(normalizedChangeSettings.filter(k -&gt; {
405                                                 if (UNMODIFIABLE_SETTINGS.contains(k)) {
406                                                     throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore");
407                                                 } else {
408                                                     return true;
409                                                 }
410                                             }));
411                                         settingsBuilder.remove(IndexMetadata.VERIFIED_BEFORE_CLOSE_SETTING.getKey());
412                                         return builder.settings(settingsBuilder).build();
413                                     }
414                                     private void restoreTemplates(Metadata.Builder mdBuilder, ClusterState currentState) {
415                                         List&lt;String&gt; toRestore = Arrays.asList(request.templates());
416                                         if (metadata.templates() != null) {
417                                             for (ObjectCursor&lt;IndexTemplateMetadata&gt; cursor : metadata.templates().values()) {
418                                                 if (currentState.metadata().templates().get(cursor.value.name()) == null
419                                                     &amp;&amp; (request.allTemplates() || toRestore.contains(cursor.value.name()))) {
420                                                     mdBuilder.put(cursor.value);
421                                                 }
422                                             }
423                                         }
424                                     }
425                                     private void validateExistingTemplates() {
426                                         if (request.indicesOptions().ignoreUnavailable() || request.allTemplates()) {
427                                             return;
428                                         }
429                                         for (String template : request.templates()) {
430                                             if (!metadata.templates().containsKey(template)) {
431                                                 throw new ResourceNotFoundException("[{}] template not found", template);
432                                             }
433                                         }
434                                     }
435                                     @Override
436                                     public void onFailure(String source, Exception e) {
437                                         LOGGER.warn(() -&gt; new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e);
438                                         listener.onFailure(e);
439                                     }
440                                     @Override
441                                     public TimeValue timeout() {
442                                         return request.masterNodeTimeout();
443                                     }
444                                     @Override
445                                     public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
446                                         listener.onResponse(new RestoreCompletionResponse(restoreUUID, snapshot, restoreInfo));
447                                     }
448                                 });
449                             }, listener::onFailure);
450                         }, listener::onFailure);
451                     }
452                 ));
453             },listener::onFailure);
454         } catch (Exception e) {
455             LOGGER.warn(() -&gt; new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e);
456             listener.onFailure(e);
457         }
458     }
459     public static RestoreInProgress updateRestoreStateWithDeletedIndices(RestoreInProgress oldRestore, Set&lt;Index&gt; deletedIndices) {
460         boolean changesMade = false;
461         RestoreInProgress.Builder builder = new RestoreInProgress.Builder();
462         for (RestoreInProgress.Entry entry : oldRestore) {
463             ImmutableOpenMap.Builder&lt;ShardId, ShardRestoreStatus&gt; shardsBuilder = null;
464             for (ObjectObjectCursor&lt;ShardId, ShardRestoreStatus&gt; cursor : entry.shards()) {
465                 ShardId shardId = cursor.key;
466                 if (deletedIndices.contains(shardId.getIndex())) {
467                     changesMade = true;
468                     if (shardsBuilder == null) {
469                         shardsBuilder = ImmutableOpenMap.builder(entry.shards());
470                     }
471                     shardsBuilder.put(shardId, new ShardRestoreStatus(null, RestoreInProgress.State.FAILURE, "index was deleted"));
472                 }
473             }
474             if (shardsBuilder != null) {
475                 ImmutableOpenMap&lt;ShardId, ShardRestoreStatus&gt; shards = shardsBuilder.build();
476                 builder.add(new RestoreInProgress.Entry(entry.uuid(), entry.snapshot(), overallState(RestoreInProgress.State.STARTED, shards), entry.indices(), shards));
477             } else {
478                 builder.add(entry);
479             }
480         }
481         if (changesMade) {
482             return builder.build();
483         } else {
484             return oldRestore;
485         }
486     }
487     public static final class RestoreCompletionResponse {
488         private final String uuid;
489         private final Snapshot snapshot;
490         private final RestoreInfo restoreInfo;
491         private RestoreCompletionResponse(final String uuid, final Snapshot snapshot, final RestoreInfo restoreInfo) {
492             this.uuid = uuid;
493             this.snapshot = snapshot;
494             this.restoreInfo = restoreInfo;
495         }
496         public String getUuid() {
497             return uuid;
498         }
499         public Snapshot getSnapshot() {
500             return snapshot;
501         }
502         public RestoreInfo getRestoreInfo() {
503             return restoreInfo;
504         }
505     }
506     public static class RestoreInProgressUpdater extends RoutingChangesObserver.AbstractRoutingChangesObserver {
507         private final Map&lt;String, Updates&gt; shardChanges = new HashMap&lt;&gt;();
508         @Override
509         public void shardStarted(ShardRouting initializingShard, ShardRouting startedShard) {
510             if (initializingShard.primary()) {
511                 RecoverySource recoverySource = initializingShard.recoverySource();
512                 if (recoverySource.getType() == RecoverySource.Type.SNAPSHOT) {
513                     changes(recoverySource).shards.put(
514                         initializingShard.shardId(),
515                         new ShardRestoreStatus(initializingShard.currentNodeId(), RestoreInProgress.State.SUCCESS));
516                 }
517             }
518         }
519         @Override
520         public void shardFailed(ShardRouting failedShard, UnassignedInfo unassignedInfo) {
521             if (failedShard.primary() &amp;&amp; failedShard.initializing()) {
522                 RecoverySource recoverySource = failedShard.recoverySource();
523                 if (recoverySource.getType() == RecoverySource.Type.SNAPSHOT) {
524                     if (unassignedInfo.getFailure() != null &amp;&amp; Lucene.isCorruptionException(unassignedInfo.getFailure().getCause())) {
525                         changes(recoverySource).shards.put(
526                             failedShard.shardId(), new ShardRestoreStatus(failedShard.currentNodeId(),
527                                 RestoreInProgress.State.FAILURE, unassignedInfo.getFailure().getCause().getMessage()));
528                     }
529                 }
530             }
531         }
532         @Override
533         public void shardInitialized(ShardRouting unassignedShard, ShardRouting initializedShard) {
534             if (unassignedShard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT &amp;&amp;
535                 initializedShard.recoverySource().getType() != RecoverySource.Type.SNAPSHOT) {
536                 changes(unassignedShard.recoverySource()).shards.put(
537                     unassignedShard.shardId(),
538                     new ShardRestoreStatus(null,
539                         RestoreInProgress.State.FAILURE, "recovery source type changed from snapshot to " + initializedShard.recoverySource())
540                 );
541             }
542         }
543         @Override
544         public void unassignedInfoUpdated(ShardRouting unassignedShard, UnassignedInfo newUnassignedInfo) {
545             RecoverySource recoverySource = unassignedShard.recoverySource();
546             if (recoverySource.getType() == RecoverySource.Type.SNAPSHOT) {
547                 if (newUnassignedInfo.getLastAllocationStatus() == UnassignedInfo.AllocationStatus.DECIDERS_NO) {
548                     String reason = "shard could not be allocated to any of the nodes";
549                     changes(recoverySource).shards.put(
550                         unassignedShard.shardId(),
551                         new ShardRestoreStatus(unassignedShard.currentNodeId(), RestoreInProgress.State.FAILURE, reason));
552                 }
553             }
554         }
555         private Updates changes(RecoverySource recoverySource) {
556             assert recoverySource.getType() == RecoverySource.Type.SNAPSHOT;
557             return shardChanges.computeIfAbsent(((SnapshotRecoverySource) recoverySource).restoreUUID(), k -&gt; new Updates());
558         }
559         private static class Updates {
560             private Map&lt;ShardId, ShardRestoreStatus&gt; shards = new HashMap&lt;&gt;();
561         }
562         public RestoreInProgress applyChanges(final RestoreInProgress oldRestore) {
563             if (shardChanges.isEmpty() == false) {
564                 RestoreInProgress.Builder builder = new RestoreInProgress.Builder();
565                 for (RestoreInProgress.Entry entry : oldRestore) {
566                     Updates updates = shardChanges.get(entry.uuid());
567                     ImmutableOpenMap&lt;ShardId, ShardRestoreStatus&gt; shardStates = entry.shards();
568                     if (updates != null &amp;&amp; updates.shards.isEmpty() == false) {
569                         ImmutableOpenMap.Builder&lt;ShardId, ShardRestoreStatus&gt; shardsBuilder = ImmutableOpenMap.builder(shardStates);
570                         for (Map.Entry&lt;ShardId, ShardRestoreStatus&gt; shard : updates.shards.entrySet()) {
571                             ShardId shardId = shard.getKey();
572                             ShardRestoreStatus status = shardStates.get(shardId);
573                             if (status == null || status.state().completed() == false) {
574                                 shardsBuilder.put(shardId, shard.getValue());
575                             }
576                         }
577                         ImmutableOpenMap&lt;ShardId, ShardRestoreStatus&gt; shards = shardsBuilder.build();
578                         RestoreInProgress.State newState = overallState(RestoreInProgress.State.STARTED, shards);
579                         builder.add(new RestoreInProgress.Entry(entry.uuid(), entry.snapshot(), newState, entry.indices(), shards));
580                     } else {
581                         builder.add(entry);
582                     }
583                 }
584                 return builder.build();
585             } else {
586                 return oldRestore;
587             }
588         }
589     }
590     public static RestoreInProgress.Entry restoreInProgress(ClusterState state, String restoreUUID) {
591         final RestoreInProgress restoreInProgress = state.custom(RestoreInProgress.TYPE);
592         if (restoreInProgress != null) {
593             return restoreInProgress.get(restoreUUID);
594         }
595         return null;
596     }
597     static class CleanRestoreStateTaskExecutor implements ClusterStateTaskExecutor&lt;CleanRestoreStateTaskExecutor.Task&gt;, ClusterStateTaskListener {
598         static class Task {
599             final String uuid;
600             Task(String uuid) {
601                 this.uuid = uuid;
602             }
603             @Override
604             public String toString() {
605                 return "clean restore state for restore " + uuid;
606             }
607         }
608         private final Logger logger;
609         CleanRestoreStateTaskExecutor(Logger logger) {
610             this.logger = logger;
611         }
612         @Override
613         public ClusterTasksResult&lt;Task&gt; execute(final ClusterState currentState, final List&lt;Task&gt; tasks) throws Exception {
614             final ClusterTasksResult.Builder&lt;Task&gt; resultBuilder = ClusterTasksResult.&lt;Task&gt;builder().successes(tasks);
615             Set&lt;String&gt; completedRestores = tasks.stream().map(e -&gt; e.uuid).collect(Collectors.toSet());
616             RestoreInProgress.Builder restoreInProgressBuilder = new RestoreInProgress.Builder();
617             final RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE);
618             boolean changed = false;
619             if (restoreInProgress != null) {
620                 for (RestoreInProgress.Entry entry : restoreInProgress) {
621                     if (completedRestores.contains(entry.uuid())) {
622                         changed = true;
623                     } else {
624                         restoreInProgressBuilder.add(entry);
625                     }
626                 }
627             }
628             if (changed == false) {
629                 return resultBuilder.build(currentState);
630             }
631             ImmutableOpenMap.Builder&lt;String, ClusterState.Custom&gt; builder = ImmutableOpenMap.builder(currentState.getCustoms());
632             builder.put(RestoreInProgress.TYPE, restoreInProgressBuilder.build());
633             ImmutableOpenMap&lt;String, ClusterState.Custom&gt; customs = builder.build();
634             return resultBuilder.build(ClusterState.builder(currentState).customs(customs).build());
635         }
636         @Override
637         public void onFailure(final String source, final Exception e) {
638             logger.error(() -&gt; new ParameterizedMessage("unexpected failure during [{}]", source), e);
639         }
640         @Override
641         public void onNoLongerMaster(String source) {
642             logger.debug("no longer master while processing restore state update [{}]", source);
643         }
644     }
645     private void cleanupRestoreState(ClusterChangedEvent event) {
646         ClusterState state = event.state();
647         RestoreInProgress restoreInProgress = state.custom(RestoreInProgress.TYPE);
648         if (restoreInProgress != null) {
649             for (RestoreInProgress.Entry entry : restoreInProgress) {
650                 if (entry.state().completed()) {
651                     assert completed(entry.shards()) : "state says completed but restore entries are not";
652                     clusterService.submitStateUpdateTask(
653                         "clean up snapshot restore state",
654                         new CleanRestoreStateTaskExecutor.Task(entry.uuid()),
655                         ClusterStateTaskConfig.build(Priority.URGENT),
656                         cleanRestoreStateTaskExecutor,
657                         cleanRestoreStateTaskExecutor);
658                 }
659             }
660         }
661     }
662     public static RestoreInProgress.State overallState(RestoreInProgress.State nonCompletedState,
663                                                        ImmutableOpenMap&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shards) {
664         boolean hasFailed = false;
665         for (ObjectCursor&lt;RestoreInProgress.ShardRestoreStatus&gt; status : shards.values()) {
666             if (!status.value.state().completed()) {
667                 return nonCompletedState;
668             }
669             if (status.value.state() == RestoreInProgress.State.FAILURE) {
670                 hasFailed = true;
671             }
672         }
673         if (hasFailed) {
674             return RestoreInProgress.State.FAILURE;
675         } else {
676             return RestoreInProgress.State.SUCCESS;
677         }
678     }
679     public static boolean completed(ImmutableOpenMap&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shards) {
680         for (ObjectCursor&lt;RestoreInProgress.ShardRestoreStatus&gt; status : shards.values()) {
681             if (!status.value.state().completed()) {
682                 return false;
683             }
684         }
685         return true;
686     }
687     public static int failedShards(ImmutableOpenMap&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shards) {
688         int failedShards = 0;
689         for (ObjectCursor&lt;RestoreInProgress.ShardRestoreStatus&gt; status : shards.values()) {
690             if (status.value.state() == RestoreInProgress.State.FAILURE) {
691                 failedShards++;
692             }
693         }
694         return failedShards;
695     }
696     private Map&lt;String, String&gt; renamedIndices(RestoreRequest request, List&lt;String&gt; filteredIndices) {
697         Map&lt;String, String&gt; renamedIndices = new HashMap&lt;&gt;();
698         for (String index : filteredIndices) {
699             String renamedIndex = index;
700             if (request.renameReplacement() != null &amp;&amp; request.renamePattern() != null) {
701                 renamedIndex = index.replaceAll(request.renamePattern(), request.renameReplacement());
702             }
703             String previousIndex = renamedIndices.put(renamedIndex, index);
704             if (previousIndex != null) {
705                 throw new SnapshotRestoreException(request.repositoryName, request.snapshotName,
706                         "indices [" + index + "] and [" + previousIndex + "] are renamed into the same index [" + renamedIndex + "]");
707             }
708         }
709         return Collections.unmodifiableMap(renamedIndices);
710     }
711     private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {
712         if (!snapshotInfo.state().restorable()) {
713             throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),
714                                                "unsupported snapshot state [" + snapshotInfo.state() + "]");
715         }
716         if (Version.CURRENT.before(snapshotInfo.version())) {
717             throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),
718                                                "the snapshot was created with CrateDB version [" + snapshotInfo.version() +
719                                                    "] which is higher than the version of this node [" + Version.CURRENT + "]");
720         }
721     }
722     private boolean failed(SnapshotInfo snapshot, String index) {
723         for (SnapshotShardFailure failure : snapshot.shardFailures()) {
724             if (index.equals(failure.index())) {
725 <a name="4"></a>                return true;
726             }
727         }
728         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return false;
729     }
730     public static Set&lt;Index&gt; restoringIndices(final ClusterState currentState, final Set&lt;Index&gt; indicesToCheck) {
731         final RestoreInProgress restore = currentState.custom</b></font>(RestoreInProgress.TYPE);
732         if (restore == null) {
733             return emptySet();
734         }
735         final Set&lt;Index&gt; indices = new HashSet&lt;&gt;();
736         for (RestoreInProgress.Entry entry : restore) {
737             for (ObjectObjectCursor&lt;ShardId, RestoreInProgress.ShardRestoreStatus&gt; shard : entry.shards()) {
738                 Index index = shard.key.getIndex();
739                 if (indicesToCheck.contains(index)
740                     &amp;&amp; shard.value.state().completed() == false
741                     &amp;&amp; currentState.getMetadata().index(index) != null) {
742                     indices.add(index);
743                 }
744             }
745         }
746         return indices;
747     }
748     @Override
749     public void applyClusterState(ClusterChangedEvent event) {
750         try {
751             if (event.localNodeMaster()) {
752                 cleanupRestoreState(event);
753             }
754         } catch (Exception t) {
755             LOGGER.warn("Failed to update restore state ", t);
756         }
757     }
758     public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {
759         RestoreInProgress restoreInProgress = clusterState.custom(RestoreInProgress.TYPE);
760         if (restoreInProgress != null) {
761             for (RestoreInProgress.Entry entry: restoreInProgress) {
762                 if (repository.equals(entry.snapshot().getRepository())) {
763                     return true;
764                 }
765             }
766         }
767         return false;
768     }
769     public static class RestoreRequest {
770         private final String cause;
771         private final String repositoryName;
772         private final String snapshotName;
773         private final String[] indices;
774         private final String[] templates;
775         private final String renamePattern;
776         private final String renameReplacement;
777         private final IndicesOptions indicesOptions;
778         private final Settings settings;
779         private final TimeValue masterNodeTimeout;
780         private final boolean partial;
781         private final boolean includeAliases;
782         private final Settings indexSettings;
783         private final String[] ignoreIndexSettings;
784         private final boolean includeIndices;
785         private final boolean includeCustomMetadata;
786         private final String[] customMetadataTypes;
787         private final boolean includeGlobalSettings;
788         private final String[] globalSettings;
789         public RestoreRequest(String repositoryName, String snapshotName, String[] indices, String[] templates, IndicesOptions indicesOptions,
790                               String renamePattern, String renameReplacement, Settings settings,
791                               TimeValue masterNodeTimeout, boolean partial, boolean includeAliases,
792                               Settings indexSettings, String[] ignoreIndexSettings, String cause,
793                               boolean includeIndices,
794                               boolean includeCustomMetadata,
795                               String[] customMetadataTypes,
796                               boolean includeGlobalSettings,
797                               String[] globalSettings) {
798             this.repositoryName = Objects.requireNonNull(repositoryName);
799             this.snapshotName = Objects.requireNonNull(snapshotName);
800             this.indices = indices;
801             this.templates = templates;
802             this.renamePattern = renamePattern;
803             this.renameReplacement = renameReplacement;
804             this.indicesOptions = indicesOptions;
805             this.settings = settings;
806             this.masterNodeTimeout = masterNodeTimeout;
807             this.partial = partial;
808             this.includeAliases = includeAliases;
809             this.indexSettings = indexSettings;
810             this.ignoreIndexSettings = ignoreIndexSettings;
811             this.cause = cause;
812             this.includeIndices = includeIndices;
813             this.includeCustomMetadata = includeCustomMetadata;
814             this.customMetadataTypes = customMetadataTypes;
815             this.includeGlobalSettings = includeGlobalSettings;
816             this.globalSettings = globalSettings;
817         }
818         public String cause() {
819             return cause;
820         }
821         public String repositoryName() {
822             return repositoryName;
823         }
824         public String snapshotName() {
825             return snapshotName;
826         }
827         public String[] indices() {
828             return indices;
829         }
830         public String[] templates() {
831             return templates;
832         }
833         public boolean allTemplates() {
834             return templates.length == 1 &amp;&amp; templates[0].equals("_all");
835         }
836         public IndicesOptions indicesOptions() {
837             return indicesOptions;
838         }
839         public String renamePattern() {
840             return renamePattern;
841         }
842         public String renameReplacement() {
843             return renameReplacement;
844         }
845         public Settings settings() {
846             return settings;
847         }
848         public boolean partial() {
849             return partial;
850         }
851         public boolean includeAliases() {
852             return includeAliases;
853         }
854         public Settings indexSettings() {
855             return indexSettings;
856         }
857         public String[] ignoreIndexSettings() {
858             return ignoreIndexSettings;
859         }
860         public boolean includeIndices() {
861             return includeIndices;
862         }
863         public boolean includeCustomMetadata() {
864             return includeCustomMetadata;
865         }
866         public String[] customMetadataTypes() {
867             return customMetadataTypes;
868         }
869         public boolean includeGlobalSettings() {
870             return includeGlobalSettings;
871         }
872         public String[] globalSettings() {
873             return globalSettings;
874         }
875         public TimeValue masterNodeTimeout() {
876             return masterNodeTimeout;
877         }
878     }
879 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
