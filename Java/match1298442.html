<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for DefaultSchemaIntegrationTest.java &amp; CopyToPlan.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DefaultSchemaIntegrationTest.java &amp; CopyToPlan.java
      </h3>
<h1 align="center">
        14.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DefaultSchemaIntegrationTest.java (30.927835%)<th>CopyToPlan.java (9.259259%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(81-88)<td><a href="#" name="0">(116-123)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(61-65)<td><a href="#" name="1">(153-161)</a><td align="center"><font color="#e70000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(24-37)<td><a href="#" name="2">(72-83)</a><td align="center"><font color="#d00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultSchemaIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<a name="2"></a>
package io.crate.integrationtests;

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.testing.SQLResponse;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.File;
import java.nio.file.Paths;

import static org.hamcrest.core.Is.is;

public class DefaultSchemaIntegrationTest extends SQLIntegrationTestCase {


    @Rule</b></font>
    public TemporaryFolder tmpFolder = new TemporaryFolder();

    public SQLResponse execute(String stmt, Object[] args, String schema) {
        return execute(stmt, args, createSession(schema));
    }

    @Test
    public void testSelectFromFooSchemaWithRequestHeaders() throws Exception {
        // this test uses all kind of different statements that involve a table to make sure the schema is applied in each case.

        execute("create table foobar (x string) with (number_of_replicas = 0)", "foo" );
        ensureYellow();
        waitNoPendingTasksOnAll();
        execute("alter table foobar set (number_of_replicas = '0-1')", "foo" );

        assertThat(getTableCount("foo", "foobar"), is(1L));
        assertThat(getTableCount("doc", "foobar"), is(0L));

        execute("insert into foobar (x) values ('a'), ('b')", "foo");
        execute("refresh table foobar", "foo");
<a name="1"></a>        execute("update foobar set x = 'c'", "foo");
        assertThat(response.rowCount(), is(2L));

        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("select * from foobar", "foo");
        assertThat(response.rowCount(), is(2L));

        File foobarExport = tmpFolder.newFolder("foobar_export");
        String uriTemplate = Paths.get</b></font>(foobarExport.toURI()).toUri().toString();
        execute("copy foobar to directory ?", new Object[]{uriTemplate}, "foo");
        refresh();
        execute("delete from foobar", "foo");
        refresh();

        execute("select * from foobar", "foo");
        assertThat(response.rowCount(), is(0L));

        execute("copy foobar from ? with (shared=True)", new Object[]{uriTemplate + "*"}, "foo");
        execute("refresh table foobar", "foo");
        execute("select * from foobar", "foo");
        assertThat(response.rowCount(), is(2L));
<a name="0"></a>
        execute("insert into foobar (x) (select x from foobar)", "foo");
        execute("refresh table foobar", "foo");
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("select * from foobar", "foo");
        assertThat(response.rowCount(), is(4L));

        execute("drop table foobar", "foo");
        assertThat(getTableCount("foo", "foobar"), is(0L));
    }

    private long </b></font>getTableCount(String schema, String tableName) {
        execute("select count(*) from information_schema.tables where table_schema = ? and table_name = ?",
            new Object[]{schema, tableName});
        return ((long) response.rows()[0][0]);
    }

}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CopyToPlan.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.planner.statement;

import io.crate.analyze.AnalyzedCopyTo;
import io.crate.analyze.BoundCopyTo;
import io.crate.analyze.PartitionPropertiesAnalyzer;
import io.crate.analyze.SymbolEvaluator;
import io.crate.analyze.WhereClause;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.data.RowConsumer;
import io.crate.exceptions.PartitionUnknownException;
import io.crate.exceptions.UnsupportedFeatureException;
import io.crate.execution.dsl.phases.NodeOperationTree;
import io.crate.execution.dsl.projection.MergeCountProjection;
import io.crate.execution.dsl.projection.WriterProjection;
import io.crate.execution.dsl.projection.builder.ProjectionBuilder;
import io.crate.execution.engine.NodeOperationTreeGenerator;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.RefVisitor;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.DocReferences;
import io.crate.metadata.GeneratedReference;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Reference;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.ExecutionPlan;
import io.crate.planner.Merge;
import io.crate.planner.Plan;
import io.crate.planner.PlannerContext;
import io.crate.planner.operators.Collect;
import io.crate.planner.operators.LogicalPlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.planner.optimizer.matcher.Captures;
import io.crate.planner.optimizer.matcher.Match;
import io.crate.planner.optimizer.rule.OptimizeCollectWhereClauseAccess;
import io.crate.sql.tree.Assignment;
import io.crate.statistics.TableStats;
import io.crate.types.DataTypes;
import org.elasticsearch.common.settings.Settings;

import java.util.ArrayList;
<a name="2"></a>import java.util.Collections;
import java.util.HashMap;
import java.util.List;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static io.crate.analyze.CopyStatementSettings.COMPRESSION_SETTING;
import static io.crate.analyze.CopyStatementSettings.OUTPUT_FORMAT_SETTING;
import static io.crate.analyze.CopyStatementSettings.settingAsEnum;
import static io.crate.analyze.GenericPropertiesConverter.genericPropertiesToSettings;

public final class CopyToPlan implements Plan {

    private final AnalyzedCopyTo copyTo</b></font>;
    private final TableStats tableStats;

    public CopyToPlan(AnalyzedCopyTo copyTo, TableStats tableStats) {
        this.copyTo = copyTo;
        this.tableStats = tableStats;
    }

    @VisibleForTesting
    AnalyzedCopyTo copyTo() {
        return copyTo;
    }

    @Override
    public StatementType type() {
        return StatementType.COPY;
    }

    @Override
    public void executeOrFail(DependencyCarrier executor,
                              PlannerContext plannerContext,
                              RowConsumer consumer,
                              Row params,
                              SubQueryResults subQueryResults) {
        ExecutionPlan executionPlan = planCopyToExecution(
            copyTo,
            plannerContext,
            tableStats,
            executor.projectionBuilder(),
            params,
<a name="0"></a>            subQueryResults
        );

        NodeOperationTree nodeOpTree = <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>NodeOperationTreeGenerator
            .fromPlan(executionPlan, executor.localNodeId());
        executor.phasesTaskFactory()
            .create(plannerContext.jobId(), List.of(nodeOpTree))
            .execute(consumer, plannerContext.transactionContext());
    }

    @VisibleForTesting</b></font>
    static ExecutionPlan planCopyToExecution(AnalyzedCopyTo copyTo,
                                             PlannerContext context,
                                             TableStats tableStats,
                                             ProjectionBuilder projectionBuilder,
                                             Row params,
                                             SubQueryResults subQueryResults) {
        var boundedCopyTo = bind(
            copyTo,
            context.transactionContext(),
            context.nodeContext(),
            params,
            subQueryResults);

        WriterProjection.OutputFormat outputFormat = boundedCopyTo.outputFormat();
        if (outputFormat == null) {
            outputFormat = boundedCopyTo.columnsDefined() ?
                WriterProjection.OutputFormat.JSON_ARRAY : WriterProjection.OutputFormat.JSON_OBJECT;
        }

        WriterProjection projection = ProjectionBuilder.writerProjection(
            boundedCopyTo.outputs(),
            boundedCopyTo.uri(),
            boundedCopyTo.compressionType(),
            boundedCopyTo.overwrites(),
            boundedCopyTo.outputNames(),
            outputFormat,
<a name="1"></a>            boundedCopyTo.withClauseOptions());

        LogicalPlan collect = Collect.create(
            new DocTableRelation(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>boundedCopyTo.table()),
            boundedCopyTo.outputs(),
            boundedCopyTo.whereClause(),
            tableStats,
            context.params()
        );
        LogicalPlan source = optimizeCollect(context, tableStats, collect);
        ExecutionPlan executionPlan = source.build(context, Set.of(), projectionBuilder, 0, 0, null, null, params, SubQueryResults.EMPTY);
        executionPlan.addProjection</b></font>(projection);

        return Merge.ensureOnHandler(
            executionPlan,
            context,
            List.of(MergeCountProjection.INSTANCE));
    }

    private static LogicalPlan optimizeCollect(PlannerContext context, TableStats tableStats, LogicalPlan collect) {
        OptimizeCollectWhereClauseAccess rewriteCollectToGet = new OptimizeCollectWhereClauseAccess();
        Match&lt;Collect&gt; match = rewriteCollectToGet.pattern().accept(collect, Captures.empty());
        if (match.isPresent()) {
            LogicalPlan plan = rewriteCollectToGet.apply(match.value(),
                                                         match.captures(),
                                                         tableStats,
                                                         context.transactionContext(),
                                                         context.nodeContext());
            return plan == null ? collect : plan;
        }
        return collect;
    }

    @VisibleForTesting
    public static BoundCopyTo bind(AnalyzedCopyTo copyTo,
                                   CoordinatorTxnCtx txnCtx,
                                   NodeContext nodeCtx,
                                   Row parameters,
                                   SubQueryResults subQueryResults) {
        Function&lt;? super Symbol, Object&gt; eval = x -&gt; SymbolEvaluator.evaluate(
            txnCtx,
            nodeCtx,
            x,
            parameters,
            subQueryResults
        );
        DocTableInfo table = (DocTableInfo) copyTo.tableInfo();

        List&lt;String&gt; partitions = resolvePartitions(
            Lists2.map(copyTo.table().partitionProperties(), x -&gt; x.map(eval)),
            table
        );

        List&lt;Symbol&gt; outputs = new ArrayList&lt;&gt;();
        Map&lt;ColumnIdent, Symbol&gt; overwrites = null;
        boolean columnsDefined = false;
        final List&lt;String&gt; outputNames = new ArrayList&lt;&gt;(copyTo.columns().size());
        if (!copyTo.columns().isEmpty()) {
            // TODO: remove outputNames?
            for (Symbol symbol : copyTo.columns()) {
                assert symbol instanceof Reference : "Only references are expected here";
                RefVisitor.visitRefs(symbol, r -&gt; outputNames.add(r.column().sqlFqn()));
                outputs.add(DocReferences.toSourceLookup(symbol));
            }
            columnsDefined = true;
        } else {
            Reference sourceRef;
            if (table.isPartitioned() &amp;&amp; partitions.isEmpty()) {
                // table is partitioned, insert partitioned columns into the output
                overwrites = new HashMap&lt;&gt;();
                for (Reference reference : table.partitionedByColumns()) {
                    if (!(reference instanceof GeneratedReference)) {
                        overwrites.put(reference.column(), reference);
                    }
                }
                if (overwrites.size() &gt; 0) {
                    sourceRef = table.getReference(DocSysColumns.DOC);
                } else {
                    sourceRef = table.getReference(DocSysColumns.RAW);
                }
            } else {
                sourceRef = table.getReference(DocSysColumns.RAW);
            }
            outputs = List.of(sourceRef);
        }

        Settings settings = genericPropertiesToSettings(copyTo.properties().map(eval));

        WriterProjection.CompressionType compressionType =
            settingAsEnum(WriterProjection.CompressionType.class, COMPRESSION_SETTING.get(settings));
        WriterProjection.OutputFormat outputFormat =
            settingAsEnum(WriterProjection.OutputFormat.class, OUTPUT_FORMAT_SETTING.get(settings));

        if (!columnsDefined &amp;&amp; outputFormat == WriterProjection.OutputFormat.JSON_ARRAY) {
            throw new UnsupportedFeatureException("Output format not supported without specifying columns.");
        }

        WhereClause whereClause = new WhereClause(copyTo.whereClause(), partitions, Collections.emptySet());
        return new BoundCopyTo(
            outputs,
            table,
            whereClause,
            Literal.of(DataTypes.STRING.sanitizeValue(eval.apply(copyTo.uri()))),
            compressionType,
            outputFormat,
            outputNames.isEmpty() ? null : outputNames,
            columnsDefined,
            overwrites,
            settings);
    }

    private static List&lt;String&gt; resolvePartitions(List&lt;Assignment&lt;Object&gt;&gt; partitionProperties,
                                                  DocTableInfo table) {
        if (partitionProperties.isEmpty()) {
            return Collections.emptyList();
        }
        var partitionName = PartitionPropertiesAnalyzer.toPartitionName(
            table,
            partitionProperties);
        if (!table.partitions().contains(partitionName)) {
            throw new PartitionUnknownException(partitionName);
        }
        return List.of(partitionName.asIndexName());
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
