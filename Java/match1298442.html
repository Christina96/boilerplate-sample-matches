<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DefaultSchemaIntegrationTest.java & CopyToPlan.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DefaultSchemaIntegrationTest.java & CopyToPlan.java
      </h3>
      <h1 align="center">
        14.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DefaultSchemaIntegrationTest.java (30.927835%)<TH>CopyToPlan.java (9.259259%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1298442-0.html#0',2,'match1298442-1.html#0',3)" NAME="0">(81-88)<TD><A HREF="javascript:ZweiFrames('match1298442-0.html#0',2,'match1298442-1.html#0',3)" NAME="0">(116-123)</A><TD ALIGN=center><FONT COLOR="#ff0000">11</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1298442-0.html#1',2,'match1298442-1.html#1',3)" NAME="1">(61-65)<TD><A HREF="javascript:ZweiFrames('match1298442-0.html#1',2,'match1298442-1.html#1',3)" NAME="1">(153-161)</A><TD ALIGN=center><FONT COLOR="#e70000">10</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1298442-0.html#2',2,'match1298442-1.html#2',3)" NAME="2">(24-37)<TD><A HREF="javascript:ZweiFrames('match1298442-0.html#2',2,'match1298442-1.html#2',3)" NAME="2">(72-83)</A><TD ALIGN=center><FONT COLOR="#d00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultSchemaIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="2"></A>
package io.crate.integrationtests;

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1298442-1.html#2',3,'match1298442-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.testing.SQLResponse;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.File;
import java.nio.file.Paths;

import static org.hamcrest.core.Is.is;

public class DefaultSchemaIntegrationTest extends SQLIntegrationTestCase {


    @Rule</B></FONT>
    public TemporaryFolder tmpFolder = new TemporaryFolder();

    public SQLResponse execute(String stmt, Object[] args, String schema) {
        return execute(stmt, args, createSession(schema));
    }

    @Test
    public void testSelectFromFooSchemaWithRequestHeaders() throws Exception {
        // this test uses all kind of different statements that involve a table to make sure the schema is applied in each case.

        execute(&quot;create table foobar (x string) with (number_of_replicas = 0)&quot;, &quot;foo&quot; );
        ensureYellow();
        waitNoPendingTasksOnAll();
        execute(&quot;alter table foobar set (number_of_replicas = '0-1')&quot;, &quot;foo&quot; );

        assertThat(getTableCount(&quot;foo&quot;, &quot;foobar&quot;), is(1L));
        assertThat(getTableCount(&quot;doc&quot;, &quot;foobar&quot;), is(0L));

        execute(&quot;insert into foobar (x) values ('a'), ('b')&quot;, &quot;foo&quot;);
        execute(&quot;refresh table foobar&quot;, &quot;foo&quot;);
<A NAME="1"></A>        execute(&quot;update foobar set x = 'c'&quot;, &quot;foo&quot;);
        assertThat(response.rowCount(), is(2L));

        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1298442-1.html#1',3,'match1298442-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>execute(&quot;select * from foobar&quot;, &quot;foo&quot;);
        assertThat(response.rowCount(), is(2L));

        File foobarExport = tmpFolder.newFolder(&quot;foobar_export&quot;);
        String uriTemplate = Paths.get</B></FONT>(foobarExport.toURI()).toUri().toString();
        execute(&quot;copy foobar to directory ?&quot;, new Object[]{uriTemplate}, &quot;foo&quot;);
        refresh();
        execute(&quot;delete from foobar&quot;, &quot;foo&quot;);
        refresh();

        execute(&quot;select * from foobar&quot;, &quot;foo&quot;);
        assertThat(response.rowCount(), is(0L));

        execute(&quot;copy foobar from ? with (shared=True)&quot;, new Object[]{uriTemplate + &quot;*&quot;}, &quot;foo&quot;);
        execute(&quot;refresh table foobar&quot;, &quot;foo&quot;);
        execute(&quot;select * from foobar&quot;, &quot;foo&quot;);
        assertThat(response.rowCount(), is(2L));
<A NAME="0"></A>
        execute(&quot;insert into foobar (x) (select x from foobar)&quot;, &quot;foo&quot;);
        execute(&quot;refresh table foobar&quot;, &quot;foo&quot;);
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1298442-1.html#0',3,'match1298442-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>execute(&quot;select * from foobar&quot;, &quot;foo&quot;);
        assertThat(response.rowCount(), is(4L));

        execute(&quot;drop table foobar&quot;, &quot;foo&quot;);
        assertThat(getTableCount(&quot;foo&quot;, &quot;foobar&quot;), is(0L));
    }

    private long </B></FONT>getTableCount(String schema, String tableName) {
        execute(&quot;select count(*) from information_schema.tables where table_schema = ? and table_name = ?&quot;,
            new Object[]{schema, tableName});
        return ((long) response.rows()[0][0]);
    }

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CopyToPlan.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.planner.statement;

import io.crate.analyze.AnalyzedCopyTo;
import io.crate.analyze.BoundCopyTo;
import io.crate.analyze.PartitionPropertiesAnalyzer;
import io.crate.analyze.SymbolEvaluator;
import io.crate.analyze.WhereClause;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.data.RowConsumer;
import io.crate.exceptions.PartitionUnknownException;
import io.crate.exceptions.UnsupportedFeatureException;
import io.crate.execution.dsl.phases.NodeOperationTree;
import io.crate.execution.dsl.projection.MergeCountProjection;
import io.crate.execution.dsl.projection.WriterProjection;
import io.crate.execution.dsl.projection.builder.ProjectionBuilder;
import io.crate.execution.engine.NodeOperationTreeGenerator;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.RefVisitor;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.DocReferences;
import io.crate.metadata.GeneratedReference;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Reference;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.ExecutionPlan;
import io.crate.planner.Merge;
import io.crate.planner.Plan;
import io.crate.planner.PlannerContext;
import io.crate.planner.operators.Collect;
import io.crate.planner.operators.LogicalPlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.planner.optimizer.matcher.Captures;
import io.crate.planner.optimizer.matcher.Match;
import io.crate.planner.optimizer.rule.OptimizeCollectWhereClauseAccess;
import io.crate.sql.tree.Assignment;
import io.crate.statistics.TableStats;
import io.crate.types.DataTypes;
import org.elasticsearch.common.settings.Settings;

import java.util.ArrayList;
<A NAME="2"></A>import java.util.Collections;
import java.util.HashMap;
import java.util.List;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1298442-0.html#2',2,'match1298442-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static io.crate.analyze.CopyStatementSettings.COMPRESSION_SETTING;
import static io.crate.analyze.CopyStatementSettings.OUTPUT_FORMAT_SETTING;
import static io.crate.analyze.CopyStatementSettings.settingAsEnum;
import static io.crate.analyze.GenericPropertiesConverter.genericPropertiesToSettings;

public final class CopyToPlan implements Plan {

    private final AnalyzedCopyTo copyTo</B></FONT>;
    private final TableStats tableStats;

    public CopyToPlan(AnalyzedCopyTo copyTo, TableStats tableStats) {
        this.copyTo = copyTo;
        this.tableStats = tableStats;
    }

    @VisibleForTesting
    AnalyzedCopyTo copyTo() {
        return copyTo;
    }

    @Override
    public StatementType type() {
        return StatementType.COPY;
    }

    @Override
    public void executeOrFail(DependencyCarrier executor,
                              PlannerContext plannerContext,
                              RowConsumer consumer,
                              Row params,
                              SubQueryResults subQueryResults) {
        ExecutionPlan executionPlan = planCopyToExecution(
            copyTo,
            plannerContext,
            tableStats,
            executor.projectionBuilder(),
            params,
<A NAME="0"></A>            subQueryResults
        );

        NodeOperationTree nodeOpTree = <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1298442-0.html#0',2,'match1298442-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>NodeOperationTreeGenerator
            .fromPlan(executionPlan, executor.localNodeId());
        executor.phasesTaskFactory()
            .create(plannerContext.jobId(), List.of(nodeOpTree))
            .execute(consumer, plannerContext.transactionContext());
    }

    @VisibleForTesting</B></FONT>
    static ExecutionPlan planCopyToExecution(AnalyzedCopyTo copyTo,
                                             PlannerContext context,
                                             TableStats tableStats,
                                             ProjectionBuilder projectionBuilder,
                                             Row params,
                                             SubQueryResults subQueryResults) {
        var boundedCopyTo = bind(
            copyTo,
            context.transactionContext(),
            context.nodeContext(),
            params,
            subQueryResults);

        WriterProjection.OutputFormat outputFormat = boundedCopyTo.outputFormat();
        if (outputFormat == null) {
            outputFormat = boundedCopyTo.columnsDefined() ?
                WriterProjection.OutputFormat.JSON_ARRAY : WriterProjection.OutputFormat.JSON_OBJECT;
        }

        WriterProjection projection = ProjectionBuilder.writerProjection(
            boundedCopyTo.outputs(),
            boundedCopyTo.uri(),
            boundedCopyTo.compressionType(),
            boundedCopyTo.overwrites(),
            boundedCopyTo.outputNames(),
            outputFormat,
<A NAME="1"></A>            boundedCopyTo.withClauseOptions());

        LogicalPlan collect = Collect.create(
            new DocTableRelation(<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1298442-0.html#1',2,'match1298442-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>boundedCopyTo.table()),
            boundedCopyTo.outputs(),
            boundedCopyTo.whereClause(),
            tableStats,
            context.params()
        );
        LogicalPlan source = optimizeCollect(context, tableStats, collect);
        ExecutionPlan executionPlan = source.build(context, Set.of(), projectionBuilder, 0, 0, null, null, params, SubQueryResults.EMPTY);
        executionPlan.addProjection</B></FONT>(projection);

        return Merge.ensureOnHandler(
            executionPlan,
            context,
            List.of(MergeCountProjection.INSTANCE));
    }

    private static LogicalPlan optimizeCollect(PlannerContext context, TableStats tableStats, LogicalPlan collect) {
        OptimizeCollectWhereClauseAccess rewriteCollectToGet = new OptimizeCollectWhereClauseAccess();
        Match&lt;Collect&gt; match = rewriteCollectToGet.pattern().accept(collect, Captures.empty());
        if (match.isPresent()) {
            LogicalPlan plan = rewriteCollectToGet.apply(match.value(),
                                                         match.captures(),
                                                         tableStats,
                                                         context.transactionContext(),
                                                         context.nodeContext());
            return plan == null ? collect : plan;
        }
        return collect;
    }

    @VisibleForTesting
    public static BoundCopyTo bind(AnalyzedCopyTo copyTo,
                                   CoordinatorTxnCtx txnCtx,
                                   NodeContext nodeCtx,
                                   Row parameters,
                                   SubQueryResults subQueryResults) {
        Function&lt;? super Symbol, Object&gt; eval = x -&gt; SymbolEvaluator.evaluate(
            txnCtx,
            nodeCtx,
            x,
            parameters,
            subQueryResults
        );
        DocTableInfo table = (DocTableInfo) copyTo.tableInfo();

        List&lt;String&gt; partitions = resolvePartitions(
            Lists2.map(copyTo.table().partitionProperties(), x -&gt; x.map(eval)),
            table
        );

        List&lt;Symbol&gt; outputs = new ArrayList&lt;&gt;();
        Map&lt;ColumnIdent, Symbol&gt; overwrites = null;
        boolean columnsDefined = false;
        final List&lt;String&gt; outputNames = new ArrayList&lt;&gt;(copyTo.columns().size());
        if (!copyTo.columns().isEmpty()) {
            // TODO: remove outputNames?
            for (Symbol symbol : copyTo.columns()) {
                assert symbol instanceof Reference : &quot;Only references are expected here&quot;;
                RefVisitor.visitRefs(symbol, r -&gt; outputNames.add(r.column().sqlFqn()));
                outputs.add(DocReferences.toSourceLookup(symbol));
            }
            columnsDefined = true;
        } else {
            Reference sourceRef;
            if (table.isPartitioned() &amp;&amp; partitions.isEmpty()) {
                // table is partitioned, insert partitioned columns into the output
                overwrites = new HashMap&lt;&gt;();
                for (Reference reference : table.partitionedByColumns()) {
                    if (!(reference instanceof GeneratedReference)) {
                        overwrites.put(reference.column(), reference);
                    }
                }
                if (overwrites.size() &gt; 0) {
                    sourceRef = table.getReference(DocSysColumns.DOC);
                } else {
                    sourceRef = table.getReference(DocSysColumns.RAW);
                }
            } else {
                sourceRef = table.getReference(DocSysColumns.RAW);
            }
            outputs = List.of(sourceRef);
        }

        Settings settings = genericPropertiesToSettings(copyTo.properties().map(eval));

        WriterProjection.CompressionType compressionType =
            settingAsEnum(WriterProjection.CompressionType.class, COMPRESSION_SETTING.get(settings));
        WriterProjection.OutputFormat outputFormat =
            settingAsEnum(WriterProjection.OutputFormat.class, OUTPUT_FORMAT_SETTING.get(settings));

        if (!columnsDefined &amp;&amp; outputFormat == WriterProjection.OutputFormat.JSON_ARRAY) {
            throw new UnsupportedFeatureException(&quot;Output format not supported without specifying columns.&quot;);
        }

        WhereClause whereClause = new WhereClause(copyTo.whereClause(), partitions, Collections.emptySet());
        return new BoundCopyTo(
            outputs,
            table,
            whereClause,
            Literal.of(DataTypes.STRING.sanitizeValue(eval.apply(copyTo.uri()))),
            compressionType,
            outputFormat,
            outputNames.isEmpty() ? null : outputNames,
            columnsDefined,
            overwrites,
            settings);
    }

    private static List&lt;String&gt; resolvePartitions(List&lt;Assignment&lt;Object&gt;&gt; partitionProperties,
                                                  DocTableInfo table) {
        if (partitionProperties.isEmpty()) {
            return Collections.emptyList();
        }
        var partitionName = PartitionPropertiesAnalyzer.toPartitionName(
            table,
            partitionProperties);
        if (!table.partitions().contains(partitionName)) {
            throw new PartitionUnknownException(partitionName);
        }
        return List.of(partitionName.asIndexName());
    }
}
</PRE>
</div>
  </div>
</body>
</html>
