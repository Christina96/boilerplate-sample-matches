<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ClassicFilterFactory.java &amp; MetadataMappingService.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ClassicFilterFactory.java &amp; MetadataMappingService.java
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ClassicFilterFactory.java (42.307693%)<th>MetadataMappingService.java (2.1611001%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(34-40)<td><a href="#" name="0">(338-344)</a><td align="center"><font color="#ff0000">11</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClassicFilterFactory.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.analysis.common;
2 import org.apache.lucene.analysis.TokenStream;
3 import org.apache.lucene.analysis.standard.ClassicFilter;
4 import org.elasticsearch.common.settings.Settings;
5 import org.elasticsearch.env.Environment;
6 import org.elasticsearch.index.IndexSettings;
7 import org.elasticsearch.index.analysis.AbstractTokenFilterFactory;
8 public class ClassicFilterFactory extends AbstractTokenFilterFactory {
9     ClassicFilterFactory(IndexSettings indexSettings, Environment environment, <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>String name, Settings settings) {
10         super(indexSettings, name, settings);
11     }
12     @Override
13     public TokenStream create(TokenStream tokenStream) {
14         return</b></font> new ClassicFilter(tokenStream);
15     }
16 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MetadataMappingService.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.cluster.metadata;
2 import org.apache.logging.log4j.LogManager;
3 import org.apache.logging.log4j.Logger;
4 import org.apache.logging.log4j.message.ParameterizedMessage;
5 import org.elasticsearch.action.ActionListener;
6 import org.elasticsearch.action.admin.indices.mapping.put.PutMappingClusterStateUpdateRequest;
7 import org.elasticsearch.cluster.AckedClusterStateTaskListener;
8 import org.elasticsearch.cluster.ClusterState;
9 import org.elasticsearch.cluster.ClusterStateTaskConfig;
10 import org.elasticsearch.cluster.ClusterStateTaskExecutor;
11 import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;
12 import org.elasticsearch.cluster.node.DiscoveryNode;
13 import org.elasticsearch.cluster.service.ClusterService;
14 import javax.annotation.Nullable;
15 import org.elasticsearch.common.Priority;
16 import org.elasticsearch.common.compress.CompressedXContent;
17 import org.elasticsearch.common.inject.Inject;
18 import io.crate.common.unit.TimeValue;
19 import io.crate.common.io.IOUtils;
20 import org.elasticsearch.index.Index;
21 import org.elasticsearch.index.IndexService;
22 import org.elasticsearch.index.mapper.DocumentMapper;
23 import org.elasticsearch.index.mapper.MapperService;
24 import org.elasticsearch.index.mapper.MapperService.MergeReason;
25 import org.elasticsearch.indices.IndicesService;
26 import java.io.IOException;
27 import java.util.ArrayList;
28 import java.util.Collections;
29 import java.util.HashMap;
30 import java.util.List;
31 import java.util.Map;
32 import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;
33 public class MetadataMappingService {
34     private static final Logger LOGGER = LogManager.getLogger(MetadataMappingService.class);
35     private final ClusterService clusterService;
36     private final IndicesService indicesService;
37     final RefreshTaskExecutor refreshExecutor = new RefreshTaskExecutor();
38     public final PutMappingExecutor putMappingExecutor = new PutMappingExecutor();
39     @Inject
40     public MetadataMappingService(ClusterService clusterService, IndicesService indicesService) {
41         this.clusterService = clusterService;
42         this.indicesService = indicesService;
43     }
44     static class RefreshTask {
45         final String index;
46         final String indexUUID;
47         RefreshTask(String index, final String indexUUID) {
48             this.index = index;
49             this.indexUUID = indexUUID;
50         }
51         @Override
52         public String toString() {
53             return "[" + index + "][" + indexUUID + "]";
54         }
55     }
56     class RefreshTaskExecutor implements ClusterStateTaskExecutor&lt;RefreshTask&gt; {
57         @Override
58         public ClusterTasksResult&lt;RefreshTask&gt; execute(ClusterState currentState, List&lt;RefreshTask&gt; tasks) throws Exception {
59             ClusterState newClusterState = executeRefresh(currentState, tasks);
60             return ClusterTasksResult.&lt;RefreshTask&gt;builder().successes(tasks).build(newClusterState);
61         }
62     }
63     ClusterState executeRefresh(final ClusterState currentState, final List&lt;RefreshTask&gt; allTasks) throws Exception {
64         Map&lt;String, List&lt;RefreshTask&gt;&gt; tasksPerIndex = new HashMap&lt;&gt;();
65         for (RefreshTask task : allTasks) {
66             if (task.index == null) {
67                 LOGGER.debug("ignoring a mapping task of type [{}] with a null index.", task);
68             }
69             tasksPerIndex.computeIfAbsent(task.index, k -&gt; new ArrayList&lt;&gt;()).add(task);
70         }
71         boolean dirty = false;
72         Metadata.Builder mdBuilder = Metadata.builder(currentState.metadata());
73         for (Map.Entry&lt;String, List&lt;RefreshTask&gt;&gt; entry : tasksPerIndex.entrySet()) {
74             IndexMetadata indexMetadata = mdBuilder.get(entry.getKey());
75             if (indexMetadata == null) {
76                 LOGGER.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey());
77                 continue;
78             }
79             final Index index = indexMetadata.getIndex();
80             List&lt;RefreshTask&gt; allIndexTasks = entry.getValue();
81             boolean hasTaskWithRightUUID = false;
82             for (RefreshTask task : allIndexTasks) {
83                 if (indexMetadata.isSameUUID(task.indexUUID)) {
84                     hasTaskWithRightUUID = true;
85                 } else {
86                     LOGGER.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task);
87                 }
88             }
89             if (hasTaskWithRightUUID == false) {
90                 continue;
91             }
92             boolean removeIndex = false;
93             IndexService indexService = indicesService.indexService(indexMetadata.getIndex());
94             if (indexService == null) {
95                 indexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);
96                 removeIndex = true;
97                 indexService.mapperService().merge(indexMetadata, MergeReason.MAPPING_RECOVERY);
98             }
99             IndexMetadata.Builder builder = IndexMetadata.builder(indexMetadata);
100             try {
101                 boolean indexDirty = refreshIndexMapping(indexService, builder);
102                 if (indexDirty) {
103                     mdBuilder.put(builder);
104                     dirty = true;
105                 }
106             } finally {
107                 if (removeIndex) {
108                     indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing");
109                 }
110             }
111         }
112         if (!dirty) {
113             return currentState;
114         }
115         return ClusterState.builder(currentState).metadata(mdBuilder).build();
116     }
117     private boolean refreshIndexMapping(IndexService indexService, IndexMetadata.Builder builder) {
118         boolean dirty = false;
119         String index = indexService.index().getName();
120         try {
121             List&lt;String&gt; updatedTypes = new ArrayList&lt;&gt;();
122             DocumentMapper mapper = indexService.mapperService().documentMapper();
123             if (mapper != null) {
124                 final String type = mapper.type();
125                 if (!mapper.mappingSource().equals(builder.mapping(type).source())) {
126                     updatedTypes.add(type);
127                 }
128             }
129             if (updatedTypes.isEmpty() == false) {
130                 LOGGER.warn("[{}] re-syncing mappings with cluster state because of types [{}]", index, updatedTypes);
131                 dirty = true;
132                 if (mapper != null) {
133                     builder.putMapping(new MappingMetadata(mapper));
134                 }
135             }
136         } catch (Exception e) {
137             LOGGER.warn(() -&gt; new ParameterizedMessage("[{}] failed to refresh-mapping in cluster state", index), e);
138         }
139         return dirty;
140     }
141     public void refreshMapping(final String index, final String indexUUID) {
142         final RefreshTask refreshTask = new RefreshTask(index, indexUUID);
143         clusterService.submitStateUpdateTask("refresh-mapping",
144             refreshTask,
145             ClusterStateTaskConfig.build(Priority.HIGH),
146             refreshExecutor,
147             (source, e) -&gt; LOGGER.warn(() -&gt; new ParameterizedMessage("failure during [{}]", source), e)
148         );
149     }
150     public class PutMappingExecutor implements ClusterStateTaskExecutor&lt;PutMappingClusterStateUpdateRequest&gt; {
151         @Override
152         public ClusterTasksResult&lt;PutMappingClusterStateUpdateRequest&gt; execute(ClusterState currentState,
153                                                                                List&lt;PutMappingClusterStateUpdateRequest&gt; tasks) throws Exception {
154             Map&lt;Index, MapperService&gt; indexMapperServices = new HashMap&lt;&gt;();
155             ClusterTasksResult.Builder&lt;PutMappingClusterStateUpdateRequest&gt; builder = ClusterTasksResult.builder();
156             try {
157                 for (PutMappingClusterStateUpdateRequest request : tasks) {
158                     try {
159                         for (Index index : request.indices()) {
160                             final IndexMetadata indexMetadata = currentState.metadata().getIndexSafe(index);
161                             if (indexMapperServices.containsKey(indexMetadata.getIndex()) == false) {
162                                 MapperService mapperService = indicesService.createIndexMapperService(indexMetadata);
163                                 indexMapperServices.put(index, mapperService);
164                                 mapperService.merge(indexMetadata, MergeReason.MAPPING_RECOVERY);
165                             }
166                         }
167                         currentState = applyRequest(currentState, request, indexMapperServices);
168                         builder.success(request);
169                     } catch (Exception e) {
170                         builder.failure(request, e);
171                     }
172                 }
173                 return builder.build(currentState);
174             } finally {
175                 IOUtils.close(indexMapperServices.values());
176             }
177         }
178         public ClusterState applyRequest(ClusterState currentState, PutMappingClusterStateUpdateRequest request,
179                                           Map&lt;Index, MapperService&gt; indexMapperServices) throws IOException {
180             CompressedXContent mappingUpdateSource = new CompressedXContent(request.source());
181             final Metadata metadata = currentState.metadata();
182             final List&lt;IndexMetadata&gt; updateList = new ArrayList&lt;&gt;();
183             for (Index index : request.indices()) {
184                 MapperService mapperService = indexMapperServices.get(index);
185                 final IndexMetadata indexMetadata = currentState.getMetadata().getIndexSafe(index);
186                 updateList.add(indexMetadata);
187                 DocumentMapper existingMapper = mapperService.documentMapper();
188                 DocumentMapper newMapper = mapperService.parse(MapperService.SINGLE_MAPPING_NAME, mappingUpdateSource);
189                 if (existingMapper != null) {
190                     existingMapper.merge(newMapper.mapping());
191                 }
192             }
193             Metadata.Builder builder = Metadata.builder(metadata);
194             boolean updated = false;
195             for (IndexMetadata indexMetadata : updateList) {
196                 boolean updatedMapping = false;
197                 final Index index = indexMetadata.getIndex();
198                 final MapperService mapperService = indexMapperServices.get(index);
199                 CompressedXContent existingSource = null;
200                 DocumentMapper existingMapper = mapperService.documentMapper();
201                 if (existingMapper != null) {
202                     existingSource = existingMapper.mappingSource();
203                 }
204                 DocumentMapper mergedMapper
205                     = mapperService.merge(MapperService.SINGLE_MAPPING_NAME, mappingUpdateSource, MergeReason.MAPPING_UPDATE);
206                 CompressedXContent updatedSource = mergedMapper.mappingSource();
207                 if (existingSource != null) {
208                     if (existingSource.equals(updatedSource)) {
209                     } else {
210                         updatedMapping = true;
211                         if (LOGGER.isDebugEnabled()) {
212                             LOGGER.debug("{} update_mapping [{}] with source [{}]", index, mergedMapper.type(), updatedSource);
213                         } else if (LOGGER.isInfoEnabled()) {
214                             LOGGER.info("{} update_mapping [{}]", index, mergedMapper.type());
215                         }
216                     }
217                 } else {
218                     updatedMapping = true;
219                     if (LOGGER.isDebugEnabled()) {
220                         LOGGER.debug("{} create_mapping with source [{}]", index, updatedSource);
221                     } else if (LOGGER.isInfoEnabled()) {
222                         LOGGER.info("{} create_mapping", index);
223                     }
224                 }
225                 IndexMetadata.Builder indexMetadataBuilder = IndexMetadata.builder(indexMetadata);
226                 DocumentMapper mapper = mapperService.documentMapper();
227                 if (mapper != null) {
228                     indexMetadataBuilder.putMapping(new MappingMetadata(mapper.mappingSource()));
229                 }
230                 if (updatedMapping) {
231                     indexMetadataBuilder.mappingVersion(1 + indexMetadataBuilder.mappingVersion());
232                 }
233                 /*
234                  * This implicitly increments the index metadata version and builds the index metadata. This means that we need to have
235                  * already incremented the mapping version if necessary. Therefore, the mapping version increment must remain before this
236                  * statement.
237                  */
238                 builder.put(indexMetadataBuilder);
239                 updated |= updatedMapping;
240             }
241             if (updated) {
242                 return ClusterState.builder(currentState).metadata(builder).build();
243             } else {
244                 return currentState;
245             }
246         }
247     }
248     public void putMapping(final PutMappingClusterStateUpdateRequest request, final ActionListener&lt;ClusterStateUpdateResponse&gt; listener) {
249         clusterService.submitStateUpdateTask("put-mapping",
250                 request,
251                 ClusterStateTaskConfig.build(Priority.HIGH, request.masterNodeTimeout()),
252                 putMappingExecutor,
253 <a name="0"></a>                new AckedClusterStateTaskListener() {
254                     @Override
255                     public void onFailure(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String source, Exception e) {
256                         listener.onFailure(e);
257                     }
258                     @Override
259                     public boolean mustAck(DiscoveryNode discoveryNode) {
260                         return</b></font> true;
261                     }
262                     @Override
263                     public void onAllNodesAcked(@Nullable Exception e) {
264                         listener.onResponse(new ClusterStateUpdateResponse(e == null));
265                     }
266                     @Override
267                     public void onAckTimeout() {
268                         listener.onResponse(new ClusterStateUpdateResponse(false));
269                     }
270                     @Override
271                     public TimeValue ackTimeout() {
272                         return request.ackTimeout();
273                     }
274                 });
275     }
276 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
