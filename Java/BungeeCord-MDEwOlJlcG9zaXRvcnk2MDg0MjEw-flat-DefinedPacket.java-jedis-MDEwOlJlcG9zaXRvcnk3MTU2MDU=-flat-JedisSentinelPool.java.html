
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.031446540880504%, Tokens: 10</h2>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</h3>
            <pre><code>1  package net.md_5.bungee.protocol;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import io.netty.buffer.ByteBuf;
5  import io.netty.buffer.ByteBufInputStream;
6  import io.netty.buffer.ByteBufOutputStream;
7  import java.io.DataInputStream;
8  import java.io.DataOutputStream;
9  import java.io.IOException;
10  import java.util.ArrayList;
11  import java.util.Arrays;
12  import java.util.BitSet;
13  import java.util.EnumSet;
14  import java.util.List;
15  import java.util.UUID;
16  import lombok.RequiredArgsConstructor;
17  import se.llbit.nbt.NamedTag;
18  import se.llbit.nbt.Tag;
19  @RequiredArgsConstructor
20  public abstract class DefinedPacket
21  {
22      public static void writeString(String s, ByteBuf buf)
23      {
24          writeString( s, buf, Short.MAX_VALUE );
25      }
26      public static void writeString(String s, ByteBuf buf, int maxLength)
27      {
28          if ( s.length() > maxLength )
29          {
30              throw new OverflowPacketException( "Cannot send string longer than " + maxLength + " (got " + s.length() + " characters)" );
31          }
32          byte[] b = s.getBytes( Charsets.UTF_8 );
33          if ( b.length > maxLength * 3 )
34          {
35              throw new OverflowPacketException( "Cannot send string longer than " + ( maxLength * 3 ) + " (got " + b.length + " bytes)" );
36          }
37          writeVarInt( b.length, buf );
38          buf.writeBytes( b );
39      }
40      public static String readString(ByteBuf buf)
41      {
42          return readString( buf, Short.MAX_VALUE );
43      }
44      public static String readString(ByteBuf buf, int maxLen)
45      {
46          int len = readVarInt( buf );
47          if ( len > maxLen * 3 )
48          {
49              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen * 3 + " (got " + len + " bytes)" );
50          }
51          String s = buf.toString( buf.readerIndex(), len, Charsets.UTF_8 );
52          buf.readerIndex( buf.readerIndex() + len );
53          if ( s.length() > maxLen )
54          {
55              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen + " (got " + s.length() + " characters)" );
56          }
57          return s;
58      }
59      public static void writeArray(byte[] b, ByteBuf buf)
60      {
61          if ( b.length > Short.MAX_VALUE )
62          {
63              throw new OverflowPacketException( "Cannot send byte array longer than Short.MAX_VALUE (got " + b.length + " bytes)" );
64          }
65          writeVarInt( b.length, buf );
66          buf.writeBytes( b );
67      }
68      public static byte[] toArray(ByteBuf buf)
69      {
70          byte[] ret = new byte[ buf.readableBytes() ];
71          buf.readBytes( ret );
72          return ret;
73      }
74      public static byte[] readArray(ByteBuf buf)
75      {
76          return readArray( buf, buf.readableBytes() );
77      }
78      public static byte[] readArray(ByteBuf buf, int limit)
79      {
80          int len = readVarInt( buf );
81          if ( len > limit )
82          {
83              throw new OverflowPacketException( "Cannot receive byte array longer than " + limit + " (got " + len + " bytes)" );
84          }
85          byte[] ret = new byte[ len ];
86          buf.readBytes( ret );
87          return ret;
88      }
89      public static int[] readVarIntArray(ByteBuf buf)
90      {
91          int len = readVarInt( buf );
92          int[] ret = new int[ len ];
93          for ( int i = 0; i < len; i++ )
94          {
95              ret[i] = readVarInt( buf );
96          }
97          return ret;
98      }
99      public static void writeStringArray(List<String> s, ByteBuf buf)
100      {
101          writeVarInt( s.size(), buf );
102          for ( String str : s )
103          {
104              writeString( str, buf );
105          }
106      }
107      public static List<String> readStringArray(ByteBuf buf)
108      {
109          int len = readVarInt( buf );
110          List<String> ret = new ArrayList<>( len );
111          for ( int i = 0; i < len; i++ )
112          {
113              ret.add( readString( buf ) );
114          }
115          return ret;
116      }
117      public static int readVarInt(ByteBuf input)
118      {
119          return readVarInt( input, 5 );
120      }
121      public static int readVarInt(ByteBuf input, int maxBytes)
122      {
123          int out = 0;
124          int bytes = 0;
125          byte in;
126          while ( true )
127          {
128              in = input.readByte();
129              out |= ( in & 0x7F ) << ( bytes++ * 7 );
130              if ( bytes > maxBytes )
131              {
132                  throw new RuntimeException( "VarInt too big" );
133              }
134              if ( ( in & 0x80 ) != 0x80 )
135              {
136                  break;
137              }
138          }
139          return out;
140      }
141      public static void writeVarInt(int value, ByteBuf output)
142      {
143          int part;
144          while ( true )
145          {
146              part = value & 0x7F;
147              value >>>= 7;
148              if ( value != 0 )
149              {
150                  part |= 0x80;
151              }
152              output.writeByte( part );
153              if ( value == 0 )
154              {
155                  break;
156              }
157          }
158      }
159      public static int readVarShort(ByteBuf buf)
160      {
161          int low = buf.readUnsignedShort();
162          int high = 0;
163          if ( ( low & 0x8000 ) != 0 )
164          {
165              low = low & 0x7FFF;
166              high = buf.readUnsignedByte();
167          }
168          return ( ( high & 0xFF ) << 15 ) | low;
169      }
170      public static void writeVarShort(ByteBuf buf, int toWrite)
171      {
172          int low = toWrite & 0x7FFF;
173          int high = ( toWrite & 0x7F8000 ) >> 15;
174          if ( high != 0 )
175          {
176              low = low | 0x8000;
177          }
178          buf.writeShort( low );
179          if ( high != 0 )
180          {
181              buf.writeByte( high );
182          }
183      }
184      public static void writeUUID(UUID value, ByteBuf output)
185      {
186          output.writeLong( value.getMostSignificantBits() );
187          output.writeLong( value.getLeastSignificantBits() );
188      }
189      public static UUID readUUID(ByteBuf input)
190      {
191          return new UUID( input.readLong(), input.readLong() );
192      }
193      public static void writeProperties(Property[] properties, ByteBuf buf)
194      {
195          if ( properties == null )
196          {
197              writeVarInt( 0, buf );
198              return;
199          }
200          writeVarInt( properties.length, buf );
201          for ( Property prop : properties )
202          {
203              writeString( prop.getName(), buf );
204              writeString( prop.getValue(), buf );
205              if ( prop.getSignature() != null )
206              {
207                  buf.writeBoolean( true );
208                  writeString( prop.getSignature(), buf );
209              } else
210              {
211                  buf.writeBoolean( false );
212              }
213          }
214      }
215      public static Property[] readProperties(ByteBuf buf)
216      {
217          Property[] properties = new Property[ DefinedPacket.readVarInt( buf ) ];
218          for ( int j = 0; j < properties.length; j++ )
219          {
220              String name = readString( buf );
221              String value = readString( buf );
222              if ( buf.readBoolean() )
223              {
224                  properties[j] = new Property( name, value, DefinedPacket.readString( buf ) );
225              } else
226              {
227                  properties[j] = new Property( name, value );
228              }
229          }
230          return properties;
231      }
232      public static void writePublicKey(PlayerPublicKey publicKey, ByteBuf buf)
233      {
234          if ( publicKey != null )
235          {
236              buf.writeBoolean( true );
237              buf.writeLong( publicKey.getExpiry() );
238              writeArray( publicKey.getKey(), buf );
239              writeArray( publicKey.getSignature(), buf );
240          } else
241          {
242              buf.writeBoolean( false );
243          }
244      }
245      public static PlayerPublicKey readPublicKey(ByteBuf buf)
246      {
247          if ( buf.readBoolean() )
248          {
249              return new PlayerPublicKey( buf.readLong(), readArray( buf, 512 ), readArray( buf, 4096 ) );
250          }
251          return null;
252      }
253      public static Tag readTag(ByteBuf input)
254      {
255          Tag tag = NamedTag.read( new DataInputStream( new ByteBufInputStream( input ) ) );
256          Preconditions.checkArgument( !tag.isError(), "Error reading tag: %s", tag.error() );
257          return tag;
258      }
259      public static void writeTag(Tag tag, ByteBuf output)
260      {
261          try
262          {
263              tag.write( new DataOutputStream( new ByteBufOutputStream( output ) ) );
264          } catch ( IOException ex )
265          {
266              throw new RuntimeException( "Exception writing tag", ex );
267          }
268      }
269      public static <E extends Enum<E>> void writeEnumSet(EnumSet<E> enumset, Class<E> oclass, ByteBuf buf)
270      {
271          E[] enums = oclass.getEnumConstants();
272          BitSet bits = new BitSet( enums.length );
273          for ( int i = 0; i < enums.length; ++i )
274          {
275              bits.set( i, enumset.contains( enums[i] ) );
276          }
277          writeFixedBitSet( bits, enums.length, buf );
278      }
279      public static <E extends Enum<E>> EnumSet<E> readEnumSet(Class<E> oclass, ByteBuf buf)
280      {
281          E[] enums = oclass.getEnumConstants();
282          BitSet bits = readFixedBitSet( enums.length, buf );
283          EnumSet<E> set = EnumSet.noneOf( oclass );
284          for ( int i = 0; i < enums.length; ++i )
285          {
286              if ( bits.get( i ) )
287              {
288                  set.add( enums[i] );
289              }
290          }
291          return set;
292      }
293      public static BitSet readFixedBitSet(int i, ByteBuf buf)
294      {
295          byte[] bits = new byte[ ( i + 8 ) >> 3 ];
296          buf.readBytes( bits );
297          return BitSet.valueOf( bits );
298      }
299      public static void writeFixedBitSet(BitSet bits, int size, ByteBuf buf)
300      {
301          if ( bits.length() > size )
302          {
303              throw new OverflowPacketException( "BitSet too large (expected " + size + " got " + bits.size() + ")" );
304          }
305          buf.writeBytes( Arrays.copyOf( bits.toByteArray(), ( size + 8 ) >> 3 ) );
306      }
307      public void read(ByteBuf buf)
308      {
<span onclick='openModal()' class='match'>309          throw new UnsupportedOperationException( "Packet must implement read method" );
310      }
311      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
312      {
313          read( buf );
314      }
315      public void write(ByteBuf buf)
</span>316      {
317          throw new UnsupportedOperationException( "Packet must implement write method" );
318      }
319      public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
320      {
321          write( buf );
322      }
323      public abstract void handle(AbstractPacketHandler handler) throws Exception;
324      @Override
325      public abstract boolean equals(Object obj);
326      @Override
327      public abstract int hashCode();
328      @Override
329      public abstract String toString();
330  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-JedisSentinelPool.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.util.ArrayList;
3  import java.util.Arrays;
4  import java.util.Collection;
5  import java.util.List;
6  import java.util.Set;
7  import java.util.concurrent.atomic.AtomicBoolean;
8  import java.util.stream.Collectors;
9  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
10  import org.slf4j.Logger;
11  import org.slf4j.LoggerFactory;
12  import redis.clients.jedis.exceptions.JedisConnectionException;
13  import redis.clients.jedis.exceptions.JedisException;
14  import redis.clients.jedis.util.Pool;
15  public class JedisSentinelPool extends Pool<Jedis> {
16    private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);
17    private final JedisFactory factory;
18    private final JedisClientConfig sentinelClientConfig;
19    protected final Collection<MasterListener> masterListeners = new ArrayList<>();
20    private volatile HostAndPort currentHostMaster;
21    private final Object initPoolLock = new Object();
22    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,
23        final JedisClientConfig masteClientConfig, final JedisClientConfig sentinelClientConfig) {
<span onclick='openModal()' class='match'>24      this(masterName, sentinels, new JedisFactory(masteClientConfig), sentinelClientConfig);
25    }
26    public JedisSentinelPool(String masterName, Set<String> sentinels,
27        final GenericObjectPoolConfig<Jedis> poolConfig) {
28      this(masterName, sentinels, poolConfig, Protocol.DEFAULT_TIMEOUT, null,
29          Protocol.DEFAULT_DATABASE);
30    }
31    public JedisSentinelPool(String masterName, Set<String> sentinels) {
</span>32      this(masterName, sentinels, new GenericObjectPoolConfig<Jedis>(), Protocol.DEFAULT_TIMEOUT, null,
33          Protocol.DEFAULT_DATABASE);
34    }
35    public JedisSentinelPool(String masterName, Set<String> sentinels, String password) {
36      this(masterName, sentinels, new GenericObjectPoolConfig<Jedis>(), Protocol.DEFAULT_TIMEOUT, password);
37    }
38    public JedisSentinelPool(String masterName, Set<String> sentinels, String password, String sentinelPassword) {
39      this(masterName, sentinels, new GenericObjectPoolConfig<Jedis>(), Protocol.DEFAULT_TIMEOUT, Protocol.DEFAULT_TIMEOUT,
40          password, Protocol.DEFAULT_DATABASE, null, Protocol.DEFAULT_TIMEOUT, Protocol.DEFAULT_TIMEOUT, sentinelPassword, null);
41    }
42    public JedisSentinelPool(String masterName, Set<String> sentinels,
43        final GenericObjectPoolConfig<Jedis> poolConfig, int timeout, final String password) {
44      this(masterName, sentinels, poolConfig, timeout, password, Protocol.DEFAULT_DATABASE);
45    }
46    public JedisSentinelPool(String masterName, Set<String> sentinels,
47        final GenericObjectPoolConfig<Jedis> poolConfig, final int timeout) {
48      this(masterName, sentinels, poolConfig, timeout, null, Protocol.DEFAULT_DATABASE);
49    }
50    public JedisSentinelPool(String masterName, Set<String> sentinels,
51        final GenericObjectPoolConfig<Jedis> poolConfig, final String password) {
52      this(masterName, sentinels, poolConfig, Protocol.DEFAULT_TIMEOUT, password);
53    }
54    public JedisSentinelPool(String masterName, Set<String> sentinels,
55        final GenericObjectPoolConfig<Jedis> poolConfig, int timeout, final String password,
56        final int database) {
57      this(masterName, sentinels, poolConfig, timeout, timeout, null, password, database);
58    }
59    public JedisSentinelPool(String masterName, Set<String> sentinels,
60        final GenericObjectPoolConfig<Jedis> poolConfig, int timeout, final String user,
61        final String password, final int database) {
62      this(masterName, sentinels, poolConfig, timeout, timeout, user, password, database);
63    }
64    public JedisSentinelPool(String masterName, Set<String> sentinels,
65        final GenericObjectPoolConfig<Jedis> poolConfig, int timeout, final String password,
66        final int database, final String clientName) {
67      this(masterName, sentinels, poolConfig, timeout, timeout, password, database, clientName);
68    }
69    public JedisSentinelPool(String masterName, Set<String> sentinels,
70        final GenericObjectPoolConfig<Jedis> poolConfig, int timeout, final String user,
71        final String password, final int database, final String clientName) {
72      this(masterName, sentinels, poolConfig, timeout, timeout, user, password, database, clientName);
73    }
74    public JedisSentinelPool(String masterName, Set<String> sentinels,
75        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
76        final String password, final int database) {
77      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, null, password, database, null);
78    }
79    public JedisSentinelPool(String masterName, Set<String> sentinels,
80        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
81        final String user, final String password, final int database) {
82      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, user, password, database, null);
83    }
84    public JedisSentinelPool(String masterName, Set<String> sentinels,
85        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
86        final String password, final int database, final String clientName) {
87      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, null, password, database, clientName);
88    }
89    public JedisSentinelPool(String masterName, Set<String> sentinels,
90        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
91        final String user, final String password, final int database, final String clientName) {
92      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, user, password, database, clientName,
93          Protocol.DEFAULT_TIMEOUT, Protocol.DEFAULT_TIMEOUT, null, null, null);
94    }
95    public JedisSentinelPool(String masterName, Set<String> sentinels,
96        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout, final int infiniteSoTimeout,
97        final String user, final String password, final int database, final String clientName) {
98      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, infiniteSoTimeout, user, password, database, clientName,
99          Protocol.DEFAULT_TIMEOUT, Protocol.DEFAULT_TIMEOUT, null, null, null);
100    }
101    public JedisSentinelPool(String masterName, Set<String> sentinels,
102        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
103        final String password, final int database, final String clientName,
104        final int sentinelConnectionTimeout, final int sentinelSoTimeout, final String sentinelPassword,
105        final String sentinelClientName) {
106      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, null, password, database, clientName,
107          sentinelConnectionTimeout, sentinelSoTimeout, null, sentinelPassword, sentinelClientName);
108    }
109    public JedisSentinelPool(String masterName, Set<String> sentinels,
110        final GenericObjectPoolConfig<Jedis> poolConfig, final int connectionTimeout, final int soTimeout,
111        final String user, final String password, final int database, final String clientName,
112        final int sentinelConnectionTimeout, final int sentinelSoTimeout, final String sentinelUser,
113        final String sentinelPassword, final String sentinelClientName) {
114      this(masterName, sentinels, poolConfig, connectionTimeout, soTimeout, 0, user, password, database, clientName,
115          sentinelConnectionTimeout, sentinelSoTimeout, sentinelUser, sentinelPassword, sentinelClientName);
116    }
117    public JedisSentinelPool(String masterName, Set<String> sentinels,
118        final GenericObjectPoolConfig<Jedis> poolConfig,
119        final int connectionTimeout, final int soTimeout, final int infiniteSoTimeout,
120        final String user, final String password, final int database, final String clientName,
121        final int sentinelConnectionTimeout, final int sentinelSoTimeout, final String sentinelUser,
122        final String sentinelPassword, final String sentinelClientName) {
123      this(masterName, parseHostAndPorts(sentinels), poolConfig,
124          DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
125              .socketTimeoutMillis(soTimeout).blockingSocketTimeoutMillis(infiniteSoTimeout)
126              .user(user).password(password).database(database).clientName(clientName).build(),
127          DefaultJedisClientConfig.builder().connectionTimeoutMillis(sentinelConnectionTimeout)
128              .socketTimeoutMillis(sentinelSoTimeout).user(sentinelUser).password(sentinelPassword)
129              .clientName(sentinelClientName).build()
130      );
131    }
132    public JedisSentinelPool(String masterName, Set<String> sentinels,
133        final GenericObjectPoolConfig<Jedis> poolConfig, final JedisFactory factory) {
134      this(masterName, parseHostAndPorts(sentinels), poolConfig, factory,
135          DefaultJedisClientConfig.builder().build());
136    }
137    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,
138        final GenericObjectPoolConfig<Jedis> poolConfig, final JedisClientConfig masteClientConfig,
139        final JedisClientConfig sentinelClientConfig) {
140      this(masterName, sentinels, poolConfig, new JedisFactory(masteClientConfig), sentinelClientConfig);
141    }
142    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,
143        final JedisFactory factory, final JedisClientConfig sentinelClientConfig) {
144      super(factory);
145      this.factory = factory;
146      this.sentinelClientConfig = sentinelClientConfig;
147      HostAndPort master = initSentinels(sentinels, masterName);
148      initMaster(master);
149    }
150    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,
151        final GenericObjectPoolConfig<Jedis> poolConfig, final JedisFactory factory,
152        final JedisClientConfig sentinelClientConfig) {
153      super(poolConfig, factory);
154      this.factory = factory;
155      this.sentinelClientConfig = sentinelClientConfig;
156      HostAndPort master = initSentinels(sentinels, masterName);
157      initMaster(master);
158    }
159    private static Set<HostAndPort> parseHostAndPorts(Set<String> strings) {
160      return strings.stream().map(HostAndPort::from).collect(Collectors.toSet());
161    }
162    @Override
163    public void destroy() {
164      for (MasterListener m : masterListeners) {
165        m.shutdown();
166      }
167      super.destroy();
168    }
169    public HostAndPort getCurrentHostMaster() {
170      return currentHostMaster;
171    }
172    private void initMaster(HostAndPort master) {
173      synchronized (initPoolLock) {
174        if (!master.equals(currentHostMaster)) {
175          currentHostMaster = master;
176          factory.setHostAndPort(currentHostMaster);
177          super.clear();
178          LOG.info("Created JedisSentinelPool to master at {}", master);
179        }
180      }
181    }
182    private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {
183      HostAndPort master = null;
184      boolean sentinelAvailable = false;
185      LOG.info("Trying to find master from available Sentinels...");
186      for (HostAndPort sentinel : sentinels) {
187        LOG.debug("Connecting to Sentinel {}", sentinel);
188        try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {
189          List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);
190          sentinelAvailable = true;
191          if (masterAddr == null || masterAddr.size() != 2) {
192            LOG.warn("Can not get master addr, master name: {}. Sentinel: {}", masterName, sentinel);
193            continue;
194          }
195          master = toHostAndPort(masterAddr);
196          LOG.debug("Found Redis master at {}", master);
197          break;
198        } catch (JedisException e) {
199          LOG.warn(
200            "Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.", sentinel, e);
201        }
202      }
203      if (master == null) {
204        if (sentinelAvailable) {
205          throw new JedisException("Can connect to sentinel, but " + masterName
206              + " seems to be not monitored...");
207        } else {
208          throw new JedisConnectionException("All sentinels down, cannot determine where is "
209              + masterName + " master is running...");
210        }
211      }
212      LOG.info("Redis master running at {}, starting Sentinel listeners...", master);
213      for (HostAndPort sentinel : sentinels) {
214        MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());
215        masterListener.setDaemon(true);
216        masterListeners.add(masterListener);
217        masterListener.start();
218      }
219      return master;
220    }
221    private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {
222      String host = getMasterAddrByNameResult.get(0);
223      int port = Integer.parseInt(getMasterAddrByNameResult.get(1));
224      return new HostAndPort(host, port);
225    }
226    @Override
227    public Jedis getResource() {
228      while (true) {
229        Jedis jedis = super.getResource();
230        jedis.setDataSource(this);
231        final HostAndPort master = currentHostMaster;
232        final HostAndPort connection = jedis.getClient().getHostAndPort();
233        if (master.equals(connection)) {
234          return jedis;
235        } else {
236          returnBrokenResource(jedis);
237        }
238      }
239    }
240    @Override
241    public void returnResource(final Jedis resource) {
242      if (resource != null) {
243        try {
244          resource.resetState();
245          super.returnResource(resource);
246        } catch (RuntimeException e) {
247          returnBrokenResource(resource);
248          LOG.debug("Resource is returned to the pool as broken", e);
249        }
250      }
251    }
252    protected class MasterListener extends Thread {
253      protected String masterName;
254      protected String host;
255      protected int port;
256      protected long subscribeRetryWaitTimeMillis = 5000;
257      protected volatile Jedis j;
258      protected AtomicBoolean running = new AtomicBoolean(false);
259      protected MasterListener() {
260      }
261      public MasterListener(String masterName, String host, int port) {
262        super(String.format("MasterListener-%s-[%s:%d]", masterName, host, port));
263        this.masterName = masterName;
264        this.host = host;
265        this.port = port;
266      }
267      public MasterListener(String masterName, String host, int port,
268          long subscribeRetryWaitTimeMillis) {
269        this(masterName, host, port);
270        this.subscribeRetryWaitTimeMillis = subscribeRetryWaitTimeMillis;
271      }
272      @Override
273      public void run() {
274        running.set(true);
275        while (running.get()) {
276          try {
277            if (!running.get()) {
278              break;
279            }
280            final HostAndPort hostPort = new HostAndPort(host, port);
281            j = new Jedis(hostPort, sentinelClientConfig);
282            List<String> masterAddr = j.sentinelGetMasterAddrByName(masterName);
283            if (masterAddr == null || masterAddr.size() != 2) {
284              LOG.warn("Can not get master addr, master name: {}. Sentinel: {}.", masterName,
285                  hostPort);
286            } else {
287              initMaster(toHostAndPort(masterAddr));
288            }
289            j.subscribe(new JedisPubSub() {
290              @Override
291              public void onMessage(String channel, String message) {
292                LOG.debug("Sentinel {} published: {}.", hostPort, message);
293                String[] switchMasterMsg = message.split(" ");
294                if (switchMasterMsg.length > 3) {
295                  if (masterName.equals(switchMasterMsg[0])) {
296                    initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));
297                  } else {
298                    LOG.debug(
299                      "Ignoring message on +switch-master for master name {}, our master name is {}",
300                      switchMasterMsg[0], masterName);
301                  }
302                } else {
303                  LOG.error("Invalid message received on Sentinel {} on channel +switch-master: {}",
304                      hostPort, message);
305                }
306              }
307            }, "+switch-master");
308          } catch (JedisException e) {
309            if (running.get()) {
310              LOG.error("Lost connection to Sentinel at {}:{}. Sleeping 5000ms and retrying.", host,
311                port, e);
312              try {
313                Thread.sleep(subscribeRetryWaitTimeMillis);
314              } catch (InterruptedException e1) {
315                LOG.error("Sleep interrupted: ", e1);
316              }
317            } else {
318              LOG.debug("Unsubscribing from Sentinel at {}:{}", host, port);
319            }
320          } finally {
321            if (j != null) {
322              j.close();
323            }
324          }
325        }
326      }
327      public void shutdown() {
328        try {
329          LOG.debug("Shutting down listener on {}:{}", host, port);
330          running.set(false);
331          if (j != null) {
332            j.close();
333          }
334        } catch (RuntimeException e) {
335          LOG.error("Caught exception while shutting down: ", e);
336        }
337      }
338    }
339  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-JedisSentinelPool.java</div>
                <div class="column column_space"><pre><code>309          throw new UnsupportedOperationException( "Packet must implement read method" );
310      }
311      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
312      {
313          read( buf );
314      }
315      public void write(ByteBuf buf)
</pre></code></div>
                <div class="column column_space"><pre><code>24      this(masterName, sentinels, new JedisFactory(masteClientConfig), sentinelClientConfig);
25    }
26    public JedisSentinelPool(String masterName, Set<String> sentinels,
27        final GenericObjectPoolConfig<Jedis> poolConfig) {
28      this(masterName, sentinels, poolConfig, Protocol.DEFAULT_TIMEOUT, null,
29          Protocol.DEFAULT_DATABASE);
30    }
31    public JedisSentinelPool(String masterName, Set<String> sentinels) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    