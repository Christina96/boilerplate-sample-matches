
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 32, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-BaseLoadBalancer.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import static java.util.Collections.singleton;
3  import com.google.common.collect.ImmutableList;
4  import com.netflix.client.ClientFactory;
5  import com.netflix.client.IClientConfigAware;
6  import com.netflix.client.PrimeConnections;
7  import com.netflix.client.config.CommonClientConfigKey;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.servo.annotations.DataSourceType;
10  import com.netflix.servo.annotations.Monitor;
11  import com.netflix.servo.monitor.Counter;
12  import com.netflix.servo.monitor.Monitors;
13  import com.netflix.util.concurrent.ShutdownEnabledTimer;
14  import org.slf4j.Logger;
15  import org.slf4j.LoggerFactory;
16  import java.util.ArrayList;
17  import java.util.Collection;
18  import java.util.Collections;
19  import java.util.Comparator;
20  import java.util.List;
21  import java.util.Timer;
22  import java.util.TimerTask;
23  import java.util.concurrent.CopyOnWriteArrayList;
24  import java.util.concurrent.atomic.AtomicBoolean;
25  import java.util.concurrent.locks.Lock;
26  import java.util.concurrent.locks.ReadWriteLock;
27  import java.util.concurrent.locks.ReentrantReadWriteLock;
28  public class BaseLoadBalancer extends AbstractLoadBalancer implements
29          PrimeConnections.PrimeConnectionListener, IClientConfigAware {
30      private static Logger logger = LoggerFactory.getLogger(BaseLoadBalancer.class);
31      private final static IRule DEFAULT_RULE = new RoundRobinRule();
32      private final static SerialPingStrategy DEFAULT_PING_STRATEGY = new SerialPingStrategy();
33      private static final String DEFAULT_NAME = &quot;default&quot;;
34      private static final String PREFIX = &quot;LoadBalancer_&quot;;
35      protected IRule rule = DEFAULT_RULE;
36      protected IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY;
37      protected IPing ping = null;
38      @Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)
39      protected volatile List&lt;Server&gt; allServerList = Collections
40              .synchronizedList(new ArrayList&lt;Server&gt;());
41      @Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL)
42      protected volatile List&lt;Server&gt; upServerList = Collections
43              .synchronizedList(new ArrayList&lt;Server&gt;());
44      protected ReadWriteLock allServerLock = new ReentrantReadWriteLock();
45      protected ReadWriteLock upServerLock = new ReentrantReadWriteLock();
46      protected String name = DEFAULT_NAME;
47      protected Timer lbTimer = null;
48      protected int pingIntervalSeconds = 10;
49      protected int maxTotalPingTimeSeconds = 5;
50      protected Comparator&lt;Server&gt; serverComparator = new ServerComparator();
51      protected AtomicBoolean pingInProgress = new AtomicBoolean(false);
52      protected LoadBalancerStats lbStats;
53      private volatile Counter counter = Monitors.newCounter(&quot;LoadBalancer_ChooseServer&quot;);
54      private PrimeConnections primeConnections;
55      private volatile boolean enablePrimingConnections = false;
56      private IClientConfig config;
57      private List&lt;ServerListChangeListener&gt; changeListeners = new CopyOnWriteArrayList&lt;ServerListChangeListener&gt;();
58      private List&lt;ServerStatusChangeListener&gt; serverStatusListeners = new CopyOnWriteArrayList&lt;ServerStatusChangeListener&gt;();
59      public BaseLoadBalancer() {
60          this.name = DEFAULT_NAME;
61          this.ping = null;
62          setRule(DEFAULT_RULE);
63          setupPingTask();
64          lbStats = new LoadBalancerStats(DEFAULT_NAME);
65      }
66      public BaseLoadBalancer(String lbName, IRule rule, LoadBalancerStats lbStats) {
67          this(lbName, rule, lbStats, null);
68      }
69      public BaseLoadBalancer(IPing ping, IRule rule) {
70          this(DEFAULT_NAME, rule, new LoadBalancerStats(DEFAULT_NAME), ping);
71      }
72      public BaseLoadBalancer(IPing ping, IRule rule, IPingStrategy pingStrategy) {
73          this(DEFAULT_NAME, rule, new LoadBalancerStats(DEFAULT_NAME), ping, pingStrategy);
74      }
75      public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,
76              IPing ping) {
77          this(name, rule, stats, ping, DEFAULT_PING_STRATEGY);
78      }
79      public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,
80              IPing ping, IPingStrategy pingStrategy) {
81          logger.debug(&quot;LoadBalancer [{}]:  initialized&quot;, name);
82          this.name = name;
83          this.ping = ping;
84          this.pingStrategy = pingStrategy;
85          setRule(rule);
86          setupPingTask();
87          lbStats = stats;
88          init();
89      }
90      public BaseLoadBalancer(IClientConfig config) {
91          initWithNiwsConfig(config);
92      }
93      public BaseLoadBalancer(IClientConfig config, IRule rule, IPing ping) {
94          initWithConfig(config, rule, ping, createLoadBalancerStatsFromConfig(config, ClientFactory::instantiateInstanceWithClientConfig));
95      }
96      void initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping) {
97          initWithConfig(clientConfig, rule, ping, createLoadBalancerStatsFromConfig(config, ClientFactory::instantiateInstanceWithClientConfig));
98      }
99      void initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping, LoadBalancerStats stats) {
100          this.config = clientConfig;
101          this.name = clientConfig.getClientName();
102          int pingIntervalTime = clientConfig.get(CommonClientConfigKey.NFLoadBalancerPingInterval, 30);
103          int maxTotalPingTime = clientConfig.get(CommonClientConfigKey.NFLoadBalancerMaxTotalPingTime, 2);
104          setPingInterval(pingIntervalTime);
105          setMaxTotalPingTime(maxTotalPingTime);
106          setRule(rule);
107          setPing(ping);
108          setLoadBalancerStats(stats);
109          rule.setLoadBalancer(this);
110          if (ping instanceof AbstractLoadBalancerPing) {
111              ((AbstractLoadBalancerPing) ping).setLoadBalancer(this);
112          }
113          logger.info(&quot;Client: {} instantiated a LoadBalancer: {}&quot;, name, this);
114          boolean enablePrimeConnections = clientConfig.getOrDefault(CommonClientConfigKey.EnablePrimeConnections);
115          if (enablePrimeConnections) {
116              this.setEnablePrimingConnections(true);
117              PrimeConnections primeConnections = new PrimeConnections(
118                      this.getName(), clientConfig);
119              this.setPrimeConnections(primeConnections);
120          }
121          init();
122      }
123      @Override
124      public void initWithNiwsConfig(IClientConfig clientConfig) {
125          try {
126              initWithNiwsConfig(clientConfig, ClientFactory::instantiateInstanceWithClientConfig);
127          } catch (Exception e) {
128              throw new RuntimeException(&quot;Error initializing load balancer&quot;, e);
129          }
130      }
131      @Override
132      public void initWithNiwsConfig(IClientConfig clientConfig, Factory factory) {
133          String ruleClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerRuleClassName);
134          String pingClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerPingClassName);
135          try {
136              IRule rule = (IRule)factory.create(ruleClassName, clientConfig);
137              IPing ping = (IPing)factory.create(pingClassName, clientConfig);
138              LoadBalancerStats stats = createLoadBalancerStatsFromConfig(clientConfig, factory);
139              initWithConfig(clientConfig, rule, ping, stats);
140          } catch (Exception e) {
141              throw new RuntimeException(&quot;Error initializing load balancer&quot;, e);
142          }
143      }
144      private LoadBalancerStats createLoadBalancerStatsFromConfig(IClientConfig clientConfig, Factory factory) {
145          String loadBalancerStatsClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerStatsClassName);
146          try {
147              return (LoadBalancerStats) factory.create(loadBalancerStatsClassName, clientConfig);
148          } catch (Exception e) {
149              throw new RuntimeException(
150                      &quot;Error initializing configured LoadBalancerStats class - &quot; + loadBalancerStatsClassName,
151                      e);
152          }
153      }
154      public void addServerListChangeListener(ServerListChangeListener listener) {
155          changeListeners.add(listener);
156      }
157      public void removeServerListChangeListener(ServerListChangeListener listener) {
158          changeListeners.remove(listener);
159      }
160      public void addServerStatusChangeListener(ServerStatusChangeListener listener) {
161          serverStatusListeners.add(listener);
162      }
163      public void removeServerStatusChangeListener(ServerStatusChangeListener listener) {
164          serverStatusListeners.remove(listener);
165      }
166      public IClientConfig getClientConfig() {
167      	return config;
168      }
169      private boolean canSkipPing() {
170          if (ping == null
171                  || ping.getClass().getName().equals(DummyPing.class.getName())) {
172              return true;
173          } else {
174              return false;
175          }
176      }
177      void setupPingTask() {
178          if (canSkipPing()) {
179              return;
180          }
181          if (lbTimer != null) {
182              lbTimer.cancel();
183          }
184          lbTimer = new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,
185                  true);
186          lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);
187          forceQuickPing();
188      }
189      void setName(String name) {
190          this.name = name;
191          if (lbStats == null) {
192              lbStats = new LoadBalancerStats(name);
193          } else {
194              lbStats.setName(name);
195          }
196      }
197      public String getName() {
198          return name;
199      }
200      @Override
201      public LoadBalancerStats getLoadBalancerStats() {
202          return lbStats;
203      }
204      public void setLoadBalancerStats(LoadBalancerStats lbStats) {
205          this.lbStats = lbStats;
206      }
207      public Lock lockAllServerList(boolean write) {
208          Lock aproposLock = write ? allServerLock.writeLock() : allServerLock
209                  .readLock();
210          aproposLock.lock();
211          return aproposLock;
212      }
213      public Lock lockUpServerList(boolean write) {
214          Lock aproposLock = write ? upServerLock.writeLock() : upServerLock
215                  .readLock();
216          aproposLock.lock();
217          return aproposLock;
218      }
219      public void setPingInterval(int pingIntervalSeconds) {
220          if (pingIntervalSeconds &lt; 1) {
221              return;
222          }
223          this.pingIntervalSeconds = pingIntervalSeconds;
224          if (logger.isDebugEnabled()) {
225              logger.debug(&quot;LoadBalancer [{}]:  pingIntervalSeconds set to {}&quot;,
226          	    name, this.pingIntervalSeconds);
227          }
228          setupPingTask(); 
229      }
230      public int getPingInterval() {
231          return pingIntervalSeconds;
232      }
233      public void setMaxTotalPingTime(int maxTotalPingTimeSeconds) {
234          if (maxTotalPingTimeSeconds &lt; 1) {
235              return;
236          }
237          this.maxTotalPingTimeSeconds = maxTotalPingTimeSeconds;
238          logger.debug(&quot;LoadBalancer [{}]: maxTotalPingTime set to {}&quot;, name, this.maxTotalPingTimeSeconds);
239      }
240      public int getMaxTotalPingTime() {
241          return maxTotalPingTimeSeconds;
242      }
243      public IPing getPing() {
244          return ping;
245      }
246      public IRule getRule() {
247          return rule;
248      }
249      public boolean isPingInProgress() {
250          return pingInProgress.get();
251      }
252      public void setPing(IPing ping) {
253          if (ping != null) {
254              if (!ping.equals(this.ping)) {
255                  this.ping = ping;
256                  setupPingTask(); 
257              }
258          } else {
259              this.ping = null;
260              lbTimer.cancel();
261          }
262      }
263      public void setRule(IRule rule) {
264          if (rule != null) {
265              this.rule = rule;
266          } else {
267              this.rule = new RoundRobinRule();
268          }
269          if (this.rule.getLoadBalancer() != this) {
270              this.rule.setLoadBalancer(this);
271          }
272      }
273      public int getServerCount(boolean onlyAvailable) {
274          if (onlyAvailable) {
275              return upServerList.size();
276          } else {
277              return allServerList.size();
278          }
279      }
280      public void addServer(Server newServer) {
281          if (newServer != null) {
282              try {
283                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
284                  newList.addAll(allServerList);
285                  newList.add(newServer);
286                  setServersList(newList);
287              } catch (Exception e) {
288                  logger.error(&quot;LoadBalancer [{}]: Error adding newServer {}&quot;, name, newServer.getHost(), e);
289              }
290          }
291      }
292      @Override
293      public void addServers(List&lt;Server&gt; newServers) {
294          if (newServers != null &amp;&amp; newServers.size() &gt; 0) {
295              try {
296                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
297                  newList.addAll(allServerList);
298                  newList.addAll(newServers);
299                  setServersList(newList);
300              } catch (Exception e) {
301                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
302              }
303          }
304      }
305      void addServers(Object[] newServers) {
306          if ((newServers != null) &amp;&amp; (newServers.length &gt; 0)) {
307              try {
308                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
309                  newList.addAll(allServerList);
310                  for (Object server : newServers) {
311                      if (server != null) {
312                          if (server instanceof String) {
313                              server = new Server((String) server);
314                          }
315                          if (server instanceof Server) {
316                              newList.add((Server) server);
317                          }
318                      }
319                  }
320                  setServersList(newList);
321              } catch (Exception e) {
322                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
323              }
324          }
325      }
326      public void setServersList(List lsrv) {
327          Lock writeLock = allServerLock.writeLock();
328          logger.debug(&quot;LoadBalancer [{}]: clearing server list (SET op)&quot;, name);
329          ArrayList&lt;Server&gt; newServers = new ArrayList&lt;Server&gt;();
330          writeLock.lock();
331          try {
332              ArrayList&lt;Server&gt; allServers = new ArrayList&lt;Server&gt;();
333              for (Object server : lsrv) {
334                  if (server == null) {
335                      continue;
336                  }
337                  if (server instanceof String) {
338                      server = new Server((String) server);
339                  }
340                  if (server instanceof Server) {
341                      logger.debug(&quot;LoadBalancer [{}]:  addServer [{}]&quot;, name, ((Server) server).getId());
342                      allServers.add((Server) server);
343                  } else {
344                      throw new IllegalArgumentException(
345                              &quot;Type String or Server expected, instead found:&quot;
346                                      + server.getClass());
347                  }
348              }
349              boolean listChanged = false;
350              if (!allServerList.equals(allServers)) {
351                  listChanged = true;
352                  if (changeListeners != null &amp;&amp; changeListeners.size() &gt; 0) {
353                     List&lt;Server&gt; oldList = ImmutableList.copyOf(allServerList);
354                     List&lt;Server&gt; newList = ImmutableList.copyOf(allServers);                   
355                     for (ServerListChangeListener l: changeListeners) {
356                         try {
357                             l.serverListChanged(oldList, newList);
358                         } catch (Exception e) {
359                             logger.error(&quot;LoadBalancer [{}]: Error invoking server list change listener&quot;, name, e);
360                         }
361                     }
362                  }
363              }
364              if (isEnablePrimingConnections()) {
365                  for (Server server : allServers) {
366                      if (!allServerList.contains(server)) {
367                          server.setReadyToServe(false);
368                          newServers.add((Server) server);
369                      }
370                  }
371                  if (primeConnections != null) {
372                      primeConnections.primeConnectionsAsync(newServers, this);
373                  }
374              }
375              allServerList = allServers;
376              if (canSkipPing()) {
377                  for (Server s : allServerList) {
378                      s.setAlive(true);
379                  }
380                  upServerList = allServerList;
381              } else if (listChanged) {
382                  forceQuickPing();
383              }
384          } finally {
385              writeLock.unlock();
386          }
387      }
388      void setServers(String srvString) {
389          if (srvString != null) {
390              try {
391                  String[] serverArr = srvString.split(&quot;,&quot;);
392                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
393                  for (String serverString : serverArr) {
394                      if (serverString != null) {
395                          serverString = serverString.trim();
396                          if (serverString.length() &gt; 0) {
397                              Server svr = new Server(serverString);
398                              newList.add(svr);
399                          }
400                      }
401                  }
402                  setServersList(newList);
403              } catch (Exception e) {
404                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
405              }
406          }
407      }
408      public Server getServerByIndex(int index, boolean availableOnly) {
409          try {
410              return (availableOnly ? upServerList.get(index) : allServerList
411                      .get(index));
412          } catch (Exception e) {
413              return null;
414          }
415      }
416      @Override
417      public List&lt;Server&gt; getServerList(boolean availableOnly) {
418          return (availableOnly ? getReachableServers() : getAllServers());
419      }
420      @Override
421      public List&lt;Server&gt; getReachableServers() {
422          return Collections.unmodifiableList(upServerList);
423      }
424      @Override
425      public List&lt;Server&gt; getAllServers() {
426          return Collections.unmodifiableList(allServerList);
427      }
428      @Override
429      public List&lt;Server&gt; getServerList(ServerGroup serverGroup) {
430          switch (serverGroup) {
431          case ALL:
432              return allServerList;
433          case STATUS_UP:
434              return upServerList;
435          case STATUS_NOT_UP:
436              ArrayList&lt;Server&gt; notAvailableServers = new ArrayList&lt;Server&gt;(
437                      allServerList);
438              ArrayList&lt;Server&gt; upServers = new ArrayList&lt;Server&gt;(upServerList);
439              notAvailableServers.removeAll(upServers);
440              return notAvailableServers;
441          }
442          return new ArrayList&lt;Server&gt;();
443      }
444      public void cancelPingTask() {
445          if (lbTimer != null) {
446              lbTimer.cancel();
447          }
448      }
449      class PingTask extends TimerTask {
450          public void run() {
<span onclick='openModal()' class='match'>451              try {
452              	new Pinger(pingStrategy).runPinger();
453              } catch (Exception e) {
454                  logger.error(&quot;LoadBalancer [{}]: Error pinging&quot;, name, e);
455              }
456          }
457      }
</span>458      class Pinger {
459          private final IPingStrategy pingerStrategy;
460          public Pinger(IPingStrategy pingerStrategy) {
461              this.pingerStrategy = pingerStrategy;
462          }
463          public void runPinger() throws Exception {
464              if (!pingInProgress.compareAndSet(false, true)) { 
465                  return; 
466              }
467              Server[] allServers = null;
468              boolean[] results = null;
469              Lock allLock = null;
470              Lock upLock = null;
471              try {
472                  allLock = allServerLock.readLock();
473                  allLock.lock();
474                  allServers = allServerList.toArray(new Server[allServerList.size()]);
475                  allLock.unlock();
476                  int numCandidates = allServers.length;
477                  results = pingerStrategy.pingServers(ping, allServers);
478                  final List&lt;Server&gt; newUpList = new ArrayList&lt;Server&gt;();
479                  final List&lt;Server&gt; changedServers = new ArrayList&lt;Server&gt;();
480                  for (int i = 0; i &lt; numCandidates; i++) {
481                      boolean isAlive = results[i];
482                      Server svr = allServers[i];
483                      boolean oldIsAlive = svr.isAlive();
484                      svr.setAlive(isAlive);
485                      if (oldIsAlive != isAlive) {
486                          changedServers.add(svr);
487                          logger.debug(&quot;LoadBalancer [{}]:  Server [{}] status changed to {}&quot;, 
488                      		name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;));
489                      }
490                      if (isAlive) {
491                          newUpList.add(svr);
492                      }
493                  }
494                  upLock = upServerLock.writeLock();
495                  upLock.lock();
496                  upServerList = newUpList;
497                  upLock.unlock();
498                  notifyServerStatusChangeListener(changedServers);
499              } finally {
500                  pingInProgress.set(false);
501              }
502          }
503      }
504      private void notifyServerStatusChangeListener(final Collection&lt;Server&gt; changedServers) {
505          if (changedServers != null &amp;&amp; !changedServers.isEmpty() &amp;&amp; !serverStatusListeners.isEmpty()) {
506              for (ServerStatusChangeListener listener : serverStatusListeners) {
507                  try {
508                      listener.serverStatusChanged(changedServers);
509                  } catch (Exception e) {
510                      logger.error(&quot;LoadBalancer [{}]: Error invoking server status change listener&quot;, name, e);
511                  }
512              }
513          }
514      }
515      private final Counter createCounter() {
516          return Monitors.newCounter(&quot;LoadBalancer_ChooseServer&quot;);
517      }
518      public Server chooseServer(Object key) {
519          if (counter == null) {
520              counter = createCounter();
521          }
522          counter.increment();
523          if (rule == null) {
524              return null;
525          } else {
526              try {
527                  return rule.choose(key);
528              } catch (Exception e) {
529                  logger.warn(&quot;LoadBalancer [{}]:  Error choosing server for key {}&quot;, name, key, e);
530                  return null;
531              }
532          }
533      }
534      public String choose(Object key) {
535          if (rule == null) {
536              return null;
537          } else {
538              try {
539                  Server svr = rule.choose(key);
540                  return ((svr == null) ? null : svr.getId());
541              } catch (Exception e) {
542                  logger.warn(&quot;LoadBalancer [{}]:  Error choosing server&quot;, name, e);
543                  return null;
544              }
545          }
546      }
547      public void markServerDown(Server server) {
548          if (server == null || !server.isAlive()) {
549              return;
550          }
551          logger.error(&quot;LoadBalancer [{}]:  markServerDown called on [{}]&quot;, name, server.getId());
552          server.setAlive(false);
553          notifyServerStatusChangeListener(singleton(server));
554      }
555      public void markServerDown(String id) {
556          boolean triggered = false;
557          id = Server.normalizeId(id);
558          if (id == null) {
559              return;
560          }
561          Lock writeLock = upServerLock.writeLock();
562      	writeLock.lock();
563          try {
564              final List&lt;Server&gt; changedServers = new ArrayList&lt;Server&gt;();
565              for (Server svr : upServerList) {
566                  if (svr.isAlive() &amp;&amp; (svr.getId().equals(id))) {
567                      triggered = true;
568                      svr.setAlive(false);
569                      changedServers.add(svr);
570                  }
571              }
572              if (triggered) {
573                  logger.error(&quot;LoadBalancer [{}]:  markServerDown called for server [{}]&quot;, name, id);
574                  notifyServerStatusChangeListener(changedServers);
575              }
576          } finally {
577              writeLock.unlock();
578          }
579      }
580      public void forceQuickPing() {
581          if (canSkipPing()) {
582              return;
583          }
584          logger.debug(&quot;LoadBalancer [{}]:  forceQuickPing invoking&quot;, name);
585          try {
586          	new Pinger(pingStrategy).runPinger();
587          } catch (Exception e) {
588              logger.error(&quot;LoadBalancer [{}]: Error running forceQuickPing()&quot;, name, e);
589          }
590      }
591      public String toString() {
592          StringBuilder sb = new StringBuilder();
593          sb.append(&quot;{NFLoadBalancer:name=&quot;).append(this.getName())
594                  .append(&quot;,current list of Servers=&quot;).append(this.allServerList)
595                  .append(&quot;,Load balancer stats=&quot;)
596                  .append(this.lbStats.toString()).append(&quot;}&quot;);
597          return sb.toString();
598      }
599      protected void init() {
600          Monitors.registerObject(&quot;LoadBalancer_&quot; + name, this);
601          Monitors.registerObject(&quot;Rule_&quot; + name, this.getRule());
602          if (enablePrimingConnections &amp;&amp; primeConnections != null) {
603              primeConnections.primeConnections(getReachableServers());
604          }
605      }
606      public final PrimeConnections getPrimeConnections() {
607          return primeConnections;
608      }
609      public final void setPrimeConnections(PrimeConnections primeConnections) {
610          this.primeConnections = primeConnections;
611      }
612      @Override
613      public void primeCompleted(Server s, Throwable lastException) {
614          s.setReadyToServe(true);
615      }
616      public boolean isEnablePrimingConnections() {
617          return enablePrimingConnections;
618      }
619      public final void setEnablePrimingConnections(
620              boolean enablePrimingConnections) {
621          this.enablePrimingConnections = enablePrimingConnections;
622      }
623      public void shutdown() {
624          cancelPingTask();
625          if (primeConnections != null) {
626              primeConnections.shutdown();
627          }
628          Monitors.unregisterObject(&quot;LoadBalancer_&quot; + name, this);
629          Monitors.unregisterObject(&quot;Rule_&quot; + name, this.getRule());
630      }
631      private static class SerialPingStrategy implements IPingStrategy {
632          @Override
633          public boolean[] pingServers(IPing ping, Server[] servers) {
634              int numCandidates = servers.length;
635              boolean[] results = new boolean[numCandidates];
636              logger.debug(&quot;LoadBalancer:  PingTask executing [{}] servers configured&quot;, numCandidates);
637              for (int i = 0; i &lt; numCandidates; i++) {
638                  results[i] = false; &amp;bsol;* Default answer is DEAD. */
639                  try {
640                      if (ping != null) {
641                          results[i] = ping.isAlive(servers[i]);
642                      }
643                  } catch (Exception e) {
644                      logger.error(&quot;Exception while pinging Server: &#x27;{}&#x27;&quot;, servers[i], e);
645                  }
646              }
647              return results;
648          }
649      }
650  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-BaseLoadBalancer.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import static java.util.Collections.singleton;
3  import com.google.common.collect.ImmutableList;
4  import com.netflix.client.ClientFactory;
5  import com.netflix.client.IClientConfigAware;
6  import com.netflix.client.PrimeConnections;
7  import com.netflix.client.config.CommonClientConfigKey;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.servo.annotations.DataSourceType;
10  import com.netflix.servo.annotations.Monitor;
11  import com.netflix.servo.monitor.Counter;
12  import com.netflix.servo.monitor.Monitors;
13  import com.netflix.util.concurrent.ShutdownEnabledTimer;
14  import org.slf4j.Logger;
15  import org.slf4j.LoggerFactory;
16  import java.util.ArrayList;
17  import java.util.Collection;
18  import java.util.Collections;
19  import java.util.Comparator;
20  import java.util.List;
21  import java.util.Timer;
22  import java.util.TimerTask;
23  import java.util.concurrent.CopyOnWriteArrayList;
24  import java.util.concurrent.atomic.AtomicBoolean;
25  import java.util.concurrent.locks.Lock;
26  import java.util.concurrent.locks.ReadWriteLock;
27  import java.util.concurrent.locks.ReentrantReadWriteLock;
28  public class BaseLoadBalancer extends AbstractLoadBalancer implements
29          PrimeConnections.PrimeConnectionListener, IClientConfigAware {
30      private static Logger logger = LoggerFactory.getLogger(BaseLoadBalancer.class);
31      private final static IRule DEFAULT_RULE = new RoundRobinRule();
32      private final static SerialPingStrategy DEFAULT_PING_STRATEGY = new SerialPingStrategy();
33      private static final String DEFAULT_NAME = &quot;default&quot;;
34      private static final String PREFIX = &quot;LoadBalancer_&quot;;
35      protected IRule rule = DEFAULT_RULE;
36      protected IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY;
37      protected IPing ping = null;
38      @Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)
39      protected volatile List&lt;Server&gt; allServerList = Collections
40              .synchronizedList(new ArrayList&lt;Server&gt;());
41      @Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL)
42      protected volatile List&lt;Server&gt; upServerList = Collections
43              .synchronizedList(new ArrayList&lt;Server&gt;());
44      protected ReadWriteLock allServerLock = new ReentrantReadWriteLock();
45      protected ReadWriteLock upServerLock = new ReentrantReadWriteLock();
46      protected String name = DEFAULT_NAME;
47      protected Timer lbTimer = null;
48      protected int pingIntervalSeconds = 10;
49      protected int maxTotalPingTimeSeconds = 5;
50      protected Comparator&lt;Server&gt; serverComparator = new ServerComparator();
51      protected AtomicBoolean pingInProgress = new AtomicBoolean(false);
52      protected LoadBalancerStats lbStats;
53      private volatile Counter counter = Monitors.newCounter(&quot;LoadBalancer_ChooseServer&quot;);
54      private PrimeConnections primeConnections;
55      private volatile boolean enablePrimingConnections = false;
56      private IClientConfig config;
57      private List&lt;ServerListChangeListener&gt; changeListeners = new CopyOnWriteArrayList&lt;ServerListChangeListener&gt;();
58      private List&lt;ServerStatusChangeListener&gt; serverStatusListeners = new CopyOnWriteArrayList&lt;ServerStatusChangeListener&gt;();
59      public BaseLoadBalancer() {
60          this.name = DEFAULT_NAME;
61          this.ping = null;
62          setRule(DEFAULT_RULE);
63          setupPingTask();
64          lbStats = new LoadBalancerStats(DEFAULT_NAME);
65      }
66      public BaseLoadBalancer(String lbName, IRule rule, LoadBalancerStats lbStats) {
67          this(lbName, rule, lbStats, null);
68      }
69      public BaseLoadBalancer(IPing ping, IRule rule) {
70          this(DEFAULT_NAME, rule, new LoadBalancerStats(DEFAULT_NAME), ping);
71      }
72      public BaseLoadBalancer(IPing ping, IRule rule, IPingStrategy pingStrategy) {
73          this(DEFAULT_NAME, rule, new LoadBalancerStats(DEFAULT_NAME), ping, pingStrategy);
74      }
75      public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,
76              IPing ping) {
77          this(name, rule, stats, ping, DEFAULT_PING_STRATEGY);
78      }
79      public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,
80              IPing ping, IPingStrategy pingStrategy) {
81          logger.debug(&quot;LoadBalancer [{}]:  initialized&quot;, name);
82          this.name = name;
83          this.ping = ping;
84          this.pingStrategy = pingStrategy;
85          setRule(rule);
86          setupPingTask();
87          lbStats = stats;
88          init();
89      }
90      public BaseLoadBalancer(IClientConfig config) {
91          initWithNiwsConfig(config);
92      }
93      public BaseLoadBalancer(IClientConfig config, IRule rule, IPing ping) {
94          initWithConfig(config, rule, ping, createLoadBalancerStatsFromConfig(config, ClientFactory::instantiateInstanceWithClientConfig));
95      }
96      void initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping) {
97          initWithConfig(clientConfig, rule, ping, createLoadBalancerStatsFromConfig(config, ClientFactory::instantiateInstanceWithClientConfig));
98      }
99      void initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping, LoadBalancerStats stats) {
100          this.config = clientConfig;
101          this.name = clientConfig.getClientName();
102          int pingIntervalTime = clientConfig.get(CommonClientConfigKey.NFLoadBalancerPingInterval, 30);
103          int maxTotalPingTime = clientConfig.get(CommonClientConfigKey.NFLoadBalancerMaxTotalPingTime, 2);
104          setPingInterval(pingIntervalTime);
105          setMaxTotalPingTime(maxTotalPingTime);
106          setRule(rule);
107          setPing(ping);
108          setLoadBalancerStats(stats);
109          rule.setLoadBalancer(this);
110          if (ping instanceof AbstractLoadBalancerPing) {
111              ((AbstractLoadBalancerPing) ping).setLoadBalancer(this);
112          }
113          logger.info(&quot;Client: {} instantiated a LoadBalancer: {}&quot;, name, this);
114          boolean enablePrimeConnections = clientConfig.getOrDefault(CommonClientConfigKey.EnablePrimeConnections);
115          if (enablePrimeConnections) {
116              this.setEnablePrimingConnections(true);
117              PrimeConnections primeConnections = new PrimeConnections(
118                      this.getName(), clientConfig);
119              this.setPrimeConnections(primeConnections);
120          }
121          init();
122      }
123      @Override
124      public void initWithNiwsConfig(IClientConfig clientConfig) {
125          try {
126              initWithNiwsConfig(clientConfig, ClientFactory::instantiateInstanceWithClientConfig);
127          } catch (Exception e) {
128              throw new RuntimeException(&quot;Error initializing load balancer&quot;, e);
129          }
130      }
131      @Override
132      public void initWithNiwsConfig(IClientConfig clientConfig, Factory factory) {
133          String ruleClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerRuleClassName);
134          String pingClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerPingClassName);
135          try {
136              IRule rule = (IRule)factory.create(ruleClassName, clientConfig);
137              IPing ping = (IPing)factory.create(pingClassName, clientConfig);
138              LoadBalancerStats stats = createLoadBalancerStatsFromConfig(clientConfig, factory);
139              initWithConfig(clientConfig, rule, ping, stats);
140          } catch (Exception e) {
141              throw new RuntimeException(&quot;Error initializing load balancer&quot;, e);
142          }
143      }
144      private LoadBalancerStats createLoadBalancerStatsFromConfig(IClientConfig clientConfig, Factory factory) {
145          String loadBalancerStatsClassName = clientConfig.getOrDefault(CommonClientConfigKey.NFLoadBalancerStatsClassName);
146          try {
147              return (LoadBalancerStats) factory.create(loadBalancerStatsClassName, clientConfig);
148          } catch (Exception e) {
149              throw new RuntimeException(
150                      &quot;Error initializing configured LoadBalancerStats class - &quot; + loadBalancerStatsClassName,
151                      e);
152          }
153      }
154      public void addServerListChangeListener(ServerListChangeListener listener) {
155          changeListeners.add(listener);
156      }
157      public void removeServerListChangeListener(ServerListChangeListener listener) {
158          changeListeners.remove(listener);
159      }
160      public void addServerStatusChangeListener(ServerStatusChangeListener listener) {
161          serverStatusListeners.add(listener);
162      }
163      public void removeServerStatusChangeListener(ServerStatusChangeListener listener) {
164          serverStatusListeners.remove(listener);
165      }
166      public IClientConfig getClientConfig() {
167      	return config;
168      }
169      private boolean canSkipPing() {
170          if (ping == null
171                  || ping.getClass().getName().equals(DummyPing.class.getName())) {
172              return true;
173          } else {
174              return false;
175          }
176      }
177      void setupPingTask() {
178          if (canSkipPing()) {
179              return;
180          }
181          if (lbTimer != null) {
182              lbTimer.cancel();
183          }
184          lbTimer = new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,
185                  true);
186          lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);
187          forceQuickPing();
188      }
189      void setName(String name) {
190          this.name = name;
191          if (lbStats == null) {
192              lbStats = new LoadBalancerStats(name);
193          } else {
194              lbStats.setName(name);
195          }
196      }
197      public String getName() {
198          return name;
199      }
200      @Override
201      public LoadBalancerStats getLoadBalancerStats() {
202          return lbStats;
203      }
204      public void setLoadBalancerStats(LoadBalancerStats lbStats) {
205          this.lbStats = lbStats;
206      }
207      public Lock lockAllServerList(boolean write) {
208          Lock aproposLock = write ? allServerLock.writeLock() : allServerLock
209                  .readLock();
210          aproposLock.lock();
211          return aproposLock;
212      }
213      public Lock lockUpServerList(boolean write) {
214          Lock aproposLock = write ? upServerLock.writeLock() : upServerLock
215                  .readLock();
216          aproposLock.lock();
217          return aproposLock;
218      }
219      public void setPingInterval(int pingIntervalSeconds) {
220          if (pingIntervalSeconds &lt; 1) {
221              return;
222          }
223          this.pingIntervalSeconds = pingIntervalSeconds;
224          if (logger.isDebugEnabled()) {
225              logger.debug(&quot;LoadBalancer [{}]:  pingIntervalSeconds set to {}&quot;,
226          	    name, this.pingIntervalSeconds);
227          }
228          setupPingTask(); 
229      }
230      public int getPingInterval() {
231          return pingIntervalSeconds;
232      }
233      public void setMaxTotalPingTime(int maxTotalPingTimeSeconds) {
234          if (maxTotalPingTimeSeconds &lt; 1) {
235              return;
236          }
237          this.maxTotalPingTimeSeconds = maxTotalPingTimeSeconds;
238          logger.debug(&quot;LoadBalancer [{}]: maxTotalPingTime set to {}&quot;, name, this.maxTotalPingTimeSeconds);
239      }
240      public int getMaxTotalPingTime() {
241          return maxTotalPingTimeSeconds;
242      }
243      public IPing getPing() {
244          return ping;
245      }
246      public IRule getRule() {
247          return rule;
248      }
249      public boolean isPingInProgress() {
250          return pingInProgress.get();
251      }
252      public void setPing(IPing ping) {
253          if (ping != null) {
254              if (!ping.equals(this.ping)) {
255                  this.ping = ping;
256                  setupPingTask(); 
257              }
258          } else {
259              this.ping = null;
260              lbTimer.cancel();
261          }
262      }
263      public void setRule(IRule rule) {
264          if (rule != null) {
265              this.rule = rule;
266          } else {
267              this.rule = new RoundRobinRule();
268          }
269          if (this.rule.getLoadBalancer() != this) {
270              this.rule.setLoadBalancer(this);
271          }
272      }
273      public int getServerCount(boolean onlyAvailable) {
274          if (onlyAvailable) {
275              return upServerList.size();
276          } else {
277              return allServerList.size();
278          }
279      }
280      public void addServer(Server newServer) {
281          if (newServer != null) {
282              try {
283                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
284                  newList.addAll(allServerList);
285                  newList.add(newServer);
286                  setServersList(newList);
287              } catch (Exception e) {
288                  logger.error(&quot;LoadBalancer [{}]: Error adding newServer {}&quot;, name, newServer.getHost(), e);
289              }
290          }
291      }
292      @Override
293      public void addServers(List&lt;Server&gt; newServers) {
294          if (newServers != null &amp;&amp; newServers.size() &gt; 0) {
295              try {
296                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
297                  newList.addAll(allServerList);
298                  newList.addAll(newServers);
299                  setServersList(newList);
300              } catch (Exception e) {
301                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
302              }
303          }
304      }
305      void addServers(Object[] newServers) {
306          if ((newServers != null) &amp;&amp; (newServers.length &gt; 0)) {
307              try {
308                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
309                  newList.addAll(allServerList);
310                  for (Object server : newServers) {
311                      if (server != null) {
312                          if (server instanceof String) {
313                              server = new Server((String) server);
314                          }
315                          if (server instanceof Server) {
316                              newList.add((Server) server);
317                          }
318                      }
319                  }
320                  setServersList(newList);
321              } catch (Exception e) {
322                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
323              }
324          }
325      }
326      public void setServersList(List lsrv) {
327          Lock writeLock = allServerLock.writeLock();
328          logger.debug(&quot;LoadBalancer [{}]: clearing server list (SET op)&quot;, name);
329          ArrayList&lt;Server&gt; newServers = new ArrayList&lt;Server&gt;();
330          writeLock.lock();
331          try {
332              ArrayList&lt;Server&gt; allServers = new ArrayList&lt;Server&gt;();
333              for (Object server : lsrv) {
334                  if (server == null) {
335                      continue;
336                  }
337                  if (server instanceof String) {
338                      server = new Server((String) server);
339                  }
340                  if (server instanceof Server) {
341                      logger.debug(&quot;LoadBalancer [{}]:  addServer [{}]&quot;, name, ((Server) server).getId());
342                      allServers.add((Server) server);
343                  } else {
344                      throw new IllegalArgumentException(
345                              &quot;Type String or Server expected, instead found:&quot;
346                                      + server.getClass());
347                  }
348              }
349              boolean listChanged = false;
350              if (!allServerList.equals(allServers)) {
351                  listChanged = true;
352                  if (changeListeners != null &amp;&amp; changeListeners.size() &gt; 0) {
353                     List&lt;Server&gt; oldList = ImmutableList.copyOf(allServerList);
354                     List&lt;Server&gt; newList = ImmutableList.copyOf(allServers);                   
355                     for (ServerListChangeListener l: changeListeners) {
356                         try {
357                             l.serverListChanged(oldList, newList);
358                         } catch (Exception e) {
359                             logger.error(&quot;LoadBalancer [{}]: Error invoking server list change listener&quot;, name, e);
360                         }
361                     }
362                  }
363              }
364              if (isEnablePrimingConnections()) {
365                  for (Server server : allServers) {
366                      if (!allServerList.contains(server)) {
367                          server.setReadyToServe(false);
368                          newServers.add((Server) server);
369                      }
370                  }
371                  if (primeConnections != null) {
372                      primeConnections.primeConnectionsAsync(newServers, this);
373                  }
374              }
375              allServerList = allServers;
376              if (canSkipPing()) {
377                  for (Server s : allServerList) {
378                      s.setAlive(true);
379                  }
380                  upServerList = allServerList;
381              } else if (listChanged) {
382                  forceQuickPing();
383              }
384          } finally {
385              writeLock.unlock();
386          }
387      }
388      void setServers(String srvString) {
389          if (srvString != null) {
390              try {
391                  String[] serverArr = srvString.split(&quot;,&quot;);
392                  ArrayList&lt;Server&gt; newList = new ArrayList&lt;Server&gt;();
393                  for (String serverString : serverArr) {
394                      if (serverString != null) {
395                          serverString = serverString.trim();
396                          if (serverString.length() &gt; 0) {
397                              Server svr = new Server(serverString);
398                              newList.add(svr);
399                          }
400                      }
401                  }
402                  setServersList(newList);
403              } catch (Exception e) {
404                  logger.error(&quot;LoadBalancer [{}]: Exception while adding Servers&quot;, name, e);
405              }
406          }
407      }
408      public Server getServerByIndex(int index, boolean availableOnly) {
409          try {
410              return (availableOnly ? upServerList.get(index) : allServerList
411                      .get(index));
412          } catch (Exception e) {
413              return null;
414          }
415      }
416      @Override
417      public List&lt;Server&gt; getServerList(boolean availableOnly) {
418          return (availableOnly ? getReachableServers() : getAllServers());
419      }
420      @Override
421      public List&lt;Server&gt; getReachableServers() {
422          return Collections.unmodifiableList(upServerList);
423      }
424      @Override
425      public List&lt;Server&gt; getAllServers() {
426          return Collections.unmodifiableList(allServerList);
427      }
428      @Override
429      public List&lt;Server&gt; getServerList(ServerGroup serverGroup) {
430          switch (serverGroup) {
431          case ALL:
432              return allServerList;
433          case STATUS_UP:
434              return upServerList;
435          case STATUS_NOT_UP:
436              ArrayList&lt;Server&gt; notAvailableServers = new ArrayList&lt;Server&gt;(
437                      allServerList);
438              ArrayList&lt;Server&gt; upServers = new ArrayList&lt;Server&gt;(upServerList);
439              notAvailableServers.removeAll(upServers);
440              return notAvailableServers;
441          }
442          return new ArrayList&lt;Server&gt;();
443      }
444      public void cancelPingTask() {
445          if (lbTimer != null) {
446              lbTimer.cancel();
447          }
448      }
449      class PingTask extends TimerTask {
450          public void run() {
451              try {
452              	new Pinger(pingStrategy).runPinger();
453              } catch (Exception e) {
454                  logger.error(&quot;LoadBalancer [{}]: Error pinging&quot;, name, e);
455              }
456          }
457      }
458      class Pinger {
459          private final IPingStrategy pingerStrategy;
460          public Pinger(IPingStrategy pingerStrategy) {
461              this.pingerStrategy = pingerStrategy;
462          }
463          public void runPinger() throws Exception {
464              if (!pingInProgress.compareAndSet(false, true)) { 
465                  return; 
466              }
467              Server[] allServers = null;
468              boolean[] results = null;
469              Lock allLock = null;
470              Lock upLock = null;
471              try {
472                  allLock = allServerLock.readLock();
473                  allLock.lock();
474                  allServers = allServerList.toArray(new Server[allServerList.size()]);
475                  allLock.unlock();
476                  int numCandidates = allServers.length;
477                  results = pingerStrategy.pingServers(ping, allServers);
478                  final List&lt;Server&gt; newUpList = new ArrayList&lt;Server&gt;();
479                  final List&lt;Server&gt; changedServers = new ArrayList&lt;Server&gt;();
480                  for (int i = 0; i &lt; numCandidates; i++) {
481                      boolean isAlive = results[i];
482                      Server svr = allServers[i];
483                      boolean oldIsAlive = svr.isAlive();
484                      svr.setAlive(isAlive);
485                      if (oldIsAlive != isAlive) {
486                          changedServers.add(svr);
487                          logger.debug(&quot;LoadBalancer [{}]:  Server [{}] status changed to {}&quot;, 
488                      		name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;));
489                      }
490                      if (isAlive) {
491                          newUpList.add(svr);
492                      }
493                  }
494                  upLock = upServerLock.writeLock();
495                  upLock.lock();
496                  upServerList = newUpList;
497                  upLock.unlock();
498                  notifyServerStatusChangeListener(changedServers);
499              } finally {
500                  pingInProgress.set(false);
501              }
502          }
503      }
504      private void notifyServerStatusChangeListener(final Collection&lt;Server&gt; changedServers) {
505          if (changedServers != null &amp;&amp; !changedServers.isEmpty() &amp;&amp; !serverStatusListeners.isEmpty()) {
506              for (ServerStatusChangeListener listener : serverStatusListeners) {
507                  try {
508                      listener.serverStatusChanged(changedServers);
509                  } catch (Exception e) {
510                      logger.error(&quot;LoadBalancer [{}]: Error invoking server status change listener&quot;, name, e);
511                  }
512              }
513          }
514      }
515      private final Counter createCounter() {
516          return Monitors.newCounter(&quot;LoadBalancer_ChooseServer&quot;);
517      }
518      public Server chooseServer(Object key) {
519          if (counter == null) {
520              counter = createCounter();
521          }
522          counter.increment();
523          if (rule == null) {
524              return null;
525          } else {
526              try {
527                  return rule.choose(key);
528              } catch (Exception e) {
529                  logger.warn(&quot;LoadBalancer [{}]:  Error choosing server for key {}&quot;, name, key, e);
530                  return null;
531              }
532          }
533      }
534      public String choose(Object key) {
535          if (rule == null) {
536              return null;
537          } else {
538              try {
539                  Server svr = rule.choose(key);
540                  return ((svr == null) ? null : svr.getId());
541              } catch (Exception e) {
542                  logger.warn(&quot;LoadBalancer [{}]:  Error choosing server&quot;, name, e);
543                  return null;
544              }
545          }
546      }
547      public void markServerDown(Server server) {
548          if (server == null || !server.isAlive()) {
549              return;
550          }
551          logger.error(&quot;LoadBalancer [{}]:  markServerDown called on [{}]&quot;, name, server.getId());
552          server.setAlive(false);
553          notifyServerStatusChangeListener(singleton(server));
554      }
555      public void markServerDown(String id) {
556          boolean triggered = false;
557          id = Server.normalizeId(id);
558          if (id == null) {
559              return;
560          }
561          Lock writeLock = upServerLock.writeLock();
562      	writeLock.lock();
563          try {
564              final List&lt;Server&gt; changedServers = new ArrayList&lt;Server&gt;();
565              for (Server svr : upServerList) {
566                  if (svr.isAlive() &amp;&amp; (svr.getId().equals(id))) {
567                      triggered = true;
568                      svr.setAlive(false);
569                      changedServers.add(svr);
570                  }
571              }
572              if (triggered) {
573                  logger.error(&quot;LoadBalancer [{}]:  markServerDown called for server [{}]&quot;, name, id);
574                  notifyServerStatusChangeListener(changedServers);
575              }
576          } finally {
577              writeLock.unlock();
578          }
579      }
580      public void forceQuickPing() {
581          if (canSkipPing()) {
582              return;
583          }
584          logger.debug(&quot;LoadBalancer [{}]:  forceQuickPing invoking&quot;, name);
<span onclick='openModal()' class='match'>585          try {
586          	new Pinger(pingStrategy).runPinger();
587          } catch (Exception e) {
588              logger.error(&quot;LoadBalancer [{}]: Error running forceQuickPing()&quot;, name, e);
589          }
590      }
591      public String toString() {
</span>592          StringBuilder sb = new StringBuilder();
593          sb.append(&quot;{NFLoadBalancer:name=&quot;).append(this.getName())
594                  .append(&quot;,current list of Servers=&quot;).append(this.allServerList)
595                  .append(&quot;,Load balancer stats=&quot;)
596                  .append(this.lbStats.toString()).append(&quot;}&quot;);
597          return sb.toString();
598      }
599      protected void init() {
600          Monitors.registerObject(&quot;LoadBalancer_&quot; + name, this);
601          Monitors.registerObject(&quot;Rule_&quot; + name, this.getRule());
602          if (enablePrimingConnections &amp;&amp; primeConnections != null) {
603              primeConnections.primeConnections(getReachableServers());
604          }
605      }
606      public final PrimeConnections getPrimeConnections() {
607          return primeConnections;
608      }
609      public final void setPrimeConnections(PrimeConnections primeConnections) {
610          this.primeConnections = primeConnections;
611      }
612      @Override
613      public void primeCompleted(Server s, Throwable lastException) {
614          s.setReadyToServe(true);
615      }
616      public boolean isEnablePrimingConnections() {
617          return enablePrimingConnections;
618      }
619      public final void setEnablePrimingConnections(
620              boolean enablePrimingConnections) {
621          this.enablePrimingConnections = enablePrimingConnections;
622      }
623      public void shutdown() {
624          cancelPingTask();
625          if (primeConnections != null) {
626              primeConnections.shutdown();
627          }
628          Monitors.unregisterObject(&quot;LoadBalancer_&quot; + name, this);
629          Monitors.unregisterObject(&quot;Rule_&quot; + name, this.getRule());
630      }
631      private static class SerialPingStrategy implements IPingStrategy {
632          @Override
633          public boolean[] pingServers(IPing ping, Server[] servers) {
634              int numCandidates = servers.length;
635              boolean[] results = new boolean[numCandidates];
636              logger.debug(&quot;LoadBalancer:  PingTask executing [{}] servers configured&quot;, numCandidates);
637              for (int i = 0; i &lt; numCandidates; i++) {
638                  results[i] = false; &amp;bsol;* Default answer is DEAD. */
639                  try {
640                      if (ping != null) {
641                          results[i] = ping.isAlive(servers[i]);
642                      }
643                  } catch (Exception e) {
644                      logger.error(&quot;Exception while pinging Server: &#x27;{}&#x27;&quot;, servers[i], e);
645                  }
646              }
647              return results;
648          }
649      }
650  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-BaseLoadBalancer.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-BaseLoadBalancer.java</div>
                </div>
                <div class="column column_space"><pre><code>451              try {
452              	new Pinger(pingStrategy).runPinger();
453              } catch (Exception e) {
454                  logger.error(&quot;LoadBalancer [{}]: Error pinging&quot;, name, e);
455              }
456          }
457      }
</pre></code></div>
                <div class="column column_space"><pre><code>585          try {
586          	new Pinger(pingStrategy).runPinger();
587          } catch (Exception e) {
588              logger.error(&quot;LoadBalancer [{}]: Error running forceQuickPing()&quot;, name, e);
589          }
590      }
591      public String toString() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    