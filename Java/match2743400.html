<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RepositoriesService.java &amp; MoreTypes.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RepositoriesService.java &amp; MoreTypes.java
      </h3>
<h1 align="center">
        8.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RepositoriesService.java (10.298508%)<th>MoreTypes.java (6.9%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(34-60)<td><a href="#" name="0">(20-51)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(349-363)<td><a href="#" name="1">(338-348)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(166-173)<td><a href="#" name="2">(600-607)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(408-412)<td><a href="#" name="3">(153-158)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(365-379)<td><a href="#" name="4">(426-434)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(220-226)<td><a href="#" name="5">(535-541)</a><td align="center"><font color="#680000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RepositoriesService.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.repositories;
2 import java.io.IOException;
3 import java.util.ArrayList;
4 import java.util.Collection;
5 import java.util.Collections;
6 import java.util.HashMap;
7 import java.util.List;
8 import java.util.Map;
9 import io.crate.common.io.IOUtils;
10 <a name="0"></a>import org.apache.logging.log4j.LogManager;
11 import org.apache.logging.log4j.Logger;
12 import org.apache.logging.log4j.message.ParameterizedMessage;
13 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.elasticsearch.action.ActionListener;
14 import org.elasticsearch.action.ActionRunnable;
15 import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryRequest;
16 import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;
17 import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
18 import org.elasticsearch.cluster.ClusterChangedEvent;
19 import org.elasticsearch.cluster.ClusterState;
20 import org.elasticsearch.cluster.ClusterStateApplier;
21 import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;
22 import org.elasticsearch.cluster.metadata.Metadata;
23 import org.elasticsearch.cluster.metadata.RepositoriesMetadata;
24 import org.elasticsearch.cluster.metadata.RepositoryMetadata;
25 import org.elasticsearch.cluster.node.DiscoveryNode;
26 import org.elasticsearch.cluster.service.ClusterService;
27 import org.elasticsearch.common.regex.Regex;
28 import org.elasticsearch.common.settings.Settings;
29 import org.elasticsearch.snapshots.RestoreService;
30 import org.elasticsearch.snapshots.SnapshotsService;
31 import org.elasticsearch.threadpool.ThreadPool;
32 import org.elasticsearch.transport.TransportService;
33 public class RepositoriesService implements ClusterStateApplier {
34     private static final Logger LOGGER = LogManager.getLogger(RepositoriesService.class)</b></font>;
35     private final Map&lt;String, Repository.Factory&gt; typesRegistry;
36     private final ClusterService clusterService;
37     private final ThreadPool threadPool;
38     private final VerifyNodeRepositoryAction verifyAction;
39     private volatile Map&lt;String, Repository&gt; repositories = Collections.emptyMap();
40     public RepositoriesService(Settings settings, ClusterService clusterService, TransportService transportService,
41                                Map&lt;String, Repository.Factory&gt; typesRegistry,
42                                ThreadPool threadPool) {
43         this.typesRegistry = typesRegistry;
44         this.clusterService = clusterService;
45         this.threadPool = threadPool;
46         if (DiscoveryNode.isDataNode(settings) || DiscoveryNode.isMasterEligibleNode(settings)) {
47             clusterService.addStateApplier(this);
48         }
49         this.verifyAction = new VerifyNodeRepositoryAction(transportService, clusterService, this);
50     }
51     public void registerRepository(final PutRepositoryRequest request, final ActionListener&lt;ClusterStateUpdateResponse&gt; listener) {
52         final RepositoryMetadata newRepositoryMetadata = new RepositoryMetadata(request.name(), request.type(), request.settings());
53         final ActionListener&lt;ClusterStateUpdateResponse&gt; registrationListener;
54         if (request.verify()) {
55             registrationListener = ActionListener.delegateFailure(listener, (delegatedListener, clusterStateUpdateResponse) -&gt; {
56                 if (clusterStateUpdateResponse.isAcknowledged()) {
57                     verifyRepository(request.name(), ActionListener.delegateFailure(delegatedListener,
58                         (innerDelegatedListener, discoveryNodes) -&gt; innerDelegatedListener.onResponse(clusterStateUpdateResponse)));
59                 } else {
60                     delegatedListener.onResponse(clusterStateUpdateResponse);
61                 }
62             });
63         } else {
64             registrationListener = listener;
65         }
66         clusterService.submitStateUpdateTask("put_repository [" + request.name() + "]",
67             new AckedClusterStateUpdateTask&lt;ClusterStateUpdateResponse&gt;(request, registrationListener) {
68                 @Override
69                 protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {
70                     return new ClusterStateUpdateResponse(acknowledged);
71                 }
72                 @Override
73                 public ClusterState execute(ClusterState currentState) throws IOException {
74                     ensureRepositoryNotInUse(currentState, request.name());
75                     if (!registerRepository(newRepositoryMetadata)) {
76                         return currentState;
77                     }
78                     Metadata metadata = currentState.metadata();
79                     Metadata.Builder mdBuilder = Metadata.builder(currentState.metadata());
80                     RepositoriesMetadata repositories = metadata.custom(RepositoriesMetadata.TYPE);
81                     if (repositories == null) {
82                         LOGGER.info("put repository [{}]", request.name());
83                         repositories = new RepositoriesMetadata(
84                             Collections.singletonList(new RepositoryMetadata(request.name(), request.type(), request.settings())));
85                     } else {
86                         boolean found = false;
87                         List&lt;RepositoryMetadata&gt; repositoriesMetadata = new ArrayList&lt;&gt;(repositories.repositories().size() + 1);
88                         for (RepositoryMetadata repositoryMetadata : repositories.repositories()) {
89                             if (repositoryMetadata.name().equals(newRepositoryMetadata.name())) {
90                                 if (newRepositoryMetadata.equalsIgnoreGenerations(repositoryMetadata)) {
91                                     return currentState;
92                                 }
93                                 found = true;
94                                 repositoriesMetadata.add(newRepositoryMetadata);
95                             } else {
96                                 repositoriesMetadata.add(repositoryMetadata);
97                             }
98                         }
99                         if (!found) {
100                             LOGGER.info("put repository [{}]", request.name());
101                             repositoriesMetadata.add(new RepositoryMetadata(request.name(), request.type(), request.settings()));
102                         } else {
103                             LOGGER.info("update repository [{}]", request.name());
104                         }
105                         repositories = new RepositoriesMetadata(repositoriesMetadata);
106                     }
107                     mdBuilder.putCustom(RepositoriesMetadata.TYPE, repositories);
108                     return ClusterState.builder(currentState).metadata(mdBuilder).build();
109                 }
110 <a name="2"></a>
111                 @Override
112                 public void onFailure(String source, Exception e) {
113                     LOGGER.warn(() -&gt; new ParameterizedMessage("failed to create repository [{}]", <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>request.name()), e);
114                     super.onFailure(source, e);
115                 }
116                 @Override
117                 public boolean mustAck(DiscoveryNode discoveryNode) {
118                     return discoveryNode.isMasterEligibleNode</b></font>() || discoveryNode.isDataNode();
119                 }
120             });
121     }
122     public void unregisterRepository(final DeleteRepositoryRequest request, final ActionListener&lt;ClusterStateUpdateResponse&gt; listener) {
123         clusterService.submitStateUpdateTask("delete_repository [" + request.name() + "]",
124             new AckedClusterStateUpdateTask&lt;&gt;(request, listener) {
125                 @Override
126                 protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {
127                     return new ClusterStateUpdateResponse(acknowledged);
128                 }
129                 @Override
130                 public ClusterState execute(ClusterState currentState) {
131                     ensureRepositoryNotInUse(currentState, request.name());
132                     Metadata metadata = currentState.metadata();
133                     Metadata.Builder mdBuilder = Metadata.builder(currentState.metadata());
134                     RepositoriesMetadata repositories = metadata.custom(RepositoriesMetadata.TYPE);
135                     if (repositories != null &amp;&amp; repositories.repositories().size() &gt; 0) {
136                         List&lt;RepositoryMetadata&gt; repositoriesMetadata = new ArrayList&lt;&gt;(repositories.repositories().size());
137                         boolean changed = false;
138                         for (RepositoryMetadata repositoryMetadata : repositories.repositories()) {
139                             if (Regex.simpleMatch(request.name(), repositoryMetadata.name())) {
140                                 LOGGER.info("delete repository [{}]", repositoryMetadata.name());
141                                 changed = true;
142                             } else {
143                                 repositoriesMetadata.add(repositoryMetadata);
144                             }
145                         }
146                         if (changed) {
147                             repositories = new RepositoriesMetadata(repositoriesMetadata);
148                             mdBuilder.putCustom(RepositoriesMetadata.TYPE, repositories);
149                             return ClusterState.builder(currentState).metadata(mdBuilder).build();
150                         }
151                     }
152 <a name="5"></a>                    if (Regex.isMatchAllPattern(request.name())) {                         return currentState;
153                     }
154                     throw new RepositoryMissingException(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>request.name());
155                 }
156                 @Override
157                 public boolean mustAck(DiscoveryNode discoveryNode) {
158                     return discoveryNode.isMasterEligibleNode</b></font>() || discoveryNode.isDataNode();
159                 }
160             });
161     }
162     public void verifyRepository(final String repositoryName, final ActionListener&lt;List&lt;DiscoveryNode&gt;&gt; listener) {
163         final Repository repository = repository(repositoryName);
164         final boolean readOnly = repository.isReadOnly();
165         threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new ActionRunnable&lt;&gt;(listener) {
166             @Override
167             protected void doRun() {
168                 final String verificationToken = repository.startVerification();
169                 if (verificationToken != null) {
170                     try {
171                         verifyAction.verify(repositoryName, readOnly, verificationToken, ActionListener.delegateFailure(listener,
172                             (delegatedListener, verifyResponse) -&gt; threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -&gt; {
173                                 try {
174                                     repository.endVerification(verificationToken);
175                                 } catch (Exception e) {
176                                     LOGGER.warn(() -&gt; new ParameterizedMessage(
177                                         "[{}] failed to finish repository verification", repositoryName), e);
178                                     delegatedListener.onFailure(e);
179                                     return;
180                                 }
181                                 delegatedListener.onResponse(verifyResponse);
182                             })));
183                     } catch (Exception e) {
184                         threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -&gt; {
185                             try {
186                                 repository.endVerification(verificationToken);
187                             } catch (Exception inner) {
188                                 inner.addSuppressed(e);
189                                 LOGGER.warn(() -&gt; new ParameterizedMessage(
190                                     "[{}] failed to finish repository verification", repositoryName), inner);
191                             }
192                             listener.onFailure(e);
193                         });
194                     }
195                 } else {
196                     listener.onResponse(Collections.emptyList());
197                 }
198             }
199         });
200     }
201     @Override
202     public void applyClusterState(ClusterChangedEvent event) {
203         try {
204             final ClusterState state = event.state();
205             RepositoriesMetadata oldMetadata = event.previousState().getMetadata().custom(RepositoriesMetadata.TYPE);
206             RepositoriesMetadata newMetadata = state.getMetadata().custom(RepositoriesMetadata.TYPE);
207             if ((oldMetadata == null &amp;&amp; newMetadata == null) || (oldMetadata != null &amp;&amp; oldMetadata.equalsIgnoreGenerations(newMetadata))) {
208                 for (Repository repo : repositories.values()) {
209                     repo.updateState(state);
210                 }
211                 return;
212             }
213             LOGGER.trace("processing new index repositories for state version [{}]", event.state().version());
214             Map&lt;String, Repository&gt; survivors = new HashMap&lt;&gt;();
215             for (Map.Entry&lt;String, Repository&gt; entry : repositories.entrySet()) {
216                 if (newMetadata == null || newMetadata.repository(entry.getKey()) == null) {
217                     LOGGER.debug("unregistering repository [{}]", entry.getKey());
218                     closeRepository(entry.getValue());
219                 } else {
220                     survivors.put(entry.getKey(), entry.getValue());
221                 }
222             }
223             Map&lt;String, Repository&gt; builder = new HashMap&lt;&gt;();
224             if (newMetadata != null) {
225                 for (RepositoryMetadata repositoryMetadata : newMetadata.repositories()) {
226                     Repository repository = survivors.get(repositoryMetadata.name());
227                     if (repository != null) {
228                         RepositoryMetadata previousMetadata = repository.getMetadata();
229                         if (previousMetadata.type().equals(repositoryMetadata.type()) == false
230                             || previousMetadata.settings().equals(repositoryMetadata.settings()) == false) {
231                             LOGGER.debug("updating repository [{}]", repositoryMetadata.name());
232                             closeRepository(repository);
233                             repository = null;
234                             try {
235                                 repository = createRepository(repositoryMetadata);
236                             } catch (RepositoryException ex) {
237                                 LOGGER.warn(() -&gt; new ParameterizedMessage("failed to change repository [{}]", repositoryMetadata.name()), ex);
238                             }
239                         }
240                     } else {
241                         try {
242                             repository = createRepository(repositoryMetadata);
243                         } catch (RepositoryException ex) {
244                             LOGGER.warn(() -&gt; new ParameterizedMessage("failed to create repository [{}]", repositoryMetadata.name()), ex);
245                         }
246                     }
247                     if (repository != null) {
248                         LOGGER.debug("registering repository [{}]", repositoryMetadata.name());
249                         builder.put(repositoryMetadata.name(), repository);
250                     }
251                 }
252             }
253             for (Repository repo : builder.values()) {
254                 repo.updateState(state);
255             }
256             repositories = Collections.unmodifiableMap(builder);
257 <a name="1"></a>        } catch (Exception ex) {
258             LOGGER.warn("failure updating cluster state ", ex);
259         }
260     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
261     public Repository repository(String repositoryName) {
262         Repository repository = repositories.get(repositoryName);
263 <a name="4"></a>        if (repository != null) {
264             return</b></font> repository;
265         }
266         <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>throw new RepositoryMissingException(repositoryName);
267     }
268     private boolean registerRepository(RepositoryMetadata repositoryMetadata) throws IOException {
269         Repository previous = repositories.get</b></font>(repositoryMetadata.name());
270         if (previous != null) {
271             RepositoryMetadata previousMetadata = previous.getMetadata();
272             if (previousMetadata.equals(repositoryMetadata)) {
273                 return false;
274             }
275         }
276         Repository newRepo = createRepository(repositoryMetadata);
277         if (previous != null) {
278             closeRepository(previous);
279         }
280         Map&lt;String, Repository&gt; newRepositories = new HashMap&lt;&gt;(repositories);
281         newRepositories.put(repositoryMetadata.name(), newRepo);
282         repositories = newRepositories;
283         return true;
284     }
285     private void closeRepository(Repository repository) throws IOException {
286         LOGGER.debug("closing repository [{}][{}]", repository.getMetadata().type(), repository.getMetadata().name());
287         repository.close();
288     }
289     private Repository createRepository(RepositoryMetadata repositoryMetadata) {
290         LOGGER.debug("creating repository [{}][{}]", repositoryMetadata.type(), repositoryMetadata.name());
291         Repository.Factory factory = typesRegistry.get(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>repositoryMetadata.type());
292         if (factory == null) {
293             throw new RepositoryException(repositoryMetadata.name(),
294                 "repository type [" + repositoryMetadata.type() + "] does not exist");
295         }</b></font>
296         Repository repository = null;
297         try {
298             repository = factory.create(repositoryMetadata);
299             repository.start();
300             return repository;
301         } catch (Exception e) {
302             IOUtils.closeWhileHandlingException(repository);
303             LOGGER.warn(new ParameterizedMessage("failed to create repository [{}][{}]",
304                 repositoryMetadata.type(), repositoryMetadata.name()), e);
305             throw new RepositoryException(repositoryMetadata.name(), "failed to create repository", e);
306         }
307     }
308     private void ensureRepositoryNotInUse(ClusterState clusterState, String repository) {
309         if (SnapshotsService.isRepositoryInUse(clusterState, repository) || RestoreService.isRepositoryInUse(clusterState, repository)) {
310             throw new IllegalStateException("trying to modify or unregister repository that is currently used ");
311         }
312     }
313     public Collection&lt;Repository&gt; getRepositoriesList() {
314         return Collections.unmodifiableCollection(repositories.values());
315     }
316     public Map&lt;String, Repository.Factory&gt; typesRegistry() {
317         return typesRegistry;
318     }
319 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreTypes.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.common.inject.internal;
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.common.inject.ConfigurationException;
4 import org.elasticsearch.common.inject.TypeLiteral;
5 import org.elasticsearch.common.inject.spi.Message;
6 import java.lang.reflect.Constructor;
7 import java.lang.reflect.Field;
8 import java.lang.reflect.GenericArrayType;
9 import java.lang.reflect.GenericDeclaration;
10 import java.lang.reflect.Member;
11 import java.lang.reflect.Method;
12 import java.lang.reflect.ParameterizedType;
13 import java.lang.reflect.Type;
14 import java.lang.reflect.TypeVariable;
15 import java.lang.reflect.WildcardType;
16 import java.util.Arrays;
17 import java.util.HashMap;
18 import java.util.Map;
19 import java.util.NoSuchElementException;
20 import java.util.Objects;
21 import static java.util.Collections.singleton;
22 import static java.util.Collections.unmodifiableMap;
23 public class MoreTypes {
24     public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{}</b></font>;
25     private MoreTypes() {
26     }
27     private static final Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; PRIMITIVE_TO_WRAPPER;
28     static {
29         Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; primitiveToWrapper = new HashMap&lt;&gt;();
30         primitiveToWrapper.put(TypeLiteral.get(boolean.class), TypeLiteral.get(Boolean.class));
31         primitiveToWrapper.put(TypeLiteral.get(byte.class), TypeLiteral.get(Byte.class));
32         primitiveToWrapper.put(TypeLiteral.get(short.class), TypeLiteral.get(Short.class));
33         primitiveToWrapper.put(TypeLiteral.get(int.class), TypeLiteral.get(Integer.class));
34         primitiveToWrapper.put(TypeLiteral.get(long.class), TypeLiteral.get(Long.class));
35         primitiveToWrapper.put(TypeLiteral.get(float.class), TypeLiteral.get(Float.class));
36         primitiveToWrapper.put(TypeLiteral.get(double.class), TypeLiteral.get(Double.class));
37         primitiveToWrapper.put(TypeLiteral.get(char.class), TypeLiteral.get(Character.class));
38         primitiveToWrapper.put(TypeLiteral.get(void.class), TypeLiteral.get(Void.class));
39         PRIMITIVE_TO_WRAPPER = unmodifiableMap(primitiveToWrapper);
40     }
41     public static &lt;T&gt; TypeLiteral&lt;T&gt; makeKeySafe(TypeLiteral&lt;T&gt; type) {
42         if (!isFullySpecified(type.getType())) {
43             String message = type + " cannot be used as a key; It is not fully specified.";
44             throw new ConfigurationException(singleton(new Message(message)));
45         }
46         @SuppressWarnings("unchecked")
47         TypeLiteral&lt;T&gt; wrappedPrimitives = (TypeLiteral&lt;T&gt;) PRIMITIVE_TO_WRAPPER.get(type);
48         return wrappedPrimitives != null
49                 ? wrappedPrimitives
50                 : type;
51     }
52     private static boolean isFullySpecified(Type type) {
53         if (type instanceof Class) {
54             return true;
55         } else if (type instanceof CompositeType) {
56             return ((CompositeType) type).isFullySpecified();
57         } else if (type instanceof TypeVariable) {
58             return false;
59         } else {
60             return ((CompositeType) canonicalize(type)).isFullySpecified();
61         }
62     }
63     public static Type canonicalize(Type type) {
64         if (type instanceof ParameterizedTypeImpl
65                 || type instanceof GenericArrayTypeImpl
66                 || type instanceof WildcardTypeImpl) {
67             return type;
68         } else if (type instanceof ParameterizedType) {
69             ParameterizedType p = (ParameterizedType) type;
70             return new ParameterizedTypeImpl(p.getOwnerType(),
71                     p.getRawType(), p.getActualTypeArguments());
72         } else if (type instanceof GenericArrayType) {
73             GenericArrayType g = (GenericArrayType) type;
74             return new GenericArrayTypeImpl(g.getGenericComponentType());
75         } else if (type instanceof Class &amp;&amp; ((Class&lt;?&gt;) type).isArray()) {
76             Class&lt;?&gt; c = (Class&lt;?&gt;) type;
77             return new GenericArrayTypeImpl(c.getComponentType());
78         } else if (type instanceof WildcardType) {
79             WildcardType w = (WildcardType) type;
80             return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
81         } else {
82             return type;
83         }
84     }
85     public static Class&lt;?&gt; getRawType(Type type) {
86         if (type instanceof Class&lt;?&gt;) {
87             return (Class&lt;?&gt;) type;
88         } else if (type instanceof ParameterizedType) {
89             ParameterizedType parameterizedType = (ParameterizedType) type;
90 <a name="3"></a>                        Type rawType = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>parameterizedType.getRawType();
91             if (!(rawType instanceof Class)) {
92                 throw new IllegalArgumentException(
93                     "Expected a Class, but &lt;" + type + "&gt; is of type " + type.getClass().getName()
94                 );
95             }</b></font>
96             return (Class&lt;?&gt;) rawType;
97         } else if (type instanceof GenericArrayType) {
98             return Object[].class;
99         } else if (type instanceof TypeVariable) {
100             return Object.class;
101         } else {
102             throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
103                     + "GenericArrayType, but &lt;" + type + "&gt; is of type " + type.getClass().getName());
104         }
105     }
106     public static boolean equals(Type a, Type b) {
107         if (a == b) {
108             return true;
109         } else if (a instanceof Class) {
110             return a.equals(b);
111         } else if (a instanceof ParameterizedType) {
112             if (!(b instanceof ParameterizedType)) {
113                 return false;
114             }
115             ParameterizedType pa = (ParameterizedType) a;
116             ParameterizedType pb = (ParameterizedType) b;
117             return Objects.equals(pa.getOwnerType(), pb.getOwnerType())
118                     &amp;&amp; pa.getRawType().equals(pb.getRawType())
119                     &amp;&amp; Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
120         } else if (a instanceof GenericArrayType) {
121             if (!(b instanceof GenericArrayType)) {
122                 return false;
123             }
124             GenericArrayType ga = (GenericArrayType) a;
125             GenericArrayType gb = (GenericArrayType) b;
126             return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
127         } else if (a instanceof WildcardType) {
128             if (!(b instanceof WildcardType)) {
129                 return false;
130             }
131             WildcardType wa = (WildcardType) a;
132             WildcardType wb = (WildcardType) b;
133             return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
134                     &amp;&amp; Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
135         } else if (a instanceof TypeVariable) {
136             if (!(b instanceof TypeVariable)) {
137                 return false;
138             }
139             TypeVariable&lt;?&gt; va = (TypeVariable) a;
140             TypeVariable&lt;?&gt; vb = (TypeVariable) b;
141             return va.getGenericDeclaration() == vb.getGenericDeclaration()
142                     &amp;&amp; va.getName().equals(vb.getName());
143         } else {
144             return false;
145         }
146     }
147     public static int hashCode(Type type) {
148         if (type instanceof Class) {
149             return type.hashCode();
150         } else if (type instanceof ParameterizedType) {
151             ParameterizedType p = (ParameterizedType) type;
152             return Arrays.hashCode(p.getActualTypeArguments())
153                     ^ p.getRawType().hashCode()
154                     ^ hashCodeOrZero(p.getOwnerType());
155         } else if (type instanceof GenericArrayType) {
156             return hashCode(((GenericArrayType) type).getGenericComponentType());
157         } else if (type instanceof WildcardType) {
158             WildcardType w = (WildcardType) type;
159             return Arrays.hashCode(w.getLowerBounds()) ^ Arrays.hashCode(w.getUpperBounds());
160         } else {
161             return hashCodeOrZero(type);
162         }
163     }
164     private static int hashCodeOrZero(Object o) {
165         return o != null ? o.hashCode() : 0;
166     }
167     public static String toString(Type type) {
168         if (type instanceof Class&lt;?&gt;) {
169             return ((Class) type).getName();
170         } else if (type instanceof ParameterizedType) {
171             ParameterizedType parameterizedType = (ParameterizedType) type;
172             Type[] arguments = parameterizedType.getActualTypeArguments();
173             Type ownerType = parameterizedType.getOwnerType();
174             StringBuilder stringBuilder = new StringBuilder();
175             if (ownerType != null) {
176                 stringBuilder.append(toString(ownerType)).append(".");
177             }
178             stringBuilder.append(toString(parameterizedType.getRawType()));
179             if (arguments.length &gt; 0) {
180                 stringBuilder
181                         .append("&lt;")
182                         .append(toString(arguments[0]));
183                 for (int i = 1; i &lt; arguments.length; i++) {
184                     stringBuilder.append(", ").append(toString(arguments[i]));
185                 }
186             }
187             return stringBuilder.append("&gt;").toString();
188         } else if (type instanceof GenericArrayType) {
189             return toString(((GenericArrayType) type).getGenericComponentType()) + "[]";
190         } else if (type instanceof WildcardType) {
191             WildcardType wildcardType = (WildcardType) type;
192             Type[] lowerBounds = wildcardType.getLowerBounds();
193             Type[] upperBounds = wildcardType.getUpperBounds();
194             if (upperBounds.length != 1 || lowerBounds.length &gt; 1) {
195                 throw new UnsupportedOperationException("Unsupported wildcard type " + type);
196             }
197             if (lowerBounds.length == 1) {
198                 if (upperBounds[0] != Object.class) {
199                     throw new UnsupportedOperationException("Unsupported wildcard type " + type);
200                 }
201                 return "? super " + toString(lowerBounds[0]);
202             } else if (upperBounds[0] == Object.class) {
203                 return "?";
204             } else {
205                 return "? extends " + toString(upperBounds[0]);
206             }
207         } else {
208             return type.toString();
209         }
210     }
211     public static Class&lt;? extends Member&gt; memberType(Member member) {
212         Objects.requireNonNull(member, "member");
213         if (member instanceof MemberImpl) {
214             return ((MemberImpl) member).memberType;
215         } else if (member instanceof Field) {
216             return Field.class;
217         } else if (member instanceof Method) {
218             return Method.class;
219         } else if (member instanceof Constructor) {
220             return Constructor.class;
221         } else {
222 <a name="1"></a>            throw new IllegalArgumentException(
223                     "Unsupported implementation class for Member, " + member.getClass());
224         }
225     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
226     public static String toString(Member member) {
227         Class&lt;? extends Member&gt; memberType = memberType(member);
228         if (memberType == Method.class) {
229             return</b></font> member.getDeclaringClass().getName() + "." + member.getName() + "()";
230         } else if (memberType == Field.class) {
231             return member.getDeclaringClass().getName() + "." + member.getName();
232         } else if (memberType == Constructor.class) {
233             return member.getDeclaringClass().getName() + ".&lt;init&gt;()";
234         } else {
235             throw new AssertionError();
236         }
237     }
238     public static String memberKey(Member member) {
239         Objects.requireNonNull(member, "member");
240         return "&lt;NO_MEMBER_KEY&gt;";
241     }
242     public static Type getGenericSupertype(Type type, Class&lt;?&gt; rawType, Class&lt;?&gt; toResolve) {
243         if (toResolve == rawType) {
244             return type;
245         }
246         if (toResolve.isInterface()) {
247             Class[] interfaces = rawType.getInterfaces();
248             for (int i = 0, length = interfaces.length; i &lt; length; i++) {
249                 if (interfaces[i] == toResolve) {
250                     return rawType.getGenericInterfaces()[i];
251                 } else if (toResolve.isAssignableFrom(interfaces[i])) {
252                     return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
253                 }
254             }
255         }
256         if (!rawType.isInterface()) {
257             while (rawType != Object.class) {
258                 Class&lt;?&gt; rawSupertype = rawType.getSuperclass();
259                 if (rawSupertype == toResolve) {
260                     return rawType.getGenericSuperclass();
261                 } else if (toResolve.isAssignableFrom(rawSupertype)) {
262                     return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
263                 }
264                 rawType = rawSupertype;
265             }
266         }
267         return toResolve;
268     }
269     public static Type resolveTypeVariable(Type type, Class&lt;?&gt; rawType, TypeVariable unknown) {
270         Class&lt;?&gt; declaredByRaw = declaringClassOf(unknown);
271         if (declaredByRaw == null) {
272             return unknown;
273         }
274         Type declaredBy = getGenericSupertype(type, rawType, declaredByRaw);
275         if (declaredBy instanceof ParameterizedType) {
276             int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
277             return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
278         }
279         return unknown;
280     }
281     private static int indexOf(Object[] array, Object toFind) {
282         for (int i = 0; i &lt; array.length; i++) {
283             if (toFind.equals(array[i])) {
284 <a name="4"></a>                return i;
285             }
286         }
287         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>throw new NoSuchElementException();
288     }
289     private static Class&lt;?&gt; declaringClassOf(TypeVariable typeVariable) {
290         GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration</b></font>();
291         return genericDeclaration instanceof Class
292                 ? (Class&lt;?&gt;) genericDeclaration
293                 : null;
294     }
295     public static class ParameterizedTypeImpl
296             implements ParameterizedType, CompositeType {
297         private final Type ownerType;
298         private final Type rawType;
299         private final Type[] typeArguments;
300         public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
301             if (rawType instanceof Class&lt;?&gt;) {
302                 Class rawTypeAsClass = (Class) rawType;
303                 if (ownerType == null &amp;&amp; rawTypeAsClass.getEnclosingClass() != null) {
304                     throw new IllegalArgumentException("No owner type for enclosed " + rawType);
305                 }
306                 if (ownerType != null &amp;&amp; rawTypeAsClass.getEnclosingClass() == null) {
307                     throw new IllegalArgumentException("Owner type for unenclosed " + rawType);
308                 }
309             }
310             this.ownerType = ownerType == null ? null : canonicalize(ownerType);
311             this.rawType = canonicalize(rawType);
312             this.typeArguments = typeArguments.clone();
313             for (int t = 0; t &lt; this.typeArguments.length; t++) {
314                 Objects.requireNonNull(this.typeArguments[t], "type parameter");
315                 checkNotPrimitive(this.typeArguments[t], "type parameters");
316                 this.typeArguments[t] = canonicalize(this.typeArguments[t]);
317             }
318         }
319         @Override
320         public Type[] getActualTypeArguments() {
321             return typeArguments.clone();
322         }
323         @Override
324         public Type getRawType() {
325             return rawType;
326         }
327         @Override
328         public Type getOwnerType() {
329             return ownerType;
330         }
331         @Override
332         public boolean isFullySpecified() {
333             if (ownerType != null &amp;&amp; !MoreTypes.isFullySpecified(ownerType)) {
334                 return false;
335             }
336             if (!MoreTypes.isFullySpecified(rawType)) {
337                 return false;
338             }
339             for (Type type : typeArguments) {
340                 if (!MoreTypes.isFullySpecified(type)) {
341                     return false;
342                 }
343             }
344             return true;
345         }
346         @Override
347         public boolean equals(Object other) {
348             return other instanceof ParameterizedType
349                     &amp;&amp; MoreTypes.equals(this, (ParameterizedType) other);
350         }
351         @Override
352         public int hashCode() {
353             return MoreTypes.hashCode(this);
354         }
355         @Override
356         public String toString() {
357             return MoreTypes.toString(this);
358         }
359     }
360     public static class GenericArrayTypeImpl
361             implements GenericArrayType, CompositeType {
362         private final Type componentType;
363         public GenericArrayTypeImpl(Type componentType) {
364             this.componentType = canonicalize(componentType);
365         }
366         @Override
367         public Type getGenericComponentType() {
368             return componentType;
369         }
370 <a name="5"></a>
371         @Override
372         public boolean isFullySpecified() {
373             return <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>MoreTypes.isFullySpecified(componentType);
374         }
375         @Override
376         public boolean equals(Object o) {
377             return o instanceof GenericArrayType
378                     &amp;&amp; MoreTypes.equals</b></font>(this, (GenericArrayType) o);
379         }
380         @Override
381         public int hashCode() {
382             return MoreTypes.hashCode(this);
383         }
384         @Override
385         public String toString() {
386             return MoreTypes.toString(this);
387         }
388     }
389     public static class WildcardTypeImpl implements WildcardType, CompositeType {
390         private final Type upperBound;
391         private final Type lowerBound;
392         public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
393             if (lowerBounds.length &gt; 1) {
394                 throw new IllegalArgumentException("Must have at most one lower bound.");
395             }
396             if (upperBounds.length != 1) {
397                 throw new IllegalArgumentException("Must have exactly one upper bound.");
398             }
399             if (lowerBounds.length == 1) {
400                 Objects.requireNonNull(lowerBounds[0], "lowerBound");
401                 checkNotPrimitive(lowerBounds[0], "wildcard bounds");
402                 if (upperBounds[0] != Object.class) {
403                     throw new IllegalArgumentException("bounded both ways");
404                 }
405                 this.lowerBound = canonicalize(lowerBounds[0]);
406                 this.upperBound = Object.class;
407             } else {
408                 Objects.requireNonNull(upperBounds[0], "upperBound");
409                 checkNotPrimitive(upperBounds[0], "wildcard bounds");
410                 this.lowerBound = null;
411                 this.upperBound = canonicalize(upperBounds[0]);
412             }
413         }
414         @Override
415         public Type[] getUpperBounds() {
416             return new Type[]{upperBound};
417         }
418         @Override
419         public Type[] getLowerBounds() {
420             return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
421         }
422 <a name="2"></a>
423         @Override
424         public boolean isFullySpecified() {
425             return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>MoreTypes.isFullySpecified(upperBound)
426                     &amp;&amp; (lowerBound == null || MoreTypes.isFullySpecified(lowerBound));
427         }
428         @Override
429         public boolean equals(Object other) {
430             return other instanceof WildcardType
431                     &amp;&amp; MoreTypes.equals</b></font>(this, (WildcardType) other);
432         }
433         @Override
434         public int hashCode() {
435             return MoreTypes.hashCode(this);
436         }
437         @Override
438         public String toString() {
439             return MoreTypes.toString(this);
440         }
441     }
442     private static void checkNotPrimitive(Type type, String use) {
443         if (type instanceof Class&lt;?&gt; &amp;&amp; ((Class) type).isPrimitive()) {
444             throw new IllegalArgumentException("Primitive types are not allowed in " + use + ": " + type);
445         }
446     }
447     public static class MemberImpl implements Member {
448         private final Class&lt;?&gt; declaringClass;
449         private final String name;
450         private final int modifiers;
451         private final boolean synthetic;
452         private final Class&lt;? extends Member&gt; memberType;
453         private final String memberKey;
454         private MemberImpl(Member member) {
455             this.declaringClass = member.getDeclaringClass();
456             this.name = member.getName();
457             this.modifiers = member.getModifiers();
458             this.synthetic = member.isSynthetic();
459             this.memberType = memberType(member);
460             this.memberKey = memberKey(member);
461         }
462         @Override
463         public Class getDeclaringClass() {
464             return declaringClass;
465         }
466         @Override
467         public String getName() {
468             return name;
469         }
470         @Override
471         public int getModifiers() {
472             return modifiers;
473         }
474         @Override
475         public boolean isSynthetic() {
476             return synthetic;
477         }
478         @Override
479         public String toString() {
480             return MoreTypes.toString(this);
481         }
482     }
483     private interface CompositeType {
484         boolean isFullySpecified();
485     }
486 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
