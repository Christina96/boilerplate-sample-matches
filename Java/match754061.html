<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for UnsignedIntsTest.java &amp; FuturesTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for UnsignedIntsTest.java &amp; FuturesTest.java
      </h3>
<h1 align="center">
        9.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>UnsignedIntsTest.java (45.20548%)<th>FuturesTest.java (5.1895857%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(351-364)<td><a href="#" name="0">(1876-1888)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(313-327)<td><a href="#" name="1">(1770-1782)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(338-349)<td><a href="#" name="2">(2068-2077)</a><td align="center"><font color="#dd0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(328-337)<td><a href="#" name="3">(1982-1991)</a><td align="center"><font color="#c70000">18</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(63-70)<td><a href="#" name="4">(3731-3738)</a><td align="center"><font color="#b10000">16</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(122-129)<td><a href="#" name="5">(378-385)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(99-106)<td><a href="#" name="6">(294-301)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(17-36)<td><a href="#" name="7">(84-102)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(374-382)<td><a href="#" name="8">(144-151)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(272-278)<td><a href="#" name="9">(525-531)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(130-146)<td><a href="#" name="10">(394-400)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(76-82)<td><a href="#" name="11">(136-143)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(304-311)<td><a href="#" name="12">(3763-3768)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(83-88)<td><a href="#" name="13">(3705-3711)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(197-203)<td><a href="#" name="14">(3174-3180)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(169-174)<td><a href="#" name="15">(3163-3173)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(107-121)<td><a href="#" name="16">(462-467)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(382-387)<td><a href="#" name="17">(3922-3927)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(297-301)<td><a href="#" name="18">(609-613)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(252-261)<td><a href="#" name="19">(509-517)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(223-226)<td><a href="#" name="20">(732-737)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(175-181)<td><a href="#" name="21">(2131-2137)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(90-94)<td><a href="#" name="22">(279-287)</a><td align="center"><font color="#630000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UnsignedIntsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="7"></a>
2 package com.google.common.primitives;
3 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.truth.Truth.assertThat;
4 import com.google.common.annotations.GwtCompatible;
5 import com.google.common.annotations.GwtIncompatible;
6 import com.google.common.collect.testing.Helpers;
7 import com.google.common.testing.NullPointerTester;
8 import java.util.Arrays;
9 import java.util.Comparator;
10 import java.util.List;
11 import java.util.Random;
12 import junit.framework.TestCase;
13 @GwtCompatible(emulated = true)
14 public class UnsignedIntsTest extends TestCase {
15   private static final long[] UNSIGNED_INTS = {</b></font>
16     0L,
17     1L,
18     2L,
19     3L,
20     0x12345678L,
21     0x5a4316b8L,
22     0x6cf78a4bL,
23     0xff1a618bL,
24     0xfffffffdL,
25     0xfffffffeL,
26     0xffffffffL
27   };
28   private static final int LEAST = (int) 0L;
29   private static final int GREATEST = (int) 0xffffffffL;
30   public void testCheckedCast() {
31     for (long value : UNSIGNED_INTS) {
32       assertEquals(value, UnsignedInts.toLong(UnsignedInts.checkedCast(value)));
33     }
34     assertCastFails(1L &lt;&lt; 32);
35     assertCastFails(-1L);
36     assertCastFails(Long.MAX_VALUE);
37 <a name="4"></a>    assertCastFails(Long.MIN_VALUE);
38   }
39   private static void assertCastFails(long value) <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
40     try {
41       UnsignedInts.checkedCast(value);
42       fail("Cast to int should have failed: " + value);
43     } catch (IllegalArgumentException ex) {
44       assertThat(ex.getMessage()).contains(String.valueOf(value));
45     }
46   }</b></font>
47   public void testSaturatedCast() {
48 <a name="11"></a>    for (long value : UNSIGNED_INTS) {
49       assertEquals(value, UnsignedInts.toLong(UnsignedInts.saturatedCast(value)));
50     }
51     <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(GREATEST, UnsignedInts.saturatedCast(1L &lt;&lt; 32));
52     assertEquals(LEAST, UnsignedInts.saturatedCast(-1L));
53     assertEquals(GREATEST, UnsignedInts.saturatedCast(Long.MAX_VALUE));
54     assertEquals(LEAST, UnsignedInts.saturatedCast(Long.MIN_VALUE));
55 <a name="13"></a>  }
56   public void testToLong() {</b></font>
57     <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (long a : UNSIGNED_INTS) {
58       assertEquals(a, UnsignedInts.toLong((int) a));
59     }
60   }
61 <a name="22"></a>
62   public void testCompare() {</b></font>
63     for (long a : UNSIGNED_INTS) {
64       for (long b : UNSIGNED_INTS) <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
65         int cmpAsLongs = Longs.compare(a, b);
66         int cmpAsUInt = UnsignedInts.compare((int) a, (int) b);
67         assertEquals(Integer.signum(cmpAsLongs), Integer.signum(cmpAsUInt));
68       }</b></font>
69     }
70 <a name="6"></a>  }
71   public void testMax_noArgs() {
72     <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
73       UnsignedInts.max();
74       fail();
75     } catch (IllegalArgumentException expected) {
76     }
77 <a name="16"></a>  }
78   public void testMax() {</b></font>
79     <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(LEAST, UnsignedInts.max(LEAST));
80     assertEquals(GREATEST, UnsignedInts.max(GREATEST));
81     assertEquals(
82         (int) 0xff1a618bL,
83         UnsignedInts.max(
84             (int) 8L,
85             (int) 6L,
86             (int) 7L,
87             (int) 0x12345678L,
88             (int) 0x5a4316b8L,
89             (int) 0xff1a618bL,
90             (int) 0L));
91 <a name="5"></a>  }
92   public void testMin_noArgs() {</b></font>
93     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
94       UnsignedInts.min();
95       fail();
96     } catch (IllegalArgumentException expected) {
97     }
98 <a name="10"></a>  }
99   public void testMin() {</b></font>
100     <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(LEAST, UnsignedInts.min(LEAST));
101     assertEquals(GREATEST, UnsignedInts.min(GREATEST));
102     assertEquals(
103         (int) 0L,
104         UnsignedInts.min(
105             (int) 8L,
106             (int) 6L,
107             (int) 7L,
108             (int) 0x12345678L,
109             (int) 0x5a4316b8L,
110             (int) 0xff1a618bL,
111             (int) 0L));
112   }
113   public void testLexicographicalComparator() {
114     List&lt;int[]&gt; ordered =
115         Arrays.asList</b></font>(
116             new int[] {},
117             new int[] {LEAST},
118             new int[] {LEAST, LEAST},
119             new int[] {LEAST, (int) 1L},
120             new int[] {(int) 1L},
121             new int[] {(int) 1L, LEAST},
122             new int[] {GREATEST, (GREATEST - (int) 1L)},
123             new int[] {GREATEST, GREATEST},
124             new int[] {GREATEST, GREATEST, GREATEST});
125     Comparator&lt;int[]&gt; comparator = UnsignedInts.lexicographicalComparator();
126     Helpers.testComparator(comparator, ordered);
127   }
128   public void testSort() {
129     testSort(new int[] {}, new int[] {});
130     testSort(new int[] {2}, new int[] {2});
131     testSort(new int[] {2, 1, 0}, new int[] {0, 1, 2});
132     testSort(new int[] {2, GREATEST, 1, LEAST}, new int[] {LEAST, 1, 2, GREATEST});
133 <a name="15"></a>  }
134   static void testSort(int[] input, int[] expected) {
135     input = <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Arrays.copyOf(input, input.length);
136     UnsignedInts.sort(input);
137     assertTrue(Arrays.equals(expected, input));
138 <a name="21"></a>  }
139   static void testSort(int[] input, int from, int to</b></font>, int[] expected) {
140     input = <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Arrays.copyOf(input, input.length);
141     UnsignedInts.sort(input, from, to);
142     assertTrue(Arrays.equals(expected, input));
143   }
144   public void testSortIndexed() {
145     testSort</b></font>(new int[] {}, 0, 0, new int[] {});
146     testSort(new int[] {2}, 0, 1, new int[] {2});
147     testSort(new int[] {2, 1, 0}, 0, 2, new int[] {1, 2, 0});
148     testSort(new int[] {2, GREATEST, 1, LEAST}, 1, 4, new int[] {2, LEAST, 1, GREATEST});
149   }
150   public void testSortDescending() {
151     testSortDescending(new int[] {}, new int[] {});
152     testSortDescending(new int[] {1}, new int[] {1});
153     testSortDescending(new int[] {1, 2}, new int[] {2, 1});
154     testSortDescending(new int[] {1, 3, 1}, new int[] {3, 1, 1});
155     testSortDescending(
156         new int[] {GREATEST - 1, 1, GREATEST - 2, 2}, new int[] {GREATEST - 1, GREATEST - 2, 2, 1});
157 <a name="14"></a>  }
158   private static void testSortDescending(int[] input, int[] expectedOutput) {
159     input = <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Arrays.copyOf(input, input.length);
160     UnsignedInts.sortDescending(input);
161     assertTrue(Arrays.equals(expectedOutput, input));
162   }
163   private static void testSortDescending(
164       int[] input, int fromIndex, int toIndex</b></font>, int[] expectedOutput) {
165     input = Arrays.copyOf(input, input.length);
166     UnsignedInts.sortDescending(input, fromIndex, toIndex);
167     assertTrue(Arrays.equals(expectedOutput, input));
168   }
169   public void testSortDescendingIndexed() {
170     testSortDescending(new int[] {}, 0, 0, new int[] {});
171     testSortDescending(new int[] {1}, 0, 1, new int[] {1});
172     testSortDescending(new int[] {1, 2}, 0, 2, new int[] {2, 1});
173     testSortDescending(new int[] {1, 3, 1}, 0, 2, new int[] {3, 1, 1});
174     testSortDescending(new int[] {1, 3, 1}, 0, 1, new int[] {1, 3, 1});
175     testSortDescending(
176         new int[] {GREATEST - 1, 1, GREATEST - 2, 2},
177         1,
178         3,
179         new int[] {GREATEST - 1, GREATEST - 2, 1, 2});
180 <a name="20"></a>  }
181   public void testDivide() {
182     for (<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>long a : UNSIGNED_INTS) {
183       for (long b : UNSIGNED_INTS) {
184         try {
185           assertEquals((int) (a / b), UnsignedInts.divide</b></font>((int) a, (int) b));
186           assertFalse(b == 0);
187         } catch (ArithmeticException e) {
188           assertEquals(0, b);
189         }
190       }
191     }
192   }
193   public void testRemainder() {
194     for (long a : UNSIGNED_INTS) {
195       for (long b : UNSIGNED_INTS) {
196         try {
197           assertEquals((int) (a % b), UnsignedInts.remainder((int) a, (int) b));
198           assertFalse(b == 0);
199         } catch (ArithmeticException e) {
200           assertEquals(0, b);
201         }
202       }
203     }
204   }
205   @GwtIncompatible <a name="19"></a>  public void testDivideRemainderEuclideanProperty() {
206     Random r = new Random(0L);
207     for (int i = 0; i &lt; 1000000; i++) <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
208       int dividend = r.nextInt();
209       int divisor = r.nextInt();
210       assertTrue(
211           dividend
212                   - (divisor * UnsignedInts.divide(dividend, divisor)
213                       + UnsignedInts.remainder(dividend, divisor))
214               == 0);
215     }</b></font>
216   }
217   public void testParseInt() {
218     for (long a : UNSIGNED_INTS) {
219       assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a)));
220     }
221   }
222 <a name="9"></a>
223   public void testParseIntFail() {
224     try {
225       UnsignedInts.parseUnsignedInt(<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Long.toString(1L &lt;&lt; 32));
226       fail("Expected NumberFormatException");
227     } catch (NumberFormatException expected) {
228     }
229   }
230   public void testParseIntWithRadix() {</b></font>
231     for (long a : UNSIGNED_INTS) {
232       for (int radix = Character.MIN_RADIX; radix &lt;= Character.MAX_RADIX; radix++) {
233         assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a, radix), radix));
234       }
235     }
236   }
237   public void testParseIntWithRadixLimits() {
238     for (int radix = Character.MIN_RADIX; radix &lt;= Character.MAX_RADIX; radix++) {
239       String maxAsString = Long.toString((1L &lt;&lt; 32) - 1, radix);
240       assertEquals(-1, UnsignedInts.parseUnsignedInt(maxAsString, radix));
241       try {
242 <a name="18"></a>                long overflow = 1L &lt;&lt; 32;
243         String overflowAsString = Long.toString(overflow, radix);
244         <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>UnsignedInts.parseUnsignedInt(overflowAsString, radix);
245         fail();
246       } catch (NumberFormatException expected) {
247       }
248 <a name="12"></a>    }</b></font>
249   }
250   public void testParseIntThrowsExceptionForInvalidRadix() <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
251     try {
252       UnsignedInts.parseUnsignedInt("0", Character.MIN_RADIX - 1);
253       fail();
254 <a name="1"></a>    } catch (NumberFormatException expected) {
255     }</b></font>
256     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
257       UnsignedInts.parseUnsignedInt("0", Character.MAX_RADIX + 1);
258       fail();
259     } catch (NumberFormatException expected) {
260     }
261     try {
262       UnsignedInts.parseUnsignedInt("0", -1);
263       fail();
264     } catch (NumberFormatException expected) {
265     }
266 <a name="3"></a>  }
267   public void t</b></font>estDecodeInt() {
268     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(0xffffffff, UnsignedInts.decode("0xffffffff"));
269     assertEquals(01234567, UnsignedInts.decode("01234567"));     assertEquals(0x12345678, UnsignedInts.decode("#12345678"));
270     assertEquals(76543210, UnsignedInts.decode("76543210"));
271     assertEquals(0x13579135, UnsignedInts.decode("0x13579135"));
272     assertEquals(0x13579135, UnsignedInts.decode("0X13579135"));
273     assertEquals(0, UnsignedInts.decode("0"));
274 <a name="2"></a>  }
275   public void testDecodeIntFails() {</b></font>
276     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
277       UnsignedInts.decode("0xfffffffff");
278       fail();
279     } catch (NumberFormatException expected) {
280     }
281     try {
282       UnsignedInts.decode("-5");
283       fail();
284 <a name="0"></a>    } catch (NumberFormatException expected) {
285     }</b></font>
286     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
287       UnsignedInts.decode("-0x5");
288       fail();
289     } catch (NumberFormatException expected) {
290     }
291     try {
292       UnsignedInts.decode("-05");
293       fail();
294     } catch (NumberFormatException expected) {
295     }
296   }
297   public void </b></font>testToString() {
298     int[] bases = {2, 5, 7, 8, 10, 16};
299     for (long a : UNSIGNED_INTS) {
300       for (int base : bases) {
301         assertEquals(UnsignedInts.toString((int) a, base), Long.toString(a, base));
302       }
303     }
304 <a name="8"></a>  }
305   public void testJoin() {
306     <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("", join());
307     assertEquals("1", join(1));
308     assertEquals("1,2", join(1, 2));
309     assertEquals("4294967295,2147483648", join(-1, Integer.MIN_VALUE));
310 <a name="17"></a>    assertEquals("123", UnsignedInts.join("", 1, 2, 3));
311   }
312   priv</b></font>ate static String join(<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int... values) {
313     return UnsignedInts.join(",", values);
314   }
315   @GwtIncompatible   public void testNulls() {</b></font>
316     new NullPointerTester().testAllPublicStaticMethods(UnsignedInts.class);
317   }
318 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FuturesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.util.concurrent;
2 import static com.google.common.base.Functions.constant;
3 import static com.google.common.base.Functions.identity;
4 import static com.google.common.base.Throwables.propagateIfInstanceOf;
5 import static com.google.common.collect.Iterables.getOnlyElement;
6 import static com.google.common.collect.Lists.newArrayList;
7 import static com.google.common.collect.Sets.intersection;
8 import static com.google.common.truth.Truth.assertThat;
9 import static com.google.common.truth.Truth.assertWithMessage;
10 import static com.google.common.util.concurrent.Futures.allAsList;
11 import static com.google.common.util.concurrent.Futures.catching;
12 import static com.google.common.util.concurrent.Futures.catchingAsync;
13 import static com.google.common.util.concurrent.Futures.getDone;
14 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
15 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
16 import static com.google.common.util.concurrent.Futures.immediateFuture;
17 import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
18 import static com.google.common.util.concurrent.Futures.inCompletionOrder;
19 import static com.google.common.util.concurrent.Futures.lazyTransform;
20 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
21 import static com.google.common.util.concurrent.Futures.scheduleAsync;
22 import static com.google.common.util.concurrent.Futures.submit;
23 import static com.google.common.util.concurrent.Futures.submitAsync;
24 import static com.google.common.util.concurrent.Futures.successfulAsList;
25 import static com.google.common.util.concurrent.Futures.transform;
26 import static com.google.common.util.concurrent.Futures.transformAsync;
27 import static com.google.common.util.concurrent.Futures.whenAllComplete;
28 import static com.google.common.util.concurrent.Futures.whenAllSucceed;
29 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
30 import static com.google.common.util.concurrent.TestPlatform.clearInterrupt;
31 import static com.google.common.util.concurrent.TestPlatform.getDoneFromTimeoutOverload;
32 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
33 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
34 import static com.google.common.util.concurrent.testing.TestingExecutors.noOpScheduledExecutor;
35 import static java.util.Arrays.asList;
36 import static java.util.concurrent.Executors.newSingleThreadExecutor;
37 import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
38 import static java.util.concurrent.TimeUnit.MILLISECONDS;
39 import static java.util.concurrent.TimeUnit.NANOSECONDS;
40 import static java.util.concurrent.TimeUnit.SECONDS;
41 import com.google.common.annotations.GwtCompatible;
42 import com.google.common.annotations.GwtIncompatible;
43 import com.google.common.base.Function;
44 import com.google.common.base.Joiner;
45 import com.google.common.base.Predicate;
46 import com.google.common.collect.ImmutableList;
47 import com.google.common.collect.ImmutableSet;
48 import com.google.common.collect.Iterables;
49 import com.google.common.testing.ClassSanityTester;
50 import com.google.common.testing.GcFinalization;
51 import com.google.common.testing.TestLogHandler;
52 import com.google.errorprone.annotations.CanIgnoreReturnValue;
53 import java.io.FileNotFoundException;
54 import java.io.IOException;
55 import java.lang.ref.WeakReference;
56 import java.util.List;
57 import java.util.Set;
58 import java.util.concurrent.Callable;
59 import java.util.concurrent.CancellationException;
60 import java.util.concurrent.CountDownLatch;
61 import java.util.concurrent.ExecutionException;
62 import java.util.concurrent.Executor;
63 <a name="7"></a>import java.util.concurrent.ExecutorService;
64 import java.util.concurrent.Executors;
65 import java.util.concurrent.Future;
66 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.concurrent.RejectedExecutionException;
67 import java.util.concurrent.ScheduledExecutorService;
68 import java.util.concurrent.TimeUnit;
69 import java.util.concurrent.TimeoutException;
70 import java.util.concurrent.atomic.AtomicBoolean;
71 import java.util.logging.LogRecord;
72 import java.util.logging.Logger;
73 import junit.framework.AssertionFailedError;
74 import junit.framework.TestCase;
75 import org.checkerframework.checker.nullness.qual.Nullable;
76 @GwtCompatible(emulated = true)
77 public class FuturesTest extends TestCase {
78   private static final Logger aggregateFutureLogger =</b></font>
79       Logger.getLogger(AggregateFuture.class.getName());
80   private final TestLogHandler aggregateFutureLogHandler = new TestLogHandler();
81   private static final String DATA1 = "data";
82   private static final String DATA2 = "more data";
83   private static final String DATA3 = "most data";
84   @Override
85   public void setUp() throws Exception {
86     super.setUp();
87     aggregateFutureLogger.addHandler(aggregateFutureLogHandler);
88   }
89   @Override
90   public void tearDown() throws Exception {
91     clearInterrupt();
92     aggregateFutureLogger.removeHandler(aggregateFutureLogHandler);
93     super.tearDown();
94   }
95   public void testImmediateFuture() throws Exception {
96     ListenableFuture&lt;String&gt; future = <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>immediateFuture(DATA1);
97     assertSame(DATA1, getDone(future));
98     assertSame(DATA1, getDoneFromTimeoutOverload(future));
99     assertThat(future.toString()).contains("[status=SUCCESS, result=[" + DATA1 + "]]");
100 <a name="8"></a>  }
101   public void testImmediateVoidFuture() throws Exception {</b></font>
102     ListenableFuture&lt;Void&gt; voidFuture = <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>immediateVoidFuture();
103     assertThat(getDone(voidFuture)).isNull();
104     assertThat(getDoneFromTimeoutOverload(voidFuture)).isNull();
105     assertThat(voidFuture.toString()).contains("[status=SUCCESS, result=[null]]");
106   }
107   public void testImmediate</b></font>FailedFuture() throws Exception {
108     Exception exception = new Exception();
109     ListenableFuture&lt;String&gt; future = immediateFailedFuture(exception);
110     assertThat(future.toString()).endsWith("[status=FAILURE, cause=[" + exception + "]]");
111     try {
112       getDone(future);
113       fail();
114     } catch (ExecutionException expected) {
115       assertSame(exception, expected.getCause());
116     }
117     try {
118       getDoneFromTimeoutOverload(future);
119       fail();
120     } catch (ExecutionException expected) {
121       assertSame(exception, expected.getCause());
122     }
123   }
124   public void testImmediateFailedFuture_cancellationException() throws Exception {
125     CancellationException exception = new CancellationException();
126     ListenableFuture&lt;String&gt; future = immediateFailedFuture(exception);
127     assertFalse(future.isCancelled());
128     assertThat(future.toString()).endsWith("[status=FAILURE, cause=[" + exception + "]]");
129     try {
130       getDone(future);
131       fail();
132     } catch (ExecutionException expected) {
133       assertSame(exception, expected.getCause());
134     }
135     try {
136       getDoneFromTimeoutOverload(future);
137       fail();
138     } catch (ExecutionException expected) {
139       assertSame(exception, expected.getCause());
140     }
141   }
142   public void testImmediateCancelledFutureBasic() throws Exception {
143     ListenableFuture&lt;String&gt; future = CallerClass1.makeImmediateCancelledFuture();
144     assertTrue(future.isCancelled());
145   }
146   @GwtIncompatible
147   public void testImmediateCancelledFutureStack() throws Exception {
148     ListenableFuture&lt;String&gt; future = CallerClass1.makeImmediateCancelledFuture();
149     assertTrue(future.isCancelled());
150     try {
151       CallerClass2.get(future);
152       fail();
153     } catch (CancellationException expected) {
154       List&lt;StackTraceElement&gt; stackTrace = ImmutableList.copyOf(expected.getStackTrace());
155       assertFalse(Iterables.any(stackTrace, hasClassName(CallerClass1.class)));
156       assertTrue(Iterables.any(stackTrace, hasClassName(CallerClass2.class)));
157       assertThat(expected.getCause()).isNull();
158     }
159   }
160   @GwtIncompatible   private static Predicate&lt;StackTraceElement&gt; hasClassName(final Class&lt;?&gt; clazz) {
161     return new Predicate&lt;StackTraceElement&gt;() {
162       @Override
163       public boolean apply(StackTraceElement element) {
164         return element.getClassName().equals(clazz.getName());
165       }
166     };
167   }
168   private static final class CallerClass1 {
169     static ListenableFuture&lt;String&gt; makeImmediateCancelledFuture() {
170       return immediateCancelledFuture();
171     }
172   }
173   private static final class CallerClass2 {
174     @CanIgnoreReturnValue
175     static &lt;V&gt; V get(ListenableFuture&lt;V&gt; future) throws ExecutionException, InterruptedException {
176       return getDone(future);
177     }
178   }
179   private static class MyException extends Exception {}
180   private static class Foo {}
181   private static class FooChild extends Foo {}
182   private static class Bar {}
183   private static class BarChild extends Bar {}
184   public void testTransform_genericsNull() throws Exception {
185     ListenableFuture&lt;?&gt; nullFuture = immediateFuture(null);
186     ListenableFuture&lt;?&gt; transformedFuture = transform(nullFuture, constant(null), directExecutor());
187     assertNull(getDone(transformedFuture));
188   }
189   public void testTransform_genericsHierarchy() throws Exception {
190     ListenableFuture&lt;FooChild&gt; future = immediateFuture(null);
191     final BarChild barChild = new BarChild();
192     Function&lt;Foo, BarChild&gt; function =
193         new Function&lt;Foo, BarChild&gt;() {
194           @Override
195           public BarChild apply(Foo unused) {
196             return barChild;
197           }
198         };
199     Bar bar = getDone(transform(future, function, directExecutor()));
200     assertSame(barChild, bar);
201   }
202 <a name="22"></a>  @AndroidIncompatible
203   @GwtIncompatible   public void testTransform_StackOverflow() throws Exception {
204     <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
205       SettableFuture&lt;Object&gt; root = SettableFuture.create();
206       ListenableFuture&lt;Object&gt; unused = transform(root, identity(), directExecutor());
207       root.set("foo");
208     }</b></font>
209     SettableFuture&lt;Object&gt; root = SettableFuture.create();
210     ListenableFuture&lt;Object&gt; output = root;
211 <a name="6"></a>    for (int i = 0; i &lt; 10000; i++) {
212       output = transform(output, identity(), directExecutor());
213     }
214     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
215       root.set("foo");
216       fail();
217     } catch (StackOverflowError expected) {
218     }
219   }
220   public void testTransform_ErrorAfterCancellation() throws Exception {</b></font>
221     class Transformer implements Function&lt;Object, Object&gt; {
222       ListenableFuture&lt;Object&gt; output;
223       @Override
224       public Object apply(Object input) {
225         output.cancel(false);
226         throw new MyError();
227       }
228     }
229     Transformer transformer = new Transformer();
230     SettableFuture&lt;Object&gt; input = SettableFuture.create();
231     ListenableFuture&lt;Object&gt; output = transform(input, transformer, directExecutor());
232     transformer.output = output;
233     input.set("foo");
234     assertTrue(output.isCancelled());
235   }
236   public void testTransform_ExceptionAfterCancellation() throws Exception {
237     class Transformer implements Function&lt;Object, Object&gt; {
238       ListenableFuture&lt;Object&gt; output;
239       @Override
240       public Object apply(Object input) {
241         output.cancel(false);
242         throw new MyRuntimeException();
243       }
244     }
245     Transformer transformer = new Transformer();
246     SettableFuture&lt;Object&gt; input = SettableFuture.create();
247     ListenableFuture&lt;Object&gt; output = transform(input, transformer, directExecutor());
248     transformer.output = output;
249     input.set("foo");
250     assertTrue(output.isCancelled());
251   }
252   public void testTransform_getThrowsRuntimeException() throws Exception {
253     ListenableFuture&lt;Object&gt; input =
254         UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());
255     ListenableFuture&lt;Object&gt; output = transform(input, identity(), directExecutor());
256     try {
257       getDone(output);
258       fail();
259     } catch (ExecutionException expected) {
260       assertThat(expected.getCause()).isInstanceOf(MyRuntimeException.class);
261     }
262   }
263   public void testTransform_getThrowsError() throws Exception {
264     ListenableFuture&lt;Object&gt; input = UncheckedThrowingFuture.throwingError(new MyError());
265     ListenableFuture&lt;Object&gt; output = transform(input, identity(), directExecutor());
266     try {
267       getDone(output);
268       fail();
269     } catch (ExecutionException expected) {
270       assertThat(expected.getCause()).isInstanceOf(MyError.class);
271     }
272   }
273   public void testTransform_listenerThrowsError() throws Exception {
274     SettableFuture&lt;Object&gt; input = SettableFuture.create();
275     ListenableFuture&lt;Object&gt; output = transform(input, identity(), directExecutor());
276     output.addListener(
277         new Runnable() {
278           @Override
279           public void run() {
280             throw new MyError();
281 <a name="5"></a>          }
282         },
283         directExecutor());
284     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
285       input.set("foo");
286       fail();
287     } catch (MyError expected) {
288     }
289   }
290   public void testTransformAsync_cancelPropagatesToInput() throws Exception {</b></font>
291     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
292     AsyncFunction&lt;Foo, Bar&gt; function =
293         new AsyncFunction&lt;Foo, Bar&gt;() {
294           @Override
295           public ListenableFuture&lt;Bar&gt; apply(Foo unused) {
296 <a name="10"></a>            throw new AssertionFailedError("Unexpeted call to apply.");
297           }
298         };
299     assertTrue(<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>transformAsync(input, function, directExecutor()).cancel(false));
300     assertTrue(input.isCancelled());
301     assertFalse(input.wasInterrupted());
302   }
303   public void testTransformAsync_interruptPropagatesToInput() throws Exception {
304     SettableFuture&lt;Foo&gt; input = SettableFuture.create</b></font>();
305     AsyncFunction&lt;Foo, Bar&gt; function =
306         new AsyncFunction&lt;Foo, Bar&gt;() {
307           @Override
308           public ListenableFuture&lt;Bar&gt; apply(Foo unused) {
309             throw new AssertionFailedError("Unexpeted call to apply.");
310           }
311         };
312     assertTrue(transformAsync(input, function, directExecutor()).cancel(true));
313     assertTrue(input.isCancelled());
314     assertTrue(input.wasInterrupted());
315   }
316   @GwtIncompatible   public void testTransformAsync_interruptPropagatesToTransformingThread() throws Exception {
317     SettableFuture&lt;String&gt; input = SettableFuture.create();
318     final CountDownLatch inFunction = new CountDownLatch(1);
319     final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
320     final CountDownLatch gotException = new CountDownLatch(1);
321     AsyncFunction&lt;String, String&gt; function =
322         new AsyncFunction&lt;String, String&gt;() {
323           @Override
324           public ListenableFuture&lt;String&gt; apply(String s) throws Exception {
325             inFunction.countDown();
326             try {
327               shouldCompleteFunction.await();
328             } catch (InterruptedException expected) {
329               gotException.countDown();
330               throw expected;
331             }
332             return immediateFuture("a");
333           }
334         };
335     ListenableFuture&lt;String&gt; futureResult =
336         transformAsync(input, function, newSingleThreadExecutor());
337     input.set("value");
338     inFunction.await();
339     futureResult.cancel(true);
340     shouldCompleteFunction.countDown();
341     try {
342       futureResult.get();
343       fail();
344     } catch (CancellationException expected) {
345     }
346     assertEquals(1, gotException.getCount());
347   }
348   public void testTransformAsync_cancelPropagatesToAsyncOutput() throws Exception {
349     ListenableFuture&lt;Foo&gt; immediate = immediateFuture(new Foo());
350     final SettableFuture&lt;Bar&gt; secondary = SettableFuture.create();
351     AsyncFunction&lt;Foo, Bar&gt; function =
352         new AsyncFunction&lt;Foo, Bar&gt;() {
353           @Override
354           public ListenableFuture&lt;Bar&gt; apply(Foo unused) {
355 <a name="16"></a>            return secondary;
356           }
357         };
358     assertTrue(<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>transformAsync(immediate, function, directExecutor()).cancel(false));
359     assertTrue(secondary.isCancelled());
360     assertFalse(secondary.wasInterrupted());
361   }
362   public void testTransformAsync_interruptPropagatesToAsyncOutput() throws Exception {</b></font>
363     ListenableFuture&lt;Foo&gt; immediate = immediateFuture(new Foo());
364     final SettableFuture&lt;Bar&gt; secondary = SettableFuture.create();
365     AsyncFunction&lt;Foo, Bar&gt; function =
366         new AsyncFunction&lt;Foo, Bar&gt;() {
367           @Override
368           public ListenableFuture&lt;Bar&gt; apply(Foo unused) {
369             return secondary;
370           }
371         };
372     assertTrue(transformAsync(immediate, function, directExecutor()).cancel(true));
373     assertTrue(secondary.isCancelled());
374     assertTrue(secondary.wasInterrupted());
375   }
376   public void testTransformAsync_inputCancelButNotInterruptPropagatesToOutput() throws Exception {
377     SettableFuture&lt;Foo&gt; f1 = SettableFuture.create();
378     final SettableFuture&lt;Bar&gt; secondary = SettableFuture.create();
379     AsyncFunction&lt;Foo, Bar&gt; function =
380         new AsyncFunction&lt;Foo, Bar&gt;() {
381           @Override
382           public ListenableFuture&lt;Bar&gt; apply(Foo unused) {
383             return secondary;
384           }
385         };
386     ListenableFuture&lt;Bar&gt; f2 = transformAsync(f1, function, directExecutor());
387     f1.cancel(true);
388     assertTrue(f2.isCancelled());
389     assertFalse(((AbstractFuture&lt;?&gt;) f2).wasInterrupted());
390   }
391 <a name="19"></a>  @AndroidIncompatible
392   @GwtIncompatible   public void testTransformAsync_StackOverflow() throws Exception {
393     <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
394       SettableFuture&lt;Object&gt; root = SettableFuture.create();
395       ListenableFuture&lt;Object&gt; unused = transformAsync(root, asyncIdentity(), directExecutor());
396       root.set("foo");
397     }</b></font>
398     SettableFuture&lt;Object&gt; root = SettableFuture.create();
399     ListenableFuture&lt;Object&gt; output = root;
400     for (int i = 0; i &lt; 10000; i++) {
401 <a name="9"></a>      output = transformAsync(output, asyncIdentity(), directExecutor());
402     }
403     try {
404       <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>root.set("foo");
405       fail();
406     } catch (StackOverflowError expected) {
407     }
408   }
409   public void testTransformAsync_ErrorAfterCancellation() throws Exception {</b></font>
410     class Transformer implements AsyncFunction&lt;Object, Object&gt; {
411       ListenableFuture&lt;Object&gt; output;
412       @Override
413       public ListenableFuture&lt;Object&gt; apply(Object input) {
414         output.cancel(false);
415         throw new MyError();
416       }
417     }
418     Transformer transformer = new Transformer();
419     SettableFuture&lt;Object&gt; input = SettableFuture.create();
420     ListenableFuture&lt;Object&gt; output = transformAsync(input, transformer, directExecutor());
421     transformer.output = output;
422     input.set("foo");
423     assertTrue(output.isCancelled());
424   }
425   public void testTransformAsync_ExceptionAfterCancellation() throws Exception {
426     class Transformer implements AsyncFunction&lt;Object, Object&gt; {
427       ListenableFuture&lt;Object&gt; output;
428       @Override
429       public ListenableFuture&lt;Object&gt; apply(Object input) {
430         output.cancel(false);
431         throw new MyRuntimeException();
432       }
433     }
434     Transformer transformer = new Transformer();
435     SettableFuture&lt;Object&gt; input = SettableFuture.create();
436     ListenableFuture&lt;Object&gt; output = transformAsync(input, transformer, directExecutor());
437     transformer.output = output;
438     input.set("foo");
439     assertTrue(output.isCancelled());
440   }
441   public void testTransformAsync_getThrowsRuntimeException() throws Exception {
442     ListenableFuture&lt;Object&gt; input =
443         UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());
444     ListenableFuture&lt;Object&gt; output = transformAsync(input, asyncIdentity(), directExecutor());
445     try {
446       getDone(output);
447       fail();
448     } catch (ExecutionException expected) {
449       assertThat(expected.getCause()).isInstanceOf(MyRuntimeException.class);
450     }
451   }
452   public void testTransformAsync_getThrowsError() throws Exception {
453     ListenableFuture&lt;Object&gt; input = UncheckedThrowingFuture.throwingError(new MyError());
454     ListenableFuture&lt;Object&gt; output = transformAsync(input, asyncIdentity(), directExecutor());
455     try {
456       getDone(output);
457       fail();
458     } catch (ExecutionException expected) {
459       assertThat(expected.getCause()).isInstanceOf(MyError.class);
460     }
461   }
462   public void testTransformAsync_listenerThrowsError() throws Exception {
463     SettableFuture&lt;Object&gt; input = SettableFuture.create();
464     ListenableFuture&lt;Object&gt; output = transformAsync(input, asyncIdentity(), directExecutor());
465     output.addListener(
466         new Runnable() {
467           @Override
468           public void run() {
469             throw new MyError();
470           }
471 <a name="18"></a>        },
472         directExecutor());
473     try {
474       <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>input.set("foo");
475       fail();
476     } catch (MyError expected) {
477     }
478   }</b></font>
479   public void testTransform_rejectionPropagatesToOutput() throws Exception {
480     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
481     Function&lt;Foo, Foo&gt; identity = identity();
482     ListenableFuture&lt;Foo&gt; transformed = transform(input, identity, REJECTING_EXECUTOR);
483     input.set(new Foo());
484     try {
485       getDone(transformed);
486       fail();
487     } catch (ExecutionException expected) {
488       assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
489     }
490   }
491   public void testTransformAsync_rejectionPropagatesToOutput() throws Exception {
492     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
493     AsyncFunction&lt;Foo, Foo&gt; asyncIdentity = asyncIdentity();
494     ListenableFuture&lt;Foo&gt; transformed = transformAsync(input, asyncIdentity, REJECTING_EXECUTOR);
495     input.set(new Foo());
496     try {
497       getDone(transformed);
498       fail();
499     } catch (ExecutionException expected) {
500       assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
501     }
502   }
503   public void testTransformValueRemainsMemoized() throws Exception {
504     class Holder {
505       int value = 2;
506     }
507     final Holder holder = new Holder();
508     Function&lt;Integer, Integer&gt; adder =
509         new Function&lt;Integer, Integer&gt;() {
510           @Override
511           public Integer apply(Integer from) {
512             return from + holder.value;
513           }
514         };
515     assertEquals(6, adder.apply(4).intValue());
516     ListenableFuture&lt;Integer&gt; immediateFuture = immediateFuture(4);
517     Future&lt;Integer&gt; transformedFuture = transform(immediateFuture, adder, directExecutor());
518     assertEquals(6, getDone(transformedFuture).intValue());
519     holder.value = 3;
520     assertEquals(6, getDone(transformedFuture).intValue());
521     assertEquals(7, adder.apply(4).intValue());
522     holder.value = 4;
523     assertEquals(6, getDone(transformedFuture).intValue());
524     assertEquals(8, adder.apply(4).intValue());
525     assertEquals(6, getDoneFromTimeoutOverload(transformedFuture).intValue());
526     assertEquals(8, getDone(transform(immediateFuture, adder, directExecutor())).intValue());
527     assertEquals(
528         8,
529         getDoneFromTimeoutOverload(transform(immediateFuture, adder, directExecutor())).intValue());
530   }
531   static class MyError extends Error {}
532   static class MyRuntimeException extends RuntimeException {}
533   @GwtIncompatible   public void testTransformExceptionRemainsMemoized() throws Throwable {
534     SettableFuture&lt;Integer&gt; exceptionInput = SettableFuture.create();
535     ListenableFuture&lt;Integer&gt; exceptionComposedFuture =
536         transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());
537     exceptionInput.set(0);
538     runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);
539     SettableFuture&lt;Integer&gt; errorInput = SettableFuture.create();
540     ListenableFuture&lt;Integer&gt; errorComposedFuture =
541         transform(errorInput, newOneTimeErrorThrower(), directExecutor());
542     errorInput.set(0);
543     runGetIdempotencyTest(errorComposedFuture, MyError.class);
544     exceptionComposedFuture =
545         transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());
546     runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);
547     runGetIdempotencyTest(
548         transform(errorInput, newOneTimeErrorThrower(), directExecutor()), MyError.class);
549     runGetIdempotencyTest(errorComposedFuture, MyError.class);
550   }
551 <a name="20"></a>
552   @GwtIncompatible   private static void runGetIdempotencyTest(
553       Future&lt;Integer&gt; transformedFuture, <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Class&lt;? extends Throwable&gt; expectedExceptionClass)
554       throws Throwable {
555     for (int i = 0; i &lt; 5; i++) {
556       try {
557         getDone(transformedFuture);
558         fail</b></font>();
559       } catch (ExecutionException expected) {
560         if (!expectedExceptionClass.isInstance(expected.getCause())) {
561           throw expected.getCause();
562         }
563       }
564     }
565   }
566   @GwtIncompatible   private static Function&lt;Integer, Integer&gt; newOneTimeExceptionThrower() {
567     return new Function&lt;Integer, Integer&gt;() {
568       int calls = 0;
569       @Override
570       public Integer apply(Integer from) {
571         if (++calls &gt; 1) {
572           fail();
573         }
574         throw new MyRuntimeException();
575       }
576     };
577   }
578   @GwtIncompatible   private static Function&lt;Integer, Integer&gt; newOneTimeErrorThrower() {
579     return new Function&lt;Integer, Integer&gt;() {
580       int calls = 0;
581       @Override
582       public Integer apply(Integer from) {
583         if (++calls &gt; 1) {
584           fail();
585         }
586         throw new MyError();
587       }
588     };
589   }
590   static class ExecutorSpy implements Executor {
591     Executor delegate;
592     boolean wasExecuted;
593     public ExecutorSpy(Executor delegate) {
594       this.delegate = delegate;
595     }
596     @Override
597     public void execute(Runnable command) {
598       delegate.execute(command);
599       wasExecuted = true;
600     }
601   }
602   public void testTransform_Executor() throws Exception {
603     Object value = new Object();
604     ExecutorSpy spy = new ExecutorSpy(directExecutor());
605     assertFalse(spy.wasExecuted);
606     ListenableFuture&lt;Object&gt; future = transform(immediateFuture(value), identity(), spy);
607     assertSame(value, getDone(future));
608     assertTrue(spy.wasExecuted);
609   }
610   @GwtIncompatible   public void testTransformAsync_functionToString() throws Exception {
611     final CountDownLatch functionCalled = new CountDownLatch(1);
612     final CountDownLatch functionBlocking = new CountDownLatch(1);
613     AsyncFunction&lt;Object, Object&gt; function =
614         tagged(
615             "Called my toString",
616             new AsyncFunction&lt;Object, Object&gt;() {
617               @Override
618               public ListenableFuture&lt;Object&gt; apply(Object input) throws Exception {
619                 functionCalled.countDown();
620                 functionBlocking.await();
621                 return immediateFuture(null);
622               }
623             });
624     ExecutorService executor = Executors.newSingleThreadExecutor();
625     try {
626       ListenableFuture&lt;?&gt; output =
627           Futures.transformAsync(immediateFuture(null), function, executor);
628       functionCalled.await();
629       assertThat(output.toString()).contains(function.toString());
630     } finally {
631       functionBlocking.countDown();
632       executor.shutdown();
633     }
634   }
635   @GwtIncompatible   public void testLazyTransform() throws Exception {
636     FunctionSpy&lt;Object, String&gt; spy = new FunctionSpy&lt;&gt;(constant("bar"));
637     Future&lt;String&gt; input = immediateFuture("foo");
638     Future&lt;String&gt; transformed = lazyTransform(input, spy);
639     spy.verifyCallCount(0);
640     assertEquals("bar", getDone(transformed));
641     spy.verifyCallCount(1);
642     assertEquals("bar", getDone(transformed));
643     spy.verifyCallCount(2);
644   }
645   @GwtIncompatible   public void testLazyTransform_exception() throws Exception {
646     final RuntimeException exception = new RuntimeException("deliberate");
647     Function&lt;Integer, String&gt; function =
648         new Function&lt;Integer, String&gt;() {
649           @Override
650           public String apply(Integer input) {
651             throw exception;
652           }
653         };
654     Future&lt;String&gt; transformed = lazyTransform(immediateFuture(1), function);
655     try {
656       getDone(transformed);
657       fail();
658     } catch (ExecutionException expected) {
659       assertSame(exception, expected.getCause());
660     }
661     try {
662       getDoneFromTimeoutOverload(transformed);
663       fail();
664     } catch (ExecutionException expected) {
665       assertSame(exception, expected.getCause());
666     }
667   }
668   private static class FunctionSpy&lt;I, O&gt; implements Function&lt;I, O&gt; {
669     private int applyCount;
670     private final Function&lt;I, O&gt; delegate;
671     public FunctionSpy(Function&lt;I, O&gt; delegate) {
672       this.delegate = delegate;
673     }
674     @Override
675     public O apply(I input) {
676       applyCount++;
677       return delegate.apply(input);
678     }
679     void verifyCallCount(int expected) {
680       assertThat(applyCount).isEqualTo(expected);
681     }
682   }
683   private static &lt;X extends Throwable, V&gt; Function&lt;X, V&gt; unexpectedFunction() {
684     return new Function&lt;X, V&gt;() {
685       @Override
686       public V apply(X t) {
687         throw newAssertionError("Unexpected fallback", t);
688       }
689     };
690   }
691   private static class AsyncFunctionSpy&lt;X extends Throwable, V&gt; implements AsyncFunction&lt;X, V&gt; {
692     private int count;
693     private final AsyncFunction&lt;X, V&gt; delegate;
694     public AsyncFunctionSpy(AsyncFunction&lt;X, V&gt; delegate) {
695       this.delegate = delegate;
696     }
697     @Override
698     public final ListenableFuture&lt;V&gt; apply(X t) throws Exception {
699       count++;
700       return delegate.apply(t);
701     }
702     void verifyCallCount(int expected) {
703       assertThat(count).isEqualTo(expected);
704     }
705   }
706   private static &lt;I, O&gt; FunctionSpy&lt;I, O&gt; spy(Function&lt;I, O&gt; delegate) {
707     return new FunctionSpy&lt;&gt;(delegate);
708   }
709   private static &lt;X extends Throwable, V&gt; AsyncFunctionSpy&lt;X, V&gt; spy(AsyncFunction&lt;X, V&gt; delegate) {
710     return new AsyncFunctionSpy&lt;&gt;(delegate);
711   }
712   private static &lt;X extends Throwable, V&gt; AsyncFunction&lt;X, V&gt; unexpectedAsyncFunction() {
713     return new AsyncFunction&lt;X, V&gt;() {
714       @Override
715       public ListenableFuture&lt;V&gt; apply(X t) {
716         throw newAssertionError("Unexpected fallback", t);
717       }
718     };
719   }
720   private static AssertionError newAssertionError(String message, Throwable cause) {
721     AssertionError e = new AssertionError(message);
722     e.initCause(cause);
723     return e;
724   }
725   public void testCatchingAsync_inputDoesNotRaiseException() throws Exception {
726     AsyncFunction&lt;Throwable, Integer&gt; fallback = unexpectedAsyncFunction();
727     ListenableFuture&lt;Integer&gt; originalFuture = immediateFuture(7);
728     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
729         catchingAsync(originalFuture, Throwable.class, fallback, directExecutor());
730     assertEquals(7, getDone(faultTolerantFuture).intValue());
731   }
732   public void testCatchingAsync_inputRaisesException() throws Exception {
733     final RuntimeException raisedException = new RuntimeException();
734     AsyncFunctionSpy&lt;Throwable, Integer&gt; fallback =
735         spy(
736             new AsyncFunction&lt;Throwable, Integer&gt;() {
737               @Override
738               public ListenableFuture&lt;Integer&gt; apply(Throwable t) throws Exception {
739                 assertThat(t).isSameInstanceAs(raisedException);
740                 return immediateFuture(20);
741               }
742             });
743     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(raisedException);
744     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
745         catchingAsync(failingFuture, Throwable.class, fallback, directExecutor());
746     assertEquals(20, getDone(faultTolerantFuture).intValue());
747     fallback.verifyCallCount(1);
748   }
749   @GwtIncompatible   public void testCatchingAsync_inputCancelledWithoutFallback() throws Exception {
750     AsyncFunction&lt;Throwable, Integer&gt; fallback = unexpectedAsyncFunction();
751     ListenableFuture&lt;Integer&gt; originalFuture = immediateCancelledFuture();
752     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
753         catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
754     assertTrue(faultTolerantFuture.isCancelled());
755   }
756   public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {
757     RuntimeException expectedException = new RuntimeException();
758     runExpectedExceptionCatchingAsyncTest(expectedException, false);
759   }
760   public void testCatchingAsync_fallbackGeneratesCheckedException() throws Exception {
761     Exception expectedException = new Exception() {};
762     runExpectedExceptionCatchingAsyncTest(expectedException, false);
763   }
764   public void testCatchingAsync_fallbackGeneratesError() throws Exception {
765     final Error error = new Error("deliberate");
766     AsyncFunction&lt;Throwable, Integer&gt; fallback =
767         new AsyncFunction&lt;Throwable, Integer&gt;() {
768           @Override
769           public ListenableFuture&lt;Integer&gt; apply(Throwable t) throws Exception {
770             throw error;
771           }
772         };
773     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(new RuntimeException());
774     try {
775       getDone(catchingAsync(failingFuture, Throwable.class, fallback, directExecutor()));
776       fail();
777     } catch (ExecutionException expected) {
778       assertSame(error, expected.getCause());
779     }
780   }
781   public void testCatchingAsync_fallbackReturnsRuntimeException() throws Exception {
782     RuntimeException expectedException = new RuntimeException();
783     runExpectedExceptionCatchingAsyncTest(expectedException, true);
784   }
785   public void testCatchingAsync_fallbackReturnsCheckedException() throws Exception {
786     Exception expectedException = new Exception() {};
787     runExpectedExceptionCatchingAsyncTest(expectedException, true);
788   }
789   private void runExpectedExceptionCatchingAsyncTest(
790       final Exception expectedException, final boolean wrapInFuture) throws Exception {
791     AsyncFunctionSpy&lt;Throwable, Integer&gt; fallback =
792         spy(
793             new AsyncFunction&lt;Throwable, Integer&gt;() {
794               @Override
795               public ListenableFuture&lt;Integer&gt; apply(Throwable t) throws Exception {
796                 if (!wrapInFuture) {
797                   throw expectedException;
798                 } else {
799                   return immediateFailedFuture(expectedException);
800                 }
801               }
802             });
803     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(new RuntimeException());
804     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
805         catchingAsync(failingFuture, Throwable.class, fallback, directExecutor());
806     try {
807       getDone(faultTolerantFuture);
808       fail();
809     } catch (ExecutionException expected) {
810       assertSame(expectedException, expected.getCause());
811     }
812     fallback.verifyCallCount(1);
813   }
814   public void testCatchingAsync_fallbackNotReady() throws Exception {
815     ListenableFuture&lt;Integer&gt; primary = immediateFailedFuture(new Exception());
816     final SettableFuture&lt;Integer&gt; secondary = SettableFuture.create();
817     AsyncFunction&lt;Throwable, Integer&gt; fallback =
818         new AsyncFunction&lt;Throwable, Integer&gt;() {
819           @Override
820           public ListenableFuture&lt;Integer&gt; apply(Throwable t) {
821             return secondary;
822           }
823         };
824     ListenableFuture&lt;Integer&gt; derived =
825         catchingAsync(primary, Throwable.class, fallback, directExecutor());
826     secondary.set(1);
827     assertEquals(1, (int) getDone(derived));
828   }
829   public void testCatchingAsync_resultInterruptedBeforeFallback() throws Exception {
830     SettableFuture&lt;Integer&gt; primary = SettableFuture.create();
831     AsyncFunction&lt;Throwable, Integer&gt; fallback = unexpectedAsyncFunction();
832     ListenableFuture&lt;Integer&gt; derived =
833         catchingAsync(primary, Throwable.class, fallback, directExecutor());
834     derived.cancel(true);
835     assertTrue(primary.isCancelled());
836     assertTrue(primary.wasInterrupted());
837   }
838   public void testCatchingAsync_resultCancelledBeforeFallback() throws Exception {
839     SettableFuture&lt;Integer&gt; primary = SettableFuture.create();
840     AsyncFunction&lt;Throwable, Integer&gt; fallback = unexpectedAsyncFunction();
841     ListenableFuture&lt;Integer&gt; derived =
842         catchingAsync(primary, Throwable.class, fallback, directExecutor());
843     derived.cancel(false);
844     assertTrue(primary.isCancelled());
845     assertFalse(primary.wasInterrupted());
846   }
847   @GwtIncompatible   @SuppressWarnings("unchecked")
848   public void testCatchingAsync_resultCancelledAfterFallback() throws Exception {
849     final SettableFuture&lt;Integer&gt; secondary = SettableFuture.create();
850     final RuntimeException raisedException = new RuntimeException();
851     AsyncFunctionSpy&lt;Throwable, Integer&gt; fallback =
852         spy(
853             new AsyncFunction&lt;Throwable, Integer&gt;() {
854               @Override
855               public ListenableFuture&lt;Integer&gt; apply(Throwable t) throws Exception {
856                 assertThat(t).isSameInstanceAs(raisedException);
857                 return secondary;
858               }
859             });
860     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(raisedException);
861     ListenableFuture&lt;Integer&gt; derived =
862         catchingAsync(failingFuture, Throwable.class, fallback, directExecutor());
863     derived.cancel(false);
864     assertTrue(secondary.isCancelled());
865     assertFalse(secondary.wasInterrupted());
866     fallback.verifyCallCount(1);
867   }
868   public void testCatchingAsync_nullInsteadOfFuture() throws Exception {
869     ListenableFuture&lt;Integer&gt; inputFuture = immediateFailedFuture(new Exception());
870     ListenableFuture&lt;?&gt; chainedFuture =
871         catchingAsync(
872             inputFuture,
873             Throwable.class,
874             new AsyncFunction&lt;Throwable, Integer&gt;() {
875               @Override
876               @SuppressWarnings("AsyncFunctionReturnsNull")
877               public ListenableFuture&lt;Integer&gt; apply(Throwable t) {
878                 return null;
879               }
880             },
881             directExecutor());
882     try {
883       getDone(chainedFuture);
884       fail();
885     } catch (ExecutionException expected) {
886       NullPointerException cause = (NullPointerException) expected.getCause();
887       assertThat(cause)
888           .hasMessageThat()
889           .contains(
890               "AsyncFunction.apply returned null instead of a Future. "
891                   + "Did you mean to return immediateFuture(null)?");
892     }
893   }
894   @GwtIncompatible   public void testCatchingAsync_interruptPropagatesToTransformingThread() throws Exception {
895     SettableFuture&lt;String&gt; input = SettableFuture.create();
896     final CountDownLatch inFunction = new CountDownLatch(1);
897     final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
898     final CountDownLatch gotException = new CountDownLatch(1);
899     AsyncFunction&lt;Throwable, String&gt; function =
900         new AsyncFunction&lt;Throwable, String&gt;() {
901           @Override
902           public ListenableFuture&lt;String&gt; apply(Throwable t) throws Exception {
903             inFunction.countDown();
904             try {
905               shouldCompleteFunction.await();
906             } catch (InterruptedException expected) {
907               gotException.countDown();
908               throw expected;
909             }
910             return immediateFuture("a");
911           }
912         };
913     ListenableFuture&lt;String&gt; futureResult =
914         catchingAsync(input, Exception.class, function, newSingleThreadExecutor());
915     input.setException(new Exception());
916     inFunction.await();
917     futureResult.cancel(true);
918     shouldCompleteFunction.countDown();
919     try {
920       futureResult.get();
921       fail();
922     } catch (CancellationException expected) {
923     }
924     assertEquals(1, gotException.getCount());
925   }
926   @GwtIncompatible   public void testCatchingAsync_functionToString() throws Exception {
927     final CountDownLatch functionCalled = new CountDownLatch(1);
928     final CountDownLatch functionBlocking = new CountDownLatch(1);
929     AsyncFunction&lt;Object, Object&gt; function =
930         tagged(
931             "Called my toString",
932             new AsyncFunction&lt;Object, Object&gt;() {
933               @Override
934               public ListenableFuture&lt;Object&gt; apply(Object input) throws Exception {
935                 functionCalled.countDown();
936                 functionBlocking.await();
937                 return immediateFuture(null);
938               }
939             });
940     ExecutorService executor = Executors.newSingleThreadExecutor();
941     try {
942       ListenableFuture&lt;?&gt; output =
943           Futures.catchingAsync(
944               immediateFailedFuture(new RuntimeException()), Throwable.class, function, executor);
945       functionCalled.await();
946       assertThat(output.toString()).contains(function.toString());
947     } finally {
948       functionBlocking.countDown();
949       executor.shutdown();
950     }
951   }
952   public void testCatchingAsync_futureToString() throws Exception {
953     final SettableFuture&lt;Object&gt; toReturn = SettableFuture.create();
954     AsyncFunction&lt;Object, Object&gt; function =
955         tagged(
956             "Called my toString",
957             new AsyncFunction&lt;Object, Object&gt;() {
958               @Override
959               public ListenableFuture&lt;Object&gt; apply(Object input) throws Exception {
960                 return toReturn;
961               }
962             });
963     ListenableFuture&lt;?&gt; output =
964         Futures.catchingAsync(
965             immediateFailedFuture(new RuntimeException()),
966             Throwable.class,
967             function,
968             directExecutor());
969     assertThat(output.toString()).contains(toReturn.toString());
970   }
971   public void testCatching_inputDoesNotRaiseException() throws Exception {
972     Function&lt;Throwable, Integer&gt; fallback = unexpectedFunction();
973     ListenableFuture&lt;Integer&gt; originalFuture = immediateFuture(7);
974     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
975         catching(originalFuture, Throwable.class, fallback, directExecutor());
976     assertEquals(7, getDone(faultTolerantFuture).intValue());
977   }
978   public void testCatching_inputRaisesException() throws Exception {
979     final RuntimeException raisedException = new RuntimeException();
980     FunctionSpy&lt;Throwable, Integer&gt; fallback =
981         spy(
982             new Function&lt;Throwable, Integer&gt;() {
983               @Override
984               public Integer apply(Throwable t) {
985                 assertThat(t).isSameInstanceAs(raisedException);
986                 return 20;
987               }
988             });
989     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(raisedException);
990     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
991         catching(failingFuture, Throwable.class, fallback, directExecutor());
992     assertEquals(20, getDone(faultTolerantFuture).intValue());
993     fallback.verifyCallCount(1);
994   }
995   @GwtIncompatible   public void testCatching_inputCancelledWithoutFallback() throws Exception {
996     Function&lt;IOException, Integer&gt; fallback = unexpectedFunction();
997     ListenableFuture&lt;Integer&gt; originalFuture = immediateCancelledFuture();
998     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
999         catching(originalFuture, IOException.class, fallback, directExecutor());
1000     assertTrue(faultTolerantFuture.isCancelled());
1001   }
1002   public void testCatching_fallbackGeneratesRuntimeException() throws Exception {
1003     RuntimeException expectedException = new RuntimeException();
1004     runExpectedExceptionCatchingTest(expectedException);
1005   }
1006   public void testCatching_fallbackGeneratesError() throws Exception {
1007     final Error error = new Error("deliberate");
1008     Function&lt;Throwable, Integer&gt; fallback =
1009         new Function&lt;Throwable, Integer&gt;() {
1010           @Override
1011           public Integer apply(Throwable t) {
1012             throw error;
1013           }
1014         };
1015     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(new RuntimeException());
1016     try {
1017       getDone(catching(failingFuture, Throwable.class, fallback, directExecutor()));
1018       fail();
1019     } catch (ExecutionException expected) {
1020       assertSame(error, expected.getCause());
1021     }
1022   }
1023   private void runExpectedExceptionCatchingTest(final RuntimeException expectedException)
1024       throws Exception {
1025     FunctionSpy&lt;Throwable, Integer&gt; fallback =
1026         spy(
1027             new Function&lt;Throwable, Integer&gt;() {
1028               @Override
1029               public Integer apply(Throwable t) {
1030                 throw expectedException;
1031               }
1032             });
1033     ListenableFuture&lt;Integer&gt; failingFuture = immediateFailedFuture(new RuntimeException());
1034     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1035         catching(failingFuture, Throwable.class, fallback, directExecutor());
1036     try {
1037       getDone(faultTolerantFuture);
1038       fail();
1039     } catch (ExecutionException expected) {
1040       assertSame(expectedException, expected.getCause());
1041     }
1042     fallback.verifyCallCount(1);
1043   }
1044   public void testCatching_resultInterruptedBeforeFallback() throws Exception {
1045     SettableFuture&lt;Integer&gt; primary = SettableFuture.create();
1046     Function&lt;Throwable, Integer&gt; fallback = unexpectedFunction();
1047     ListenableFuture&lt;Integer&gt; derived =
1048         catching(primary, Throwable.class, fallback, directExecutor());
1049     derived.cancel(true);
1050     assertTrue(primary.isCancelled());
1051     assertTrue(primary.wasInterrupted());
1052   }
1053   public void testCatching_resultCancelledBeforeFallback() throws Exception {
1054     SettableFuture&lt;Integer&gt; primary = SettableFuture.create();
1055     Function&lt;Throwable, Integer&gt; fallback = unexpectedFunction();
1056     ListenableFuture&lt;Integer&gt; derived =
1057         catching(primary, Throwable.class, fallback, directExecutor());
1058     derived.cancel(false);
1059     assertTrue(primary.isCancelled());
1060     assertFalse(primary.wasInterrupted());
1061   }
1062   public void testCatching_Throwable() throws Exception {
1063     Function&lt;Throwable, Integer&gt; fallback = functionReturningOne();
1064     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new IOException());
1065     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1066         catching(originalFuture, Throwable.class, fallback, directExecutor());
1067     assertEquals(1, (int) getDone(faultTolerantFuture));
1068   }
1069   @GwtIncompatible   public void testCatching_customTypeMatch() throws Exception {
1070     Function&lt;IOException, Integer&gt; fallback = functionReturningOne();
1071     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new FileNotFoundException());
1072     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1073         catching(originalFuture, IOException.class, fallback, directExecutor());
1074     assertEquals(1, (int) getDone(faultTolerantFuture));
1075   }
1076   @GwtIncompatible   public void testCatching_customTypeNoMatch() throws Exception {
1077     Function&lt;IOException, Integer&gt; fallback = functionReturningOne();
1078     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new RuntimeException());
1079     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1080         catching(originalFuture, IOException.class, fallback, directExecutor());
1081     try {
1082       getDone(faultTolerantFuture);
1083       fail();
1084     } catch (ExecutionException expected) {
1085       assertThat(expected.getCause()).isInstanceOf(RuntimeException.class);
1086     }
1087   }
1088   @GwtIncompatible   public void testCatching_StackOverflow() throws Exception {
1089     {
1090       SettableFuture&lt;Object&gt; root = SettableFuture.create();
1091       ListenableFuture&lt;Object&gt; unused =
1092           catching(root, MyException.class, identity(), directExecutor());
1093       root.setException(new MyException());
1094     }
1095     SettableFuture&lt;Object&gt; root = SettableFuture.create();
1096     ListenableFuture&lt;Object&gt; output = root;
1097     for (int i = 0; i &lt; 10000; i++) {
1098       output = catching(output, MyException.class, identity(), directExecutor());
1099     }
1100     try {
1101       root.setException(new MyException());
1102       fail();
1103     } catch (StackOverflowError expected) {
1104     }
1105   }
1106   public void testCatching_ErrorAfterCancellation() throws Exception {
1107     class Fallback implements Function&lt;Throwable, Object&gt; {
1108       ListenableFuture&lt;Object&gt; output;
1109       @Override
1110       public Object apply(Throwable input) {
1111         output.cancel(false);
1112         throw new MyError();
1113       }
1114     }
1115     Fallback fallback = new Fallback();
1116     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1117     ListenableFuture&lt;Object&gt; output = catching(input, Throwable.class, fallback, directExecutor());
1118     fallback.output = output;
1119     input.setException(new MyException());
1120     assertTrue(output.isCancelled());
1121   }
1122   public void testCatching_ExceptionAfterCancellation() throws Exception {
1123     class Fallback implements Function&lt;Throwable, Object&gt; {
1124       ListenableFuture&lt;Object&gt; output;
1125       @Override
1126       public Object apply(Throwable input) {
1127         output.cancel(false);
1128         throw new MyRuntimeException();
1129       }
1130     }
1131     Fallback fallback = new Fallback();
1132     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1133     ListenableFuture&lt;Object&gt; output = catching(input, Throwable.class, fallback, directExecutor());
1134     fallback.output = output;
1135     input.setException(new MyException());
1136     assertTrue(output.isCancelled());
1137   }
1138   public void testCatching_getThrowsRuntimeException() throws Exception {
1139     ListenableFuture&lt;Object&gt; input =
1140         UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());
1141     ListenableFuture&lt;Object&gt; output =
1142         catching(input, Throwable.class, identity(), directExecutor());
1143     assertThat(getDone(output)).isInstanceOf(MyRuntimeException.class);
1144   }
1145   public void testCatching_getThrowsError() throws Exception {
1146     ListenableFuture&lt;Object&gt; input = UncheckedThrowingFuture.throwingError(new MyError());
1147     ListenableFuture&lt;Object&gt; output =
1148         catching(input, Throwable.class, identity(), directExecutor());
1149     assertThat(getDone(output)).isInstanceOf(MyError.class);
1150   }
1151   public void testCatching_listenerThrowsError() throws Exception {
1152     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1153     ListenableFuture&lt;Object&gt; output =
1154         catching(input, Throwable.class, identity(), directExecutor());
1155     output.addListener(
1156         new Runnable() {
1157           @Override
1158           public void run() {
1159             throw new MyError();
1160           }
1161         },
1162         directExecutor());
1163     try {
1164       input.setException(new MyException());
1165       fail();
1166     } catch (MyError expected) {
1167     }
1168   }
1169   public void testCatchingAsync_Throwable() throws Exception {
1170     AsyncFunction&lt;Throwable, Integer&gt; fallback = asyncFunctionReturningOne();
1171     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new IOException());
1172     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1173         catchingAsync(originalFuture, Throwable.class, fallback, directExecutor());
1174     assertEquals(1, (int) getDone(faultTolerantFuture));
1175   }
1176   @GwtIncompatible   public void testCatchingAsync_customTypeMatch() throws Exception {
1177     AsyncFunction&lt;IOException, Integer&gt; fallback = asyncFunctionReturningOne();
1178     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new FileNotFoundException());
1179     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1180         catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
1181     assertEquals(1, (int) getDone(faultTolerantFuture));
1182   }
1183   @GwtIncompatible   public void testCatchingAsync_customTypeNoMatch() throws Exception {
1184     AsyncFunction&lt;IOException, Integer&gt; fallback = asyncFunctionReturningOne();
1185     ListenableFuture&lt;Integer&gt; originalFuture = immediateFailedFuture(new RuntimeException());
1186     ListenableFuture&lt;Integer&gt; faultTolerantFuture =
1187         catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
1188     try {
1189       getDone(faultTolerantFuture);
1190       fail();
1191     } catch (ExecutionException expected) {
1192       assertThat(expected.getCause()).isInstanceOf(RuntimeException.class);
1193     }
1194   }
1195   @GwtIncompatible   public void testCatchingAsync_StackOverflow() throws Exception {
1196     {
1197       SettableFuture&lt;Object&gt; root = SettableFuture.create();
1198       ListenableFuture&lt;Object&gt; unused =
1199           catchingAsync(root, MyException.class, asyncIdentity(), directExecutor());
1200       root.setException(new MyException());
1201     }
1202     SettableFuture&lt;Object&gt; root = SettableFuture.create();
1203     ListenableFuture&lt;Object&gt; output = root;
1204     for (int i = 0; i &lt; 10000; i++) {
1205       output = catchingAsync(output, MyException.class, asyncIdentity(), directExecutor());
1206     }
1207     try {
1208       root.setException(new MyException());
1209       fail();
1210     } catch (StackOverflowError expected) {
1211     }
1212   }
1213   public void testCatchingAsync_ErrorAfterCancellation() throws Exception {
1214     class Fallback implements AsyncFunction&lt;Throwable, Object&gt; {
1215       ListenableFuture&lt;Object&gt; output;
1216       @Override
1217       public ListenableFuture&lt;Object&gt; apply(Throwable input) {
1218         output.cancel(false);
1219         throw new MyError();
1220       }
1221     }
1222     Fallback fallback = new Fallback();
1223     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1224     ListenableFuture&lt;Object&gt; output =
1225         catchingAsync(input, Throwable.class, fallback, directExecutor());
1226     fallback.output = output;
1227     input.setException(new MyException());
1228     assertTrue(output.isCancelled());
1229   }
1230   public void testCatchingAsync_ExceptionAfterCancellation() throws Exception {
1231     class Fallback implements AsyncFunction&lt;Throwable, Object&gt; {
1232       ListenableFuture&lt;Object&gt; output;
1233       @Override
1234       public ListenableFuture&lt;Object&gt; apply(Throwable input) {
1235         output.cancel(false);
1236         throw new MyRuntimeException();
1237       }
1238     }
1239     Fallback fallback = new Fallback();
1240     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1241     ListenableFuture&lt;Object&gt; output =
1242         catchingAsync(input, Throwable.class, fallback, directExecutor());
1243     fallback.output = output;
1244     input.setException(new MyException());
1245     assertTrue(output.isCancelled());
1246   }
1247   public void testCatchingAsync_getThrowsRuntimeException() throws Exception {
1248     ListenableFuture&lt;Object&gt; input =
1249         UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());
1250     ListenableFuture&lt;Object&gt; output =
1251         catchingAsync(input, Throwable.class, asyncIdentity(), directExecutor());
1252     assertThat(getDone(output)).isInstanceOf(MyRuntimeException.class);
1253   }
1254   public void testCatchingAsync_getThrowsError() throws Exception {
1255     ListenableFuture&lt;Object&gt; input = UncheckedThrowingFuture.throwingError(new MyError());
1256     ListenableFuture&lt;Object&gt; output =
1257         catchingAsync(input, Throwable.class, asyncIdentity(), directExecutor());
1258     assertThat(getDone(output)).isInstanceOf(MyError.class);
1259   }
1260   public void testCatchingAsync_listenerThrowsError() throws Exception {
1261     SettableFuture&lt;Object&gt; input = SettableFuture.create();
1262     ListenableFuture&lt;Object&gt; output =
1263         catchingAsync(input, Throwable.class, asyncIdentity(), directExecutor());
1264     output.addListener(
1265         new Runnable() {
1266           @Override
1267           public void run() {
1268             throw new MyError();
1269           }
1270         },
1271         directExecutor());
1272     try {
1273       input.setException(new MyException());
1274       fail();
1275     } catch (MyError expected) {
1276     }
1277   }
1278   public void testCatching_rejectionPropagatesToOutput() throws Exception {
1279     SettableFuture&lt;String&gt; input = SettableFuture.create();
1280     ListenableFuture&lt;String&gt; transformed =
1281         catching(input, Throwable.class, constant("foo"), REJECTING_EXECUTOR);
1282     input.setException(new Exception());
1283     try {
1284       getDone(transformed);
1285       fail();
1286     } catch (ExecutionException expected) {
1287       assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
1288     }
1289   }
1290   public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {
1291     SettableFuture&lt;String&gt; input = SettableFuture.create();
1292     ListenableFuture&lt;String&gt; transformed =
1293         catchingAsync(
1294             input,
1295             Throwable.class,
1296             constantAsyncFunction(immediateFuture("foo")),
1297             REJECTING_EXECUTOR);
1298     input.setException(new Exception());
1299     try {
1300       getDone(transformed);
1301       fail();
1302     } catch (ExecutionException expected) {
1303       assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
1304     }
1305   }
1306   private &lt;X extends Throwable&gt; Function&lt;X, Integer&gt; functionReturningOne() {
1307     return new Function&lt;X, Integer&gt;() {
1308       @Override
1309       public Integer apply(X t) {
1310         return 1;
1311       }
1312     };
1313   }
1314   private &lt;X extends Throwable&gt; AsyncFunction&lt;X, Integer&gt; asyncFunctionReturningOne() {
1315     return new AsyncFunction&lt;X, Integer&gt;() {
1316       @Override
1317       public ListenableFuture&lt;Integer&gt; apply(X t) {
1318         return immediateFuture(1);
1319       }
1320     };
1321   }
1322   private static &lt;I, O&gt; AsyncFunction&lt;I, O&gt; constantAsyncFunction(
1323       final ListenableFuture&lt;O&gt; output) {
1324     return new AsyncFunction&lt;I, O&gt;() {
1325       @Override
1326       public ListenableFuture&lt;O&gt; apply(I input) {
1327         return output;
1328       }
1329     };
1330   }
1331   public void testTransformAsync_genericsWildcard_AsyncFunction() throws Exception {
1332     ListenableFuture&lt;?&gt; nullFuture = immediateFuture(null);
1333     ListenableFuture&lt;?&gt; chainedFuture =
1334         transformAsync(nullFuture, constantAsyncFunction(nullFuture), directExecutor());
1335     assertNull(getDone(chainedFuture));
1336   }
1337   public void testTransformAsync_genericsHierarchy_AsyncFunction() throws Exception {
1338     ListenableFuture&lt;FooChild&gt; future = immediateFuture(null);
1339     final BarChild barChild = new BarChild();
1340     AsyncFunction&lt;Foo, BarChild&gt; function =
1341         new AsyncFunction&lt;Foo, BarChild&gt;() {
1342           @Override
1343           public AbstractFuture&lt;BarChild&gt; apply(Foo unused) {
1344             AbstractFuture&lt;BarChild&gt; future = new AbstractFuture&lt;BarChild&gt;() {};
1345             future.set(barChild);
1346             return future;
1347           }
1348         };
1349     Bar bar = getDone(transformAsync(future, function, directExecutor()));
1350     assertSame(barChild, bar);
1351   }
1352   @GwtIncompatible   public void testTransformAsync_asyncFunction_timeout()
1353       throws InterruptedException, ExecutionException {
1354     AsyncFunction&lt;String, Integer&gt; function = constantAsyncFunction(immediateFuture(1));
1355     ListenableFuture&lt;Integer&gt; future =
1356         transformAsync(SettableFuture.&lt;String&gt;create(), function, directExecutor());
1357     try {
1358       future.get(1, MILLISECONDS);
1359       fail();
1360     } catch (TimeoutException expected) {
1361     }
1362   }
1363   public void testTransformAsync_asyncFunction_error() throws InterruptedException {
1364     final Error error = new Error("deliberate");
1365     AsyncFunction&lt;String, Integer&gt; function =
1366         new AsyncFunction&lt;String, Integer&gt;() {
1367           @Override
1368           public ListenableFuture&lt;Integer&gt; apply(String input) {
1369             throw error;
1370           }
1371         };
1372     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1373     ListenableFuture&lt;Integer&gt; outputFuture =
1374         transformAsync(inputFuture, function, directExecutor());
1375     inputFuture.set("value");
1376     try {
1377       getDone(outputFuture);
1378       fail();
1379     } catch (ExecutionException expected) {
1380       assertSame(error, expected.getCause());
1381     }
1382   }
1383   public void testTransformAsync_asyncFunction_nullInsteadOfFuture() throws Exception {
1384     ListenableFuture&lt;?&gt; inputFuture = immediateFuture("a");
1385     ListenableFuture&lt;?&gt; chainedFuture =
1386         transformAsync(inputFuture, constantAsyncFunction(null), directExecutor());
1387     try {
1388       getDone(chainedFuture);
1389       fail();
1390     } catch (ExecutionException expected) {
1391       NullPointerException cause = (NullPointerException) expected.getCause();
1392       assertThat(cause)
1393           .hasMessageThat()
1394           .contains(
1395               "AsyncFunction.apply returned null instead of a Future. "
1396                   + "Did you mean to return immediateFuture(null)?");
1397     }
1398   }
1399   @GwtIncompatible   public void testTransformAsync_asyncFunction_cancelledWhileApplyingFunction()
1400       throws InterruptedException, ExecutionException {
1401     final CountDownLatch inFunction = new CountDownLatch(1);
1402     final CountDownLatch functionDone = new CountDownLatch(1);
1403     final SettableFuture&lt;Integer&gt; resultFuture = SettableFuture.create();
1404     AsyncFunction&lt;String, Integer&gt; function =
1405         new AsyncFunction&lt;String, Integer&gt;() {
1406           @Override
1407           public ListenableFuture&lt;Integer&gt; apply(String input) throws Exception {
1408             inFunction.countDown();
1409             functionDone.await();
1410             return resultFuture;
1411           }
1412         };
1413     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1414     ListenableFuture&lt;Integer&gt; future =
1415         transformAsync(inputFuture, function, newSingleThreadExecutor());
1416     inputFuture.set("value");
1417 <a name="1"></a>    inFunction.await();
1418     future.cancel(false);
1419     functionDone.countDown();
1420     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1421       future.get();
1422       fail();
1423     } catch (CancellationException expected) {
1424     }
1425     try {
1426       resultFuture.get();
1427       fail();
1428     } catch (CancellationException expected) {
1429     }
1430   }
1431   @GwtIncompatible   public void testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction()
1432       throws InterruptedException {
1433     final AtomicBoolean functionCalled = new AtomicBoolean();
1434     AsyncFunction&lt;String, Integer&gt; function =
1435         new AsyncFunction&lt;String, Integer&gt;() {
1436           @Override
1437           public ListenableFuture&lt;Integer&gt; apply(String input) throws Exception {
1438             functionCalled.set(true);
1439             return immediateFuture(1);
1440           }
1441         };
1442     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1443     ExecutorService executor = newSingleThreadExecutor();
1444     ListenableFuture&lt;Integer&gt; future = transformAsync(inputFuture, function, executor);
1445     final CountDownLatch beforeFunction = new CountDownLatch(1);
1446     executor.execute(
1447         new Runnable() {
1448           @Override
1449           public void run() {
1450             awaitUninterruptibly(beforeFunction);
1451           }
1452         });
1453     inputFuture.set("value");
1454     future.cancel(false);
1455     beforeFunction.countDown();
1456     executor.shutdown();
1457     assertTrue(executor.awaitTermination(5, SECONDS));
1458     assertFalse(functionCalled.get());
1459   }
1460   public void testSubmitAsync_asyncCallable_error() throws InterruptedException {
1461     final Error error = new Error("deliberate");
1462     AsyncCallable&lt;Integer&gt; callable =
1463         new AsyncCallable&lt;Integer&gt;() {
1464           @Override
1465           public ListenableFuture&lt;Integer&gt; call() {
1466             throw error;
1467           }
1468         };
1469     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1470     ListenableFuture&lt;Integer&gt; outputFuture = submitAsync(callable, directExecutor());
1471     inputFuture.set("value");
1472     try {
1473       getDone(outputFuture);
1474       fail();
1475     } catch (ExecutionException expected) {
1476       assertSame(error, expected.getCause());
1477     }
1478   }
1479   public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception {
1480     ListenableFuture&lt;?&gt; chainedFuture = submitAsync(constantAsyncCallable(null), directExecutor());
1481     try {
1482       getDone(chainedFuture);
1483       fail();
1484     } catch (ExecutionException expected) {
1485       NullPointerException cause = (NullPointerException) expected.getCause();
1486       assertThat(cause)
1487           .hasMessageThat()
1488           .contains(
1489               "AsyncCallable.call returned null instead of a Future. "
1490                   + "Did you mean to return immediateFuture(null)?");
1491     }
1492   }
1493   @GwtIncompatible   public void testSubmitAsync_asyncCallable_cancelledWhileApplyingFunction()
1494       throws InterruptedException, ExecutionException {
1495     final CountDownLatch inFunction = new CountDownLatch(1);
1496     final CountDownLatch callableDone = new CountDownLatch(1);
1497     final SettableFuture&lt;Integer&gt; resultFuture = SettableFuture.create();
1498     AsyncCallable&lt;Integer&gt; callable =
1499         new AsyncCallable&lt;Integer&gt;() {
1500           @Override
1501           public ListenableFuture&lt;Integer&gt; call() throws InterruptedException {
1502             inFunction.countDown();
1503             callableDone.await();
1504             return resultFuture;
1505           }
1506         };
1507     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1508     ListenableFuture&lt;Integer&gt; future = submitAsync(callable, newSingleThreadExecutor());
1509     inputFuture.set("value");
1510 <a name="0"></a>    inFunction.await();
1511     future.cancel(false);
1512     callableDone.countDown();
1513     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1514       future.get();
1515       fail();
1516     } catch (CancellationException expected) {
1517     }
1518     try {
1519       resultFuture.get();
1520       fail();
1521     } catch (CancellationException expected) {
1522     }
1523   }
1524   @GwtIncompatible   public void testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction()
1525       throws InterruptedException {
1526     final AtomicBoolean callableCalled = new AtomicBoolean();
1527     AsyncCallable&lt;Integer&gt; callable =
1528         new AsyncCallable&lt;Integer&gt;() {
1529           @Override
1530           public ListenableFuture&lt;Integer&gt; call() {
1531             callableCalled.set(true);
1532             return immediateFuture(1);
1533           }
1534         };
1535     ExecutorService executor = newSingleThreadExecutor();
1536     final CountDownLatch beforeFunction = new CountDownLatch(1);
1537     executor.execute(
1538         new Runnable() {
1539           @Override
1540           public void run() {
1541             awaitUninterruptibly(beforeFunction);
1542           }
1543         });
1544     ListenableFuture&lt;Integer&gt; future = submitAsync(callable, executor);
1545     future.cancel(false);
1546     beforeFunction.countDown();
1547     executor.shutdown();
1548     assertTrue(executor.awaitTermination(5, SECONDS));
1549     assertFalse(callableCalled.get());
1550   }
1551   @GwtIncompatible   public void testSubmitAsync_asyncCallable_returnsInterruptedFuture() throws InterruptedException {
1552     assertThat(Thread.interrupted()).isFalse();
1553     SettableFuture&lt;Integer&gt; cancelledFuture = SettableFuture.create();
1554     cancelledFuture.cancel(true);
1555     assertThat(Thread.interrupted()).isFalse();
1556     ListenableFuture&lt;Integer&gt; future =
1557         submitAsync(constantAsyncCallable(cancelledFuture), directExecutor());
1558     assertThat(future.isDone()).isTrue();
1559     assertThat(Thread.interrupted()).isFalse();
1560   }
1561   public void testSubmit_callable_returnsValue() throws Exception {
1562     Callable&lt;Integer&gt; callable =
1563         new Callable&lt;Integer&gt;() {
1564           @Override
1565           public Integer call() {
1566             return 42;
1567           }
1568         };
1569     ListenableFuture&lt;Integer&gt; future = submit(callable, directExecutor());
1570     assertThat(future.isDone()).isTrue();
1571     assertThat(getDone(future)).isEqualTo(42);
1572   }
1573   public void testSubmit_callable_throwsException() {
1574     final Exception exception = new Exception("Exception for testing");
1575     Callable&lt;Integer&gt; callable =
1576         new Callable&lt;Integer&gt;() {
1577           @Override
1578           public Integer call() throws Exception {
1579             throw exception;
1580           }
1581         };
1582     ListenableFuture&lt;Integer&gt; future = submit(callable, directExecutor());
1583     try {
1584       getDone(future);
1585       fail();
1586     } catch (ExecutionException expected) {
1587       assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
1588     }
1589   }
1590   public void testSubmit_runnable_completesAfterRun() throws Exception {
1591     final List&lt;Runnable&gt; pendingRunnables = newArrayList();
1592     final List&lt;Runnable&gt; executedRunnables = newArrayList();
1593     Runnable runnable =
1594         new Runnable() {
1595           @Override
1596           public void run() {
1597             executedRunnables.add(this);
1598           }
1599         };
1600     Executor executor =
1601         new Executor() {
1602           @Override
1603           public void execute(Runnable runnable) {
1604             pendingRunnables.add(runnable);
1605 <a name="3"></a>          }
1606         };
1607     ListenableFuture&lt;Void&gt; future = submit(runnable, executor);
1608     assertThat(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>future.isDone()).isFalse();
1609     assertThat(executedRunnables).isEmpty();
1610     assertThat(pendingRunnables).hasSize(1);
1611     pendingRunnables.remove(0).run();
1612     assertThat(future.isDone()).isTrue();
1613     assertThat(executedRunnables).containsExactly(runnable);
1614     assertThat(pendingRunnables).isEmpty();
1615   }
1616   public void testSubmit_runnable_throwsException() throws Exception {</b></font>
1617     final RuntimeException exception = new RuntimeException("Exception for testing");
1618     Runnable runnable =
1619         new Runnable() {
1620           @Override
1621           public void run() {
1622             throw exception;
1623           }
1624         };
1625     ListenableFuture&lt;Void&gt; future = submit(runnable, directExecutor());
1626     try {
1627       getDone(future);
1628       fail();
1629     } catch (ExecutionException expected) {
1630       assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
1631     }
1632   }
1633   @GwtIncompatible   public void testScheduleAsync_asyncCallable_error() throws InterruptedException {
1634     final Error error = new Error("deliberate");
1635     AsyncCallable&lt;Integer&gt; callable =
1636         new AsyncCallable&lt;Integer&gt;() {
1637           @Override
1638           public ListenableFuture&lt;Integer&gt; call() {
1639             throw error;
1640           }
1641         };
1642     SettableFuture&lt;String&gt; inputFuture = SettableFuture.create();
1643     ListenableFuture&lt;Integer&gt; outputFuture = submitAsync(callable, directExecutor());
1644     inputFuture.set("value");
1645     try {
1646       getDone(outputFuture);
1647       fail();
1648     } catch (ExecutionException expected) {
1649       assertSame(error, expected.getCause());
1650     }
1651   }
1652   @GwtIncompatible   public void testScheduleAsync_asyncCallable_nullInsteadOfFuture() throws Exception {
1653     ListenableFuture&lt;?&gt; chainedFuture =
1654         scheduleAsync(
1655             constantAsyncCallable(null), 1, NANOSECONDS, newSingleThreadScheduledExecutor());
1656     try {
1657       chainedFuture.get();
1658       fail();
1659     } catch (ExecutionException expected) {
1660       NullPointerException cause = (NullPointerException) expected.getCause();
1661       assertThat(cause)
1662           .hasMessageThat()
1663           .contains(
1664               "AsyncCallable.call returned null instead of a Future. "
1665                   + "Did you mean to return immediateFuture(null)?");
1666     }
1667   }
1668   @GwtIncompatible   public void testScheduleAsync_asyncCallable_cancelledWhileApplyingFunction()
1669       throws InterruptedException, ExecutionException {
1670     final CountDownLatch inFunction = new CountDownLatch(1);
1671     final CountDownLatch callableDone = new CountDownLatch(1);
1672     final SettableFuture&lt;Integer&gt; resultFuture = SettableFuture.create();
1673     AsyncCallable&lt;Integer&gt; callable =
1674         new AsyncCallable&lt;Integer&gt;() {
1675           @Override
1676           public ListenableFuture&lt;Integer&gt; call() throws InterruptedException {
1677             inFunction.countDown();
1678             callableDone.await();
1679             return resultFuture;
1680           }
1681         };
1682     ListenableFuture&lt;Integer&gt; future =
1683         scheduleAsync(callable, 1, NANOSECONDS, newSingleThreadScheduledExecutor());
1684 <a name="2"></a>    inFunction.await();
1685     future.cancel(false);
1686     callableDone.countDown();
1687     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1688       future.get();
1689       fail();
1690     } catch (CancellationException expected) {
1691     }
1692     try {
1693       resultFuture.get();
1694       fail();
1695     } catch (CancellationException expected) {
1696     }</b></font>
1697   }
1698   @GwtIncompatible   public void testScheduleAsync_asyncCallable_cancelledBeforeCallingFunction()
1699       throws InterruptedException {
1700     final AtomicBoolean callableCalled = new AtomicBoolean();
1701     AsyncCallable&lt;Integer&gt; callable =
1702         new AsyncCallable&lt;Integer&gt;() {
1703           @Override
1704           public ListenableFuture&lt;Integer&gt; call() {
1705             callableCalled.set(true);
1706             return immediateFuture(1);
1707           }
1708         };
1709     ScheduledExecutorService executor = newSingleThreadScheduledExecutor();
1710     final CountDownLatch beforeFunction = new CountDownLatch(1);
1711     executor.execute(
1712         new Runnable() {
1713           @Override
1714           public void run() {
1715             awaitUninterruptibly(beforeFunction);
1716           }
1717         });
1718     ListenableFuture&lt;Integer&gt; future = scheduleAsync(callable, 1, NANOSECONDS, executor);
1719     future.cancel(false);
1720     beforeFunction.countDown();
1721     executor.shutdown();
1722     assertTrue(executor.awaitTermination(5, SECONDS));
1723     assertFalse(callableCalled.get());
1724   }
1725   private static &lt;T&gt; AsyncCallable&lt;T&gt; constantAsyncCallable(final ListenableFuture&lt;T&gt; returnValue) {
1726     return new AsyncCallable&lt;T&gt;() {
1727       @Override
1728       public ListenableFuture&lt;T&gt; call() {
1729         return returnValue;
1730       }
1731     };
1732   }
1733   private static class SingleCallListener implements Runnable {
1734     private boolean expectCall = false;
1735     private final AtomicBoolean called = new AtomicBoolean();
1736 <a name="21"></a>
1737     @Override
1738     public void run() {
1739       <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue("Listener called before it was expected", expectCall);
1740       assertFalse("Listener called more than once", wasCalled());
1741       called.set(true);
1742     }
1743     public void expectCall() {
1744       assertFalse</b></font>("expectCall is already true", expectCall);
1745       expectCall = true;
1746     }
1747     public boolean wasCalled() {
1748       return called.get();
1749     }
1750   }
1751   public void testAllAsList() throws Exception {
1752     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1753     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1754     SettableFuture&lt;String&gt; future3 = SettableFuture.create();
1755     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2, future3);
1756     SingleCallListener listener = new SingleCallListener();
1757     compound.addListener(listener, directExecutor());
1758     assertFalse(compound.isDone());
1759     future1.set(DATA1);
1760     assertFalse(compound.isDone());
1761     future2.set(DATA2);
1762     assertFalse(compound.isDone());
1763     listener.expectCall();
1764     future3.set(DATA3);
1765     assertTrue(listener.wasCalled());
1766     List&lt;String&gt; results = getDone(compound);
1767     assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
1768   }
1769   public void testAllAsList_emptyList() throws Exception {
1770     SingleCallListener listener = new SingleCallListener();
1771     listener.expectCall();
1772     List&lt;ListenableFuture&lt;String&gt;&gt; futures = ImmutableList.of();
1773     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(futures);
1774     compound.addListener(listener, directExecutor());
1775     assertThat(getDone(compound)).isEmpty();
1776     assertTrue(listener.wasCalled());
1777   }
1778   public void testAllAsList_emptyArray() throws Exception {
1779     SingleCallListener listener = new SingleCallListener();
1780     listener.expectCall();
1781     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList();
1782     compound.addListener(listener, directExecutor());
1783     assertThat(getDone(compound)).isEmpty();
1784     assertTrue(listener.wasCalled());
1785   }
1786   public void testAllAsList_failure() throws Exception {
1787     SingleCallListener listener = new SingleCallListener();
1788     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1789     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1790     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1791     compound.addListener(listener, directExecutor());
1792     listener.expectCall();
1793     Throwable exception = new Throwable("failed1");
1794     future1.setException(exception);
1795     assertTrue(compound.isDone());
1796     assertTrue(listener.wasCalled());
1797     assertFalse(future2.isDone());
1798     try {
1799       getDone(compound);
1800       fail();
1801     } catch (ExecutionException expected) {
1802       assertSame(exception, expected.getCause());
1803     }
1804   }
1805   public void testAllAsList_singleFailure() throws Exception {
1806     Throwable exception = new Throwable("failed");
1807     ListenableFuture&lt;String&gt; future = immediateFailedFuture(exception);
1808     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(ImmutableList.of(future));
1809     try {
1810       getDone(compound);
1811       fail();
1812     } catch (ExecutionException expected) {
1813       assertSame(exception, expected.getCause());
1814     }
1815   }
1816   public void testAllAsList_immediateFailure() throws Exception {
1817     Throwable exception = new Throwable("failed");
1818     ListenableFuture&lt;String&gt; future1 = immediateFailedFuture(exception);
1819     ListenableFuture&lt;String&gt; future2 = immediateFuture("results");
1820     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(ImmutableList.of(future1, future2));
1821     try {
1822       getDone(compound);
1823       fail();
1824     } catch (ExecutionException expected) {
1825       assertSame(exception, expected.getCause());
1826     }
1827   }
1828   public void testAllAsList_error() throws Exception {
1829     Error error = new Error("deliberate");
1830     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1831     ListenableFuture&lt;String&gt; future2 = immediateFuture("results");
1832     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(ImmutableList.of(future1, future2));
1833     future1.setException(error);
1834     try {
1835       getDone(compound);
1836       fail();
1837     } catch (ExecutionException expected) {
1838       assertSame(error, expected.getCause());
1839     }
1840   }
1841   public void testAllAsList_cancelled() throws Exception {
1842     SingleCallListener listener = new SingleCallListener();
1843     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1844     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1845     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1846     compound.addListener(listener, directExecutor());
1847     listener.expectCall();
1848     future1.cancel(true);
1849     assertTrue(compound.isDone());
1850     assertTrue(listener.wasCalled());
1851     assertFalse(future2.isDone());
1852     try {
1853       getDone(compound);
1854       fail();
1855     } catch (CancellationException expected) {
1856     }
1857   }
1858   public void testAllAsList_resultCancelled() throws Exception {
1859     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1860     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1861     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1862     future2.set(DATA2);
1863     assertFalse(compound.isDone());
1864     assertTrue(compound.cancel(false));
1865     assertTrue(compound.isCancelled());
1866     assertTrue(future1.isCancelled());
1867     assertFalse(future1.wasInterrupted());
1868   }
1869   public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture() throws Exception {
1870     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1871     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1872     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1873     ListenableFuture&lt;List&lt;String&gt;&gt; otherCompound = allAsList(future1, future2);
1874     assertTrue(compound.cancel(true));
1875     assertTrue(future1.isCancelled());
1876     assertTrue(future1.wasInterrupted());
1877     assertTrue(future2.isCancelled());
1878     assertTrue(future2.wasInterrupted());
1879     assertTrue(otherCompound.isCancelled());
1880   }
1881   public void testAllAsList_resultCancelled_withSecondaryListFuture() throws Exception {
1882     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1883     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1884     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1885     ListenableFuture&lt;List&lt;String&gt;&gt; unused = allAsList(future1, future2);
1886     assertTrue(compound.cancel(false));
1887     assertTrue(future1.isCancelled());
1888     assertFalse(future1.wasInterrupted());
1889     assertTrue(future2.isCancelled());
1890     assertFalse(future2.wasInterrupted());
1891   }
1892   public void testAllAsList_resultInterrupted() throws Exception {
1893     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1894     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1895     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2);
1896     future2.set(DATA2);
1897     assertFalse(compound.isDone());
1898     assertTrue(compound.cancel(true));
1899     assertTrue(compound.isCancelled());
1900     assertTrue(future1.isCancelled());
1901     assertTrue(future1.wasInterrupted());
1902   }
1903   public void testAllAsList_doneFutures() throws Exception {
1904     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
1905     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
1906     SettableFuture&lt;String&gt; future3 = SettableFuture.create();
1907     future1.set(DATA1);
1908     future2.set(DATA2);
1909     future3.set(DATA3);
1910     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = allAsList(future1, future2, future3);
1911     SingleCallListener listener = new SingleCallListener();
1912     listener.expectCall();
1913     compound.addListener(listener, directExecutor());
1914     assertTrue(listener.wasCalled());
1915     List&lt;String&gt; results = getDone(compound);
1916     assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
1917   }
1918   @SuppressWarnings("unchecked")
1919   public void testAllAsList_logging_exception() throws Exception {
1920     try {
1921       getDone(allAsList(immediateFailedFuture(new MyException())));
1922       fail();
1923     } catch (ExecutionException expected) {
1924       assertThat(expected.getCause()).isInstanceOf(MyException.class);
1925       assertEquals(
1926           "Nothing should be logged", 0, aggregateFutureLogHandler.getStoredLogRecords().size());
1927     }
1928   }
1929   @SuppressWarnings("unchecked")
1930   public void testAllAsList_logging_error() throws Exception {
1931     try {
1932       getDone(allAsList(immediateFailedFuture(new MyError())));
1933       fail();
1934     } catch (ExecutionException expected) {
1935       assertThat(expected.getCause()).isInstanceOf(MyError.class);
1936       List&lt;LogRecord&gt; logged = aggregateFutureLogHandler.getStoredLogRecords();
1937       assertThat(logged).hasSize(1);       assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
1938     }
1939   }
1940   @SuppressWarnings("unchecked")
1941   public void testAllAsList_logging_multipleExceptions_alreadyDone() throws Exception {
1942     try {
1943       getDone(
1944           allAsList(
1945               immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));
1946       fail();
1947     } catch (ExecutionException expected) {
1948       assertThat(expected.getCause()).isInstanceOf(MyException.class);
1949       List&lt;LogRecord&gt; logged = aggregateFutureLogHandler.getStoredLogRecords();
1950       assertThat(logged).hasSize(1);       assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);
1951     }
1952   }
1953   @SuppressWarnings("unchecked")
1954   public void testAllAsList_logging_multipleExceptions_doneLater() throws Exception {
1955     SettableFuture&lt;Object&gt; future1 = SettableFuture.create();
1956     SettableFuture&lt;Object&gt; future2 = SettableFuture.create();
1957     SettableFuture&lt;Object&gt; future3 = SettableFuture.create();
1958     ListenableFuture&lt;List&lt;Object&gt;&gt; all = allAsList(future1, future2, future3);
1959     future1.setException(new MyException());
1960     future2.setException(new MyException());
1961     future3.setException(new MyException());
1962     try {
1963       getDone(all);
1964       fail();
1965     } catch (ExecutionException expected) {
1966       List&lt;LogRecord&gt; logged = aggregateFutureLogHandler.getStoredLogRecords();
1967       assertThat(logged).hasSize(2);       assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);
1968       assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);
1969     }
1970   }
1971   @SuppressWarnings("unchecked")
1972   public void testAllAsList_logging_same_exception() throws Exception {
1973     try {
1974       MyException sameInstance = new MyException();
1975       getDone(allAsList(immediateFailedFuture(sameInstance), immediateFailedFuture(sameInstance)));
1976       fail();
1977     } catch (ExecutionException expected) {
1978       assertThat(expected.getCause()).isInstanceOf(MyException.class);
1979       assertEquals(
1980           "Nothing should be logged", 0, aggregateFutureLogHandler.getStoredLogRecords().size());
1981     }
1982   }
1983   public void testAllAsList_logging_seenExceptionUpdateRace() throws Exception {
1984     final MyException sameInstance = new MyException();
1985     SettableFuture&lt;Object&gt; firstFuture = SettableFuture.create();
1986     final SettableFuture&lt;Object&gt; secondFuture = SettableFuture.create();
1987     ListenableFuture&lt;List&lt;Object&gt;&gt; bulkFuture = allAsList(firstFuture, secondFuture);
1988     bulkFuture.addListener(
1989         new Runnable() {
1990           @Override
1991           public void run() {
1992             secondFuture.setException(sameInstance);
1993           }
1994         },
1995         directExecutor());
1996     firstFuture.setException(sameInstance);
1997     try {
1998       getDone(bulkFuture);
1999       fail();
2000     } catch (ExecutionException expected) {
2001       assertThat(expected.getCause()).isInstanceOf(MyException.class);
2002       assertThat(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();
2003     }
2004   }
2005   public void testAllAsList_logging_seenExceptionUpdateCancelRace() throws Exception {
2006     final MyException subsequentFailure = new MyException();
2007     SettableFuture&lt;Object&gt; firstFuture = SettableFuture.create();
2008     final SettableFuture&lt;Object&gt; secondFuture = SettableFuture.create();
2009     ListenableFuture&lt;List&lt;Object&gt;&gt; bulkFuture = allAsList(firstFuture, secondFuture);
2010     bulkFuture.addListener(
2011         new Runnable() {
2012           @Override
2013           public void run() {
2014             secondFuture.setException(subsequentFailure);
2015           }
2016         },
2017         directExecutor());
2018     firstFuture.cancel(false);
2019     try {
2020       getDone(bulkFuture);
2021       fail();
2022     } catch (CancellationException expected) {
2023       assertThat(getOnlyElement(aggregateFutureLogHandler.getStoredLogRecords()).getThrown())
2024           .isSameInstanceAs(subsequentFailure);
2025     }
2026   }
2027   @SuppressWarnings("unchecked")
2028   public void testAllAsList_logging_same_cause() throws Exception {
2029     try {
2030       MyException exception1 = new MyException();
2031       MyException exception2 = new MyException();
2032       MyException exception3 = new MyException();
2033       MyException sameInstance = new MyException();
2034       exception1.initCause(sameInstance);
2035       exception2.initCause(sameInstance);
2036       exception3.initCause(exception2);
2037       getDone(allAsList(immediateFailedFuture(exception1), immediateFailedFuture(exception3)));
2038       fail();
2039     } catch (ExecutionException expected) {
2040       assertThat(expected.getCause()).isInstanceOf(MyException.class);
2041       assertEquals(
2042           "Nothing should be logged", 0, aggregateFutureLogHandler.getStoredLogRecords().size());
2043     }
2044   }
2045   private static String createCombinedResult(Integer i, Boolean b) {
2046     return "-" + i + "-" + b;
2047   }
2048   @GwtIncompatible   public void testWhenAllComplete_noLeakInterruption() throws Exception {
2049     final SettableFuture&lt;String&gt; stringFuture = SettableFuture.create();
2050     AsyncCallable&lt;String&gt; combiner =
2051         new AsyncCallable&lt;String&gt;() {
2052           @Override
2053           public ListenableFuture&lt;String&gt; call() throws Exception {
2054             return stringFuture;
2055           }
2056         };
2057     ListenableFuture&lt;String&gt; futureResult = whenAllComplete().callAsync(combiner, directExecutor());
2058     assertThat(Thread.interrupted()).isFalse();
2059     futureResult.cancel(true);
2060     assertThat(Thread.interrupted()).isFalse();
2061   }
2062   public void testWhenAllComplete_wildcard() throws Exception {
2063     ListenableFuture&lt;?&gt; futureA = immediateFuture("a");
2064     ListenableFuture&lt;?&gt; futureB = immediateFuture("b");
2065     ListenableFuture&lt;?&gt;[] futures = new ListenableFuture&lt;?&gt;[0];
2066     Callable&lt;String&gt; combiner =
2067         new Callable&lt;String&gt;() {
2068           @Override
2069           public String call() throws Exception {
2070             return "hi";
2071           }
2072         };
2073     ListenableFuture&lt;String&gt; unused;
2074     unused = whenAllComplete(futureA, futureB).call(combiner, directExecutor());
2075     unused = whenAllComplete(asList(futures)).call(combiner, directExecutor());
2076   }
2077   @GwtIncompatible   public void testWhenAllComplete_asyncResult() throws Exception {
2078     SettableFuture&lt;Integer&gt; futureInteger = SettableFuture.create();
2079     SettableFuture&lt;Boolean&gt; futureBoolean = SettableFuture.create();
2080     final ExecutorService executor = newSingleThreadExecutor();
2081     final CountDownLatch callableBlocking = new CountDownLatch(1);
2082     final SettableFuture&lt;String&gt; resultOfCombiner = SettableFuture.create();
2083     AsyncCallable&lt;String&gt; combiner =
2084         tagged(
2085             "Called my toString",
2086             new AsyncCallable&lt;String&gt;() {
2087               @Override
2088               public ListenableFuture&lt;String&gt; call() throws Exception {
2089                 executor.shutdown();
2090                 callableBlocking.await();
2091                 return resultOfCombiner;
2092               }
2093             });
2094     ListenableFuture&lt;String&gt; futureResult =
2095         whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, executor);
2096     assertThat(futureResult.toString())
2097         .matches(
2098             "CombinedFuture@\\w+\\[status=PENDING,"
2099                 + " info=\\[futures=\\[SettableFuture@\\w+\\[status=PENDING],"
2100                 + " SettableFuture@\\w+\\[status=PENDING]]]]");
2101     Integer integerPartial = 1;
2102     futureInteger.set(integerPartial);
2103     assertThat(futureResult.toString())
2104         .matches(
2105             "CombinedFuture@\\w+\\[status=PENDING,"
2106                 + " info=\\[futures=\\[SettableFuture@\\w+\\[status=SUCCESS,"
2107                 + " result=\\[java.lang.Integer@\\w+]], SettableFuture@\\w+\\[status=PENDING]]]]");
2108     Boolean booleanPartial = true;
2109     futureBoolean.set(booleanPartial);
2110     assertThat(futureResult.toString()).matches("CombinedFuture@\\w+\\[status=PENDING]");
2111     callableBlocking.countDown();
2112     assertTrue(executor.awaitTermination(10, SECONDS));
2113     assertThat(futureResult.toString())
2114         .matches(
2115             "CombinedFuture@\\w+\\[status=PENDING,"
2116                 + " setFuture=\\[SettableFuture@\\w+\\[status=PENDING]]]");
2117     resultOfCombiner.set(createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
2118     String expectedResult = createCombinedResult(integerPartial, booleanPartial);
2119     assertEquals(expectedResult, futureResult.get());
2120     assertThat(futureResult.toString())
2121         .matches("CombinedFuture@\\w+\\[status=SUCCESS, result=\\[java.lang.String@\\w+]]");
2122   }
2123   public void testWhenAllComplete_asyncError() throws Exception {
2124     final Exception thrown = new RuntimeException("test");
2125     final SettableFuture&lt;Integer&gt; futureInteger = SettableFuture.create();
2126     final SettableFuture&lt;Boolean&gt; futureBoolean = SettableFuture.create();
2127     AsyncCallable&lt;String&gt; combiner =
2128         new AsyncCallable&lt;String&gt;() {
2129           @Override
2130           public ListenableFuture&lt;String&gt; call() throws Exception {
2131             assertTrue(futureInteger.isDone());
2132             assertTrue(futureBoolean.isDone());
2133             return immediateFailedFuture(thrown);
2134           }
2135         };
2136     ListenableFuture&lt;String&gt; futureResult =
2137         whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
2138     Integer integerPartial = 1;
2139     futureInteger.set(integerPartial);
2140     Boolean booleanPartial = true;
2141     futureBoolean.set(booleanPartial);
2142     try {
2143       getDone(futureResult);
2144       fail();
2145     } catch (ExecutionException expected) {
2146       assertSame(thrown, expected.getCause());
2147     }
2148   }
2149   @GwtIncompatible   public void testWhenAllComplete_cancelledNotInterrupted() throws Exception {
2150     SettableFuture&lt;String&gt; stringFuture = SettableFuture.create();
2151     SettableFuture&lt;Boolean&gt; booleanFuture = SettableFuture.create();
2152     final CountDownLatch inFunction = new CountDownLatch(1);
2153     final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
2154     final SettableFuture&lt;String&gt; resultFuture = SettableFuture.create();
2155     AsyncCallable&lt;String&gt; combiner =
2156         new AsyncCallable&lt;String&gt;() {
2157           @Override
2158           public ListenableFuture&lt;String&gt; call() throws Exception {
2159             inFunction.countDown();
2160             shouldCompleteFunction.await();
2161             return resultFuture;
2162           }
2163         };
2164     ListenableFuture&lt;String&gt; futureResult =
2165         whenAllComplete(stringFuture, booleanFuture).callAsync(combiner, newSingleThreadExecutor());
2166     stringFuture.set("value");
2167     booleanFuture.set(true);
2168     inFunction.await();
2169     futureResult.cancel(false);
2170     shouldCompleteFunction.countDown();
2171     try {
2172       futureResult.get();
2173       fail();
2174     } catch (CancellationException expected) {
2175     }
2176     try {
2177       resultFuture.get();
2178       fail();
2179     } catch (CancellationException expected) {
2180     }
2181   }
2182   @GwtIncompatible   public void testWhenAllComplete_interrupted() throws Exception {
2183     SettableFuture&lt;String&gt; stringFuture = SettableFuture.create();
2184     SettableFuture&lt;Boolean&gt; booleanFuture = SettableFuture.create();
2185     final CountDownLatch inFunction = new CountDownLatch(1);
2186     final CountDownLatch gotException = new CountDownLatch(1);
2187     AsyncCallable&lt;String&gt; combiner =
2188         new AsyncCallable&lt;String&gt;() {
2189           @Override
2190           public ListenableFuture&lt;String&gt; call() throws Exception {
2191             inFunction.countDown();
2192             try {
2193               new CountDownLatch(1).await();             } catch (InterruptedException expected) {
2194               gotException.countDown();
2195               throw expected;
2196             }
2197             return immediateFuture("a");
2198           }
2199         };
2200     ListenableFuture&lt;String&gt; futureResult =
2201         whenAllComplete(stringFuture, booleanFuture).callAsync(combiner, newSingleThreadExecutor());
2202     stringFuture.set("value");
2203     booleanFuture.set(true);
2204     inFunction.await();
2205     futureResult.cancel(true);
2206     try {
2207       futureResult.get();
2208       fail();
2209     } catch (CancellationException expected) {
2210     }
2211     gotException.await();
2212   }
2213   public void testWhenAllComplete_runnableResult() throws Exception {
2214     final SettableFuture&lt;Integer&gt; futureInteger = SettableFuture.create();
2215     final SettableFuture&lt;Boolean&gt; futureBoolean = SettableFuture.create();
2216     final String[] result = new String[1];
2217     Runnable combiner =
2218         new Runnable() {
2219           @Override
2220           public void run() {
2221             assertTrue(futureInteger.isDone());
2222             assertTrue(futureBoolean.isDone());
2223             result[0] =
2224                 createCombinedResult(
2225                     Futures.getUnchecked(futureInteger), Futures.getUnchecked(futureBoolean));
2226           }
2227         };
2228     ListenableFuture&lt;?&gt; futureResult =
2229         whenAllComplete(futureInteger, futureBoolean).run(combiner, directExecutor());
2230     Integer integerPartial = 1;
2231     futureInteger.set(integerPartial);
2232     Boolean booleanPartial = true;
2233     futureBoolean.set(booleanPartial);
2234     futureResult.get();
2235     assertEquals(createCombinedResult(integerPartial, booleanPartial), result[0]);
2236   }
2237   public void testWhenAllComplete_runnableError() throws Exception {
2238     final RuntimeException thrown = new RuntimeException("test");
2239     final SettableFuture&lt;Integer&gt; futureInteger = SettableFuture.create();
2240     final SettableFuture&lt;Boolean&gt; futureBoolean = SettableFuture.create();
2241     Runnable combiner =
2242         new Runnable() {
2243           @Override
2244           public void run() {
2245             assertTrue(futureInteger.isDone());
2246             assertTrue(futureBoolean.isDone());
2247             throw thrown;
2248           }
2249         };
2250     ListenableFuture&lt;?&gt; futureResult =
2251         whenAllComplete(futureInteger, futureBoolean).run(combiner, directExecutor());
2252     Integer integerPartial = 1;
2253     futureInteger.set(integerPartial);
2254     Boolean booleanPartial = true;
2255     futureBoolean.set(booleanPartial);
2256     try {
2257       getDone(futureResult);
2258       fail();
2259     } catch (ExecutionException expected) {
2260       assertSame(thrown, expected.getCause());
2261     }
2262   }
2263   @GwtIncompatible   public void testWhenAllCompleteRunnable_resultCanceledWithoutInterrupt_doesNotInterruptRunnable()
2264       throws Exception {
2265     SettableFuture&lt;String&gt; stringFuture = SettableFuture.create();
2266     SettableFuture&lt;Boolean&gt; booleanFuture = SettableFuture.create();
2267     final CountDownLatch inFunction = new CountDownLatch(1);
2268     final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
2269     final CountDownLatch combinerCompletedWithoutInterrupt = new CountDownLatch(1);
2270     Runnable combiner =
2271         new Runnable() {
2272           @Override
2273           public void run() {
2274             inFunction.countDown();
2275             try {
2276               shouldCompleteFunction.await();
2277               combinerCompletedWithoutInterrupt.countDown();
2278             } catch (InterruptedException e) {
2279               Thread.currentThread().interrupt();
2280               throw new RuntimeException(e);
2281             }
2282           }
2283         };
2284     ListenableFuture&lt;?&gt; futureResult =
2285         whenAllComplete(stringFuture, booleanFuture).run(combiner, newSingleThreadExecutor());
2286     stringFuture.set("value");
2287     booleanFuture.set(true);
2288     inFunction.await();
2289     futureResult.cancel(false);
2290     shouldCompleteFunction.countDown();
2291     try {
2292       futureResult.get();
2293       fail();
2294     } catch (CancellationException expected) {
2295     }
2296     combinerCompletedWithoutInterrupt.await();
2297   }
2298   @GwtIncompatible   public void testWhenAllCompleteRunnable_resultCanceledWithInterrupt_InterruptsRunnable()
2299       throws Exception {
2300     SettableFuture&lt;String&gt; stringFuture = SettableFuture.create();
2301     SettableFuture&lt;Boolean&gt; booleanFuture = SettableFuture.create();
2302     final CountDownLatch inFunction = new CountDownLatch(1);
2303     final CountDownLatch gotException = new CountDownLatch(1);
2304     Runnable combiner =
2305         new Runnable() {
2306           @Override
2307           public void run() {
2308             inFunction.countDown();
2309             try {
2310               new CountDownLatch(1).await();             } catch (InterruptedException expected) {
2311               Thread.currentThread().interrupt();
2312               gotException.countDown();
2313             }
2314           }
2315         };
2316     ListenableFuture&lt;?&gt; futureResult =
2317         whenAllComplete(stringFuture, booleanFuture).run(combiner, newSingleThreadExecutor());
2318     stringFuture.set("value");
2319     booleanFuture.set(true);
2320     inFunction.await();
2321     futureResult.cancel(true);
2322     try {
2323       futureResult.get();
2324       fail();
2325     } catch (CancellationException expected) {
2326     }
2327     gotException.await();
2328   }
2329   public void testWhenAllSucceed() throws Exception {
2330     class PartialResultException extends Exception {}
2331     final SettableFuture&lt;Integer&gt; futureInteger = SettableFuture.create();
2332     final SettableFuture&lt;Boolean&gt; futureBoolean = SettableFuture.create();
2333     AsyncCallable&lt;String&gt; combiner =
2334         new AsyncCallable&lt;String&gt;() {
2335           @Override
2336           public ListenableFuture&lt;String&gt; call() throws Exception {
2337             throw new AssertionFailedError("AsyncCallable should not have been called.");
2338           }
2339         };
2340     ListenableFuture&lt;String&gt; futureResult =
2341         whenAllSucceed(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
2342     PartialResultException partialResultException = new PartialResultException();
2343     futureInteger.setException(partialResultException);
2344     Boolean booleanPartial = true;
2345     futureBoolean.set(booleanPartial);
2346     try {
2347       getDone(futureResult);
2348       fail();
2349     } catch (ExecutionException expected) {
2350       assertSame(partialResultException, expected.getCause());
2351     }
2352   }
2353   @AndroidIncompatible
2354   @GwtIncompatible
2355   public void testWhenAllSucceed_releasesInputFuturesUponSubmission() throws Exception {
2356     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
2357     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
2358     WeakReference&lt;SettableFuture&lt;Long&gt;&gt; future1Ref = new WeakReference&lt;&gt;(future1);
2359     WeakReference&lt;SettableFuture&lt;Long&gt;&gt; future2Ref = new WeakReference&lt;&gt;(future2);
2360     Callable&lt;Long&gt; combiner =
2361         new Callable&lt;Long&gt;() {
2362           @Override
2363           public Long call() {
2364             throw new AssertionError();
2365           }
2366         };
2367     ListenableFuture&lt;Long&gt; unused =
2368         whenAllSucceed(future1, future2).call(combiner, noOpScheduledExecutor());
2369     future1.set(1L);
2370     future1 = null;
2371     future2.set(2L);
2372     future2 = null;
2373     GcFinalization.awaitClear(future1Ref);
2374     GcFinalization.awaitClear(future2Ref);
2375   }
2376   @AndroidIncompatible
2377   @GwtIncompatible
2378   public void testWhenAllComplete_releasesInputFuturesUponCancellation() throws Exception {
2379     SettableFuture&lt;Long&gt; future = SettableFuture.create();
2380     WeakReference&lt;SettableFuture&lt;Long&gt;&gt; futureRef = new WeakReference&lt;&gt;(future);
2381     Callable&lt;Long&gt; combiner =
2382         new Callable&lt;Long&gt;() {
2383           @Override
2384           public Long call() {
2385             throw new AssertionError();
2386           }
2387         };
2388     ListenableFuture&lt;Long&gt; unused = whenAllComplete(future).call(combiner, noOpScheduledExecutor());
2389     unused.cancel(false);
2390     future = null;
2391     GcFinalization.awaitClear(futureRef);
2392   }
2393   @AndroidIncompatible
2394   @GwtIncompatible
2395   public void testWhenAllSucceed_releasesCallable() throws Exception {
2396     AsyncCallable&lt;Long&gt; combiner =
2397         new AsyncCallable&lt;Long&gt;() {
2398           @Override
2399           public ListenableFuture&lt;Long&gt; call() {
2400             return SettableFuture.create();
2401           }
2402         };
2403     WeakReference&lt;AsyncCallable&lt;Long&gt;&gt; combinerRef = new WeakReference&lt;&gt;(combiner);
2404     ListenableFuture&lt;Long&gt; unused =
2405         whenAllSucceed(immediateFuture(1L)).callAsync(combiner, directExecutor());
2406     combiner = null;
2407     GcFinalization.awaitClear(combinerRef);
2408   }
2409   @GwtIncompatible   private static final class TestFuture {
2410     final ListenableFuture&lt;String&gt; future;
2411     final String name;
2412     final Runnable finisher;
2413     TestFuture(ListenableFuture&lt;String&gt; future, String name, Runnable finisher) {
2414       this.future = future;
2415       this.name = name;
2416       this.finisher = finisher;
2417     }
2418   }
2419   @GwtIncompatible   private static final class TestFutureBatch {
2420     final ListenableFuture&lt;String&gt; doneSuccess = immediateFuture("a");
2421     final ListenableFuture&lt;String&gt; doneFailed = immediateFailedFuture(new Exception());
2422     final SettableFuture&lt;String&gt; doneCancelled = SettableFuture.create();
2423     {
2424       doneCancelled.cancel(true);
2425     }
2426     final ListenableFuture&lt;String&gt; doneRuntimeException =
2427         new ForwardingListenableFuture&lt;String&gt;() {
2428           final ListenableFuture&lt;String&gt; delegate = immediateFuture("Should never be seen");
2429           @Override
2430           protected ListenableFuture&lt;String&gt; delegate() {
2431             return delegate;
2432           }
2433           @Override
2434           public String get() {
2435             throw new RuntimeException();
2436           }
2437           @Override
2438           public String get(long timeout, TimeUnit unit) {
2439             throw new RuntimeException();
2440           }
2441         };
2442     final SettableFuture&lt;String&gt; delayedSuccess = SettableFuture.create();
2443     final SettableFuture&lt;String&gt; delayedFailed = SettableFuture.create();
2444     final SettableFuture&lt;String&gt; delayedCancelled = SettableFuture.create();
2445     final SettableFuture&lt;String&gt; delegateForDelayedRuntimeException = SettableFuture.create();
2446     final ListenableFuture&lt;String&gt; delayedRuntimeException =
2447         new ForwardingListenableFuture&lt;String&gt;() {
2448           @Override
2449           protected ListenableFuture&lt;String&gt; delegate() {
2450             return delegateForDelayedRuntimeException;
2451           }
2452           @Override
2453           public String get() throws ExecutionException, InterruptedException {
2454             delegateForDelayedRuntimeException.get();
2455             throw new RuntimeException();
2456           }
2457           @Override
2458           public String get(long timeout, TimeUnit unit)
2459               throws ExecutionException, InterruptedException, TimeoutException {
2460             delegateForDelayedRuntimeException.get(timeout, unit);
2461             throw new RuntimeException();
2462           }
2463         };
2464     final Runnable doNothing =
2465         new Runnable() {
2466           @Override
2467           public void run() {}
2468         };
2469     final Runnable finishSuccess =
2470         new Runnable() {
2471           @Override
2472           public void run() {
2473             delayedSuccess.set("b");
2474           }
2475         };
2476     final Runnable finishFailure =
2477         new Runnable() {
2478           @Override
2479           public void run() {
2480             delayedFailed.setException(new Exception());
2481           }
2482         };
2483     final Runnable finishCancelled =
2484         new Runnable() {
2485           @Override
2486           public void run() {
2487             delayedCancelled.cancel(true);
2488           }
2489         };
2490     final Runnable finishRuntimeException =
2491         new Runnable() {
2492           @Override
2493           public void run() {
2494             delegateForDelayedRuntimeException.set("Should never be seen");
2495           }
2496         };
2497     final ImmutableList&lt;TestFuture&gt; allFutures =
2498         ImmutableList.of(
2499             new TestFuture(doneSuccess, "doneSuccess", doNothing),
2500             new TestFuture(doneFailed, "doneFailed", doNothing),
2501             new TestFuture(doneCancelled, "doneCancelled", doNothing),
2502             new TestFuture(doneRuntimeException, "doneRuntimeException", doNothing),
2503             new TestFuture(delayedSuccess, "delayedSuccess", finishSuccess),
2504             new TestFuture(delayedFailed, "delayedFailed", finishFailure),
2505             new TestFuture(delayedCancelled, "delayedCancelled", finishCancelled),
2506             new TestFuture(
2507                 delayedRuntimeException, "delayedRuntimeException", finishRuntimeException));
2508     final Function&lt;ListenableFuture&lt;String&gt;, String&gt; nameGetter =
2509         new Function&lt;ListenableFuture&lt;String&gt;, String&gt;() {
2510           @Override
2511           public String apply(ListenableFuture&lt;String&gt; input) {
2512             for (TestFuture future : allFutures) {
2513               if (future.future == input) {
2514                 return future.name;
2515               }
2516             }
2517             throw new IllegalArgumentException(input.toString());
2518           }
2519         };
2520     static boolean intersect(Set&lt;?&gt; a, Set&lt;?&gt; b) {
2521       return !intersection(a, b).isEmpty();
2522     }
2523     String smartToString(ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs) {
2524       Iterable&lt;String&gt; inputNames = Iterables.transform(inputs, nameGetter);
2525       return Joiner.on(", ").join(inputNames);
2526     }
2527     void smartAssertTrue(
2528         ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs, Exception cause, boolean expression) {
2529       if (!expression) {
2530         throw failureWithCause(cause, smartToString(inputs));
2531       }
2532     }
2533     boolean hasDelayed(ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b) {
2534       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = ImmutableSet.of(a, b);
2535       return intersect(
2536           inputs,
2537           ImmutableSet.of(
2538               delayedSuccess, delayedFailed, delayedCancelled, delayedRuntimeException));
2539     }
2540     void assertHasDelayed(ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b, Exception e) {
2541       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = ImmutableSet.of(a, b);
2542       smartAssertTrue(inputs, e, hasDelayed(a, b));
2543 <a name="15"></a>    }
2544     void assertHasFailure(ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b, Exception e) {
2545       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ImmutableSet.of(a, b);
2546       smartAssertTrue(
2547           inputs,
2548           e,
2549           intersect(
2550               inputs,
2551               ImmutableSet.of(
2552                   doneFailed, doneRuntimeException, delayedFailed, delayedRuntimeException)));
2553 <a name="14"></a>    }
2554     void assertHasCancel(ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b, Exception e</b></font>) {
2555       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ImmutableSet.of(a, b);
2556       smartAssertTrue(
2557           inputs, e, intersect(inputs, ImmutableSet.of(doneCancelled, delayedCancelled)));
2558     }
2559     void assertHasImmediateFailure(
2560         ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b, Exception e</b></font>) {
2561       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = ImmutableSet.of(a, b);
2562       smartAssertTrue(
2563           inputs, e, intersect(inputs, ImmutableSet.of(doneFailed, doneRuntimeException)));
2564     }
2565     void assertHasImmediateCancel(
2566         ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b, Exception e) {
2567       ImmutableSet&lt;ListenableFuture&lt;String&gt;&gt; inputs = ImmutableSet.of(a, b);
2568       smartAssertTrue(inputs, e, intersect(inputs, ImmutableSet.of(doneCancelled)));
2569     }
2570   }
2571   @GwtIncompatible   private interface Merger {
2572     ListenableFuture&lt;List&lt;String&gt;&gt; merged(ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b);
2573     Merger allMerger =
2574         new Merger() {
2575           @Override
2576           public ListenableFuture&lt;List&lt;String&gt;&gt; merged(
2577               ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b) {
2578             return allAsList(ImmutableSet.of(a, b));
2579           }
2580         };
2581     Merger successMerger =
2582         new Merger() {
2583           @Override
2584           public ListenableFuture&lt;List&lt;String&gt;&gt; merged(
2585               ListenableFuture&lt;String&gt; a, ListenableFuture&lt;String&gt; b) {
2586             return successfulAsList(ImmutableSet.of(a, b));
2587           }
2588         };
2589   }
2590   @CanIgnoreReturnValue
2591   @GwtIncompatible   static &lt;V&gt; V pseudoTimedGetUninterruptibly(final Future&lt;V&gt; input, long timeout, TimeUnit unit)
2592       throws ExecutionException, TimeoutException {
2593     ExecutorService executor = newSingleThreadExecutor();
2594     Future&lt;V&gt; waiter =
2595         executor.submit(
2596             new Callable&lt;V&gt;() {
2597               @Override
2598               public V call() throws Exception {
2599                 return input.get();
2600               }
2601             });
2602     try {
2603       return getUninterruptibly(waiter, timeout, unit);
2604     } catch (ExecutionException e) {
2605       propagateIfInstanceOf(e.getCause(), ExecutionException.class);
2606       propagateIfInstanceOf(e.getCause(), CancellationException.class);
2607       throw failureWithCause(e, "Unexpected exception");
2608     } finally {
2609       executor.shutdownNow();
2610     }
2611   }
2612   @GwtIncompatible   private static void runExtensiveMergerTest(Merger merger) throws InterruptedException {
2613     int inputCount = new TestFutureBatch().allFutures.size();
2614     for (int i = 0; i &lt; inputCount; i++) {
2615       for (int j = 0; j &lt; inputCount; j++) {
2616         for (boolean iBeforeJ : new boolean[] {true, false}) {
2617           TestFutureBatch inputs = new TestFutureBatch();
2618           ListenableFuture&lt;String&gt; iFuture = inputs.allFutures.get(i).future;
2619           ListenableFuture&lt;String&gt; jFuture = inputs.allFutures.get(j).future;
2620           ListenableFuture&lt;List&lt;String&gt;&gt; future = merger.merged(iFuture, jFuture);
2621           try {
2622             List&lt;String&gt; result = future.get(0, MILLISECONDS);
2623             assertTrue("Got " + result, asList("a", null).containsAll(result));
2624           } catch (CancellationException e) {
2625             assertTrue(merger == Merger.allMerger);
2626             inputs.assertHasImmediateCancel(iFuture, jFuture, e);
2627           } catch (ExecutionException e) {
2628             assertTrue(merger == Merger.allMerger);
2629             inputs.assertHasImmediateFailure(iFuture, jFuture, e);
2630           } catch (TimeoutException e) {
2631             inputs.assertHasDelayed(iFuture, jFuture, e);
2632           }
2633           try {
2634             List&lt;String&gt; result =
2635                 conditionalPseudoTimedGetUninterruptibly(
2636                     inputs, iFuture, jFuture, future, 20, MILLISECONDS);
2637             assertTrue("Got " + result, asList("a", null).containsAll(result));
2638           } catch (CancellationException e) {
2639             assertTrue(merger == Merger.allMerger);
2640             inputs.assertHasImmediateCancel(iFuture, jFuture, e);
2641           } catch (ExecutionException e) {
2642             assertTrue(merger == Merger.allMerger);
2643             inputs.assertHasImmediateFailure(iFuture, jFuture, e);
2644           } catch (TimeoutException e) {
2645             inputs.assertHasDelayed(iFuture, jFuture, e);
2646           }
2647           inputs.allFutures.get(iBeforeJ ? i : j).finisher.run();
2648           inputs.allFutures.get(iBeforeJ ? j : i).finisher.run();
2649           try {
2650             List&lt;String&gt; result = getDone(future);
2651             assertTrue("Got " + result, asList("a", "b", null).containsAll(result));
2652           } catch (CancellationException e) {
2653             assertTrue(merger == Merger.allMerger);
2654             inputs.assertHasCancel(iFuture, jFuture, e);
2655           } catch (ExecutionException e) {
2656             assertTrue(merger == Merger.allMerger);
2657             inputs.assertHasFailure(iFuture, jFuture, e);
2658           }
2659         }
2660       }
2661     }
2662   }
2663   @GwtIncompatible   private static List&lt;String&gt; conditionalPseudoTimedGetUninterruptibly(
2664       TestFutureBatch inputs,
2665       ListenableFuture&lt;String&gt; iFuture,
2666       ListenableFuture&lt;String&gt; jFuture,
2667       ListenableFuture&lt;List&lt;String&gt;&gt; future,
2668       int timeout,
2669       TimeUnit unit)
2670       throws ExecutionException, TimeoutException {
2671     /*
2672      * For faster tests (that may hang indefinitely if the class under test has
2673      * a bug!), switch the second branch to call untimed future.get() instead of
2674      * pseudoTimedGet.
2675      */
2676     return (inputs.hasDelayed(iFuture, jFuture))
2677         ? pseudoTimedGetUninterruptibly(future, timeout, unit)
2678         : pseudoTimedGetUninterruptibly(future, 2500, MILLISECONDS);
2679   }
2680   @GwtIncompatible   public void testAllAsList_extensive() throws InterruptedException {
2681     runExtensiveMergerTest(Merger.allMerger);
2682   }
2683   @GwtIncompatible   public void testSuccessfulAsList_extensive() throws InterruptedException {
2684     runExtensiveMergerTest(Merger.successMerger);
2685   }
2686   public void testSuccessfulAsList() throws Exception {
2687     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2688     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2689     SettableFuture&lt;String&gt; future3 = SettableFuture.create();
2690     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2, future3);
2691     SingleCallListener listener = new SingleCallListener();
2692     compound.addListener(listener, directExecutor());
2693     assertFalse(compound.isDone());
2694     future1.set(DATA1);
2695     assertFalse(compound.isDone());
2696     future2.set(DATA2);
2697     assertFalse(compound.isDone());
2698     listener.expectCall();
2699     future3.set(DATA3);
2700     assertTrue(listener.wasCalled());
2701     List&lt;String&gt; results = getDone(compound);
2702     assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
2703   }
2704   public void testSuccessfulAsList_emptyList() throws Exception {
2705     SingleCallListener listener = new SingleCallListener();
2706     listener.expectCall();
2707     List&lt;ListenableFuture&lt;String&gt;&gt; futures = ImmutableList.of();
2708     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(futures);
2709     compound.addListener(listener, directExecutor());
2710     assertThat(getDone(compound)).isEmpty();
2711     assertTrue(listener.wasCalled());
2712   }
2713   public void testSuccessfulAsList_emptyArray() throws Exception {
2714     SingleCallListener listener = new SingleCallListener();
2715     listener.expectCall();
2716     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList();
2717     compound.addListener(listener, directExecutor());
2718     assertThat(getDone(compound)).isEmpty();
2719     assertTrue(listener.wasCalled());
2720   }
2721   public void testSuccessfulAsList_partialFailure() throws Exception {
2722     SingleCallListener listener = new SingleCallListener();
2723     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2724     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2725     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2726     compound.addListener(listener, directExecutor());
2727     assertFalse(compound.isDone());
2728     future1.setException(new Throwable("failed1"));
2729     assertFalse(compound.isDone());
2730     listener.expectCall();
2731     future2.set(DATA2);
2732     assertTrue(listener.wasCalled());
2733     List&lt;String&gt; results = getDone(compound);
2734     assertThat(results).containsExactly(null, DATA2).inOrder();
2735   }
2736   public void testSuccessfulAsList_totalFailure() throws Exception {
2737     SingleCallListener listener = new SingleCallListener();
2738     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2739     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2740     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2741     compound.addListener(listener, directExecutor());
2742     assertFalse(compound.isDone());
2743     future1.setException(new Throwable("failed1"));
2744     assertFalse(compound.isDone());
2745     listener.expectCall();
2746     future2.setException(new Throwable("failed2"));
2747     assertTrue(listener.wasCalled());
2748     List&lt;String&gt; results = getDone(compound);
2749     assertThat(results).containsExactly(null, null).inOrder();
2750   }
2751   public void testSuccessfulAsList_cancelled() throws Exception {
2752     SingleCallListener listener = new SingleCallListener();
2753     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2754     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2755     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2756     compound.addListener(listener, directExecutor());
2757     assertFalse(compound.isDone());
2758     future1.cancel(true);
2759     assertFalse(compound.isDone());
2760     listener.expectCall();
2761     future2.set(DATA2);
2762     assertTrue(listener.wasCalled());
2763     List&lt;String&gt; results = getDone(compound);
2764     assertThat(results).containsExactly(null, DATA2).inOrder();
2765   }
2766   public void testSuccessfulAsList_resultCancelled() throws Exception {
2767     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2768     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2769     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2770     future2.set(DATA2);
2771     assertFalse(compound.isDone());
2772     assertTrue(compound.cancel(false));
2773     assertTrue(compound.isCancelled());
2774     assertTrue(future1.isCancelled());
2775     assertFalse(future1.wasInterrupted());
2776   }
2777   public void testSuccessfulAsList_resultCancelledRacingInputDone() throws Exception {
2778     TestLogHandler listenerLoggerHandler = new TestLogHandler();
2779     Logger exceptionLogger = Logger.getLogger(AbstractFuture.class.getName());
2780     exceptionLogger.addHandler(listenerLoggerHandler);
2781     try {
2782       doTestSuccessfulAsList_resultCancelledRacingInputDone();
2783       assertWithMessage("Nothing should be logged")
2784           .that(listenerLoggerHandler.getStoredLogRecords())
2785           .isEmpty();
2786     } finally {
2787       exceptionLogger.removeHandler(listenerLoggerHandler);
2788     }
2789   }
2790   private static void doTestSuccessfulAsList_resultCancelledRacingInputDone() throws Exception {
2791     successfulAsList(ImmutableList.of(SettableFuture.create())).cancel(true);
2792     /*
2793      * Complex (combined.cancel -&gt; input.cancel -&gt; other.set -&gt; setOneValue),
2794      * to show that this isn't just about problems with the input future we just
2795      * cancelled:
2796      */
2797     final SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2798     final SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2799     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2800     future1.addListener(
2801         new Runnable() {
2802           @Override
2803           public void run() {
2804             assertTrue(future1.isCancelled());
2805             /*
2806              * This test relies on behavior that's unspecified but currently
2807              * guaranteed by the implementation: Cancellation of inputs is
2808              * performed in the order they were provided to the constructor. Verify
2809              * that as a sanity check:
2810              */
2811             assertFalse(future2.isCancelled());
2812             future2.set(DATA2);
2813           }
2814         },
2815         directExecutor());
2816     assertTrue(compound.cancel(false));
2817     assertTrue(compound.isCancelled());
2818     assertTrue(future1.isCancelled());
2819     assertFalse(future2.isCancelled());
2820     try {
2821       getDone(compound);
2822       fail();
2823     } catch (CancellationException expected) {
2824     }
2825   }
2826   public void testSuccessfulAsList_resultInterrupted() throws Exception {
2827     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2828     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2829     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2);
2830     future2.set(DATA2);
2831     assertFalse(compound.isDone());
2832     assertTrue(compound.cancel(true));
2833     assertTrue(compound.isCancelled());
2834     assertTrue(future1.isCancelled());
2835     assertTrue(future1.wasInterrupted());
2836   }
2837   public void testSuccessfulAsList_mixed() throws Exception {
2838     SingleCallListener listener = new SingleCallListener();
2839     SettableFuture&lt;String&gt; future1 = SettableFuture.create();
2840     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
2841     SettableFuture&lt;String&gt; future3 = SettableFuture.create();
2842     @SuppressWarnings("unchecked")     ListenableFuture&lt;List&lt;String&gt;&gt; compound = successfulAsList(future1, future2, future3);
2843     compound.addListener(listener, directExecutor());
2844     assertFalse(compound.isDone());
2845     future1.cancel(true);
2846     assertFalse(compound.isDone());
2847     future2.setException(new Throwable("failed2"));
2848     assertFalse(compound.isDone());
2849     listener.expectCall();
2850     future3.set(DATA3);
2851     assertTrue(listener.wasCalled());
2852     List&lt;String&gt; results = getDone(compound);
2853     assertThat(results).containsExactly(null, null, DATA3).inOrder();
2854   }
2855   @SuppressWarnings("unchecked")
2856   public void testSuccessfulAsList_logging_exception() throws Exception {
2857     assertEquals(
2858         newArrayList((Object) null),
2859         getDone(successfulAsList(immediateFailedFuture(new MyException()))));
2860     assertWithMessage("Nothing should be logged")
2861         .that(aggregateFutureLogHandler.getStoredLogRecords())
2862         .isEmpty();
2863     assertEquals(
2864         newArrayList(null, null, null),
2865         getDone(
2866             successfulAsList(
2867                 immediateFailedFuture(new MyException()),
2868                 immediateFailedFuture(new MyException()),
2869                 immediateFailedFuture(new MyException()))));
2870     assertWithMessage("Nothing should be logged")
2871         .that(aggregateFutureLogHandler.getStoredLogRecords())
2872         .isEmpty();
2873   }
2874   @SuppressWarnings("unchecked")
2875   public void testSuccessfulAsList_logging_error() throws Exception {
2876     assertEquals(
2877         newArrayList((Object) null),
2878         getDone(successfulAsList(immediateFailedFuture(new MyError()))));
2879     List&lt;LogRecord&gt; logged = aggregateFutureLogHandler.getStoredLogRecords();
2880     assertThat(logged).hasSize(1);     assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
2881   }
2882   public void testSuccessfulAsList_failureLoggedEvenAfterOutputCancelled() throws Exception {
2883     ListenableFuture&lt;String&gt; input = new CancelPanickingFuture&lt;&gt;();
2884     ListenableFuture&lt;List&lt;String&gt;&gt; output = successfulAsList(input);
2885     output.cancel(false);
2886     List&lt;LogRecord&gt; logged = aggregateFutureLogHandler.getStoredLogRecords();
2887     assertThat(logged).hasSize(1);
2888     assertThat(logged.get(0).getThrown()).hasMessageThat().isEqualTo("You can't fire me, I quit.");
2889   }
2890   private static final class CancelPanickingFuture&lt;V&gt; extends AbstractFuture&lt;V&gt; {
2891     @Override
2892     public boolean cancel(boolean mayInterruptIfRunning) {
2893       setException(new Error("You can't fire me, I quit."));
2894       return false;
2895     }
2896   }
2897   public void testNonCancellationPropagating_successful() throws Exception {
2898     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
2899     ListenableFuture&lt;Foo&gt; wrapper = nonCancellationPropagating(input);
2900     Foo foo = new Foo();
2901     assertFalse(wrapper.isDone());
2902     input.set(foo);
2903     assertTrue(wrapper.isDone());
2904     assertSame(foo, getDone(wrapper));
2905   }
2906   public void testNonCancellationPropagating_failure() throws Exception {
2907     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
2908     ListenableFuture&lt;Foo&gt; wrapper = nonCancellationPropagating(input);
2909     Throwable failure = new Throwable("thrown");
2910     assertFalse(wrapper.isDone());
2911     input.setException(failure);
2912     try {
2913       getDone(wrapper);
2914       fail();
2915     } catch (ExecutionException expected) {
2916       assertSame(failure, expected.getCause());
2917     }
2918   }
2919   public void testNonCancellationPropagating_delegateCancelled() throws Exception {
2920     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
2921     ListenableFuture&lt;Foo&gt; wrapper = nonCancellationPropagating(input);
2922     assertFalse(wrapper.isDone());
2923     assertTrue(input.cancel(false));
2924     assertTrue(wrapper.isCancelled());
2925   }
2926   public void testNonCancellationPropagating_doesNotPropagate() throws Exception {
2927     SettableFuture&lt;Foo&gt; input = SettableFuture.create();
2928     ListenableFuture&lt;Foo&gt; wrapper = nonCancellationPropagating(input);
2929     assertTrue(wrapper.cancel(true));
2930     assertTrue(wrapper.isCancelled());
2931     assertTrue(wrapper.isDone());
2932     assertFalse(input.isCancelled());
2933     assertFalse(input.isDone());
2934   }
2935   @GwtIncompatible   private static class TestException extends Exception {
2936     TestException(@Nullable Throwable cause) {
2937       super(cause);
2938     }
2939   }
2940   @GwtIncompatible   private interface MapperFunction extends Function&lt;Throwable, Exception&gt; {}
2941   public void testCompletionOrder() throws Exception {
2942     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
2943     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
2944     SettableFuture&lt;Long&gt; future3 = SettableFuture.create();
2945     SettableFuture&lt;Long&gt; future4 = SettableFuture.create();
2946     SettableFuture&lt;Long&gt; future5 = SettableFuture.create();
2947     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; futures =
2948         inCompletionOrder(
2949             ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2, future3, future4, future5));
2950     future2.set(1L);
2951     future5.set(2L);
2952     future1.set(3L);
2953     future3.set(4L);
2954 <a name="13"></a>    future4.set(5L);
2955     long expectedResult = 1L;
2956     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (ListenableFuture&lt;Long&gt; future : futures) {
2957       assertEquals((Long) expectedResult, getDone(future));
2958       expectedResult++;
2959     }
2960   }
2961   public void testCompletionOrderExceptionThrown() throws Exception {</b></font>
2962     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
2963     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
2964     SettableFuture&lt;Long&gt; future3 = SettableFuture.create();
2965     SettableFuture&lt;Long&gt; future4 = SettableFuture.create();
2966     SettableFuture&lt;Long&gt; future5 = SettableFuture.create();
2967     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; futures =
2968         inCompletionOrder(
2969             ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2, future3, future4, future5));
2970     future2.set(1L);
2971     future5.setException(new IllegalStateException("2L"));
2972     future1.set(3L);
2973     future3.set(4L);
2974     future4.set(5L);
2975     long expectedResult = 1L;
2976 <a name="4"></a>    for (ListenableFuture&lt;Long&gt; future : futures) {
2977       if (expectedResult != 2) {
2978         assertEquals((Long) expectedResult, getDone(future));
2979       } else <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
2980         try {
2981           getDone(future);
2982           fail();
2983         } catch (ExecutionException expected) {
2984           assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo("2L");
2985         }
2986       }</b></font>
2987       expectedResult++;
2988     }
2989   }
2990   public void testCompletionOrderFutureCancelled() throws Exception {
2991     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
2992     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
2993     SettableFuture&lt;Long&gt; future3 = SettableFuture.create();
2994     SettableFuture&lt;Long&gt; future4 = SettableFuture.create();
2995     SettableFuture&lt;Long&gt; future5 = SettableFuture.create();
2996     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; futures =
2997         inCompletionOrder(
2998             ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2, future3, future4, future5));
2999     future2.set(1L);
3000     future5.set(2L);
3001     future1.set(3L);
3002     future3.cancel(true);
3003     future4.set(5L);
3004     long expectedResult = 1L;
3005 <a name="12"></a>    for (ListenableFuture&lt;Long&gt; future : futures) {
3006       if (expectedResult != 4) {
3007         assertEquals((Long) expectedResult, getDone(future));
3008       } else <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
3009         try {
3010           getDone(future);
3011           fail();
3012         } catch (CancellationException expected) {
3013         }</b></font>
3014       }
3015       expectedResult++;
3016     }
3017   }
3018   public void testCompletionOrderFutureInterruption() throws Exception {
3019     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
3020     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
3021     SettableFuture&lt;Long&gt; future3 = SettableFuture.create();
3022     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; futures =
3023         inCompletionOrder(ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2, future3));
3024     future2.set(1L);
3025     futures.get(1).cancel(true);
3026     futures.get(2).cancel(false);
3027     assertTrue(future1.isCancelled());
3028     assertFalse(future1.wasInterrupted());
3029     assertTrue(future3.isCancelled());
3030     assertFalse(future3.wasInterrupted());
3031   }
3032   public void testCancellingADelegatePropagates() throws Exception {
3033     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
3034     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
3035     SettableFuture&lt;Long&gt; future3 = SettableFuture.create();
3036     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; delegates =
3037         inCompletionOrder(ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2, future3));
3038     future1.set(1L);
3039     assertFalse(delegates.get(0).cancel(true));
3040     assertTrue(delegates.get(1).cancel(true));
3041     assertTrue(future2.set(2L));
3042     assertEquals((Long) 2L, getDone(future2));
3043     assertTrue(future3.isCancelled());
3044     assertTrue(future3.wasInterrupted());
3045   }
3046   @AndroidIncompatible   public void testCancellingAllDelegatesIsNotQuadratic() throws Exception {
3047     ImmutableList.Builder&lt;SettableFuture&lt;Long&gt;&gt; builder = ImmutableList.builder();
3048     for (int i = 0; i &lt; 500_000; i++) {
3049       builder.add(SettableFuture.&lt;Long&gt;create());
3050     }
3051     ImmutableList&lt;SettableFuture&lt;Long&gt;&gt; inputs = builder.build();
3052     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; delegates = inCompletionOrder(inputs);
3053     for (ListenableFuture&lt;?&gt; delegate : delegates) {
3054       delegate.cancel(true);
3055     }
3056     for (ListenableFuture&lt;?&gt; input : inputs) {
3057       assertTrue(input.isDone());
3058     }
3059   }
3060   @AndroidIncompatible   @GwtIncompatible
3061   public void testInputGCedIfUnreferenced() throws Exception {
3062     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
3063     SettableFuture&lt;Long&gt; future2 = SettableFuture.create();
3064     WeakReference&lt;SettableFuture&lt;Long&gt;&gt; future1Ref = new WeakReference&lt;&gt;(future1);
3065     WeakReference&lt;SettableFuture&lt;Long&gt;&gt; future2Ref = new WeakReference&lt;&gt;(future2);
3066     ImmutableList&lt;ListenableFuture&lt;Long&gt;&gt; delegates =
3067         inCompletionOrder(ImmutableList.&lt;ListenableFuture&lt;Long&gt;&gt;of(future1, future2));
3068     future1.set(1L);
3069     future1 = null;
3070     GcFinalization.awaitClear(future1Ref);
3071     ListenableFuture&lt;Long&gt; outputFuture1 = delegates.get(0);
3072     delegates = null;
3073     future2 = null;
3074     GcFinalization.awaitClear(future2Ref);
3075     outputFuture1.get();
3076   }
3077   public void testCompletionOrderMixedBagOTypes() throws Exception {
3078     SettableFuture&lt;Long&gt; future1 = SettableFuture.create();
3079     SettableFuture&lt;String&gt; future2 = SettableFuture.create();
3080     SettableFuture&lt;Integer&gt; future3 = SettableFuture.create();
3081     ImmutableList&lt;? extends ListenableFuture&lt;?&gt;&gt; inputs =
3082         ImmutableList.&lt;ListenableFuture&lt;?&gt;&gt;of(future1, future2, future3);
3083     ImmutableList&lt;ListenableFuture&lt;Object&gt;&gt; futures = inCompletionOrder(inputs);
3084     future2.set("1L");
3085     future1.set(2L);
3086     future3.set(3);
3087     ImmutableList&lt;?&gt; expected = ImmutableList.of("1L", 2L, 3);
3088     for (int i = 0; i &lt; expected.size(); i++) {
3089       assertEquals(expected.get(i), getDone(futures.get(i)));
3090     }
3091   }
3092   @GwtIncompatible   public void testFutures_nullChecks() throws Exception {
3093     new ClassSanityTester()
3094         .forAllPublicStaticMethods(Futures.class)
3095         .thatReturn(Future.class)
3096         .testNulls();
3097   }
3098   static AssertionFailedError failureWithCause(Throwable cause, String message) {
3099     AssertionFailedError failure = new AssertionFailedError(message);
3100     failure.initCause(cause);
3101     return failure;
3102   }
3103   private static final Executor REJECTING_EXECUTOR =
3104       new Executor() {
3105         @Override
3106         public void execute(Runnable runnable) {
3107           throw new RejectedExecutionException();
3108         }
3109       };
3110   private static &lt;V&gt; AsyncFunction&lt;V, V&gt; asyncIdentity() {
3111     return new AsyncFunction&lt;V, V&gt;() {
3112       @Override
3113       public ListenableFuture&lt;V&gt; apply(V input) {
3114         return immediateFuture(input);
3115       }
3116     };
3117   }
3118   private static &lt;I, O&gt; AsyncFunction&lt;I, O&gt; tagged(
3119 <a name="17"></a>      final String toString, final AsyncFunction&lt;I, O&gt; function) {
3120     return new AsyncFunction&lt;I, O&gt;() {
3121       @Override
3122       public ListenableFuture&lt;O&gt; apply(<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>I input) throws Exception {
3123         return function.apply(input);
3124       }
3125       @Override
3126       public String toString() {</b></font>
3127         return toString;
3128       }
3129     };
3130   }
3131   private static &lt;V&gt; AsyncCallable&lt;V&gt; tagged(
3132       final String toString, final AsyncCallable&lt;V&gt; callable) {
3133     return new AsyncCallable&lt;V&gt;() {
3134       @Override
3135       public ListenableFuture&lt;V&gt; call() throws Exception {
3136         return callable.call();
3137       }
3138       @Override
3139       public String toString() {
3140         return toString;
3141       }
3142     };
3143   }
3144 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
