
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.net.URI;
3  import java.time.Duration;
4  import java.util.List;
5  import java.util.Map;
6  import java.util.Set;
7  import java.util.regex.Pattern;
8  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
9  import org.json.JSONArray;
10  import redis.clients.jedis.args.*;
11  import redis.clients.jedis.bloom.*;
12  import redis.clients.jedis.commands.JedisCommands;
13  import redis.clients.jedis.commands.JedisBinaryCommands;
14  import redis.clients.jedis.commands.ProtocolCommand;
15  import redis.clients.jedis.commands.SampleBinaryKeyedCommands;
16  import redis.clients.jedis.commands.SampleKeyedCommands;
17  import redis.clients.jedis.commands.RedisModuleCommands;
18  import redis.clients.jedis.exceptions.JedisException;
19  import redis.clients.jedis.executors.*;
20  import redis.clients.jedis.graph.GraphCommandObjects;
21  import redis.clients.jedis.graph.ResultSet;
22  import redis.clients.jedis.json.JsonSetParams;
23  import redis.clients.jedis.json.Path;
24  import redis.clients.jedis.json.Path2;
25  import redis.clients.jedis.json.JsonObjectMapper;
26  import redis.clients.jedis.params.*;
27  import redis.clients.jedis.providers.*;
28  import redis.clients.jedis.resps.*;
29  import redis.clients.jedis.search.*;
30  import redis.clients.jedis.search.aggr.AggregationBuilder;
31  import redis.clients.jedis.search.aggr.AggregationResult;
32  import redis.clients.jedis.search.aggr.FtAggregateIteration;
33  import redis.clients.jedis.search.schemafields.SchemaField;
34  import redis.clients.jedis.timeseries.*;
35  import redis.clients.jedis.util.IOUtils;
36  import redis.clients.jedis.util.JedisURIHelper;
37  import redis.clients.jedis.util.KeyValue;
38  public class UnifiedJedis implements JedisCommands, JedisBinaryCommands,
39      SampleKeyedCommands, SampleBinaryKeyedCommands, RedisModuleCommands,
40      AutoCloseable {
41    protected RedisProtocol protocol = null;
42    protected final ConnectionProvider provider;
43    protected final CommandExecutor executor;
44    protected final CommandObjects commandObjects;
45    private final GraphCommandObjects graphCommandObjects;
46    private JedisBroadcastAndRoundRobinConfig broadcastAndRoundRobinConfig = null;
47    public UnifiedJedis() {
48      this(new HostAndPort(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT));
49    }
50    public UnifiedJedis(HostAndPort hostAndPort) {
51      this(new PooledConnectionProvider(hostAndPort));
52    }
53    public UnifiedJedis(final String url) {
54      this(URI.create(url));
55    }
56    public UnifiedJedis(final URI uri) {
57      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
58          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
59          .database(JedisURIHelper.getDBIndex(uri)).protocol(JedisURIHelper.getRedisProtocol(uri))
60          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
61    }
62    public UnifiedJedis(final URI uri, JedisClientConfig config) {
63      this(JedisURIHelper.getHostAndPort(uri), DefaultJedisClientConfig.builder()
64          .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
65          .socketTimeoutMillis(config.getSocketTimeoutMillis())
66          .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
67          .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
68          .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
69          .protocol(JedisURIHelper.getRedisProtocol(uri))
70          .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
71          .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
72          .build());
73    }
74    public UnifiedJedis(HostAndPort hostAndPort, JedisClientConfig clientConfig) {
75      this(new PooledConnectionProvider(hostAndPort, clientConfig));
76      RedisProtocol proto = clientConfig.getRedisProtocol();
77      if (proto != null) commandObjects.setProtocol(proto);
78    }
79    public UnifiedJedis(ConnectionProvider provider) {
80      this.provider = provider;
81      this.executor = new DefaultCommandExecutor(provider);
82      this.commandObjects = new CommandObjects();
83      this.graphCommandObjects = new GraphCommandObjects(this);
84      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
85      try (Connection conn = this.provider.getConnection()) {
86        if (conn != null) {
87          RedisProtocol proto = conn.getRedisProtocol();
88          if (proto != null) commandObjects.setProtocol(proto);
89        }
90      } catch (JedisException je) { 
91      }
92    }
93    public UnifiedJedis(JedisSocketFactory socketFactory) {
94      this(new Connection(socketFactory));
95    }
96    public UnifiedJedis(JedisSocketFactory socketFactory, JedisClientConfig clientConfig) {
97      this(new Connection(socketFactory, clientConfig));
98    }
99    public UnifiedJedis(Connection connection) {
100      this.provider = null;
101      this.executor = new SimpleCommandExecutor(connection);
102      this.commandObjects = new CommandObjects();
103      this.graphCommandObjects = new GraphCommandObjects(this);
104      RedisProtocol proto = connection.getRedisProtocol();
105      if (proto == RedisProtocol.RESP3) this.commandObjects.setProtocol(proto);
106    }
107    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts) {
108      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts,
109          Duration.ofMillis(maxAttempts * clientConfig.getSocketTimeoutMillis()));
110      RedisProtocol proto = clientConfig.getRedisProtocol();
111      if (proto != null) commandObjects.setProtocol(proto);
112    }
113    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
114      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig), maxAttempts, maxTotalRetriesDuration);
115      RedisProtocol proto = clientConfig.getRedisProtocol();
116      if (proto != null) commandObjects.setProtocol(proto);
117    }
118    public UnifiedJedis(Set&lt;HostAndPort&gt; jedisClusterNodes, JedisClientConfig clientConfig,
119        GenericObjectPoolConfig&lt;Connection&gt; poolConfig, int maxAttempts, Duration maxTotalRetriesDuration) {
120      this(new ClusterConnectionProvider(jedisClusterNodes, clientConfig, poolConfig), maxAttempts, maxTotalRetriesDuration);
121      RedisProtocol proto = clientConfig.getRedisProtocol();
122      if (proto != null) commandObjects.setProtocol(proto);
123    }
124    public UnifiedJedis(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
125      this.provider = provider;
126      this.executor = new ClusterCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
127      this.commandObjects = new ClusterCommandObjects();
128      this.graphCommandObjects = new GraphCommandObjects(this);
129      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
130    }
131    @Deprecated
132    public UnifiedJedis(ShardedConnectionProvider provider) {
133      this.provider = provider;
134      this.executor = new DefaultCommandExecutor(provider);
135      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo());
136      this.graphCommandObjects = new GraphCommandObjects(this);
137      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
138    }
139    @Deprecated
140    public UnifiedJedis(ShardedConnectionProvider provider, Pattern tagPattern) {
141      this.provider = provider;
142      this.executor = new DefaultCommandExecutor(provider);
143      this.commandObjects = new ShardedCommandObjects(provider.getHashingAlgo(), tagPattern);
144      this.graphCommandObjects = new GraphCommandObjects(this);
145      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
146    }
147    public UnifiedJedis(ConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {
148      this.provider = provider;
149      this.executor = new RetryableCommandExecutor(provider, maxAttempts, maxTotalRetriesDuration);
150      this.commandObjects = new CommandObjects();
151      this.graphCommandObjects = new GraphCommandObjects(this);
152      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
153    }
154    public UnifiedJedis(MultiClusterPooledConnectionProvider provider) {
155      this.provider = provider;
156      this.executor = new CircuitBreakerCommandExecutor(provider);
157      this.commandObjects = new CommandObjects();
158      this.graphCommandObjects = new GraphCommandObjects(this);
159      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
160    }
161    public UnifiedJedis(CommandExecutor executor) {
162      this.provider = null;
163      this.executor = executor;
164      this.commandObjects = new CommandObjects();
165      this.graphCommandObjects = new GraphCommandObjects(this);
166      this.graphCommandObjects.setBaseCommandArgumentsCreator((comm) -&gt; this.commandObjects.commandArguments(comm));
167    }
168    @Override
169    public void close() {
170      IOUtils.closeQuietly(this.executor);
171    }
172    protected final void setProtocol(RedisProtocol protocol) {
173      this.protocol = protocol;
174      this.commandObjects.setProtocol(this.protocol);
175    }
176    public final &lt;T&gt; T executeCommand(CommandObject&lt;T&gt; commandObject) {
177      return executor.executeCommand(commandObject);
178    }
179    public final &lt;T&gt; T broadcastCommand(CommandObject&lt;T&gt; commandObject) {
180      return executor.broadcastCommand(commandObject);
181    }
182    private &lt;T&gt; T checkAndBroadcastCommand(CommandObject&lt;T&gt; commandObject) {
183      boolean broadcast = true;
184      if (broadcastAndRoundRobinConfig == null) {
185      } else if (commandObject.getArguments().getCommand() instanceof SearchProtocol.SearchCommand
186          &amp;&amp; broadcastAndRoundRobinConfig.getRediSearchModeInCluster() == JedisBroadcastAndRoundRobinConfig.RediSearchMode.LIGHT) {
187        broadcast = false;
188      }
189      return broadcast ? broadcastCommand(commandObject) : executeCommand(commandObject);
190    }
191    public void setBroadcastAndRoundRobinConfig(JedisBroadcastAndRoundRobinConfig config) {
192      this.broadcastAndRoundRobinConfig = config;
193      this.commandObjects.setBroadcastAndRoundRobinConfig(this.broadcastAndRoundRobinConfig);
194    }
195    public String ping() {
196      return checkAndBroadcastCommand(commandObjects.ping());
197    }
198    public String flushDB() {
199      return checkAndBroadcastCommand(commandObjects.flushDB());
200    }
201    public String flushAll() {
202      return checkAndBroadcastCommand(commandObjects.flushAll());
203    }
204    public String configSet(String parameter, String value) {
205      return checkAndBroadcastCommand(commandObjects.configSet(parameter, value));
206    }
207    @Override
208    public boolean exists(String key) {
209      return executeCommand(commandObjects.exists(key));
210    }
211    @Override
212    public long exists(String... keys) {
213      return executeCommand(commandObjects.exists(keys));
214    }
215    @Override
216    public long persist(String key) {
217      return executeCommand(commandObjects.persist(key));
218    }
219    @Override
220    public String type(String key) {
221      return executeCommand(commandObjects.type(key));
222    }
223    @Override
224    public boolean exists(byte[] key) {
225      return executeCommand(commandObjects.exists(key));
226    }
227    @Override
228    public long exists(byte[]... keys) {
229      return executeCommand(commandObjects.exists(keys));
230    }
231    @Override
232    public long persist(byte[] key) {
233      return executeCommand(commandObjects.persist(key));
234    }
235    @Override
236    public String type(byte[] key) {
237      return executeCommand(commandObjects.type(key));
238    }
239    @Override
240    public byte[] dump(String key) {
241      return executeCommand(commandObjects.dump(key));
242    }
243    @Override
244    public String restore(String key, long ttl, byte[] serializedValue) {
245      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
246    }
247    @Override
248    public String restore(String key, long ttl, byte[] serializedValue, RestoreParams params) {
249      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
250    }
251    @Override
252    public byte[] dump(byte[] key) {
253      return executeCommand(commandObjects.dump(key));
254    }
255    @Override
256    public String restore(byte[] key, long ttl, byte[] serializedValue) {
257      return executeCommand(commandObjects.restore(key, ttl, serializedValue));
258    }
259    @Override
260    public String restore(byte[] key, long ttl, byte[] serializedValue, RestoreParams params) {
261      return executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
262    }
263    @Override
264    public long expire(String key, long seconds) {
265      return executeCommand(commandObjects.expire(key, seconds));
266    }
267    @Override
268    public long expire(String key, long seconds, ExpiryOption expiryOption) {
269      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
270    }
271    @Override
272    public long pexpire(String key, long milliseconds) {
273      return executeCommand(commandObjects.pexpire(key, milliseconds));
274    }
275    @Override
276    public long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {
277      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
278    }
279    @Override
280    public long expireTime(String key) {
281      return executeCommand(commandObjects.expireTime(key));
282    }
283    @Override
284    public long pexpireTime(String key) {
285      return executeCommand(commandObjects.pexpireTime(key));
286    }
287    @Override
288    public long expireAt(String key, long unixTime) {
289      return executeCommand(commandObjects.expireAt(key, unixTime));
290    }
291    @Override
292    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
293      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
294    }
295    @Override
296    public long pexpireAt(String key, long millisecondsTimestamp) {
297      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
298    }
299    @Override
300    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
301      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
302    }
303    @Override
304    public long expire(byte[] key, long seconds) {
305      return executeCommand(commandObjects.expire(key, seconds));
306    }
307    @Override
308    public long expire(byte[] key, long seconds, ExpiryOption expiryOption) {
309      return executeCommand(commandObjects.expire(key, seconds, expiryOption));
310    }
311    @Override
312    public long pexpire(byte[] key, long milliseconds) {
313      return executeCommand(commandObjects.pexpire(key, milliseconds));
314    }
315    @Override
316    public long pexpire(byte[] key, long milliseconds, ExpiryOption expiryOption) {
317      return executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
318    }
319    @Override
320    public long expireTime(byte[] key) {
321      return executeCommand(commandObjects.expireTime(key));
322    }
323    @Override
324    public long pexpireTime(byte[] key) {
325      return executeCommand(commandObjects.pexpireTime(key));
326    }
327    @Override
328    public long expireAt(byte[] key, long unixTime) {
329      return executeCommand(commandObjects.expireAt(key, unixTime));
330    }
331    @Override
332    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
333      return executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
334    }
335    @Override
336    public long pexpireAt(byte[] key, long millisecondsTimestamp) {
337      return executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
338    }
339    @Override
340    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
341      return executeCommand(commandObjects.expireAt(key, millisecondsTimestamp, expiryOption));
342    }
343    @Override
344    public long ttl(String key) {
345      return executeCommand(commandObjects.ttl(key));
346    }
347    @Override
348    public long pttl(String key) {
349      return executeCommand(commandObjects.pttl(key));
350    }
351    @Override
352    public long touch(String key) {
353      return executeCommand(commandObjects.touch(key));
354    }
355    @Override
356    public long touch(String... keys) {
357      return executeCommand(commandObjects.touch(keys));
358    }
359    @Override
360    public long ttl(byte[] key) {
361      return executeCommand(commandObjects.ttl(key));
362    }
363    @Override
364    public long pttl(byte[] key) {
365      return executeCommand(commandObjects.pttl(key));
366    }
367    @Override
368    public long touch(byte[] key) {
369      return executeCommand(commandObjects.touch(key));
370    }
371    @Override
372    public long touch(byte[]... keys) {
373      return executeCommand(commandObjects.touch(keys));
374    }
375    @Override
376    public List&lt;String&gt; sort(String key) {
377      return executeCommand(commandObjects.sort(key));
378    }
379    @Override
380    public List&lt;String&gt; sort(String key, SortingParams sortingParams) {
381      return executeCommand(commandObjects.sort(key, sortingParams));
382    }
383    @Override
384    public long sort(String key, String dstkey) {
385      return executeCommand(commandObjects.sort(key, dstkey));
386    }
387    @Override
388    public long sort(String key, SortingParams sortingParams, String dstkey) {
389      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
390    }
391    @Override
392    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
393      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
394    }
395    @Override
396    public List&lt;byte[]&gt; sort(byte[] key) {
397      return executeCommand(commandObjects.sort(key));
398    }
399    @Override
400    public List&lt;byte[]&gt; sort(byte[] key, SortingParams sortingParams) {
401      return executeCommand(commandObjects.sort(key, sortingParams));
402    }
403    @Override
404    public long sort(byte[] key, byte[] dstkey) {
405      return executeCommand(commandObjects.sort(key, dstkey));
406    }
407    @Override
408    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
409      return executeCommand(commandObjects.sortReadonly(key, sortingParams));
410    }
411    @Override
412    public long sort(byte[] key, SortingParams sortingParams, byte[] dstkey) {
413      return executeCommand(commandObjects.sort(key, sortingParams, dstkey));
414    }
415    @Override
416    public long del(String key) {
417      return executeCommand(commandObjects.del(key));
418    }
419    @Override
420    public long del(String... keys) {
421      return executeCommand(commandObjects.del(keys));
422    }
423    @Override
424    public long unlink(String key) {
425      return executeCommand(commandObjects.unlink(key));
426    }
427    @Override
428    public long unlink(String... keys) {
429      return executeCommand(commandObjects.unlink(keys));
430    }
431    @Override
432    public long del(byte[] key) {
433      return executeCommand(commandObjects.del(key));
434    }
435    @Override
436    public long del(byte[]... keys) {
437      return executeCommand(commandObjects.del(keys));
438    }
439    @Override
440    public long unlink(byte[] key) {
441      return executeCommand(commandObjects.unlink(key));
442    }
443    @Override
444    public long unlink(byte[]... keys) {
445      return executeCommand(commandObjects.unlink(keys));
446    }
447    @Override
448    public Long memoryUsage(String key) {
449      return executeCommand(commandObjects.memoryUsage(key));
450    }
451    @Override
452    public Long memoryUsage(String key, int samples) {
453      return executeCommand(commandObjects.memoryUsage(key, samples));
454    }
455    @Override
456    public Long memoryUsage(byte[] key) {
457      return executeCommand(commandObjects.memoryUsage(key));
458    }
459    @Override
460    public Long memoryUsage(byte[] key, int samples) {
461      return executeCommand(commandObjects.memoryUsage(key, samples));
462    }
463    @Override
464    public boolean copy(String srcKey, String dstKey, boolean replace) {
465      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
466    }
467    @Override
468    public String rename(String oldkey, String newkey) {
469      return executeCommand(commandObjects.rename(oldkey, newkey));
470    }
471    @Override
472    public long renamenx(String oldkey, String newkey) {
473      return executeCommand(commandObjects.renamenx(oldkey, newkey));
474    }
475    @Override
476    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
477      return executeCommand(commandObjects.copy(srcKey, dstKey, replace));
478    }
479    @Override
480    public String rename(byte[] oldkey, byte[] newkey) {
481      return executeCommand(commandObjects.rename(oldkey, newkey));
482    }
483    @Override
484    public long renamenx(byte[] oldkey, byte[] newkey) {
485      return executeCommand(commandObjects.renamenx(oldkey, newkey));
486    }
487    public long dbSize() {
488      return executeCommand(commandObjects.dbSize());
489    }
490    @Override
491    public Set&lt;String&gt; keys(String pattern) {
492      return executeCommand(commandObjects.keys(pattern));
493    }
494    @Override
495    public ScanResult&lt;String&gt; scan(String cursor) {
496      return executeCommand(commandObjects.scan(cursor));
497    }
498    @Override
499    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params) {
500      return executeCommand(commandObjects.scan(cursor, params));
501    }
502    @Override
503    public ScanResult&lt;String&gt; scan(String cursor, ScanParams params, String type) {
504      return executeCommand(commandObjects.scan(cursor, params, type));
505    }
506    public ScanIteration scanIteration(int batchCount, String match) {
507      return new ScanIteration(provider, batchCount, match);
508    }
509    public ScanIteration scanIteration(int batchCount, String match, String type) {
510      return new ScanIteration(provider, batchCount, match, type);
511    }
512    @Override
513    public Set&lt;byte[]&gt; keys(byte[] pattern) {
514      return executeCommand(commandObjects.keys(pattern));
515    }
516    @Override
517    public ScanResult&lt;byte[]&gt; scan(byte[] cursor) {
518      return executeCommand(commandObjects.scan(cursor));
519    }
520    @Override
521    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params) {
522      return executeCommand(commandObjects.scan(cursor, params));
523    }
524    @Override
525    public ScanResult&lt;byte[]&gt; scan(byte[] cursor, ScanParams params, byte[] type) {
526      return executeCommand(commandObjects.scan(cursor, params, type));
527    }
528    @Override
529    public String randomKey() {
530      return executeCommand(commandObjects.randomKey());
531    }
532    @Override
533    public byte[] randomBinaryKey() {
534      return executeCommand(commandObjects.randomBinaryKey());
535    }
536    @Override
537    public String set(String key, String value) {
538      return executeCommand(commandObjects.set(key, value));
539    }
540    @Override
541    public String set(String key, String value, SetParams params) {
542      return executeCommand(commandObjects.set(key, value, params));
543    }
544    @Override
545    public String get(String key) {
546      return executeCommand(commandObjects.get(key));
547    }
548    @Override
549    public String setGet(String key, String value) {
550      return executeCommand(commandObjects.setGet(key, value));
551    }
552    @Override
553    public String setGet(String key, String value, SetParams params) {
554      return executeCommand(commandObjects.setGet(key, value, params));
555    }
556    @Override
557    public String getDel(String key) {
558      return executeCommand(commandObjects.getDel(key));
559    }
560    @Override
561    public String getEx(String key, GetExParams params) {
562      return executeCommand(commandObjects.getEx(key, params));
563    }
564    @Override
565    public String set(byte[] key, byte[] value) {
566      return executeCommand(commandObjects.set(key, value));
567    }
568    @Override
569    public String set(byte[] key, byte[] value, SetParams params) {
570      return executeCommand(commandObjects.set(key, value, params));
571    }
572    @Override
573    public byte[] get(byte[] key) {
574      return executeCommand(commandObjects.get(key));
575    }
576    @Override
577    public byte[] setGet(byte[] key, byte[] value) {
578      return executeCommand(commandObjects.setGet(key, value));
579    }
580    @Override
581    public byte[] setGet(byte[] key, byte[] value, SetParams params) {
582      return executeCommand(commandObjects.setGet(key, value, params));
583    }
584    @Override
585    public byte[] getDel(byte[] key) {
586      return executeCommand(commandObjects.getDel(key));
587    }
588    @Override
589    public byte[] getEx(byte[] key, GetExParams params) {
590      return executeCommand(commandObjects.getEx(key, params));
591    }
592    @Override
593    public boolean setbit(String key, long offset, boolean value) {
594      return executeCommand(commandObjects.setbit(key, offset, value));
595    }
596    @Override
597    public boolean getbit(String key, long offset) {
598      return executeCommand(commandObjects.getbit(key, offset));
599    }
600    @Override
601    public long setrange(String key, long offset, String value) {
602      return executeCommand(commandObjects.setrange(key, offset, value));
603    }
604    @Override
605    public String getrange(String key, long startOffset, long endOffset) {
606      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
607    }
608    @Override
609    public boolean setbit(byte[] key, long offset, boolean value) {
610      return executeCommand(commandObjects.setbit(key, offset, value));
611    }
612    @Override
613    public boolean getbit(byte[] key, long offset) {
614      return executeCommand(commandObjects.getbit(key, offset));
615    }
616    @Override
617    public long setrange(byte[] key, long offset, byte[] value) {
618      return executeCommand(commandObjects.setrange(key, offset, value));
619    }
620    @Override
621    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
622      return executeCommand(commandObjects.getrange(key, startOffset, endOffset));
623    }
624    @Override
625    public String getSet(String key, String value) {
626      return executeCommand(commandObjects.getSet(key, value));
627    }
628    @Override
629    public long setnx(String key, String value) {
630      return executeCommand(commandObjects.setnx(key, value));
631    }
632    @Override
633    public String setex(String key, long seconds, String value) {
634      return executeCommand(commandObjects.setex(key, seconds, value));
635    }
636    @Override
637    public String psetex(String key, long milliseconds, String value) {
638      return executeCommand(commandObjects.psetex(key, milliseconds, value));
639    }
640    @Override
641    public byte[] getSet(byte[] key, byte[] value) {
642      return executeCommand(commandObjects.getSet(key, value));
643    }
644    @Override
645    public long setnx(byte[] key, byte[] value) {
646      return executeCommand(commandObjects.setnx(key, value));
647    }
648    @Override
649    public String setex(byte[] key, long seconds, byte[] value) {
650      return executeCommand(commandObjects.setex(key, seconds, value));
651    }
652    @Override
653    public String psetex(byte[] key, long milliseconds, byte[] value) {
654      return executeCommand(commandObjects.psetex(key, milliseconds, value));
655    }
656    @Override
657    public long incr(String key) {
658      return executeCommand(commandObjects.incr(key));
659    }
660    @Override
661    public long incrBy(String key, long increment) {
662      return executeCommand(commandObjects.incrBy(key, increment));
663    }
664    @Override
665    public double incrByFloat(String key, double increment) {
666      return executeCommand(commandObjects.incrByFloat(key, increment));
667    }
668    @Override
669    public long decr(String key) {
670      return executeCommand(commandObjects.decr(key));
671    }
672    @Override
673    public long decrBy(String key, long decrement) {
674      return executeCommand(commandObjects.decrBy(key, decrement));
675    }
676    @Override
677    public long incr(byte[] key) {
678      return executeCommand(commandObjects.incr(key));
679    }
680    @Override
681    public long incrBy(byte[] key, long increment) {
682      return executeCommand(commandObjects.incrBy(key, increment));
683    }
684    @Override
685    public double incrByFloat(byte[] key, double increment) {
686      return executeCommand(commandObjects.incrByFloat(key, increment));
687    }
688    @Override
689    public long decr(byte[] key) {
690      return executeCommand(commandObjects.decr(key));
691    }
692    @Override
693    public long decrBy(byte[] key, long decrement) {
694      return executeCommand(commandObjects.decrBy(key, decrement));
695    }
696    @Override
697    public List&lt;String&gt; mget(String... keys) {
698      return executeCommand(commandObjects.mget(keys));
699    }
700    @Override
701    public String mset(String... keysvalues) {
702      return executeCommand(commandObjects.mset(keysvalues));
703    }
704    @Override
705    public long msetnx(String... keysvalues) {
706      return executeCommand(commandObjects.msetnx(keysvalues));
707    }
708    @Override
709    public List&lt;byte[]&gt; mget(byte[]... keys) {
710      return executeCommand(commandObjects.mget(keys));
711    }
712    @Override
713    public String mset(byte[]... keysvalues) {
714      return executeCommand(commandObjects.mset(keysvalues));
715    }
716    @Override
717    public long msetnx(byte[]... keysvalues) {
718      return executeCommand(commandObjects.msetnx(keysvalues));
719    }
720    @Override
721    public long append(String key, String value) {
722      return executeCommand(commandObjects.append(key, value));
723    }
724    @Override
725    public String substr(String key, int start, int end) {
726      return executeCommand(commandObjects.substr(key, start, end));
727    }
728    @Override
729    public long strlen(String key) {
730      return executeCommand(commandObjects.strlen(key));
731    }
732    @Override
733    public long append(byte[] key, byte[] value) {
734      return executeCommand(commandObjects.append(key, value));
735    }
736    @Override
737    public byte[] substr(byte[] key, int start, int end) {
738      return executeCommand(commandObjects.substr(key, start, end));
739    }
740    @Override
741    public long strlen(byte[] key) {
742      return executeCommand(commandObjects.strlen(key));
743    }
744    @Override
745    public long bitcount(String key) {
746      return executeCommand(commandObjects.bitcount(key));
747    }
748    @Override
749    public long bitcount(String key, long start, long end) {
750      return executeCommand(commandObjects.bitcount(key, start, end));
751    }
752    @Override
753    public long bitcount(String key, long start, long end, BitCountOption option) {
754      return executeCommand(commandObjects.bitcount(key, start, end, option));
755    }
756    @Override
757    public long bitpos(String key, boolean value) {
758      return executeCommand(commandObjects.bitpos(key, value));
759    }
760    @Override
761    public long bitpos(String key, boolean value, BitPosParams params) {
762      return executeCommand(commandObjects.bitpos(key, value, params));
763    }
764    @Override
765    public long bitcount(byte[] key) {
766      return executeCommand(commandObjects.bitcount(key));
767    }
768    @Override
769    public long bitcount(byte[] key, long start, long end) {
770      return executeCommand(commandObjects.bitcount(key, start, end));
771    }
772    @Override
773    public long bitcount(byte[] key, long start, long end, BitCountOption option) {
774      return executeCommand(commandObjects.bitcount(key, start, end, option));
775    }
776    @Override
777    public long bitpos(byte[] key, boolean value) {
778      return executeCommand(commandObjects.bitpos(key, value));
779    }
780    @Override
781    public long bitpos(byte[] key, boolean value, BitPosParams params) {
782      return executeCommand(commandObjects.bitpos(key, value, params));
783    }
784    @Override
785    public List&lt;Long&gt; bitfield(String key, String... arguments) {
786      return executeCommand(commandObjects.bitfield(key, arguments));
787    }
788    @Override
789    public List&lt;Long&gt; bitfieldReadonly(String key, String... arguments) {
790      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
791    }
792    @Override
793    public List&lt;Long&gt; bitfield(byte[] key, byte[]... arguments) {
794      return executeCommand(commandObjects.bitfield(key, arguments));
795    }
796    @Override
797    public List&lt;Long&gt; bitfieldReadonly(byte[] key, byte[]... arguments) {
798      return executeCommand(commandObjects.bitfieldReadonly(key, arguments));
799    }
800    @Override
801    public long bitop(BitOP op, String destKey, String... srcKeys) {
802      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
803    }
804    @Override
805    public long bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
806      return executeCommand(commandObjects.bitop(op, destKey, srcKeys));
807    }
808    @Override
809    public LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {
810      return executeCommand(commandObjects.lcs(keyA, keyB, params));
811    }
812    @Override
813    public LCSMatchResult lcs(byte[] keyA, byte[] keyB, LCSParams params) {
814      return executeCommand(commandObjects.lcs(keyA, keyB, params));
815    }
816    @Override
817    public long rpush(String key, String... string) {
818      return executeCommand(commandObjects.rpush(key, string));
819    }
820    @Override
821    public long lpush(String key, String... string) {
822      return executeCommand(commandObjects.lpush(key, string));
823    }
824    @Override
825    public long llen(String key) {
826      return executeCommand(commandObjects.llen(key));
827    }
828    @Override
829    public List&lt;String&gt; lrange(String key, long start, long stop) {
830      return executeCommand(commandObjects.lrange(key, start, stop));
831    }
832    @Override
833    public String ltrim(String key, long start, long stop) {
834      return executeCommand(commandObjects.ltrim(key, start, stop));
835    }
836    @Override
837    public String lindex(String key, long index) {
838      return executeCommand(commandObjects.lindex(key, index));
839    }
840    @Override
841    public long rpush(byte[] key, byte[]... args) {
842      return executeCommand(commandObjects.rpush(key, args));
843    }
844    @Override
845    public long lpush(byte[] key, byte[]... args) {
846      return executeCommand(commandObjects.lpush(key, args));
847    }
848    @Override
849    public long llen(byte[] key) {
850      return executeCommand(commandObjects.llen(key));
851    }
852    @Override
853    public List&lt;byte[]&gt; lrange(byte[] key, long start, long stop) {
854      return executeCommand(commandObjects.lrange(key, start, stop));
855    }
856    @Override
857    public String ltrim(byte[] key, long start, long stop) {
858      return executeCommand(commandObjects.ltrim(key, start, stop));
859    }
860    @Override
861    public byte[] lindex(byte[] key, long index) {
862      return executeCommand(commandObjects.lindex(key, index));
863    }
864    @Override
865    public String lset(String key, long index, String value) {
866      return executeCommand(commandObjects.lset(key, index, value));
867    }
868    @Override
869    public long lrem(String key, long count, String value) {
870      return executeCommand(commandObjects.lrem(key, count, value));
871    }
872    @Override
873    public String lpop(String key) {
874      return executeCommand(commandObjects.lpop(key));
875    }
876    @Override
877    public List&lt;String&gt; lpop(String key, int count) {
878      return executeCommand(commandObjects.lpop(key, count));
879    }
880    @Override
881    public String lset(byte[] key, long index, byte[] value) {
882      return executeCommand(commandObjects.lset(key, index, value));
883    }
884    @Override
885    public long lrem(byte[] key, long count, byte[] value) {
886      return executeCommand(commandObjects.lrem(key, count, value));
887    }
888    @Override
889    public byte[] lpop(byte[] key) {
890      return executeCommand(commandObjects.lpop(key));
891    }
892    @Override
893    public List&lt;byte[]&gt; lpop(byte[] key, int count) {
894      return executeCommand(commandObjects.lpop(key, count));
895    }
896    @Override
897    public Long lpos(String key, String element) {
898      return executeCommand(commandObjects.lpos(key, element));
899    }
900    @Override
901    public Long lpos(String key, String element, LPosParams params) {
902      return executeCommand(commandObjects.lpos(key, element, params));
903    }
904    @Override
905    public List&lt;Long&gt; lpos(String key, String element, LPosParams params, long count) {
906      return executeCommand(commandObjects.lpos(key, element, params, count));
907    }
908    @Override
909    public Long lpos(byte[] key, byte[] element) {
910      return executeCommand(commandObjects.lpos(key, element));
911    }
912    @Override
913    public Long lpos(byte[] key, byte[] element, LPosParams params) {
914      return executeCommand(commandObjects.lpos(key, element, params));
915    }
916    @Override
917    public List&lt;Long&gt; lpos(byte[] key, byte[] element, LPosParams params, long count) {
918      return executeCommand(commandObjects.lpos(key, element, params, count));
919    }
920    @Override
921    public String rpop(String key) {
922      return executeCommand(commandObjects.rpop(key));
923    }
924    @Override
925    public List&lt;String&gt; rpop(String key, int count) {
926      return executeCommand(commandObjects.rpop(key, count));
927    }
928    @Override
929    public byte[] rpop(byte[] key) {
930      return executeCommand(commandObjects.rpop(key));
931    }
932    @Override
933    public List&lt;byte[]&gt; rpop(byte[] key, int count) {
934      return executeCommand(commandObjects.rpop(key, count));
935    }
936    @Override
937    public long linsert(String key, ListPosition where, String pivot, String value) {
938      return executeCommand(commandObjects.linsert(key, where, pivot, value));
939    }
940    @Override
941    public long lpushx(String key, String... strings) {
942      return executeCommand(commandObjects.lpushx(key, strings));
943    }
944    @Override
945    public long rpushx(String key, String... strings) {
946      return executeCommand(commandObjects.rpushx(key, strings));
947    }
948    @Override
949    public long linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value) {
950      return executeCommand(commandObjects.linsert(key, where, pivot, value));
951    }
952    @Override
953    public long lpushx(byte[] key, byte[]... args) {
954      return executeCommand(commandObjects.lpushx(key, args));
955    }
956    @Override
957    public long rpushx(byte[] key, byte[]... args) {
958      return executeCommand(commandObjects.rpushx(key, args));
959    }
960    @Override
961    public List&lt;String&gt; blpop(int timeout, String key) {
962      return executeCommand(commandObjects.blpop(timeout, key));
963    }
964    @Override
965    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
966      return executeCommand(commandObjects.blpop(timeout, key));
967    }
968    @Override
969    public List&lt;String&gt; brpop(int timeout, String key) {
970      return executeCommand(commandObjects.brpop(timeout, key));
971    }
972    @Override
973    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
974      return executeCommand(commandObjects.brpop(timeout, key));
975    }
976    @Override
977    public List&lt;String&gt; blpop(int timeout, String... keys) {
978      return executeCommand(commandObjects.blpop(timeout, keys));
979    }
980    @Override
981    public KeyValue&lt;String, String&gt; blpop(double timeout, String... keys) {
982      return executeCommand(commandObjects.blpop(timeout, keys));
983    }
984    @Override
985    public List&lt;String&gt; brpop(int timeout, String... keys) {
986      return executeCommand(commandObjects.brpop(timeout, keys));
987    }
988    @Override
989    public KeyValue&lt;String, String&gt; brpop(double timeout, String... keys) {
990      return executeCommand(commandObjects.brpop(timeout, keys));
991    }
992    @Override
993    public List&lt;byte[]&gt; blpop(int timeout, byte[]... keys) {
994      return executeCommand(commandObjects.blpop(timeout, keys));
995    }
996    @Override
997    public KeyValue&lt;byte[], byte[]&gt; blpop(double timeout, byte[]... keys) {
998      return executeCommand(commandObjects.blpop(timeout, keys));
999    }
1000    @Override
1001    public List&lt;byte[]&gt; brpop(int timeout, byte[]... keys) {
1002      return executeCommand(commandObjects.brpop(timeout, keys));
1003    }
1004    @Override
1005    public KeyValue&lt;byte[], byte[]&gt; brpop(double timeout, byte[]... keys) {
1006      return executeCommand(commandObjects.brpop(timeout, keys));
1007    }
1008    @Override
1009    public String rpoplpush(String srckey, String dstkey) {
1010      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1011    }
1012    @Override
1013    public String brpoplpush(String source, String destination, int timeout) {
1014      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1015    }
1016    @Override
1017    public byte[] rpoplpush(byte[] srckey, byte[] dstkey) {
1018      return executeCommand(commandObjects.rpoplpush(srckey, dstkey));
1019    }
1020    @Override
1021    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
1022      return executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1023    }
1024    @Override
1025    public String lmove(String srcKey, String dstKey, ListDirection from, ListDirection to) {
1026      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1027    }
1028    @Override
1029    public String blmove(String srcKey, String dstKey, ListDirection from, ListDirection to, double timeout) {
1030      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1031    }
1032    @Override
1033    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1034      return executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1035    }
1036    @Override
1037    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1038      return executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1039    }
1040    @Override
1041    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
1042      return executeCommand(commandObjects.lmpop(direction, keys));
1043    }
1044    @Override
1045    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
1046      return executeCommand(commandObjects.lmpop(direction, count, keys));
1047    }
1048    @Override
1049    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
1050      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1051    }
1052    @Override
1053    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
1054      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1055    }
1056    @Override
1057    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1058      return executeCommand(commandObjects.lmpop(direction, keys));
1059    }
1060    @Override
1061    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1062      return executeCommand(commandObjects.lmpop(direction, count, keys));
1063    }
1064    @Override
1065    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1066      return executeCommand(commandObjects.blmpop(timeout, direction, keys));
1067    }
1068    @Override
1069    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1070      return executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1071    }
1072    @Override
1073    public long hset(String key, String field, String value) {
1074      return executeCommand(commandObjects.hset(key, field, value));
1075    }
1076    @Override
1077    public long hset(String key, Map&lt;String, String&gt; hash) {
1078      return executeCommand(commandObjects.hset(key, hash));
1079    }
1080    @Override
1081    public String hget(String key, String field) {
1082      return executeCommand(commandObjects.hget(key, field));
1083    }
1084    @Override
1085    public long hsetnx(String key, String field, String value) {
1086      return executeCommand(commandObjects.hsetnx(key, field, value));
1087    }
1088    @Override
1089    public String hmset(String key, Map&lt;String, String&gt; hash) {
1090      return executeCommand(commandObjects.hmset(key, hash));
1091    }
1092    @Override
1093    public List&lt;String&gt; hmget(String key, String... fields) {
1094      return executeCommand(commandObjects.hmget(key, fields));
1095    }
1096    @Override
1097    public long hset(byte[] key, byte[] field, byte[] value) {
1098      return executeCommand(commandObjects.hset(key, field, value));
1099    }
1100    @Override
1101    public long hset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1102      return executeCommand(commandObjects.hset(key, hash));
1103    }
1104    @Override
1105    public byte[] hget(byte[] key, byte[] field) {
1106      return executeCommand(commandObjects.hget(key, field));
1107    }
1108    @Override
1109    public long hsetnx(byte[] key, byte[] field, byte[] value) {
1110      return executeCommand(commandObjects.hsetnx(key, field, value));
1111    }
1112    @Override
1113    public String hmset(byte[] key, Map&lt;byte[], byte[]&gt; hash) {
1114      return executeCommand(commandObjects.hmset(key, hash));
1115    }
1116    @Override
1117    public List&lt;byte[]&gt; hmget(byte[] key, byte[]... fields) {
1118      return executeCommand(commandObjects.hmget(key, fields));
1119    }
1120    @Override
1121    public long hincrBy(String key, String field, long value) {
1122      return executeCommand(commandObjects.hincrBy(key, field, value));
1123    }
1124    @Override
1125    public double hincrByFloat(String key, String field, double value) {
1126      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1127    }
1128    @Override
1129    public boolean hexists(String key, String field) {
1130      return executeCommand(commandObjects.hexists(key, field));
1131    }
1132    @Override
1133    public long hdel(String key, String... field) {
1134      return executeCommand(commandObjects.hdel(key, field));
1135    }
1136    @Override
1137    public long hlen(String key) {
1138      return executeCommand(commandObjects.hlen(key));
1139    }
1140    @Override
1141    public long hincrBy(byte[] key, byte[] field, long value) {
1142      return executeCommand(commandObjects.hincrBy(key, field, value));
1143    }
1144    @Override
1145    public double hincrByFloat(byte[] key, byte[] field, double value) {
1146      return executeCommand(commandObjects.hincrByFloat(key, field, value));
1147    }
1148    @Override
1149    public boolean hexists(byte[] key, byte[] field) {
1150      return executeCommand(commandObjects.hexists(key, field));
1151    }
1152    @Override
1153    public long hdel(byte[] key, byte[]... field) {
1154      return executeCommand(commandObjects.hdel(key, field));
1155    }
1156    @Override
1157    public long hlen(byte[] key) {
1158      return executeCommand(commandObjects.hlen(key));
1159    }
1160    @Override
1161    public Set&lt;String&gt; hkeys(String key) {
1162      return executeCommand(commandObjects.hkeys(key));
1163    }
1164    @Override
1165    public List&lt;String&gt; hvals(String key) {
1166      return executeCommand(commandObjects.hvals(key));
1167    }
1168    @Override
1169    public Map&lt;String, String&gt; hgetAll(String key) {
1170      return executeCommand(commandObjects.hgetAll(key));
1171    }
1172    @Override
1173    public Set&lt;byte[]&gt; hkeys(byte[] key) {
1174      return executeCommand(commandObjects.hkeys(key));
1175    }
1176    @Override
1177    public List&lt;byte[]&gt; hvals(byte[] key) {
1178      return executeCommand(commandObjects.hvals(key));
1179    }
1180    @Override
1181    public Map&lt;byte[], byte[]&gt; hgetAll(byte[] key) {
1182      return executeCommand(commandObjects.hgetAll(key));
1183    }
1184    @Override
1185    public String hrandfield(String key) {
1186      return executeCommand(commandObjects.hrandfield(key));
1187    }
1188    @Override
1189    public List&lt;String&gt; hrandfield(String key, long count) {
1190      return executeCommand(commandObjects.hrandfield(key, count));
1191    }
1192    @Override
1193    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(String key, long count) {
1194      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1195    }
1196    @Override
1197    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(String key, String cursor, ScanParams params) {
1198      return executeCommand(commandObjects.hscan(key, cursor, params));
1199    }
1200    @Override
1201    public long hstrlen(String key, String field) {
1202      return executeCommand(commandObjects.hstrlen(key, field));
1203    }
1204    @Override
1205    public byte[] hrandfield(byte[] key) {
1206      return executeCommand(commandObjects.hrandfield(key));
1207    }
1208    @Override
1209    public List&lt;byte[]&gt; hrandfield(byte[] key, long count) {
1210      return executeCommand(commandObjects.hrandfield(key, count));
1211    }
1212    @Override
1213    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(byte[] key, long count) {
1214      return executeCommand(commandObjects.hrandfieldWithValues(key, count));
1215    }
1216    @Override
1217    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(byte[] key, byte[] cursor, ScanParams params) {
1218      return executeCommand(commandObjects.hscan(key, cursor, params));
1219    }
1220    @Override
1221    public long hstrlen(byte[] key, byte[] field) {
1222      return executeCommand(commandObjects.hstrlen(key, field));
1223    }
1224    @Override
1225    public long sadd(String key, String... members) {
1226      return executeCommand(commandObjects.sadd(key, members));
1227    }
1228    @Override
1229    public Set&lt;String&gt; smembers(String key) {
1230      return executeCommand(commandObjects.smembers(key));
1231    }
1232    @Override
1233    public long srem(String key, String... members) {
1234      return executeCommand(commandObjects.srem(key, members));
1235    }
1236    @Override
1237    public String spop(String key) {
1238      return executeCommand(commandObjects.spop(key));
1239    }
1240    @Override
1241    public Set&lt;String&gt; spop(String key, long count) {
1242      return executeCommand(commandObjects.spop(key, count));
1243    }
1244    @Override
1245    public long scard(String key) {
1246      return executeCommand(commandObjects.scard(key));
1247    }
1248    @Override
1249    public boolean sismember(String key, String member) {
1250      return executeCommand(commandObjects.sismember(key, member));
1251    }
1252    @Override
1253    public List&lt;Boolean&gt; smismember(String key, String... members) {
1254      return executeCommand(commandObjects.smismember(key, members));
1255    }
1256    @Override
1257    public long sadd(byte[] key, byte[]... members) {
1258      return executeCommand(commandObjects.sadd(key, members));
1259    }
1260    @Override
1261    public Set&lt;byte[]&gt; smembers(byte[] key) {
1262      return executeCommand(commandObjects.smembers(key));
1263    }
1264    @Override
1265    public long srem(byte[] key, byte[]... members) {
1266      return executeCommand(commandObjects.srem(key, members));
1267    }
1268    @Override
1269    public byte[] spop(byte[] key) {
1270      return executeCommand(commandObjects.spop(key));
1271    }
1272    @Override
1273    public Set&lt;byte[]&gt; spop(byte[] key, long count) {
1274      return executeCommand(commandObjects.spop(key, count));
1275    }
1276    @Override
1277    public long scard(byte[] key) {
1278      return executeCommand(commandObjects.scard(key));
1279    }
1280    @Override
1281    public boolean sismember(byte[] key, byte[] member) {
1282      return executeCommand(commandObjects.sismember(key, member));
1283    }
1284    @Override
1285    public List&lt;Boolean&gt; smismember(byte[] key, byte[]... members) {
1286      return executeCommand(commandObjects.smismember(key, members));
1287    }
1288    @Override
1289    public String srandmember(String key) {
1290      return executeCommand(commandObjects.srandmember(key));
1291    }
1292    @Override
1293    public List&lt;String&gt; srandmember(String key, int count) {
1294      return executeCommand(commandObjects.srandmember(key, count));
1295    }
1296    @Override
1297    public ScanResult&lt;String&gt; sscan(String key, String cursor, ScanParams params) {
1298      return executeCommand(commandObjects.sscan(key, cursor, params));
1299    }
1300    @Override
1301    public byte[] srandmember(byte[] key) {
1302      return executeCommand(commandObjects.srandmember(key));
1303    }
1304    @Override
1305    public List&lt;byte[]&gt; srandmember(byte[] key, int count) {
1306      return executeCommand(commandObjects.srandmember(key, count));
1307    }
1308    @Override
1309    public ScanResult&lt;byte[]&gt; sscan(byte[] key, byte[] cursor, ScanParams params) {
1310      return executeCommand(commandObjects.sscan(key, cursor, params));
1311    }
1312    @Override
1313    public Set&lt;String&gt; sdiff(String... keys) {
1314      return executeCommand(commandObjects.sdiff(keys));
1315    }
1316    @Override
1317    public long sdiffstore(String dstkey, String... keys) {
1318      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1319    }
1320    @Override
1321    public Set&lt;String&gt; sinter(String... keys) {
1322      return executeCommand(commandObjects.sinter(keys));
1323    }
1324    @Override
1325    public long sinterstore(String dstkey, String... keys) {
1326      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1327    }
1328    @Override
1329    public long sintercard(String... keys) {
1330      return executeCommand(commandObjects.sintercard(keys));
1331    }
1332    @Override
1333    public long sintercard(int limit, String... keys) {
1334      return executeCommand(commandObjects.sintercard(limit, keys));
1335    }
1336    @Override
1337    public Set&lt;String&gt; sunion(String... keys) {
1338      return executeCommand(commandObjects.sunion(keys));
1339    }
1340    @Override
1341    public long sunionstore(String dstkey, String... keys) {
1342      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1343    }
1344    @Override
1345    public long smove(String srckey, String dstkey, String member) {
1346      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1347    }
1348    @Override
1349    public Set&lt;byte[]&gt; sdiff(byte[]... keys) {
1350      return executeCommand(commandObjects.sdiff(keys));
1351    }
1352    @Override
1353    public long sdiffstore(byte[] dstkey, byte[]... keys) {
1354      return executeCommand(commandObjects.sdiffstore(dstkey, keys));
1355    }
1356    @Override
1357    public Set&lt;byte[]&gt; sinter(byte[]... keys) {
1358      return executeCommand(commandObjects.sinter(keys));
1359    }
1360    @Override
1361    public long sinterstore(byte[] dstkey, byte[]... keys) {
1362      return executeCommand(commandObjects.sinterstore(dstkey, keys));
1363    }
1364    @Override
1365    public long sintercard(byte[]... keys) {
1366      return executeCommand(commandObjects.sintercard(keys));
1367    }
1368    @Override
1369    public long sintercard(int limit, byte[]... keys) {
1370      return executeCommand(commandObjects.sintercard(limit, keys));
1371    }
1372    @Override
1373    public Set&lt;byte[]&gt; sunion(byte[]... keys) {
1374      return executeCommand(commandObjects.sunion(keys));
1375    }
1376    @Override
1377    public long sunionstore(byte[] dstkey, byte[]... keys) {
1378      return executeCommand(commandObjects.sunionstore(dstkey, keys));
1379    }
1380    @Override
1381    public long smove(byte[] srckey, byte[] dstkey, byte[] member) {
1382      return executeCommand(commandObjects.smove(srckey, dstkey, member));
1383    }
1384    @Override
1385    public long zadd(String key, double score, String member) {
1386      return executeCommand(commandObjects.zadd(key, score, member));
1387    }
1388    @Override
1389    public long zadd(String key, double score, String member, ZAddParams params) {
1390      return executeCommand(commandObjects.zadd(key, score, member, params));
1391    }
1392    @Override
1393    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers) {
1394      return executeCommand(commandObjects.zadd(key, scoreMembers));
1395    }
1396    @Override
1397    public long zadd(String key, Map&lt;String, Double&gt; scoreMembers, ZAddParams params) {
1398      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1399    }
1400    @Override
1401    public Double zaddIncr(String key, double score, String member, ZAddParams params) {
1402      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1403    }
1404    @Override
1405    public long zadd(byte[] key, double score, byte[] member) {
1406      return executeCommand(commandObjects.zadd(key, score, member));
1407    }
1408    @Override
1409    public long zadd(byte[] key, double score, byte[] member, ZAddParams params) {
1410      return executeCommand(commandObjects.zadd(key, score, member, params));
1411    }
1412    @Override
1413    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers) {
1414      return executeCommand(commandObjects.zadd(key, scoreMembers));
1415    }
1416    @Override
1417    public long zadd(byte[] key, Map&lt;byte[], Double&gt; scoreMembers, ZAddParams params) {
1418      return executeCommand(commandObjects.zadd(key, scoreMembers, params));
1419    }
1420    @Override
1421    public Double zaddIncr(byte[] key, double score, byte[] member, ZAddParams params) {
1422      return executeCommand(commandObjects.zaddIncr(key, score, member, params));
1423    }
1424    @Override
1425    public long zrem(String key, String... members) {
1426      return executeCommand(commandObjects.zrem(key, members));
1427    }
1428    @Override
1429    public double zincrby(String key, double increment, String member) {
1430      return executeCommand(commandObjects.zincrby(key, increment, member));
1431    }
1432    @Override
1433    public Double zincrby(String key, double increment, String member, ZIncrByParams params) {
1434      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1435    }
1436    @Override
1437    public Long zrank(String key, String member) {
1438      return executeCommand(commandObjects.zrank(key, member));
1439    }
1440    @Override
1441    public Long zrevrank(String key, String member) {
1442      return executeCommand(commandObjects.zrevrank(key, member));
1443    }
1444    @Override
1445    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
1446      return executeCommand(commandObjects.zrankWithScore(key, member));
1447    }
1448    @Override
1449    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
1450      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1451    }
1452    @Override
1453    public long zrem(byte[] key, byte[]... members) {
1454      return executeCommand(commandObjects.zrem(key, members));
1455    }
1456    @Override
1457    public double zincrby(byte[] key, double increment, byte[] member) {
1458      return executeCommand(commandObjects.zincrby(key, increment, member));
1459    }
1460    @Override
1461    public Double zincrby(byte[] key, double increment, byte[] member, ZIncrByParams params) {
1462      return executeCommand(commandObjects.zincrby(key, increment, member, params));
1463    }
1464    @Override
1465    public Long zrank(byte[] key, byte[] member) {
1466      return executeCommand(commandObjects.zrank(key, member));
1467    }
1468    @Override
1469    public Long zrevrank(byte[] key, byte[] member) {
1470      return executeCommand(commandObjects.zrevrank(key, member));
1471    }
1472    @Override
1473    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
1474      return executeCommand(commandObjects.zrankWithScore(key, member));
1475    }
1476    @Override
1477    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
1478      return executeCommand(commandObjects.zrevrankWithScore(key, member));
1479    }
1480    @Override
1481    public String zrandmember(String key) {
1482      return executeCommand(commandObjects.zrandmember(key));
1483    }
1484    @Override
1485    public List&lt;String&gt; zrandmember(String key, long count) {
1486      return executeCommand(commandObjects.zrandmember(key, count));
1487    }
1488    @Override
1489    public List&lt;Tuple&gt; zrandmemberWithScores(String key, long count) {
1490      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1491    }
1492    @Override
1493    public long zcard(String key) {
1494      return executeCommand(commandObjects.zcard(key));
1495    }
1496    @Override
1497    public Double zscore(String key, String member) {
1498      return executeCommand(commandObjects.zscore(key, member));
1499    }
1500    @Override
1501    public List&lt;Double&gt; zmscore(String key, String... members) {
1502      return executeCommand(commandObjects.zmscore(key, members));
1503    }
1504    @Override
1505    public byte[] zrandmember(byte[] key) {
1506      return executeCommand(commandObjects.zrandmember(key));
1507    }
1508    @Override
1509    public List&lt;byte[]&gt; zrandmember(byte[] key, long count) {
1510      return executeCommand(commandObjects.zrandmember(key, count));
1511    }
1512    @Override
1513    public List&lt;Tuple&gt; zrandmemberWithScores(byte[] key, long count) {
1514      return executeCommand(commandObjects.zrandmemberWithScores(key, count));
1515    }
1516    @Override
1517    public long zcard(byte[] key) {
1518      return executeCommand(commandObjects.zcard(key));
1519    }
1520    @Override
1521    public Double zscore(byte[] key, byte[] member) {
1522      return executeCommand(commandObjects.zscore(key, member));
1523    }
1524    @Override
1525    public List&lt;Double&gt; zmscore(byte[] key, byte[]... members) {
1526      return executeCommand(commandObjects.zmscore(key, members));
1527    }
1528    @Override
1529    public Tuple zpopmax(String key) {
1530      return executeCommand(commandObjects.zpopmax(key));
1531    }
1532    @Override
1533    public List&lt;Tuple&gt; zpopmax(String key, int count) {
1534      return executeCommand(commandObjects.zpopmax(key, count));
1535    }
1536    @Override
1537    public Tuple zpopmin(String key) {
1538      return executeCommand(commandObjects.zpopmin(key));
1539    }
1540    @Override
1541    public List&lt;Tuple&gt; zpopmin(String key, int count) {
1542      return executeCommand(commandObjects.zpopmin(key, count));
1543    }
1544    @Override
1545    public long zcount(String key, double min, double max) {
1546      return executeCommand(commandObjects.zcount(key, min, max));
1547    }
1548    @Override
1549    public long zcount(String key, String min, String max) {
1550      return executeCommand(commandObjects.zcount(key, min, max));
1551    }
1552    @Override
1553    public Tuple zpopmax(byte[] key) {
1554      return executeCommand(commandObjects.zpopmax(key));
1555    }
1556    @Override
1557    public List&lt;Tuple&gt; zpopmax(byte[] key, int count) {
1558      return executeCommand(commandObjects.zpopmax(key, count));
1559    }
1560    @Override
1561    public Tuple zpopmin(byte[] key) {
1562      return executeCommand(commandObjects.zpopmin(key));
1563    }
1564    @Override
1565    public List&lt;Tuple&gt; zpopmin(byte[] key, int count) {
1566      return executeCommand(commandObjects.zpopmin(key, count));
1567    }
1568    @Override
1569    public long zcount(byte[] key, double min, double max) {
1570      return executeCommand(commandObjects.zcount(key, min, max));
1571    }
1572    @Override
1573    public long zcount(byte[] key, byte[] min, byte[] max) {
1574      return executeCommand(commandObjects.zcount(key, min, max));
1575    }
1576    @Override
1577    public List&lt;String&gt; zrange(String key, long start, long stop) {
1578      return executeCommand(commandObjects.zrange(key, start, stop));
1579    }
1580    @Override
1581    public List&lt;String&gt; zrevrange(String key, long start, long stop) {
1582      return executeCommand(commandObjects.zrevrange(key, start, stop));
1583    }
1584    @Override
1585    public List&lt;Tuple&gt; zrangeWithScores(String key, long start, long stop) {
1586      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1587    }
1588    @Override
1589    public List&lt;Tuple&gt; zrevrangeWithScores(String key, long start, long stop) {
1590      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1591    }
1592    @Override
1593    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
1594      return executeCommand(commandObjects.zrange(key, zRangeParams));
1595    }
1596    @Override
1597    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
1598      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1599    }
1600    @Override
1601    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
1602      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1603    }
1604    @Override
1605    public List&lt;String&gt; zrangeByScore(String key, double min, double max) {
1606      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1607    }
1608    @Override
1609    public List&lt;String&gt; zrangeByScore(String key, String min, String max) {
1610      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1611    }
1612    @Override
1613    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min) {
1614      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1615    }
1616    @Override
1617    public List&lt;String&gt; zrangeByScore(String key, double min, double max, int offset, int count) {
1618      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1619    }
1620    @Override
1621    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min) {
1622      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1623    }
1624    @Override
1625    public List&lt;String&gt; zrangeByScore(String key, String min, String max, int offset, int count) {
1626      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1627    }
1628    @Override
1629    public List&lt;String&gt; zrevrangeByScore(String key, double max, double min, int offset, int count) {
1630      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1631    }
1632    @Override
1633    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max) {
1634      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1635    }
1636    @Override
1637    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min) {
1638      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1639    }
1640    @Override
1641    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, double min, double max, int offset, int count) {
1642      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1643    }
1644    @Override
1645    public List&lt;String&gt; zrevrangeByScore(String key, String max, String min, int offset, int count) {
1646      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1647    }
1648    @Override
1649    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max) {
1650      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1651    }
1652    @Override
1653    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min) {
1654      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1655    }
1656    @Override
1657    public List&lt;Tuple&gt; zrangeByScoreWithScores(String key, String min, String max, int offset, int count) {
1658      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1659    }
1660    @Override
1661    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) {
1662      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1663    }
1664    @Override
1665    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count) {
1666      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1667    }
1668    @Override
1669    public List&lt;byte[]&gt; zrange(byte[] key, long start, long stop) {
1670      return executeCommand(commandObjects.zrange(key, start, stop));
1671    }
1672    @Override
1673    public List&lt;byte[]&gt; zrevrange(byte[] key, long start, long stop) {
1674      return executeCommand(commandObjects.zrevrange(key, start, stop));
1675    }
1676    @Override
1677    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, long start, long stop) {
1678      return executeCommand(commandObjects.zrangeWithScores(key, start, stop));
1679    }
1680    @Override
1681    public List&lt;Tuple&gt; zrevrangeWithScores(byte[] key, long start, long stop) {
1682      return executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
1683    }
1684    @Override
1685    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
1686      return executeCommand(commandObjects.zrange(key, zRangeParams));
1687    }
1688    @Override
1689    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
1690      return executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
1691    }
1692    @Override
1693    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
1694      return executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
1695    }
1696    @Override
1697    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max) {
1698      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1699    }
1700    @Override
1701    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max) {
1702      return executeCommand(commandObjects.zrangeByScore(key, min, max));
1703    }
1704    @Override
1705    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min) {
1706      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1707    }
1708    @Override
1709    public List&lt;byte[]&gt; zrangeByScore(byte[] key, double min, double max, int offset, int count) {
1710      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1711    }
1712    @Override
1713    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
1714      return executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1715    }
1716    @Override
1717    public List&lt;byte[]&gt; zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count) {
1718      return executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1719    }
1720    @Override
1721    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, double max, double min, int offset, int count) {
1722      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1723    }
1724    @Override
1725    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max) {
1726      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1727    }
1728    @Override
1729    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min) {
1730      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1731    }
1732    @Override
1733    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count) {
1734      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1735    }
1736    @Override
1737    public List&lt;byte[]&gt; zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count) {
1738      return executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1739    }
1740    @Override
1741    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
1742      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1743    }
1744    @Override
1745    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
1746      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1747    }
1748    @Override
1749    public List&lt;Tuple&gt; zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count) {
1750      return executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1751    }
1752    @Override
1753    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count) {
1754      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1755    }
1756    @Override
1757    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count) {
1758      return executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1759    }
1760    @Override
1761    public long zremrangeByRank(String key, long start, long stop) {
1762      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1763    }
1764    @Override
1765    public long zremrangeByScore(String key, double min, double max) {
1766      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1767    }
1768    @Override
1769    public long zremrangeByScore(String key, String min, String max) {
1770      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1771    }
1772    @Override
1773    public long zremrangeByRank(byte[] key, long start, long stop) {
1774      return executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1775    }
1776    @Override
1777    public long zremrangeByScore(byte[] key, double min, double max) {
1778      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1779    }
1780    @Override
1781    public long zremrangeByScore(byte[] key, byte[] min, byte[] max) {
1782      return executeCommand(commandObjects.zremrangeByScore(key, min, max));
1783    }
1784    @Override
1785    public long zlexcount(String key, String min, String max) {
1786      return executeCommand(commandObjects.zlexcount(key, min, max));
1787    }
1788    @Override
1789    public List&lt;String&gt; zrangeByLex(String key, String min, String max) {
1790      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1791    }
1792    @Override
1793    public List&lt;String&gt; zrangeByLex(String key, String min, String max, int offset, int count) {
1794      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1795    }
1796    @Override
1797    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min) {
1798      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1799    }
1800    @Override
1801    public List&lt;String&gt; zrevrangeByLex(String key, String max, String min, int offset, int count) {
1802      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1803    }
1804    @Override
1805    public long zremrangeByLex(String key, String min, String max) {
1806      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1807    }
1808    @Override
1809    public long zlexcount(byte[] key, byte[] min, byte[] max) {
1810      return executeCommand(commandObjects.zlexcount(key, min, max));
1811    }
1812    @Override
1813    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max) {
1814      return executeCommand(commandObjects.zrangeByLex(key, min, max));
1815    }
1816    @Override
1817    public List&lt;byte[]&gt; zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count) {
1818      return executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1819    }
1820    @Override
1821    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
1822      return executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1823    }
1824    @Override
1825    public List&lt;byte[]&gt; zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
1826      return executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1827    }
1828    @Override
1829    public long zremrangeByLex(byte[] key, byte[] min, byte[] max) {
1830      return executeCommand(commandObjects.zremrangeByLex(key, min, max));
1831    }
1832    @Override
1833    public ScanResult&lt;Tuple&gt; zscan(String key, String cursor, ScanParams params) {
1834      return executeCommand(commandObjects.zscan(key, cursor, params));
1835    }
1836    @Override
1837    public ScanResult&lt;Tuple&gt; zscan(byte[] key, byte[] cursor, ScanParams params) {
1838      return executeCommand(commandObjects.zscan(key, cursor, params));
1839    }
1840    @Override
1841    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
1842      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1843    }
1844    @Override
1845    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
1846      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1847    }
1848    @Override
1849    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(double timeout, byte[]... keys) {
1850      return executeCommand(commandObjects.bzpopmax(timeout, keys));
1851    }
1852    @Override
1853    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(double timeout, byte[]... keys) {
1854      return executeCommand(commandObjects.bzpopmin(timeout, keys));
1855    }
1856    @Override
1857    public List&lt;String&gt; zdiff(String... keys) {
1858      return executeCommand(commandObjects.zdiff(keys));
1859    }
1860    @Override
1861    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
1862      return executeCommand(commandObjects.zdiffWithScores(keys));
1863    }
1864    @Override
1865    @Deprecated
1866    public long zdiffStore(String dstkey, String... keys) {
1867      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1868    }
1869    @Override
1870    public long zdiffstore(String dstkey, String... keys) {
1871      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1872    }
1873    @Override
1874    public List&lt;byte[]&gt; zdiff(byte[]... keys) {
1875      return executeCommand(commandObjects.zdiff(keys));
1876    }
1877    @Override
1878    public List&lt;Tuple&gt; zdiffWithScores(byte[]... keys) {
1879      return executeCommand(commandObjects.zdiffWithScores(keys));
1880    }
1881    @Override
1882    @Deprecated
1883    public long zdiffStore(byte[] dstkey, byte[]... keys) {
1884      return executeCommand(commandObjects.zdiffStore(dstkey, keys));
1885    }
1886    @Override
1887    public long zdiffstore(byte[] dstkey, byte[]... keys) {
1888      return executeCommand(commandObjects.zdiffstore(dstkey, keys));
1889    }
1890    @Override
1891    public long zinterstore(String dstkey, String... sets) {
1892      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1893    }
1894    @Override
1895    public long zinterstore(String dstkey, ZParams params, String... sets) {
1896      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1897    }
1898    @Override
1899    public List&lt;String&gt; zinter(ZParams params, String... keys) {
1900      return executeCommand(commandObjects.zinter(params, keys));
1901    }
1902    @Override
1903    public List&lt;Tuple&gt; zinterWithScores(ZParams params, String... keys) {
1904      return executeCommand(commandObjects.zinterWithScores(params, keys));
1905    }
1906    @Override
1907    public long zinterstore(byte[] dstkey, byte[]... sets) {
1908      return executeCommand(commandObjects.zinterstore(dstkey, sets));
1909    }
1910    @Override
1911    public long zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
1912      return executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1913    }
1914    @Override
1915    public long zintercard(byte[]... keys) {
1916      return executeCommand(commandObjects.zintercard(keys));
1917    }
1918    @Override
1919    public long zintercard(long limit, byte[]... keys) {
1920      return executeCommand(commandObjects.zintercard(limit, keys));
1921    }
1922    @Override
1923    public long zintercard(String... keys) {
1924      return executeCommand(commandObjects.zintercard(keys));
1925    }
1926    @Override
1927    public long zintercard(long limit, String... keys) {
1928      return executeCommand(commandObjects.zintercard(limit, keys));
1929    }
1930    @Override
1931    public List&lt;byte[]&gt; zinter(ZParams params, byte[]... keys) {
1932      return executeCommand(commandObjects.zinter(params, keys));
1933    }
1934    @Override
1935    public List&lt;Tuple&gt; zinterWithScores(ZParams params, byte[]... keys) {
1936      return executeCommand(commandObjects.zinterWithScores(params, keys));
1937    }
1938    @Override
1939    public List&lt;String&gt; zunion(ZParams params, String... keys) {
1940      return executeCommand(commandObjects.zunion(params, keys));
1941    }
1942    @Override
1943    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
1944      return executeCommand(commandObjects.zunionWithScores(params, keys));
1945    }
1946    @Override
1947    public long zunionstore(String dstkey, String... sets) {
1948      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1949    }
1950    @Override
1951    public long zunionstore(String dstkey, ZParams params, String... sets) {
1952      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1953    }
1954    @Override
1955    public List&lt;byte[]&gt; zunion(ZParams params, byte[]... keys) {
1956      return executeCommand(commandObjects.zunion(params, keys));
1957    }
1958    @Override
1959    public List&lt;Tuple&gt; zunionWithScores(ZParams params, byte[]... keys) {
1960      return executeCommand(commandObjects.zunionWithScores(params, keys));
1961    }
1962    @Override
1963    public long zunionstore(byte[] dstkey, byte[]... sets) {
1964      return executeCommand(commandObjects.zunionstore(dstkey, sets));
1965    }
1966    @Override
1967    public long zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
1968      return executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1969    }
1970    @Override
1971    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
1972      return executeCommand(commandObjects.zmpop(option, keys));
1973    }
1974    @Override
1975    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
1976      return executeCommand(commandObjects.zmpop(option, count, keys));
1977    }
1978    @Override
1979    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
1980      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1981    }
1982    @Override
1983    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
1984      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1985    }
1986    @Override
1987    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1988      return executeCommand(commandObjects.zmpop(option, keys));
1989    }
1990    @Override
1991    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1992      return executeCommand(commandObjects.zmpop(option, count, keys));
1993    }
1994    @Override
1995    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1996      return executeCommand(commandObjects.bzmpop(timeout, option, keys));
1997    }
1998    @Override
1999    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
2000      return executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
2001    }
2002    @Override
2003    public long geoadd(String key, double longitude, double latitude, String member) {
2004      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2005    }
2006    @Override
2007    public long geoadd(String key, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2008      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2009    }
2010    @Override
2011    public long geoadd(String key, GeoAddParams params, Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
2012      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2013    }
2014    @Override
2015    public Double geodist(String key, String member1, String member2) {
2016      return executeCommand(commandObjects.geodist(key, member1, member2));
2017    }
2018    @Override
2019    public Double geodist(String key, String member1, String member2, GeoUnit unit) {
2020      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2021    }
2022    @Override
2023    public List&lt;String&gt; geohash(String key, String... members) {
2024      return executeCommand(commandObjects.geohash(key, members));
2025    }
2026    @Override
2027    public List&lt;GeoCoordinate&gt; geopos(String key, String... members) {
2028      return executeCommand(commandObjects.geopos(key, members));
2029    }
2030    @Override
2031    public long geoadd(byte[] key, double longitude, double latitude, byte[] member) {
2032      return executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2033    }
2034    @Override
2035    public long geoadd(byte[] key, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2036      return executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2037    }
2038    @Override
2039    public long geoadd(byte[] key, GeoAddParams params, Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2040      return executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2041    }
2042    @Override
2043    public Double geodist(byte[] key, byte[] member1, byte[] member2) {
2044      return executeCommand(commandObjects.geodist(key, member1, member2));
2045    }
2046    @Override
2047    public Double geodist(byte[] key, byte[] member1, byte[] member2, GeoUnit unit) {
2048      return executeCommand(commandObjects.geodist(key, member1, member2, unit));
2049    }
2050    @Override
2051    public List&lt;byte[]&gt; geohash(byte[] key, byte[]... members) {
2052      return executeCommand(commandObjects.geohash(key, members));
2053    }
2054    @Override
2055    public List&lt;GeoCoordinate&gt; geopos(byte[] key, byte[]... members) {
2056      return executeCommand(commandObjects.geopos(key, members));
2057    }
2058    @Override
2059    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2060      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2061    }
2062    @Override
2063    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit) {
2064      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2065    }
2066    @Override
2067    public List&lt;GeoRadiusResponse&gt; georadius(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2068      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2069    }
2070    @Override
2071    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2072      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2073    }
2074    @Override
2075    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit) {
2076      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2077    }
2078    @Override
2079    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit) {
2080      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2081    }
2082    @Override
2083    public List&lt;GeoRadiusResponse&gt; georadiusByMember(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2084      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2085    }
2086    @Override
2087    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
2088      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2089    }
2090    @Override
2091    public long georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2092      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2093    }
2094    @Override
2095    public long georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2096      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2097    }
2098    @Override
<span onclick='openModal()' class='match'>2099    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
2100      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
</span>2101    }
2102    @Override
2103    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
2104      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2105    }
2106    @Override
2107    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
2108      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2112      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2113    }
2114    @Override
2115    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
2116      return executeCommand(commandObjects.geosearch(key, params));
2117    }
2118    @Override
2119    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
2120      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2121    }
2122    @Override
2123    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
2124      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2125    }
2126    @Override
2127    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
2128      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2129    }
2130    @Override
2131    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2132      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2133    }
2134    @Override
2135    public long geosearchStore(String dest, String src, GeoSearchParam params) {
2136      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2137    }
2138    @Override
2139    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
2140      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2141    }
2142    @Override
2143    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2144      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2145    }
2146    @Override
2147    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
2148      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2152      return executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2153    }
2154    @Override
2155    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
2156      return executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2157    }
2158    @Override
2159    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit) {
2160      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2161    }
2162    @Override
2163    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit) {
2164      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2165    }
2166    @Override
2167    public List&lt;GeoRadiusResponse&gt; georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2168      return executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2169    }
2170    @Override
2171    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
2172      return executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2173    }
2174    @Override
2175    public long georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2176      return executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2177    }
2178    @Override
2179    public long georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
2180      return executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2181    }
2182    @Override
2183    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2184      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
2185    }
2186    @Override
2187    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2188      return executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2189    }
2190    @Override
2191    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2192      return executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2193    }
2194    @Override
2195    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2196      return executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2197    }
2198    @Override
2199    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2200      return executeCommand(commandObjects.geosearch(key, params));
2201    }
2202    @Override
2203    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2204      return executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2205    }
2206    @Override
2207    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2208      return executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2209    }
2210    @Override
2211    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2212      return executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2213    }
2214    @Override
2215    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2216      return executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2217    }
2218    @Override
2219    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2220      return executeCommand(commandObjects.geosearchStore(dest, src, params));
2221    }
2222    @Override
2223    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2224      return executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2225    }
2226    @Override
2227    public long pfadd(String key, String... elements) {
2228      return executeCommand(commandObjects.pfadd(key, elements));
2229    }
2230    @Override
2231    public String pfmerge(String destkey, String... sourcekeys) {
2232      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2233    }
2234    @Override
2235    public long pfcount(String key) {
2236      return executeCommand(commandObjects.pfcount(key));
2237    }
2238    @Override
2239    public long pfcount(String... keys) {
2240      return executeCommand(commandObjects.pfcount(keys));
2241    }
2242    @Override
2243    public long pfadd(byte[] key, byte[]... elements) {
2244      return executeCommand(commandObjects.pfadd(key, elements));
2245    }
2246    @Override
2247    public String pfmerge(byte[] destkey, byte[]... sourcekeys) {
2248      return executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
2249    }
2250    @Override
2251    public long pfcount(byte[] key) {
2252      return executeCommand(commandObjects.pfcount(key));
2253    }
2254    @Override
2255    public long pfcount(byte[]... keys) {
2256      return executeCommand(commandObjects.pfcount(keys));
2257    }
2258    @Override
2259    public StreamEntryID xadd(String key, StreamEntryID id, Map&lt;String, String&gt; hash) {
2260      return executeCommand(commandObjects.xadd(key, id, hash));
2261    }
2262    @Override
2263    public StreamEntryID xadd(String key, XAddParams params, Map&lt;String, String&gt; hash) {
2264      return executeCommand(commandObjects.xadd(key, params, hash));
2265    }
2266    @Override
2267    public long xlen(String key) {
2268      return executeCommand(commandObjects.xlen(key));
2269    }
2270    @Override
2271    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end) {
2272      return executeCommand(commandObjects.xrange(key, start, end));
2273    }
2274    @Override
2275    public List&lt;StreamEntry&gt; xrange(String key, StreamEntryID start, StreamEntryID end, int count) {
2276      return executeCommand(commandObjects.xrange(key, start, end, count));
2277    }
2278    @Override
2279    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start) {
2280      return executeCommand(commandObjects.xrevrange(key, end, start));
2281    }
2282    @Override
2283    public List&lt;StreamEntry&gt; xrevrange(String key, StreamEntryID end, StreamEntryID start, int count) {
2284      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2285    }
2286    @Override
2287    public List&lt;StreamEntry&gt; xrange(String key, String start, String end) {
2288      return executeCommand(commandObjects.xrange(key, start, end));
2289    }
2290    @Override
2291    public List&lt;StreamEntry&gt; xrange(String key, String start, String end, int count) {
2292      return executeCommand(commandObjects.xrange(key, start, end, count));
2293    }
2294    @Override
2295    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start) {
2296      return executeCommand(commandObjects.xrevrange(key, end, start));
2297    }
2298    @Override
2299    public List&lt;StreamEntry&gt; xrevrange(String key, String end, String start, int count) {
2300      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2301    }
2302    @Override
2303    public long xack(String key, String group, StreamEntryID... ids) {
2304      return executeCommand(commandObjects.xack(key, group, ids));
2305    }
2306    @Override
2307    public String xgroupCreate(String key, String groupName, StreamEntryID id, boolean makeStream) {
2308      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2309    }
2310    @Override
2311    public String xgroupSetID(String key, String groupName, StreamEntryID id) {
2312      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2313    }
2314    @Override
2315    public long xgroupDestroy(String key, String groupName) {
2316      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2317    }
2318    @Override
2319    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
2320      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2321    }
2322    @Override
2323    public long xgroupDelConsumer(String key, String groupName, String consumerName) {
2324      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2325    }
2326    @Override
2327    public StreamPendingSummary xpending(String key, String groupName) {
2328      return executeCommand(commandObjects.xpending(key, groupName));
2329    }
2330    @Override
2331    public List&lt;StreamPendingEntry&gt; xpending(String key, String groupName, XPendingParams params) {
2332      return executeCommand(commandObjects.xpending(key, groupName, params));
2333    }
2334    @Override
2335    public long xdel(String key, StreamEntryID... ids) {
2336      return executeCommand(commandObjects.xdel(key, ids));
2337    }
2338    @Override
2339    public long xtrim(String key, long maxLen, boolean approximate) {
2340      return executeCommand(commandObjects.xtrim(key, maxLen, approximate));
2341    }
2342    @Override
2343    public long xtrim(String key, XTrimParams params) {
2344      return executeCommand(commandObjects.xtrim(key, params));
2345    }
2346    @Override
2347    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2348      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2349    }
2350    @Override
2351    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
2352      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2353    }
2354    @Override
2355    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2356      return executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
2357    }
2358    @Override
2359    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
2360      return executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
2361    }
2362    @Override
2363    public StreamInfo xinfoStream(String key) {
2364      return executeCommand(commandObjects.xinfoStream(key));
2365    }
2366    @Override
2367    public StreamFullInfo xinfoStreamFull(String key) {
2368      return executeCommand(commandObjects.xinfoStreamFull(key));
2369    }
2370    @Override
2371    public StreamFullInfo xinfoStreamFull(String key, int count) {
2372      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2373    }
2374    @Override
2375    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
2376      return executeCommand(commandObjects.xinfoGroups(key));
2377    }
2378    @Override
2379    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
2380      return executeCommand(commandObjects.xinfoConsumers(key, group));
2381    }
2382    @Override
2383    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
2384      return executeCommand(commandObjects.xinfoConsumers2(key, group));
2385    }
2386    @Override
2387    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(XReadParams xReadParams, Map&lt;String, StreamEntryID&gt; streams) {
2388      return executeCommand(commandObjects.xread(xReadParams, streams));
2389    }
2390    @Override
2391    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(String groupName, String consumer,
2392        XReadGroupParams xReadGroupParams, Map&lt;String, StreamEntryID&gt; streams) {
2393      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2394    }
2395    @Override
2396    public byte[] xadd(byte[] key, XAddParams params, Map&lt;byte[], byte[]&gt; hash) {
2397      return executeCommand(commandObjects.xadd(key, params, hash));
2398    }
2399    @Override
2400    public long xlen(byte[] key) {
2401      return executeCommand(commandObjects.xlen(key));
2402    }
2403    @Override
2404    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2405      return executeCommand(commandObjects.xrange(key, start, end));
2406    }
2407    @Override
2408    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2409      return executeCommand(commandObjects.xrange(key, start, end, count));
2410    }
2411    @Override
2412    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2413      return executeCommand(commandObjects.xrevrange(key, end, start));
2414    }
2415    @Override
2416    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2417      return executeCommand(commandObjects.xrevrange(key, end, start, count));
2418    }
2419    @Override
2420    public long xack(byte[] key, byte[] group, byte[]... ids) {
2421      return executeCommand(commandObjects.xack(key, group, ids));
2422    }
2423    @Override
2424    public String xgroupCreate(byte[] key, byte[] groupName, byte[] id, boolean makeStream) {
2425      return executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2426    }
2427    @Override
2428    public String xgroupSetID(byte[] key, byte[] groupName, byte[] id) {
2429      return executeCommand(commandObjects.xgroupSetID(key, groupName, id));
2430    }
2431    @Override
2432    public long xgroupDestroy(byte[] key, byte[] groupName) {
2433      return executeCommand(commandObjects.xgroupDestroy(key, groupName));
2434    }
2435    @Override
2436    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2437      return executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2438    }
2439    @Override
2440    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2441      return executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2442    }
2443    @Override
2444    public long xdel(byte[] key, byte[]... ids) {
2445      return executeCommand(commandObjects.xdel(key, ids));
2446    }
2447    @Override
2448    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2449      return executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2450    }
2451    @Override
2452    public long xtrim(byte[] key, XTrimParams params) {
2453      return executeCommand(commandObjects.xtrim(key, params));
2454    }
2455    @Override
2456    public Object xpending(byte[] key, byte[] groupName) {
2457      return executeCommand(commandObjects.xpending(key, groupName));
2458    }
2459    @Override
2460    public List&lt;Object&gt; xpending(byte[] key, byte[] groupName, XPendingParams params) {
2461      return executeCommand(commandObjects.xpending(key, groupName, params));
2462    }
2463    @Override
2464    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2465      return executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2466    }
2467    @Override
2468    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2469      return executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2470    }
2471    @Override
2472    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2473      return executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2474    }
2475    @Override
2476    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2477      return executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2478    }
2479    @Override
2480    public Object xinfoStream(byte[] key) {
2481      return executeCommand(commandObjects.xinfoStream(key));
2482    }
2483    @Override
2484    public Object xinfoStreamFull(byte[] key) {
2485      return executeCommand(commandObjects.xinfoStreamFull(key));
2486    }
2487    @Override
2488    public Object xinfoStreamFull(byte[] key, int count) {
2489      return executeCommand(commandObjects.xinfoStreamFull(key, count));
2490    }
2491    @Override
2492    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2493      return executeCommand(commandObjects.xinfoGroups(key));
2494    }
2495    @Override
2496    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2497      return executeCommand(commandObjects.xinfoConsumers(key, group));
2498    }
2499    @Override
2500    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2501      return executeCommand(commandObjects.xread(xReadParams, streams));
2502    }
2503    @Override
2504    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry&lt;byte[], byte[]&gt;... streams) {
2505      return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2506    }
2507    @Override
2508    public Object eval(String script) {
2509      return executeCommand(commandObjects.eval(script));
2510    }
2511    @Override
2512    public Object eval(String script, int keyCount, String... params) {
2513      return executeCommand(commandObjects.eval(script, keyCount, params));
2514    }
2515    @Override
2516    public Object eval(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2517      return executeCommand(commandObjects.eval(script, keys, args));
2518    }
2519    @Override
2520    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
2521      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2522    }
2523    @Override
2524    public Object evalsha(String sha1) {
2525      return executeCommand(commandObjects.evalsha(sha1));
2526    }
2527    @Override
2528    public Object evalsha(String sha1, int keyCount, String... params) {
2529      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2530    }
2531    @Override
2532    public Object evalsha(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2533      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2534    }
2535    @Override
2536    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
2537      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2538    }
2539    @Override
2540    public Object eval(byte[] script) {
2541      return executeCommand(commandObjects.eval(script));
2542    }
2543    @Override
2544    public Object eval(byte[] script, int keyCount, byte[]... params) {
2545      return executeCommand(commandObjects.eval(script, keyCount, params));
2546    }
2547    @Override
2548    public Object eval(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2549      return executeCommand(commandObjects.eval(script, keys, args));
2550    }
2551    @Override
2552    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2553      return executeCommand(commandObjects.evalReadonly(script, keys, args));
2554    }
2555    @Override
2556    public Object evalsha(byte[] sha1) {
2557      return executeCommand(commandObjects.evalsha(sha1));
2558    }
2559    @Override
2560    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
2561      return executeCommand(commandObjects.evalsha(sha1, keyCount, params));
2562    }
2563    @Override
2564    public Object evalsha(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2565      return executeCommand(commandObjects.evalsha(sha1, keys, args));
2566    }
2567    @Override
2568    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2569      return executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2570    }
2571    @Override
2572    public Object fcall(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2573      return executeCommand(commandObjects.fcall(name, keys, args));
2574    }
2575    @Override
2576    public Object fcallReadonly(String name, List&lt;String&gt; keys, List&lt;String&gt; args) {
2577      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2578    }
2579    @Override
2580    public String functionDelete(String libraryName) {
2581      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2582    }
2583    @Override
2584    public String functionFlush() {
2585      return checkAndBroadcastCommand(commandObjects.functionFlush());
2586    }
2587    @Override
2588    public String functionFlush(FlushMode mode) {
2589      return checkAndBroadcastCommand(commandObjects.functionFlush(mode));
2590    }
2591    @Override
2592    public String functionKill() {
2593      return checkAndBroadcastCommand(commandObjects.functionKill());
2594    }
2595    @Override
2596    public List&lt;LibraryInfo&gt; functionList() {
2597      return executeCommand(commandObjects.functionList());
2598    }
2599    @Override
2600    public List&lt;LibraryInfo&gt; functionList(String libraryNamePattern) {
2601      return executeCommand(commandObjects.functionList(libraryNamePattern));
2602    }
2603    @Override
2604    public List&lt;LibraryInfo&gt; functionListWithCode() {
2605      return executeCommand(commandObjects.functionListWithCode());
2606    }
2607    @Override
2608    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
2609      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2610    }
2611    @Override
2612    public String functionLoad(String functionCode) {
2613      return executeCommand(commandObjects.functionLoad(functionCode));
2614    }
2615    @Override
2616    public String functionLoadReplace(String functionCode) {
2617      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2618    }
2619    @Override
2620    public FunctionStats functionStats() {
2621      return executeCommand(commandObjects.functionStats());
2622    }
2623    @Override
2624    public Object fcall(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2625      return executeCommand(commandObjects.fcall(name, keys, args));
2626    }
2627    @Override
2628    public Object fcallReadonly(byte[] name, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
2629      return executeCommand(commandObjects.fcallReadonly(name, keys, args));
2630    }
2631    @Override
2632    public String functionDelete(byte[] libraryName) {
2633      return checkAndBroadcastCommand(commandObjects.functionDelete(libraryName));
2634    }
2635    @Override
2636    public byte[] functionDump() {
2637      return executeCommand(commandObjects.functionDump());
2638    }
2639    @Override
2640    public List&lt;Object&gt; functionListBinary() {
2641      return executeCommand(commandObjects.functionListBinary());
2642    }
2643    @Override
2644    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
2645      return executeCommand(commandObjects.functionList(libraryNamePattern));
2646    }
2647    @Override
2648    public List&lt;Object&gt; functionListWithCodeBinary() {
2649      return executeCommand(commandObjects.functionListWithCodeBinary());
2650    }
2651    @Override
2652    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
2653      return executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
2654    }
2655    @Override
2656    public String functionLoad(byte[] functionCode) {
2657      return executeCommand(commandObjects.functionLoad(functionCode));
2658    }
2659    @Override
2660    public String functionLoadReplace(byte[] functionCode) {
2661      return executeCommand(commandObjects.functionLoadReplace(functionCode));
2662    }
2663    @Override
2664    public String functionRestore(byte[] serializedValue) {
2665      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue));
2666    }
2667    @Override
2668    public String functionRestore(byte[] serializedValue, FunctionRestorePolicy policy) {
2669      return checkAndBroadcastCommand(commandObjects.functionRestore(serializedValue, policy));
2670    }
2671    @Override
2672    public Object functionStatsBinary() {
2673      return executeCommand(commandObjects.functionStatsBinary());
2674    }
2675    @Override
2676    public Long objectRefcount(String key) {
2677      return executeCommand(commandObjects.objectRefcount(key));
2678    }
2679    @Override
2680    public String objectEncoding(String key) {
2681      return executeCommand(commandObjects.objectEncoding(key));
2682    }
2683    @Override
2684    public Long objectIdletime(String key) {
2685      return executeCommand(commandObjects.objectIdletime(key));
2686    }
2687    @Override
2688    public Long objectFreq(String key) {
2689      return executeCommand(commandObjects.objectFreq(key));
2690    }
2691    @Override
2692    public Long objectRefcount(byte[] key) {
2693      return executeCommand(commandObjects.objectRefcount(key));
2694    }
2695    @Override
2696    public byte[] objectEncoding(byte[] key) {
2697      return executeCommand(commandObjects.objectEncoding(key));
2698    }
2699    @Override
2700    public Long objectIdletime(byte[] key) {
2701      return executeCommand(commandObjects.objectIdletime(key));
2702    }
2703    @Override
2704    public Long objectFreq(byte[] key) {
2705      return executeCommand(commandObjects.objectFreq(key));
2706    }
2707    @Override
2708    public String migrate(String host, int port, String key, int timeout) {
2709      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2710    }
2711    @Override
2712    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
2713      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2714    }
2715    @Override
2716    public String migrate(String host, int port, byte[] key, int timeout) {
2717      return executeCommand(commandObjects.migrate(host, port, key, timeout));
2718    }
2719    @Override
2720    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
2721      return executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
2722    }
2723    @Override
2724    public long waitReplicas(String sampleKey, int replicas, long timeout) {
2725      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2726    }
2727    @Override
2728    public long waitReplicas(byte[] sampleKey, int replicas, long timeout) {
2729      return executeCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2730    }
2731    @Override
2732    public KeyValue&lt;Long, Long&gt; waitAOF(String sampleKey, long numLocal, long numReplicas, long timeout) {
2733      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2734    }
2735    @Override
2736    public KeyValue&lt;Long, Long&gt; waitAOF(byte[] sampleKey, long numLocal, long numReplicas, long timeout) {
2737      return executeCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2738    }
2739    @Override
2740    public Object eval(String script, String sampleKey) {
2741      return executeCommand(commandObjects.eval(script, sampleKey));
2742    }
2743    @Override
2744    public Object evalsha(String sha1, String sampleKey) {
2745      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2746    }
2747    @Override
2748    public Object eval(byte[] script, byte[] sampleKey) {
2749      return executeCommand(commandObjects.eval(script, sampleKey));
2750    }
2751    @Override
2752    public Object evalsha(byte[] sha1, byte[] sampleKey) {
2753      return executeCommand(commandObjects.evalsha(sha1, sampleKey));
2754    }
2755    public List&lt;Boolean&gt; scriptExists(List&lt;String&gt; sha1s) {
2756      return checkAndBroadcastCommand(commandObjects.scriptExists(sha1s));
2757    }
2758    @Override
2759    public Boolean scriptExists(String sha1, String sampleKey) {
2760      return scriptExists(sampleKey, new String[]{sha1}).get(0);
2761    }
2762    @Override
2763    public List&lt;Boolean&gt; scriptExists(String sampleKey, String... sha1s) {
2764      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2765    }
2766    @Override
2767    public Boolean scriptExists(byte[] sha1, byte[] sampleKey) {
2768      return scriptExists(sampleKey, new byte[][]{sha1}).get(0);
2769    }
2770    @Override
2771    public List&lt;Boolean&gt; scriptExists(byte[] sampleKey, byte[]... sha1s) {
2772      return executeCommand(commandObjects.scriptExists(sampleKey, sha1s));
2773    }
2774    public String scriptLoad(String script) {
2775      return checkAndBroadcastCommand(commandObjects.scriptLoad(script));
2776    }
2777    @Override
2778    public String scriptLoad(String script, String sampleKey) {
2779      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2780    }
2781    public String scriptFlush() {
2782      return checkAndBroadcastCommand(commandObjects.scriptFlush());
2783    }
2784    @Override
2785    public String scriptFlush(String sampleKey) {
2786      return executeCommand(commandObjects.scriptFlush(sampleKey));
2787    }
2788    @Override
2789    public String scriptFlush(String sampleKey, FlushMode flushMode) {
2790      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2791    }
2792    public String scriptKill() {
2793      return checkAndBroadcastCommand(commandObjects.scriptKill());
2794    }
2795    @Override
2796    public String scriptKill(String sampleKey) {
2797      return executeCommand(commandObjects.scriptKill(sampleKey));
2798    }
2799    @Override
2800    public byte[] scriptLoad(byte[] script, byte[] sampleKey) {
2801      return executeCommand(commandObjects.scriptLoad(script, sampleKey));
2802    }
2803    @Override
2804    public String scriptFlush(byte[] sampleKey) {
2805      return executeCommand(commandObjects.scriptFlush(sampleKey));
2806    }
2807    @Override
2808    public String scriptFlush(byte[] sampleKey, FlushMode flushMode) {
2809      return executeCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2810    }
2811    @Override
2812    public String scriptKill(byte[] sampleKey) {
2813      return executeCommand(commandObjects.scriptKill(sampleKey));
2814    }
2815    public String slowlogReset() {
2816      return checkAndBroadcastCommand(commandObjects.slowlogReset());
2817    }
2818    public long publish(String channel, String message) {
2819      return executeCommand(commandObjects.publish(channel, message));
2820    }
2821    public long publish(byte[] channel, byte[] message) {
2822      return executeCommand(commandObjects.publish(channel, message));
2823    }
2824    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
2825      try (Connection connection = this.provider.getConnection()) {
2826        jedisPubSub.proceed(connection, channels);
2827      }
2828    }
2829    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
2830      try (Connection connection = this.provider.getConnection()) {
2831        jedisPubSub.proceedWithPatterns(connection, patterns);
2832      }
2833    }
2834    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
2835      try (Connection connection = this.provider.getConnection()) {
2836        jedisPubSub.proceed(connection, channels);
2837      }
2838    }
2839    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
2840      try (Connection connection = this.provider.getConnection()) {
2841        jedisPubSub.proceedWithPatterns(connection, patterns);
2842      }
2843    }
2844    @Override
2845    public String ftCreate(String indexName, IndexOptions indexOptions, Schema schema) {
2846      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, indexOptions, schema));
2847    }
2848    @Override
2849    public String ftCreate(String indexName, FTCreateParams createParams, Iterable&lt;SchemaField&gt; schemaFields) {
2850      return checkAndBroadcastCommand(commandObjects.ftCreate(indexName, createParams, schemaFields));
2851    }
2852    @Override
2853    public String ftAlter(String indexName, Schema schema) {
2854      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schema));
2855    }
2856    @Override
2857    public String ftAlter(String indexName, Iterable&lt;SchemaField&gt; schemaFields) {
2858      return checkAndBroadcastCommand(commandObjects.ftAlter(indexName, schemaFields));
2859    }
2860    @Override
2861    public SearchResult ftSearch(String indexName, String query) {
2862      return executeCommand(commandObjects.ftSearch(indexName, query));
2863    }
2864    @Override
2865    public SearchResult ftSearch(String indexName, String query, FTSearchParams params) {
2866      return executeCommand(commandObjects.ftSearch(indexName, query, params));
2867    }
2868    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, String query, FTSearchParams params) {
2869      return new FtSearchIteration(provider, batchSize, indexName, query, params);
2870    }
2871    @Override
2872    public SearchResult ftSearch(String indexName, Query query) {
2873      return executeCommand(commandObjects.ftSearch(indexName, query));
2874    }
2875    public FtSearchIteration ftSearchIteration(int batchSize, String indexName, Query query) {
2876      return new FtSearchIteration(provider, batchSize, indexName, query);
2877    }
2878    @Override
2879    public SearchResult ftSearch(byte[] indexName, Query query) {
2880      return executeCommand(commandObjects.ftSearch(indexName, query));
2881    }
2882    @Override
2883    public String ftExplain(String indexName, Query query) {
2884      return executeCommand(commandObjects.ftExplain(indexName, query));
2885    }
2886    @Override
2887    public List&lt;String&gt; ftExplainCLI(String indexName, Query query) {
2888      return executeCommand(commandObjects.ftExplainCLI(indexName, query));
2889    }
2890    @Override
2891    public AggregationResult ftAggregate(String indexName, AggregationBuilder aggr) {
2892      return executeCommand(commandObjects.ftAggregate(indexName, aggr));
2893    }
2894    @Override
2895    public AggregationResult ftCursorRead(String indexName, long cursorId, int count) {
2896      return executeCommand(commandObjects.ftCursorRead(indexName, cursorId, count));
2897    }
2898    @Override
2899    public String ftCursorDel(String indexName, long cursorId) {
2900      return executeCommand(commandObjects.ftCursorDel(indexName, cursorId));
2901    }
2902    public FtAggregateIteration ftAggregateIteration(String indexName, AggregationBuilder aggr) {
2903      return new FtAggregateIteration(provider, indexName, aggr);
2904    }
2905    @Override
2906    public Map.Entry&lt;AggregationResult, Map&lt;String, Object&gt;&gt; ftProfileAggregate(String indexName,
2907        FTProfileParams profileParams, AggregationBuilder aggr) {
2908      return executeCommand(commandObjects.ftProfileAggregate(indexName, profileParams, aggr));
2909    }
2910    @Override
2911    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2912        FTProfileParams profileParams, Query query) {
2913      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query));
2914    }
2915    @Override
2916    public Map.Entry&lt;SearchResult, Map&lt;String, Object&gt;&gt; ftProfileSearch(String indexName,
2917        FTProfileParams profileParams, String query, FTSearchParams searchParams) {
2918      return executeCommand(commandObjects.ftProfileSearch(indexName, profileParams, query, searchParams));
2919    }
2920    @Override
2921    public String ftDropIndex(String indexName) {
2922      return checkAndBroadcastCommand(commandObjects.ftDropIndex(indexName));
2923    }
2924    @Override
2925    public String ftDropIndexDD(String indexName) {
2926      return checkAndBroadcastCommand(commandObjects.ftDropIndexDD(indexName));
2927    }
2928    @Override
2929    public String ftSynUpdate(String indexName, String synonymGroupId, String... terms) {
2930      return executeCommand(commandObjects.ftSynUpdate(indexName, synonymGroupId, terms));
2931    }
2932    @Override
2933    public Map&lt;String, List&lt;String&gt;&gt; ftSynDump(String indexName) {
2934      return executeCommand(commandObjects.ftSynDump(indexName));
2935    }
2936    @Override
2937    public long ftDictAdd(String dictionary, String... terms) {
2938      return executeCommand(commandObjects.ftDictAdd(dictionary, terms));
2939    }
2940    @Override
2941    public long ftDictDel(String dictionary, String... terms) {
2942      return executeCommand(commandObjects.ftDictDel(dictionary, terms));
2943    }
2944    @Override
2945    public Set&lt;String&gt; ftDictDump(String dictionary) {
2946      return executeCommand(commandObjects.ftDictDump(dictionary));
2947    }
2948    @Override
2949    public long ftDictAddBySampleKey(String indexName, String dictionary, String... terms) {
2950      return executeCommand(commandObjects.ftDictAddBySampleKey(indexName, dictionary, terms));
2951    }
2952    @Override
2953    public long ftDictDelBySampleKey(String indexName, String dictionary, String... terms) {
2954      return executeCommand(commandObjects.ftDictDelBySampleKey(indexName, dictionary, terms));
2955    }
2956    @Override
2957    public Set&lt;String&gt; ftDictDumpBySampleKey(String indexName, String dictionary) {
2958      return executeCommand(commandObjects.ftDictDumpBySampleKey(indexName, dictionary));
2959    }
2960    @Override
2961    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query) {
2962      return executeCommand(commandObjects.ftSpellCheck(index, query));
2963    }
2964    @Override
2965    public Map&lt;String, Map&lt;String, Double&gt;&gt; ftSpellCheck(String index, String query, FTSpellCheckParams spellCheckParams) {
2966      return executeCommand(commandObjects.ftSpellCheck(index, query, spellCheckParams));
2967    }
2968    @Override
2969    public Map&lt;String, Object&gt; ftInfo(String indexName) {
2970      return executeCommand(commandObjects.ftInfo(indexName));
2971    }
2972    @Override
2973    public Set&lt;String&gt; ftTagVals(String indexName, String fieldName) {
2974      return executeCommand(commandObjects.ftTagVals(indexName, fieldName));
2975    }
2976    @Override
2977    public String ftAliasAdd(String aliasName, String indexName) {
2978      return checkAndBroadcastCommand(commandObjects.ftAliasAdd(aliasName, indexName));
2979    }
2980    @Override
2981    public String ftAliasUpdate(String aliasName, String indexName) {
2982      return checkAndBroadcastCommand(commandObjects.ftAliasUpdate(aliasName, indexName));
2983    }
2984    @Override
2985    public String ftAliasDel(String aliasName) {
2986      return checkAndBroadcastCommand(commandObjects.ftAliasDel(aliasName));
2987    }
2988    @Override
2989    public Map&lt;String, String&gt; ftConfigGet(String option) {
2990      return executeCommand(commandObjects.ftConfigGet(option));
2991    }
2992    @Override
2993    public Map&lt;String, String&gt; ftConfigGet(String indexName, String option) {
2994      return executeCommand(commandObjects.ftConfigGet(indexName, option));
2995    }
2996    @Override
2997    public String ftConfigSet(String option, String value) {
2998      return executeCommand(commandObjects.ftConfigSet(option, value));
2999    }
3000    @Override
3001    public String ftConfigSet(String indexName, String option, String value) {
3002      return executeCommand(commandObjects.ftConfigSet(indexName, option, value));
3003    }
3004    @Override
3005    public long ftSugAdd(String key, String string, double score) {
3006      return executeCommand(commandObjects.ftSugAdd(key, string, score));
3007    }
3008    @Override
3009    public long ftSugAddIncr(String key, String string, double score) {
3010      return executeCommand(commandObjects.ftSugAddIncr(key, string, score));
3011    }
3012    @Override
3013    public List&lt;String&gt; ftSugGet(String key, String prefix) {
3014      return executeCommand(commandObjects.ftSugGet(key, prefix));
3015    }
3016    @Override
3017    public List&lt;String&gt; ftSugGet(String key, String prefix, boolean fuzzy, int max) {
3018      return executeCommand(commandObjects.ftSugGet(key, prefix, fuzzy, max));
3019    }
3020    @Override
3021    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix) {
3022      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix));
3023    }
3024    @Override
3025    public List&lt;Tuple&gt; ftSugGetWithScores(String key, String prefix, boolean fuzzy, int max) {
3026      return executeCommand(commandObjects.ftSugGetWithScores(key, prefix, fuzzy, max));
3027    }
3028    @Override
3029    public boolean ftSugDel(String key, String string) {
3030      return executeCommand(commandObjects.ftSugDel(key, string));
3031    }
3032    @Override
3033    public long ftSugLen(String key) {
3034      return executeCommand(commandObjects.ftSugLen(key));
3035    }
3036    @Override
3037    public List&lt;String&gt; ftList() {
3038      return executeCommand(commandObjects.ftList());
3039    }
3040    @Override
3041    public String jsonSet(String key, Path2 path, Object object) {
3042      return executeCommand(commandObjects.jsonSet(key, path, object));
3043    }
3044    @Override
3045    public String jsonSetWithEscape(String key, Path2 path, Object object) {
3046      return executeCommand(commandObjects.jsonSetWithEscape(key, path, object));
3047    }
3048    @Override
3049    public String jsonSet(String key, Path path, Object pojo) {
3050      return executeCommand(commandObjects.jsonSet(key, path, pojo));
3051    }
3052    @Override
3053    public String jsonSetWithPlainString(String key, Path path, String string) {
3054      return executeCommand(commandObjects.jsonSetWithPlainString(key, path, string));
3055    }
3056    @Override
3057    public String jsonSet(String key, Path2 path, Object pojo, JsonSetParams params) {
3058      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3059    }
3060    @Override
3061    public String jsonSetWithEscape(String key, Path2 path, Object pojo, JsonSetParams params) {
3062      return executeCommand(commandObjects.jsonSetWithEscape(key, path, pojo, params));
3063    }
3064    @Override
3065    public String jsonSet(String key, Path path, Object pojo, JsonSetParams params) {
3066      return executeCommand(commandObjects.jsonSet(key, path, pojo, params));
3067    }
3068    @Override
3069    public String jsonMerge(String key, Path2 path, Object object) {
3070      return executeCommand(commandObjects.jsonMerge(key, path, object));
3071    }
3072    @Override
3073    public String jsonMerge(String key, Path path, Object pojo) {
3074      return executeCommand(commandObjects.jsonMerge(key, path, pojo));
3075    }
3076    @Override
3077    public Object jsonGet(String key) {
3078      return executeCommand(commandObjects.jsonGet(key));
3079    }
3080    @Override
3081    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz) {
3082      return executeCommand(commandObjects.jsonGet(key, clazz));
3083    }
3084    @Override
3085    public Object jsonGet(String key, Path2... paths) {
3086      return executeCommand(commandObjects.jsonGet(key, paths));
3087    }
3088    @Override
3089    public Object jsonGet(String key, Path... paths) {
3090      return executeCommand(commandObjects.jsonGet(key, paths));
3091    }
3092    @Override
3093    public String jsonGetAsPlainString(String key, Path path) {
3094      return executeCommand(commandObjects.jsonGetAsPlainString(key, path));
3095    }
3096    @Override
3097    public &lt;T&gt; T jsonGet(String key, Class&lt;T&gt; clazz, Path... paths) {
3098      return executeCommand(commandObjects.jsonGet(key, clazz, paths));
3099    }
3100    @Override
3101    public List&lt;JSONArray&gt; jsonMGet(Path2 path, String... keys) {
3102      return executeCommand(commandObjects.jsonMGet(path, keys));
3103    }
3104    @Override
3105    public &lt;T&gt; List&lt;T&gt; jsonMGet(Path path, Class&lt;T&gt; clazz, String... keys) {
3106      return executeCommand(commandObjects.jsonMGet(path, clazz, keys));
3107    }
3108    @Override
3109    public long jsonDel(String key) {
3110      return executeCommand(commandObjects.jsonDel(key));
3111    }
3112    @Override
3113    public long jsonDel(String key, Path2 path) {
3114      return executeCommand(commandObjects.jsonDel(key, path));
3115    }
3116    @Override
3117    public long jsonDel(String key, Path path) {
3118      return executeCommand(commandObjects.jsonDel(key, path));
3119    }
3120    @Override
3121    public long jsonClear(String key) {
3122      return executeCommand(commandObjects.jsonClear(key));
3123    }
3124    @Override
3125    public long jsonClear(String key, Path2 path) {
3126      return executeCommand(commandObjects.jsonClear(key, path));
3127    }
3128    @Override
3129    public long jsonClear(String key, Path path) {
3130      return executeCommand(commandObjects.jsonClear(key, path));
3131    }
3132    @Override
3133    public List&lt;Boolean&gt; jsonToggle(String key, Path2 path) {
3134      return executeCommand(commandObjects.jsonToggle(key, path));
3135    }
3136    @Override
3137    public String jsonToggle(String key, Path path) {
3138      return executeCommand(commandObjects.jsonToggle(key, path));
3139    }
3140    @Override
3141    public Class&lt;?&gt; jsonType(String key) {
3142      return executeCommand(commandObjects.jsonType(key));
3143    }
3144    @Override
3145    public List&lt;Class&lt;?&gt;&gt; jsonType(String key, Path2 path) {
3146      return executeCommand(commandObjects.jsonType(key, path));
3147    }
3148    @Override
3149    public Class&lt;?&gt; jsonType(String key, Path path) {
3150      return executeCommand(commandObjects.jsonType(key, path));
3151    }
3152    @Override
3153    public long jsonStrAppend(String key, Object string) {
3154      return executeCommand(commandObjects.jsonStrAppend(key, string));
3155    }
3156    @Override
3157    public List&lt;Long&gt; jsonStrAppend(String key, Path2 path, Object string) {
3158      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3159    }
3160    @Override
3161    public long jsonStrAppend(String key, Path path, Object string) {
3162      return executeCommand(commandObjects.jsonStrAppend(key, path, string));
3163    }
3164    @Override
3165    public Long jsonStrLen(String key) {
3166      return executeCommand(commandObjects.jsonStrLen(key));
3167    }
3168    @Override
3169    public List&lt;Long&gt; jsonStrLen(String key, Path2 path) {
3170      return executeCommand(commandObjects.jsonStrLen(key, path));
3171    }
3172    @Override
3173    public Long jsonStrLen(String key, Path path) {
3174      return executeCommand(commandObjects.jsonStrLen(key, path));
3175    }
3176    @Override
3177    public JSONArray jsonNumIncrBy(String key, Path2 path, double value) {
3178      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3179    }
3180    @Override
3181    public double jsonNumIncrBy(String key, Path path, double value) {
3182      return executeCommand(commandObjects.jsonNumIncrBy(key, path, value));
3183    }
3184    @Override
3185    public List&lt;Long&gt; jsonArrAppend(String key, Path2 path, Object... objects) {
3186      return executeCommand(commandObjects.jsonArrAppend(key, path, objects));
3187    }
3188    @Override
3189    public List&lt;Long&gt; jsonArrAppendWithEscape(String key, Path2 path, Object... objects) {
3190      return executeCommand(commandObjects.jsonArrAppendWithEscape(key, path, objects));
3191    }
3192    @Override
3193    public Long jsonArrAppend(String key, Path path, Object... pojos) {
3194      return executeCommand(commandObjects.jsonArrAppend(key, path, pojos));
3195    }
3196    @Override
3197    public List&lt;Long&gt; jsonArrIndex(String key, Path2 path, Object scalar) {
3198      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3199    }
3200    @Override
3201    public List&lt;Long&gt; jsonArrIndexWithEscape(String key, Path2 path, Object scalar) {
3202      return executeCommand(commandObjects.jsonArrIndexWithEscape(key, path, scalar));
3203    }
3204    @Override
3205    public long jsonArrIndex(String key, Path path, Object scalar) {
3206      return executeCommand(commandObjects.jsonArrIndex(key, path, scalar));
3207    }
3208    @Override
3209    public List&lt;Long&gt; jsonArrInsert(String key, Path2 path, int index, Object... objects) {
3210      return executeCommand(commandObjects.jsonArrInsert(key, path, index, objects));
3211    }
3212    @Override
3213    public List&lt;Long&gt; jsonArrInsertWithEscape(String key, Path2 path, int index, Object... objects) {
3214      return executeCommand(commandObjects.jsonArrInsertWithEscape(key, path, index, objects));
3215    }
3216    @Override
3217    public long jsonArrInsert(String key, Path path, int index, Object... pojos) {
3218      return executeCommand(commandObjects.jsonArrInsert(key, path, index, pojos));
3219    }
3220    @Override
3221    public Object jsonArrPop(String key) {
3222      return executeCommand(commandObjects.jsonArrPop(key));
3223    }
3224    @Override
3225    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz) {
3226      return executeCommand(commandObjects.jsonArrPop(key, clazz));
3227    }
3228    @Override
3229    public List&lt;Object&gt; jsonArrPop(String key, Path2 path) {
3230      return executeCommand(commandObjects.jsonArrPop(key, path));
3231    }
3232    @Override
3233    public Object jsonArrPop(String key, Path path) {
3234      return executeCommand(commandObjects.jsonArrPop(key, path));
3235    }
3236    @Override
3237    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path) {
3238      return executeCommand(commandObjects.jsonArrPop(key, clazz, path));
3239    }
3240    @Override
3241    public List&lt;Object&gt; jsonArrPop(String key, Path2 path, int index) {
3242      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3243    }
3244    @Override
3245    public Object jsonArrPop(String key, Path path, int index) {
3246      return executeCommand(commandObjects.jsonArrPop(key, path, index));
3247    }
3248    @Override
3249    public &lt;T&gt; T jsonArrPop(String key, Class&lt;T&gt; clazz, Path path, int index) {
3250      return executeCommand(commandObjects.jsonArrPop(key, clazz, path, index));
3251    }
3252    @Override
3253    public Long jsonArrLen(String key) {
3254      return executeCommand(commandObjects.jsonArrLen(key));
3255    }
3256    @Override
3257    public List&lt;Long&gt; jsonArrLen(String key, Path2 path) {
3258      return executeCommand(commandObjects.jsonArrLen(key, path));
3259    }
3260    @Override
3261    public Long jsonArrLen(String key, Path path) {
3262      return executeCommand(commandObjects.jsonArrLen(key, path));
3263    }
3264    @Override
3265    public List&lt;Long&gt; jsonArrTrim(String key, Path2 path, int start, int stop) {
3266      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3267    }
3268    @Override
3269    public Long jsonArrTrim(String key, Path path, int start, int stop) {
3270      return executeCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3271    }
3272    @Override
3273    public Long jsonObjLen(String key) {
3274      return executeCommand(commandObjects.jsonObjLen(key));
3275    }
3276    @Override
3277    public Long jsonObjLen(String key, Path path) {
3278      return executeCommand(commandObjects.jsonObjLen(key, path));
3279    }
3280    @Override
3281    public List&lt;Long&gt; jsonObjLen(String key, Path2 path) {
3282      return executeCommand(commandObjects.jsonObjLen(key, path));
3283    }
3284    @Override
3285    public List&lt;String&gt; jsonObjKeys(String key) {
3286      return executeCommand(commandObjects.jsonObjKeys(key));
3287    }
3288    @Override
3289    public List&lt;String&gt; jsonObjKeys(String key, Path path) {
3290      return executeCommand(commandObjects.jsonObjKeys(key, path));
3291    }
3292    @Override
3293    public List&lt;List&lt;String&gt;&gt; jsonObjKeys(String key, Path2 path) {
3294      return executeCommand(commandObjects.jsonObjKeys(key, path));
3295    }
3296    @Override
3297    public long jsonDebugMemory(String key) {
3298      return executeCommand(commandObjects.jsonDebugMemory(key));
3299    }
3300    @Override
3301    public long jsonDebugMemory(String key, Path path) {
3302      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3303    }
3304    @Override
3305    public List&lt;Long&gt; jsonDebugMemory(String key, Path2 path) {
3306      return executeCommand(commandObjects.jsonDebugMemory(key, path));
3307    }
3308    @Override
3309    public List&lt;Object&gt; jsonResp(String key) {
3310      return executeCommand(commandObjects.jsonResp(key));
3311    }
3312    @Override
3313    public List&lt;Object&gt; jsonResp(String key, Path path) {
3314      return executeCommand(commandObjects.jsonResp(key, path));
3315    }
3316    @Override
3317    public List&lt;List&lt;Object&gt;&gt; jsonResp(String key, Path2 path) {
3318      return executeCommand(commandObjects.jsonResp(key, path));
3319    }
3320    @Override
3321    public String tsCreate(String key) {
3322      return executeCommand(commandObjects.tsCreate(key));
3323    }
3324    @Override
3325    public String tsCreate(String key, TSCreateParams createParams) {
3326      return executeCommand(commandObjects.tsCreate(key, createParams));
3327    }
3328    @Override
3329    public long tsDel(String key, long fromTimestamp, long toTimestamp) {
3330      return executeCommand(commandObjects.tsDel(key, fromTimestamp, toTimestamp));
3331    }
3332    @Override
3333    public String tsAlter(String key, TSAlterParams alterParams) {
3334      return executeCommand(commandObjects.tsAlter(key, alterParams));
3335    }
3336    @Override
3337    public long tsAdd(String key, double value) {
3338      return executeCommand(commandObjects.tsAdd(key, value));
3339    }
3340    @Override
3341    public long tsAdd(String key, long timestamp, double value) {
3342      return executeCommand(commandObjects.tsAdd(key, timestamp, value));
3343    }
3344    @Override
3345    public long tsAdd(String key, long timestamp, double value, TSCreateParams createParams) {
3346      return executeCommand(commandObjects.tsAdd(key, timestamp, value, createParams));
3347    }
3348    @Override
3349    public List&lt;Long&gt; tsMAdd(Map.Entry&lt;String, TSElement&gt;... entries) {
3350      return executeCommand(commandObjects.tsMAdd(entries));
3351    }
3352    @Override
3353    public long tsIncrBy(String key, double value) {
3354      return executeCommand(commandObjects.tsIncrBy(key, value));
3355    }
3356    @Override
3357    public long tsIncrBy(String key, double value, long timestamp) {
3358      return executeCommand(commandObjects.tsIncrBy(key, value, timestamp));
3359    }
3360    @Override
3361    public long tsDecrBy(String key, double value) {
3362      return executeCommand(commandObjects.tsDecrBy(key, value));
3363    }
3364    @Override
3365    public long tsDecrBy(String key, double value, long timestamp) {
3366      return executeCommand(commandObjects.tsDecrBy(key, value, timestamp));
3367    }
3368    @Override
3369    public List&lt;TSElement&gt; tsRange(String key, long fromTimestamp, long toTimestamp) {
3370      return executeCommand(commandObjects.tsRange(key, fromTimestamp, toTimestamp));
3371    }
3372    @Override
3373    public List&lt;TSElement&gt; tsRange(String key, TSRangeParams rangeParams) {
3374      return executeCommand(commandObjects.tsRange(key, rangeParams));
3375    }
3376    @Override
3377    public List&lt;TSElement&gt; tsRevRange(String key, long fromTimestamp, long toTimestamp) {
3378      return executeCommand(commandObjects.tsRevRange(key, fromTimestamp, toTimestamp));
3379    }
3380    @Override
3381    public List&lt;TSElement&gt; tsRevRange(String key, TSRangeParams rangeParams) {
3382      return executeCommand(commandObjects.tsRevRange(key, rangeParams));
3383    }
3384    @Override
3385    public Map&lt;String, TSMRangeElements&gt; tsMRange(long fromTimestamp, long toTimestamp, String... filters) {
3386      return executeCommand(commandObjects.tsMRange(fromTimestamp, toTimestamp, filters));
3387    }
3388    @Override
3389    public Map&lt;String, TSMRangeElements&gt; tsMRange(TSMRangeParams multiRangeParams) {
3390      return executeCommand(commandObjects.tsMRange(multiRangeParams));
3391    }
3392    @Override
3393    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(long fromTimestamp, long toTimestamp, String... filters) {
3394      return executeCommand(commandObjects.tsMRevRange(fromTimestamp, toTimestamp, filters));
3395    }
3396    @Override
3397    public Map&lt;String, TSMRangeElements&gt; tsMRevRange(TSMRangeParams multiRangeParams) {
3398      return executeCommand(commandObjects.tsMRevRange(multiRangeParams));
3399    }
3400    @Override
3401    public TSElement tsGet(String key) {
3402      return executeCommand(commandObjects.tsGet(key));
3403    }
3404    @Override
3405    public TSElement tsGet(String key, TSGetParams getParams) {
3406      return executeCommand(commandObjects.tsGet(key, getParams));
3407    }
3408    @Override
3409    public Map&lt;String, TSMGetElement&gt; tsMGet(TSMGetParams multiGetParams, String... filters) {
3410      return executeCommand(commandObjects.tsMGet(multiGetParams, filters));
3411    }
3412    @Override
3413    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long timeBucket) {
3414      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, timeBucket));
3415    }
3416    @Override
3417    public String tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long bucketDuration, long alignTimestamp) {
3418      return executeCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, bucketDuration, alignTimestamp));
3419    }
3420    @Override
3421    public String tsDeleteRule(String sourceKey, String destKey) {
3422      return executeCommand(commandObjects.tsDeleteRule(sourceKey, destKey));
3423    }
3424    @Override
3425    public List&lt;String&gt; tsQueryIndex(String... filters) {
3426      return executeCommand(commandObjects.tsQueryIndex(filters));
3427    }
3428    @Override
3429    public TSInfo tsInfo(String key) {
3430      return executor.executeCommand(commandObjects.tsInfo(key));
3431    }
3432    @Override
3433    public TSInfo tsInfoDebug(String key) {
3434      return executeCommand(commandObjects.tsInfoDebug(key));
3435    }
3436    @Override
3437    public String bfReserve(String key, double errorRate, long capacity) {
3438      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity));
3439    }
3440    @Override
3441    public String bfReserve(String key, double errorRate, long capacity, BFReserveParams reserveParams) {
3442      return executeCommand(commandObjects.bfReserve(key, errorRate, capacity, reserveParams));
3443    }
3444    @Override
3445    public boolean bfAdd(String key, String item) {
3446      return executeCommand(commandObjects.bfAdd(key, item));
3447    }
3448    @Override
3449    public List&lt;Boolean&gt; bfMAdd(String key, String... items) {
3450      return executeCommand(commandObjects.bfMAdd(key, items));
3451    }
3452    @Override
3453    public List&lt;Boolean&gt; bfInsert(String key, String... items) {
3454      return executeCommand(commandObjects.bfInsert(key, items));
3455    }
3456    @Override
3457    public List&lt;Boolean&gt; bfInsert(String key, BFInsertParams insertParams, String... items) {
3458      return executeCommand(commandObjects.bfInsert(key, insertParams, items));
3459    }
3460    @Override
3461    public boolean bfExists(String key, String item) {
3462      return executeCommand(commandObjects.bfExists(key, item));
3463    }
3464    @Override
3465    public List&lt;Boolean&gt; bfMExists(String key, String... items) {
3466      return executeCommand(commandObjects.bfMExists(key, items));
3467    }
3468    @Override
3469    public Map.Entry&lt;Long, byte[]&gt; bfScanDump(String key, long iterator) {
3470      return executeCommand(commandObjects.bfScanDump(key, iterator));
3471    }
3472    @Override
3473    public String bfLoadChunk(String key, long iterator, byte[] data) {
3474      return executeCommand(commandObjects.bfLoadChunk(key, iterator, data));
3475    }
3476    @Override
3477    public long bfCard(String key) {
3478      return executeCommand(commandObjects.bfCard(key));
3479    }
3480    @Override
3481    public Map&lt;String, Object&gt; bfInfo(String key) {
3482      return executeCommand(commandObjects.bfInfo(key));
3483    }
3484    @Override
3485    public String cfReserve(String key, long capacity) {
3486      return executeCommand(commandObjects.cfReserve(key, capacity));
3487    }
3488    @Override
3489    public String cfReserve(String key, long capacity, CFReserveParams reserveParams) {
3490      return executeCommand(commandObjects.cfReserve(key, capacity, reserveParams));
3491    }
3492    @Override
3493    public boolean cfAdd(String key, String item) {
3494      return executeCommand(commandObjects.cfAdd(key, item));
3495    }
3496    @Override
3497    public boolean cfAddNx(String key, String item) {
3498      return executeCommand(commandObjects.cfAddNx(key, item));
3499    }
3500    @Override
3501    public List&lt;Boolean&gt; cfInsert(String key, String... items) {
3502      return executeCommand(commandObjects.cfInsert(key, items));
3503    }
3504    @Override
3505    public List&lt;Boolean&gt; cfInsert(String key, CFInsertParams insertParams, String... items) {
3506      return executeCommand(commandObjects.cfInsert(key, insertParams, items));
3507    }
3508    @Override
3509    public List&lt;Boolean&gt; cfInsertNx(String key, String... items) {
3510      return executeCommand(commandObjects.cfInsertNx(key, items));
3511    }
3512    @Override
3513    public List&lt;Boolean&gt; cfInsertNx(String key, CFInsertParams insertParams, String... items) {
3514      return executeCommand(commandObjects.cfInsertNx(key, insertParams, items));
3515    }
3516    @Override
3517    public boolean cfExists(String key, String item) {
3518      return executeCommand(commandObjects.cfExists(key, item));
3519    }
3520    @Override
3521    public List&lt;Boolean&gt; cfMExists(String key, String... items) {
3522      return executeCommand(commandObjects.cfMExists(key, items));
3523    }
3524    @Override
3525    public boolean cfDel(String key, String item) {
3526      return executeCommand(commandObjects.cfDel(key, item));
3527    }
3528    @Override
3529    public long cfCount(String key, String item) {
3530      return executeCommand(commandObjects.cfCount(key, item));
3531    }
3532    @Override
3533    public Map.Entry&lt;Long, byte[]&gt; cfScanDump(String key, long iterator) {
3534      return executeCommand(commandObjects.cfScanDump(key, iterator));
3535    }
3536    @Override
3537    public String cfLoadChunk(String key, long iterator, byte[] data) {
3538      return executeCommand(commandObjects.cfLoadChunk(key, iterator, data));
3539    }
3540    @Override
3541    public Map&lt;String, Object&gt; cfInfo(String key) {
3542      return executeCommand(commandObjects.cfInfo(key));
3543    }
3544    @Override
3545    public String cmsInitByDim(String key, long width, long depth) {
3546      return executeCommand(commandObjects.cmsInitByDim(key, width, depth));
3547    }
3548    @Override
3549    public String cmsInitByProb(String key, double error, double probability) {
3550      return executeCommand(commandObjects.cmsInitByProb(key, error, probability));
3551    }
3552    @Override
3553    public List&lt;Long&gt; cmsIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3554      return executeCommand(commandObjects.cmsIncrBy(key, itemIncrements));
3555    }
3556    @Override
3557    public List&lt;Long&gt; cmsQuery(String key, String... items) {
3558      return executeCommand(commandObjects.cmsQuery(key, items));
3559    }
3560    @Override
3561    public String cmsMerge(String destKey, String... keys) {
3562      return executeCommand(commandObjects.cmsMerge(destKey, keys));
3563    }
3564    @Override
3565    public String cmsMerge(String destKey, Map&lt;String, Long&gt; keysAndWeights) {
3566      return executeCommand(commandObjects.cmsMerge(destKey, keysAndWeights));
3567    }
3568    @Override
3569    public Map&lt;String, Object&gt; cmsInfo(String key) {
3570      return executeCommand(commandObjects.cmsInfo(key));
3571    }
3572    @Override
3573    public String topkReserve(String key, long topk) {
3574      return executeCommand(commandObjects.topkReserve(key, topk));
3575    }
3576    @Override
3577    public String topkReserve(String key, long topk, long width, long depth, double decay) {
3578      return executeCommand(commandObjects.topkReserve(key, topk, width, depth, decay));
3579    }
3580    @Override
3581    public List&lt;String&gt; topkAdd(String key, String... items) {
3582      return executeCommand(commandObjects.topkAdd(key, items));
3583    }
3584    @Override
3585    public List&lt;String&gt; topkIncrBy(String key, Map&lt;String, Long&gt; itemIncrements) {
3586      return executeCommand(commandObjects.topkIncrBy(key, itemIncrements));
3587    }
3588    @Override
3589    public List&lt;Boolean&gt; topkQuery(String key, String... items) {
3590      return executeCommand(commandObjects.topkQuery(key, items));
3591    }
3592    @Override
3593    public List&lt;String&gt; topkList(String key) {
3594      return executeCommand(commandObjects.topkList(key));
3595    }
3596    @Override
3597    public Map&lt;String, Object&gt; topkInfo(String key) {
3598      return executeCommand(commandObjects.topkInfo(key));
3599    }
3600    @Override
3601    public String tdigestCreate(String key) {
3602      return executeCommand(commandObjects.tdigestCreate(key));
3603    }
3604    @Override
3605    public String tdigestCreate(String key, int compression) {
3606      return executeCommand(commandObjects.tdigestCreate(key, compression));
3607    }
3608    @Override
3609    public String tdigestReset(String key) {
3610      return executeCommand(commandObjects.tdigestReset(key));
3611    }
3612    @Override
3613    public String tdigestMerge(String destinationKey, String... sourceKeys) {
3614      return executeCommand(commandObjects.tdigestMerge(destinationKey, sourceKeys));
3615    }
3616    @Override
3617    public String tdigestMerge(TDigestMergeParams mergeParams, String destinationKey, String... sourceKeys) {
3618      return executeCommand(commandObjects.tdigestMerge(mergeParams, destinationKey, sourceKeys));
3619    }
3620    @Override
3621    public Map&lt;String, Object&gt; tdigestInfo(String key) {
3622      return executeCommand(commandObjects.tdigestInfo(key));
3623    }
3624    @Override
3625    public String tdigestAdd(String key, double... values) {
3626      return executeCommand(commandObjects.tdigestAdd(key, values));
3627    }
3628    @Override
3629    public List&lt;Double&gt; tdigestCDF(String key, double... values) {
3630      return executeCommand(commandObjects.tdigestCDF(key, values));
3631    }
3632    @Override
3633    public List&lt;Double&gt; tdigestQuantile(String key, double... quantiles) {
3634      return executeCommand(commandObjects.tdigestQuantile(key, quantiles));
3635    }
3636    @Override
3637    public double tdigestMin(String key) {
3638      return executeCommand(commandObjects.tdigestMin(key));
3639    }
3640    @Override
3641    public double tdigestMax(String key) {
3642      return executeCommand(commandObjects.tdigestMax(key));
3643    }
3644    @Override
3645    public double tdigestTrimmedMean(String key, double lowCutQuantile, double highCutQuantile) {
3646      return executeCommand(commandObjects.tdigestTrimmedMean(key, lowCutQuantile, highCutQuantile));
3647    }
3648    @Override
3649    public List&lt;Long&gt; tdigestRank(String key, double... values) {
3650      return executeCommand(commandObjects.tdigestRank(key, values));
3651    }
3652    @Override
3653    public List&lt;Long&gt; tdigestRevRank(String key, double... values) {
3654      return executeCommand(commandObjects.tdigestRevRank(key, values));
3655    }
3656    @Override
3657    public List&lt;Double&gt; tdigestByRank(String key, long... ranks) {
3658      return executeCommand(commandObjects.tdigestByRank(key, ranks));
3659    }
3660    @Override
3661    public List&lt;Double&gt; tdigestByRevRank(String key, long... ranks) {
3662      return executeCommand(commandObjects.tdigestByRevRank(key, ranks));
3663    }
3664    @Override
3665    public ResultSet graphQuery(String name, String query) {
3666      return executeCommand(graphCommandObjects.graphQuery(name, query));
3667    }
3668    @Override
3669    public ResultSet graphReadonlyQuery(String name, String query) {
3670      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query));
3671    }
3672    @Override
3673    public ResultSet graphQuery(String name, String query, long timeout) {
3674      return executeCommand(graphCommandObjects.graphQuery(name, query, timeout));
3675    }
3676    @Override
3677    public ResultSet graphReadonlyQuery(String name, String query, long timeout) {
3678      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, timeout));
3679    }
3680    @Override
3681    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params) {
3682      return executeCommand(graphCommandObjects.graphQuery(name, query, params));
3683    }
3684    @Override
3685    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params) {
3686      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params));
3687    }
3688    @Override
3689    public ResultSet graphQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3690      return executeCommand(graphCommandObjects.graphQuery(name, query, params, timeout));
3691    }
3692    @Override
3693    public ResultSet graphReadonlyQuery(String name, String query, Map&lt;String, Object&gt; params, long timeout) {
3694      return executeCommand(graphCommandObjects.graphReadonlyQuery(name, query, params, timeout));
3695    }
3696    @Override
3697    public String graphDelete(String name) {
3698      return executeCommand(graphCommandObjects.graphDelete(name));
3699    }
3700    @Override
3701    public List&lt;String&gt; graphList() {
3702      return executeCommand(commandObjects.graphList());
3703    }
3704    @Override
3705    public List&lt;String&gt; graphProfile(String graphName, String query) {
3706      return executeCommand(commandObjects.graphProfile(graphName, query));
3707    }
3708    @Override
3709    public List&lt;String&gt; graphExplain(String graphName, String query) {
3710      return executeCommand(commandObjects.graphExplain(graphName, query));
3711    }
3712    @Override
3713    public List&lt;List&lt;Object&gt;&gt; graphSlowlog(String graphName) {
3714      return executeCommand(commandObjects.graphSlowlog(graphName));
3715    }
3716    @Override
3717    public String graphConfigSet(String configName, Object value) {
3718      return executeCommand(commandObjects.graphConfigSet(configName, value));
3719    }
3720    @Override
3721    public Map&lt;String, Object&gt; graphConfigGet(String configName) {
3722      return executeCommand(commandObjects.graphConfigGet(configName));
3723    }
3724    public PipelineBase pipelined() {
3725      if (provider == null) {
3726        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3727      }
3728      return new Pipeline(provider.getConnection(), true);
3729    }
3730    public Transaction multi() {
3731      if (provider == null) {
3732        throw new IllegalStateException(&quot;It is not allowed to create Pipeline from this &quot; + getClass());
3733      }
3734      return new Transaction(provider.getConnection(), true, true);
3735    }
3736    public Object sendCommand(ProtocolCommand cmd) {
3737      return executeCommand(commandObjects.commandArguments(cmd));
3738    }
3739    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
3740      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3741    }
3742    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
3743      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3744    }
3745    public Object sendCommand(ProtocolCommand cmd, String... args) {
3746      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args));
3747    }
3748    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
3749      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking());
3750    }
3751    public Object sendCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3752      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3753    }
3754    public Object sendBlockingCommand(byte[] sampleKey, ProtocolCommand cmd, byte[]... args) {
3755      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3756    }
3757    public Object sendCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3758      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).processKey(sampleKey));
3759    }
3760    public Object sendBlockingCommand(String sampleKey, ProtocolCommand cmd, String... args) {
3761      return executeCommand(commandObjects.commandArguments(cmd).addObjects((Object[]) args).blocking().processKey(sampleKey));
3762    }
3763    public Object executeCommand(CommandArguments args) {
3764      return executeCommand(new CommandObject&lt;&gt;(args, BuilderFactory.RAW_OBJECT));
3765    }
3766    public void setJsonObjectMapper(JsonObjectMapper jsonObjectMapper) {
3767      this.commandObjects.setJsonObjectMapper(jsonObjectMapper);
3768    }
3769    public void setDefaultSearchDialect(int dialect) {
3770      this.commandObjects.setDefaultSearchDialect(dialect);
3771    }
3772  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static redis.clients.jedis.Protocol.Command.*;
3  import static redis.clients.jedis.Protocol.Keyword.*;
4  import static redis.clients.jedis.Protocol.SentinelKeyword.*;
5  import static redis.clients.jedis.Protocol.toByteArray;
6  import static redis.clients.jedis.util.SafeEncoder.encode;
7  import java.io.Closeable;
8  import java.net.URI;
9  import java.util.Iterator;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.Map.Entry;
13  import java.util.Set;
14  import java.util.stream.Collectors;
15  import javax.net.ssl.HostnameVerifier;
16  import javax.net.ssl.SSLParameters;
17  import javax.net.ssl.SSLSocketFactory;
18  import redis.clients.jedis.Protocol.*;
19  import redis.clients.jedis.args.*;
20  import redis.clients.jedis.commands.*;
21  import redis.clients.jedis.exceptions.InvalidURIException;
22  import redis.clients.jedis.exceptions.JedisConnectionException;
23  import redis.clients.jedis.exceptions.JedisException;
24  import redis.clients.jedis.params.*;
25  import redis.clients.jedis.resps.*;
26  import redis.clients.jedis.util.JedisURIHelper;
27  import redis.clients.jedis.util.KeyValue;
28  import redis.clients.jedis.util.Pool;
29  public class Jedis implements ServerCommands, DatabaseCommands, JedisCommands, JedisBinaryCommands,
30      ControlCommands, ControlBinaryCommands, ClusterCommands, ModuleCommands, GenericControlCommands,
31      SentinelCommands, Closeable {
32    protected final Connection connection;
33    private final CommandObjects commandObjects = new CommandObjects();
34    private int db = 0;
35    private Transaction transaction = null;
36    private boolean isInMulti = false;
37    private boolean isInWatch = false;
38    private Pipeline pipeline = null;
39    protected static final byte[][] DUMMY_ARRAY = new byte[0][];
40    private Pool&lt;Jedis&gt; dataSource = null;
41    public Jedis() {
42      connection = new Connection();
43    }
44    public Jedis(final String url) {
45      this(URI.create(url));
46    }
47    public Jedis(final HostAndPort hp) {
48      connection = new Connection(hp);
49    }
50    public Jedis(final String host, final int port) {
51      connection = new Connection(host, port);
52    }
53    public Jedis(final String host, final int port, final JedisClientConfig config) {
54      this(new HostAndPort(host, port), config);
55    }
56    public Jedis(final HostAndPort hostPort, final JedisClientConfig config) {
57      connection = new Connection(hostPort, config);
58      RedisProtocol proto = config.getRedisProtocol();
59      if (proto != null) commandObjects.setProtocol(proto);
60    }
61    public Jedis(final String host, final int port, final boolean ssl) {
62      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl).build());
63    }
64    public Jedis(final String host, final int port, final boolean ssl,
65        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
66        final HostnameVerifier hostnameVerifier) {
67      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl)
68          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
69          .hostnameVerifier(hostnameVerifier).build());
70    }
71    public Jedis(final String host, final int port, final int timeout) {
72      this(host, port, timeout, timeout);
73    }
74    public Jedis(final String host, final int port, final int timeout, final boolean ssl) {
75      this(host, port, timeout, timeout, ssl);
76    }
77    public Jedis(final String host, final int port, final int timeout, final boolean ssl,
78        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
79        final HostnameVerifier hostnameVerifier) {
80      this(host, port, timeout, timeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);
81    }
82    public Jedis(final String host, final int port, final int connectionTimeout,
83        final int soTimeout) {
84      this(host, port, DefaultJedisClientConfig.builder()
85          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).build());
86    }
87    public Jedis(final String host, final int port, final int connectionTimeout,
88        final int soTimeout, final int infiniteSoTimeout) {
89      this(host, port, DefaultJedisClientConfig.builder()
90          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
91          .blockingSocketTimeoutMillis(infiniteSoTimeout).build());
92    }
93    public Jedis(final String host, final int port, final int connectionTimeout,
94        final int soTimeout, final boolean ssl) {
95      this(host, port, DefaultJedisClientConfig.builder()
96          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
97          .build());
98    }
99    public Jedis(final String host, final int port, final int connectionTimeout,
100        final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory,
101        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
102      this(host, port, DefaultJedisClientConfig.builder()
103          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
104          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
105          .hostnameVerifier(hostnameVerifier).build());
106    }
107    public Jedis(final String host, final int port, final int connectionTimeout,
108        final int soTimeout, final int infiniteSoTimeout, final boolean ssl,
109        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
110        final HostnameVerifier hostnameVerifier) {
111      this(host, port, DefaultJedisClientConfig.builder()
112          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
113          .blockingSocketTimeoutMillis(infiniteSoTimeout).ssl(ssl)
114          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
115          .hostnameVerifier(hostnameVerifier).build());
116    }
117    public Jedis(URI uri) {
118      if (!JedisURIHelper.isValid(uri)) {
119        throw new InvalidURIException(String.format(
120          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
121      }
122      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
123          DefaultJedisClientConfig.builder().user(JedisURIHelper.getUser(uri))
124              .password(JedisURIHelper.getPassword(uri)).database(JedisURIHelper.getDBIndex(uri))
125              .protocol(JedisURIHelper.getRedisProtocol(uri))
126              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
127    }
128    public Jedis(URI uri, final SSLSocketFactory sslSocketFactory,
129        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
130      this(uri, DefaultJedisClientConfig.builder().sslSocketFactory(sslSocketFactory)
131          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
132    }
133    public Jedis(final URI uri, final int timeout) {
134      this(uri, timeout, timeout);
135    }
136    public Jedis(final URI uri, final int timeout, final SSLSocketFactory sslSocketFactory,
137        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
138      this(uri, timeout, timeout, sslSocketFactory, sslParameters, hostnameVerifier);
139    }
140    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout) {
141      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
142          .socketTimeoutMillis(soTimeout).build());
143    }
144    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
145        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
146        final HostnameVerifier hostnameVerifier) {
147      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
148          .socketTimeoutMillis(soTimeout).sslSocketFactory(sslSocketFactory)
149          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
150    }
151    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
152        final int infiniteSoTimeout, final SSLSocketFactory sslSocketFactory,
153        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
154      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
155          .socketTimeoutMillis(soTimeout).blockingSocketTimeoutMillis(infiniteSoTimeout)
156          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
157          .hostnameVerifier(hostnameVerifier).build());
158    }
159    public Jedis(final URI uri, JedisClientConfig config) {
160      if (!JedisURIHelper.isValid(uri)) {
161        throw new InvalidURIException(String.format(
162          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
163      }
164      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
165          DefaultJedisClientConfig.builder()
166              .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
167              .socketTimeoutMillis(config.getSocketTimeoutMillis())
168              .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
169              .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
170              .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
171              .protocol(JedisURIHelper.getRedisProtocol(uri))
172              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
173              .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
174              .build());
175      RedisProtocol proto = config.getRedisProtocol();
176      if (proto != null) commandObjects.setProtocol(proto);
177    }
178    public Jedis(final JedisSocketFactory jedisSocketFactory) {
179      connection = new Connection(jedisSocketFactory);
180    }
181    public Jedis(final JedisSocketFactory jedisSocketFactory, final JedisClientConfig clientConfig) {
182      connection = new Connection(jedisSocketFactory, clientConfig);
183      RedisProtocol proto = clientConfig.getRedisProtocol();
184      if (proto != null) commandObjects.setProtocol(proto);
185    }
186    public Jedis(final Connection connection) {
187      this.connection = connection;
188    }
189    @Override
190    public String toString() {
191      return &quot;Jedis{&quot; + connection + &#x27;}&#x27;;
192    }
193    public Connection getClient() {
194      return getConnection();
195    }
196    public Connection getConnection() {
197      return connection;
198    }
199    public void connect() {
200      connection.connect();
201    }
202    public void disconnect() {
203      connection.disconnect();
204    }
205    public boolean isConnected() {
206      return connection.isConnected();
207    }
208    public boolean isBroken() {
209      return connection.isBroken();
210    }
211    public void resetState() {
212      if (isConnected()) {
213        if (transaction != null) {
214          transaction.close();
215        }
216        if (pipeline != null) {
217          pipeline.close();
218        }
219        if (isInWatch) {
220          connection.sendCommand(UNWATCH);
221          connection.getStatusCodeReply();
222          isInWatch = false;
223        }
224      }
225      transaction = null;
226      pipeline = null;
227    }
228    protected void setDataSource(Pool&lt;Jedis&gt; jedisPool) {
229      this.dataSource = jedisPool;
230    }
231    @Override
232    public void close() {
233      if (dataSource != null) {
234        Pool&lt;Jedis&gt; pool = this.dataSource;
235        this.dataSource = null;
236        if (isBroken()) {
237          pool.returnBrokenResource(this);
238        } else {
239          pool.returnResource(this);
240        }
241      } else {
242        connection.close();
243      }
244    }
245    public Transaction multi() {
246      transaction = new Transaction(this);
247      return transaction;
248    }
249    public Pipeline pipelined() {
250      pipeline = new Pipeline(this);
251      return pipeline;
252    }
253    protected void checkIsInMultiOrPipeline() {
254      if (transaction != null) {
255        throw new IllegalStateException(
256            &quot;Cannot use Jedis when in Multi. Please use Transaction or reset jedis state.&quot;);
257      } else if (pipeline != null &amp;&amp; pipeline.hasPipelinedResponse()) {
258        throw new IllegalStateException(
259            &quot;Cannot use Jedis when in Pipeline. Please use Pipeline or reset jedis state.&quot;);
260      }
261    }
262    public int getDB() {
263      return this.db;
264    }
265    @Override
266    public String ping() {
267      checkIsInMultiOrPipeline();
268      connection.sendCommand(Command.PING);
269      return connection.getStatusCodeReply();
270    }
271    public byte[] ping(final byte[] message) {
272      checkIsInMultiOrPipeline();
273      connection.sendCommand(Command.PING, message);
274      return connection.getBinaryBulkReply();
275    }
276    @Override
277    public String select(final int index) {
278      checkIsInMultiOrPipeline();
279      connection.sendCommand(SELECT, toByteArray(index));
280      String statusCodeReply = connection.getStatusCodeReply();
281      this.db = index;
282      return statusCodeReply;
283    }
284    @Override
285    public String swapDB(final int index1, final int index2) {
286      checkIsInMultiOrPipeline();
287      connection.sendCommand(SWAPDB, toByteArray(index1), toByteArray(index2));
288      return connection.getStatusCodeReply();
289    }
290    @Override
291    public String flushDB() {
292      checkIsInMultiOrPipeline();
293      return connection.executeCommand(commandObjects.flushDB());
294    }
295    @Override
296    public String flushDB(FlushMode flushMode) {
297      checkIsInMultiOrPipeline();
298      connection.sendCommand(FLUSHDB, flushMode.getRaw());
299      return connection.getStatusCodeReply();
300    }
301    @Override
302    public String flushAll() {
303      checkIsInMultiOrPipeline();
304      return connection.executeCommand(commandObjects.flushAll());
305    }
306    @Override
307    public String flushAll(FlushMode flushMode) {
308      checkIsInMultiOrPipeline();
309      connection.sendCommand(FLUSHALL, flushMode.getRaw());
310      return connection.getStatusCodeReply();
311    }
312    @Override
313    public boolean copy(byte[] srcKey, byte[] dstKey, int db, boolean replace) {
314      checkIsInMultiOrPipeline();
315      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
316    }
317    @Override
318    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
319      checkIsInMultiOrPipeline();
320      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
321    }
322    @Override
323    public String set(final byte[] key, final byte[] value) {
324      checkIsInMultiOrPipeline();
325      return connection.executeCommand(commandObjects.set(key, value));
326    }
327    @Override
328    public String set(final byte[] key, final byte[] value, final SetParams params) {
329      checkIsInMultiOrPipeline();
330      return connection.executeCommand(commandObjects.set(key, value, params));
331    }
332    @Override
333    public byte[] get(final byte[] key) {
334      checkIsInMultiOrPipeline();
335      return connection.executeCommand(commandObjects.get(key));
336    }
337    @Override
338    public byte[] setGet(final byte[] key, final byte[] value) {
339      checkIsInMultiOrPipeline();
340      return connection.executeCommand(commandObjects.setGet(key, value));
341    }
342    @Override
343    public byte[] setGet(final byte[] key, final byte[] value, final SetParams params) {
344      checkIsInMultiOrPipeline();
345      return connection.executeCommand(commandObjects.setGet(key, value, params));
346    }
347    @Override
348    public byte[] getDel(final byte[] key) {
349      checkIsInMultiOrPipeline();
350      return connection.executeCommand(commandObjects.getDel(key));
351    }
352    @Override
353    public byte[] getEx(final byte[] key, final GetExParams params) {
354      checkIsInMultiOrPipeline();
355      return connection.executeCommand(commandObjects.getEx(key, params));
356    }
357    @Override
358    public long exists(final byte[]... keys) {
359      checkIsInMultiOrPipeline();
360      return connection.executeCommand(commandObjects.exists(keys));
361    }
362    @Override
363    public boolean exists(final byte[] key) {
364      checkIsInMultiOrPipeline();
365      return connection.executeCommand(commandObjects.exists(key));
366    }
367    @Override
368    public long del(final byte[]... keys) {
369      checkIsInMultiOrPipeline();
370      return connection.executeCommand(commandObjects.del(keys));
371    }
372    @Override
373    public long del(final byte[] key) {
374      checkIsInMultiOrPipeline();
375      return connection.executeCommand(commandObjects.del(key));
376    }
377    @Override
378    public long unlink(final byte[]... keys) {
379      checkIsInMultiOrPipeline();
380      return connection.executeCommand(commandObjects.unlink(keys));
381    }
382    @Override
383    public long unlink(final byte[] key) {
384      checkIsInMultiOrPipeline();
385      return connection.executeCommand(commandObjects.unlink(key));
386    }
387    @Override
388    public String type(final byte[] key) {
389      checkIsInMultiOrPipeline();
390      return connection.executeCommand(commandObjects.type(key));
391    }
392    @Override
393    public Set&lt;byte[]&gt; keys(final byte[] pattern) {
394      checkIsInMultiOrPipeline();
395      return connection.executeCommand(commandObjects.keys(pattern));
396    }
397    @Override
398    public byte[] randomBinaryKey() {
399      checkIsInMultiOrPipeline();
400      return connection.executeCommand(commandObjects.randomBinaryKey());
401    }
402    @Override
403    public String rename(final byte[] oldkey, final byte[] newkey) {
404      checkIsInMultiOrPipeline();
405      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
406    }
407    @Override
408    public long renamenx(final byte[] oldkey, final byte[] newkey) {
409      checkIsInMultiOrPipeline();
410      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
411    }
412    @Override
413    public long dbSize() {
414      checkIsInMultiOrPipeline();
415      connection.sendCommand(DBSIZE);
416      return connection.getIntegerReply();
417    }
418    @Override
419    public long expire(final byte[] key, final long seconds) {
420      checkIsInMultiOrPipeline();
421      return connection.executeCommand(commandObjects.expire(key, seconds));
422    }
423    @Override
424    public long expire(final byte[] key, final long seconds, final ExpiryOption expiryOption) {
425      checkIsInMultiOrPipeline();
426      return connection.executeCommand((commandObjects.expire(key, seconds, expiryOption)));
427    }
428    @Override
429    public long pexpire(final byte[] key, final long milliseconds) {
430      checkIsInMultiOrPipeline();
431      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
432    }
433    @Override
434    public long pexpire(final byte[] key, final long milliseconds, final ExpiryOption expiryOption) {
435      checkIsInMultiOrPipeline();
436      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
437    }
438    @Override
439    public long expireTime(final byte[] key) {
440      checkIsInMultiOrPipeline();
441      return connection.executeCommand((commandObjects.expireTime(key)));
442    }
443    @Override
444    public long pexpireTime(final byte[] key) {
445      checkIsInMultiOrPipeline();
446      return connection.executeCommand(commandObjects.pexpireTime(key));
447    }
448    @Override
449    public long expireAt(final byte[] key, final long unixTime) {
450      checkIsInMultiOrPipeline();
451      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
452    }
453    @Override
454    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
455      checkIsInMultiOrPipeline();
456      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
457    }
458    @Override
459    public long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
460      checkIsInMultiOrPipeline();
461      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
462    }
463    @Override
464    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
465      checkIsInMultiOrPipeline();
466      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
467    }
468    @Override
469    public long ttl(final byte[] key) {
470      checkIsInMultiOrPipeline();
471      return connection.executeCommand(commandObjects.ttl(key));
472    }
473    @Override
474    public long touch(final byte[]... keys) {
475      checkIsInMultiOrPipeline();
476      return connection.executeCommand(commandObjects.touch(keys));
477    }
478    @Override
479    public long touch(final byte[] key) {
480      checkIsInMultiOrPipeline();
481      return connection.executeCommand(commandObjects.touch(key));
482    }
483    @Override
484    public long move(final byte[] key, final int dbIndex) {
485      checkIsInMultiOrPipeline();
486      connection.sendCommand(MOVE, key, toByteArray(dbIndex));
487      return connection.getIntegerReply();
488    }
489    @Override
490    public byte[] getSet(final byte[] key, final byte[] value) {
491      checkIsInMultiOrPipeline();
492      return connection.executeCommand(commandObjects.getSet(key, value));
493    }
494    @Override
495    public List&lt;byte[]&gt; mget(final byte[]... keys) {
496      checkIsInMultiOrPipeline();
497      return connection.executeCommand(commandObjects.mget(keys));
498    }
499    @Override
500    public long setnx(final byte[] key, final byte[] value) {
501      checkIsInMultiOrPipeline();
502      return connection.executeCommand(commandObjects.setnx(key, value));
503    }
504    @Override
505    public String setex(final byte[] key, final long seconds, final byte[] value) {
506      checkIsInMultiOrPipeline();
507      return connection.executeCommand(commandObjects.setex(key, seconds, value));
508    }
509    @Override
510    public String mset(final byte[]... keysvalues) {
511      checkIsInMultiOrPipeline();
512      return connection.executeCommand(commandObjects.mset(keysvalues));
513    }
514    @Override
515    public long msetnx(final byte[]... keysvalues) {
516      checkIsInMultiOrPipeline();
517      return connection.executeCommand(commandObjects.msetnx(keysvalues));
518    }
519    @Override
520    public long decrBy(final byte[] key, final long decrement) {
521      checkIsInMultiOrPipeline();
522      return connection.executeCommand(commandObjects.decrBy(key, decrement));
523    }
524    @Override
525    public long decr(final byte[] key) {
526      checkIsInMultiOrPipeline();
527      return connection.executeCommand(commandObjects.decr(key));
528    }
529    @Override
530    public long incrBy(final byte[] key, final long increment) {
531      checkIsInMultiOrPipeline();
532      return connection.executeCommand(commandObjects.incrBy(key, increment));
533    }
534    @Override
535    public double incrByFloat(final byte[] key, final double increment) {
536      checkIsInMultiOrPipeline();
537      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
538    }
539    @Override
540    public long incr(final byte[] key) {
541      checkIsInMultiOrPipeline();
542      return connection.executeCommand(commandObjects.incr(key));
543    }
544    @Override
545    public long append(final byte[] key, final byte[] value) {
546      checkIsInMultiOrPipeline();
547      return connection.executeCommand(commandObjects.append(key, value));
548    }
549    @Override
550    public byte[] substr(final byte[] key, final int start, final int end) {
551      checkIsInMultiOrPipeline();
552      return connection.executeCommand(commandObjects.substr(key, start, end));
553    }
554    @Override
555    public long hset(final byte[] key, final byte[] field, final byte[] value) {
556      checkIsInMultiOrPipeline();
557      return connection.executeCommand(commandObjects.hset(key, field, value));
558    }
559    @Override
560    public long hset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
561      checkIsInMultiOrPipeline();
562      return connection.executeCommand(commandObjects.hset(key, hash));
563    }
564    @Override
565    public byte[] hget(final byte[] key, final byte[] field) {
566      checkIsInMultiOrPipeline();
567      return connection.executeCommand(commandObjects.hget(key, field));
568    }
569    @Override
570    public long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
571      checkIsInMultiOrPipeline();
572      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
573    }
574    @Override
575    public String hmset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
576      checkIsInMultiOrPipeline();
577      return connection.executeCommand(commandObjects.hmset(key, hash));
578    }
579    @Override
580    public List&lt;byte[]&gt; hmget(final byte[] key, final byte[]... fields) {
581      checkIsInMultiOrPipeline();
582      return connection.executeCommand(commandObjects.hmget(key, fields));
583    }
584    @Override
585    public long hincrBy(final byte[] key, final byte[] field, final long value) {
586      checkIsInMultiOrPipeline();
587      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
588    }
589    @Override
590    public double hincrByFloat(final byte[] key, final byte[] field, final double value) {
591      checkIsInMultiOrPipeline();
592      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
593    }
594    @Override
595    public boolean hexists(final byte[] key, final byte[] field) {
596      checkIsInMultiOrPipeline();
597      return connection.executeCommand(commandObjects.hexists(key, field));
598    }
599    @Override
600    public long hdel(final byte[] key, final byte[]... fields) {
601      checkIsInMultiOrPipeline();
602      return connection.executeCommand(commandObjects.hdel(key, fields));
603    }
604    @Override
605    public long hlen(final byte[] key) {
606      checkIsInMultiOrPipeline();
607      return connection.executeCommand(commandObjects.hlen(key));
608    }
609    @Override
610    public Set&lt;byte[]&gt; hkeys(final byte[] key) {
611      checkIsInMultiOrPipeline();
612      return connection.executeCommand(commandObjects.hkeys(key));
613    }
614    @Override
615    public List&lt;byte[]&gt; hvals(final byte[] key) {
616      checkIsInMultiOrPipeline();
617      return connection.executeCommand(commandObjects.hvals(key));
618    }
619    @Override
620    public Map&lt;byte[], byte[]&gt; hgetAll(final byte[] key) {
621      checkIsInMultiOrPipeline();
622      return connection.executeCommand(commandObjects.hgetAll(key));
623    }
624    @Override
625    public byte[] hrandfield(final byte[] key) {
626      checkIsInMultiOrPipeline();
627      return connection.executeCommand(commandObjects.hrandfield(key));
628    }
629    @Override
630    public List&lt;byte[]&gt; hrandfield(final byte[] key, final long count) {
631      checkIsInMultiOrPipeline();
632      return connection.executeCommand(commandObjects.hrandfield(key, count));
633    }
634    @Override
635    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(final byte[] key, final long count) {
636      checkIsInMultiOrPipeline();
637      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
638    }
639    @Override
640    public long rpush(final byte[] key, final byte[]... strings) {
641      checkIsInMultiOrPipeline();
642      return connection.executeCommand(commandObjects.rpush(key, strings));
643    }
644    @Override
645    public long lpush(final byte[] key, final byte[]... strings) {
646      checkIsInMultiOrPipeline();
647      return connection.executeCommand(commandObjects.lpush(key, strings));
648    }
649    @Override
650    public long llen(final byte[] key) {
651      checkIsInMultiOrPipeline();
652      return connection.executeCommand(commandObjects.llen(key));
653    }
654    @Override
655    public List&lt;byte[]&gt; lrange(final byte[] key, final long start, final long stop) {
656      checkIsInMultiOrPipeline();
657      return connection.executeCommand(commandObjects.lrange(key, start, stop));
658    }
659    @Override
660    public String ltrim(final byte[] key, final long start, final long stop) {
661      checkIsInMultiOrPipeline();
662      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
663    }
664    @Override
665    public byte[] lindex(final byte[] key, final long index) {
666      checkIsInMultiOrPipeline();
667      return connection.executeCommand(commandObjects.lindex(key, index));
668    }
669    @Override
670    public String lset(final byte[] key, final long index, final byte[] value) {
671      checkIsInMultiOrPipeline();
672      return connection.executeCommand(commandObjects.lset(key, index, value));
673    }
674    @Override
675    public long lrem(final byte[] key, final long count, final byte[] value) {
676      checkIsInMultiOrPipeline();
677      return connection.executeCommand(commandObjects.lrem(key, count, value));
678    }
679    @Override
680    public byte[] lpop(final byte[] key) {
681      checkIsInMultiOrPipeline();
682      return connection.executeCommand(commandObjects.lpop(key));
683    }
684    @Override
685    public List&lt;byte[]&gt; lpop(final byte[] key, final int count) {
686      checkIsInMultiOrPipeline();
687      return connection.executeCommand(commandObjects.lpop(key, count));
688    }
689    @Override
690    public Long lpos(final byte[] key, final byte[] element) {
691      checkIsInMultiOrPipeline();
692      return connection.executeCommand(commandObjects.lpos(key, element));
693    }
694    @Override
695    public Long lpos(final byte[] key, final byte[] element, final LPosParams params) {
696      checkIsInMultiOrPipeline();
697      return connection.executeCommand(commandObjects.lpos(key, element, params));
698    }
699    @Override
700    public List&lt;Long&gt; lpos(final byte[] key, final byte[] element, final LPosParams params,
701        final long count) {
702      checkIsInMultiOrPipeline();
703      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
704    }
705    @Override
706    public byte[] rpop(final byte[] key) {
707      checkIsInMultiOrPipeline();
708      return connection.executeCommand(commandObjects.rpop(key));
709    }
710    @Override
711    public List&lt;byte[]&gt; rpop(final byte[] key, final int count) {
712      checkIsInMultiOrPipeline();
713      return connection.executeCommand(commandObjects.rpop(key, count));
714    }
715    @Override
716    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
717      checkIsInMultiOrPipeline();
718      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
719    }
720    @Override
721    public long sadd(final byte[] key, final byte[]... members) {
722      checkIsInMultiOrPipeline();
723      return connection.executeCommand(commandObjects.sadd(key, members));
724    }
725    @Override
726    public Set&lt;byte[]&gt; smembers(final byte[] key) {
727      checkIsInMultiOrPipeline();
728      return connection.executeCommand(commandObjects.smembers(key));
729    }
730    @Override
731    public long srem(final byte[] key, final byte[]... members) {
732      checkIsInMultiOrPipeline();
733      return connection.executeCommand(commandObjects.srem(key, members));
734    }
735    @Override
736    public byte[] spop(final byte[] key) {
737      checkIsInMultiOrPipeline();
738      return connection.executeCommand(commandObjects.spop(key));
739    }
740    @Override
741    public Set&lt;byte[]&gt; spop(final byte[] key, final long count) {
742      checkIsInMultiOrPipeline();
743      return connection.executeCommand(commandObjects.spop(key, count));
744    }
745    @Override
746    public long smove(final byte[] srckey, final byte[] dstkey, final byte[] member) {
747      checkIsInMultiOrPipeline();
748      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
749    }
750    @Override
751    public long scard(final byte[] key) {
752      checkIsInMultiOrPipeline();
753      return connection.executeCommand(commandObjects.scard(key));
754    }
755    @Override
756    public boolean sismember(final byte[] key, final byte[] member) {
757      checkIsInMultiOrPipeline();
758      return connection.executeCommand(commandObjects.sismember(key, member));
759    }
760    @Override
761    public List&lt;Boolean&gt; smismember(final byte[] key, final byte[]... members) {
762      checkIsInMultiOrPipeline();
763      return connection.executeCommand(commandObjects.smismember(key, members));
764    }
765    @Override
766    public Set&lt;byte[]&gt; sinter(final byte[]... keys) {
767      checkIsInMultiOrPipeline();
768      return connection.executeCommand(commandObjects.sinter(keys));
769    }
770    @Override
771    public long sinterstore(final byte[] dstkey, final byte[]... keys) {
772      checkIsInMultiOrPipeline();
773      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
774    }
775    @Override
776    public long sintercard(byte[]... keys) {
777      checkIsInMultiOrPipeline();
778      return connection.executeCommand(commandObjects.sintercard(keys));
779    }
780    @Override
781    public long sintercard(int limit, byte[]... keys) {
782      checkIsInMultiOrPipeline();
783      return connection.executeCommand(commandObjects.sintercard(limit, keys));
784    }
785    @Override
786    public Set&lt;byte[]&gt; sunion(final byte[]... keys) {
787      checkIsInMultiOrPipeline();
788      return connection.executeCommand(commandObjects.sunion(keys));
789    }
790    @Override
791    public long sunionstore(final byte[] dstkey, final byte[]... keys) {
792      checkIsInMultiOrPipeline();
793      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
794    }
795    @Override
796    public Set&lt;byte[]&gt; sdiff(final byte[]... keys) {
797      checkIsInMultiOrPipeline();
798      return connection.executeCommand(commandObjects.sdiff(keys));
799    }
800    @Override
801    public long sdiffstore(final byte[] dstkey, final byte[]... keys) {
802      checkIsInMultiOrPipeline();
803      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
804    }
805    @Override
806    public byte[] srandmember(final byte[] key) {
807      checkIsInMultiOrPipeline();
808      return connection.executeCommand(commandObjects.srandmember(key));
809    }
810    @Override
811    public List&lt;byte[]&gt; srandmember(final byte[] key, final int count) {
812      checkIsInMultiOrPipeline();
813      return connection.executeCommand(commandObjects.srandmember(key, count));
814    }
815    @Override
816    public long zadd(final byte[] key, final double score, final byte[] member) {
817      checkIsInMultiOrPipeline();
818      return connection.executeCommand(commandObjects.zadd(key, score, member));
819    }
820    @Override
821    public long zadd(final byte[] key, final double score, final byte[] member,
822        final ZAddParams params) {
823      checkIsInMultiOrPipeline();
824      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
825    }
826    @Override
827    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers) {
828      checkIsInMultiOrPipeline();
829      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
830    }
831    @Override
832    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers, final ZAddParams params) {
833      checkIsInMultiOrPipeline();
834      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
835    }
836    @Override
837    public Double zaddIncr(final byte[] key, final double score, final byte[] member, final ZAddParams params) {
838      checkIsInMultiOrPipeline();
839      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
840    }
841    @Override
842    public List&lt;byte[]&gt; zrange(final byte[] key, final long start, final long stop) {
843      checkIsInMultiOrPipeline();
844      return connection.executeCommand(commandObjects.zrange(key, start, stop));
845    }
846    @Override
847    public long zrem(final byte[] key, final byte[]... members) {
848      checkIsInMultiOrPipeline();
849      return connection.executeCommand(commandObjects.zrem(key, members));
850    }
851    @Override
852    public double zincrby(final byte[] key, final double increment, final byte[] member) {
853      checkIsInMultiOrPipeline();
854      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
855    }
856    @Override
857    public Double zincrby(final byte[] key, final double increment, final byte[] member,
858        final ZIncrByParams params) {
859      checkIsInMultiOrPipeline();
860      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
861    }
862    @Override
863    public Long zrank(final byte[] key, final byte[] member) {
864      checkIsInMultiOrPipeline();
865      return connection.executeCommand(commandObjects.zrank(key, member));
866    }
867    @Override
868    public Long zrevrank(final byte[] key, final byte[] member) {
869      checkIsInMultiOrPipeline();
870      return connection.executeCommand(commandObjects.zrevrank(key, member));
871    }
872    @Override
873    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
874      checkIsInMultiOrPipeline();
875      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
876    }
877    @Override
878    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
879      checkIsInMultiOrPipeline();
880      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
881    }
882    @Override
883    public List&lt;byte[]&gt; zrevrange(final byte[] key, final long start, final long stop) {
884      checkIsInMultiOrPipeline();
885      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
886    }
887    @Override
888    public List&lt;Tuple&gt; zrangeWithScores(final byte[] key, final long start, final long stop) {
889      checkIsInMultiOrPipeline();
890      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
891    }
892    @Override
893    public List&lt;Tuple&gt; zrevrangeWithScores(final byte[] key, final long start, final long stop) {
894      checkIsInMultiOrPipeline();
895      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
896    }
897    @Override
898    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
899      checkIsInMultiOrPipeline();
900      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
901    }
902    @Override
903    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
904      checkIsInMultiOrPipeline();
905      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
906    }
907    @Override
908    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
909      checkIsInMultiOrPipeline();
910      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
911    }
912    @Override
913    public byte[] zrandmember(final byte[] key) {
914      checkIsInMultiOrPipeline();
915      return connection.executeCommand(commandObjects.zrandmember(key));
916    }
917    @Override
918    public List&lt;byte[]&gt; zrandmember(final byte[] key, final long count) {
919      checkIsInMultiOrPipeline();
920      return connection.executeCommand(commandObjects.zrandmember(key, count));
921    }
922    @Override
923    public List&lt;Tuple&gt; zrandmemberWithScores(final byte[] key, final long count) {
924      checkIsInMultiOrPipeline();
925      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
926    }
927    @Override
928    public long zcard(final byte[] key) {
929      checkIsInMultiOrPipeline();
930      return connection.executeCommand(commandObjects.zcard(key));
931    }
932    @Override
933    public Double zscore(final byte[] key, final byte[] member) {
934      checkIsInMultiOrPipeline();
935      return connection.executeCommand(commandObjects.zscore(key, member));
936    }
937    @Override
938    public List&lt;Double&gt; zmscore(final byte[] key, final byte[]... members) {
939      checkIsInMultiOrPipeline();
940      return connection.executeCommand(commandObjects.zmscore(key, members));
941    }
942    @Override
943    public Tuple zpopmax(final byte[] key) {
944      checkIsInMultiOrPipeline();
945      return connection.executeCommand(commandObjects.zpopmax(key));
946    }
947    @Override
948    public List&lt;Tuple&gt; zpopmax(final byte[] key, final int count) {
949      checkIsInMultiOrPipeline();
950      return connection.executeCommand(commandObjects.zpopmax(key, count));
951    }
952    @Override
953    public Tuple zpopmin(final byte[] key) {
954      checkIsInMultiOrPipeline();
955      return connection.executeCommand(commandObjects.zpopmin(key));
956    }
957    @Override
958    public List&lt;Tuple&gt; zpopmin(final byte[] key, final int count) {
959      checkIsInMultiOrPipeline();
960      return connection.executeCommand(commandObjects.zpopmin(key, count));
961    }
962    public String watch(final byte[]... keys) {
963      checkIsInMultiOrPipeline();
964      connection.sendCommand(WATCH, keys);
965      String status = connection.getStatusCodeReply();
966      isInWatch = true;
967      return status;
968    }
969    public String unwatch() {
970      checkIsInMultiOrPipeline();
971      connection.sendCommand(UNWATCH);
972      return connection.getStatusCodeReply();
973    }
974    @Override
975    public List&lt;byte[]&gt; sort(final byte[] key) {
976      checkIsInMultiOrPipeline();
977      return connection.executeCommand(commandObjects.sort(key));
978    }
979    @Override
980    public List&lt;byte[]&gt; sort(final byte[] key, final SortingParams sortingParams) {
981      checkIsInMultiOrPipeline();
982      return connection.executeCommand(commandObjects.sort(key, sortingParams));
983    }
984    @Override
985    public long sort(final byte[] key, final SortingParams sortingParams, final byte[] dstkey) {
986      checkIsInMultiOrPipeline();
987      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
988    }
989    @Override
990    public long sort(final byte[] key, final byte[] dstkey) {
991      checkIsInMultiOrPipeline();
992      return connection.executeCommand(commandObjects.sort(key, dstkey));
993    }
994    @Override
995    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
996      checkIsInMultiOrPipeline();
997      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
998    }
999    @Override
1000    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1001      checkIsInMultiOrPipeline();
1002      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1003    }
1004    @Override
1005    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1006      checkIsInMultiOrPipeline();
1007      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1008    }
1009    @Override
1010    public List&lt;byte[]&gt; blpop(final int timeout, final byte[]... keys) {
1011      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1012    }
1013    @Override
1014    public KeyValue&lt;byte[], byte[]&gt; blpop(final double timeout, final byte[]... keys) {
1015      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1016    }
1017    @Override
1018    public List&lt;byte[]&gt; brpop(final int timeout, final byte[]... keys) {
1019      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1020    }
1021    @Override
1022    public KeyValue&lt;byte[], byte[]&gt; brpop(final double timeout, final byte[]... keys) {
1023      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1024    }
1025    @Override
1026    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1027      checkIsInMultiOrPipeline();
1028      return connection.executeCommand(commandObjects.lmpop(direction, keys));
1029    }
1030    @Override
1031    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1032      checkIsInMultiOrPipeline();
1033      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
1034    }
1035    @Override
1036    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1037      checkIsInMultiOrPipeline();
1038      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
1039    }
1040    @Override
1041    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1042      checkIsInMultiOrPipeline();
1043      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1044    }
1045    @Override
1046    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(final double timeout, final byte[]... keys) {
1047      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
1048    }
1049    @Override
1050    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(final double timeout, final byte[]... keys) {
1051      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
1052    }
1053    @Override
1054    public String auth(final String password) {
1055      checkIsInMultiOrPipeline();
1056      connection.sendCommand(Command.AUTH, password);
1057      return connection.getStatusCodeReply();
1058    }
1059    @Override
1060    public String auth(final String user, final String password) {
1061      checkIsInMultiOrPipeline();
1062      connection.sendCommand(Command.AUTH, user, password);
1063      return connection.getStatusCodeReply();
1064    }
1065    @Override
1066    public long zcount(final byte[] key, final double min, final double max) {
1067      checkIsInMultiOrPipeline();
1068      return connection.executeCommand(commandObjects.zcount(key, min, max));
1069    }
1070    @Override
1071    public long zcount(final byte[] key, final byte[] min, final byte[] max) {
1072      checkIsInMultiOrPipeline();
1073      return connection.executeCommand(commandObjects.zcount(key, min, max));
1074    }
1075    @Override
1076    public List&lt;byte[]&gt; zdiff(final byte[]... keys) {
1077      checkIsInMultiOrPipeline();
1078      return connection.executeCommand(commandObjects.zdiff(keys));
1079    }
1080    @Override
1081    public List&lt;Tuple&gt; zdiffWithScores(final byte[]... keys) {
1082      checkIsInMultiOrPipeline();
1083      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
1084    }
1085    @Override
1086    @Deprecated
1087    public long zdiffStore(final byte[] dstkey, final byte[]... keys) {
1088      checkIsInMultiOrPipeline();
1089      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
1090    }
1091    @Override
1092    public long zdiffstore(final byte[] dstkey, final byte[]... keys) {
1093      checkIsInMultiOrPipeline();
1094      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
1095    }
1096    @Override
1097    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max) {
1098      checkIsInMultiOrPipeline();
1099      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1100    }
1101    @Override
1102    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1103      checkIsInMultiOrPipeline();
1104      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1105    }
1106    @Override
1107    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max,
1108        final int offset, final int count) {
1109      checkIsInMultiOrPipeline();
1110      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1111    }
1112    @Override
1113    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
1114        final int offset, final int count) {
1115      checkIsInMultiOrPipeline();
1116      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1117    }
1118    @Override
1119    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
1120      checkIsInMultiOrPipeline();
1121      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1122    }
1123    @Override
1124    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
1125      checkIsInMultiOrPipeline();
1126      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1127    }
1128    @Override
1129    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max,
1130        final int offset, final int count) {
1131      checkIsInMultiOrPipeline();
1132      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1133    }
1134    @Override
1135    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
1136        final int offset, final int count) {
1137      checkIsInMultiOrPipeline();
1138      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1139    }
1140    @Override
1141    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min) {
1142      checkIsInMultiOrPipeline();
1143      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1144    }
1145    @Override
1146    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
1147      checkIsInMultiOrPipeline();
1148      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1149    }
1150    @Override
1151    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min,
1152        final int offset, final int count) {
1153      checkIsInMultiOrPipeline();
1154      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1155    }
1156    @Override
1157    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
1158        final int offset, final int count) {
1159      checkIsInMultiOrPipeline();
1160      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1161    }
1162    @Override
1163    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
1164      checkIsInMultiOrPipeline();
1165      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1166    }
1167    @Override
1168    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max,
1169        final double min, final int offset, final int count) {
1170      checkIsInMultiOrPipeline();
1171      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1172    }
1173    @Override
1174    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
1175      checkIsInMultiOrPipeline();
1176      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1177    }
1178    @Override
1179    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
1180        final byte[] min, final int offset, final int count) {
1181      checkIsInMultiOrPipeline();
1182      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1183    }
1184    @Override
1185    public long zremrangeByRank(final byte[] key, final long start, final long stop) {
1186      checkIsInMultiOrPipeline();
1187      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1188    }
1189    @Override
1190    public long zremrangeByScore(final byte[] key, final double min, final double max) {
1191      checkIsInMultiOrPipeline();
1192      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1193    }
1194    @Override
1195    public long zremrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1196      checkIsInMultiOrPipeline();
1197      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1198    }
1199    @Override
1200    public List&lt;byte[]&gt; zunion(final ZParams params, final byte[]... keys) {
1201      checkIsInMultiOrPipeline();
1202      return connection.executeCommand(commandObjects.zunion(params, keys));
1203    }
1204    @Override
1205    public List&lt;Tuple&gt; zunionWithScores(final ZParams params, final byte[]... keys) {
1206      checkIsInMultiOrPipeline();
1207      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
1208    }
1209    @Override
1210    public long zunionstore(final byte[] dstkey, final byte[]... sets) {
1211      checkIsInMultiOrPipeline();
1212      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
1213    }
1214    @Override
1215    public long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1216      checkIsInMultiOrPipeline();
1217      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1218    }
1219    @Override
1220    public List&lt;byte[]&gt; zinter(final ZParams params, final byte[]... keys) {
1221      checkIsInMultiOrPipeline();
1222      return connection.executeCommand(commandObjects.zinter(params, keys));
1223    }
1224    @Override
1225    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final byte[]... keys) {
1226      checkIsInMultiOrPipeline();
1227      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
1228    }
1229    @Override
1230    public long zinterstore(final byte[] dstkey, final byte[]... sets) {
1231      checkIsInMultiOrPipeline();
1232      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
1233    }
1234    @Override
1235    public long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1236      checkIsInMultiOrPipeline();
1237      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1238    }
1239    @Override
1240    public long zintercard(byte[]... keys) {
1241      checkIsInMultiOrPipeline();
1242      return connection.executeCommand(commandObjects.zintercard(keys));
1243    }
1244    @Override
1245    public long zintercard(long limit, byte[]... keys) {
1246      checkIsInMultiOrPipeline();
1247      return connection.executeCommand(commandObjects.zintercard(limit, keys));
1248    }
1249    @Override
1250    public long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
1251      checkIsInMultiOrPipeline();
1252      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
1253    }
1254    @Override
1255    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1256      checkIsInMultiOrPipeline();
1257      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
1258    }
1259    @Override
1260    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
1261        final int offset, final int count) {
1262      checkIsInMultiOrPipeline();
1263      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1264    }
1265    @Override
1266    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min) {
1267      checkIsInMultiOrPipeline();
1268      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1269    }
1270    @Override
1271    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
1272        final int offset, final int count) {
1273      checkIsInMultiOrPipeline();
1274      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1275    }
1276    @Override
1277    public long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1278      checkIsInMultiOrPipeline();
1279      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
1280    }
1281    @Override
1282    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1283      checkIsInMultiOrPipeline();
1284      return connection.executeCommand(commandObjects.zmpop(option, keys));
1285    }
1286    @Override
1287    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1288      checkIsInMultiOrPipeline();
1289      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
1290    }
1291    @Override
1292    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1293      checkIsInMultiOrPipeline();
1294      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
1295    }
1296    @Override
1297    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
1298      checkIsInMultiOrPipeline();
1299      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1300    }
1301    @Override
1302    public String save() {
1303      connection.sendCommand(Command.SAVE);
1304      return connection.getStatusCodeReply();
1305    }
1306    @Override
1307    public String bgsave() {
1308      connection.sendCommand(BGSAVE);
1309      return connection.getStatusCodeReply();
1310    }
1311    @Override
1312    public String bgsaveSchedule() {
1313      connection.sendCommand(BGSAVE, SCHEDULE);
1314      return connection.getStatusCodeReply();
1315    }
1316    @Override
1317    public String bgrewriteaof() {
1318      connection.sendCommand(BGREWRITEAOF);
1319      return connection.getStatusCodeReply();
1320    }
1321    @Override
1322    public long lastsave() {
1323      connection.sendCommand(LASTSAVE);
1324      return connection.getIntegerReply();
1325    }
1326    @Override
1327    public void shutdown() throws JedisException {
1328      connection.sendCommand(SHUTDOWN);
1329      try {
1330        throw new JedisException(connection.getStatusCodeReply());
1331      } catch (JedisConnectionException jce) {
1332        connection.setBroken();
1333      }
1334    }
1335    @Override
1336    public void shutdown(ShutdownParams shutdownParams) throws JedisException {
1337      connection.sendCommand(new CommandArguments(SHUTDOWN).addParams(shutdownParams));
1338      try {
1339        throw new JedisException(connection.getStatusCodeReply());
1340      } catch (JedisConnectionException jce) {
1341        connection.setBroken();
1342      }
1343    }
1344    @Override
1345    public String shutdownAbort() {
1346      connection.sendCommand(SHUTDOWN, ABORT);
1347      return connection.getStatusCodeReply();
1348    }
1349    @Override
1350    public String info() {
1351      connection.sendCommand(Command.INFO);
1352      return connection.getBulkReply();
1353    }
1354    @Override
1355    public String info(final String section) {
1356      connection.sendCommand(Command.INFO, section);
1357      return connection.getBulkReply();
1358    }
1359    public void monitor(final JedisMonitor jedisMonitor) {
1360      connection.sendCommand(Command.MONITOR);
1361      connection.getStatusCodeReply();
1362      jedisMonitor.proceed(connection);
1363    }
1364    @Override
1365    @Deprecated
1366    public String slaveof(final String host, final int port) {
1367      connection.sendCommand(SLAVEOF, encode(host), toByteArray(port));
1368      return connection.getStatusCodeReply();
1369    }
1370    @Override
1371    @Deprecated
1372    public String slaveofNoOne() {
1373      connection.sendCommand(SLAVEOF, NO.getRaw(), ONE.getRaw());
1374      return connection.getStatusCodeReply();
1375    }
1376    @Override
1377    public String replicaof(final String host, final int port) {
1378      connection.sendCommand(REPLICAOF, encode(host), toByteArray(port));
1379      return connection.getStatusCodeReply();
1380    }
1381    @Override
1382    public String replicaofNoOne() {
1383      connection.sendCommand(REPLICAOF, NO.getRaw(), ONE.getRaw());
1384      return connection.getStatusCodeReply();
1385    }
1386    @Override
1387    public List&lt;Object&gt; roleBinary() {
1388      checkIsInMultiOrPipeline();
1389      connection.sendCommand(ROLE);
1390      return BuilderFactory.RAW_OBJECT_LIST.build(connection.getOne());
1391    }
1392    @Override
1393    public Map&lt;byte[], byte[]&gt; configGet(final byte[] pattern) {
1394      checkIsInMultiOrPipeline();
1395      connection.sendCommand(Command.CONFIG, Keyword.GET.getRaw(), pattern);
1396      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1397    }
1398    @Override
1399    public Map&lt;byte[], byte[]&gt; configGet(byte[]... patterns) {
1400      checkIsInMultiOrPipeline();
1401      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.getRaw(), patterns));
1402      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1403    }
1404    @Override
1405    public String configResetStat() {
1406      checkIsInMultiOrPipeline();
1407      connection.sendCommand(Command.CONFIG, Keyword.RESETSTAT);
1408      return connection.getStatusCodeReply();
1409    }
1410    @Override
1411    public String configRewrite() {
1412      checkIsInMultiOrPipeline();
1413      connection.sendCommand(Command.CONFIG, Keyword.REWRITE);
1414      return connection.getStatusCodeReply();
1415    }
1416    @Override
1417    public String configSet(final byte[] parameter, final byte[] value) {
1418      checkIsInMultiOrPipeline();
1419      connection.sendCommand(Command.CONFIG, Keyword.SET.getRaw(), parameter, value);
1420      return connection.getStatusCodeReply();
1421    }
1422    @Override
1423    public String configSet(final byte[]... parameterValues) {
1424      checkIsInMultiOrPipeline();
1425      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.getRaw(), parameterValues));
1426      return connection.getStatusCodeReply();
1427    }
1428    @Override
1429    public String configSetBinary(Map&lt;byte[], byte[]&gt; parameterValues) {
1430      checkIsInMultiOrPipeline();
1431      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
1432      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
1433      connection.sendCommand(args);
1434      return connection.getStatusCodeReply();
1435    }
1436    @Override
1437    public long strlen(final byte[] key) {
1438      checkIsInMultiOrPipeline();
1439      return connection.executeCommand(commandObjects.strlen(key));
1440    }
1441    @Override
1442    public LCSMatchResult lcs(final byte[] keyA, final byte[] keyB, final LCSParams params) {
1443      checkIsInMultiOrPipeline();
1444      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
1445    }
1446    @Override
1447    public long lpushx(final byte[] key, final byte[]... strings) {
1448      checkIsInMultiOrPipeline();
1449      return connection.executeCommand(commandObjects.lpushx(key, strings));
1450    }
1451    @Override
1452    public long persist(final byte[] key) {
1453      checkIsInMultiOrPipeline();
1454      return connection.executeCommand(commandObjects.persist(key));
1455    }
1456    @Override
1457    public long rpushx(final byte[] key, final byte[]... strings) {
1458      checkIsInMultiOrPipeline();
1459      return connection.executeCommand(commandObjects.rpushx(key, strings));
1460    }
1461    @Override
1462    public byte[] echo(final byte[] string) {
1463      checkIsInMultiOrPipeline();
1464      connection.sendCommand(ECHO, string);
1465      return connection.getBinaryBulkReply();
1466    }
1467    @Override
1468    public long linsert(final byte[] key, final ListPosition where, final byte[] pivot,
1469        final byte[] value) {
1470      checkIsInMultiOrPipeline();
1471      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
1472    }
1473    @Override
1474    public byte[] brpoplpush(final byte[] source, final byte[] destination, final int timeout) {
1475      checkIsInMultiOrPipeline();
1476      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1477    }
1478    @Override
1479    public boolean setbit(final byte[] key, final long offset, final boolean value) {
1480      checkIsInMultiOrPipeline();
1481      return connection.executeCommand(commandObjects.setbit(key, offset, value));
1482    }
1483    @Override
1484    public boolean getbit(final byte[] key, final long offset) {
1485      checkIsInMultiOrPipeline();
1486      return connection.executeCommand(commandObjects.getbit(key, offset));
1487    }
1488    @Override
1489    public long bitpos(final byte[] key, final boolean value) {
1490      return bitpos(key, value, new BitPosParams());
1491    }
1492    @Override
1493    public long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
1494      checkIsInMultiOrPipeline();
1495      return connection.executeCommand(commandObjects.bitpos(key, value, params));
1496    }
1497    @Override
1498    public long setrange(final byte[] key, final long offset, final byte[] value) {
1499      checkIsInMultiOrPipeline();
1500      return connection.executeCommand(commandObjects.setrange(key, offset, value));
1501    }
1502    @Override
1503    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
1504      checkIsInMultiOrPipeline();
1505      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
1506    }
1507    public long publish(final byte[] channel, final byte[] message) {
1508      checkIsInMultiOrPipeline();
1509      return connection.executeCommand(commandObjects.publish(channel, message));
1510    }
1511    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
1512      jedisPubSub.proceed(connection, channels);
1513    }
1514    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
1515      jedisPubSub.proceedWithPatterns(connection, patterns);
1516    }
1517    @Override
1518    public Object eval(final byte[] script, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1519      checkIsInMultiOrPipeline();
1520      return connection.executeCommand(commandObjects.eval(script, keys, args));
1521    }
1522    @Override
1523    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1524      checkIsInMultiOrPipeline();
1525      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
1526    }
1527    protected static byte[][] getParamsWithBinary(List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1528      final int keyCount = keys.size();
1529      final int argCount = args.size();
1530      byte[][] params = new byte[keyCount + argCount][];
1531      for (int i = 0; i &lt; keyCount; i++)
1532        params[i] = keys.get(i);
1533      for (int i = 0; i &lt; argCount; i++)
1534        params[keyCount + i] = args.get(i);
1535      return params;
1536    }
1537    @Override
1538    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
1539      checkIsInMultiOrPipeline();
1540      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
1541    }
1542    @Override
1543    public Object eval(final byte[] script) {
1544      checkIsInMultiOrPipeline();
1545      return connection.executeCommand(commandObjects.eval(script));
1546    }
1547    @Override
1548    public Object evalsha(final byte[] sha1) {
1549      checkIsInMultiOrPipeline();
1550      return connection.executeCommand(commandObjects.evalsha(sha1));
1551    }
1552    @Override
1553    public Object evalsha(final byte[] sha1, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1554      checkIsInMultiOrPipeline();
1555      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
1556    }
1557    @Override
1558    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1559      checkIsInMultiOrPipeline();
1560      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1561    }
1562    @Override
1563    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
1564      checkIsInMultiOrPipeline();
1565      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
1566    }
1567    @Override
1568    public String scriptFlush() {
1569      connection.sendCommand(SCRIPT, FLUSH);
1570      return connection.getStatusCodeReply();
1571    }
1572    @Override
1573    public String scriptFlush(final FlushMode flushMode) {
1574      connection.sendCommand(SCRIPT, FLUSH.getRaw(), flushMode.getRaw());
1575      return connection.getStatusCodeReply();
1576    }
1577    @Override
1578    public Boolean scriptExists(final byte[] sha1) {
1579      byte[][] a = new byte[1][];
1580      a[0] = sha1;
1581      return scriptExists(a).get(0);
1582    }
1583    @Override
1584    public List&lt;Boolean&gt; scriptExists(final byte[]... sha1) {
1585      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.getRaw(), sha1));
1586      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
1587    }
1588    @Override
1589    public byte[] scriptLoad(final byte[] script) {
1590      connection.sendCommand(SCRIPT, LOAD.getRaw(), script);
1591      return connection.getBinaryBulkReply();
1592    }
1593    @Override
1594    public String scriptKill() {
1595      return connection.executeCommand(commandObjects.scriptKill());
1596    }
1597    @Override
1598    public String slowlogReset() {
1599      return connection.executeCommand(commandObjects.slowlogReset());
1600    }
1601    @Override
1602    public long slowlogLen() {
1603      connection.sendCommand(SLOWLOG, LEN);
1604      return connection.getIntegerReply();
1605    }
1606    @Override
1607    public List&lt;Object&gt; slowlogGetBinary() {
1608      connection.sendCommand(SLOWLOG, Keyword.GET);
1609      return connection.getObjectMultiBulkReply();
1610    }
1611    @Override
1612    public List&lt;Object&gt; slowlogGetBinary(final long entries) {
1613      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
1614      return connection.getObjectMultiBulkReply();
1615    }
1616    @Override
1617    public Long objectRefcount(final byte[] key) {
1618      connection.sendCommand(OBJECT, REFCOUNT.getRaw(), key);
1619      return connection.getIntegerReply();
1620    }
1621    @Override
1622    public byte[] objectEncoding(final byte[] key) {
1623      connection.sendCommand(OBJECT, ENCODING.getRaw(), key);
1624      return connection.getBinaryBulkReply();
1625    }
1626    @Override
1627    public Long objectIdletime(final byte[] key) {
1628      connection.sendCommand(OBJECT, IDLETIME.getRaw(), key);
1629      return connection.getIntegerReply();
1630    }
1631    @Override
1632    public List&lt;byte[]&gt; objectHelpBinary() {
1633      connection.sendCommand(OBJECT, HELP);
1634      return connection.getBinaryMultiBulkReply();
1635    }
1636    @Override
1637    public Long objectFreq(final byte[] key) {
1638      connection.sendCommand(OBJECT, FREQ.getRaw(), key);
1639      return connection.getIntegerReply();
1640    }
1641    @Override
1642    public long bitcount(final byte[] key) {
1643      checkIsInMultiOrPipeline();
1644      return connection.executeCommand(commandObjects.bitcount(key));
1645    }
1646    @Override
1647    public long bitcount(final byte[] key, final long start, final long end) {
1648      checkIsInMultiOrPipeline();
1649      return connection.executeCommand(commandObjects.bitcount(key, start, end));
1650    }
1651    @Override
1652    public long bitcount(final byte[] key, final long start, final long end, final BitCountOption option) {
1653      checkIsInMultiOrPipeline();
1654      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
1655    }
1656    @Override
1657    public long bitop(final BitOP op, final byte[] destKey, final byte[]... srcKeys) {
1658      checkIsInMultiOrPipeline();
1659      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
1660    }
1661    @Override
1662    public byte[] dump(final byte[] key) {
1663      checkIsInMultiOrPipeline();
1664      return connection.executeCommand(commandObjects.dump(key));
1665    }
1666    @Override
1667    public String restore(final byte[] key, final long ttl, final byte[] serializedValue) {
1668      checkIsInMultiOrPipeline();
1669      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
1670    }
1671    @Override
1672    public String restore(final byte[] key, final long ttl, final byte[] serializedValue,
1673        final RestoreParams params) {
1674      checkIsInMultiOrPipeline();
1675      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
1676    }
1677    @Override
1678    public long pttl(final byte[] key) {
1679      checkIsInMultiOrPipeline();
1680      return connection.executeCommand(commandObjects.pttl(key));
1681    }
1682    @Override
1683    public String psetex(final byte[] key, final long milliseconds, final byte[] value) {
1684      checkIsInMultiOrPipeline();
1685      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
1686    }
1687    @Override
1688    public byte[] memoryDoctorBinary() {
1689      checkIsInMultiOrPipeline();
1690      connection.sendCommand(MEMORY, DOCTOR);
1691      return connection.getBinaryBulkReply();
1692    }
1693    @Override
1694    public Long memoryUsage(final byte[] key) {
1695      checkIsInMultiOrPipeline();
1696      connection.sendCommand(MEMORY, USAGE.getRaw(), key);
1697      return connection.getIntegerReply();
1698    }
1699    @Override
1700    public Long memoryUsage(final byte[] key, final int samples) {
1701      checkIsInMultiOrPipeline();
1702      connection.sendCommand(MEMORY, USAGE.getRaw(), key, SAMPLES.getRaw(), toByteArray(samples));
1703      return connection.getIntegerReply();
1704    }
1705    @Override
1706    public String failover() {
1707      checkIsInMultiOrPipeline();
1708      connection.sendCommand(Command.FAILOVER);
1709      connection.setTimeoutInfinite();
1710      try {
1711        return connection.getStatusCodeReply();
1712      } finally {
1713        connection.rollbackTimeout();
1714      }
1715    }
1716    @Override
1717    public String failover(FailoverParams failoverParams) {
1718      checkIsInMultiOrPipeline();
1719      CommandArguments args = new ClusterCommandArguments(Command.FAILOVER).addParams(failoverParams);
1720      connection.sendCommand(args);
1721      connection.setTimeoutInfinite();
1722      try {
1723        return connection.getStatusCodeReply();
1724      } finally {
1725        connection.rollbackTimeout();
1726      }
1727    }
1728    @Override
1729    public String failoverAbort() {
1730      checkIsInMultiOrPipeline();
1731      connection.sendCommand(Command.FAILOVER, ABORT);
1732      return connection.getStatusCodeReply();
1733    }
1734    @Override
1735    public byte[] aclWhoAmIBinary() {
1736      checkIsInMultiOrPipeline();
1737      connection.sendCommand(ACL, WHOAMI);
1738      return connection.getBinaryBulkReply();
1739    }
1740    @Override
1741    public byte[] aclGenPassBinary() {
1742      checkIsInMultiOrPipeline();
1743      connection.sendCommand(ACL, GENPASS);
1744      return connection.getBinaryBulkReply();
1745    }
1746    @Override
1747    public byte[] aclGenPassBinary(int bits) {
1748      checkIsInMultiOrPipeline();
1749      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
1750      return connection.getBinaryBulkReply();
1751    }
1752    @Override
1753    public List&lt;byte[]&gt; aclListBinary() {
1754      checkIsInMultiOrPipeline();
1755      connection.sendCommand(ACL, LIST);
1756      return connection.getBinaryMultiBulkReply();
1757    }
1758    @Override
1759    public List&lt;byte[]&gt; aclUsersBinary() {
1760      checkIsInMultiOrPipeline();
1761      connection.sendCommand(ACL, USERS);
1762      return connection.getBinaryMultiBulkReply();
1763    }
1764    @Override
1765    public AccessControlUser aclGetUser(byte[] name) {
1766      checkIsInMultiOrPipeline();
1767      connection.sendCommand(ACL, GETUSER.getRaw(), name);
1768      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getObjectMultiBulkReply());
1769    }
1770    @Override
1771    public String aclSetUser(byte[] name) {
1772      checkIsInMultiOrPipeline();
1773      connection.sendCommand(ACL, SETUSER.getRaw(), name);
1774      return connection.getStatusCodeReply();
1775    }
1776    @Override
1777    public String aclSetUser(byte[] name, byte[]... rules) {
1778      checkIsInMultiOrPipeline();
1779      connection.sendCommand(ACL, joinParameters(SETUSER.getRaw(), name, rules));
1780      return connection.getStatusCodeReply();
1781    }
1782    @Override
1783    public long aclDelUser(byte[]... names) {
1784      checkIsInMultiOrPipeline();
1785      connection.sendCommand(ACL, joinParameters(DELUSER.getRaw(), names));
1786      return connection.getIntegerReply();
1787    }
1788    @Override
1789    public List&lt;byte[]&gt; aclCatBinary() {
1790      checkIsInMultiOrPipeline();
1791      connection.sendCommand(ACL, CAT);
1792      return connection.getBinaryMultiBulkReply();
1793    }
1794    @Override
1795    public List&lt;byte[]&gt; aclCat(byte[] category) {
1796      checkIsInMultiOrPipeline();
1797      connection.sendCommand(ACL, CAT.getRaw(), category);
1798      return connection.getBinaryMultiBulkReply();
1799    }
1800    @Override
1801    public List&lt;byte[]&gt; aclLogBinary() {
1802      checkIsInMultiOrPipeline();
1803      connection.sendCommand(ACL, LOG);
1804      return connection.getBinaryMultiBulkReply();
1805    }
1806    @Override
1807    public List&lt;byte[]&gt; aclLogBinary(int limit) {
1808      checkIsInMultiOrPipeline();
1809      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
1810      return connection.getBinaryMultiBulkReply();
1811    }
1812    @Override
1813    public String aclLogReset() {
1814      checkIsInMultiOrPipeline();
1815      connection.sendCommand(ACL, LOG.getRaw(), Keyword.RESET.getRaw());
1816      return connection.getStatusCodeReply();
1817    }
1818    @Override
1819    public String clientKill(final byte[] ipPort) {
1820      checkIsInMultiOrPipeline();
1821      connection.sendCommand(CLIENT, KILL.getRaw(), ipPort);
1822      return this.connection.getStatusCodeReply();
1823    }
1824    @Override
1825    public String clientKill(final String ip, final int port) {
1826      return clientKill(ip + &#x27;:&#x27; + port);
1827    }
1828    @Override
1829    public long clientKill(ClientKillParams params) {
1830      checkIsInMultiOrPipeline();
1831      connection.sendCommand(new CommandArguments(CLIENT).add(KILL).addParams(params));
1832      return this.connection.getIntegerReply();
1833    }
1834    @Override
1835    public byte[] clientGetnameBinary() {
1836      checkIsInMultiOrPipeline();
1837      connection.sendCommand(CLIENT, GETNAME);
1838      return connection.getBinaryBulkReply();
1839    }
1840    @Override
1841    public byte[] clientListBinary() {
1842      checkIsInMultiOrPipeline();
1843      connection.sendCommand(CLIENT, LIST);
1844      return connection.getBinaryBulkReply();
1845    }
1846    @Override
1847    public byte[] clientListBinary(ClientType type) {
1848      checkIsInMultiOrPipeline();
1849      connection.sendCommand(CLIENT, LIST.getRaw(), type.getRaw());
1850      return connection.getBinaryBulkReply();
1851    }
1852    @Override
1853    public byte[] clientListBinary(final long... clientIds) {
1854      checkIsInMultiOrPipeline();
1855      connection.sendCommand(CLIENT, clientListParams(clientIds));
1856      return connection.getBinaryBulkReply();
1857    }
1858    private byte[][] clientListParams(final long... clientIds) {
1859      final byte[][] params = new byte[2 + clientIds.length][];
1860      int index = 0;
1861      params[index++] = Keyword.LIST.getRaw();
1862      params[index++] = ID.getRaw();
1863      for (final long clientId : clientIds) {
1864        params[index++] = toByteArray(clientId);
1865      }
1866      return params;
1867    }
1868    @Override
1869    public byte[] clientInfoBinary() {
1870      checkIsInMultiOrPipeline();
1871      connection.sendCommand(CLIENT, Keyword.INFO);
1872      return connection.getBinaryBulkReply();
1873    }
1874    @Override
1875    public String clientSetInfo(ClientAttributeOption attr, byte[] value) {
1876      checkIsInMultiOrPipeline();
1877      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), value);
1878      return connection.getStatusCodeReply();
1879    }
1880    @Override
1881    public String clientSetname(final byte[] name) {
1882      checkIsInMultiOrPipeline();
1883      connection.sendCommand(CLIENT, SETNAME.getRaw(), name);
1884      return connection.getBulkReply();
1885    }
1886    @Override
1887    public long clientId() {
1888      checkIsInMultiOrPipeline();
1889      connection.sendCommand(CLIENT, ID);
1890      return connection.getIntegerReply();
1891    }
1892    @Override
1893    public long clientUnblock(final long clientId) {
1894      checkIsInMultiOrPipeline();
1895      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId));
1896      return connection.getIntegerReply();
1897    }
1898    @Override
1899    public long clientUnblock(final long clientId, final UnblockType unblockType) {
1900      checkIsInMultiOrPipeline();
1901      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId), unblockType.getRaw());
1902      return connection.getIntegerReply();
1903    }
1904    @Override
1905    public String clientPause(final long timeout) {
1906      checkIsInMultiOrPipeline();
1907      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout));
1908      return connection.getBulkReply();
1909    }
1910    @Override
1911    public String clientPause(final long timeout, final ClientPauseMode mode) {
1912      checkIsInMultiOrPipeline();
1913      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout), mode.getRaw());
1914      return connection.getBulkReply();
1915    }
1916    @Override
1917    public String clientUnpause() {
1918      checkIsInMultiOrPipeline();
1919      connection.sendCommand(CLIENT, UNPAUSE);
1920      return connection.getBulkReply();
1921    }
1922    @Override
1923    public String clientNoEvictOn() {
1924      checkIsInMultiOrPipeline();
1925      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;ON&quot;);
1926      return connection.getBulkReply();
1927    }
1928    @Override
1929    public String clientNoEvictOff() {
1930      checkIsInMultiOrPipeline();
1931      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;OFF&quot;);
1932      return connection.getBulkReply();
1933    }
1934    @Override
1935    public String clientNoTouchOn() {
1936      checkIsInMultiOrPipeline();
1937      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;ON&quot;);
1938      return connection.getStatusCodeReply();
1939    }
1940    @Override
1941    public String clientNoTouchOff() {
1942      checkIsInMultiOrPipeline();
1943      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;OFF&quot;);
1944      return connection.getStatusCodeReply();
1945    }
1946    public List&lt;String&gt; time() {
1947      checkIsInMultiOrPipeline();
1948      connection.sendCommand(Command.TIME);
1949      return connection.getMultiBulkReply();
1950    }
1951    @Override
1952    public String migrate(final String host, final int port, final byte[] key,
1953        final int destinationDb, final int timeout) {
1954      checkIsInMultiOrPipeline();
1955      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
1956    }
1957    @Override
1958    public String migrate(final String host, final int port, final int destinationDB,
1959        final int timeout, final MigrateParams params, final byte[]... keys) {
1960      checkIsInMultiOrPipeline();
1961      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
1962    }
1963    @Override
1964    public String migrate(String host, int port, byte[] key, int timeout) {
1965      checkIsInMultiOrPipeline();
1966      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
1967    }
1968    @Override
1969    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
1970      checkIsInMultiOrPipeline();
1971      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
1972    }
1973    @Override
1974    public long waitReplicas(final int replicas, final long timeout) {
1975      checkIsInMultiOrPipeline();
1976      connection.sendCommand(WAIT, toByteArray(replicas), toByteArray(timeout));
1977      return connection.getIntegerReply();
1978    }
1979    @Override
1980    public KeyValue&lt;Long, Long&gt; waitAOF(long numLocal, long numReplicas, long timeout) {
1981      checkIsInMultiOrPipeline();
1982      connection.sendCommand(WAITAOF, toByteArray(numLocal), toByteArray(numReplicas), toByteArray(timeout));
1983      return BuilderFactory.LONG_LONG_PAIR.build(connection.getOne());
1984    }
1985    @Override
1986    public long pfadd(final byte[] key, final byte[]... elements) {
1987      checkIsInMultiOrPipeline();
1988      return connection.executeCommand(commandObjects.pfadd(key, elements));
1989    }
1990    @Override
1991    public long pfcount(final byte[] key) {
1992      checkIsInMultiOrPipeline();
1993      return connection.executeCommand(commandObjects.pfcount(key));
1994    }
1995    @Override
1996    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
1997      checkIsInMultiOrPipeline();
1998      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
1999    }
2000    @Override
2001    public long pfcount(final byte[]... keys) {
2002      checkIsInMultiOrPipeline();
2003      return connection.executeCommand(commandObjects.pfcount(keys));
2004    }
2005    @Override
2006    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor) {
2007      checkIsInMultiOrPipeline();
2008      return connection.executeCommand(commandObjects.scan(cursor));
2009    }
2010    @Override
2011    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params) {
2012      checkIsInMultiOrPipeline();
2013      return connection.executeCommand(commandObjects.scan(cursor, params));
2014    }
2015    @Override
2016    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params, final byte[] type) {
2017      checkIsInMultiOrPipeline();
2018      return connection.executeCommand(commandObjects.scan(cursor, params, type));
2019    }
2020    @Override
2021    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor) {
2022      return hscan(key, cursor, new ScanParams());
2023    }
2024    @Override
2025    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor,
2026        final ScanParams params) {
2027      checkIsInMultiOrPipeline();
2028      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
2029    }
2030    @Override
2031    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor) {
2032      return sscan(key, cursor, new ScanParams());
2033    }
2034    @Override
2035    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2036      checkIsInMultiOrPipeline();
2037      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
2038    }
2039    @Override
2040    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor) {
2041      return zscan(key, cursor, new ScanParams());
2042    }
2043    @Override
2044    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2045      checkIsInMultiOrPipeline();
2046      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
2047    }
2048    @Override
2049    public long geoadd(final byte[] key, final double longitude, final double latitude,
2050        final byte[] member) {
2051      checkIsInMultiOrPipeline();
2052      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2053    }
2054    @Override
2055    public long geoadd(final byte[] key, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2056      checkIsInMultiOrPipeline();
2057      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2058    }
2059    @Override
2060    public long geoadd(final byte[] key, final GeoAddParams params, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2061      checkIsInMultiOrPipeline();
2062      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2063    }
2064    @Override
2065    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2) {
2066      checkIsInMultiOrPipeline();
2067      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
2068    }
2069    @Override
2070    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2,
2071        final GeoUnit unit) {
2072      checkIsInMultiOrPipeline();
2073      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
2074    }
2075    @Override
2076    public List&lt;byte[]&gt; geohash(final byte[] key, final byte[]... members) {
2077      checkIsInMultiOrPipeline();
2078      return connection.executeCommand(commandObjects.geohash(key, members));
2079    }
2080    @Override
2081    public List&lt;GeoCoordinate&gt; geopos(final byte[] key, final byte[]... members) {
2082      checkIsInMultiOrPipeline();
2083      return connection.executeCommand(commandObjects.geopos(key, members));
2084    }
2085    @Override
2086    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2087        final double latitude, final double radius, final GeoUnit unit) {
2088      checkIsInMultiOrPipeline();
2089      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2090    }
2091    @Override
2092    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2093        final double latitude, final double radius, final GeoUnit unit) {
2094      checkIsInMultiOrPipeline();
2095      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2096    }
2097    @Override
2098    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2099        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2100      checkIsInMultiOrPipeline();
2101      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2102    }
2103    @Override
2104    public long georadiusStore(final byte[] key, final double longitude, final double latitude,
2105        final double radius, final GeoUnit unit, final GeoRadiusParam param,
2106        final GeoRadiusStoreParam storeParam) {
2107      checkIsInMultiOrPipeline();
2108      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2112        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2113      checkIsInMultiOrPipeline();
2114      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2115    }
2116    @Override
2117    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2118        final double radius, final GeoUnit unit) {
2119      checkIsInMultiOrPipeline();
2120      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2121    }
2122    @Override
2123    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2124        final double radius, final GeoUnit unit) {
2125      checkIsInMultiOrPipeline();
2126      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2127    }
2128    @Override
2129    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2130        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2131      checkIsInMultiOrPipeline();
2132      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2133    }
2134    @Override
2135    public long georadiusByMemberStore(final byte[] key, final byte[] member, final double radius,
2136        final GeoUnit unit, final GeoRadiusParam param, final GeoRadiusStoreParam storeParam) {
2137      checkIsInMultiOrPipeline();
2138      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2139    }
2140    @Override
2141    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2142      checkIsInMultiOrPipeline();
2143      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
2144    }
2145    @Override
2146    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2147      checkIsInMultiOrPipeline();
2148      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2152      checkIsInMultiOrPipeline();
2153      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2154    }
2155    @Override
2156    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2157      checkIsInMultiOrPipeline();
2158      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2159    }
2160    @Override
2161    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2162      checkIsInMultiOrPipeline();
2163      return connection.executeCommand(commandObjects.geosearch(key, params));
2164    }
2165    @Override
2166    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2167      checkIsInMultiOrPipeline();
2168      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2169    }
2170    @Override
2171    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2172      checkIsInMultiOrPipeline();
2173      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2174    }
2175    @Override
2176    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2177      checkIsInMultiOrPipeline();
2178      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2179    }
2180    @Override
2181    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2182      checkIsInMultiOrPipeline();
2183      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2184    }
2185    @Override
2186    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2187      checkIsInMultiOrPipeline();
2188      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
2189    }
2190    @Override
2191    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2192      checkIsInMultiOrPipeline();
2193      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2194    }
2195    @Override
2196    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2197        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2198      checkIsInMultiOrPipeline();
2199      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2200    }
2201    @Override
2202    public List&lt;Long&gt; bitfield(final byte[] key, final byte[]... arguments) {
2203      checkIsInMultiOrPipeline();
2204      return connection.executeCommand(commandObjects.bitfield(key, arguments));
2205    }
2206    @Override
2207    public List&lt;Long&gt; bitfieldReadonly(byte[] key, final byte[]... arguments) {
2208      checkIsInMultiOrPipeline();
2209      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
2210    }
2211    @Override
2212    public long hstrlen(final byte[] key, final byte[] field) {
2213      checkIsInMultiOrPipeline();
2214      return connection.executeCommand(commandObjects.hstrlen(key, field));
2215    }
2216    @Override
2217    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Entry&lt;byte[], byte[]&gt;... streams) {
2218      checkIsInMultiOrPipeline();
2219      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
2220    }
2221    @Override
2222    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer,
2223        XReadGroupParams xReadGroupParams, Entry&lt;byte[], byte[]&gt;... streams) {
2224      checkIsInMultiOrPipeline();
2225      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2226    }
2227    @Override
2228    public byte[] xadd(final byte[] key, final XAddParams params, final Map&lt;byte[], byte[]&gt; hash) {
2229      checkIsInMultiOrPipeline();
2230      return connection.executeCommand(commandObjects.xadd(key, params, hash));
2231    }
2232    @Override
2233    public long xlen(byte[] key) {
2234      checkIsInMultiOrPipeline();
2235      return connection.executeCommand(commandObjects.xlen(key));
2236    }
2237    @Override
2238    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2239      checkIsInMultiOrPipeline();
2240      return connection.executeCommand(commandObjects.xrange(key, start, end));
2241    }
2242    @Override
2243    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2244      checkIsInMultiOrPipeline();
2245      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
2246    }
2247    @Override
2248    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2249      checkIsInMultiOrPipeline();
2250      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
2251    }
2252    @Override
2253    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2254      checkIsInMultiOrPipeline();
2255      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
2256    }
2257    @Override
2258    public long xack(byte[] key, byte[] group, byte[]... ids) {
2259      checkIsInMultiOrPipeline();
2260      return connection.executeCommand(commandObjects.xack(key, group, ids));
2261    }
2262    @Override
2263    public String xgroupCreate(byte[] key, byte[] consumer, byte[] id, boolean makeStream) {
2264      checkIsInMultiOrPipeline();
2265      return connection.executeCommand(commandObjects.xgroupCreate(key, consumer, id, makeStream));
2266    }
2267    @Override
2268    public String xgroupSetID(byte[] key, byte[] consumer, byte[] id) {
2269      checkIsInMultiOrPipeline();
2270      return connection.executeCommand(commandObjects.xgroupSetID(key, consumer, id));
2271    }
2272    @Override
2273    public long xgroupDestroy(byte[] key, byte[] consumer) {
2274      checkIsInMultiOrPipeline();
2275      return connection.executeCommand(commandObjects.xgroupDestroy(key, consumer));
2276    }
2277    @Override
2278    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2279      checkIsInMultiOrPipeline();
2280      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2281    }
2282    @Override
2283    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2284      checkIsInMultiOrPipeline();
2285      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2286    }
2287    @Override
2288    public long xdel(byte[] key, byte[]... ids) {
2289      checkIsInMultiOrPipeline();
2290      return connection.executeCommand(commandObjects.xdel(key, ids));
2291    }
2292    @Override
2293    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2294      checkIsInMultiOrPipeline();
2295      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2296    }
2297    @Override
2298    public long xtrim(byte[] key, XTrimParams params) {
2299      checkIsInMultiOrPipeline();
2300      return connection.executeCommand(commandObjects.xtrim(key, params));
2301    }
2302    @Override
2303    public Object xpending(final byte[] key, final byte[] groupName) {
2304      checkIsInMultiOrPipeline();
2305      return connection.executeCommand(commandObjects.xpending(key, groupName));
2306    }
2307    @Override
2308    public List&lt;Object&gt; xpending(final byte[] key, final byte[] groupName, final XPendingParams params) {
2309      checkIsInMultiOrPipeline();
2310      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
2311    }
2312    @Override
2313    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2314        XClaimParams params, byte[]... ids) {
2315      checkIsInMultiOrPipeline();
2316      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2317    }
2318    @Override
2319    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2320        XClaimParams params, byte[]... ids) {
2321      checkIsInMultiOrPipeline();
2322      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2323    }
2324    @Override
2325    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName,
2326        long minIdleTime, byte[] start, XAutoClaimParams params) {
2327      checkIsInMultiOrPipeline();
2328      return connection.executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2329    }
2330    @Override
2331    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName,
2332        long minIdleTime, byte[] start, XAutoClaimParams params) {
2333      checkIsInMultiOrPipeline();
2334      return connection.executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2335    }
2336    @Override
2337    public Object xinfoStream(byte[] key) {
2338      checkIsInMultiOrPipeline();
2339      return connection.executeCommand(commandObjects.xinfoStream(key));
2340    }
2341    @Override
2342    public Object xinfoStreamFull(byte[] key) {
2343      checkIsInMultiOrPipeline();
2344      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
2345    }
2346    @Override
2347    public Object xinfoStreamFull(byte[] key, int count) {
2348      checkIsInMultiOrPipeline();
2349      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
2350    }
2351    @Override
2352    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2353      checkIsInMultiOrPipeline();
2354      return connection.executeCommand(commandObjects.xinfoGroups(key));
2355    }
2356    @Override
2357    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2358      checkIsInMultiOrPipeline();
2359      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
2360    }
2361    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
2362      checkIsInMultiOrPipeline();
2363      connection.sendCommand(cmd, args);
2364      return connection.getOne();
2365    }
2366    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
2367      checkIsInMultiOrPipeline();
2368      connection.sendCommand(cmd, args);
2369      connection.setTimeoutInfinite();
2370      try {
2371        return connection.getOne();
2372      } finally {
2373        connection.rollbackTimeout();
2374      }
2375    }
2376    public Object sendCommand(ProtocolCommand cmd) {
2377      return sendCommand(cmd, DUMMY_ARRAY);
2378    }
2379    @Override
2380    public boolean copy(String srcKey, String dstKey, int db, boolean replace) {
2381      checkIsInMultiOrPipeline();
2382      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
2383    }
2384    @Override
2385    public boolean copy(String srcKey, String dstKey, boolean replace) {
2386      checkIsInMultiOrPipeline();
2387      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
2388    }
2389    @Override
2390    public String ping(final String message) {
2391      checkIsInMultiOrPipeline();
2392      connection.sendCommand(Command.PING, message);
2393      return connection.getBulkReply();
2394    }
2395    @Override
2396    public String set(final String key, final String value) {
2397      checkIsInMultiOrPipeline();
2398      return connection.executeCommand(commandObjects.set(key, value));
2399    }
2400    @Override
2401    public String set(final String key, final String value, final SetParams params) {
2402      checkIsInMultiOrPipeline();
2403      return connection.executeCommand(commandObjects.set(key, value, params));
2404    }
2405    @Override
2406    public String get(final String key) {
2407      checkIsInMultiOrPipeline();
2408      return connection.executeCommand(commandObjects.get(key));
2409    }
2410    @Override
2411    public String setGet(final String key, final String value) {
2412      checkIsInMultiOrPipeline();
2413      return connection.executeCommand(commandObjects.setGet(key, value));
2414    }
2415    @Override
2416    public String setGet(final String key, final String value, final SetParams params) {
2417      checkIsInMultiOrPipeline();
2418      return connection.executeCommand(commandObjects.setGet(key, value, params));
2419    }
2420    @Override
2421    public String getDel(final String key) {
2422      checkIsInMultiOrPipeline();
2423      return connection.executeCommand(commandObjects.getDel(key));
2424    }
2425    @Override
2426    public String getEx(String key, GetExParams params) {
2427      checkIsInMultiOrPipeline();
2428      return connection.executeCommand(commandObjects.getEx(key, params));
2429    }
2430    @Override
2431    public long exists(final String... keys) {
2432      checkIsInMultiOrPipeline();
2433      return connection.executeCommand(commandObjects.exists(keys));
2434    }
2435    @Override
2436    public boolean exists(final String key) {
2437      checkIsInMultiOrPipeline();
2438      return connection.executeCommand(commandObjects.exists(key));
2439    }
2440    @Override
2441    public long del(final String... keys) {
2442      checkIsInMultiOrPipeline();
2443      return connection.executeCommand(commandObjects.del(keys));
2444    }
2445    @Override
2446    public long del(final String key) {
2447      checkIsInMultiOrPipeline();
2448      return connection.executeCommand(commandObjects.del(key));
2449    }
2450    @Override
2451    public long unlink(final String... keys) {
2452      checkIsInMultiOrPipeline();
2453      return connection.executeCommand(commandObjects.unlink(keys));
2454    }
2455    @Override
2456    public long unlink(final String key) {
2457      checkIsInMultiOrPipeline();
2458      return connection.executeCommand(commandObjects.unlink(key));
2459    }
2460    @Override
2461    public String type(final String key) {
2462      checkIsInMultiOrPipeline();
2463      return connection.executeCommand(commandObjects.type(key));
2464    }
2465    @Override
2466    public Set&lt;String&gt; keys(final String pattern) {
2467      checkIsInMultiOrPipeline();
2468      return connection.executeCommand(commandObjects.keys(pattern));
2469    }
2470    @Override
2471    public String randomKey() {
2472      checkIsInMultiOrPipeline();
2473      return connection.executeCommand(commandObjects.randomKey());
2474    }
2475    @Override
2476    public String rename(final String oldkey, final String newkey) {
2477      checkIsInMultiOrPipeline();
2478      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
2479    }
2480    @Override
2481    public long renamenx(final String oldkey, final String newkey) {
2482      checkIsInMultiOrPipeline();
2483      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
2484    }
2485    @Override
2486    public long expire(final String key, final long seconds) {
2487      checkIsInMultiOrPipeline();
2488      return connection.executeCommand(commandObjects.expire(key, seconds));
2489    }
2490    @Override
2491    public long expire(final String key, final long seconds, final ExpiryOption expiryOption) {
2492      checkIsInMultiOrPipeline();
2493      return connection.executeCommand(commandObjects.expire(key, seconds, expiryOption));
2494    }
2495    @Override
2496    public long pexpire(final String key, final long milliseconds) {
2497      checkIsInMultiOrPipeline();
2498      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
2499    }
2500    @Override
2501    public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {
2502      checkIsInMultiOrPipeline();
2503      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
2504    }
2505    @Override
2506    public long expireTime(final String key) {
2507      checkIsInMultiOrPipeline();
2508      return connection.executeCommand(commandObjects.expireTime(key));
2509    }
2510    @Override
2511    public long pexpireTime(final String key) {
2512      checkIsInMultiOrPipeline();
2513      return connection.executeCommand(commandObjects.pexpireTime(key));
2514    }
2515    @Override
2516    public long expireAt(final String key, final long unixTime) {
2517      checkIsInMultiOrPipeline();
2518      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
2519    }
2520    @Override
2521    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
2522      checkIsInMultiOrPipeline();
2523      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
2524    }
2525    @Override
2526    public long pexpireAt(final String key, final long millisecondsTimestamp) {
2527      checkIsInMultiOrPipeline();
2528      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
2529    }
2530    @Override
2531    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
2532      checkIsInMultiOrPipeline();
2533      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
2534    }
2535    @Override
2536    public long ttl(final String key) {
2537      checkIsInMultiOrPipeline();
2538      return connection.executeCommand(commandObjects.ttl(key));
2539    }
2540    @Override
2541    public long touch(final String... keys) {
2542      checkIsInMultiOrPipeline();
2543      return connection.executeCommand(commandObjects.touch(keys));
2544    }
2545    @Override
2546    public long touch(final String key) {
2547      checkIsInMultiOrPipeline();
2548      return connection.executeCommand(commandObjects.touch(key));
2549    }
2550    @Override
2551    public long move(final String key, final int dbIndex) {
2552      checkIsInMultiOrPipeline();
2553      connection.sendCommand(MOVE, encode(key), toByteArray(dbIndex));
2554      return connection.getIntegerReply();
2555    }
2556    @Override
2557    public String getSet(final String key, final String value) {
2558      checkIsInMultiOrPipeline();
2559      return connection.executeCommand(commandObjects.getSet(key, value));
2560    }
2561    @Override
2562    public List&lt;String&gt; mget(final String... keys) {
2563      checkIsInMultiOrPipeline();
2564      return connection.executeCommand(commandObjects.mget(keys));
2565    }
2566    @Override
2567    public long setnx(final String key, final String value) {
2568      checkIsInMultiOrPipeline();
2569      return connection.executeCommand(commandObjects.setnx(key, value));
2570    }
2571    @Override
2572    public String setex(final String key, final long seconds, final String value) {
2573      checkIsInMultiOrPipeline();
2574      return connection.executeCommand(commandObjects.setex(key, seconds, value));
2575    }
2576    @Override
2577    public String mset(final String... keysvalues) {
2578      checkIsInMultiOrPipeline();
2579      return connection.executeCommand(commandObjects.mset(keysvalues));
2580    }
2581    @Override
2582    public long msetnx(final String... keysvalues) {
2583      checkIsInMultiOrPipeline();
2584      return connection.executeCommand(commandObjects.msetnx(keysvalues));
2585    }
2586    @Override
2587    public long decrBy(final String key, final long decrement) {
2588      checkIsInMultiOrPipeline();
2589      return connection.executeCommand(commandObjects.decrBy(key, decrement));
2590    }
2591    @Override
2592    public long decr(final String key) {
2593      checkIsInMultiOrPipeline();
2594      return connection.executeCommand(commandObjects.decr(key));
2595    }
2596    @Override
2597    public long incrBy(final String key, final long increment) {
2598      checkIsInMultiOrPipeline();
2599      return connection.executeCommand(commandObjects.incrBy(key, increment));
2600    }
2601    @Override
2602    public double incrByFloat(final String key, final double increment) {
2603      checkIsInMultiOrPipeline();
2604      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
2605    }
2606    @Override
2607    public long incr(final String key) {
2608      checkIsInMultiOrPipeline();
2609      return connection.executeCommand(commandObjects.incr(key));
2610    }
2611    @Override
2612    public long append(final String key, final String value) {
2613      checkIsInMultiOrPipeline();
2614      return connection.executeCommand(commandObjects.append(key, value));
2615    }
2616    @Override
2617    public String substr(final String key, final int start, final int end) {
2618      checkIsInMultiOrPipeline();
2619      return connection.executeCommand(commandObjects.substr(key, start, end));
2620    }
2621    @Override
2622    public long hset(final String key, final String field, final String value) {
2623      checkIsInMultiOrPipeline();
2624      return connection.executeCommand(commandObjects.hset(key, field, value));
2625    }
2626    @Override
2627    public long hset(final String key, final Map&lt;String, String&gt; hash) {
2628      checkIsInMultiOrPipeline();
2629      return connection.executeCommand(commandObjects.hset(key, hash));
2630    }
2631    @Override
2632    public String hget(final String key, final String field) {
2633      checkIsInMultiOrPipeline();
2634      return connection.executeCommand(commandObjects.hget(key, field));
2635    }
2636    @Override
2637    public long hsetnx(final String key, final String field, final String value) {
2638      checkIsInMultiOrPipeline();
2639      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
2640    }
2641    @Override
2642    public String hmset(final String key, final Map&lt;String, String&gt; hash) {
2643      checkIsInMultiOrPipeline();
2644      return connection.executeCommand(commandObjects.hmset(key, hash));
2645    }
2646    @Override
2647    public List&lt;String&gt; hmget(final String key, final String... fields) {
2648      checkIsInMultiOrPipeline();
2649      return connection.executeCommand(commandObjects.hmget(key, fields));
2650    }
2651    @Override
2652    public long hincrBy(final String key, final String field, final long value) {
2653      checkIsInMultiOrPipeline();
2654      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
2655    }
2656    @Override
2657    public double hincrByFloat(final String key, final String field, final double value) {
2658      checkIsInMultiOrPipeline();
2659      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
2660    }
2661    @Override
2662    public boolean hexists(final String key, final String field) {
2663      checkIsInMultiOrPipeline();
2664      return connection.executeCommand(commandObjects.hexists(key, field));
2665    }
2666    @Override
2667    public long hdel(final String key, final String... fields) {
2668      checkIsInMultiOrPipeline();
2669      return connection.executeCommand(commandObjects.hdel(key, fields));
2670    }
2671    @Override
2672    public long hlen(final String key) {
2673      checkIsInMultiOrPipeline();
2674      return connection.executeCommand(commandObjects.hlen(key));
2675    }
2676    @Override
2677    public Set&lt;String&gt; hkeys(final String key) {
2678      checkIsInMultiOrPipeline();
2679      return connection.executeCommand(commandObjects.hkeys(key));
2680    }
2681    @Override
2682    public List&lt;String&gt; hvals(final String key) {
2683      checkIsInMultiOrPipeline();
2684      return connection.executeCommand(commandObjects.hvals(key));
2685    }
2686    @Override
2687    public Map&lt;String, String&gt; hgetAll(final String key) {
2688      checkIsInMultiOrPipeline();
2689      return connection.executeCommand(commandObjects.hgetAll(key));
2690    }
2691    @Override
2692    public String hrandfield(final String key) {
2693      checkIsInMultiOrPipeline();
2694      return connection.executeCommand(commandObjects.hrandfield(key));
2695    }
2696    @Override
2697    public List&lt;String&gt; hrandfield(final String key, final long count) {
2698      checkIsInMultiOrPipeline();
2699      return connection.executeCommand(commandObjects.hrandfield(key, count));
2700    }
2701    @Override
2702    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(final String key, final long count) {
2703      checkIsInMultiOrPipeline();
2704      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
2705    }
2706    @Override
2707    public long rpush(final String key, final String... strings) {
2708      checkIsInMultiOrPipeline();
2709      return connection.executeCommand(commandObjects.rpush(key, strings));
2710    }
2711    @Override
2712    public long lpush(final String key, final String... strings) {
2713      checkIsInMultiOrPipeline();
2714      return connection.executeCommand(commandObjects.lpush(key, strings));
2715    }
2716    @Override
2717    public long llen(final String key) {
2718      checkIsInMultiOrPipeline();
2719      return connection.executeCommand(commandObjects.llen(key));
2720    }
2721    @Override
2722    public List&lt;String&gt; lrange(final String key, final long start, final long stop) {
2723      checkIsInMultiOrPipeline();
2724      return connection.executeCommand(commandObjects.lrange(key, start, stop));
2725    }
2726    @Override
2727    public String ltrim(final String key, final long start, final long stop) {
2728      checkIsInMultiOrPipeline();
2729      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
2730    }
2731    @Override
2732    public String lindex(final String key, final long index) {
2733      checkIsInMultiOrPipeline();
2734      return connection.executeCommand(commandObjects.lindex(key, index));
2735    }
2736    @Override
2737    public String lset(final String key, final long index, final String value) {
2738      checkIsInMultiOrPipeline();
2739      return connection.executeCommand(commandObjects.lset(key, index, value));
2740    }
2741    @Override
2742    public long lrem(final String key, final long count, final String value) {
2743      checkIsInMultiOrPipeline();
2744      return connection.executeCommand(commandObjects.lrem(key, count, value));
2745    }
2746    @Override
2747    public String lpop(final String key) {
2748      checkIsInMultiOrPipeline();
2749      return connection.executeCommand(commandObjects.lpop(key));
2750    }
2751    @Override
2752    public List&lt;String&gt; lpop(final String key, final int count) {
2753      checkIsInMultiOrPipeline();
2754      return connection.executeCommand(commandObjects.lpop(key, count));
2755    }
2756    @Override
2757    public Long lpos(final String key, final String element) {
2758      checkIsInMultiOrPipeline();
2759      return connection.executeCommand(commandObjects.lpos(key, element));
2760    }
2761    @Override
2762    public Long lpos(final String key, final String element, final LPosParams params) {
2763      checkIsInMultiOrPipeline();
2764      return connection.executeCommand(commandObjects.lpos(key, element, params));
2765    }
2766    @Override
2767    public List&lt;Long&gt; lpos(final String key, final String element, final LPosParams params,
2768        final long count) {
2769      checkIsInMultiOrPipeline();
2770      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
2771    }
2772    @Override
2773    public String rpop(final String key) {
2774      checkIsInMultiOrPipeline();
2775      return connection.executeCommand(commandObjects.rpop(key));
2776    }
2777    @Override
2778    public List&lt;String&gt; rpop(final String key, final int count) {
2779      checkIsInMultiOrPipeline();
2780      return connection.executeCommand(commandObjects.rpop(key, count));
2781    }
2782    @Override
2783    public String rpoplpush(final String srckey, final String dstkey) {
2784      checkIsInMultiOrPipeline();
2785      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
2786    }
2787    @Override
2788    public long sadd(final String key, final String... members) {
2789      checkIsInMultiOrPipeline();
2790      return connection.executeCommand(commandObjects.sadd(key, members));
2791    }
2792    @Override
2793    public Set&lt;String&gt; smembers(final String key) {
2794      checkIsInMultiOrPipeline();
2795      return connection.executeCommand(commandObjects.smembers(key));
2796    }
2797    @Override
2798    public long srem(final String key, final String... members) {
2799      checkIsInMultiOrPipeline();
2800      return connection.executeCommand(commandObjects.srem(key, members));
2801    }
2802    @Override
2803    public String spop(final String key) {
2804      checkIsInMultiOrPipeline();
2805      return connection.executeCommand(commandObjects.spop(key));
2806    }
2807    @Override
2808    public Set&lt;String&gt; spop(final String key, final long count) {
2809      checkIsInMultiOrPipeline();
2810      return connection.executeCommand(commandObjects.spop(key, count));
2811    }
2812    @Override
2813    public long smove(final String srckey, final String dstkey, final String member) {
2814      checkIsInMultiOrPipeline();
2815      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
2816    }
2817    @Override
2818    public long scard(final String key) {
2819      checkIsInMultiOrPipeline();
2820      return connection.executeCommand(commandObjects.scard(key));
2821    }
2822    @Override
2823    public boolean sismember(final String key, final String member) {
2824      checkIsInMultiOrPipeline();
2825      return connection.executeCommand(commandObjects.sismember(key, member));
2826    }
2827    @Override
2828    public List&lt;Boolean&gt; smismember(final String key, final String... members) {
2829      checkIsInMultiOrPipeline();
2830      return connection.executeCommand(commandObjects.smismember(key, members));
2831    }
2832    @Override
2833    public Set&lt;String&gt; sinter(final String... keys) {
2834      checkIsInMultiOrPipeline();
2835      return connection.executeCommand(commandObjects.sinter(keys));
2836    }
2837    @Override
2838    public long sinterstore(final String dstkey, final String... keys) {
2839      checkIsInMultiOrPipeline();
2840      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
2841    }
2842    @Override
2843    public long sintercard(String... keys) {
2844      checkIsInMultiOrPipeline();
2845      return connection.executeCommand(commandObjects.sintercard(keys));
2846    }
2847    @Override
2848    public long sintercard(int limit, String... keys) {
2849      checkIsInMultiOrPipeline();
2850      return connection.executeCommand(commandObjects.sintercard(limit, keys));
2851    }
2852    @Override
2853    public Set&lt;String&gt; sunion(final String... keys) {
2854      checkIsInMultiOrPipeline();
2855      return connection.executeCommand(commandObjects.sunion(keys));
2856    }
2857    @Override
2858    public long sunionstore(final String dstkey, final String... keys) {
2859      checkIsInMultiOrPipeline();
2860      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
2861    }
2862    @Override
2863    public Set&lt;String&gt; sdiff(final String... keys) {
2864      checkIsInMultiOrPipeline();
2865      return connection.executeCommand(commandObjects.sdiff(keys));
2866    }
2867    @Override
2868    public long sdiffstore(final String dstkey, final String... keys) {
2869      checkIsInMultiOrPipeline();
2870      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
2871    }
2872    @Override
2873    public String srandmember(final String key) {
2874      checkIsInMultiOrPipeline();
2875      return connection.executeCommand(commandObjects.srandmember(key));
2876    }
2877    @Override
2878    public List&lt;String&gt; srandmember(final String key, final int count) {
2879      checkIsInMultiOrPipeline();
2880      return connection.executeCommand(commandObjects.srandmember(key, count));
2881    }
2882    @Override
2883    public long zadd(final String key, final double score, final String member) {
2884      checkIsInMultiOrPipeline();
2885      return connection.executeCommand(commandObjects.zadd(key, score, member));
2886    }
2887    @Override
2888    public long zadd(final String key, final double score, final String member,
2889        final ZAddParams params) {
2890      checkIsInMultiOrPipeline();
2891      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
2892    }
2893    @Override
2894    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers) {
2895      checkIsInMultiOrPipeline();
2896      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
2897    }
2898    @Override
2899    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers, final ZAddParams params) {
2900      checkIsInMultiOrPipeline();
2901      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
2902    }
2903    @Override
2904    public Double zaddIncr(final String key, final double score, final String member, final ZAddParams params) {
2905      checkIsInMultiOrPipeline();
2906      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
2907    }
2908    @Override
2909    public List&lt;String&gt; zdiff(String... keys) {
2910      checkIsInMultiOrPipeline();
2911      return connection.executeCommand(commandObjects.zdiff(keys));
2912    }
2913    @Override
2914    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
2915      checkIsInMultiOrPipeline();
2916      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
2917    }
2918    @Override
2919    @Deprecated
2920    public long zdiffStore(final String dstkey, final String... keys) {
2921      checkIsInMultiOrPipeline();
2922      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
2923    }
2924    @Override
2925    public long zdiffstore(final String dstkey, final String... keys) {
2926      checkIsInMultiOrPipeline();
2927      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
2928    }
2929    @Override
2930    public List&lt;String&gt; zrange(final String key, final long start, final long stop) {
2931      checkIsInMultiOrPipeline();
2932      return connection.executeCommand(commandObjects.zrange(key, start, stop));
2933    }
2934    @Override
2935    public long zrem(final String key, final String... members) {
2936      checkIsInMultiOrPipeline();
2937      return connection.executeCommand(commandObjects.zrem(key, members));
2938    }
2939    @Override
2940    public double zincrby(final String key, final double increment, final String member) {
2941      checkIsInMultiOrPipeline();
2942      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
2943    }
2944    @Override
2945    public Double zincrby(final String key, final double increment, final String member,
2946        final ZIncrByParams params) {
2947      checkIsInMultiOrPipeline();
2948      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
2949    }
2950    @Override
2951    public Long zrank(final String key, final String member) {
2952      checkIsInMultiOrPipeline();
2953      return connection.executeCommand(commandObjects.zrank(key, member));
2954    }
2955    @Override
2956    public Long zrevrank(final String key, final String member) {
2957      checkIsInMultiOrPipeline();
2958      return connection.executeCommand(commandObjects.zrevrank(key, member));
2959    }
2960    @Override
2961    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
2962      checkIsInMultiOrPipeline();
2963      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
2964    }
2965    @Override
2966    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
2967      checkIsInMultiOrPipeline();
2968      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
2969    }
2970    @Override
2971    public List&lt;String&gt; zrevrange(final String key, final long start, final long stop) {
2972      checkIsInMultiOrPipeline();
2973      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
2974    }
2975    @Override
2976    public List&lt;Tuple&gt; zrangeWithScores(final String key, final long start, final long stop) {
2977      checkIsInMultiOrPipeline();
2978      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
2979    }
2980    @Override
2981    public List&lt;Tuple&gt; zrevrangeWithScores(final String key, final long start, final long stop) {
2982      checkIsInMultiOrPipeline();
2983      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
2984    }
2985    @Override
2986    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
2987      checkIsInMultiOrPipeline();
2988      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
2989    }
2990    @Override
2991    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
2992      checkIsInMultiOrPipeline();
2993      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
2994    }
2995    @Override
2996    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
2997      checkIsInMultiOrPipeline();
2998      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
2999    }
3000    @Override
3001    public String zrandmember(final String key) {
3002      checkIsInMultiOrPipeline();
3003      return connection.executeCommand(commandObjects.zrandmember(key));
3004    }
3005    @Override
3006    public List&lt;String&gt; zrandmember(final String key, final long count) {
3007      checkIsInMultiOrPipeline();
3008      return connection.executeCommand(commandObjects.zrandmember(key, count));
3009    }
3010    @Override
3011    public List&lt;Tuple&gt; zrandmemberWithScores(final String key, final long count) {
3012      checkIsInMultiOrPipeline();
3013      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
3014    }
3015    @Override
3016    public long zcard(final String key) {
3017      checkIsInMultiOrPipeline();
3018      return connection.executeCommand(commandObjects.zcard(key));
3019    }
3020    @Override
3021    public Double zscore(final String key, final String member) {
3022      checkIsInMultiOrPipeline();
3023      return connection.executeCommand(commandObjects.zscore(key, member));
3024    }
3025    @Override
3026    public List&lt;Double&gt; zmscore(final String key, final String... members) {
3027      checkIsInMultiOrPipeline();
3028      return connection.executeCommand(commandObjects.zmscore(key, members));
3029    }
3030    @Override
3031    public Tuple zpopmax(final String key) {
3032      checkIsInMultiOrPipeline();
3033      return connection.executeCommand(commandObjects.zpopmax(key));
3034    }
3035    @Override
3036    public List&lt;Tuple&gt; zpopmax(final String key, final int count) {
3037      checkIsInMultiOrPipeline();
3038      return connection.executeCommand(commandObjects.zpopmax(key, count));
3039    }
3040    @Override
3041    public Tuple zpopmin(final String key) {
3042      checkIsInMultiOrPipeline();
3043      return connection.executeCommand(commandObjects.zpopmin(key));
3044    }
3045    @Override
3046    public List&lt;Tuple&gt; zpopmin(final String key, final int count) {
3047      checkIsInMultiOrPipeline();
3048      return connection.executeCommand(commandObjects.zpopmin(key, count));
3049    }
3050    public String watch(final String... keys) {
3051      checkIsInMultiOrPipeline();
3052      connection.sendCommand(WATCH, keys);
3053      String status = connection.getStatusCodeReply();
3054      isInWatch = true;
3055      return status;
3056    }
3057    @Override
3058    public List&lt;String&gt; sort(final String key) {
3059      checkIsInMultiOrPipeline();
3060      return connection.executeCommand(commandObjects.sort(key));
3061    }
3062    @Override
3063    public List&lt;String&gt; sort(final String key, final SortingParams sortingParams) {
3064      checkIsInMultiOrPipeline();
3065      return connection.executeCommand(commandObjects.sort(key, sortingParams));
3066    }
3067    @Override
3068    public long sort(final String key, final SortingParams sortingParams, final String dstkey) {
3069      checkIsInMultiOrPipeline();
3070      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
3071    }
3072    @Override
3073    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
3074      checkIsInMultiOrPipeline();
3075      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
3076    }
3077    @Override
3078    public long sort(final String key, final String dstkey) {
3079      checkIsInMultiOrPipeline();
3080      return connection.executeCommand(commandObjects.sort(key, dstkey));
3081    }
3082    @Override
3083    public String lmove(final String srcKey, final String dstKey, final ListDirection from,
3084        final ListDirection to) {
3085      checkIsInMultiOrPipeline();
3086      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
3087    }
3088    @Override
3089    public String blmove(final String srcKey, final String dstKey, final ListDirection from,
3090        final ListDirection to, final double timeout) {
3091      checkIsInMultiOrPipeline();
3092      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
3093    }
3094    @Override
3095    public List&lt;String&gt; blpop(final int timeout, final String... keys) {
3096      checkIsInMultiOrPipeline();
3097      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3098    }
3099    @Override
3100    public KeyValue&lt;String, String&gt; blpop(final double timeout, final String... keys) {
3101      checkIsInMultiOrPipeline();
3102      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3103    }
3104    @Override
3105    public List&lt;String&gt; brpop(final int timeout, final String... keys) {
3106      checkIsInMultiOrPipeline();
3107      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3108    }
3109    @Override
3110    public KeyValue&lt;String, String&gt; brpop(final double timeout, final String... keys) {
3111      checkIsInMultiOrPipeline();
3112      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3113    }
3114    @Override
3115    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
3116      checkIsInMultiOrPipeline();
3117      return connection.executeCommand(commandObjects.lmpop(direction, keys));
3118    }
3119    @Override
3120    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
3121      checkIsInMultiOrPipeline();
3122      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
3123    }
3124    @Override
3125    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
3126      checkIsInMultiOrPipeline();
3127      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
3128    }
3129    @Override
3130    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
3131      checkIsInMultiOrPipeline();
3132      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
3133    }
3134    @Override
3135    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
3136      checkIsInMultiOrPipeline();
3137      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
3138    }
3139    @Override
3140    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
3141      checkIsInMultiOrPipeline();
3142      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
3143    }
3144    @Override
3145    public List&lt;String&gt; blpop(final int timeout, final String key) {
3146      checkIsInMultiOrPipeline();
3147      return connection.executeCommand(commandObjects.blpop(timeout, key));
3148    }
3149    @Override
3150    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
3151      checkIsInMultiOrPipeline();
3152      return connection.executeCommand(commandObjects.blpop(timeout, key));
3153    }
3154    @Override
3155    public List&lt;String&gt; brpop(final int timeout, final String key) {
3156      checkIsInMultiOrPipeline();
3157      return connection.executeCommand(commandObjects.brpop(timeout, key));
3158    }
3159    @Override
3160    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
3161      checkIsInMultiOrPipeline();
3162      return connection.executeCommand(commandObjects.brpop(timeout, key));
3163    }
3164    @Override
3165    public long zcount(final String key, final double min, final double max) {
3166      checkIsInMultiOrPipeline();
3167      return connection.executeCommand(commandObjects.zcount(key, min, max));
3168    }
3169    @Override
3170    public long zcount(final String key, final String min, final String max) {
3171      checkIsInMultiOrPipeline();
3172      return connection.executeCommand(commandObjects.zcount(key, min, max));
3173    }
3174    @Override
3175    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max) {
3176      checkIsInMultiOrPipeline();
3177      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3178    }
3179    @Override
3180    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max) {
3181      checkIsInMultiOrPipeline();
3182      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3183    }
3184    @Override
3185    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max,
3186        final int offset, final int count) {
3187      checkIsInMultiOrPipeline();
3188      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3189    }
3190    @Override
3191    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max,
3192        final int offset, final int count) {
3193      checkIsInMultiOrPipeline();
3194      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3195    }
3196    @Override
3197    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max) {
3198      checkIsInMultiOrPipeline();
3199      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3200    }
3201    @Override
3202    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max) {
3203      checkIsInMultiOrPipeline();
3204      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3205    }
3206    @Override
3207    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max,
3208        final int offset, final int count) {
3209      checkIsInMultiOrPipeline();
3210      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3211    }
3212    @Override
3213    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max,
3214        final int offset, final int count) {
3215      checkIsInMultiOrPipeline();
3216      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3217    }
3218    @Override
3219    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min) {
3220      checkIsInMultiOrPipeline();
3221      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3222    }
3223    @Override
3224    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min) {
3225      checkIsInMultiOrPipeline();
3226      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3227    }
3228    @Override
3229    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min,
3230        final int offset, final int count) {
3231      checkIsInMultiOrPipeline();
3232      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3233    }
3234    @Override
3235    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max, final double min) {
3236      checkIsInMultiOrPipeline();
3237      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3238    }
3239    @Override
3240    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max,
3241        final double min, final int offset, final int count) {
3242      checkIsInMultiOrPipeline();
3243      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3244    }
3245    @Override
3246    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max,
3247        final String min, final int offset, final int count) {
3248      checkIsInMultiOrPipeline();
3249      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3250    }
3251    @Override
3252    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min,
3253        final int offset, final int count) {
3254      checkIsInMultiOrPipeline();
3255      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3256    }
3257    @Override
3258    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max, final String min) {
3259      checkIsInMultiOrPipeline();
3260      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3261    }
3262    @Override
3263    public long zremrangeByRank(final String key, final long start, final long stop) {
3264      checkIsInMultiOrPipeline();
3265      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
3266    }
3267    @Override
3268    public long zremrangeByScore(final String key, final double min, final double max) {
3269      checkIsInMultiOrPipeline();
3270      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3271    }
3272    @Override
3273    public long zremrangeByScore(final String key, final String min, final String max) {
3274      checkIsInMultiOrPipeline();
3275      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3276    }
3277    @Override
3278    public List&lt;String&gt; zunion(ZParams params, String... keys) {
3279      checkIsInMultiOrPipeline();
3280      return connection.executeCommand(commandObjects.zunion(params, keys));
3281    }
3282    @Override
3283    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
3284      checkIsInMultiOrPipeline();
3285      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
3286    }
3287    @Override
3288    public long zunionstore(final String dstkey, final String... sets) {
3289      checkIsInMultiOrPipeline();
3290      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
3291    }
3292    @Override
3293    public long zunionstore(final String dstkey, final ZParams params, final String... sets) {
3294      checkIsInMultiOrPipeline();
3295      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
3296    }
3297    @Override
3298    public List&lt;String&gt; zinter(final ZParams params, final String... keys) {
3299      checkIsInMultiOrPipeline();
3300      return connection.executeCommand(commandObjects.zinter(params, keys));
3301    }
3302    @Override
3303    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final String... keys) {
3304      checkIsInMultiOrPipeline();
3305      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
3306    }
3307    @Override
3308    public long zintercard(String... keys) {
3309      checkIsInMultiOrPipeline();
3310      return connection.executeCommand(commandObjects.zintercard(keys));
3311    }
3312    @Override
3313    public long zintercard(long limit, String... keys) {
3314      checkIsInMultiOrPipeline();
3315      return connection.executeCommand(commandObjects.zintercard(limit, keys));
3316    }
3317    @Override
3318    public long zinterstore(final String dstkey, final String... sets) {
3319      checkIsInMultiOrPipeline();
3320      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
3321    }
3322    @Override
3323    public long zinterstore(final String dstkey, final ZParams params, final String... sets) {
3324      checkIsInMultiOrPipeline();
3325      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
3326    }
3327    @Override
3328    public long zlexcount(final String key, final String min, final String max) {
3329      checkIsInMultiOrPipeline();
3330      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
3331    }
3332    @Override
3333    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max) {
3334      checkIsInMultiOrPipeline();
3335      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
3336    }
3337    @Override
3338    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max,
3339        final int offset, final int count) {
3340      checkIsInMultiOrPipeline();
3341      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
3342    }
3343    @Override
3344    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min) {
3345      checkIsInMultiOrPipeline();
3346      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
3347    }
3348    @Override
3349    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min,
3350        final int offset, final int count) {
3351      checkIsInMultiOrPipeline();
3352      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
3353    }
3354    @Override
3355    public long zremrangeByLex(final String key, final String min, final String max) {
3356      checkIsInMultiOrPipeline();
3357      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
3358    }
3359    @Override
3360    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
3361      checkIsInMultiOrPipeline();
3362      return connection.executeCommand(commandObjects.zmpop(option, keys));
3363    }
3364    @Override
3365    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
3366      checkIsInMultiOrPipeline();
3367      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
3368    }
3369    @Override
3370    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
3371      checkIsInMultiOrPipeline();
3372      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
3373    }
3374    @Override
3375    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
3376      checkIsInMultiOrPipeline();
3377      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
3378    }
3379    @Override
3380    public long strlen(final String key) {
3381      checkIsInMultiOrPipeline();
3382      return connection.executeCommand(commandObjects.strlen(key));
3383    }
3384    @Override
3385    public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {
3386      checkIsInMultiOrPipeline();
3387      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
3388    }
3389    @Override
3390    public long lpushx(final String key, final String... strings) {
3391      checkIsInMultiOrPipeline();
3392      return connection.executeCommand(commandObjects.lpushx(key, strings));
3393    }
3394    @Override
3395    public long persist(final String key) {
3396      checkIsInMultiOrPipeline();
3397      return connection.executeCommand(commandObjects.persist(key));
3398    }
3399    @Override
3400    public long rpushx(final String key, final String... strings) {
3401      checkIsInMultiOrPipeline();
3402      return connection.executeCommand(commandObjects.rpushx(key, strings));
3403    }
3404    @Override
3405    public String echo(final String string) {
3406      checkIsInMultiOrPipeline();
3407      connection.sendCommand(ECHO, string);
3408      return connection.getBulkReply();
3409    }
3410    @Override
3411    public long linsert(final String key, final ListPosition where, final String pivot,
3412        final String value) {
3413      checkIsInMultiOrPipeline();
3414      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
3415    }
3416    @Override
3417    public String brpoplpush(final String source, final String destination, final int timeout) {
3418      checkIsInMultiOrPipeline();
3419      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
3420    }
3421    @Override
3422    public boolean setbit(final String key, final long offset, final boolean value) {
3423      checkIsInMultiOrPipeline();
3424      return connection.executeCommand(commandObjects.setbit(key, offset, value));
3425    }
3426    @Override
3427    public boolean getbit(final String key, final long offset) {
3428      checkIsInMultiOrPipeline();
3429      return connection.executeCommand(commandObjects.getbit(key, offset));
3430    }
3431    @Override
3432    public long setrange(final String key, final long offset, final String value) {
3433      checkIsInMultiOrPipeline();
3434      return connection.executeCommand(commandObjects.setrange(key, offset, value));
3435    }
3436    @Override
3437    public String getrange(final String key, final long startOffset, final long endOffset) {
3438      checkIsInMultiOrPipeline();
3439      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
3440    }
3441    @Override
3442    public long bitpos(final String key, final boolean value) {
3443      checkIsInMultiOrPipeline();
3444      return connection.executeCommand(commandObjects.bitpos(key, value));
3445    }
3446    @Override
3447    public long bitpos(final String key, final boolean value, final BitPosParams params) {
3448      checkIsInMultiOrPipeline();
3449      return connection.executeCommand(commandObjects.bitpos(key, value, params));
3450    }
3451    @Override
3452    public List&lt;Object&gt; role() {
3453      checkIsInMultiOrPipeline();
3454      connection.sendCommand(ROLE);
3455      return BuilderFactory.ENCODED_OBJECT_LIST.build(connection.getOne());
3456    }
3457    @Override
3458    public Map&lt;String, String&gt; configGet(final String pattern) {
3459      checkIsInMultiOrPipeline();
3460      connection.sendCommand(Command.CONFIG, Keyword.GET.name(), pattern);
3461      return BuilderFactory.STRING_MAP.build(connection.getOne());
3462    }
3463    @Override
3464    public Map&lt;String, String&gt; configGet(String... patterns) {
3465      checkIsInMultiOrPipeline();
3466      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.name(), patterns));
3467      return BuilderFactory.STRING_MAP.build(connection.getOne());
3468    }
3469    @Override
3470    public String configSet(final String parameter, final String value) {
3471      checkIsInMultiOrPipeline();
3472      connection.sendCommand(Command.CONFIG, Keyword.SET.name(), parameter, value);
3473      return connection.getStatusCodeReply();
3474    }
3475    @Override
3476    public String configSet(final String... parameterValues) {
3477      checkIsInMultiOrPipeline();
3478      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.name(), parameterValues));
3479      return connection.getStatusCodeReply();
3480    }
3481    @Override
3482    public String configSet(Map&lt;String, String&gt; parameterValues) {
3483      checkIsInMultiOrPipeline();
3484      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
3485      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
3486      connection.sendCommand(args);
3487      return connection.getStatusCodeReply();
3488    }
3489    public long publish(final String channel, final String message) {
3490      checkIsInMultiOrPipeline();
3491      connection.sendCommand(PUBLISH, channel, message);
3492      return connection.getIntegerReply();
3493    }
3494    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
3495      jedisPubSub.proceed(connection, channels);
3496    }
3497    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
3498      jedisPubSub.proceedWithPatterns(connection, patterns);
3499    }
3500    public List&lt;String&gt; pubsubChannels() {
3501      checkIsInMultiOrPipeline();
3502      connection.sendCommand(PUBSUB, CHANNELS);
3503      return connection.getMultiBulkReply();
3504    }
3505    public List&lt;String&gt; pubsubChannels(final String pattern) {
3506      checkIsInMultiOrPipeline();
3507      connection.sendCommand(PUBSUB, CHANNELS.name(), pattern);
3508      return connection.getMultiBulkReply();
3509    }
3510    public Long pubsubNumPat() {
3511      checkIsInMultiOrPipeline();
3512      connection.sendCommand(PUBSUB, NUMPAT);
3513      return connection.getIntegerReply();
3514    }
3515    public Map&lt;String, Long&gt; pubsubNumSub(String... channels) {
3516      checkIsInMultiOrPipeline();
3517      connection.sendCommand(PUBSUB, joinParameters(NUMSUB.name(), channels));
3518      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3519    }
3520    public List&lt;String&gt; pubsubShardChannels() {
3521      checkIsInMultiOrPipeline();
3522      connection.sendCommand(PUBSUB, SHARDCHANNELS);
3523      return connection.getMultiBulkReply();
3524    }
3525    public List&lt;String&gt; pubsubShardChannels(final String pattern) {
3526      checkIsInMultiOrPipeline();
3527      connection.sendCommand(PUBSUB, SHARDCHANNELS.name(), pattern);
3528      return connection.getMultiBulkReply();
3529    }
3530    public Map&lt;String, Long&gt; pubsubShardNumSub(String... channels) {
3531      checkIsInMultiOrPipeline();
3532      connection.sendCommand(PUBSUB, joinParameters(SHARDNUMSUB.name(), channels));
3533      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3534    }
3535    @Override
3536    public Object eval(final String script, final int keyCount, final String... params) {
3537      checkIsInMultiOrPipeline();
3538      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
3539    }
3540    @Override
3541    public Object eval(final String script, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3542      checkIsInMultiOrPipeline();
3543      return connection.executeCommand(commandObjects.eval(script, keys, args));
3544    }
3545    @Override
3546    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
3547      checkIsInMultiOrPipeline();
3548      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
3549    }
3550    @Override
3551    public Object eval(final String script) {
3552      checkIsInMultiOrPipeline();
3553      return connection.executeCommand(commandObjects.eval(script));
3554    }
3555    @Override
3556    public Object evalsha(final String sha1) {
3557      checkIsInMultiOrPipeline();
3558      return connection.executeCommand(commandObjects.evalsha(sha1));
3559    }
3560    @Override
3561    public Object evalsha(final String sha1, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3562      checkIsInMultiOrPipeline();
3563      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
3564    }
3565    @Override
3566    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
3567      checkIsInMultiOrPipeline();
3568      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
3569    }
3570    @Override
3571    public Object evalsha(final String sha1, final int keyCount, final String... params) {
3572      checkIsInMultiOrPipeline();
3573      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
3574    }
3575    @Override
3576    public Boolean scriptExists(final String sha1) {
3577      String[] a = new String[1];
3578      a[0] = sha1;
3579      return scriptExists(a).get(0);
3580    }
3581    @Override
3582    public List&lt;Boolean&gt; scriptExists(final String... sha1) {
3583      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.name(), sha1));
3584      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
3585    }
3586    @Override
3587    public String scriptLoad(final String script) {
3588      connection.sendCommand(SCRIPT, LOAD.name(), script);
3589      return connection.getBulkReply();
3590    }
3591    @Override
3592    public List&lt;Slowlog&gt; slowlogGet() {
3593      connection.sendCommand(SLOWLOG, Keyword.GET);
3594      return Slowlog.from(connection.getObjectMultiBulkReply());
3595    }
3596    @Override
3597    public List&lt;Slowlog&gt; slowlogGet(final long entries) {
3598      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
3599      return Slowlog.from(connection.getObjectMultiBulkReply());
3600    }
3601    @Override
3602    public Long objectRefcount(final String key) {
3603      connection.sendCommand(OBJECT, REFCOUNT.name(), key);
3604      return connection.getIntegerReply();
3605    }
3606    @Override
3607    public String objectEncoding(final String key) {
3608      connection.sendCommand(OBJECT, ENCODING.name(), key);
3609      return connection.getBulkReply();
3610    }
3611    @Override
3612    public Long objectIdletime(final String key) {
3613      connection.sendCommand(OBJECT, IDLETIME.name(), key);
3614      return connection.getIntegerReply();
3615    }
3616    @Override
3617    public List&lt;String&gt; objectHelp() {
3618      connection.sendCommand(OBJECT, HELP);
3619      return connection.getMultiBulkReply();
3620    }
3621    @Override
3622    public Long objectFreq(final String key) {
3623      connection.sendCommand(OBJECT, FREQ.name(), key);
3624      return connection.getIntegerReply();
3625    }
3626    @Override
3627    public long bitcount(final String key) {
3628      checkIsInMultiOrPipeline();
3629      return connection.executeCommand(commandObjects.bitcount(key));
3630    }
3631    @Override
3632    public long bitcount(final String key, final long start, final long end) {
3633      checkIsInMultiOrPipeline();
3634      return connection.executeCommand(commandObjects.bitcount(key, start, end));
3635    }
3636    @Override
3637    public long bitcount(final String key, final long start, final long end, final BitCountOption option) {
3638      checkIsInMultiOrPipeline();
3639      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
3640    }
3641    @Override
3642    public long bitop(final BitOP op, final String destKey, final String... srcKeys) {
3643      checkIsInMultiOrPipeline();
3644      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
3645    }
3646    public long commandCount() {
3647      checkIsInMultiOrPipeline();
3648      connection.sendCommand(COMMAND, COUNT);
3649      return connection.getIntegerReply();
3650    }
3651    public Map&lt;String, CommandDocument&gt; commandDocs(String... commands) {
3652      checkIsInMultiOrPipeline();
3653      connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));
3654      return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());
3655    }
3656    public List&lt;String&gt; commandGetKeys(String... command) {
3657      checkIsInMultiOrPipeline();
3658      connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));
3659      return BuilderFactory.STRING_LIST.build(connection.getOne());
3660    }
3661    public List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; commandGetKeysAndFlags(String... command) {
3662      checkIsInMultiOrPipeline();
3663      connection.sendCommand(COMMAND, joinParameters(GETKEYSANDFLAGS.name(), command));
3664      return BuilderFactory.KEYED_STRING_LIST_LIST.build(connection.getOne());
3665    }
3666    public Map&lt;String, CommandInfo&gt; commandInfo(String... commands) {
3667      checkIsInMultiOrPipeline();
3668      connection.sendCommand(COMMAND, joinParameters(Keyword.INFO.name(), commands));
3669      return BuilderFactory.COMMAND_INFO_RESPONSE.build(connection.getOne());
3670    }
3671    public List&lt;String&gt; commandList() {
3672      checkIsInMultiOrPipeline();
3673      connection.sendCommand(COMMAND, LIST);
3674      return BuilderFactory.STRING_LIST.build(connection.getOne());
3675    }
3676    public List&lt;String&gt; commandListFilterBy(CommandListFilterByParams filterByParams) {
3677      checkIsInMultiOrPipeline();
3678      CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);
3679      connection.sendCommand(args);
3680      return BuilderFactory.STRING_LIST.build(connection.getOne());
3681    }
3682    @Override
3683    public String sentinelMyId() {
3684      connection.sendCommand(SENTINEL, MYID);
3685      return connection.getBulkReply();
3686    }
3687    @Override
3688    public List&lt;Map&lt;String, String&gt;&gt; sentinelMasters() {
3689      connection.sendCommand(SENTINEL, MASTERS);
3690      return connection.getObjectMultiBulkReply().stream()
3691          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3692    }
3693    @Override
3694    public Map&lt;String, String&gt; sentinelMaster(String masterName) {
3695      connection.sendCommand(SENTINEL, MASTER.name(), masterName);
3696      return BuilderFactory.STRING_MAP.build(connection.getOne());
3697    }
3698    @Override
3699    public List&lt;Map&lt;String, String&gt;&gt; sentinelSentinels(String masterName) {
3700      connection.sendCommand(SENTINEL, SENTINELS.name(), masterName);
3701      return connection.getObjectMultiBulkReply().stream()
3702          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3703    }
3704    @Override
3705    public List&lt;String&gt; sentinelGetMasterAddrByName(String masterName) {
3706      connection.sendCommand(SENTINEL, GET_MASTER_ADDR_BY_NAME.getRaw(), encode(masterName));
3707      return connection.getMultiBulkReply();
3708    }
3709    @Override
3710    public Long sentinelReset(String pattern) {
3711      connection.sendCommand(SENTINEL, SentinelKeyword.RESET.name(), pattern);
3712      return connection.getIntegerReply();
3713    }
3714    @Override
3715    @Deprecated
3716    public List&lt;Map&lt;String, String&gt;&gt; sentinelSlaves(String masterName) {
3717      connection.sendCommand(SENTINEL, SLAVES.name(), masterName);
3718      return connection.getObjectMultiBulkReply().stream()
3719          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3720    }
3721    @Override
3722    public List&lt;Map&lt;String, String&gt;&gt; sentinelReplicas(String masterName) {
3723      connection.sendCommand(SENTINEL, REPLICAS.name(), masterName);
3724      return connection.getObjectMultiBulkReply().stream()
3725          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3726    }
3727    @Override
3728    public String sentinelFailover(String masterName) {
3729      connection.sendCommand(SENTINEL, SentinelKeyword.FAILOVER.name(), masterName);
3730      return connection.getStatusCodeReply();
3731    }
3732    @Override
3733    public String sentinelMonitor(String masterName, String ip, int port, int quorum) {
3734      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.MONITOR)
3735          .add(masterName).add(ip).add(port).add(quorum);
3736      connection.sendCommand(args);
3737      return connection.getStatusCodeReply();
3738    }
3739    @Override
3740    public String sentinelRemove(String masterName) {
3741      connection.sendCommand(SENTINEL, REMOVE.name(), masterName);
3742      return connection.getStatusCodeReply();
3743    }
3744    @Override
3745    public String sentinelSet(String masterName, Map&lt;String, String&gt; parameterMap) {
3746      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.SET).add(masterName);
3747      parameterMap.entrySet().forEach(entry -&gt; args.add(entry.getKey()).add(entry.getValue()));
3748      connection.sendCommand(args);
3749      return connection.getStatusCodeReply();
3750    }
3751    @Override
3752    public byte[] dump(final String key) {
3753      checkIsInMultiOrPipeline();
3754      return connection.executeCommand(commandObjects.dump(key));
3755    }
3756    @Override
3757    public String restore(final String key, final long ttl, final byte[] serializedValue) {
3758      checkIsInMultiOrPipeline();
3759      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
3760    }
3761    @Override
3762    public String restore(final String key, final long ttl, final byte[] serializedValue,
3763        final RestoreParams params) {
3764      checkIsInMultiOrPipeline();
3765      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
3766    }
3767    @Override
3768    public long pttl(final String key) {
3769      checkIsInMultiOrPipeline();
3770      return connection.executeCommand(commandObjects.pttl(key));
3771    }
3772    @Override
3773    public String psetex(final String key, final long milliseconds, final String value) {
3774      checkIsInMultiOrPipeline();
3775      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
3776    }
3777    @Override
3778    public String aclSetUser(final String name) {
3779      checkIsInMultiOrPipeline();
3780      connection.sendCommand(ACL, SETUSER.name(), name);
3781      return connection.getStatusCodeReply();
3782    }
3783    @Override
3784    public String aclSetUser(String name, String... rules) {
3785      checkIsInMultiOrPipeline();
3786      connection.sendCommand(ACL, joinParameters(SETUSER.name(), name, rules));
3787      return connection.getStatusCodeReply();
3788    }
3789    @Override
3790    public long aclDelUser(final String... names) {
3791      checkIsInMultiOrPipeline();
3792      connection.sendCommand(ACL, joinParameters(DELUSER.name(), names));
3793      return connection.getIntegerReply();
3794    }
3795    @Override
3796    public AccessControlUser aclGetUser(final String name) {
3797      checkIsInMultiOrPipeline();
3798      connection.sendCommand(ACL, GETUSER.name(), name);
3799      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getOne());
3800    }
3801    @Override
3802    public List&lt;String&gt; aclUsers() {
3803      checkIsInMultiOrPipeline();
3804      connection.sendCommand(ACL, USERS);
3805      return BuilderFactory.STRING_LIST.build(connection.getObjectMultiBulkReply());
3806    }
3807    @Override
3808    public List&lt;String&gt; aclList() {
3809      checkIsInMultiOrPipeline();
3810      connection.sendCommand(ACL, LIST);
3811      return connection.getMultiBulkReply();
3812    }
3813    @Override
3814    public String aclWhoAmI() {
3815      checkIsInMultiOrPipeline();
3816      connection.sendCommand(ACL, WHOAMI);
3817      return connection.getStatusCodeReply();
3818    }
3819    @Override
3820    public List&lt;String&gt; aclCat() {
3821      checkIsInMultiOrPipeline();
3822      connection.sendCommand(ACL, CAT);
3823      return BuilderFactory.STRING_LIST.build(connection.getOne());
3824    }
3825    @Override
3826    public List&lt;String&gt; aclCat(String category) {
3827      checkIsInMultiOrPipeline();
3828      connection.sendCommand(ACL, CAT.name(), category);
3829      return BuilderFactory.STRING_LIST.build(connection.getOne());
3830    }
3831    @Override
3832    public List&lt;AccessControlLogEntry&gt; aclLog() {
3833      checkIsInMultiOrPipeline();
3834      connection.sendCommand(ACL, LOG);
3835      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3836    }
3837    @Override
3838    public List&lt;AccessControlLogEntry&gt; aclLog(int limit) {
3839      checkIsInMultiOrPipeline();
3840      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
3841      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3842    }
3843    @Override
3844    public String aclLoad() {
3845      checkIsInMultiOrPipeline();
3846      connection.sendCommand(ACL, LOAD);
3847      return connection.getStatusCodeReply();
3848    }
3849    @Override
3850    public String aclSave() {
3851      checkIsInMultiOrPipeline();
3852      connection.sendCommand(ACL, Keyword.SAVE);
3853      return connection.getStatusCodeReply();
3854    }
3855    @Override
3856    public String aclGenPass() {
3857      connection.sendCommand(ACL, GENPASS);
3858      return connection.getBulkReply();
3859    }
3860    @Override
3861    public String aclGenPass(int bits) {
3862      checkIsInMultiOrPipeline();
3863      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
3864      return connection.getBulkReply();
3865    }
3866    @Override
3867    public String aclDryRun(String username, String command, String... args) {
3868      checkIsInMultiOrPipeline();
3869      String[] allArgs = new String[3 + args.length];
3870      allArgs[0] = DRYRUN.name();
3871      allArgs[1] = username;
3872      allArgs[2] = command;
3873      System.arraycopy(args, 0, allArgs, 3, args.length);
3874      connection.sendCommand(ACL, allArgs);
3875      return connection.getBulkReply();
3876    }
3877    @Override
3878    public String aclDryRun(String username, CommandArguments commandArgs) {
3879      checkIsInMultiOrPipeline();
3880      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3881      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3882      while (it.hasNext()) allArgs.add(it.next());
3883      connection.sendCommand(allArgs);
3884      return connection.getBulkReply();
3885    }
3886    @Override
3887    public byte[] aclDryRunBinary(byte[] username, byte[] command, byte[]... args) {
3888      checkIsInMultiOrPipeline();
3889      byte[][] allArgs = new byte[3 + args.length][];
3890      allArgs[0] = DRYRUN.getRaw();
3891      allArgs[1] = username;
3892      allArgs[2] = command;
3893      System.arraycopy(args, 0, allArgs, 3, args.length);
3894      connection.sendCommand(ACL, allArgs);
3895      return connection.getBinaryBulkReply();
3896    }
3897    @Override
3898    public byte[] aclDryRunBinary(byte[] username, CommandArguments commandArgs) {
3899      checkIsInMultiOrPipeline();
3900      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3901      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3902      while (it.hasNext()) allArgs.add(it.next());
3903      connection.sendCommand(allArgs);
3904      return connection.getBinaryBulkReply();
3905    }
3906    @Override
3907    public String clientKill(final String ipPort) {
3908      checkIsInMultiOrPipeline();
3909      connection.sendCommand(CLIENT, KILL.name(), ipPort);
3910      return connection.getStatusCodeReply();
3911    }
3912    @Override
3913    public String clientGetname() {
3914      checkIsInMultiOrPipeline();
3915      connection.sendCommand(CLIENT, GETNAME);
3916      return connection.getBulkReply();
3917    }
3918    @Override
3919    public String clientList() {
3920      checkIsInMultiOrPipeline();
3921      connection.sendCommand(CLIENT, LIST);
3922      return connection.getBulkReply();
3923    }
3924    @Override
3925    public String clientList(ClientType type) {
3926      checkIsInMultiOrPipeline();
3927      connection.sendCommand(CLIENT, LIST.getRaw(), Keyword.TYPE.getRaw(), type.getRaw());
3928      return connection.getBulkReply();
3929    }
3930    @Override
3931    public String clientList(final long... clientIds) {
3932      checkIsInMultiOrPipeline();
3933      connection.sendCommand(CLIENT, clientListParams(clientIds));
3934      return connection.getBulkReply();
3935    }
3936    @Override
3937    public String clientInfo() {
3938      checkIsInMultiOrPipeline();
3939      connection.sendCommand(CLIENT, Keyword.INFO);
3940      return connection.getBulkReply();
3941    }
3942    @Override
3943    public String clientSetInfo(ClientAttributeOption attr, String value) {
3944      checkIsInMultiOrPipeline();
3945      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), encode(value));
3946      return connection.getStatusCodeReply();
3947    }
3948    @Override
3949    public String clientSetname(final String name) {
3950      checkIsInMultiOrPipeline();
3951      connection.sendCommand(CLIENT, SETNAME.name(), name);
3952      return connection.getStatusCodeReply();
3953    }
3954    @Override
3955    public String migrate(final String host, final int port, final String key,
3956        final int destinationDb, final int timeout) {
3957      checkIsInMultiOrPipeline();
3958      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
3959    }
3960    @Override
3961    public String migrate(final String host, final int port, final int destinationDB,
3962        final int timeout, final MigrateParams params, final String... keys) {
3963      checkIsInMultiOrPipeline();
3964      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
3965    }
3966    @Override
3967    public String migrate(String host, int port, String key, int timeout) {
3968      checkIsInMultiOrPipeline();
3969      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
3970    }
3971    @Override
3972    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
3973      checkIsInMultiOrPipeline();
3974      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
3975    }
3976    @Override
3977    public ScanResult&lt;String&gt; scan(final String cursor) {
3978      return connection.executeCommand(commandObjects.scan(cursor));
3979    }
3980    @Override
3981    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params) {
3982      return connection.executeCommand(commandObjects.scan(cursor, params));
3983    }
3984    @Override
3985    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params, final String type) {
3986      checkIsInMultiOrPipeline();
3987      return connection.executeCommand(commandObjects.scan(cursor, params, type));
3988    }
3989    @Override
3990    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(final String key, final String cursor,
3991        final ScanParams params) {
3992      checkIsInMultiOrPipeline();
3993      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
3994    }
3995    @Override
3996    public ScanResult&lt;String&gt; sscan(final String key, final String cursor, final ScanParams params) {
3997      checkIsInMultiOrPipeline();
3998      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
3999    }
4000    @Override
4001    public ScanResult&lt;Tuple&gt; zscan(final String key, final String cursor, final ScanParams params) {
4002      checkIsInMultiOrPipeline();
4003      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
4004    }
4005    @Override
4006    public String readonly() {
4007      checkIsInMultiOrPipeline();
4008      connection.sendCommand(READONLY);
4009      return connection.getStatusCodeReply();
4010    }
4011    @Override
4012    public String readwrite() {
4013      checkIsInMultiOrPipeline();
4014      connection.sendCommand(READWRITE);
4015      return connection.getStatusCodeReply();
4016    }
4017    @Override
4018    public String clusterNodes() {
4019      checkIsInMultiOrPipeline();
4020      connection.sendCommand(CLUSTER, ClusterKeyword.NODES);
4021      return connection.getBulkReply();
4022    }
4023    @Override
4024    public String clusterMeet(final String ip, final int port) {
4025      checkIsInMultiOrPipeline();
4026      connection.sendCommand(CLUSTER, ClusterKeyword.MEET.name(), ip, Integer.toString(port));
4027      return connection.getStatusCodeReply();
4028    }
4029    @Override
4030    public String clusterReset() {
4031      checkIsInMultiOrPipeline();
4032      connection.sendCommand(CLUSTER, ClusterKeyword.RESET);
4033      return connection.getStatusCodeReply();
4034    }
4035    @Override
4036    public String clusterReset(final ClusterResetType resetType) {
4037      checkIsInMultiOrPipeline();
4038      connection.sendCommand(CLUSTER, ClusterKeyword.RESET.getRaw(), resetType.getRaw());
4039      return connection.getStatusCodeReply();
4040    }
4041    @Override
4042    public String clusterAddSlots(final int... slots) {
4043      checkIsInMultiOrPipeline();
4044      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.ADDSLOTS.getRaw(), joinParameters(slots)));
4045      return connection.getStatusCodeReply();
4046    }
4047    @Override
4048    public String clusterDelSlots(final int... slots) {
4049      checkIsInMultiOrPipeline();
4050      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.DELSLOTS.getRaw(), joinParameters(slots)));
4051      return connection.getStatusCodeReply();
4052    }
4053    @Override
4054    public String clusterInfo() {
4055      checkIsInMultiOrPipeline();
4056      connection.sendCommand(CLUSTER, ClusterKeyword.INFO);
4057      return connection.getStatusCodeReply();
4058    }
4059    @Override
4060    public List&lt;String&gt; clusterGetKeysInSlot(final int slot, final int count) {
4061      checkIsInMultiOrPipeline();
4062      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4063      return connection.getMultiBulkReply();
4064    }
4065    @Override
4066    public List&lt;byte[]&gt; clusterGetKeysInSlotBinary(final int slot, final int count) {
4067      checkIsInMultiOrPipeline();
4068      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4069      return connection.getBinaryMultiBulkReply();
4070    }
4071    @Override
4072    public String clusterSetSlotNode(final int slot, final String nodeId) {
4073      checkIsInMultiOrPipeline();
4074      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.NODE.getRaw(), encode(nodeId));
4075      return connection.getStatusCodeReply();
4076    }
4077    @Override
4078    public String clusterSetSlotMigrating(final int slot, final String nodeId) {
4079      checkIsInMultiOrPipeline();
4080      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.MIGRATING.getRaw(), encode(nodeId));
4081      return connection.getStatusCodeReply();
4082    }
4083    @Override
4084    public String clusterSetSlotImporting(final int slot, final String nodeId) {
4085      checkIsInMultiOrPipeline();
4086      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.IMPORTING.getRaw(), encode(nodeId));
4087      return connection.getStatusCodeReply();
4088    }
4089    @Override
4090    public String clusterSetSlotStable(final int slot) {
4091      checkIsInMultiOrPipeline();
4092      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.STABLE.getRaw());
4093      return connection.getStatusCodeReply();
4094    }
4095    @Override
4096    public String clusterForget(final String nodeId) {
4097      checkIsInMultiOrPipeline();
4098      connection.sendCommand(CLUSTER, ClusterKeyword.FORGET.name(), nodeId);
4099      return connection.getStatusCodeReply();
4100    }
4101    @Override
4102    public String clusterFlushSlots() {
4103      checkIsInMultiOrPipeline();
4104      connection.sendCommand(CLUSTER, ClusterKeyword.FLUSHSLOTS);
4105      return connection.getStatusCodeReply();
4106    }
4107    @Override
4108    public long clusterKeySlot(final String key) {
4109      checkIsInMultiOrPipeline();
4110      connection.sendCommand(CLUSTER, ClusterKeyword.KEYSLOT.name(), key);
4111      return connection.getIntegerReply();
4112    }
4113    @Override
4114    public long clusterCountFailureReports(final String nodeId) {
4115      checkIsInMultiOrPipeline();
4116      connection.sendCommand(CLUSTER, &quot;COUNT-FAILURE-REPORTS&quot;,  nodeId);
4117      return connection.getIntegerReply();  
4118    }
4119    @Override
4120    public long clusterCountKeysInSlot(final int slot) {
4121      checkIsInMultiOrPipeline();
4122      connection.sendCommand(CLUSTER, ClusterKeyword.COUNTKEYSINSLOT.getRaw(), toByteArray(slot));
4123      return connection.getIntegerReply();
4124    }
4125    @Override
4126    public String clusterSaveConfig() {
4127      checkIsInMultiOrPipeline();
4128      connection.sendCommand(CLUSTER, ClusterKeyword.SAVECONFIG);
4129      return connection.getStatusCodeReply();
4130    }
4131    @Override
4132    public String clusterSetConfigEpoch(long configEpoch) {
4133      checkIsInMultiOrPipeline();
4134      connection.sendCommand(CLUSTER, &quot;SET-CONFIG-EPOCH&quot;, Long.toString(configEpoch));
4135      return connection.getStatusCodeReply();
4136    }
4137    @Override
4138    public String clusterBumpEpoch() {
4139      checkIsInMultiOrPipeline();
4140      connection.sendCommand(CLUSTER, ClusterKeyword.BUMPEPOCH);
4141      return connection.getBulkReply();
4142    }
4143    @Override
4144    public String clusterReplicate(final String nodeId) {
4145      checkIsInMultiOrPipeline();
4146      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICATE.name(), nodeId);
4147      return connection.getStatusCodeReply();
4148    }
4149    @Override
4150    @Deprecated
4151    public List&lt;String&gt; clusterSlaves(final String nodeId) {
4152      checkIsInMultiOrPipeline();
4153      connection.sendCommand(CLUSTER, ClusterKeyword.SLAVES.name(), nodeId);
4154      return connection.getMultiBulkReply();
4155    }
4156    @Override
4157    public List&lt;String&gt; clusterReplicas(final String nodeId) {
4158      checkIsInMultiOrPipeline();
4159      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICAS.name(), nodeId);
4160      return connection.getMultiBulkReply();
4161    }
4162    @Override
4163    public String clusterFailover() {
4164      checkIsInMultiOrPipeline();
4165      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER);
4166      return connection.getStatusCodeReply();
4167    }
4168    @Override
4169    public String clusterFailover(ClusterFailoverOption failoverOption) {
4170      checkIsInMultiOrPipeline();
4171      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER.getRaw(), failoverOption.getRaw());
4172      return connection.getStatusCodeReply();
4173    }
4174    @Override
4175    public List&lt;Object&gt; clusterSlots() {
4176      checkIsInMultiOrPipeline();
4177      connection.sendCommand(CLUSTER, ClusterKeyword.SLOTS);
4178      return connection.getObjectMultiBulkReply();
4179    }
4180    @Override
4181    public String clusterMyId() {
4182      checkIsInMultiOrPipeline();
4183      connection.sendCommand(CLUSTER, ClusterKeyword.MYID);
4184      return connection.getBulkReply();
4185    }
4186    @Override
4187    public String clusterMyShardId() {
4188      checkIsInMultiOrPipeline();
4189      connection.sendCommand(CLUSTER, ClusterKeyword.MYSHARDID);
4190      return connection.getBulkReply();
4191    }
4192    @Override
4193    public List&lt;Map&lt;String, Object&gt;&gt; clusterLinks() {
4194      checkIsInMultiOrPipeline();
4195      connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);
4196      return connection.getObjectMultiBulkReply().stream()
4197              .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());
4198    }
4199    @Override
4200    public String clusterAddSlotsRange(int... ranges) {
4201      checkIsInMultiOrPipeline();
4202      connection.sendCommand(CLUSTER,
4203          joinParameters(ClusterKeyword.ADDSLOTSRANGE.getRaw(), joinParameters(ranges)));
4204      return connection.getStatusCodeReply();
4205    }
4206    @Override
4207    public String clusterDelSlotsRange(int... ranges) {
4208      checkIsInMultiOrPipeline();
4209      connection.sendCommand(CLUSTER,
4210          joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));
4211      return connection.getStatusCodeReply();
4212    }
4213    @Override
4214    public String asking() {
4215      checkIsInMultiOrPipeline();
4216      connection.sendCommand(ASKING);
4217      return connection.getStatusCodeReply();
4218    }
4219    @Override
4220    public long pfadd(final String key, final String... elements) {
4221      checkIsInMultiOrPipeline();
4222      return connection.executeCommand(commandObjects.pfadd(key, elements));
4223    }
4224    @Override
4225    public long pfcount(final String key) {
4226      checkIsInMultiOrPipeline();
4227      return connection.executeCommand(commandObjects.pfcount(key));
4228    }
4229    @Override
4230    public long pfcount(final String... keys) {
4231      checkIsInMultiOrPipeline();
4232      return connection.executeCommand(commandObjects.pfcount(keys));
4233    }
4234    @Override
4235    public String pfmerge(final String destkey, final String... sourcekeys) {
4236      checkIsInMultiOrPipeline();
4237      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
4238    }
4239    @Override
4240    public Object fcall(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4241      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4242    }
4243    @Override
4244    public Object fcallReadonly(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4245      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4246    }
4247    @Override
4248    public String functionDelete(final String libraryName) {
4249      checkIsInMultiOrPipeline();
4250      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4251    }
4252    @Override
4253    public String functionLoad(final String functionCode) {
4254      checkIsInMultiOrPipeline();
4255      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4256    }
4257    @Override
4258    public String functionLoadReplace(final String functionCode) {
4259      checkIsInMultiOrPipeline();
4260      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4261    }
4262    @Override
4263    public FunctionStats functionStats() {
4264      checkIsInMultiOrPipeline();
4265      return connection.executeCommand(commandObjects.functionStats());
4266    }
4267    @Override
4268    public String functionFlush() {
4269      checkIsInMultiOrPipeline();
4270      return connection.executeCommand(commandObjects.functionFlush());
4271    }
4272    @Override
4273    public String functionFlush(final FlushMode mode) {
4274      checkIsInMultiOrPipeline();
4275      return connection.executeCommand(commandObjects.functionFlush(mode));
4276    }
4277    @Override
4278    public String functionKill() {
4279      checkIsInMultiOrPipeline();
4280      return connection.executeCommand(commandObjects.functionKill());
4281    }
4282    @Override
4283    public List&lt;LibraryInfo&gt; functionList() {
4284      checkIsInMultiOrPipeline();
4285      return connection.executeCommand(commandObjects.functionList());
4286    }
4287    @Override
4288    public List&lt;LibraryInfo&gt; functionList(final String libraryNamePattern) {
4289      checkIsInMultiOrPipeline();
4290      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4291    }
4292    @Override
4293    public List&lt;LibraryInfo&gt; functionListWithCode() {
4294      checkIsInMultiOrPipeline();
4295      return connection.executeCommand(commandObjects.functionListWithCode());  }
4296    @Override
4297    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
4298      checkIsInMultiOrPipeline();
4299      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4300    }
4301    @Override
4302    public long geoadd(final String key, final double longitude, final double latitude,
4303        final String member) {
4304      checkIsInMultiOrPipeline();
4305      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
4306    }
4307    @Override
4308    public long geoadd(final String key, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4309      checkIsInMultiOrPipeline();
4310      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
4311    }
4312    @Override
4313    public long geoadd(final String key, final GeoAddParams params, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4314      checkIsInMultiOrPipeline();
4315      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
4316    }
4317    @Override
4318    public Double geodist(final String key, final String member1, final String member2) {
4319      checkIsInMultiOrPipeline();
4320      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
4321    }
4322    @Override
4323    public Double geodist(final String key, final String member1, final String member2,
4324        final GeoUnit unit) {
4325      checkIsInMultiOrPipeline();
4326      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
4327    }
4328    @Override
4329    public List&lt;String&gt; geohash(final String key, String... members) {
4330      checkIsInMultiOrPipeline();
4331      return connection.executeCommand(commandObjects.geohash(key, members));
4332    }
4333    @Override
4334    public List&lt;GeoCoordinate&gt; geopos(final String key, String... members) {
4335      checkIsInMultiOrPipeline();
4336      return connection.executeCommand(commandObjects.geopos(key, members));
4337    }
4338    @Override
4339    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4340        final double latitude, final double radius, final GeoUnit unit) {
4341      checkIsInMultiOrPipeline();
4342      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
4343    }
4344    @Override
4345    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4346        final double latitude, final double radius, final GeoUnit unit) {
4347      checkIsInMultiOrPipeline();
4348      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
4349    }
4350    @Override
4351    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4352        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4353      checkIsInMultiOrPipeline();
4354      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
4355    }
4356    @Override
4357    public long georadiusStore(final String key, double longitude, double latitude, double radius,
4358        GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4359      checkIsInMultiOrPipeline();
4360      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
4361    }
4362    @Override
4363    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4364        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4365      checkIsInMultiOrPipeline();
4366      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
4367    }
4368    @Override
4369    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4370        final double radius, final GeoUnit unit) {
4371      checkIsInMultiOrPipeline();
4372      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
4373    }
4374    @Override
4375    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4376        final double radius, final GeoUnit unit) {
4377      checkIsInMultiOrPipeline();
4378      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
4379    }
4380    @Override
4381    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4382        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4383      checkIsInMultiOrPipeline();
4384      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
4385    }
4386    @Override
4387    public long georadiusByMemberStore(final String key, String member, double radius, GeoUnit unit,
4388        GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4389      checkIsInMultiOrPipeline();
4390      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
4391    }
4392    @Override
4393    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4394        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4395      checkIsInMultiOrPipeline();
4396      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
4397    }
4398    @Override
<span onclick='openModal()' class='match'>4399    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
4400      checkIsInMultiOrPipeline();
</span>4401      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
4402    }
4403    @Override
4404    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
4405      checkIsInMultiOrPipeline();
4406      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
4407    }
4408    @Override
4409    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
4410      checkIsInMultiOrPipeline();
4411      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
4412    }
4413    @Override
4414    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4415      checkIsInMultiOrPipeline();
4416      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
4417    }
4418    @Override
4419    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
4420      checkIsInMultiOrPipeline();
4421      return connection.executeCommand(commandObjects.geosearch(key, params));
4422    }
4423    @Override
4424    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
4425      checkIsInMultiOrPipeline();
4426      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
4427    }
4428    @Override
4429    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
4430      checkIsInMultiOrPipeline();
4431      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
4432    }
4433    @Override
4434    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
4435      checkIsInMultiOrPipeline();
4436      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
4437    }
4438    @Override
4439    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4440      checkIsInMultiOrPipeline();
4441      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
4442    }
4443    @Override
4444    public long geosearchStore(String dest, String src, GeoSearchParam params) {
4445      checkIsInMultiOrPipeline();
4446      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
4447    }
4448    @Override
4449    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
4450      checkIsInMultiOrPipeline();
4451      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
4452    }
4453    @Override
4454    public String moduleLoad(final String path) {
4455      checkIsInMultiOrPipeline();
4456      connection.sendCommand(Command.MODULE, LOAD.name(), path);
4457      return connection.getStatusCodeReply();
4458    }
4459    @Override
4460    public String moduleLoad(String path, String... args) {
4461      checkIsInMultiOrPipeline();
4462      connection.sendCommand(Command.MODULE, joinParameters(LOAD.name(), path, args));
4463      return connection.getStatusCodeReply();
4464    }
4465    @Override
4466    public String moduleLoadEx(String path, ModuleLoadExParams params) {
4467      checkIsInMultiOrPipeline();
4468      connection.sendCommand(new CommandArguments(Command.MODULE).add(LOADEX).add(path)
4469          .addParams(params));
4470      return connection.getStatusCodeReply();
4471    }
4472    @Override
4473    public String moduleUnload(final String name) {
4474      checkIsInMultiOrPipeline();
4475      connection.sendCommand(Command.MODULE, UNLOAD.name(), name);
4476      return connection.getStatusCodeReply();
4477    }
4478    @Override
4479    public List&lt;Module&gt; moduleList() {
4480      checkIsInMultiOrPipeline();
4481      connection.sendCommand(Command.MODULE, LIST);
4482      return BuilderFactory.MODULE_LIST.build(connection.getOne());
4483    }
4484    @Override
4485    public List&lt;Long&gt; bitfield(final String key, final String... arguments) {
4486      checkIsInMultiOrPipeline();
4487      return connection.executeCommand(commandObjects.bitfield(key, arguments));
4488    }
4489    @Override
4490    public List&lt;Long&gt; bitfieldReadonly(final String key, final String... arguments) {
4491      checkIsInMultiOrPipeline();
4492      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
4493    }
4494    @Override
4495    public long hstrlen(final String key, final String field) {
4496      checkIsInMultiOrPipeline();
4497      return connection.executeCommand(commandObjects.hstrlen(key, field));
4498    }
4499    @Override
4500    public String memoryDoctor() {
4501      checkIsInMultiOrPipeline();
4502      connection.sendCommand(MEMORY, DOCTOR);
4503      return connection.getBulkReply();
4504    }
4505    @Override
4506    public Long memoryUsage(final String key) {
4507      checkIsInMultiOrPipeline();
4508      connection.sendCommand(MEMORY, USAGE.name(), key);
4509      return connection.getIntegerReply();
4510    }
4511    @Override
4512    public Long memoryUsage(final String key, final int samples) {
4513      checkIsInMultiOrPipeline();
4514      connection.sendCommand(MEMORY, USAGE.getRaw(), encode(key), SAMPLES.getRaw(), toByteArray(samples));
4515      return connection.getIntegerReply();
4516    }
4517    @Override
4518    public String memoryPurge() {
4519      checkIsInMultiOrPipeline();
4520      connection.sendCommand(MEMORY, PURGE);
4521      return connection.getBulkReply();
4522    }
4523    @Override
4524    public Map&lt;String, Object&gt; memoryStats() {
4525      checkIsInMultiOrPipeline();
4526      connection.sendCommand(MEMORY, STATS);
4527      return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());
4528    }
4529    @Override
4530    public String lolwut() {
4531      checkIsInMultiOrPipeline();
4532      connection.sendCommand(LOLWUT);
4533      return connection.getBulkReply();
4534    }
4535    @Override
4536    public String lolwut(LolwutParams lolwutParams) {
4537      checkIsInMultiOrPipeline();
4538      connection.sendCommand(new CommandArguments(LOLWUT).addParams(lolwutParams));
4539      return connection.getBulkReply();
4540    }
4541    @Override
4542    public String latencyDoctor() {
4543      checkIsInMultiOrPipeline();
4544      connection.sendCommand(LATENCY, DOCTOR);
4545      return connection.getBulkReply();
4546    }
4547    @Override
4548    public StreamEntryID xadd(final String key, final StreamEntryID id, final Map&lt;String, String&gt; hash) {
4549      checkIsInMultiOrPipeline();
4550      return connection.executeCommand(commandObjects.xadd(key, id, hash));
4551    }
4552    @Override
4553    public StreamEntryID xadd(final String key, final XAddParams params, final Map&lt;String, String&gt; hash) {
4554      checkIsInMultiOrPipeline();
4555      return connection.executeCommand(commandObjects.xadd(key, params, hash));
4556    }
4557    @Override
4558    public long xlen(final String key) {
4559      checkIsInMultiOrPipeline();
4560      return connection.executeCommand(commandObjects.xlen(key));
4561    }
4562    @Override
4563    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start, final StreamEntryID end) {
4564      checkIsInMultiOrPipeline();
4565      return connection.executeCommand(commandObjects.xrange(key, start, end));
4566    }
4567    @Override
4568    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start,
4569        final StreamEntryID end, final int count) {
4570      checkIsInMultiOrPipeline();
4571      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4572    }
4573    @Override
4574    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4575        final StreamEntryID start) {
4576      checkIsInMultiOrPipeline();
4577      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4578    }
4579    @Override
4580    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4581        final StreamEntryID start, final int count) {
4582      checkIsInMultiOrPipeline();
4583      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4584    }
4585    @Override
4586    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end) {
4587      checkIsInMultiOrPipeline();
4588      return connection.executeCommand(commandObjects.xrange(key, start, end));
4589    }
4590    @Override
4591    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end, final int count) {
4592      checkIsInMultiOrPipeline();
4593      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4594    }
4595    @Override
4596    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start) {
4597      checkIsInMultiOrPipeline();
4598      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4599    }
4600    @Override
4601    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start, final int count) {
4602      checkIsInMultiOrPipeline();
4603      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4604    }
4605    @Override
4606    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(final XReadParams xReadParams, final Map&lt;String, StreamEntryID&gt; streams) {
4607      checkIsInMultiOrPipeline();
4608      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
4609    }
4610    @Override
4611    public long xack(final String key, final String group, final StreamEntryID... ids) {
4612      checkIsInMultiOrPipeline();
4613      return connection.executeCommand(commandObjects.xack(key, group, ids));
4614    }
4615    @Override
4616    public String xgroupCreate(final String key, final String groupName, final StreamEntryID id,
4617        final boolean makeStream) {
4618      checkIsInMultiOrPipeline();
4619      return connection.executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
4620    }
4621    @Override
4622    public String xgroupSetID(final String key, final String groupName, final StreamEntryID id) {
4623      checkIsInMultiOrPipeline();
4624      return connection.executeCommand(commandObjects.xgroupSetID(key, groupName, id));
4625    }
4626    @Override
4627    public long xgroupDestroy(final String key, final String groupName) {
4628      checkIsInMultiOrPipeline();
4629      return connection.executeCommand(commandObjects.xgroupDestroy(key, groupName));
4630    }
4631    @Override
4632    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
4633      checkIsInMultiOrPipeline();
4634      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
4635    }
4636    @Override
4637    public long xgroupDelConsumer(final String key, final String groupName, final String consumerName) {
4638      checkIsInMultiOrPipeline();
4639      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
4640    }
4641    @Override
4642    public long xdel(final String key, final StreamEntryID... ids) {
4643      checkIsInMultiOrPipeline();
4644      return connection.executeCommand(commandObjects.xdel(key, ids));
4645    }
4646    @Override
4647    public long xtrim(final String key, final long maxLen, final boolean approximateLength) {
4648      checkIsInMultiOrPipeline();
4649      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
4650    }
4651    @Override
4652    public long xtrim(final String key, final XTrimParams params) {
4653      checkIsInMultiOrPipeline();
4654      return connection.executeCommand(commandObjects.xtrim(key, params));
4655    }
4656    @Override
4657    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(final String groupName,
4658        final String consumer, final XReadGroupParams xReadGroupParams,
4659        final Map&lt;String, StreamEntryID&gt; streams) {
4660      checkIsInMultiOrPipeline();
4661      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
4662    }
4663    @Override
4664    public StreamPendingSummary xpending(final String key, final String groupName) {
4665      checkIsInMultiOrPipeline();
4666      return connection.executeCommand(commandObjects.xpending(key, groupName));
4667    }
4668    @Override
4669    public List&lt;StreamPendingEntry&gt; xpending(final String key, final String groupName, final XPendingParams params) {
4670      checkIsInMultiOrPipeline();
4671      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
4672    }
4673    @Override
4674    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime,
4675        XClaimParams params, StreamEntryID... ids) {
4676      checkIsInMultiOrPipeline();
4677      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
4678    }
4679    @Override
4680    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName,
4681        long minIdleTime, XClaimParams params, StreamEntryID... ids) {
4682      checkIsInMultiOrPipeline();
4683      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
4684    }
4685    @Override
4686    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName,
4687        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4688      checkIsInMultiOrPipeline();
4689      return connection.executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
4690    }
4691    @Override
4692    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName,
4693        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4694      checkIsInMultiOrPipeline();
4695      return connection.executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
4696    }
4697    @Override
4698    public StreamInfo xinfoStream(String key) {
4699      return connection.executeCommand(commandObjects.xinfoStream(key));
4700    }
4701    @Override
4702    public StreamFullInfo xinfoStreamFull(String key) {
4703      checkIsInMultiOrPipeline();
4704      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
4705    }
4706    @Override
4707    public StreamFullInfo xinfoStreamFull(String key, int count) {
4708      checkIsInMultiOrPipeline();
4709      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
4710    }
4711    @Override
4712    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
4713      return connection.executeCommand(commandObjects.xinfoGroups(key));
4714    }
4715    @Override
4716    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
4717      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
4718    }
4719    @Override
4720    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
4721      return connection.executeCommand(commandObjects.xinfoConsumers2(key, group));
4722    }
4723    @Override
4724    public Object fcall(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4725      checkIsInMultiOrPipeline();
4726      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4727    }
4728    @Override
4729    public Object fcallReadonly(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4730      checkIsInMultiOrPipeline();
4731      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4732    }
4733    @Override
4734    public String functionDelete(final byte[] libraryName) {
4735      checkIsInMultiOrPipeline();
4736      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4737    }
4738    @Override
4739    public byte[] functionDump() {
4740      checkIsInMultiOrPipeline();
4741      return connection.executeCommand(commandObjects.functionDump());
4742    }
4743    @Override
4744    public List&lt;Object&gt; functionListBinary() {
4745      checkIsInMultiOrPipeline();
4746      return connection.executeCommand(commandObjects.functionListBinary());
4747    }
4748    @Override
4749    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
4750      checkIsInMultiOrPipeline();
4751      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4752    }
4753    @Override
4754    public List&lt;Object&gt; functionListWithCodeBinary() {
4755      checkIsInMultiOrPipeline();
4756      return connection.executeCommand(commandObjects.functionListWithCodeBinary());
4757    }
4758    @Override
4759    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
4760      checkIsInMultiOrPipeline();
4761      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4762    }
4763    @Override
4764    public String functionLoad(final byte[] functionCode) {
4765      checkIsInMultiOrPipeline();
4766      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4767    }
4768    @Override
4769    public String functionLoadReplace(final byte[] functionCode) {
4770      checkIsInMultiOrPipeline();
4771      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4772    }
4773    @Override
4774    public String functionRestore(final byte[] serializedValue) {
4775      checkIsInMultiOrPipeline();
4776      return connection.executeCommand(commandObjects.functionRestore(serializedValue));
4777    }
4778    @Override
4779    public String functionRestore(final byte[] serializedValue, final FunctionRestorePolicy policy) {
4780      checkIsInMultiOrPipeline();
4781      return connection.executeCommand(commandObjects.functionRestore(serializedValue, policy));
4782    }
4783    @Override
4784    public Object functionStatsBinary() {
4785      checkIsInMultiOrPipeline();
4786      return connection.executeCommand(commandObjects.functionStatsBinary());
4787    }
4788    public Object sendCommand(ProtocolCommand cmd, String... args) {
4789      checkIsInMultiOrPipeline();
4790      connection.sendCommand(cmd, args);
4791      return connection.getOne();
4792    }
4793    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
4794      checkIsInMultiOrPipeline();
4795      connection.sendCommand(cmd, args);
4796      connection.setTimeoutInfinite();
4797      try {
4798        return connection.getOne();
4799      } finally {
4800        connection.rollbackTimeout();
4801      }
4802    }
4803    private static byte[][] joinParameters(int... params) {
4804      byte[][] result = new byte[params.length][];
4805      for (int i = 0; i &lt; params.length; i++) {
4806        result[i] = toByteArray(params[i]);
4807      }
4808      return result;
4809    }
4810    private static byte[][] joinParameters(byte[] first, byte[][] rest) {
4811      byte[][] result = new byte[rest.length + 1][];
4812      result[0] = first;
4813      System.arraycopy(rest, 0, result, 1, rest.length);
4814      return result;
4815    }
4816    private static byte[][] joinParameters(byte[] first, byte[] second, byte[][] rest) {
4817      byte[][] result = new byte[rest.length + 2][];
4818      result[0] = first;
4819      result[1] = second;
4820      System.arraycopy(rest, 0, result, 2, rest.length);
4821      return result;
4822    }
4823    private static String[] joinParameters(String first, String[] rest) {
4824      String[] result = new String[rest.length + 1];
4825      result[0] = first;
4826      System.arraycopy(rest, 0, result, 1, rest.length);
4827      return result;
4828    }
4829    private static String[] joinParameters(String first, String second, String[] rest) {
4830      String[] result = new String[rest.length + 2];
4831      result[0] = first;
4832      result[1] = second;
4833      System.arraycopy(rest, 0, result, 2, rest.length);
4834      return result;
4835    }
4836  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-UnifiedJedis.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</div>
                </div>
                <div class="column column_space"><pre><code>2099    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
2100      return executeCommand(commandObjects.geosearch(key, member, radius, unit));
</pre></code></div>
                <div class="column column_space"><pre><code>4399    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
4400      checkIsInMultiOrPipeline();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    