<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DefaultChannelGroup.java & EmptyHeaders.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DefaultChannelGroup.java & EmptyHeaders.java
      </h3>
      <h1 align="center">
        9.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DefaultChannelGroup.java (10.775862%)<TH>EmptyHeaders.java (9.282178%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#0',2,'match378659-1.html#0',3)" NAME="0">(284-294)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#0',2,'match378659-1.html#0',3)" NAME="0">(48-58)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#1',2,'match378659-1.html#1',3)" NAME="1">(437-445)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#1',2,'match378659-1.html#1',3)" NAME="1">(304-312)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#2',2,'match378659-1.html#2',3)" NAME="2">(123-129)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#2',2,'match378659-1.html#2',3)" NAME="2">(499-505)</A><TD ALIGN=center><FONT COLOR="#9f0000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#3',2,'match378659-1.html#3',3)" NAME="3">(99-106)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#3',2,'match378659-1.html#3',3)" NAME="3">(294-301)</A><TD ALIGN=center><FONT COLOR="#9f0000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#4',2,'match378659-1.html#4',3)" NAME="4">(457-461)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#4',2,'match378659-1.html#4',3)" NAME="4">(515-519)</A><TD ALIGN=center><FONT COLOR="#8f0000">9</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#5',2,'match378659-1.html#5',3)" NAME="5">(377-382)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#5',2,'match378659-1.html#5',3)" NAME="5">(28-33)</A><TD ALIGN=center><FONT COLOR="#8f0000">9</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match378659-0.html#6',2,'match378659-1.html#6',3)" NAME="6">(118-123)<TD><A HREF="javascript:ZweiFrames('match378659-0.html#6',2,'match378659-1.html#6',3)" NAME="6">(509-514)</A><TD ALIGN=center><FONT COLOR="#8f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultChannelGroup.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2013 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.channel.group;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufHolder;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelId;
import io.netty.channel.ServerChannel;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.StringUtil;

import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The default {@link ChannelGroup} implementation.
 */
public class DefaultChannelGroup extends AbstractSet&lt;Channel&gt; implements ChannelGroup {

    private static final AtomicInteger nextId = new AtomicInteger();
    private final String name;
    private final EventExecutor executor;
    private final ConcurrentMap&lt;ChannelId, Channel&gt; serverChannels = PlatformDependent.newConcurrentHashMap();
    private final ConcurrentMap&lt;ChannelId, Channel&gt; nonServerChannels = PlatformDependent.newConcurrentHashMap();
    private final ChannelFutureListener remover = new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
            remove(future.channel());
        }
    };
    private final VoidChannelGroupFuture voidFuture = new VoidChannelGroupFuture(this);
    private final boolean stayClosed;
    private volatile boolean closed;

    /**
     * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s.
     */
    public DefaultChannelGroup(EventExecutor executor) {
        this(executor, false);
    }

    /**
     * Creates a new group with the specified {@code name} and {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s.  Please note that different groups can have the same name, which means no
     * duplicate check is done against group names.
     */
    public DefaultChannelGroup(String name, EventExecutor executor) {
        this(name, executor, false);
    }

    /**
     * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s. {@code stayClosed} defines whether or not, this group can be closed
     * more than once. Adding channels to a closed group will immediately close them, too. This makes it
     * easy, to shutdown server and child channels at once.
     */
    public DefaultChannelGroup(EventExecutor executor, boolean stayClosed) {
        this(&quot;group-0x&quot; + Integer.toHexString(nextId.incrementAndGet()), executor, stayClosed);
    }

    /**
     * Creates a new group with the specified {@code name} and {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s. {@code stayClosed} defines whether or not, this group can be closed
     * more than once. Adding channels to a closed group will immediately close them, too. This makes it
     * easy, to shutdown server and child channels at once. Please note that different groups can have
     * the same name, which means no duplicate check is done against group names.
     */
    public DefaultChannelGroup(String name, EventExecutor executor, boolean stayClosed) {
        ObjectUtil.checkNotNull(name, &quot;name&quot;);
<A NAME="3"></A>        this.name = name;
        this.executor = executor;
        this.stayClosed = stayClosed;
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match378659-1.html#3',3,'match378659-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public String name() {
        return name;
    }

    @</B></FONT>Override
    public Channel find(ChannelId id) {
        Channel c = nonServerChannels.get(id);
        if (c != null) {
            return c;
        } else {
            return serverChannels.get(id);
        }
    }
<A NAME="6"></A>
    @Override
    public boolean isEmpty() {
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match378659-1.html#6',3,'match378659-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return nonServerChannels.isEmpty() &amp;&amp; serverChannels.isEmpty();
    }
<A NAME="2"></A>
    @Override
    public int size() {
        return</B></FONT> nonServerChannels.size() + <FONT color="#980517"><A HREF="javascript:ZweiFrames('match378659-1.html#2',3,'match378659-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>serverChannels.size();
    }

    @Override
    public boolean contains(Object o) {
        if (o instanceof ServerChannel) {
            return</B></FONT> serverChannels.containsValue(o);
        } else if (o instanceof Channel) {
            return nonServerChannels.containsValue(o);
        }
        return false;
    }

    @Override
    public boolean add(Channel channel) {
        ConcurrentMap&lt;ChannelId, Channel&gt; map =
            channel instanceof ServerChannel? serverChannels : nonServerChannels;

        boolean added = map.putIfAbsent(channel.id(), channel) == null;
        if (added) {
            channel.closeFuture().addListener(remover);
        }

        if (stayClosed &amp;&amp; closed) {

            // First add channel, than check if closed.
            // Seems inefficient at first, but this way a volatile
            // gives us enough synchronization to be thread-safe.
            //
            // If true: Close right away.
            // (Might be closed a second time by ChannelGroup.close(), but this is ok)
            //
            // If false: Channel will definitely be closed by the ChannelGroup.
            // (Because closed=true always happens-before ChannelGroup.close())
            //
            // See https://github.com/netty/netty/issues/4020
            channel.close();
        }

        return added;
    }

    @Override
    public boolean remove(Object o) {
        Channel c = null;
        if (o instanceof ChannelId) {
            c = nonServerChannels.remove(o);
            if (c == null) {
                c = serverChannels.remove(o);
            }
        } else if (o instanceof Channel) {
            c = (Channel) o;
            if (c instanceof ServerChannel) {
                c = serverChannels.remove(c.id());
            } else {
                c = nonServerChannels.remove(c.id());
            }
        }

        if (c == null) {
            return false;
        }

        c.closeFuture().removeListener(remover);
        return true;
    }

    @Override
    public void clear() {
        nonServerChannels.clear();
        serverChannels.clear();
    }

    @Override
    public Iterator&lt;Channel&gt; iterator() {
        return new CombinedIterator&lt;Channel&gt;(
                serverChannels.values().iterator(),
                nonServerChannels.values().iterator());
    }

    @Override
    public Object[] toArray() {
        Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
        channels.addAll(serverChannels.values());
        channels.addAll(nonServerChannels.values());
        return channels.toArray();
    }

    @Override
    public &lt;T&gt; T[] toArray(T[] a) {
        Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
        channels.addAll(serverChannels.values());
        channels.addAll(nonServerChannels.values());
        return channels.toArray(a);
    }

    @Override
    public ChannelGroupFuture close() {
        return close(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture disconnect() {
        return disconnect(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture deregister() {
        return deregister(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture write(Object message) {
        return write(message, ChannelMatchers.all());
    }

    // Create a safe duplicate of the message to write it to a channel but not affect other writes.
    // See https://github.com/netty/netty/issues/1461
    private static Object safeDuplicate(Object message) {
        if (message instanceof ByteBuf) {
            return ((ByteBuf) message).retainedDuplicate();
        } else if (message instanceof ByteBufHolder) {
            return ((ByteBufHolder) message).retainedDuplicate();
        } else {
            return ReferenceCountUtil.retain(message);
        }
    }

    @Override
    public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
        return write(message, matcher, false);
    }

    @Override
    public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise) {
        ObjectUtil.checkNotNull(message, &quot;message&quot;);
        ObjectUtil.checkNotNull(matcher, &quot;matcher&quot;);

        final ChannelGroupFuture future;
        if (voidPromise) {
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    c.write(safeDuplicate(message), c.voidPromise());
                }
            }
            future = voidFuture;
        } else {
            Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    futures.put(c, c.write(safeDuplicate(message)));
                }
            }
            future = new DefaultChannelGroupFuture(this, futures, executor);
        }
        ReferenceCountUtil.release(message);
        return future;
    }
<A NAME="0"></A>
    @Override
    public ChannelGroup flush() {
        return flush(<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match378659-1.html#0',3,'match378659-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture flushAndWrite(Object message) {
        return writeAndFlush(message);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message) {
        return</B></FONT> writeAndFlush(message, ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture disconnect(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, &quot;matcher&quot;);

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.disconnect());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.disconnect());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroupFuture close(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, &quot;matcher&quot;);

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        if (stayClosed) {
            // It is important to set the closed to true, before closing channels.
            // Our invariants are:
            // closed=true happens-before ChannelGroup.close()
            // ChannelGroup.add() happens-before checking closed==true
            //
            // See https://github.com/netty/netty/issues/4020
            closed = true;
        }

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.close());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.close());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroupFuture deregister(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, &quot;matcher&quot;);

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.deregister());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.deregister());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroup flush(ChannelMatcher matcher) {
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
<A NAME="5"></A>                c.flush();
            }
        }
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match378659-1.html#5',3,'match378659-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return this;
    }

    @Override
    public ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher) {
        return</B></FONT> writeAndFlush(message, matcher);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher) {
        return writeAndFlush(message, matcher, false);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise) {
        ObjectUtil.checkNotNull(message, &quot;message&quot;);

        final ChannelGroupFuture future;
        if (voidPromise) {
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    c.writeAndFlush(safeDuplicate(message), c.voidPromise());
                }
            }
            future = voidFuture;
        } else {
            Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    futures.put(c, c.writeAndFlush(safeDuplicate(message)));
                }
            }
            future = new DefaultChannelGroupFuture(this, futures, executor);
        }
        ReferenceCountUtil.release(message);
        return future;
    }

    @Override
    public ChannelGroupFuture newCloseFuture() {
        return newCloseFuture(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture newCloseFuture(ChannelMatcher matcher) {
        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.closeFuture());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.closeFuture());
            }
<A NAME="1"></A>        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match378659-1.html#1',3,'match378659-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public int hashCode() {
        return System.identityHashCode(this);
    }

    @Override
    public boolean equals(Object o</B></FONT>) {
        return this == o;
    }

    @Override
    public int compareTo(ChannelGroup o) {
        int v = name().compareTo(o.name());
        if (v != 0) {
            return v;
<A NAME="4"></A>        }

        return System.identityHashCode(this) - System.identityHashCode(o);
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match378659-1.html#4',3,'match378659-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public String toString() {
        return StringUtil.simpleClassName(this) + &quot;(name: &quot; + name() + &quot;, size: &quot; + size</B></FONT>() + ')';
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>EmptyHeaders.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package io.netty.handler.codec;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import static io.netty.handler.codec.DefaultHeaders.HASH_CODE_SEED;

<A NAME="5"></A>public class EmptyHeaders&lt;K, V, T extends Headers&lt;K, V, T&gt;&gt; implements Headers&lt;K, V, T&gt; {
    @Override
    public V get(K name) {
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#5',2,'match378659-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return null;
    }

    @Override
    public V get(K name, V defaultValue) {
        return</B></FONT> defaultValue;
    }

    @Override
    public V getAndRemove(K name) {
        return null;
    }

    @Override
    public V getAndRemove(K name, V defaultValue) {
        return defaultValue;
    }
<A NAME="0"></A>
    @Override
    public List&lt;V&gt; getAll(K name) {
        return <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#0',2,'match378659-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Collections.emptyList();
    }

    @Override
    public List&lt;V&gt; getAllAndRemove(K name) {
        return Collections.emptyList();
    }

    @Override
    public Boolean getBoolean(K name) {
        return</B></FONT> null;
    }

    @Override
    public boolean getBoolean(K name, boolean defaultValue) {
        return defaultValue;
    }

    @Override
    public Byte getByte(K name) {
        return null;
    }

    @Override
    public byte getByte(K name, byte defaultValue) {
        return defaultValue;
    }

    @Override
    public Character getChar(K name) {
        return null;
    }

    @Override
    public char getChar(K name, char defaultValue) {
        return defaultValue;
    }

    @Override
    public Short getShort(K name) {
        return null;
    }

    @Override
    public short getShort(K name, short defaultValue) {
        return defaultValue;
    }

    @Override
    public Integer getInt(K name) {
        return null;
    }

    @Override
    public int getInt(K name, int defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getLong(K name) {
        return null;
    }

    @Override
    public long getLong(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Float getFloat(K name) {
        return null;
    }

    @Override
    public float getFloat(K name, float defaultValue) {
        return defaultValue;
    }

    @Override
    public Double getDouble(K name) {
        return null;
    }

    @Override
    public double getDouble(K name, double defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getTimeMillis(K name) {
        return null;
    }

    @Override
    public long getTimeMillis(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Boolean getBooleanAndRemove(K name) {
        return null;
    }

    @Override
    public boolean getBooleanAndRemove(K name, boolean defaultValue) {
        return defaultValue;
    }

    @Override
    public Byte getByteAndRemove(K name) {
        return null;
    }

    @Override
    public byte getByteAndRemove(K name, byte defaultValue) {
        return defaultValue;
    }

    @Override
    public Character getCharAndRemove(K name) {
        return null;
    }

    @Override
    public char getCharAndRemove(K name, char defaultValue) {
        return defaultValue;
    }

    @Override
    public Short getShortAndRemove(K name) {
        return null;
    }

    @Override
    public short getShortAndRemove(K name, short defaultValue) {
        return defaultValue;
    }

    @Override
    public Integer getIntAndRemove(K name) {
        return null;
    }

    @Override
    public int getIntAndRemove(K name, int defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getLongAndRemove(K name) {
        return null;
    }

    @Override
    public long getLongAndRemove(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Float getFloatAndRemove(K name) {
        return null;
    }

    @Override
    public float getFloatAndRemove(K name, float defaultValue) {
        return defaultValue;
    }

    @Override
    public Double getDoubleAndRemove(K name) {
        return null;
    }

    @Override
    public double getDoubleAndRemove(K name, double defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getTimeMillisAndRemove(K name) {
        return null;
    }

    @Override
    public long getTimeMillisAndRemove(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public boolean contains(K name) {
        return false;
    }

    @Override
    public boolean contains(K name, V value) {
        return false;
    }

    @Override
    public boolean containsObject(K name, Object value) {
        return false;
    }

    @Override
    public boolean containsBoolean(K name, boolean value) {
        return false;
    }

    @Override
    public boolean containsByte(K name, byte value) {
        return false;
    }

    @Override
    public boolean containsChar(K name, char value) {
        return false;
    }

    @Override
    public boolean containsShort(K name, short value) {
        return false;
    }

    @Override
    public boolean containsInt(K name, int value) {
        return false;
    }

    @Override
    public boolean containsLong(K name, long value) {
        return false;
    }

    @Override
    public boolean containsFloat(K name, float value) {
        return false;
    }

    @Override
    public boolean containsDouble(K name, double value) {
        return false;
    }

<A NAME="3"></A>    @Override
    public boolean containsTimeMillis(K name, long value) {
        return false;
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#3',2,'match378659-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public int size() {
        return 0;
    }

<A NAME="1"></A>    @</B></FONT>Override
    public boolean isEmpty() {
        return true;
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#1',2,'match378659-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public Set&lt;K&gt; names() {
        return Collections.emptySet();
    }

    @Override
    public T add(K name</B></FONT>, V value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T add(K name, Iterable&lt;? extends V&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T add(K name, V... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addObject(K name, Object value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addObject(K name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addObject(K name, Object... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addBoolean(K name, boolean value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addByte(K name, byte value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addChar(K name, char value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addShort(K name, short value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addInt(K name, int value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addLong(K name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addFloat(K name, float value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addDouble(K name, double value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T addTimeMillis(K name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T add(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T set(K name, V value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T set(K name, Iterable&lt;? extends V&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T set(K name, V... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setObject(K name, Object value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setObject(K name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setObject(K name, Object... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setBoolean(K name, boolean value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setByte(K name, byte value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setChar(K name, char value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setShort(K name, short value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setInt(K name, int value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setLong(K name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setFloat(K name, float value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setDouble(K name, double value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setTimeMillis(K name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T set(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public T setAll(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public boolean remove(K name) {
        return false;
    }

    @Override
    public T clear() {
        return thisT();
    }

    /**
     * Equivalent to {@link #getAll(Object)} but no intermediate list is generated.
     * @param name the name of the header to retrieve
     * @return an {@link Iterator} of header values corresponding to {@code name}.
     */
    public Iterator&lt;V&gt; valueIterator(@SuppressWarnings(&quot;unused&quot;) K name) {
        List&lt;V&gt; empty = Collections.emptyList();
        return empty.iterator();
    }

<A NAME="2"></A>    @Override
    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
        List&lt;Entry&lt;K, V&gt;&gt; empty = Collections.emptyList();
        return <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#2',2,'match378659-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>empty.iterator();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Headers)) {
            return</B></FONT> false;
<A NAME="6"></A>        }

        Headers&lt;?, ?, ?&gt; rhs = (Headers&lt;?, ?, ?&gt;) o;
        <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#6',2,'match378659-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return isEmpty() &amp;&amp; rhs.isEmpty();
    }

<A NAME="4"></A>    @Override
    public int hashCode() {
        return</B></FONT> HASH_CODE_SEED;
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match378659-0.html#4',2,'match378659-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public String toString() {
        return new StringBuilder(getClass().getSimpleName()).append</B></FONT>('[').append(']').toString();
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private T thisT() {
        return (T) this;
    }
}
</PRE>
</div>
  </div>
</body>
</html>
