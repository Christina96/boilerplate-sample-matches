<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for DefaultChannelGroup.java &amp; EmptyHeaders.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DefaultChannelGroup.java &amp; EmptyHeaders.java
      </h3>
<h1 align="center">
        9.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DefaultChannelGroup.java (10.775862%)<th>EmptyHeaders.java (9.282178%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(284-294)<td><a href="#" name="0">(48-58)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(437-445)<td><a href="#" name="1">(304-312)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(123-129)<td><a href="#" name="2">(499-505)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(99-106)<td><a href="#" name="3">(294-301)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(457-461)<td><a href="#" name="4">(515-519)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(377-382)<td><a href="#" name="5">(28-33)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(118-123)<td><a href="#" name="6">(509-514)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultChannelGroup.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright 2013 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.channel.group;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufHolder;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelId;
import io.netty.channel.ServerChannel;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.StringUtil;

import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The default {@link ChannelGroup} implementation.
 */
public class DefaultChannelGroup extends AbstractSet&lt;Channel&gt; implements ChannelGroup {

    private static final AtomicInteger nextId = new AtomicInteger();
    private final String name;
    private final EventExecutor executor;
    private final ConcurrentMap&lt;ChannelId, Channel&gt; serverChannels = PlatformDependent.newConcurrentHashMap();
    private final ConcurrentMap&lt;ChannelId, Channel&gt; nonServerChannels = PlatformDependent.newConcurrentHashMap();
    private final ChannelFutureListener remover = new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
            remove(future.channel());
        }
    };
    private final VoidChannelGroupFuture voidFuture = new VoidChannelGroupFuture(this);
    private final boolean stayClosed;
    private volatile boolean closed;

    /**
     * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s.
     */
    public DefaultChannelGroup(EventExecutor executor) {
        this(executor, false);
    }

    /**
     * Creates a new group with the specified {@code name} and {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s.  Please note that different groups can have the same name, which means no
     * duplicate check is done against group names.
     */
    public DefaultChannelGroup(String name, EventExecutor executor) {
        this(name, executor, false);
    }

    /**
     * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s. {@code stayClosed} defines whether or not, this group can be closed
     * more than once. Adding channels to a closed group will immediately close them, too. This makes it
     * easy, to shutdown server and child channels at once.
     */
    public DefaultChannelGroup(EventExecutor executor, boolean stayClosed) {
        this("group-0x" + Integer.toHexString(nextId.incrementAndGet()), executor, stayClosed);
    }

    /**
     * Creates a new group with the specified {@code name} and {@link EventExecutor} to notify the
     * {@link ChannelGroupFuture}s. {@code stayClosed} defines whether or not, this group can be closed
     * more than once. Adding channels to a closed group will immediately close them, too. This makes it
     * easy, to shutdown server and child channels at once. Please note that different groups can have
     * the same name, which means no duplicate check is done against group names.
     */
    public DefaultChannelGroup(String name, EventExecutor executor, boolean stayClosed) {
        ObjectUtil.checkNotNull(name, "name");
<a name="3"></a>        this.name = name;
        this.executor = executor;
        this.stayClosed = stayClosed;
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public String name() {
        return name;
    }

    @</b></font>Override
    public Channel find(ChannelId id) {
        Channel c = nonServerChannels.get(id);
        if (c != null) {
            return c;
        } else {
            return serverChannels.get(id);
        }
    }
<a name="6"></a>
    @Override
    public boolean isEmpty() {
        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return nonServerChannels.isEmpty() &amp;&amp; serverChannels.isEmpty();
    }
<a name="2"></a>
    @Override
    public int size() {
        return</b></font> nonServerChannels.size() + <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>serverChannels.size();
    }

    @Override
    public boolean contains(Object o) {
        if (o instanceof ServerChannel) {
            return</b></font> serverChannels.containsValue(o);
        } else if (o instanceof Channel) {
            return nonServerChannels.containsValue(o);
        }
        return false;
    }

    @Override
    public boolean add(Channel channel) {
        ConcurrentMap&lt;ChannelId, Channel&gt; map =
            channel instanceof ServerChannel? serverChannels : nonServerChannels;

        boolean added = map.putIfAbsent(channel.id(), channel) == null;
        if (added) {
            channel.closeFuture().addListener(remover);
        }

        if (stayClosed &amp;&amp; closed) {

            // First add channel, than check if closed.
            // Seems inefficient at first, but this way a volatile
            // gives us enough synchronization to be thread-safe.
            //
            // If true: Close right away.
            // (Might be closed a second time by ChannelGroup.close(), but this is ok)
            //
            // If false: Channel will definitely be closed by the ChannelGroup.
            // (Because closed=true always happens-before ChannelGroup.close())
            //
            // See https://github.com/netty/netty/issues/4020
            channel.close();
        }

        return added;
    }

    @Override
    public boolean remove(Object o) {
        Channel c = null;
        if (o instanceof ChannelId) {
            c = nonServerChannels.remove(o);
            if (c == null) {
                c = serverChannels.remove(o);
            }
        } else if (o instanceof Channel) {
            c = (Channel) o;
            if (c instanceof ServerChannel) {
                c = serverChannels.remove(c.id());
            } else {
                c = nonServerChannels.remove(c.id());
            }
        }

        if (c == null) {
            return false;
        }

        c.closeFuture().removeListener(remover);
        return true;
    }

    @Override
    public void clear() {
        nonServerChannels.clear();
        serverChannels.clear();
    }

    @Override
    public Iterator&lt;Channel&gt; iterator() {
        return new CombinedIterator&lt;Channel&gt;(
                serverChannels.values().iterator(),
                nonServerChannels.values().iterator());
    }

    @Override
    public Object[] toArray() {
        Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
        channels.addAll(serverChannels.values());
        channels.addAll(nonServerChannels.values());
        return channels.toArray();
    }

    @Override
    public &lt;T&gt; T[] toArray(T[] a) {
        Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
        channels.addAll(serverChannels.values());
        channels.addAll(nonServerChannels.values());
        return channels.toArray(a);
    }

    @Override
    public ChannelGroupFuture close() {
        return close(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture disconnect() {
        return disconnect(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture deregister() {
        return deregister(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture write(Object message) {
        return write(message, ChannelMatchers.all());
    }

    // Create a safe duplicate of the message to write it to a channel but not affect other writes.
    // See https://github.com/netty/netty/issues/1461
    private static Object safeDuplicate(Object message) {
        if (message instanceof ByteBuf) {
            return ((ByteBuf) message).retainedDuplicate();
        } else if (message instanceof ByteBufHolder) {
            return ((ByteBufHolder) message).retainedDuplicate();
        } else {
            return ReferenceCountUtil.retain(message);
        }
    }

    @Override
    public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
        return write(message, matcher, false);
    }

    @Override
    public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise) {
        ObjectUtil.checkNotNull(message, "message");
        ObjectUtil.checkNotNull(matcher, "matcher");

        final ChannelGroupFuture future;
        if (voidPromise) {
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    c.write(safeDuplicate(message), c.voidPromise());
                }
            }
            future = voidFuture;
        } else {
            Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    futures.put(c, c.write(safeDuplicate(message)));
                }
            }
            future = new DefaultChannelGroupFuture(this, futures, executor);
        }
        ReferenceCountUtil.release(message);
        return future;
    }
<a name="0"></a>
    @Override
    public ChannelGroup flush() {
        return flush(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture flushAndWrite(Object message) {
        return writeAndFlush(message);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message) {
        return</b></font> writeAndFlush(message, ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture disconnect(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, "matcher");

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.disconnect());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.disconnect());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroupFuture close(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, "matcher");

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        if (stayClosed) {
            // It is important to set the closed to true, before closing channels.
            // Our invariants are:
            // closed=true happens-before ChannelGroup.close()
            // ChannelGroup.add() happens-before checking closed==true
            //
            // See https://github.com/netty/netty/issues/4020
            closed = true;
        }

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.close());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.close());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroupFuture deregister(ChannelMatcher matcher) {
        ObjectUtil.checkNotNull(matcher, "matcher");

        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.deregister());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.deregister());
            }
        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    }

    @Override
    public ChannelGroup flush(ChannelMatcher matcher) {
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
<a name="5"></a>                c.flush();
            }
        }
        <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
    }

    @Override
    public ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher) {
        return</b></font> writeAndFlush(message, matcher);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher) {
        return writeAndFlush(message, matcher, false);
    }

    @Override
    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise) {
        ObjectUtil.checkNotNull(message, "message");

        final ChannelGroupFuture future;
        if (voidPromise) {
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    c.writeAndFlush(safeDuplicate(message), c.voidPromise());
                }
            }
            future = voidFuture;
        } else {
            Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
            for (Channel c: nonServerChannels.values()) {
                if (matcher.matches(c)) {
                    futures.put(c, c.writeAndFlush(safeDuplicate(message)));
                }
            }
            future = new DefaultChannelGroupFuture(this, futures, executor);
        }
        ReferenceCountUtil.release(message);
        return future;
    }

    @Override
    public ChannelGroupFuture newCloseFuture() {
        return newCloseFuture(ChannelMatchers.all());
    }

    @Override
    public ChannelGroupFuture newCloseFuture(ChannelMatcher matcher) {
        Map&lt;Channel, ChannelFuture&gt; futures =
                new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());

        for (Channel c: serverChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.closeFuture());
            }
        }
        for (Channel c: nonServerChannels.values()) {
            if (matcher.matches(c)) {
                futures.put(c, c.closeFuture());
            }
<a name="1"></a>        }

        return new DefaultChannelGroupFuture(this, futures, executor);
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public int hashCode() {
        return System.identityHashCode(this);
    }

    @Override
    public boolean equals(Object o</b></font>) {
        return this == o;
    }

    @Override
    public int compareTo(ChannelGroup o) {
        int v = name().compareTo(o.name());
        if (v != 0) {
            return v;
<a name="4"></a>        }

        return System.identityHashCode(this) - System.identityHashCode(o);
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public String toString() {
        return StringUtil.simpleClassName(this) + "(name: " + name() + ", size: " + size</b></font>() + ')';
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>EmptyHeaders.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package io.netty.handler.codec;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import static io.netty.handler.codec.DefaultHeaders.HASH_CODE_SEED;

<a name="5"></a>public class EmptyHeaders&lt;K, V, T extends Headers&lt;K, V, T&gt;&gt; implements Headers&lt;K, V, T&gt; {
    @Override
    public V get(K name) {
        <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return null;
    }

    @Override
    public V get(K name, V defaultValue) {
        return</b></font> defaultValue;
    }

    @Override
    public V getAndRemove(K name) {
        return null;
    }

    @Override
    public V getAndRemove(K name, V defaultValue) {
        return defaultValue;
    }
<a name="0"></a>
    @Override
    public List&lt;V&gt; getAll(K name) {
        return <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Collections.emptyList();
    }

    @Override
    public List&lt;V&gt; getAllAndRemove(K name) {
        return Collections.emptyList();
    }

    @Override
    public Boolean getBoolean(K name) {
        return</b></font> null;
    }

    @Override
    public boolean getBoolean(K name, boolean defaultValue) {
        return defaultValue;
    }

    @Override
    public Byte getByte(K name) {
        return null;
    }

    @Override
    public byte getByte(K name, byte defaultValue) {
        return defaultValue;
    }

    @Override
    public Character getChar(K name) {
        return null;
    }

    @Override
    public char getChar(K name, char defaultValue) {
        return defaultValue;
    }

    @Override
    public Short getShort(K name) {
        return null;
    }

    @Override
    public short getShort(K name, short defaultValue) {
        return defaultValue;
    }

    @Override
    public Integer getInt(K name) {
        return null;
    }

    @Override
    public int getInt(K name, int defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getLong(K name) {
        return null;
    }

    @Override
    public long getLong(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Float getFloat(K name) {
        return null;
    }

    @Override
    public float getFloat(K name, float defaultValue) {
        return defaultValue;
    }

    @Override
    public Double getDouble(K name) {
        return null;
    }

    @Override
    public double getDouble(K name, double defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getTimeMillis(K name) {
        return null;
    }

    @Override
    public long getTimeMillis(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Boolean getBooleanAndRemove(K name) {
        return null;
    }

    @Override
    public boolean getBooleanAndRemove(K name, boolean defaultValue) {
        return defaultValue;
    }

    @Override
    public Byte getByteAndRemove(K name) {
        return null;
    }

    @Override
    public byte getByteAndRemove(K name, byte defaultValue) {
        return defaultValue;
    }

    @Override
    public Character getCharAndRemove(K name) {
        return null;
    }

    @Override
    public char getCharAndRemove(K name, char defaultValue) {
        return defaultValue;
    }

    @Override
    public Short getShortAndRemove(K name) {
        return null;
    }

    @Override
    public short getShortAndRemove(K name, short defaultValue) {
        return defaultValue;
    }

    @Override
    public Integer getIntAndRemove(K name) {
        return null;
    }

    @Override
    public int getIntAndRemove(K name, int defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getLongAndRemove(K name) {
        return null;
    }

    @Override
    public long getLongAndRemove(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public Float getFloatAndRemove(K name) {
        return null;
    }

    @Override
    public float getFloatAndRemove(K name, float defaultValue) {
        return defaultValue;
    }

    @Override
    public Double getDoubleAndRemove(K name) {
        return null;
    }

    @Override
    public double getDoubleAndRemove(K name, double defaultValue) {
        return defaultValue;
    }

    @Override
    public Long getTimeMillisAndRemove(K name) {
        return null;
    }

    @Override
    public long getTimeMillisAndRemove(K name, long defaultValue) {
        return defaultValue;
    }

    @Override
    public boolean contains(K name) {
        return false;
    }

    @Override
    public boolean contains(K name, V value) {
        return false;
    }

    @Override
    public boolean containsObject(K name, Object value) {
        return false;
    }

    @Override
    public boolean containsBoolean(K name, boolean value) {
        return false;
    }

    @Override
    public boolean containsByte(K name, byte value) {
        return false;
    }

    @Override
    public boolean containsChar(K name, char value) {
        return false;
    }

    @Override
    public boolean containsShort(K name, short value) {
        return false;
    }

    @Override
    public boolean containsInt(K name, int value) {
        return false;
    }

    @Override
    public boolean containsLong(K name, long value) {
        return false;
    }

    @Override
    public boolean containsFloat(K name, float value) {
        return false;
    }

    @Override
    public boolean containsDouble(K name, double value) {
        return false;
    }

<a name="3"></a>    @Override
    public boolean containsTimeMillis(K name, long value) {
        return false;
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public int size() {
        return 0;
    }

<a name="1"></a>    @</b></font>Override
    public boolean isEmpty() {
        return true;
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public Set&lt;K&gt; names() {
        return Collections.emptySet();
    }

    @Override
    public T add(K name</b></font>, V value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T add(K name, Iterable&lt;? extends V&gt; values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T add(K name, V... values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addObject(K name, Object value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addObject(K name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addObject(K name, Object... values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addBoolean(K name, boolean value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addByte(K name, byte value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addChar(K name, char value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addShort(K name, short value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addInt(K name, int value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addLong(K name, long value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addFloat(K name, float value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addDouble(K name, double value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T addTimeMillis(K name, long value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T add(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T set(K name, V value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T set(K name, Iterable&lt;? extends V&gt; values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T set(K name, V... values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setObject(K name, Object value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setObject(K name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setObject(K name, Object... values) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setBoolean(K name, boolean value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setByte(K name, byte value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setChar(K name, char value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setShort(K name, short value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setInt(K name, int value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setLong(K name, long value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setFloat(K name, float value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setDouble(K name, double value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setTimeMillis(K name, long value) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T set(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public T setAll(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        throw new UnsupportedOperationException("read only");
    }

    @Override
    public boolean remove(K name) {
        return false;
    }

    @Override
    public T clear() {
        return thisT();
    }

    /**
     * Equivalent to {@link #getAll(Object)} but no intermediate list is generated.
     * @param name the name of the header to retrieve
     * @return an {@link Iterator} of header values corresponding to {@code name}.
     */
    public Iterator&lt;V&gt; valueIterator(@SuppressWarnings("unused") K name) {
        List&lt;V&gt; empty = Collections.emptyList();
        return empty.iterator();
    }

<a name="2"></a>    @Override
    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
        List&lt;Entry&lt;K, V&gt;&gt; empty = Collections.emptyList();
        return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>empty.iterator();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Headers)) {
            return</b></font> false;
<a name="6"></a>        }

        Headers&lt;?, ?, ?&gt; rhs = (Headers&lt;?, ?, ?&gt;) o;
        <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return isEmpty() &amp;&amp; rhs.isEmpty();
    }

<a name="4"></a>    @Override
    public int hashCode() {
        return</b></font> HASH_CODE_SEED;
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public String toString() {
        return new StringBuilder(getClass().getSimpleName()).append</b></font>('[').append(']').toString();
    }

    @SuppressWarnings("unchecked")
    private T thisT() {
        return (T) this;
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
