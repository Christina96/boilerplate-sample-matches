<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for DefaultChannelGroup.java &amp; EmptyHeaders.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DefaultChannelGroup.java &amp; EmptyHeaders.java
      </h3>
<h1 align="center">
        9.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DefaultChannelGroup.java (10.775862%)<th>EmptyHeaders.java (9.282178%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(284-294)<td><a href="#" name="0">(48-58)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(437-445)<td><a href="#" name="1">(304-312)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(123-129)<td><a href="#" name="2">(499-505)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(99-106)<td><a href="#" name="3">(294-301)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(457-461)<td><a href="#" name="4">(515-519)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(377-382)<td><a href="#" name="5">(28-33)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(118-123)<td><a href="#" name="6">(509-514)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultChannelGroup.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.channel.group;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.ByteBufHolder;
4 import io.netty.channel.Channel;
5 import io.netty.channel.ChannelFuture;
6 import io.netty.channel.ChannelFutureListener;
7 import io.netty.channel.ChannelId;
8 import io.netty.channel.ServerChannel;
9 import io.netty.util.ReferenceCountUtil;
10 import io.netty.util.concurrent.EventExecutor;
11 import io.netty.util.internal.ObjectUtil;
12 import io.netty.util.internal.PlatformDependent;
13 import io.netty.util.internal.StringUtil;
14 import java.util.AbstractSet;
15 import java.util.ArrayList;
16 import java.util.Collection;
17 import java.util.Iterator;
18 import java.util.LinkedHashMap;
19 import java.util.Map;
20 import java.util.concurrent.ConcurrentMap;
21 import java.util.concurrent.atomic.AtomicInteger;
22 public class DefaultChannelGroup extends AbstractSet&lt;Channel&gt; implements ChannelGroup {
23     private static final AtomicInteger nextId = new AtomicInteger();
24     private final String name;
25     private final EventExecutor executor;
26     private final ConcurrentMap&lt;ChannelId, Channel&gt; serverChannels = PlatformDependent.newConcurrentHashMap();
27     private final ConcurrentMap&lt;ChannelId, Channel&gt; nonServerChannels = PlatformDependent.newConcurrentHashMap();
28     private final ChannelFutureListener remover = new ChannelFutureListener() {
29         @Override
30         public void operationComplete(ChannelFuture future) throws Exception {
31             remove(future.channel());
32         }
33     };
34     private final VoidChannelGroupFuture voidFuture = new VoidChannelGroupFuture(this);
35     private final boolean stayClosed;
36     private volatile boolean closed;
37     public DefaultChannelGroup(EventExecutor executor) {
38         this(executor, false);
39     }
40     public DefaultChannelGroup(String name, EventExecutor executor) {
41         this(name, executor, false);
42     }
43     public DefaultChannelGroup(EventExecutor executor, boolean stayClosed) {
44         this("group-0x" + Integer.toHexString(nextId.incrementAndGet()), executor, stayClosed);
45     }
46     public DefaultChannelGroup(String name, EventExecutor executor, boolean stayClosed) {
47         ObjectUtil.checkNotNull(name, "name");
48 <a name="3"></a>        this.name = name;
49         this.executor = executor;
50         this.stayClosed = stayClosed;
51     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
52     @Override
53     public String name() {
54         return name;
55     }
56     @</b></font>Override
57     public Channel find(ChannelId id) {
58         Channel c = nonServerChannels.get(id);
59         if (c != null) {
60             return c;
61         } else {
62             return serverChannels.get(id);
63         }
64     }
65 <a name="6"></a>
66     @Override
67     public boolean isEmpty() {
68         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return nonServerChannels.isEmpty() &amp;&amp; serverChannels.isEmpty();
69     }
70 <a name="2"></a>
71     @Override
72     public int size() {
73         return</b></font> nonServerChannels.size() + <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>serverChannels.size();
74     }
75     @Override
76     public boolean contains(Object o) {
77         if (o instanceof ServerChannel) {
78             return</b></font> serverChannels.containsValue(o);
79         } else if (o instanceof Channel) {
80             return nonServerChannels.containsValue(o);
81         }
82         return false;
83     }
84     @Override
85     public boolean add(Channel channel) {
86         ConcurrentMap&lt;ChannelId, Channel&gt; map =
87             channel instanceof ServerChannel? serverChannels : nonServerChannels;
88         boolean added = map.putIfAbsent(channel.id(), channel) == null;
89         if (added) {
90             channel.closeFuture().addListener(remover);
91         }
92         if (stayClosed &amp;&amp; closed) {
93             //
94             //
95             //
96             channel.close();
97         }
98         return added;
99     }
100     @Override
101     public boolean remove(Object o) {
102         Channel c = null;
103         if (o instanceof ChannelId) {
104             c = nonServerChannels.remove(o);
105             if (c == null) {
106                 c = serverChannels.remove(o);
107             }
108         } else if (o instanceof Channel) {
109             c = (Channel) o;
110             if (c instanceof ServerChannel) {
111                 c = serverChannels.remove(c.id());
112             } else {
113                 c = nonServerChannels.remove(c.id());
114             }
115         }
116         if (c == null) {
117             return false;
118         }
119         c.closeFuture().removeListener(remover);
120         return true;
121     }
122     @Override
123     public void clear() {
124         nonServerChannels.clear();
125         serverChannels.clear();
126     }
127     @Override
128     public Iterator&lt;Channel&gt; iterator() {
129         return new CombinedIterator&lt;Channel&gt;(
130                 serverChannels.values().iterator(),
131                 nonServerChannels.values().iterator());
132     }
133     @Override
134     public Object[] toArray() {
135         Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
136         channels.addAll(serverChannels.values());
137         channels.addAll(nonServerChannels.values());
138         return channels.toArray();
139     }
140     @Override
141     public &lt;T&gt; T[] toArray(T[] a) {
142         Collection&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;(size());
143         channels.addAll(serverChannels.values());
144         channels.addAll(nonServerChannels.values());
145         return channels.toArray(a);
146     }
147     @Override
148     public ChannelGroupFuture close() {
149         return close(ChannelMatchers.all());
150     }
151     @Override
152     public ChannelGroupFuture disconnect() {
153         return disconnect(ChannelMatchers.all());
154     }
155     @Override
156     public ChannelGroupFuture deregister() {
157         return deregister(ChannelMatchers.all());
158     }
159     @Override
160     public ChannelGroupFuture write(Object message) {
161         return write(message, ChannelMatchers.all());
162     }
163     private static Object safeDuplicate(Object message) {
164         if (message instanceof ByteBuf) {
165             return ((ByteBuf) message).retainedDuplicate();
166         } else if (message instanceof ByteBufHolder) {
167             return ((ByteBufHolder) message).retainedDuplicate();
168         } else {
169             return ReferenceCountUtil.retain(message);
170         }
171     }
172     @Override
173     public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
174         return write(message, matcher, false);
175     }
176     @Override
177     public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise) {
178         ObjectUtil.checkNotNull(message, "message");
179         ObjectUtil.checkNotNull(matcher, "matcher");
180         final ChannelGroupFuture future;
181         if (voidPromise) {
182             for (Channel c: nonServerChannels.values()) {
183                 if (matcher.matches(c)) {
184                     c.write(safeDuplicate(message), c.voidPromise());
185                 }
186             }
187             future = voidFuture;
188         } else {
189             Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
190             for (Channel c: nonServerChannels.values()) {
191                 if (matcher.matches(c)) {
192                     futures.put(c, c.write(safeDuplicate(message)));
193                 }
194             }
195             future = new DefaultChannelGroupFuture(this, futures, executor);
196         }
197         ReferenceCountUtil.release(message);
198         return future;
199     }
200 <a name="0"></a>
201     @Override
202     public ChannelGroup flush() {
203         return flush(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ChannelMatchers.all());
204     }
205     @Override
206     public ChannelGroupFuture flushAndWrite(Object message) {
207         return writeAndFlush(message);
208     }
209     @Override
210     public ChannelGroupFuture writeAndFlush(Object message) {
211         return</b></font> writeAndFlush(message, ChannelMatchers.all());
212     }
213     @Override
214     public ChannelGroupFuture disconnect(ChannelMatcher matcher) {
215         ObjectUtil.checkNotNull(matcher, "matcher");
216         Map&lt;Channel, ChannelFuture&gt; futures =
217                 new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());
218         for (Channel c: serverChannels.values()) {
219             if (matcher.matches(c)) {
220                 futures.put(c, c.disconnect());
221             }
222         }
223         for (Channel c: nonServerChannels.values()) {
224             if (matcher.matches(c)) {
225                 futures.put(c, c.disconnect());
226             }
227         }
228         return new DefaultChannelGroupFuture(this, futures, executor);
229     }
230     @Override
231     public ChannelGroupFuture close(ChannelMatcher matcher) {
232         ObjectUtil.checkNotNull(matcher, "matcher");
233         Map&lt;Channel, ChannelFuture&gt; futures =
234                 new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());
235         if (stayClosed) {
236             //
237             closed = true;
238         }
239         for (Channel c: serverChannels.values()) {
240             if (matcher.matches(c)) {
241                 futures.put(c, c.close());
242             }
243         }
244         for (Channel c: nonServerChannels.values()) {
245             if (matcher.matches(c)) {
246                 futures.put(c, c.close());
247             }
248         }
249         return new DefaultChannelGroupFuture(this, futures, executor);
250     }
251     @Override
252     public ChannelGroupFuture deregister(ChannelMatcher matcher) {
253         ObjectUtil.checkNotNull(matcher, "matcher");
254         Map&lt;Channel, ChannelFuture&gt; futures =
255                 new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());
256         for (Channel c: serverChannels.values()) {
257             if (matcher.matches(c)) {
258                 futures.put(c, c.deregister());
259             }
260         }
261         for (Channel c: nonServerChannels.values()) {
262             if (matcher.matches(c)) {
263                 futures.put(c, c.deregister());
264             }
265         }
266         return new DefaultChannelGroupFuture(this, futures, executor);
267     }
268     @Override
269     public ChannelGroup flush(ChannelMatcher matcher) {
270         for (Channel c: nonServerChannels.values()) {
271             if (matcher.matches(c)) {
272 <a name="5"></a>                c.flush();
273             }
274         }
275         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
276     }
277     @Override
278     public ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher) {
279         return</b></font> writeAndFlush(message, matcher);
280     }
281     @Override
282     public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher) {
283         return writeAndFlush(message, matcher, false);
284     }
285     @Override
286     public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise) {
287         ObjectUtil.checkNotNull(message, "message");
288         final ChannelGroupFuture future;
289         if (voidPromise) {
290             for (Channel c: nonServerChannels.values()) {
291                 if (matcher.matches(c)) {
292                     c.writeAndFlush(safeDuplicate(message), c.voidPromise());
293                 }
294             }
295             future = voidFuture;
296         } else {
297             Map&lt;Channel, ChannelFuture&gt; futures = new LinkedHashMap&lt;Channel, ChannelFuture&gt;(nonServerChannels.size());
298             for (Channel c: nonServerChannels.values()) {
299                 if (matcher.matches(c)) {
300                     futures.put(c, c.writeAndFlush(safeDuplicate(message)));
301                 }
302             }
303             future = new DefaultChannelGroupFuture(this, futures, executor);
304         }
305         ReferenceCountUtil.release(message);
306         return future;
307     }
308     @Override
309     public ChannelGroupFuture newCloseFuture() {
310         return newCloseFuture(ChannelMatchers.all());
311     }
312     @Override
313     public ChannelGroupFuture newCloseFuture(ChannelMatcher matcher) {
314         Map&lt;Channel, ChannelFuture&gt; futures =
315                 new LinkedHashMap&lt;Channel, ChannelFuture&gt;(size());
316         for (Channel c: serverChannels.values()) {
317             if (matcher.matches(c)) {
318                 futures.put(c, c.closeFuture());
319             }
320         }
321         for (Channel c: nonServerChannels.values()) {
322             if (matcher.matches(c)) {
323                 futures.put(c, c.closeFuture());
324             }
325 <a name="1"></a>        }
326         return new DefaultChannelGroupFuture(this, futures, executor);
327     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
328     @Override
329     public int hashCode() {
330         return System.identityHashCode(this);
331     }
332     @Override
333     public boolean equals(Object o</b></font>) {
334         return this == o;
335     }
336     @Override
337     public int compareTo(ChannelGroup o) {
338         int v = name().compareTo(o.name());
339         if (v != 0) {
340             return v;
341 <a name="4"></a>        }
342         return System.identityHashCode(this) - System.identityHashCode(o);
343     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
344     @Override
345     public String toString() {
346         return StringUtil.simpleClassName(this) + "(name: " + name() + ", size: " + size</b></font>() + ')';
347     }
348 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>EmptyHeaders.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec;
2 import java.util.Collections;
3 import java.util.Iterator;
4 import java.util.List;
5 import java.util.Map.Entry;
6 import java.util.Set;
7 import static io.netty.handler.codec.DefaultHeaders.HASH_CODE_SEED;
8 <a name="5"></a>public class EmptyHeaders&lt;K, V, T extends Headers&lt;K, V, T&gt;&gt; implements Headers&lt;K, V, T&gt; {
9     @Override
10     public V get(K name) {
11         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return null;
12     }
13     @Override
14     public V get(K name, V defaultValue) {
15         return</b></font> defaultValue;
16     }
17     @Override
18     public V getAndRemove(K name) {
19         return null;
20     }
21     @Override
22     public V getAndRemove(K name, V defaultValue) {
23         return defaultValue;
24     }
25 <a name="0"></a>
26     @Override
27     public List&lt;V&gt; getAll(K name) {
28         return <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Collections.emptyList();
29     }
30     @Override
31     public List&lt;V&gt; getAllAndRemove(K name) {
32         return Collections.emptyList();
33     }
34     @Override
35     public Boolean getBoolean(K name) {
36         return</b></font> null;
37     }
38     @Override
39     public boolean getBoolean(K name, boolean defaultValue) {
40         return defaultValue;
41     }
42     @Override
43     public Byte getByte(K name) {
44         return null;
45     }
46     @Override
47     public byte getByte(K name, byte defaultValue) {
48         return defaultValue;
49     }
50     @Override
51     public Character getChar(K name) {
52         return null;
53     }
54     @Override
55     public char getChar(K name, char defaultValue) {
56         return defaultValue;
57     }
58     @Override
59     public Short getShort(K name) {
60         return null;
61     }
62     @Override
63     public short getShort(K name, short defaultValue) {
64         return defaultValue;
65     }
66     @Override
67     public Integer getInt(K name) {
68         return null;
69     }
70     @Override
71     public int getInt(K name, int defaultValue) {
72         return defaultValue;
73     }
74     @Override
75     public Long getLong(K name) {
76         return null;
77     }
78     @Override
79     public long getLong(K name, long defaultValue) {
80         return defaultValue;
81     }
82     @Override
83     public Float getFloat(K name) {
84         return null;
85     }
86     @Override
87     public float getFloat(K name, float defaultValue) {
88         return defaultValue;
89     }
90     @Override
91     public Double getDouble(K name) {
92         return null;
93     }
94     @Override
95     public double getDouble(K name, double defaultValue) {
96         return defaultValue;
97     }
98     @Override
99     public Long getTimeMillis(K name) {
100         return null;
101     }
102     @Override
103     public long getTimeMillis(K name, long defaultValue) {
104         return defaultValue;
105     }
106     @Override
107     public Boolean getBooleanAndRemove(K name) {
108         return null;
109     }
110     @Override
111     public boolean getBooleanAndRemove(K name, boolean defaultValue) {
112         return defaultValue;
113     }
114     @Override
115     public Byte getByteAndRemove(K name) {
116         return null;
117     }
118     @Override
119     public byte getByteAndRemove(K name, byte defaultValue) {
120         return defaultValue;
121     }
122     @Override
123     public Character getCharAndRemove(K name) {
124         return null;
125     }
126     @Override
127     public char getCharAndRemove(K name, char defaultValue) {
128         return defaultValue;
129     }
130     @Override
131     public Short getShortAndRemove(K name) {
132         return null;
133     }
134     @Override
135     public short getShortAndRemove(K name, short defaultValue) {
136         return defaultValue;
137     }
138     @Override
139     public Integer getIntAndRemove(K name) {
140         return null;
141     }
142     @Override
143     public int getIntAndRemove(K name, int defaultValue) {
144         return defaultValue;
145     }
146     @Override
147     public Long getLongAndRemove(K name) {
148         return null;
149     }
150     @Override
151     public long getLongAndRemove(K name, long defaultValue) {
152         return defaultValue;
153     }
154     @Override
155     public Float getFloatAndRemove(K name) {
156         return null;
157     }
158     @Override
159     public float getFloatAndRemove(K name, float defaultValue) {
160         return defaultValue;
161     }
162     @Override
163     public Double getDoubleAndRemove(K name) {
164         return null;
165     }
166     @Override
167     public double getDoubleAndRemove(K name, double defaultValue) {
168         return defaultValue;
169     }
170     @Override
171     public Long getTimeMillisAndRemove(K name) {
172         return null;
173     }
174     @Override
175     public long getTimeMillisAndRemove(K name, long defaultValue) {
176         return defaultValue;
177     }
178     @Override
179     public boolean contains(K name) {
180         return false;
181     }
182     @Override
183     public boolean contains(K name, V value) {
184         return false;
185     }
186     @Override
187     public boolean containsObject(K name, Object value) {
188         return false;
189     }
190     @Override
191     public boolean containsBoolean(K name, boolean value) {
192         return false;
193     }
194     @Override
195     public boolean containsByte(K name, byte value) {
196         return false;
197     }
198     @Override
199     public boolean containsChar(K name, char value) {
200         return false;
201     }
202     @Override
203     public boolean containsShort(K name, short value) {
204         return false;
205     }
206     @Override
207     public boolean containsInt(K name, int value) {
208         return false;
209     }
210     @Override
211     public boolean containsLong(K name, long value) {
212         return false;
213     }
214     @Override
215     public boolean containsFloat(K name, float value) {
216         return false;
217     }
218     @Override
219     public boolean containsDouble(K name, double value) {
220         return false;
221     }
222 <a name="3"></a>    @Override
223     public boolean containsTimeMillis(K name, long value) {
224         return false;
225     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
226     @Override
227     public int size() {
228         return 0;
229     }
230 <a name="1"></a>    @</b></font>Override
231     public boolean isEmpty() {
232         return true;
233     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
234     @Override
235     public Set&lt;K&gt; names() {
236         return Collections.emptySet();
237     }
238     @Override
239     public T add(K name</b></font>, V value) {
240         throw new UnsupportedOperationException("read only");
241     }
242     @Override
243     public T add(K name, Iterable&lt;? extends V&gt; values) {
244         throw new UnsupportedOperationException("read only");
245     }
246     @Override
247     public T add(K name, V... values) {
248         throw new UnsupportedOperationException("read only");
249     }
250     @Override
251     public T addObject(K name, Object value) {
252         throw new UnsupportedOperationException("read only");
253     }
254     @Override
255     public T addObject(K name, Iterable&lt;?&gt; values) {
256         throw new UnsupportedOperationException("read only");
257     }
258     @Override
259     public T addObject(K name, Object... values) {
260         throw new UnsupportedOperationException("read only");
261     }
262     @Override
263     public T addBoolean(K name, boolean value) {
264         throw new UnsupportedOperationException("read only");
265     }
266     @Override
267     public T addByte(K name, byte value) {
268         throw new UnsupportedOperationException("read only");
269     }
270     @Override
271     public T addChar(K name, char value) {
272         throw new UnsupportedOperationException("read only");
273     }
274     @Override
275     public T addShort(K name, short value) {
276         throw new UnsupportedOperationException("read only");
277     }
278     @Override
279     public T addInt(K name, int value) {
280         throw new UnsupportedOperationException("read only");
281     }
282     @Override
283     public T addLong(K name, long value) {
284         throw new UnsupportedOperationException("read only");
285     }
286     @Override
287     public T addFloat(K name, float value) {
288         throw new UnsupportedOperationException("read only");
289     }
290     @Override
291     public T addDouble(K name, double value) {
292         throw new UnsupportedOperationException("read only");
293     }
294     @Override
295     public T addTimeMillis(K name, long value) {
296         throw new UnsupportedOperationException("read only");
297     }
298     @Override
299     public T add(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
300         throw new UnsupportedOperationException("read only");
301     }
302     @Override
303     public T set(K name, V value) {
304         throw new UnsupportedOperationException("read only");
305     }
306     @Override
307     public T set(K name, Iterable&lt;? extends V&gt; values) {
308         throw new UnsupportedOperationException("read only");
309     }
310     @Override
311     public T set(K name, V... values) {
312         throw new UnsupportedOperationException("read only");
313     }
314     @Override
315     public T setObject(K name, Object value) {
316         throw new UnsupportedOperationException("read only");
317     }
318     @Override
319     public T setObject(K name, Iterable&lt;?&gt; values) {
320         throw new UnsupportedOperationException("read only");
321     }
322     @Override
323     public T setObject(K name, Object... values) {
324         throw new UnsupportedOperationException("read only");
325     }
326     @Override
327     public T setBoolean(K name, boolean value) {
328         throw new UnsupportedOperationException("read only");
329     }
330     @Override
331     public T setByte(K name, byte value) {
332         throw new UnsupportedOperationException("read only");
333     }
334     @Override
335     public T setChar(K name, char value) {
336         throw new UnsupportedOperationException("read only");
337     }
338     @Override
339     public T setShort(K name, short value) {
340         throw new UnsupportedOperationException("read only");
341     }
342     @Override
343     public T setInt(K name, int value) {
344         throw new UnsupportedOperationException("read only");
345     }
346     @Override
347     public T setLong(K name, long value) {
348         throw new UnsupportedOperationException("read only");
349     }
350     @Override
351     public T setFloat(K name, float value) {
352         throw new UnsupportedOperationException("read only");
353     }
354     @Override
355     public T setDouble(K name, double value) {
356         throw new UnsupportedOperationException("read only");
357     }
358     @Override
359     public T setTimeMillis(K name, long value) {
360         throw new UnsupportedOperationException("read only");
361     }
362     @Override
363     public T set(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
364         throw new UnsupportedOperationException("read only");
365     }
366     @Override
367     public T setAll(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
368         throw new UnsupportedOperationException("read only");
369     }
370     @Override
371     public boolean remove(K name) {
372         return false;
373     }
374     @Override
375     public T clear() {
376         return thisT();
377     }
378     public Iterator&lt;V&gt; valueIterator(@SuppressWarnings("unused") K name) {
379         List&lt;V&gt; empty = Collections.emptyList();
380         return empty.iterator();
381     }
382 <a name="2"></a>    @Override
383     public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
384         List&lt;Entry&lt;K, V&gt;&gt; empty = Collections.emptyList();
385         return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>empty.iterator();
386     }
387     @Override
388     public boolean equals(Object o) {
389         if (!(o instanceof Headers)) {
390             return</b></font> false;
391 <a name="6"></a>        }
392         Headers&lt;?, ?, ?&gt; rhs = (Headers&lt;?, ?, ?&gt;) o;
393         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return isEmpty() &amp;&amp; rhs.isEmpty();
394     }
395 <a name="4"></a>    @Override
396     public int hashCode() {
397         return</b></font> HASH_CODE_SEED;
398     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
399     @Override
400     public String toString() {
401         return new StringBuilder(getClass().getSimpleName()).append</b></font>('[').append(']').toString();
402     }
403     @SuppressWarnings("unchecked")
404     private T thisT() {
405         return (T) this;
406     }
407 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
