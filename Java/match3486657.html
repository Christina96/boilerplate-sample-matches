<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ArithmeticFunctions.java & TestSqlParser.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ArithmeticFunctions.java & TestSqlParser.java
      </h3>
      <h1 align="center">
        5.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ArithmeticFunctions.java (11.299435%)<TH>TestSqlParser.java (4.056795%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3486657-0.html#0',2,'match3486657-1.html#0',3)" NAME="0">(22-34)<TD><A HREF="javascript:ZweiFrames('match3486657-0.html#0',2,'match3486657-1.html#0',3)" NAME="0">(22-33)</A><TD ALIGN=center><FONT COLOR="#ff0000">11</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match3486657-0.html#1',2,'match3486657-1.html#1',3)" NAME="1">(127-133)<TD><A HREF="javascript:ZweiFrames('match3486657-0.html#1',2,'match3486657-1.html#1',3)" NAME="1">(454-458)</A><TD ALIGN=center><FONT COLOR="#d00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ArithmeticFunctions.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3486657-1.html#0',3,'match3486657-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.expression.scalar.arithmetic;

import io.crate.expression.scalar.ScalarFunctionModule;
import io.crate.metadata.Scalar;
import io.crate.metadata.functions.Signature;
import io.crate.types.DataTypes;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import</B></FONT> java.util.function.BinaryOperator;

public class ArithmeticFunctions {

    public static class Names {
        public static final String ADD = &quot;add&quot;;
        public static final String SUBTRACT = &quot;subtract&quot;;
        public static final String MULTIPLY = &quot;multiply&quot;;
        public static final String DIVIDE = &quot;divide&quot;;
        public static final String POWER = &quot;power&quot;;
        public static final String MODULUS = &quot;modulus&quot;;
        public static final String MOD = &quot;mod&quot;;
    }

    private enum Operations {
        ADD(
            Scalar.DETERMINISTIC_AND_COMPARISON_REPLACEMENT,
            Math::addExact,
            Double::sum,
            Math::addExact,
            Float::sum,
            BigDecimal::add
        ),
        SUBTRACT(
            Scalar.DETERMINISTIC_ONLY,
            Math::subtractExact,
                (arg0, arg1) -&gt; arg0 - arg1,
            Math::subtractExact,
                (arg0, arg1) -&gt; arg0 - arg1,
            BigDecimal::subtract
        ),
        MULTIPLY(
            Scalar.DETERMINISTIC_ONLY,
            Math::multiplyExact,
                (arg0, arg1) -&gt; arg0 * arg1,
            Math::multiplyExact,
                (arg0, arg1) -&gt; arg0 * arg1,
            BigDecimal::multiply
        ),
        DIVIDE(
            Scalar.DETERMINISTIC_ONLY,
                (arg0, arg1) -&gt; arg0 / arg1,
                (arg0, arg1) -&gt; arg0 / arg1,
                (arg0, arg1) -&gt; arg0 / arg1,
                (arg0, arg1) -&gt; arg0 / arg1,
                (arg0, arg1) -&gt; arg0.divide(arg1, MathContext.DECIMAL64)
        ),
        MODULUS(
            Scalar.DETERMINISTIC_ONLY,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
            BigDecimal::remainder
        ),
        MOD(
            Scalar.DETERMINISTIC_ONLY,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
                (arg0, arg1) -&gt; arg0 % arg1,
            BigDecimal::remainder
        );

        private final Set&lt;Scalar.Feature&gt; features;

        private final BinaryOperator&lt;Integer&gt; integerFunction;
        private final BinaryOperator&lt;Double&gt; doubleFunction;
        private final BinaryOperator&lt;Long&gt; longFunction;
        private final BinaryOperator&lt;Float&gt; floatFunction;
        private final BinaryOperator&lt;BigDecimal&gt; bdFunction;

        Operations(Set&lt;Scalar.Feature&gt; features,
                   BinaryOperator&lt;Integer&gt; integerFunction,
                   BinaryOperator&lt;Double&gt; doubleFunction,
                   BinaryOperator&lt;Long&gt; longFunction,
                   BinaryOperator&lt;Float&gt; floatFunction,
                   BinaryOperator&lt;BigDecimal&gt; bdFunction) {
            this.features = features;
            this.doubleFunction = doubleFunction;
            this.integerFunction = integerFunction;
            this.longFunction = longFunction;
            this.floatFunction = floatFunction;
            this.bdFunction = bdFunction;
        }

        @Override
        public String toString() {
            return name().toLowerCase(Locale.ENGLISH);
        }
<A NAME="1"></A>    }

    public static void register(ScalarFunctionModule module) {
        for (var op : <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match3486657-1.html#1',3,'match3486657-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Operations.values()) {
            module.register(
                Signature.scalar(
                    op.toString(),
                    DataTypes.INTEGER.getTypeSignature(),
                    DataTypes.INTEGER.getTypeSignature(),
                    DataTypes.INTEGER.getTypeSignature</B></FONT>()
                ).withFeatures(op.features),
                (signature, boundSignature) -&gt;
                    new BinaryScalar&lt;&gt;(op.integerFunction, signature, boundSignature, DataTypes.INTEGER)
            );
            for (var type : List.of(DataTypes.LONG, DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ)) {
                module.register(
                    Signature.scalar(
                        op.toString(),
                        type.getTypeSignature(),
                        type.getTypeSignature(),
                        type.getTypeSignature()
                    ).withFeatures(op.features),
                    (signature, boundSignature) -&gt;
                        new BinaryScalar&lt;&gt;(op.longFunction, signature, boundSignature, type)
                );
            }
            module.register(
                Signature.scalar(
                    op.toString(),
                    DataTypes.FLOAT.getTypeSignature(),
                    DataTypes.FLOAT.getTypeSignature(),
                    DataTypes.FLOAT.getTypeSignature()
                ).withFeatures(op.features),
                (signature, boundSignature) -&gt;
                    new BinaryScalar&lt;&gt;(op.floatFunction, signature, boundSignature, DataTypes.FLOAT)
            );
            module.register(
                Signature.scalar(
                    op.toString(),
                    DataTypes.DOUBLE.getTypeSignature(),
                    DataTypes.DOUBLE.getTypeSignature(),
                    DataTypes.DOUBLE.getTypeSignature()
                ).withFeatures(op.features),
                (signature, boundSignature) -&gt;
                    new BinaryScalar&lt;&gt;(op.doubleFunction, signature, boundSignature, DataTypes.DOUBLE)
            );
            module.register(
                Signature.scalar(
                    op.toString(),
                    DataTypes.NUMERIC.getTypeSignature(),
                    DataTypes.NUMERIC.getTypeSignature(),
                    DataTypes.NUMERIC.getTypeSignature()
                ).withFeatures(op.features),
                (signature, boundSignature) -&gt;
                    new BinaryScalar&lt;&gt;(op.bdFunction, signature, boundSignature, DataTypes.NUMERIC)
            );
        }

        module.register(
            Signature.scalar(
                Names.POWER,
                DataTypes.DOUBLE.getTypeSignature(),
                DataTypes.DOUBLE.getTypeSignature(),
                DataTypes.DOUBLE.getTypeSignature()
            ).withFeatures(Scalar.DETERMINISTIC_ONLY),
            (signature, boundSignature) -&gt;
                new BinaryScalar&lt;&gt;(Math::pow, signature, boundSignature, DataTypes.DOUBLE)
        );
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestSqlParser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3486657-0.html#0',2,'match3486657-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.sql.parser;

import io.crate.common.collections.Lists2;
import io.crate.sql.tree.Cast;
import io.crate.sql.tree.ColumnType;
import io.crate.sql.tree.CreateTable;
import io.crate.sql.tree.CurrentTime;
import io.crate.sql.tree.DoubleLiteral;
import io.crate.sql.tree.Expression;
import io.crate.sql.tree.FunctionCall;
import io.crate.sql.tree.Node;
import</B></FONT> io.crate.sql.tree.ParameterExpression;
import io.crate.sql.tree.QualifiedName;
import io.crate.sql.tree.QualifiedNameReference;
import io.crate.sql.tree.Query;
import io.crate.sql.tree.QuerySpecification;
import io.crate.sql.tree.Statement;
import io.crate.sql.tree.StringLiteral;
import org.junit.Test;

import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;

import static io.crate.sql.SqlFormatter.formatSql;
import static io.crate.sql.tree.QueryUtil.selectList;
import static io.crate.sql.tree.QueryUtil.table;
import static java.lang.String.format;
import static java.util.Collections.nCopies;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;
import static org.hamcrest.core.IsInstanceOf.instanceOf;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TestSqlParser {

    @Test
    public void testComments() {
        assertThat(
            SqlParser.createStatement(&quot;-- this is a line comment\nSelect 1&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;Select 1\n-- this is a line comment&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;-- this is a line comment\nSelect 1\n-- this is a line comment&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;-- this is a line comment\nSelect \n-- this is a line comment\n1&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;/* this\n&quot; +
                                  &quot;       is a multiline\n&quot; +
                                  &quot;       comment\n&quot; +
                                  &quot;    */\nSelect 1;&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;Select 1;&quot; +
                                  &quot;    /* this\n&quot; +
                                  &quot;       is a multiline\n&quot; +
                                  &quot;       comment\n&quot; +
                                  &quot;    */&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;Select&quot; +
                                             &quot;    /* this\n&quot; +
                                             &quot;       is a multiline\n&quot; +
                                             &quot;       comment\n&quot; +
                                             &quot;    */&quot; +
                                             &quot;1&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;Select&quot; +
                                      &quot;    /* this\n&quot; +
                                      &quot;       is a multiline\n&quot; +
                                      &quot;       comment\n&quot; +
                                      &quot;    */\n&quot; +
                                      &quot;-- line comment\n&quot; +
                                      &quot;1&quot;),
            instanceOf(Query.class));
        assertThat(
            SqlParser.createStatement(&quot;CREATE TABLE IF NOT EXISTS \&quot;doc\&quot;.\&quot;data\&quot; (\n&quot; +
                                      &quot;   \&quot;week__generated\&quot; TIMESTAMP GENERATED ALWAYS AS date_trunc('week', \&quot;ts\&quot;),\n&quot; +
                                      &quot;   \&quot;mid\&quot; STRING, -- measurement id, mainly used for triggers, starts for continuuous measurment with random uuid\n&quot; +
                                      &quot;   \&quot;res\&quot; INTEGER, -- resolution in ms\n&quot; +
                                      &quot;   \&quot;ts\&quot; TIMESTAMP,\n&quot; +
                                      &quot;   \&quot;val_avg\&quot; FLOAT,\n&quot; +
                                      &quot;   \&quot;val_max\&quot; FLOAT,\n&quot; +
                                      &quot;   \&quot;val_min\&quot; FLOAT,\n&quot; +
                                      &quot;   \&quot;val_stddev\&quot; FLOAT,\n&quot; +
                                      &quot;   \&quot;vid\&quot; STRING, -- variable id, unique uuid\n&quot; +
                                      &quot;   PRIMARY KEY (\&quot;ts\&quot;, \&quot;mid\&quot;, \&quot;vid\&quot;, \&quot;res\&quot;, \&quot;week__generated\&quot;)\n&quot; +
                                      &quot;)\n&quot; +
                                      &quot;CLUSTERED INTO 3 SHARDS\n&quot; +
                                      &quot;PARTITIONED BY (\&quot;res\&quot;, \&quot;week__generated\&quot;)\n&quot; +
                                      &quot;WITH (\n&quot; +
                                      &quot;   number_of_replicas = '1'\n&quot; +
                                      &quot;);&quot;),
                instanceOf(CreateTable.class));
    }

    @Test
    public void testPossibleExponentialBacktracking()
        throws Exception {
        SqlParser.createExpression(&quot;(((((((((((((((((((((((((((true)))))))))))))))))))))))))))&quot;);
    }

    @Test
    public void testDouble()
        throws Exception {
        assertExpression(&quot;123.&quot;, new DoubleLiteral(&quot;123&quot;));
        assertExpression(&quot;123.0&quot;, new DoubleLiteral(&quot;123&quot;));
        assertExpression(&quot;.5&quot;, new DoubleLiteral(&quot;.5&quot;));
        assertExpression(&quot;123.5&quot;, new DoubleLiteral(&quot;123.5&quot;));

        assertExpression(&quot;123E7&quot;, new DoubleLiteral(&quot;123E7&quot;));
        assertExpression(&quot;123.E7&quot;, new DoubleLiteral(&quot;123E7&quot;));
        assertExpression(&quot;123.0E7&quot;, new DoubleLiteral(&quot;123E7&quot;));
        assertExpression(&quot;123E+7&quot;, new DoubleLiteral(&quot;123E7&quot;));
        assertExpression(&quot;123E-7&quot;, new DoubleLiteral(&quot;123E-7&quot;));

        assertExpression(&quot;123.456E7&quot;, new DoubleLiteral(&quot;123.456E7&quot;));
        assertExpression(&quot;123.456E+7&quot;, new DoubleLiteral(&quot;123.456E7&quot;));
        assertExpression(&quot;123.456E-7&quot;, new DoubleLiteral(&quot;123.456E-7&quot;));

        assertExpression(&quot;.4E42&quot;, new DoubleLiteral(&quot;.4E42&quot;));
        assertExpression(&quot;.4E+42&quot;, new DoubleLiteral(&quot;.4E42&quot;));
        assertExpression(&quot;.4E-42&quot;, new DoubleLiteral(&quot;.4E-42&quot;));
    }

    @Test
    public void testParameter() throws Exception {
        assertExpression(&quot;?&quot;, new ParameterExpression(1));
        for (int i = 0; i &lt; 1000; i++) {
            assertExpression(String.format(Locale.ENGLISH, &quot;$%d&quot;, i), new ParameterExpression(i));
        }
    }

    @Test
    public void testDoubleInQuery() {
        assertStatement(&quot;SELECT 123.456E7 FROM DUAL&quot;,
            new Query(
                new QuerySpecification(
                    selectList(new DoubleLiteral(&quot;123.456E7&quot;)),
                    table(QualifiedName.of(&quot;dual&quot;)),
                    Optional.empty(),
                    List.of(),
                    Optional.empty(),
                    Map.of(),
                    List.of(),
                    Optional.empty(),
                    Optional.empty()),
                List.of(),
                Optional.empty(),
                Optional.empty())
        );
    }

    @Test
    public void testEmptyExpression() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createExpression(&quot;&quot;),
                     &quot;line 1:1: mismatched input '&lt;EOF&gt;'&quot;);
    }

    @Test
    public void testEmptyStatement() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;&quot;),
                     &quot;line 1:1: mismatched input '&lt;EOF&gt;'&quot;);
    }

    @Test
    public void testExpressionWithTrailingJunk() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;1 + 1 x&quot;),
                     &quot;line 1:7: extraneous input 'x' expecting&quot;);
    }

    @Test
    public void testTokenizeErrorStartOfLine() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;@select&quot;),
                     &quot;line 1:1: extraneous input '@' expecting&quot;);
    }

    @Test
    public void testTokenizeErrorMiddleOfLine() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from foo where @what&quot;),
                     &quot;line 1:25: no viable alternative at input 'select * from foo where @'&quot;);
    }

    @Test
    public void testTokenizeErrorIncompleteToken() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from 'oops&quot;),
                     &quot;line 1:15: no viable alternative at input 'select * from ''&quot;);
    }

    @Test
    public void testParseErrorStartOfLine() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select *\nfrom x\nfrom&quot;),
                     &quot;line 3:1: extraneous input 'from' expecting&quot;);
    }

    @Test
    public void testParseErrorMiddleOfLine() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select *\nfrom x\nwhere from&quot;),
                     &quot;line 3:7: no viable alternative at input 'select *\\nfrom x\\nwhere from'&quot;);
    }

    @Test
    public void testParseErrorEndOfInput() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from&quot;),
                     &quot;line 1:14: no viable alternative at input 'select * from'&quot;);
    }

    @Test
    public void testParseErrorEndOfInputWhitespace() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from  &quot;),
                     &quot;line 1:16: no viable alternative at input 'select * from  '&quot;);
    }

    @Test
    public void testParseErrorBackquotes() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from `foo`&quot;),
                     &quot;line 1:15: backquoted identifiers are not supported; use double quotes to quote identifiers&quot;);
    }

    @Test
    public void testParseErrorBackquotesEndOfInput() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from foo `bar`&quot;),
                     &quot;line 1:19: backquoted identifiers are not supported; use double quotes to quote identifiers&quot;);
    }

    @Test
    public void testParseErrorDigitIdentifiers() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select 1x from dual&quot;),
                     &quot;line 1:8: identifiers must not start with a digit; surround the identifier with double quotes&quot;);
    }

    @Test
    public void testIdentifierWithColon() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select * from foo:bar&quot;),
                     &quot;line 1:15: identifiers must not contain ':'&quot;);
    }

    @Test
    public void testParseErrorDualOrderBy() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select fuu from dual order by fuu order by fuu&quot;),
                     &quot;line 1:35: mismatched input 'order'&quot;);
    }

    @Test
    public void testParseErrorReverseOrderByLimit() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select fuu from dual limit 10 order by fuu&quot;),
                     &quot;line 1:31: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}&quot;);
    }

    @Test
    public void testParseErrorReverseOrderByLimitOffset() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select fuu from dual limit 10 offset 20 order by fuu&quot;),
                     &quot;line 1:41: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}&quot;);
    }

    @Test
    public void testParseErrorReverseOrderByOffset() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select fuu from dual offset 20 order by fuu&quot;),
                     &quot;line 1:32: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}&quot;);
    }

    @Test
    public void testParseErrorReverseLimitOffset() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;select fuu from dual offset 20 order by fuu&quot;),
                     &quot;line 1:32: mismatched input 'limit' expecting {&lt;EOF&gt;, ';'}&quot;);
    }

    @Test
    public void testParsingExceptionPositionInfo() {
        try {
            SqlParser.createStatement(&quot;select *\nfrom x\nwhere from&quot;);
            fail(&quot;expected exception&quot;);
        } catch (ParsingException e) {
            assertEquals(e.getMessage(), &quot;line 3:7: no viable alternative at input 'select *\\nfrom x\\nwhere from'&quot;);
            assertEquals(e.getErrorMessage(), &quot;no viable alternative at input 'select *\\nfrom x\\nwhere from'&quot;);
            assertEquals(e.getLineNumber(), 3);
            assertEquals(e.getColumnNumber(), 7);
        }
    }

    @Test
    public void testCurrentTimestamp() {
        assertExpression(&quot;CURRENT_TIMESTAMP&quot;, new CurrentTime(CurrentTime.Type.TIMESTAMP));
    }

    @Test
    public void testCurrentSchemaFunction() {
        assertInstanceOf(&quot;CURRENT_SCHEMA&quot;, FunctionCall.class);
        assertInstanceOf(&quot;CURRENT_SCHEMA()&quot;, FunctionCall.class);
    }

    @Test
    public void testUserFunctions() {
        assertInstanceOf(&quot;CURRENT_USER&quot;, FunctionCall.class);
        assertInstanceOf(&quot;SESSION_USER&quot;, FunctionCall.class);
        assertInstanceOf(&quot;USER&quot;, FunctionCall.class);
    }

    @Test
    public void testTrimFunctionExpression() {
        assertExpression(&quot;TRIM(BOTH 'A' FROM chars)&quot;,
            new FunctionCall(new QualifiedName(&quot;trim&quot;), List.of(
                new QualifiedNameReference(new QualifiedName(&quot;chars&quot;)),
                new StringLiteral(&quot;A&quot;),
                new StringLiteral(&quot;BOTH&quot;)
            ))
        );
    }

    @Test
    public void testTrimFunctionExpressionSingleArgument() {
        assertExpression(&quot;TRIM(chars)&quot;,
            new FunctionCall(new QualifiedName(&quot;trim&quot;), List.of(
                new QualifiedNameReference(new QualifiedName(&quot;chars&quot;))
            ))
        );
    }

    @Test
    public void testTrimFunctionAllArgs() {
        assertInstanceOf(&quot;TRIM(LEADING 'A' FROM chars)&quot;, FunctionCall.class);
        assertInstanceOf(&quot;TRIM(TRAILING 'A' FROM chars)&quot;, FunctionCall.class);
        assertInstanceOf(&quot;TRIM(BOTH 'A' FROM chars)&quot;, FunctionCall.class);
    }

    @Test
    public void testTrimFunctionDefaultTrimModeOnly() {
        assertInstanceOf(&quot;TRIM('A' FROM chars)&quot;, FunctionCall.class);
    }

    @Test
    public void testTrimFunctionDefaultCharsToTrimOnly() {
        assertInstanceOf(&quot;TRIM(LEADING FROM chars)&quot;, FunctionCall.class);
        assertInstanceOf(&quot;TRIM(TRAILING FROM chars)&quot;, FunctionCall.class);
        assertInstanceOf(&quot;TRIM(BOTH FROM chars)&quot;, FunctionCall.class);
        assertInstanceOf(&quot;TRIM(FROM chars)&quot;, FunctionCall.class);
    }

    @Test
    public void testTrimFunctionDefaultTrimModeAndCharsToTrim() {
        assertInstanceOf(&quot;TRIM(chars)&quot;, FunctionCall.class);
    }

    @Test
    public void testTrimFunctionMissingFromWhenCharsToTrimIsPresentThrowsException() {
        assertThrows(ParsingException.class,
                     () -&gt; assertInstanceOf(&quot;TRIM(' ' chars)&quot;, FunctionCall.class),
                     &quot;line 1:10: no viable alternative at input 'TRIM(' ' chars'&quot;);
    }

    private void assertInstanceOf(String expr, Class&lt;? extends Node&gt; cls) {
        Expression expression = SqlParser.createExpression(expr);
        assertThat(expression, instanceOf(cls));
    }

    @Test
    public void testStackOverflowExpression() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createExpression(Lists2.joinOn(&quot; OR &quot;, nCopies(4000, &quot;x = y&quot;), x -&gt; x)),
                     &quot;line 1:1: expression is too large (stack overflow while parsing)&quot;);
    }

    @Test
    public void testStackOverflowStatement() {
        assertThrows(ParsingException.class,
                     () -&gt; SqlParser.createStatement(&quot;SELECT &quot; + Lists2.joinOn(&quot; OR &quot;, nCopies(4000, &quot;x = y&quot;), x -&gt; x)),
                     &quot;line 1:1: statement is too large (stack overflow while parsing)&quot;);
    }

    @Test
    public void testDataTypesWithWhitespaceCharacters() {
        Cast cast = (Cast) SqlParser.createExpression(&quot;1::double precision&quot;);
        assertThat(cast.getType().getClass(), is(ColumnType.class));
        assertThat(cast.getType().name(), is(&quot;double precision&quot;));
    }

    @Test
    public void testFromStringLiteralCast() {
        assertInstanceOf(&quot;TIMESTAMP '2016-12-31 01:02:03.123'&quot;, Cast.class);
        assertInstanceOf(&quot;int2 '2016'&quot;, Cast.class);
    }

    @Test
    public void testFromStringLiteralCastDoesNotSupportArrayType() {
        assertThrows(UnsupportedOperationException.class,
                     () -&gt; SqlParser.createExpression(&quot;array(boolean) '[1,2,0]'&quot;),
                     &quot;type 'string' cast notation only supports primitive types. Use '::' or cast() operator instead.&quot;);
    }

    @Test
    public void testFromStringLiteralCastDoesNotSupportObjectType() {
        assertThrows(UnsupportedOperationException.class,
                     () -&gt; SqlParser.createExpression(&quot;object '{\&quot;x\&quot;: 10}'&quot;),
                     &quot;type 'string' cast notation only supports primitive types. Use '::' or cast() operator instead.&quot;);
    }

    private static void assertStatement(String query, Statement expected) {
        assertParsed(query, expected, SqlParser.createStatement(query));
    }

    private static void assertExpression(String expression, Expression expected) {
        assertParsed(expression, expected, SqlParser.createExpression(expression));
<A NAME="1"></A>    }

    private static void assertParsed(String input, Node expected, Node parsed) {
        if (!<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3486657-0.html#1',2,'match3486657-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>parsed.equals(expected)) {
            fail(format(&quot;expected%n%n%s%n%nto parse as%n%n%s%n%nbut was%n%n%s%n&quot;,
                indent(input),
                indent(formatSql(expected)),
                indent(formatSql</B></FONT>(parsed))));
        }
    }

    private static String indent(String value) {
        String indent = &quot;    &quot;;
        return indent + value.trim().replaceAll(&quot;\n&quot;, &quot;\n&quot; + indent);
    }
}
</PRE>
</div>
  </div>
</body>
</html>
