<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ArithmeticFunctions.java &amp; TestSqlParser.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ArithmeticFunctions.java &amp; TestSqlParser.java
      </h3>
<h1 align="center">
        5.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ArithmeticFunctions.java (11.299435%)<th>TestSqlParser.java (4.056795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-34)<td><a href="#" name="0">(22-33)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(127-133)<td><a href="#" name="1">(454-458)</a><td align="center"><font color="#d00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ArithmeticFunctions.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.expression.scalar.arithmetic;
2 import io.crate.expression.scalar.ScalarFunctionModule;
3 import io.crate.metadata.Scalar;
4 import io.crate.metadata.functions.Signature;
5 import io.crate.types.DataTypes;
6 import java.math.BigDecimal;
7 import java.math.MathContext;
8 import java.util.List;
9 import java.util.Locale;
10 import java.util.Set;
11 import</b></font> java.util.function.BinaryOperator;
12 public class ArithmeticFunctions {
13     public static class Names {
14         public static final String ADD = "add";
15         public static final String SUBTRACT = "subtract";
16         public static final String MULTIPLY = "multiply";
17         public static final String DIVIDE = "divide";
18         public static final String POWER = "power";
19         public static final String MODULUS = "modulus";
20         public static final String MOD = "mod";
21     }
22     private enum Operations {
23         ADD(
24             Scalar.DETERMINISTIC_AND_COMPARISON_REPLACEMENT,
25             Math::addExact,
26             Double::sum,
27             Math::addExact,
28             Float::sum,
29             BigDecimal::add
30         ),
31         SUBTRACT(
32             Scalar.DETERMINISTIC_ONLY,
33             Math::subtractExact,
34                 (arg0, arg1) -&gt; arg0 - arg1,
35             Math::subtractExact,
36                 (arg0, arg1) -&gt; arg0 - arg1,
37             BigDecimal::subtract
38         ),
39         MULTIPLY(
40             Scalar.DETERMINISTIC_ONLY,
41             Math::multiplyExact,
42                 (arg0, arg1) -&gt; arg0 * arg1,
43             Math::multiplyExact,
44                 (arg0, arg1) -&gt; arg0 * arg1,
45             BigDecimal::multiply
46         ),
47         DIVIDE(
48             Scalar.DETERMINISTIC_ONLY,
49                 (arg0, arg1) -&gt; arg0 / arg1,
50                 (arg0, arg1) -&gt; arg0 / arg1,
51                 (arg0, arg1) -&gt; arg0 / arg1,
52                 (arg0, arg1) -&gt; arg0 / arg1,
53                 (arg0, arg1) -&gt; arg0.divide(arg1, MathContext.DECIMAL64)
54         ),
55         MODULUS(
56             Scalar.DETERMINISTIC_ONLY,
57                 (arg0, arg1) -&gt; arg0 % arg1,
58                 (arg0, arg1) -&gt; arg0 % arg1,
59                 (arg0, arg1) -&gt; arg0 % arg1,
60                 (arg0, arg1) -&gt; arg0 % arg1,
61             BigDecimal::remainder
62         ),
63         MOD(
64             Scalar.DETERMINISTIC_ONLY,
65                 (arg0, arg1) -&gt; arg0 % arg1,
66                 (arg0, arg1) -&gt; arg0 % arg1,
67                 (arg0, arg1) -&gt; arg0 % arg1,
68                 (arg0, arg1) -&gt; arg0 % arg1,
69             BigDecimal::remainder
70         );
71         private final Set&lt;Scalar.Feature&gt; features;
72         private final BinaryOperator&lt;Integer&gt; integerFunction;
73         private final BinaryOperator&lt;Double&gt; doubleFunction;
74         private final BinaryOperator&lt;Long&gt; longFunction;
75         private final BinaryOperator&lt;Float&gt; floatFunction;
76         private final BinaryOperator&lt;BigDecimal&gt; bdFunction;
77         Operations(Set&lt;Scalar.Feature&gt; features,
78                    BinaryOperator&lt;Integer&gt; integerFunction,
79                    BinaryOperator&lt;Double&gt; doubleFunction,
80                    BinaryOperator&lt;Long&gt; longFunction,
81                    BinaryOperator&lt;Float&gt; floatFunction,
82                    BinaryOperator&lt;BigDecimal&gt; bdFunction) {
83             this.features = features;
84             this.doubleFunction = doubleFunction;
85             this.integerFunction = integerFunction;
86             this.longFunction = longFunction;
87             this.floatFunction = floatFunction;
88             this.bdFunction = bdFunction;
89         }
90         @Override
91         public String toString() {
92             return name().toLowerCase(Locale.ENGLISH);
93         }
94 <a name="1"></a>    }
95     public static void register(ScalarFunctionModule module) {
96         for (var op : <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Operations.values()) {
97             module.register(
98                 Signature.scalar(
99                     op.toString(),
100                     DataTypes.INTEGER.getTypeSignature(),
101                     DataTypes.INTEGER.getTypeSignature(),
102                     DataTypes.INTEGER.getTypeSignature</b></font>()
103                 ).withFeatures(op.features),
104                 (signature, boundSignature) -&gt;
105                     new BinaryScalar&lt;&gt;(op.integerFunction, signature, boundSignature, DataTypes.INTEGER)
106             );
107             for (var type : List.of(DataTypes.LONG, DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ)) {
108                 module.register(
109                     Signature.scalar(
110                         op.toString(),
111                         type.getTypeSignature(),
112                         type.getTypeSignature(),
113                         type.getTypeSignature()
114                     ).withFeatures(op.features),
115                     (signature, boundSignature) -&gt;
116                         new BinaryScalar&lt;&gt;(op.longFunction, signature, boundSignature, type)
117                 );
118             }
119             module.register(
120                 Signature.scalar(
121                     op.toString(),
122                     DataTypes.FLOAT.getTypeSignature(),
123                     DataTypes.FLOAT.getTypeSignature(),
124                     DataTypes.FLOAT.getTypeSignature()
125                 ).withFeatures(op.features),
126                 (signature, boundSignature) -&gt;
127                     new BinaryScalar&lt;&gt;(op.floatFunction, signature, boundSignature, DataTypes.FLOAT)
128             );
129             module.register(
130                 Signature.scalar(
131                     op.toString(),
132                     DataTypes.DOUBLE.getTypeSignature(),
133                     DataTypes.DOUBLE.getTypeSignature(),
134                     DataTypes.DOUBLE.getTypeSignature()
135                 ).withFeatures(op.features),
136                 (signature, boundSignature) -&gt;
137                     new BinaryScalar&lt;&gt;(op.doubleFunction, signature, boundSignature, DataTypes.DOUBLE)
138             );
139             module.register(
140                 Signature.scalar(
141                     op.toString(),
142                     DataTypes.NUMERIC.getTypeSignature(),
143                     DataTypes.NUMERIC.getTypeSignature(),
144                     DataTypes.NUMERIC.getTypeSignature()
145                 ).withFeatures(op.features),
146                 (signature, boundSignature) -&gt;
147                     new BinaryScalar&lt;&gt;(op.bdFunction, signature, boundSignature, DataTypes.NUMERIC)
148             );
149         }
150         module.register(
151             Signature.scalar(
152                 Names.POWER,
153                 DataTypes.DOUBLE.getTypeSignature(),
154                 DataTypes.DOUBLE.getTypeSignature(),
155                 DataTypes.DOUBLE.getTypeSignature()
156             ).withFeatures(Scalar.DETERMINISTIC_ONLY),
157             (signature, boundSignature) -&gt;
158                 new BinaryScalar&lt;&gt;(Math::pow, signature, boundSignature, DataTypes.DOUBLE)
159         );
160     }
161 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestSqlParser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.sql.parser;
2 import io.crate.common.collections.Lists2;
3 import io.crate.sql.tree.Cast;
4 import io.crate.sql.tree.ColumnType;
5 import io.crate.sql.tree.CreateTable;
6 import io.crate.sql.tree.CurrentTime;
7 import io.crate.sql.tree.DoubleLiteral;
8 import io.crate.sql.tree.Expression;
9 import io.crate.sql.tree.FunctionCall;
10 import io.crate.sql.tree.Node;
11 import</b></font> io.crate.sql.tree.ParameterExpression;
12 import io.crate.sql.tree.QualifiedName;
13 import io.crate.sql.tree.QualifiedNameReference;
14 import io.crate.sql.tree.Query;
15 import io.crate.sql.tree.QuerySpecification;
16 import io.crate.sql.tree.Statement;
17 import io.crate.sql.tree.StringLiteral;
18 import org.junit.Test;
19 import java.util.List;
20 import java.util.Locale;
21 import java.util.Map;
22 import java.util.Optional;
23 import static io.crate.sql.SqlFormatter.formatSql;
24 import static io.crate.sql.tree.QueryUtil.selectList;
25 import static io.crate.sql.tree.QueryUtil.table;
26 import static java.lang.String.format;
27 import static java.util.Collections.nCopies;
28 import static org.hamcrest.MatcherAssert.assertThat;
29 import static org.hamcrest.core.Is.is;
30 import static org.hamcrest.core.IsInstanceOf.instanceOf;
31 import static org.junit.Assert.assertEquals;
32 import static org.junit.Assert.fail;
33 import static org.junit.jupiter.api.Assertions.assertThrows;
34 public class TestSqlParser {
35     @Test
36     public void testComments() {
37         assertThat(
38             SqlParser.createStatement("-- this is a line comment\nSelect 1"),
39             instanceOf(Query.class));
40         assertThat(
41             SqlParser.createStatement("Select 1\n-- this is a line comment"),
42             instanceOf(Query.class));
43         assertThat(
44             SqlParser.createStatement("-- this is a line comment\nSelect 1\n-- this is a line comment"),
45             instanceOf(Query.class));
46         assertThat(
47             SqlParser.createStatement("-- this is a line comment\nSelect \n-- this is a line comment\n1"),
48             instanceOf(Query.class));
49         assertThat(
50             instanceOf(Query.class));
51         assertThat(
52             SqlParser.createStatement("Select 1;" +
53             instanceOf(Query.class));
54         assertThat(
55             SqlParser.createStatement("Select" +
56                                              "1"),
57             instanceOf(Query.class));
58         assertThat(
59             SqlParser.createStatement("Select" +
60                                       "-- line comment\n" +
61                                       "1"),
62             instanceOf(Query.class));
63         assertThat(
64             SqlParser.createStatement("CREATE TABLE IF NOT EXISTS \"doc\".\"data\" (\n" +
65                                       "   \"week__generated\" TIMESTAMP GENERATED ALWAYS AS date_trunc('week', \"ts\"),\n" +
66                                       "   \"mid\" STRING, -- measurement id, mainly used for triggers, starts for continuuous measurment with random uuid\n" +
67                                       "   \"res\" INTEGER, -- resolution in ms\n" +
68                                       "   \"ts\" TIMESTAMP,\n" +
69                                       "   \"val_avg\" FLOAT,\n" +
70                                       "   \"val_max\" FLOAT,\n" +
71                                       "   \"val_min\" FLOAT,\n" +
72                                       "   \"val_stddev\" FLOAT,\n" +
73                                       "   \"vid\" STRING, -- variable id, unique uuid\n" +
74                                       "   PRIMARY KEY (\"ts\", \"mid\", \"vid\", \"res\", \"week__generated\")\n" +
75                                       ")\n" +
76                                       "CLUSTERED INTO 3 SHARDS\n" +
77                                       "PARTITIONED BY (\"res\", \"week__generated\")\n" +
78                                       "WITH (\n" +
79                                       "   number_of_replicas = '1'\n" +
80                                       ");"),
81                 instanceOf(CreateTable.class));
82     }
83     @Test
84     public void testPossibleExponentialBacktracking()
85         throws Exception {
86         SqlParser.createExpression("(((((((((((((((((((((((((((true)))))))))))))))))))))))))))");
87     }
88     @Test
89     public void testDouble()
90         throws Exception {
91         assertExpression("123.", new DoubleLiteral("123"));
92         assertExpression("123.0", new DoubleLiteral("123"));
93         assertExpression(".5", new DoubleLiteral(".5"));
94         assertExpression("123.5", new DoubleLiteral("123.5"));
95         assertExpression("123E7", new DoubleLiteral("123E7"));
96         assertExpression("123.E7", new DoubleLiteral("123E7"));
97         assertExpression("123.0E7", new DoubleLiteral("123E7"));
98         assertExpression("123E+7", new DoubleLiteral("123E7"));
99         assertExpression("123E-7", new DoubleLiteral("123E-7"));
100         assertExpression("123.456E7", new DoubleLiteral("123.456E7"));
101         assertExpression("123.456E+7", new DoubleLiteral("123.456E7"));
102         assertExpression("123.456E-7", new DoubleLiteral("123.456E-7"));
103         assertExpression(".4E42", new DoubleLiteral(".4E42"));
104         assertExpression(".4E+42", new DoubleLiteral(".4E42"));
105         assertExpression(".4E-42", new DoubleLiteral(".4E-42"));
106     }
107     @Test
108     public void testParameter() throws Exception {
109         assertExpression("?", new ParameterExpression(1));
110         for (int i = 0; i &lt; 1000; i++) {
111             assertExpression(String.format(Locale.ENGLISH, "$%d", i), new ParameterExpression(i));
112         }
113     }
114     @Test
115     public void testDoubleInQuery() {
116         assertStatement("SELECT 123.456E7 FROM DUAL",
117             new Query(
118                 new QuerySpecification(
119                     selectList(new DoubleLiteral("123.456E7")),
120                     table(QualifiedName.of("dual")),
121                     Optional.empty(),
122                     List.of(),
123                     Optional.empty(),
124                     Map.of(),
125                     List.of(),
126                     Optional.empty(),
127                     Optional.empty()),
128                 List.of(),
129                 Optional.empty(),
130                 Optional.empty())
131         );
132     }
133     @Test
134     public void testEmptyExpression() {
135         assertThrows(ParsingException.class,
136                      () -&gt; SqlParser.createExpression(""),
137                      "line 1:1: mismatched input '&lt;EOF&gt;'");
138     }
139     @Test
140     public void testEmptyStatement() {
141         assertThrows(ParsingException.class,
142                      () -&gt; SqlParser.createStatement(""),
143                      "line 1:1: mismatched input '&lt;EOF&gt;'");
144     }
145     @Test
146     public void testExpressionWithTrailingJunk() {
147         assertThrows(ParsingException.class,
148                      () -&gt; SqlParser.createStatement("1 + 1 x"),
149                      "line 1:7: extraneous input 'x' expecting");
150     }
151     @Test
152     public void testTokenizeErrorStartOfLine() {
153         assertThrows(ParsingException.class,
154                      () -&gt; SqlParser.createStatement("@select"),
155                      "line 1:1: extraneous input '@' expecting");
156     }
157     @Test
158     public void testTokenizeErrorMiddleOfLine() {
159         assertThrows(ParsingException.class,
160                      () -&gt; SqlParser.createStatement("select * from foo where @what"),
161                      "line 1:25: no viable alternative at input 'select * from foo where @'");
162     }
163     @Test
164     public void testTokenizeErrorIncompleteToken() {
165         assertThrows(ParsingException.class,
166                      () -&gt; SqlParser.createStatement("select * from 'oops"),
167                      "line 1:15: no viable alternative at input 'select * from ''");
168     }
169     @Test
170     public void testParseErrorStartOfLine() {
171         assertThrows(ParsingException.class,
172                      () -&gt; SqlParser.createStatement("select *\nfrom x\nfrom"),
173                      "line 3:1: extraneous input 'from' expecting");
174     }
175     @Test
176     public void testParseErrorMiddleOfLine() {
177         assertThrows(ParsingException.class,
178                      () -&gt; SqlParser.createStatement("select *\nfrom x\nwhere from"),
179                      "line 3:7: no viable alternative at input 'select *\\nfrom x\\nwhere from'");
180     }
181     @Test
182     public void testParseErrorEndOfInput() {
183         assertThrows(ParsingException.class,
184                      () -&gt; SqlParser.createStatement("select * from"),
185                      "line 1:14: no viable alternative at input 'select * from'");
186     }
187     @Test
188     public void testParseErrorEndOfInputWhitespace() {
189         assertThrows(ParsingException.class,
190                      () -&gt; SqlParser.createStatement("select * from  "),
191                      "line 1:16: no viable alternative at input 'select * from  '");
192     }
193     @Test
194     public void testParseErrorBackquotes() {
195         assertThrows(ParsingException.class,
196                      () -&gt; SqlParser.createStatement("select * from `foo`"),
197                      "line 1:15: backquoted identifiers are not supported; use double quotes to quote identifiers");
198     }
199     @Test
200     public void testParseErrorBackquotesEndOfInput() {
201         assertThrows(ParsingException.class,
202                      () -&gt; SqlParser.createStatement("select * from foo `bar`"),
203                      "line 1:19: backquoted identifiers are not supported; use double quotes to quote identifiers");
204     }
205     @Test
206     public void testParseErrorDigitIdentifiers() {
207         assertThrows(ParsingException.class,
208                      () -&gt; SqlParser.createStatement("select 1x from dual"),
209                      "line 1:8: identifiers must not start with a digit; surround the identifier with double quotes");
210     }
211     @Test
212     public void testIdentifierWithColon() {
213         assertThrows(ParsingException.class,
214                      () -&gt; SqlParser.createStatement("select * from foo:bar"),
215                      "line 1:15: identifiers must not contain ':'");
216     }
217     @Test
218     public void testParseErrorDualOrderBy() {
219         assertThrows(ParsingException.class,
220                      () -&gt; SqlParser.createStatement("select fuu from dual order by fuu order by fuu"),
221                      "line 1:35: mismatched input 'order'");
222     }
223     @Test
224     public void testParseErrorReverseOrderByLimit() {
225         assertThrows(ParsingException.class,
226                      () -&gt; SqlParser.createStatement("select fuu from dual limit 10 order by fuu"),
227                      "line 1:31: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}");
228     }
229     @Test
230     public void testParseErrorReverseOrderByLimitOffset() {
231         assertThrows(ParsingException.class,
232                      () -&gt; SqlParser.createStatement("select fuu from dual limit 10 offset 20 order by fuu"),
233                      "line 1:41: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}");
234     }
235     @Test
236     public void testParseErrorReverseOrderByOffset() {
237         assertThrows(ParsingException.class,
238                      () -&gt; SqlParser.createStatement("select fuu from dual offset 20 order by fuu"),
239                      "line 1:32: mismatched input 'order' expecting {&lt;EOF&gt;, ';'}");
240     }
241     @Test
242     public void testParseErrorReverseLimitOffset() {
243         assertThrows(ParsingException.class,
244                      () -&gt; SqlParser.createStatement("select fuu from dual offset 20 order by fuu"),
245                      "line 1:32: mismatched input 'limit' expecting {&lt;EOF&gt;, ';'}");
246     }
247     @Test
248     public void testParsingExceptionPositionInfo() {
249         try {
250             SqlParser.createStatement("select *\nfrom x\nwhere from");
251             fail("expected exception");
252         } catch (ParsingException e) {
253             assertEquals(e.getMessage(), "line 3:7: no viable alternative at input 'select *\\nfrom x\\nwhere from'");
254             assertEquals(e.getErrorMessage(), "no viable alternative at input 'select *\\nfrom x\\nwhere from'");
255             assertEquals(e.getLineNumber(), 3);
256             assertEquals(e.getColumnNumber(), 7);
257         }
258     }
259     @Test
260     public void testCurrentTimestamp() {
261         assertExpression("CURRENT_TIMESTAMP", new CurrentTime(CurrentTime.Type.TIMESTAMP));
262     }
263     @Test
264     public void testCurrentSchemaFunction() {
265         assertInstanceOf("CURRENT_SCHEMA", FunctionCall.class);
266         assertInstanceOf("CURRENT_SCHEMA()", FunctionCall.class);
267     }
268     @Test
269     public void testUserFunctions() {
270         assertInstanceOf("CURRENT_USER", FunctionCall.class);
271         assertInstanceOf("SESSION_USER", FunctionCall.class);
272         assertInstanceOf("USER", FunctionCall.class);
273     }
274     @Test
275     public void testTrimFunctionExpression() {
276         assertExpression("TRIM(BOTH 'A' FROM chars)",
277             new FunctionCall(new QualifiedName("trim"), List.of(
278                 new QualifiedNameReference(new QualifiedName("chars")),
279                 new StringLiteral("A"),
280                 new StringLiteral("BOTH")
281             ))
282         );
283     }
284     @Test
285     public void testTrimFunctionExpressionSingleArgument() {
286         assertExpression("TRIM(chars)",
287             new FunctionCall(new QualifiedName("trim"), List.of(
288                 new QualifiedNameReference(new QualifiedName("chars"))
289             ))
290         );
291     }
292     @Test
293     public void testTrimFunctionAllArgs() {
294         assertInstanceOf("TRIM(LEADING 'A' FROM chars)", FunctionCall.class);
295         assertInstanceOf("TRIM(TRAILING 'A' FROM chars)", FunctionCall.class);
296         assertInstanceOf("TRIM(BOTH 'A' FROM chars)", FunctionCall.class);
297     }
298     @Test
299     public void testTrimFunctionDefaultTrimModeOnly() {
300         assertInstanceOf("TRIM('A' FROM chars)", FunctionCall.class);
301     }
302     @Test
303     public void testTrimFunctionDefaultCharsToTrimOnly() {
304         assertInstanceOf("TRIM(LEADING FROM chars)", FunctionCall.class);
305         assertInstanceOf("TRIM(TRAILING FROM chars)", FunctionCall.class);
306         assertInstanceOf("TRIM(BOTH FROM chars)", FunctionCall.class);
307         assertInstanceOf("TRIM(FROM chars)", FunctionCall.class);
308     }
309     @Test
310     public void testTrimFunctionDefaultTrimModeAndCharsToTrim() {
311         assertInstanceOf("TRIM(chars)", FunctionCall.class);
312     }
313     @Test
314     public void testTrimFunctionMissingFromWhenCharsToTrimIsPresentThrowsException() {
315         assertThrows(ParsingException.class,
316                      () -&gt; assertInstanceOf("TRIM(' ' chars)", FunctionCall.class),
317                      "line 1:10: no viable alternative at input 'TRIM(' ' chars'");
318     }
319     private void assertInstanceOf(String expr, Class&lt;? extends Node&gt; cls) {
320         Expression expression = SqlParser.createExpression(expr);
321         assertThat(expression, instanceOf(cls));
322     }
323     @Test
324     public void testStackOverflowExpression() {
325         assertThrows(ParsingException.class,
326                      () -&gt; SqlParser.createExpression(Lists2.joinOn(" OR ", nCopies(4000, "x = y"), x -&gt; x)),
327                      "line 1:1: expression is too large (stack overflow while parsing)");
328     }
329     @Test
330     public void testStackOverflowStatement() {
331         assertThrows(ParsingException.class,
332                      () -&gt; SqlParser.createStatement("SELECT " + Lists2.joinOn(" OR ", nCopies(4000, "x = y"), x -&gt; x)),
333                      "line 1:1: statement is too large (stack overflow while parsing)");
334     }
335     @Test
336     public void testDataTypesWithWhitespaceCharacters() {
337         Cast cast = (Cast) SqlParser.createExpression("1::double precision");
338         assertThat(cast.getType().getClass(), is(ColumnType.class));
339         assertThat(cast.getType().name(), is("double precision"));
340     }
341     @Test
342     public void testFromStringLiteralCast() {
343         assertInstanceOf("TIMESTAMP '2016-12-31 01:02:03.123'", Cast.class);
344         assertInstanceOf("int2 '2016'", Cast.class);
345     }
346     @Test
347     public void testFromStringLiteralCastDoesNotSupportArrayType() {
348         assertThrows(UnsupportedOperationException.class,
349                      () -&gt; SqlParser.createExpression("array(boolean) '[1,2,0]'"),
350                      "type 'string' cast notation only supports primitive types. Use '::' or cast() operator instead.");
351     }
352     @Test
353     public void testFromStringLiteralCastDoesNotSupportObjectType() {
354         assertThrows(UnsupportedOperationException.class,
355                      () -&gt; SqlParser.createExpression("object '{\"x\": 10}'"),
356                      "type 'string' cast notation only supports primitive types. Use '::' or cast() operator instead.");
357     }
358     private static void assertStatement(String query, Statement expected) {
359         assertParsed(query, expected, SqlParser.createStatement(query));
360     }
361     private static void assertExpression(String expression, Expression expected) {
362         assertParsed(expression, expected, SqlParser.createExpression(expression));
363 <a name="1"></a>    }
364     private static void assertParsed(String input, Node expected, Node parsed) {
365         if (!<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>parsed.equals(expected)) {
366             fail(format("expected%n%n%s%n%nto parse as%n%n%s%n%nbut was%n%n%s%n",
367                 indent(input),
368                 indent(formatSql(expected)),
369                 indent(formatSql</b></font>(parsed))));
370         }
371     }
372     private static String indent(String value) {
373         String indent = "    ";
374         return indent + value.trim().replaceAll("\n", "\n" + indent);
375     }
376 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
