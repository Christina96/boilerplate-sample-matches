
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.6920473773265652%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-CFReserveParams.java</h3>
            <pre><code>1  package redis.clients.jedis.bloom;
<span onclick='openModal()' class='match'>2  import static redis.clients.jedis.Protocol.toByteArray;
3  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.BUCKETSIZE;
4  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.EXPANSION;
5  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.MAXITERATIONS;
6  import redis.clients.jedis.CommandArguments;
7  import redis.clients.jedis.params.IParams;
8  public class CFReserveParams implements IParams {
9    private Long bucketSize;
10    private Integer maxIterations;
11    private Integer expansion;
</span>12    public static CFReserveParams reserveParams() {
13      return new CFReserveParams();
14    }
15    public CFReserveParams bucketSize(long bucketSize) {
16      this.bucketSize = bucketSize;
17      return this;
18    }
19    public CFReserveParams maxIterations(int maxIterations) {
20      this.maxIterations = maxIterations;
21      return this;
22    }
23    public CFReserveParams expansion(int expansion) {
24      this.expansion = expansion;
25      return this;
26    }
27    @Override
28    public void addParams(CommandArguments args) {
29      if (bucketSize != null) {
30        args.add(BUCKETSIZE).add(toByteArray(bucketSize));
31      }
32      if (maxIterations != null) {
33        args.add(MAXITERATIONS).add(toByteArray(maxIterations));
34      }
35      if (expansion != null) {
36        args.add(EXPANSION).add(toByteArray(expansion));
37      }
38    }
39  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import static com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout;
3  import static org.junit.Assert.assertEquals;
4  import static org.junit.Assert.assertNotNull;
5  import static org.junit.Assert.assertNull;
6  import static org.junit.Assert.assertTrue;
7  import static org.junit.Assert.fail;
8  import io.netty.buffer.ByteBuf;
9  import io.netty.buffer.ByteBufInputStream;
10  import io.netty.buffer.Unpooled;
11  import io.reactivex.netty.contexts.ContextsContainer;
12  import io.reactivex.netty.contexts.ContextsContainerImpl;
13  import io.reactivex.netty.contexts.MapBackedKeySupplier;
14  import io.reactivex.netty.contexts.RxContexts;
15  import io.reactivex.netty.protocol.http.client.HttpClient.HttpClientConfig;
16  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
17  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
18  import io.reactivex.netty.protocol.text.sse.ServerSentEvent;
19  import io.reactivex.netty.servo.http.HttpClientListener;
20  import java.io.IOException;
21  import java.nio.charset.Charset;
22  import java.util.Iterator;
23  import java.util.List;
24  import java.util.Random;
25  import java.util.concurrent.CountDownLatch;
26  import java.util.concurrent.ExecutorService;
27  import java.util.concurrent.Executors;
28  import java.util.concurrent.atomic.AtomicReference;
29  import org.codehaus.jackson.map.ObjectMapper;
30  import org.junit.BeforeClass;
31  import org.junit.Ignore;
32  import org.junit.Test;
33  import rx.Observable;
34  import rx.functions.Action0;
35  import rx.functions.Action1;
36  import rx.functions.Func0;
37  import rx.functions.Func1;
38  import com.google.common.collect.Lists;
39  import com.google.mockwebserver.MockResponse;
40  import com.google.mockwebserver.MockWebServer;
41  import com.netflix.client.ClientException;
42  import com.netflix.client.RequestSpecificRetryHandler;
43  import com.netflix.client.RetryHandler;
44  import com.netflix.client.config.CommonClientConfigKey;
45  import com.netflix.client.config.DefaultClientConfigImpl;
46  import com.netflix.client.config.IClientConfig;
47  import com.netflix.client.config.IClientConfigKey;
48  import com.netflix.loadbalancer.AvailabilityFilteringRule;
49  import com.netflix.loadbalancer.BaseLoadBalancer;
50  import com.netflix.loadbalancer.DummyPing;
51  import com.netflix.loadbalancer.LoadBalancerBuilder;
52  import com.netflix.loadbalancer.Server;
53  import com.netflix.loadbalancer.ServerStats;
54  import com.netflix.ribbon.test.resources.EmbeddedResources;
55  import com.netflix.ribbon.test.resources.EmbeddedResources.Person;
56  import com.netflix.ribbon.transport.netty.RibbonTransport;
<span onclick='openModal()' class='match'>57  import com.netflix.serialization.JacksonCodec;
58  import com.netflix.serialization.SerializationUtils;
59  import com.netflix.serialization.TypeDef;
60  import com.sun.jersey.api.container.httpserver.HttpServerFactory;
61  import com.sun.jersey.api.core.PackagesResourceConfig;
62  import com.sun.net.httpserver.HttpServer;
63  public class NettyClientTest {
64      private static HttpServer server = null;
65      private static String SERVICE_URI;
66      private static int port;
</span>67      private static final String host = "localhost";
68      static Observable<ServerSentEvent> transformSSE(Observable<HttpClientResponse<ServerSentEvent>> response) {
69          return response.flatMap(new Func1<HttpClientResponse<ServerSentEvent>, Observable<ServerSentEvent>>() {
70              @Override
71              public Observable<ServerSentEvent> call(HttpClientResponse<ServerSentEvent> t1) {
72                  return t1.getContent();
73              }
74          });
75      }
76      @BeforeClass 
77      public static void init() throws Exception {
78          PackagesResourceConfig resourceConfig = new PackagesResourceConfig("com.netflix.ribbon.test.resources");
79          port = (new Random()).nextInt(1000) + 4000;
80          SERVICE_URI = "http:&bsol;&bsol;localhost:" + port + "/";
81          ExecutorService service = Executors.newFixedThreadPool(20);
82          try{
83              server = HttpServerFactory.create(SERVICE_URI, resourceConfig);           
84              server.setExecutor(service);
85              server.start();
86          } catch(Exception e) {
87              e.printStackTrace();
88              fail("Unable to start server");
89          }
90      }
91      private static Observable<Person> getPersonObservable(Observable<HttpClientResponse<ByteBuf>> response) {
92          return response.flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>() {
93              @Override
94              public Observable<ByteBuf> call(HttpClientResponse<ByteBuf> t1) {
95                  return t1.getContent();
96              }
97          }).map(new Func1<ByteBuf, Person>() {
98              @Override
99              public Person call(ByteBuf t1) {
100                  try {
101                      return JacksonCodec.<Person>getInstance().deserialize(new ByteBufInputStream(t1), TypeDef.fromClass(Person.class));
102                  } catch (IOException e) {
103                      e.printStackTrace();
104                      return null;
105                  }
106              }
107          });
108      }
109      @Test
110      public void testObservable() throws Exception {
111          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
112          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
113          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
114          Person person = getPersonObservable(response).toBlocking().single();
115          assertEquals(EmbeddedResources.defaultPerson, person);
116          final HttpClientListener listener = observableClient.getListener();
117          assertEquals(1, listener.getPoolAcquires());
118          assertEquals(1, listener.getConnectionCount());
119          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
120              @Override
121              public Boolean call() {
122                  return listener.getPoolReleases() == 1;
123              }
124          });
125      }
126      @Test
127      public void testSubmitToAbsoluteURI() throws Exception {
128          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
129          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
130          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
131          Person person = getPersonObservable(response).toBlocking().single();
132          assertEquals(EmbeddedResources.defaultPerson, person);
133          final HttpClientListener listener = observableClient.getListener();
134          assertEquals(1, listener.getConnectionCount());
135          assertEquals(1, listener.getPoolAcquires());
136          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
137              @Override
138              public Boolean call() {
139                  return listener.getPoolReleases() == 1;
140              }
141          });
142      }
143      @Test
144      public void testPoolReuse() throws Exception {
145          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
146          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
147                  IClientConfig.Builder.newBuilder().withDefaultValues()
148                  .withMaxAutoRetries(1)
149                  .withMaxAutoRetriesNextServer(1).build());
150          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
151          Person person = getPersonObservable(response).toBlocking().single();
152          assertEquals(EmbeddedResources.defaultPerson, person);
153          response = observableClient.submit(request);
154          person = getPersonObservable(response).toBlocking().single();
155          assertEquals(EmbeddedResources.defaultPerson, person);
156          final HttpClientListener listener = observableClient.getListener();
157          assertEquals(2, listener.getPoolAcquires());
158          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
159              @Override
160              public Boolean call() {
161                  return listener.getPoolReleases() == 2;
162              }
163          });
164          assertEquals(1, listener.getConnectionCount());
165          assertEquals(1, listener.getPoolReuse());
166      }
167      @Test
168      public void testPostWithObservable() throws Exception {
169          Person myPerson = new Person("netty", 5);
170          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost(SERVICE_URI + "testAsync/person")
171                  .withHeader("Content-type", "application/json")
172                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), myPerson, null));
173          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
174                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
175          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(new Server(host, port), request);
176          Person person = getPersonObservable(response).toBlocking().single();
177          assertEquals(myPerson, person);
178      }
179      @Test
180      public void testPostWithByteBuf() throws Exception {
181          Person myPerson = new Person("netty", 5);
182          ObjectMapper mapper = new ObjectMapper();
183          byte[] raw = mapper.writeValueAsBytes(myPerson);
184          ByteBuf buffer = Unpooled.copiedBuffer(raw);
185          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost(SERVICE_URI + "testAsync/person")
186                  .withHeader("Content-type", "application/json")
187                  .withHeader("Content-length", String.valueOf(raw.length))
188                  .withContent(buffer);
189          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
190                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
191          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
192          Person person = getPersonObservable(response).toBlocking().single();
193          assertEquals(myPerson, person);
194      }
195      @Test
196      public void testConnectTimeout() throws Exception {
197          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
198                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1"));
199          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;www.google.com:81/");
200          Observable<HttpClientResponse<ByteBuf>> observable = observableClient.submit(new Server("www.google.com", 81), request);
201          ObserverWithLatch<HttpClientResponse<ByteBuf>> observer = new ObserverWithLatch<HttpClientResponse<ByteBuf>>();
202          observable.subscribe(observer);
203          observer.await();
204          assertNotNull(observer.error);
205          assertTrue(observer.error instanceof io.netty.channel.ConnectTimeoutException);
206      }
207      @Test
208      public void testReadTimeout() throws Exception {
209          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
210                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ReadTimeout, "100"));
211          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/readTimeout");
212          Observable<HttpClientResponse<ByteBuf>> observable = observableClient.submit(request);
213          ObserverWithLatch<HttpClientResponse<ByteBuf>> observer = new ObserverWithLatch<HttpClientResponse<ByteBuf>>();
214          observable.subscribe(observer);
215          observer.await();
216          assertTrue(observer.error instanceof io.netty.handler.timeout.ReadTimeoutException);      
217      }
218      @Test
219      public void testObservableWithMultipleServers() throws Exception {
220          IClientConfig config = DefaultClientConfigImpl
221                  .getClientConfigWithDefaultValues()
222                  .withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
223          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
224          Server badServer = new Server("localhost:12345");
225          Server goodServer = new Server("localhost:" + port);
226          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
227          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
228                  .withRule(new AvailabilityFilteringRule())
229                  .withPing(new DummyPing())
230                  .buildFixedServerListLoadBalancer(servers);
231          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
232                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
233          Person person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
234          assertEquals(EmbeddedResources.defaultPerson, person);
235          ServerStats stats = lbObservables.getServerStats(badServer);
236          assertEquals(4, stats.getTotalRequestsCount());
237          assertEquals(0, stats.getActiveRequestsCount());
238          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
239          stats = lbObservables.getServerStats(goodServer);
240          assertEquals(1, stats.getTotalRequestsCount());
241          assertEquals(0, stats.getActiveRequestsCount());
242          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
243          person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
244          assertEquals(EmbeddedResources.defaultPerson, person);
245          HttpClientListener listener = lbObservables.getListener();
246          assertEquals(1, listener.getPoolReuse());
247      }
248      @Test
249      public void testObservableWithMultipleServersWithOverrideRxConfig() throws Exception {
250          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
251          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
252          Server badServer = new Server("localhost:12345");
253          Server goodServer = new Server("localhost:" + port);
254          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
255          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
256                  .withRule(new AvailabilityFilteringRule())
257                  .withPing(new DummyPing())
258                  .buildFixedServerListLoadBalancer(servers);
259          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
260                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
261          HttpClientConfig rxconfig = HttpClientConfig.Builder.newDefaultConfig();
262          Person person = getPersonObservable(lbObservables.submit(request, rxconfig)).toBlocking().single();
263          assertEquals(EmbeddedResources.defaultPerson, person);
264          ServerStats stats = lbObservables.getServerStats(badServer);
265          assertEquals(4, stats.getTotalRequestsCount());
266          assertEquals(0, stats.getActiveRequestsCount());
267          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
268          stats = lbObservables.getServerStats(goodServer);
269          assertEquals(1, stats.getTotalRequestsCount());
270          assertEquals(0, stats.getActiveRequestsCount());
271          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
272          final HttpClientListener listener = lbObservables.getListener();
273          assertEquals(1, listener.getConnectionCount());
274          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
275              @Override
276              public Boolean call() {
277                  return listener.getPoolReleases() == 1;
278              }
279          });
280      }
281      @Test
282      public void testObservableWithRetrySameServer() throws Exception {
283          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
284          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
285          Server badServer = new Server("localhost:12345");
286          Server goodServer = new Server("localhost:" + port);
287          List<Server> servers = Lists.newArrayList(badServer, badServer, goodServer);
288          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
289                  .withRule(new AvailabilityFilteringRule())
290                  .withPing(new DummyPing())
291                  .buildFixedServerListLoadBalancer(servers);
292          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
293                  new NettyHttpLoadBalancerErrorHandler(1, 0, true));
294          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
295          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
296          observableWithRetries.subscribe(observer);
297          observer.await();
298          assertNull(observer.obj);
299          assertTrue(observer.error instanceof ClientException);
300          ServerStats stats = lbObservables.getServerStats(badServer);
301          assertEquals(2, stats.getTotalRequestsCount());
302          assertEquals(0, stats.getActiveRequestsCount());
303          stats = lbObservables.getServerStats(goodServer);
304          assertEquals(0, stats.getTotalRequestsCount());
305      }
306      @Test
307      public void testLoadBalancingObservablesWithReadTimeout() throws Exception {
308          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
309          MockWebServer server = new MockWebServer();
310          String content = "{\"name\": \"ribbon\", \"age\": 2}";
311          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
312                  .setBody(content));       
313          server.play();
314          IClientConfig config = DefaultClientConfigImpl
315                  .getClientConfigWithDefaultValues()
316                  .set(CommonClientConfigKey.ReadTimeout, 100);
317          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/readTimeout");
318          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
319          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
320          Server goodServer = new Server("localhost:" + server.getPort());
321          Server badServer  = new Server("localhost:" + port);
322          lb.setServersList(Lists.newArrayList(goodServer, badServer, badServer, goodServer));
323          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
324          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
325          observableWithRetries.subscribe(observer);
326          observer.await();
327          if (observer.error != null) {
328              observer.error.printStackTrace();
329          }
330          assertEquals("ribbon", observer.obj.name);
331          assertEquals(2, observer.obj.age);
332          ServerStats stats = lbObservables.getServerStats(badServer);
333          server.shutdown();
334          final HttpClientListener listener = lbObservables.getListener();
335          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
336              @Override
337              public Boolean call() {
338                  return listener.getPoolReleases() == 5;
339              }
340          });
341          assertEquals(0, listener.getPoolReuse());
342          assertEquals(4, stats.getTotalRequestsCount());
343          assertEquals(0, stats.getActiveRequestsCount());
344          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
345          stats = lbObservables.getServerStats(goodServer);
346          assertEquals(1, stats.getTotalRequestsCount());
347          assertEquals(0, stats.getActiveRequestsCount());
348          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
349      }
350      @Test
351      public void testLoadBalancingWithTwoServers() throws Exception {
352          MockWebServer server = new MockWebServer();
353          String content = "{\"name\": \"ribbon\", \"age\": 2}";
354          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
355                  .setBody(content));       
356          server.play();
357          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
358          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/person")
359                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
360                  .withHeader("Content-type", "application/json");
361          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
362          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
363          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
364          HttpClientListener externalListener = HttpClientListener.newHttpListener("external");
365          lbObservables.subscribe(externalListener);
366          Server server1 = new Server("localhost:" + server.getPort());
367          Server server2 = new Server("localhost:" + port);
368          lb.setServersList(Lists.newArrayList(server1, server2));
369          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
370              @Override
371              public boolean isRetriableException(Throwable e, boolean sameServer) {
372                  return true;
373              }
374          };
375          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
376          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
377          observableWithRetries.subscribe(observer);
378          observer.await();
379          if (observer.error != null) {
380              observer.error.printStackTrace();
381          }
382          assertEquals("ribbon", observer.obj.name);
383          assertEquals(EmbeddedResources.defaultPerson.age, observer.obj.age);
384          observer = new ObserverWithLatch<Person>();
385          observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
386          observableWithRetries.subscribe(observer);
387          observer.await();
388          if (observer.error != null) {
389              observer.error.printStackTrace();
390          }
391          assertEquals("ribbon", observer.obj.name);
392          assertEquals(2, observer.obj.age);
393          ServerStats stats = lbObservables.getServerStats(server1);
394          server.shutdown();
395          assertEquals(0, stats.getActiveRequestsCount());
396          stats = lbObservables.getServerStats(server2);
397          assertEquals(1, stats.getTotalRequestsCount());
398          assertEquals(0, stats.getActiveRequestsCount());
399          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
400          final HttpClientListener listener = lbObservables.getListener();
401          assertEquals(2, listener.getPoolAcquires());
402          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
403              @Override
404              public Boolean call() {
405                  return listener.getPoolReleases() == 2;
406              }
407          });
408          assertEquals(2, listener.getConnectionCount());
409          assertEquals(0, listener.getPoolReuse());
410          assertEquals(2, externalListener.getPoolAcquires());
411      }
412      @Test
413      public void testLoadBalancingPostWithReadTimeout() throws Exception {
414          MockWebServer server = new MockWebServer();
415          String content = "{\"name\": \"ribbon\", \"age\": 2}";
416          server.enqueue(new MockResponse()
417                  .setResponseCode(200)
418                  .setHeader("Content-type", "application/json")
419                  .setBody(content));       
420          server.play();
421          IClientConfig config = DefaultClientConfigImpl
422                  .getClientConfigWithDefaultValues()
423                  .set(CommonClientConfigKey.ReadTimeout, 100);
424          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/postTimeout")
425                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
426                  .withHeader("Content-type", "application/json");
427          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
428          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
429          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
430          Server goodServer = new Server("localhost:" + server.getPort());
431          Server badServer = new Server("localhost:" + port);
432          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
433          lb.setServersList(servers);
434          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
435              @Override
436              public boolean isRetriableException(Throwable e, boolean sameServer) {
437                  return true;
438              }
439          };
440          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
441          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
442          observableWithRetries.subscribe(observer);
443          observer.await();
444          if (observer.error != null) {
445              observer.error.printStackTrace();
446          }
447          assertEquals("ribbon", observer.obj.name);
448          assertEquals(2, observer.obj.age);
449          ServerStats stats = lbObservables.getServerStats(badServer);
450          server.shutdown();
451          assertEquals(4, stats.getTotalRequestsCount());
452          assertEquals(0, stats.getActiveRequestsCount());
453          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
454          stats = lbObservables.getServerStats(goodServer);
455          assertEquals(1, stats.getTotalRequestsCount());
456          assertEquals(0, stats.getActiveRequestsCount());
457          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
458      }
459      @Test
460      public void testLoadBalancingPostWithNoRetrySameServer() throws Exception {
461          MockWebServer server = new MockWebServer();
462          String content = "{\"name\": \"ribbon\", \"age\": 2}";
463          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
464                  .setBody(content));       
465          server.play();
466          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
467                  .set(CommonClientConfigKey.ReadTimeout, 100);
468          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/postTimeout")
469                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
470                  .withHeader("Content-type", "application/json");
471          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(0, 3, true);
472          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
473          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
474          Server goodServer = new Server("localhost:" + server.getPort());
475          Server badServer = new Server("localhost:" + port);
476          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
477          lb.setServersList(servers);
478          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
479              @Override
480              public boolean isRetriableException(Throwable e, boolean sameServer) {
481                  return true;
482              }
483          };
484          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
485          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
486          observableWithRetries.subscribe(observer);
487          observer.await();
488          if (observer.error != null) {
489              observer.error.printStackTrace();
490          }
491          server.shutdown();
492          assertEquals("ribbon", observer.obj.name);
493          assertEquals(2, observer.obj.age);
494          ServerStats stats = lbObservables.getServerStats(badServer);
495          assertEquals(2, stats.getTotalRequestsCount());
496          assertEquals(0, stats.getActiveRequestsCount());
497          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
498          stats = lbObservables.getServerStats(goodServer);
499          assertEquals(1, stats.getTotalRequestsCount());
500          assertEquals(0, stats.getActiveRequestsCount());
501          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
502      }
503      @Test
504      public void testObservableWithMultipleServersFailed() throws Exception {        
505          IClientConfig config = IClientConfig.Builder.newBuilder()
506                  .withDefaultValues()
507                  .withRetryOnAllOperations(true)
508                  .withMaxAutoRetries(1)
509                  .withMaxAutoRetriesNextServer(3)
510                  .withConnectTimeout(100)
511                  .build();
512          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
513          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
514          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config);
515          Server badServer = new Server("localhost:12345");
516          Server badServer1 = new Server("localhost:12346");
517          Server badServer2 = new Server("localhost:12347");
518          List<Server> servers = Lists.newArrayList(badServer, badServer1, badServer2);
519          lb.setServersList(servers);
520          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
521          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
522          observableWithRetries.subscribe(observer);
523          observer.await();
524          assertNull(observer.obj);
525          observer.error.printStackTrace();
526          assertTrue(observer.error instanceof ClientException);
527          ServerStats stats = lbObservables.getServerStats(badServer);
528          assertEquals(2, stats.getTotalRequestsCount());
529          assertEquals(0, stats.getActiveRequestsCount());
530          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
531      }
532      private static List<Person> getPersonListFromResponse(Observable<HttpClientResponse<ServerSentEvent>> response) {
533          return getPersonList(transformSSE(response));
534      }
535      private static List<Person> getPersonList(Observable<ServerSentEvent> events) {
536          List<Person> result = Lists.newArrayList();
537          Iterator<Person> iterator = events.map(new Func1<ServerSentEvent, Person>() {
538              @Override
539              public Person call(ServerSentEvent t1) {
540                  String content = t1.getEventData();
541                  try {
542                      return SerializationUtils.deserializeFromString(JacksonCodec.<Person>getInstance(), content, TypeDef.fromClass(Person.class));
543                  } catch (IOException e) {
544                      e.printStackTrace();
545                      return null;
546                  }
547              }
548          }).toBlocking().getIterator();
549          while (iterator.hasNext()) {
550              result.add(iterator.next());
551          }
552          return result;
553      }
554      @Test
555      public void testStream() throws Exception {
556          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/personStream");
557          LoadBalancingHttpClient<ByteBuf, ServerSentEvent> observableClient = (LoadBalancingHttpClient<ByteBuf, ServerSentEvent>) RibbonTransport.newSSEClient();
558          List<Person> result = getPersonListFromResponse(observableClient.submit(new Server(host, port), request));
559          assertEquals(EmbeddedResources.entityStream, result);
560      }
561      @Test
562      public void testStreamWithLoadBalancer() throws Exception {
563          IClientConfig config = IClientConfig.Builder.newBuilder().withRetryOnAllOperations(true)
564                  .withMaxAutoRetries(1)
565                  .withMaxAutoRetriesNextServer(3)
566                  .build();
567          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
568          LoadBalancingHttpClient<ByteBuf, ServerSentEvent> lbObservables = (LoadBalancingHttpClient<ByteBuf, ServerSentEvent>) RibbonTransport.newSSEClient(lb, config);
569          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/personStream");
570          List<Person> result = Lists.newArrayList();
571          Server goodServer = new Server("localhost:" + port);
572          Server badServer = new Server("localhost:12245");
573          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
574          lb.setServersList(servers);
575          result = getPersonListFromResponse(lbObservables.submit(request, null, null));
576          assertEquals(EmbeddedResources.entityStream, result);
577      }
578      @Test
579      public void testQuery() throws Exception {
580          Person myPerson = new Person("hello_world", 4);
581          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/personQuery?name=" + myPerson.name + "&age=" + myPerson.age);
582          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
583          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
584          assertEquals(myPerson, person);
585      }
586      @Test
587      public void testUnexpectedResponse() throws Exception {
588          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/throttle");
589          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient();
590          Observable<HttpClientResponse<ByteBuf>> responseObservable = client.submit(new Server(host, port), request);
591          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
592          final CountDownLatch latch = new CountDownLatch(1);
593          responseObservable.subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
594              @Override
595              public void call(HttpClientResponse<ByteBuf> t1) {
596                  latch.countDown();
597              }
598          }, new Action1<Throwable>(){
599              @Override
600              public void call(Throwable t1) {
601                  error.set(t1);
602                  latch.countDown();
603              }
604          });
605          latch.await();
606          assertTrue(error.get() instanceof ClientException);
607          ClientException ce = (ClientException) error.get();
608          assertTrue(ce.getErrorType() == ClientException.ErrorType.SERVER_THROTTLED);
609      }
610      @Test
611      public void testLoadBalancerThrottle() throws Exception {
612          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/throttle");
613          IClientConfig config = DefaultClientConfigImpl
614                  .getClientConfigWithDefaultValues()
615                  .set(IClientConfigKey.Keys.MaxAutoRetriesNextServer, 1)
616                  .set(IClientConfigKey.Keys.OkToRetryOnAllOperations, true);
617          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
618          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config);
619          Server server = new Server(host, port);
620          lb.setServersList(Lists.newArrayList(server, server, server));
621          Observable<HttpClientResponse<ByteBuf>> response = lbObservables.submit(request);
622          final CountDownLatch latch = new CountDownLatch(1);
623          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
624          response.subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
625              @Override
626              public void call(HttpClientResponse<ByteBuf> t1) {
627                  System.err.println("Get response: " + t1.getStatus().code());
628                  latch.countDown();
629              }
630          }, new Action1<Throwable>(){
631              @Override
632              public void call(Throwable t1) {
633                  error.set(t1);
634                  latch.countDown();
635              }
636          }, new Action0() {
637              @Override
638              public void call() {
639                  Thread.dumpStack();
640                  latch.countDown();
641              }
642          });
643          latch.await();
644          assertTrue(error.get() instanceof ClientException);
645          ClientException ce = (ClientException) error.get();
646          assertTrue(ce.toString(), ce.getErrorType() == ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED);
647          assertEquals(2, lbObservables.getServerStats(server).getSuccessiveConnectionFailureCount());
648      }
649      @Test
650      public void testContext() throws Exception {
651          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/context");
652          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
653          String requestId = "xyz";
654          ContextsContainerImpl contextsContainer = new ContextsContainerImpl(new MapBackedKeySupplier());
655          contextsContainer.addContext("Context1", "value1");
656          RxContexts.DEFAULT_CORRELATOR.onNewServerRequest(requestId, contextsContainer);
657          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(new Server(host, port), request);
658          final AtomicReference<ContextsContainer> responseContext = new AtomicReference<ContextsContainer>(); 
659          String requestIdSent = response.flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>() {
660              @Override
661              public Observable<ByteBuf> call(HttpClientResponse<ByteBuf> t1) {
662                  return t1.getContent();
663              }
664          }).map(new Func1<ByteBuf, String>() {
665              @Override
666              public String call(ByteBuf t1) {
667                  String requestId = RxContexts.DEFAULT_CORRELATOR.getRequestIdForClientRequest();
668                  responseContext.set(RxContexts.DEFAULT_CORRELATOR.getContextForClientRequest(requestId));
669                  return t1.toString(Charset.defaultCharset());
670              }
671          }).toBlocking().single();
672          assertEquals(requestId, requestIdSent);
673          assertEquals("value1", responseContext.get().getContext("Context1"));
674      }
675      @Test
676      @Ignore
677      public void testRedirect() throws Exception {
678          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/redirect?port=" + port);
679          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient =
680                  RibbonTransport.newHttpClient(
681                          IClientConfig.Builder.newBuilder().withDefaultValues()
682                          .withFollowRedirects(true)
683                          .build());
684          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
685          assertEquals(EmbeddedResources.defaultPerson, person);
686      }     
687  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-CFReserveParams.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import static redis.clients.jedis.Protocol.toByteArray;
3  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.BUCKETSIZE;
4  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.EXPANSION;
5  import static redis.clients.jedis.bloom.RedisBloomProtocol.RedisBloomKeyword.MAXITERATIONS;
6  import redis.clients.jedis.CommandArguments;
7  import redis.clients.jedis.params.IParams;
8  public class CFReserveParams implements IParams {
9    private Long bucketSize;
10    private Integer maxIterations;
11    private Integer expansion;
</pre></code></div>
                <div class="column column_space"><pre><code>57  import com.netflix.serialization.JacksonCodec;
58  import com.netflix.serialization.SerializationUtils;
59  import com.netflix.serialization.TypeDef;
60  import com.sun.jersey.api.container.httpserver.HttpServerFactory;
61  import com.sun.jersey.api.core.PackagesResourceConfig;
62  import com.sun.net.httpserver.HttpServer;
63  public class NettyClientTest {
64      private static HttpServer server = null;
65      private static String SERVICE_URI;
66      private static int port;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    