<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Sets_1.java &amp; FluentIterableTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Sets_1.java &amp; FluentIterableTest.java
      </h3>
<h1 align="center">
        4.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Sets_1.java (3.9428077%)<th>FluentIterableTest.java (5.7522125%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(29-70)<td><a href="#" name="0">(19-54)</a><td align="center"><font color="#ff0000">31</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1406-1412)<td><a href="#" name="1">(883-889)</a><td align="center"><font color="#620000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1744-1749)<td><a href="#" name="2">(956-961)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1725-1730)<td><a href="#" name="3">(608-613)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1272-1330)<td><a href="#" name="4">(938-943)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1206-1208)<td><a href="#" name="5">(619-622)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1133-1136)<td><a href="#" name="6">(856-859)</a><td align="center"><font color="#4a0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Sets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
5 import com.google.common.annotations.Beta;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.annotations.GwtIncompatible;
8 <a name="0"></a>import com.google.common.base.Predicate;
9 import com.google.common.base.Predicates;
10 import com.google.common.collect.Collections2.FilteredCollection;
11 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.math.IntMath;
12 import com.google.errorprone.annotations.CanIgnoreReturnValue;
13 import com.google.errorprone.annotations.DoNotCall;
14 import java.io.Serializable;
15 import java.util.AbstractSet;
16 import java.util.Arrays;
17 import java.util.BitSet;
18 import java.util.Collection;
19 import java.util.Collections;
20 import java.util.Comparator;
21 import java.util.EnumSet;
22 import java.util.HashSet;
23 import java.util.Iterator;
24 import java.util.LinkedHashSet;
25 import java.util.List;
26 import java.util.Map;
27 import java.util.NavigableSet;
28 import java.util.NoSuchElementException;
29 import java.util.Set;
30 import java.util.SortedSet;
31 import java.util.TreeSet;
32 import java.util.concurrent.ConcurrentHashMap;
33 import java.util.concurrent.CopyOnWriteArraySet;
34 import java.util.function.Consumer;
35 import java.util.stream.Collector;
36 import java.util.stream.Stream;
37 import javax.annotation.CheckForNull;
38 import org.checkerframework.checker.nullness.qual.Nullable;
39 @GwtCompatible(e</b></font>mulated = true)
40 @ElementTypesAreNonnullByDefault
41 public final class Sets {
42   private Sets() {}
43   abstract static class ImprovedAbstractSet&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
44     @Override
45     public boolean removeAll(Collection&lt;?&gt; c) {
46       return removeAllImpl(this, c);
47     }
48     @Override
49     public boolean retainAll(Collection&lt;?&gt; c) {
50       return super.retainAll(checkNotNull(c));     }
51   }
52   @GwtCompatible(serializable = true)
53   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(
54       E anElement, E... otherElements) {
55     return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
56   }
57   @GwtCompatible(serializable = true)
58   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(Iterable&lt;E&gt; elements) {
59     if (elements instanceof ImmutableEnumSet) {
60       return (ImmutableEnumSet&lt;E&gt;) elements;
61     } else if (elements instanceof Collection) {
62       Collection&lt;E&gt; collection = (Collection&lt;E&gt;) elements;
63       if (collection.isEmpty()) {
64         return ImmutableSet.of();
65       } else {
66         return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
67       }
68     } else {
69       Iterator&lt;E&gt; itr = elements.iterator();
70       if (itr.hasNext()) {
71         EnumSet&lt;E&gt; enumSet = EnumSet.of(itr.next());
72         Iterators.addAll(enumSet, itr);
73         return ImmutableEnumSet.asImmutable(enumSet);
74       } else {
75         return ImmutableSet.of();
76       }
77     }
78   }
79   public static &lt;E extends Enum&lt;E&gt;&gt; Collector&lt;E, ?, ImmutableSet&lt;E&gt;&gt; toImmutableEnumSet() {
80     return CollectCollectors.toImmutableEnumSet();
81   }
82   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(
83       Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
84     EnumSet&lt;E&gt; set = EnumSet.noneOf(elementType);
85     Iterables.addAll(set, iterable);
86     return set;
87   }
88   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet() {
89     return new HashSet&lt;E&gt;();
90   }
91   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
92     HashSet&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);
93     Collections.addAll(set, elements);
94     return set;
95   }
96   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
97     return (elements instanceof Collection)
98         ? new HashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements)
99         : newHashSet(elements.iterator());
100   }
101   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
102     HashSet&lt;E&gt; set = newHashSet();
103     Iterators.addAll(set, elements);
104     return set;
105   }
106   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(
107       int expectedSize) {
108     return new HashSet&lt;E&gt;(Maps.capacity(expectedSize));
109   }
110   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
111     return Platform.newConcurrentHashSet();
112   }
113   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
114     Set&lt;E&gt; set = newConcurrentHashSet();
115     Iterables.addAll(set, elements);
116     return set;
117   }
118   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
119     return new LinkedHashSet&lt;E&gt;();
120   }
121   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(
122       Iterable&lt;? extends E&gt; elements) {
123     if (elements instanceof Collection) {
124       return new LinkedHashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements);
125     }
126     LinkedHashSet&lt;E&gt; set = newLinkedHashSet();
127     Iterables.addAll(set, elements);
128     return set;
129   }
130   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(
131       int expectedSize) {
132     return new LinkedHashSet&lt;E&gt;(Maps.capacity(expectedSize));
133   }
134   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
135     return new TreeSet&lt;E&gt;();
136   }
137   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
138     TreeSet&lt;E&gt; set = newTreeSet();
139     Iterables.addAll(set, elements);
140     return set;
141   }
142   public static &lt;E extends @Nullable Object&gt; TreeSet&lt;E&gt; newTreeSet(
143       Comparator&lt;? super E&gt; comparator) {
144     return new TreeSet&lt;E&gt;(checkNotNull(comparator));
145   }
146   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newIdentityHashSet() {
147     return Collections.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());
148   }
149   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
150     return new CopyOnWriteArraySet&lt;E&gt;();
151   }
152   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(
153       Iterable&lt;? extends E&gt; elements) {
154     Collection&lt;? extends E&gt; elementsCollection =
155         (elements instanceof Collection)
156             ? (Collection&lt;? extends E&gt;) elements
157             : Lists.newArrayList(elements);
158     return new CopyOnWriteArraySet&lt;E&gt;(elementsCollection);
159   }
160   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
161     if (collection instanceof EnumSet) {
162       return EnumSet.complementOf((EnumSet&lt;E&gt;) collection);
163     }
164     checkArgument(
165         !collection.isEmpty(), "collection is empty; use the other version of this method");
166     Class&lt;E&gt; type = collection.iterator().next().getDeclaringClass();
167     return makeComplementByHand(collection, type);
168   }
169   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(
170       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
171     checkNotNull(collection);
172     return (collection instanceof EnumSet)
173         ? EnumSet.complementOf((EnumSet&lt;E&gt;) collection)
174         : makeComplementByHand(collection, type);
175   }
176   private static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; makeComplementByHand(
177       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
178     EnumSet&lt;E&gt; result = EnumSet.allOf(type);
179     result.removeAll(collection);
180     return result;
181   }
182   @Deprecated
183   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newSetFromMap(
184       Map&lt;E, Boolean&gt; map) {
185     return Collections.newSetFromMap(map);
186   }
187   public abstract static class SetView&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
188     private SetView() {} 
189     @SuppressWarnings("nullness")     public ImmutableSet&lt;E&gt; immutableCopy() {
190       return ImmutableSet.copyOf(this);
191     }
192     @CanIgnoreReturnValue
193     public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
194       set.addAll(this);
195       return set;
196     }
197     @CanIgnoreReturnValue
198     @Deprecated
199     @Override
200     @DoNotCall("Always throws UnsupportedOperationException")
201     public final boolean add(@ParametricNullness E e) {
202       throw new UnsupportedOperationException();
203     }
204     @CanIgnoreReturnValue
205     @Deprecated
206     @Override
207     @DoNotCall("Always throws UnsupportedOperationException")
208     public final boolean remove(@CheckForNull Object object) {
209       throw new UnsupportedOperationException();
210     }
211     @CanIgnoreReturnValue
212     @Deprecated
213     @Override
214     @DoNotCall("Always throws UnsupportedOperationException")
215     public final boolean addAll(Collection&lt;? extends E&gt; newElements) {
216       throw new UnsupportedOperationException();
217     }
218     @CanIgnoreReturnValue
219     @Deprecated
220     @Override
221     @DoNotCall("Always throws UnsupportedOperationException")
222     public final boolean removeAll(Collection&lt;?&gt; oldElements) {
223       throw new UnsupportedOperationException();
224     }
225     @CanIgnoreReturnValue
226     @Deprecated
227     @Override
228     @DoNotCall("Always throws UnsupportedOperationException")
229     public final boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
230       throw new UnsupportedOperationException();
231     }
232     @CanIgnoreReturnValue
233     @Deprecated
234     @Override
235     @DoNotCall("Always throws UnsupportedOperationException")
236     public final boolean retainAll(Collection&lt;?&gt; elementsToKeep) {
237       throw new UnsupportedOperationException();
238     }
239     @Deprecated
240     @Override
241     @DoNotCall("Always throws UnsupportedOperationException")
242     public final void clear() {
243       throw new UnsupportedOperationException();
244     }
245     @Override
246     public abstract UnmodifiableIterator&lt;E&gt; iterator();
247   }
248   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; union(
249       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
250     checkNotNull(set1, "set1");
251     checkNotNull(set2, "set2");
252     return new SetView&lt;E&gt;() {
253       @Override
254       public int size() {
255         int size = set1.size();
256         for (E e : set2) {
257           if (!set1.contains(e)) {
258             size++;
259           }
260         }
261         return size;
262       }
263       @Override
264       public boolean isEmpty() {
265         return set1.isEmpty() &amp;&amp; set2.isEmpty();
266       }
267       @Override
268       public UnmodifiableIterator&lt;E&gt; iterator() {
269         return new AbstractIterator&lt;E&gt;() {
270           final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
271           final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
272           @Override
273           @CheckForNull
274           protected E computeNext() {
275             if (itr1.hasNext()) {
276               return itr1.next();
277             }
278             while (itr2.hasNext()) {
279               E e = itr2.next();
280               if (!set1.contains(e)) {
281                 return e;
282               }
283             }
284             return endOfData();
285           }
286         };
287       }
288       @Override
289       public Stream&lt;E&gt; stream() {
290         return Stream.concat(set1.stream(), set2.stream().filter((E e) -&gt; !set1.contains(e)));
291       }
292       @Override
293       public Stream&lt;E&gt; parallelStream() {
294         return stream().parallel();
295       }
296       @Override
297       public boolean contains(@CheckForNull Object object) {
298         return set1.contains(object) || set2.contains(object);
299       }
300       @Override
301       public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
302         set.addAll(set1);
303         set.addAll(set2);
304         return set;
305       }
306       @Override
307       @SuppressWarnings("nullness")       public ImmutableSet&lt;E&gt; immutableCopy() {
308         return new ImmutableSet.Builder&lt;E&gt;().addAll(set1).addAll(set2).build();
309       }
310     };
311   }
312   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; intersection(
313       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
314     checkNotNull(set1, "set1");
315     checkNotNull(set2, "set2");
316     return new SetView&lt;E&gt;() {
317       @Override
318       public UnmodifiableIterator&lt;E&gt; iterator() {
319         return new AbstractIterator&lt;E&gt;() {
320           final Iterator&lt;E&gt; itr = set1.iterator();
321           @Override
322           @CheckForNull
323           protected E computeNext() {
324             while (itr.hasNext()) {
325               E e = itr.next();
326               if (set2.contains(e)) {
327                 return e;
328               }
329             }
330             return endOfData();
331           }
332         };
333       }
334       @Override
335       public Stream&lt;E&gt; stream() {
336         return set1.stream().filter(set2::contains);
337       }
338       @Override
339       public Stream&lt;E&gt; parallelStream() {
340         return set1.parallelStream().filter(set2::contains);
341       }
342       @Override
343       public int size() {
344         int size = 0;
345         for (E e : set1) {
346           if (set2.contains(e)) {
347             size++;
348           }
349         }
350         return size;
351       }
352       @Override
353       public boolean isEmpty() {
354         return Collections.disjoint(set2, set1);
355       }
356       @Override
357       public boolean contains(@CheckForNull Object object) {
358         return set1.contains(object) &amp;&amp; set2.contains(object);
359       }
360       @Override
361       public boolean containsAll(Collection&lt;?&gt; collection) {
362         return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
363       }
364     };
365   }
366   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; difference(
367       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
368     checkNotNull(set1, "set1");
369     checkNotNull(set2, "set2");
370     return new SetView&lt;E&gt;() {
371       @Override
372       public UnmodifiableIterator&lt;E&gt; iterator() {
373         return new AbstractIterator&lt;E&gt;() {
374           final Iterator&lt;E&gt; itr = set1.iterator();
375           @Override
376           @CheckForNull
377           protected E computeNext() {
378             while (itr.hasNext()) {
379               E e = itr.next();
380               if (!set2.contains(e)) {
381                 return e;
382               }
383             }
384             return endOfData();
385           }
386         };
387       }
388       @Override
389       public Stream&lt;E&gt; stream() {
390         return set1.stream().filter(e -&gt; !set2.contains(e));
391       }
392       @Override
393       public Stream&lt;E&gt; parallelStream() {
394         return set1.parallelStream().filter(e -&gt; !set2.contains(e));
395       }
396       @Override
397       public int size() {
398         int size = 0;
399         for (E e : set1) {
400           if (!set2.contains(e)) {
401             size++;
402           }
403         }
404         return size;
405       }
406       @Override
407       public boolean isEmpty() {
408         return set2.containsAll(set1);
409       }
410       @Override
411       public boolean contains(@CheckForNull Object element) {
412         return set1.contains(element) &amp;&amp; !set2.contains(element);
413       }
414     };
415   }
416   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; symmetricDifference(
417       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
418     checkNotNull(set1, "set1");
419     checkNotNull(set2, "set2");
420     return new SetView&lt;E&gt;() {
421       @Override
422       public UnmodifiableIterator&lt;E&gt; iterator() {
423         final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
424         final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
425         return new AbstractIterator&lt;E&gt;() {
426           @Override
427           @CheckForNull
428           public E computeNext() {
429             while (itr1.hasNext()) {
430               E elem1 = itr1.next();
431               if (!set2.contains(elem1)) {
432                 return elem1;
433               }
434             }
435             while (itr2.hasNext()) {
436               E elem2 = itr2.next();
437               if (!set1.contains(elem2)) {
438                 return elem2;
439               }
440             }
441             return endOfData();
442           }
443         };
444       }
445       @Override
446       public int size() {
447         int size = 0;
448         for (E e : set1) {
449           if (!set2.contains(e)) {
450             size++;
451           }
452         }
453         for (E e : set2) {
454           if (!set1.contains(e)) {
455             size++;
456           }
457         }
458         return size;
459       }
460       @Override
461       public boolean isEmpty() {
462         return set1.equals(set2);
463       }
464       @Override
465       public boolean contains(@CheckForNull Object element) {
466         return set1.contains(element) ^ set2.contains(element);
467       }
468     };
469   }
470   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; filter(
471       Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
472     if (unfiltered instanceof SortedSet) {
473       return filter((SortedSet&lt;E&gt;) unfiltered, predicate);
474     }
475     if (unfiltered instanceof FilteredSet) {
476       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
477       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
478       return new FilteredSet&lt;E&gt;((Set&lt;E&gt;) filtered.unfiltered, combinedPredicate);
479     }
480     return new FilteredSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
481   }
482   public static &lt;E extends @Nullable Object&gt; SortedSet&lt;E&gt; filter(
483       SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
484     if (unfiltered instanceof FilteredSet) {
485       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
486       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
487       return new FilteredSortedSet&lt;E&gt;((SortedSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
488     }
489     return new FilteredSortedSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
490   }
491   @GwtIncompatible   @SuppressWarnings("unchecked")
492   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; filter(
493       NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
494     if (unfiltered instanceof FilteredSet) {
495       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
496       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
497       return new FilteredNavigableSet&lt;E&gt;((NavigableSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
498     }
499     return new FilteredNavigableSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
500   }
501   private static class FilteredSet&lt;E extends @Nullable Object&gt; extends FilteredCollection&lt;E&gt;
502       implements Set&lt;E&gt; {
503     FilteredSet(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
504 <a name="6"></a>      super(unfiltered, predicate);
505     }
506     <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
507     public boolean equals(@CheckForNull Object object) {
508       return equalsImpl(this, object);
509     }</b></font>
510     @Override
511     public int hashCode() {
512       return hashCodeImpl(this);
513     }
514   }
515   private static class FilteredSortedSet&lt;E extends @Nullable Object&gt; extends FilteredSet&lt;E&gt;
516       implements SortedSet&lt;E&gt; {
517     FilteredSortedSet(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
518       super(unfiltered, predicate);
519     }
520     @Override
521     @CheckForNull
522     public Comparator&lt;? super E&gt; comparator() {
523       return ((SortedSet&lt;E&gt;) unfiltered).comparator();
524     }
525     @Override
526     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
527       return new FilteredSortedSet&lt;E&gt;(
528           ((SortedSet&lt;E&gt;) unfiltered).subSet(fromElement, toElement), predicate);
529     }
530     @Override
531     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
532       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).headSet(toElement), predicate);
533     }
534     @Override
535     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
536       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).tailSet(fromElement), predicate);
537     }
538     @Override
539     @ParametricNullness
540     public E first() {
541       return Iterators.find(unfiltered.iterator(), predicate);
542     }
543     @Override
544     @ParametricNullness
545     public E last() {
546       SortedSet&lt;E&gt; sortedUnfiltered = (SortedSet&lt;E&gt;) unfiltered;
547       while (true) {
548         E element = sortedUnfiltered.last();
549         if (predicate.apply(element)) {
550           return element;
551         }
552         sortedUnfiltered = sortedUnfiltered.headSet(element);
553       }
554     }
555   }
556   @GwtIncompatible   private static class FilteredNavigableSet&lt;E extends @Nullable Object&gt; extends FilteredSortedSet&lt;E&gt;
557       implements NavigableSet&lt;E&gt; {
558     FilteredNavigableSet(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
559       super(unfiltered, predicate);
560     }
561     NavigableSet&lt;E&gt; unfiltered() {
562       return (NavigableSet&lt;E&gt;) unfiltered;
563     }
564 <a name="5"></a>
565     @Override
566     @CheckForNull
567     public E lower(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@ParametricNullness E e) {
568       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
569     }</b></font>
570     @Override
571     @CheckForNull
572     public E floor(@ParametricNullness E e) {
573       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
574     }
575     @Override
576     @CheckForNull
577     public E ceiling(@ParametricNullness E e) {
578       return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
579     }
580     @Override
581     @CheckForNull
582     public E higher(@ParametricNullness E e) {
583       return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
584     }
585     @Override
586     @CheckForNull
587     public E pollFirst() {
588       return Iterables.removeFirstMatching(unfiltered(), predicate);
589     }
590     @Override
591     @CheckForNull
592     public E pollLast() {
593       return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
594     }
595     @Override
596     public NavigableSet&lt;E&gt; descendingSet() {
597       return Sets.filter(unfiltered().descendingSet(), predicate);
598     }
599     @Override
600     public Iterator&lt;E&gt; descendingIterator() {
601       return Iterators.filter(unfiltered().descendingIterator(), predicate);
602     }
603     @Override
604     @ParametricNullness
605     public E last() {
606       return Iterators.find(unfiltered().descendingIterator(), predicate);
607     }
608     @Override
609     public NavigableSet&lt;E&gt; subSet(
610         @ParametricNullness E fromElement,
611         boolean fromInclusive,
612         @ParametricNullness E toElement,
613         boolean toInclusive) {
614       return filter(
615           unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);
616     }
617     @Override
618     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
619       return filter(unfiltered().headSet(toElement, inclusive), predicate);
620 <a name="4"></a>    }
621     @Override
622     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>boolean inclusive) {
623       return filter(unfiltered().tailSet(fromElement, inclusive), predicate);
624     }
625   }
626   public static &lt;B</b></font>&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets) {
627     return CartesianSet.create(sets);
628   }
629   @SafeVarargs
630   public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets) {
631     return cartesianProduct(Arrays.asList(sets));
632   }
633   private static final class CartesianSet&lt;E&gt; extends ForwardingCollection&lt;List&lt;E&gt;&gt;
634       implements Set&lt;List&lt;E&gt;&gt; {
635     private final transient ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes;
636     private final transient CartesianList&lt;E&gt; delegate;
637     static &lt;E&gt; Set&lt;List&lt;E&gt;&gt; create(List&lt;? extends Set&lt;? extends E&gt;&gt; sets) {
638       ImmutableList.Builder&lt;ImmutableSet&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder&lt;&gt;(sets.size());
639       for (Set&lt;? extends E&gt; set : sets) {
640         ImmutableSet&lt;E&gt; copy = ImmutableSet.copyOf(set);
641         if (copy.isEmpty()) {
642           return ImmutableSet.of();
643 <a name="1"></a>        }
644         axesBuilder.add(copy);
645       }
646       <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes = axesBuilder.build();
647       ImmutableList&lt;List&lt;E&gt;&gt; listAxes =
648           new ImmutableList&lt;List&lt;E&gt;&gt;() {
649             @Override
650             public int size() {
651               return axes.size();
652             }</b></font>
653             @Override
654             public List&lt;E&gt; get(int index) {
655               return axes.get(index).asList();
656             }
657             @Override
658             boolean isPartialView() {
659               return true;
660             }
661           };
662       return new CartesianSet&lt;E&gt;(axes, new CartesianList&lt;E&gt;(listAxes));
663     }
664     private CartesianSet(ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes, CartesianList&lt;E&gt; delegate) {
665       this.axes = axes;
666       this.delegate = delegate;
667     }
668     @Override
669     protected Collection&lt;List&lt;E&gt;&gt; delegate() {
670       return delegate;
671     }
672     @Override
673     public boolean contains(@CheckForNull Object object) {
674       if (!(object instanceof List)) {
675         return false;
676       }
677       List&lt;?&gt; list = (List&lt;?&gt;) object;
678       if (list.size() != axes.size()) {
679         return false;
680       }
681       int i = 0;
682       for (Object o : list) {
683         if (!axes.get(i).contains(o)) {
684           return false;
685         }
686         i++;
687       }
688       return true;
689     }
690     @Override
691     public boolean equals(@CheckForNull Object object) {
692       if (object instanceof CartesianSet) {
693         CartesianSet&lt;?&gt; that = (CartesianSet&lt;?&gt;) object;
694         return this.axes.equals(that.axes);
695       }
696       return super.equals(object);
697     }
698     @Override
699     public int hashCode() {
700       int adjust = size() - 1;
701       for (int i = 0; i &lt; axes.size(); i++) {
702         adjust *= 31;
703         adjust = ~~adjust;
704       }
705       int hash = 1;
706       for (Set&lt;E&gt; axis : axes) {
707         hash = 31 * hash + (size() / axis.size() * axis.hashCode());
708         hash = ~~hash;
709       }
710       hash += adjust;
711       return ~~hash;
712     }
713   }
714   @GwtCompatible(serializable = false)
715   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; powerSet(Set&lt;E&gt; set) {
716     return new PowerSet&lt;E&gt;(set);
717   }
718   private static final class SubSet&lt;E&gt; extends AbstractSet&lt;E&gt; {
719     private final ImmutableMap&lt;E, Integer&gt; inputSet;
720     private final int mask;
721     SubSet(ImmutableMap&lt;E, Integer&gt; inputSet, int mask) {
722       this.inputSet = inputSet;
723       this.mask = mask;
724     }
725     @Override
726     public Iterator&lt;E&gt; iterator() {
727       return new UnmodifiableIterator&lt;E&gt;() {
728         final ImmutableList&lt;E&gt; elements = inputSet.keySet().asList();
729         int remainingSetBits = mask;
730         @Override
731         public boolean hasNext() {
732           return remainingSetBits != 0;
733         }
734         @Override
735         public E next() {
736           int index = Integer.numberOfTrailingZeros(remainingSetBits);
737           if (index == 32) {
738             throw new NoSuchElementException();
739           }
740           remainingSetBits &amp;= ~(1 &lt;&lt; index);
741           return elements.get(index);
742         }
743       };
744     }
745     @Override
746     public int size() {
747       return Integer.bitCount(mask);
748     }
749     @Override
750     public boolean contains(@CheckForNull Object o) {
751       Integer index = inputSet.get(o);
752       return index != null &amp;&amp; (mask &amp; (1 &lt;&lt; index)) != 0;
753     }
754   }
755   private static final class PowerSet&lt;E&gt; extends AbstractSet&lt;Set&lt;E&gt;&gt; {
756     final ImmutableMap&lt;E, Integer&gt; inputSet;
757     PowerSet(Set&lt;E&gt; input) {
758       checkArgument(
759           input.size() &lt;= 30, "Too many elements to create power set: %s &gt; 30", input.size());
760       this.inputSet = Maps.indexMap(input);
761     }
762     @Override
763     public int size() {
764       return 1 &lt;&lt; inputSet.size();
765     }
766     @Override
767     public boolean isEmpty() {
768       return false;
769     }
770     @Override
771     public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
772       return new AbstractIndexedListIterator&lt;Set&lt;E&gt;&gt;(size()) {
773         @Override
774         protected Set&lt;E&gt; get(final int setBits) {
775           return new SubSet&lt;E&gt;(inputSet, setBits);
776         }
777       };
778     }
779     @Override
780     public boolean contains(@CheckForNull Object obj) {
781       if (obj instanceof Set) {
782         Set&lt;?&gt; set = (Set&lt;?&gt;) obj;
783         return inputSet.keySet().containsAll(set);
784       }
785       return false;
786     }
787     @Override
788     public boolean equals(@CheckForNull Object obj) {
789       if (obj instanceof PowerSet) {
790         PowerSet&lt;?&gt; that = (PowerSet&lt;?&gt;) obj;
791         return inputSet.keySet().equals(that.inputSet.keySet());
792       }
793       return super.equals(obj);
794     }
795     @Override
796     public int hashCode() {
797       return inputSet.keySet().hashCode() &lt;&lt; (inputSet.size() - 1);
798     }
799     @Override
800     public String toString() {
801       return "powerSet(" + inputSet + ")";
802     }
803   }
804   @Beta
805   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; combinations(Set&lt;E&gt; set, final int size) {
806     final ImmutableMap&lt;E, Integer&gt; index = Maps.indexMap(set);
807     checkNonnegative(size, "size");
808     checkArgument(size &lt;= index.size(), "size (%s) must be &lt;= set.size() (%s)", size, index.size());
809     if (size == 0) {
810       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(ImmutableSet.&lt;E&gt;of());
811     } else if (size == index.size()) {
812       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(index.keySet());
813     }
814     return new AbstractSet&lt;Set&lt;E&gt;&gt;() {
815       @Override
816       public boolean contains(@CheckForNull Object o) {
817         if (o instanceof Set) {
818           Set&lt;?&gt; s = (Set&lt;?&gt;) o;
819           return s.size() == size &amp;&amp; index.keySet().containsAll(s);
820         }
821         return false;
822       }
823       @Override
824       public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
825         return new AbstractIterator&lt;Set&lt;E&gt;&gt;() {
826           final BitSet bits = new BitSet(index.size());
827           @Override
828           @CheckForNull
829           protected Set&lt;E&gt; computeNext() {
830             if (bits.isEmpty()) {
831               bits.set(0, size);
832             } else {
833               int firstSetBit = bits.nextSetBit(0);
834               int bitToFlip = bits.nextClearBit(firstSetBit);
835               if (bitToFlip == index.size()) {
836                 return endOfData();
837               }
838               bits.set(0, bitToFlip - firstSetBit - 1);
839               bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);
840               bits.set(bitToFlip);
841             }
842             final BitSet copy = (BitSet) bits.clone();
843             return new AbstractSet&lt;E&gt;() {
844               @Override
845               public boolean contains(@CheckForNull Object o) {
846                 Integer i = index.get(o);
847                 return i != null &amp;&amp; copy.get(i);
848               }
849               @Override
850               public Iterator&lt;E&gt; iterator() {
851                 return new AbstractIterator&lt;E&gt;() {
852                   int i = -1;
853                   @Override
854                   @CheckForNull
855                   protected E computeNext() {
856                     i = copy.nextSetBit(i + 1);
857 <a name="3"></a>                    if (i == -1) {
858                       return endOfData();
859                     }
860                     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return index.keySet().asList().get(i);
861                   }
862                 };
863               }
864               @Ove</b></font>rride
865               public int size() {
866                 return size;
867               }
868             };
869           }
870         };
871       }
872       @Override
873       public int size() {
874 <a name="2"></a>        return IntMath.binomial(index.size(), size);
875       }
876       <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
877       public String toString() {
878         return "Sets.combinations(" + index.keySet() + ", " + size + ")";
879       }
880     };
881   }</b></font>
882   static int hashCodeImpl(Set&lt;?&gt; s) {
883     int hashCode = 0;
884     for (Object o : s) {
885       hashCode += o != null ? o.hashCode() : 0;
886       hashCode = ~~hashCode;
887     }
888     return hashCode;
889   }
890   static boolean equalsImpl(Set&lt;?&gt; s, @CheckForNull Object object) {
891     if (s == object) {
892       return true;
893     }
894     if (object instanceof Set) {
895       Set&lt;?&gt; o = (Set&lt;?&gt;) object;
896       try {
897         return s.size() == o.size() &amp;&amp; s.containsAll(o);
898       } catch (NullPointerException | ClassCastException ignored) {
899         return false;
900       }
901     }
902     return false;
903   }
904   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; unmodifiableNavigableSet(
905       NavigableSet&lt;E&gt; set) {
906     if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
907       return set;
908     }
909     return new UnmodifiableNavigableSet&lt;E&gt;(set);
910   }
911   static final class UnmodifiableNavigableSet&lt;E extends @Nullable Object&gt;
912       extends ForwardingSortedSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Serializable {
913     private final NavigableSet&lt;E&gt; delegate;
914     private final SortedSet&lt;E&gt; unmodifiableDelegate;
915     UnmodifiableNavigableSet(NavigableSet&lt;E&gt; delegate) {
916       this.delegate = checkNotNull(delegate);
917       this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
918     }
919     @Override
920     protected SortedSet&lt;E&gt; delegate() {
921       return unmodifiableDelegate;
922     }
923     @Override
924     public boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
925       throw new UnsupportedOperationException();
926     }
927     @Override
928     public Stream&lt;E&gt; stream() {
929       return delegate.stream();
930     }
931     @Override
932     public Stream&lt;E&gt; parallelStream() {
933       return delegate.parallelStream();
934     }
935     @Override
936     public void forEach(Consumer&lt;? super E&gt; action) {
937       delegate.forEach(action);
938     }
939     @Override
940     @CheckForNull
941     public E lower(@ParametricNullness E e) {
942       return delegate.lower(e);
943     }
944     @Override
945     @CheckForNull
946     public E floor(@ParametricNullness E e) {
947       return delegate.floor(e);
948     }
949     @Override
950     @CheckForNull
951     public E ceiling(@ParametricNullness E e) {
952       return delegate.ceiling(e);
953     }
954     @Override
955     @CheckForNull
956     public E higher(@ParametricNullness E e) {
957       return delegate.higher(e);
958     }
959     @Override
960     @CheckForNull
961     public E pollFirst() {
962       throw new UnsupportedOperationException();
963     }
964     @Override
965     @CheckForNull
966     public E pollLast() {
967       throw new UnsupportedOperationException();
968     }
969     @CheckForNull private transient UnmodifiableNavigableSet&lt;E&gt; descendingSet;
970     @Override
971     public NavigableSet&lt;E&gt; descendingSet() {
972       UnmodifiableNavigableSet&lt;E&gt; result = descendingSet;
973       if (result == null) {
974         result = descendingSet = new UnmodifiableNavigableSet&lt;E&gt;(delegate.descendingSet());
975         result.descendingSet = this;
976       }
977       return result;
978     }
979     @Override
980     public Iterator&lt;E&gt; descendingIterator() {
981       return Iterators.unmodifiableIterator(delegate.descendingIterator());
982     }
983     @Override
984     public NavigableSet&lt;E&gt; subSet(
985         @ParametricNullness E fromElement,
986         boolean fromInclusive,
987         @ParametricNullness E toElement,
988         boolean toInclusive) {
989       return unmodifiableNavigableSet(
990           delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));
991     }
992     @Override
993     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
994       return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));
995     }
996     @Override
997     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
998       return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));
999     }
1000     private static final long serialVersionUID = 0;
1001   }
1002   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; synchronizedNavigableSet(
1003       NavigableSet&lt;E&gt; navigableSet) {
1004     return Synchronized.navigableSet(navigableSet);
1005   }
1006   static boolean removeAllImpl(Set&lt;?&gt; set, Iterator&lt;?&gt; iterator) {
1007     boolean changed = false;
1008     while (iterator.hasNext()) {
1009       changed |= set.remove(iterator.next());
1010     }
1011     return changed;
1012   }
1013   static boolean removeAllImpl(Set&lt;?&gt; set, Collection&lt;?&gt; collection) {
1014     checkNotNull(collection);     if (collection instanceof Multiset) {
1015       collection = ((Multiset&lt;?&gt;) collection).elementSet();
1016     }
1017     if (collection instanceof Set &amp;&amp; collection.size() &gt; set.size()) {
1018       return Iterators.removeAll(set.iterator(), collection);
1019     } else {
1020       return removeAllImpl(set, collection.iterator());
1021     }
1022   }
1023   @GwtIncompatible   static class DescendingSet&lt;E extends @Nullable Object&gt; extends ForwardingNavigableSet&lt;E&gt; {
1024     private final NavigableSet&lt;E&gt; forward;
1025     DescendingSet(NavigableSet&lt;E&gt; forward) {
1026       this.forward = forward;
1027     }
1028     @Override
1029     protected NavigableSet&lt;E&gt; delegate() {
1030       return forward;
1031     }
1032     @Override
1033     @CheckForNull
1034     public E lower(@ParametricNullness E e) {
1035       return forward.higher(e);
1036     }
1037     @Override
1038     @CheckForNull
1039     public E floor(@ParametricNullness E e) {
1040       return forward.ceiling(e);
1041     }
1042     @Override
1043     @CheckForNull
1044     public E ceiling(@ParametricNullness E e) {
1045       return forward.floor(e);
1046     }
1047     @Override
1048     @CheckForNull
1049     public E higher(@ParametricNullness E e) {
1050       return forward.lower(e);
1051     }
1052     @Override
1053     @CheckForNull
1054     public E pollFirst() {
1055       return forward.pollLast();
1056     }
1057     @Override
1058     @CheckForNull
1059     public E pollLast() {
1060       return forward.pollFirst();
1061     }
1062     @Override
1063     public NavigableSet&lt;E&gt; descendingSet() {
1064       return forward;
1065     }
1066     @Override
1067     public Iterator&lt;E&gt; descendingIterator() {
1068       return forward.iterator();
1069     }
1070     @Override
1071     public NavigableSet&lt;E&gt; subSet(
1072         @ParametricNullness E fromElement,
1073         boolean fromInclusive,
1074         @ParametricNullness E toElement,
1075         boolean toInclusive) {
1076       return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
1077     }
1078     @Override
1079     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
1080       return standardSubSet(fromElement, toElement);
1081     }
1082     @Override
1083     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
1084       return forward.tailSet(toElement, inclusive).descendingSet();
1085     }
1086     @Override
1087     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
1088       return standardHeadSet(toElement);
1089     }
1090     @Override
1091     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
1092       return forward.headSet(fromElement, inclusive).descendingSet();
1093     }
1094     @Override
1095     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
1096       return standardTailSet(fromElement);
1097     }
1098     @SuppressWarnings("unchecked")
1099     @Override
1100     public Comparator&lt;? super E&gt; comparator() {
1101       Comparator&lt;? super E&gt; forwardComparator = forward.comparator();
1102       if (forwardComparator == null) {
1103         return (Comparator) Ordering.natural().reverse();
1104       } else {
1105         return reverse(forwardComparator);
1106       }
1107     }
1108     private static &lt;T extends @Nullable Object&gt; Ordering&lt;T&gt; reverse(Comparator&lt;T&gt; forward) {
1109       return Ordering.from(forward).reverse();
1110     }
1111     @Override
1112     @ParametricNullness
1113     public E first() {
1114       return forward.last();
1115     }
1116     @Override
1117     @ParametricNullness
1118     public E last() {
1119       return forward.first();
1120     }
1121     @Override
1122     public Iterator&lt;E&gt; iterator() {
1123       return forward.descendingIterator();
1124     }
1125     @Override
1126     public @Nullable Object[] toArray() {
1127       return standardToArray();
1128     }
1129     @Override
1130     @SuppressWarnings("nullness")     public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
1131       return standardToArray(array);
1132     }
1133     @Override
1134     public String toString() {
1135       return standardToString();
1136     }
1137   }
1138   @Beta
1139   @GwtIncompatible   public static &lt;K extends Comparable&lt;? super K&gt;&gt; NavigableSet&lt;K&gt; subSet(
1140       NavigableSet&lt;K&gt; set, Range&lt;K&gt; range) {
1141     if (set.comparator() != null
1142         &amp;&amp; set.comparator() != Ordering.natural()
1143         &amp;&amp; range.hasLowerBound()
1144         &amp;&amp; range.hasUpperBound()) {
1145       checkArgument(
1146           set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) &lt;= 0,
1147           "set is using a custom comparator which is inconsistent with the natural ordering.");
1148     }
1149     if (range.hasLowerBound() &amp;&amp; range.hasUpperBound()) {
1150       return set.subSet(
1151           range.lowerEndpoint(),
1152           range.lowerBoundType() == BoundType.CLOSED,
1153           range.upperEndpoint(),
1154           range.upperBoundType() == BoundType.CLOSED);
1155     } else if (range.hasLowerBound()) {
1156       return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);
1157     } else if (range.hasUpperBound()) {
1158       return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
1159     }
1160     return checkNotNull(set);
1161   }
1162 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FluentIterableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static com.google.common.collect.FluentIterableTest.Help.assertThat;
4 import static com.google.common.collect.Lists.newArrayList;
5 import static com.google.common.truth.Truth.assertThat;
6 import static java.util.Arrays.asList;
7 import com.google.common.annotations.GwtCompatible;
8 import com.google.common.annotations.GwtIncompatible;
9 import com.google.common.base.Function;
10 import com.google.common.base.Functions;
11 import com.google.common.base.Joiner;
12 import com.google.common.base.Predicate;
13 import com.google.common.base.Predicates;
14 import com.google.common.collect.testing.IteratorFeature;
15 import com.google.common.collect.testing.IteratorTester;
16 import com.google.common.testing.NullPointerTester;
17 import com.google.common.truth.IterableSubject;
18 import com.google.common.truth.Truth;
19 import java.util.ArrayList;
20 import java.util.Collection;
21 import java.util.Collections;
22 import java.util.Iterator;
23 import java.util.List;
24 import java.util.Set;
25 import java.util.SortedSet;
26 import java.util.concurrent.TimeUnit;
27 import java.util.stream.Stream;
28 import junit.framework.AssertionFailedError;
29 import junit.framework.TestCase;
30 import org.checkerframework.checker.nullness.qual.Nullable;
31 @GwtCompatible(e</b></font>mulated = true)
32 public class FluentIterableTest extends TestCase {
33   @GwtIncompatible   public void testNullPointerExceptions() {
34     NullPointerTester tester = new NullPointerTester();
35     tester.testAllPublicStaticMethods(FluentIterable.class);
36   }
37   public void testFromArrayAndAppend() {
38     FluentIterable&lt;TimeUnit&gt; units =
39         FluentIterable.from(TimeUnit.values()).append(TimeUnit.SECONDS);
40   }
41   public void testFromArrayAndIteratorRemove() {
42     FluentIterable&lt;TimeUnit&gt; units = FluentIterable.from(TimeUnit.values());
43     try {
44       Iterables.removeIf(units, Predicates.equalTo(TimeUnit.SECONDS));
45       fail("Expected an UnsupportedOperationException to be thrown but it wasn't.");
46     } catch (UnsupportedOperationException expected) {
47     }
48   }
49   public void testFrom() {
50     assertEquals(
51         ImmutableList.of(1, 2, 3, 4),
52         Lists.newArrayList(FluentIterable.from(ImmutableList.of(1, 2, 3, 4))));
53   }
54   @SuppressWarnings("deprecation")   public void testFrom_alreadyFluentIterable() {
55     FluentIterable&lt;Integer&gt; iterable = FluentIterable.from(asList(1));
56     assertSame(iterable, FluentIterable.from(iterable));
57   }
58   public void testOf() {
59     assertEquals(ImmutableList.of(1, 2, 3, 4), Lists.newArrayList(FluentIterable.of(1, 2, 3, 4)));
60   }
61   public void testFromArray() {
62     assertEquals(
63         ImmutableList.of("1", "2", "3", "4"),
64         Lists.newArrayList(FluentIterable.from(new Object[] {"1", "2", "3", "4"})));
65   }
66   public void testOf_empty() {
67     assertEquals(ImmutableList.of(), Lists.newArrayList(FluentIterable.of()));
68   }
69   public void testConcatIterable() {
70     List&lt;Integer&gt; list1 = newArrayList(1);
71     List&lt;Integer&gt; list2 = newArrayList(4);
72     @SuppressWarnings("unchecked")
73     List&lt;List&lt;Integer&gt;&gt; input = newArrayList(list1, list2);
74     FluentIterable&lt;Integer&gt; result = FluentIterable.concat(input);
75     assertEquals(asList(1, 4), newArrayList(result));
76     list1.add(2);
77     List&lt;Integer&gt; list3 = newArrayList(3);
78     input.add(1, list3);
79     assertEquals(asList(1, 2, 3, 4), newArrayList(result));
80     assertEquals("[1, 2, 3, 4]", result.toString());
81   }
82   public void testConcatVarargs() {
83     List&lt;Integer&gt; list1 = newArrayList(1);
84     List&lt;Integer&gt; list2 = newArrayList(4);
85     List&lt;Integer&gt; list3 = newArrayList(7, 8);
86     List&lt;Integer&gt; list4 = newArrayList(9);
87     List&lt;Integer&gt; list5 = newArrayList(10);
88     @SuppressWarnings("unchecked")
89     FluentIterable&lt;Integer&gt; result = FluentIterable.concat(list1, list2, list3, list4, list5);
90     assertEquals(asList(1, 4, 7, 8, 9, 10), newArrayList(result));
91     assertEquals("[1, 4, 7, 8, 9, 10]", result.toString());
92   }
93   public void testConcatNullPointerException() {
94     List&lt;Integer&gt; list1 = newArrayList(1);
95     List&lt;Integer&gt; list2 = newArrayList(4);
96     try {
97       FluentIterable.concat(list1, null, list2);
98       fail();
99     } catch (NullPointerException expected) {
100     }
101   }
102   public void testConcatPeformingFiniteCycle() {
103     Iterable&lt;Integer&gt; iterable = asList(1, 2, 3);
104     int n = 4;
105     FluentIterable&lt;Integer&gt; repeated = FluentIterable.concat(Collections.nCopies(n, iterable));
106     assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();
107   }
108   interface X {}
109   interface Y {}
110   static class A implements X, Y {}
111   static class B implements X, Y {}
112   public void testConcatIntersectionType() {
113     Iterable&lt;A&gt; aIterable = ImmutableList.of();
114     Iterable&lt;B&gt; bIterable = ImmutableList.of();
115     Predicate&lt;X&gt; xPredicate = Predicates.alwaysTrue();
116     Predicate&lt;Y&gt; yPredicate = Predicates.alwaysTrue();
117     FluentIterable&lt;?&gt; unused =
118         FluentIterable.concat(aIterable, bIterable).filter(xPredicate).filter(yPredicate);
119   }
120   public void testSize0() {
121     assertEquals(0, FluentIterable.&lt;String&gt;of().size());
122   }
123   public void testSize1Collection() {
124     assertEquals(1, FluentIterable.from(asList("a")).size());
125   }
126   public void testSize2NonCollection() {
127     Iterable&lt;Integer&gt; iterable =
128         new Iterable&lt;Integer&gt;() {
129           @Override
130           public Iterator&lt;Integer&gt; iterator() {
131             return asList(0, 1).iterator();
132           }
133         };
134     assertEquals(2, FluentIterable.from(iterable).size());
135   }
136   public void testSize_collectionDoesntIterate() {
137     List&lt;Integer&gt; nums = asList(1, 2, 3, 4, 5);
138     List&lt;Integer&gt; collection =
139         new ArrayList&lt;Integer&gt;(nums) {
140           @Override
141           public Iterator&lt;Integer&gt; iterator() {
142             throw new AssertionFailedError("Don't iterate me!");
143           }
144         };
145     assertEquals(5, FluentIterable.from(collection).size());
146   }
147   public void testContains_nullSetYes() {
148     Iterable&lt;String&gt; set = Sets.newHashSet("a", null, "b");
149     assertTrue(FluentIterable.from(set).contains(null));
150   }
151   public void testContains_nullSetNo() {
152     Iterable&lt;String&gt; set = ImmutableSortedSet.of("a", "b");
153     assertFalse(FluentIterable.from(set).contains(null));
154   }
155   public void testContains_nullIterableYes() {
156     Iterable&lt;String&gt; iterable = iterable("a", null, "b");
157     assertTrue(FluentIterable.from(iterable).contains(null));
158   }
159   public void testContains_nullIterableNo() {
160     Iterable&lt;String&gt; iterable = iterable("a", "b");
161     assertFalse(FluentIterable.from(iterable).contains(null));
162   }
163   public void testContains_nonNullSetYes() {
164     Iterable&lt;String&gt; set = Sets.newHashSet("a", null, "b");
165     assertTrue(FluentIterable.from(set).contains("b"));
166   }
167   public void testContains_nonNullSetNo() {
168     Iterable&lt;String&gt; set = Sets.newHashSet("a", "b");
169     assertFalse(FluentIterable.from(set).contains("c"));
170   }
171   public void testContains_nonNullIterableYes() {
172     Iterable&lt;String&gt; set = iterable("a", null, "b");
173     assertTrue(FluentIterable.from(set).contains("b"));
174   }
175   public void testContains_nonNullIterableNo() {
176     Iterable&lt;String&gt; iterable = iterable("a", "b");
177     assertFalse(FluentIterable.from(iterable).contains("c"));
178   }
179   public void testOfToString() {
180     assertEquals("[yam, bam, jam, ham]", FluentIterable.of("yam", "bam", "jam", "ham").toString());
181   }
182   public void testToString() {
183     assertEquals("[]", FluentIterable.from(Collections.emptyList()).toString());
184     assertEquals("[]", FluentIterable.&lt;String&gt;of().toString());
185     assertEquals(
186         "[yam, bam, jam, ham]", FluentIterable.from(asList("yam", "bam", "jam", "ham")).toString());
187   }
188   public void testCycle() {
189     FluentIterable&lt;String&gt; cycle = FluentIterable.from(asList("a", "b")).cycle();
190     int howManyChecked = 0;
191     for (String string : cycle) {
192       String expected = (howManyChecked % 2 == 0) ? "a" : "b";
193       assertEquals(expected, string);
194       if (howManyChecked++ == 5) {
195         break;
196       }
197     }
198     assertEquals("a", cycle.iterator().next());
199   }
200   public void testCycle_emptyIterable() {
201     FluentIterable&lt;Integer&gt; cycle = FluentIterable.&lt;Integer&gt;of().cycle();
202     assertFalse(cycle.iterator().hasNext());
203   }
204   public void testCycle_removingAllElementsStopsCycle() {
205     FluentIterable&lt;Integer&gt; cycle = fluent(1, 2).cycle();
206     Iterator&lt;Integer&gt; iterator = cycle.iterator();
207     iterator.next();
208     iterator.remove();
209     iterator.next();
210     iterator.remove();
211     assertFalse(iterator.hasNext());
212     assertFalse(cycle.iterator().hasNext());
213   }
214   public void testAppend() {
215     FluentIterable&lt;Integer&gt; result =
216         FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(Lists.newArrayList(4, 5, 6));
217     assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
218     assertEquals("[1, 2, 3, 4, 5, 6]", result.toString());
219     result = FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(4, 5, 6);
220     assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
221     assertEquals("[1, 2, 3, 4, 5, 6]", result.toString());
222   }
223   public void testAppend_toEmpty() {
224     FluentIterable&lt;Integer&gt; result =
225         FluentIterable.&lt;Integer&gt;of().append(Lists.newArrayList(1, 2, 3));
226     assertEquals(asList(1, 2, 3), Lists.newArrayList(result));
227   }
228   public void testAppend_emptyList() {
229     FluentIterable&lt;Integer&gt; result =
230         FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(Lists.&lt;Integer&gt;newArrayList());
231     assertEquals(asList(1, 2, 3), Lists.newArrayList(result));
232   }
233   public void testAppend_nullPointerException() {
234     try {
235       FluentIterable&lt;Integer&gt; unused =
236           FluentIterable.&lt;Integer&gt;from(asList(1, 2)).append((List&lt;Integer&gt;) null);
237       fail("Appending null iterable should throw NPE.");
238     } catch (NullPointerException expected) {
239     }
240   }
241   /*
242    * Tests for partition(int size) method.
243    */
244   /*
245    * Tests for partitionWithPadding(int size) method.
246    */
247   public void testFilter() {
248     FluentIterable&lt;String&gt; filtered =
249         FluentIterable.from(asList("foo", "bar")).filter(Predicates.equalTo("foo"));
250     List&lt;String&gt; expected = Collections.singletonList("foo");
251     List&lt;String&gt; actual = Lists.newArrayList(filtered);
252     assertEquals(expected, actual);
253     assertCanIterateAgain(filtered);
254     assertEquals("[foo]", filtered.toString());
255   }
256   private static class TypeA {}
257   private interface TypeB {}
258   private static class HasBoth extends TypeA implements TypeB {}
259   @GwtIncompatible   public void testFilterByType() throws Exception {
260     HasBoth hasBoth = new HasBoth();
261     FluentIterable&lt;TypeA&gt; alist =
262         FluentIterable.from(asList(new TypeA(), new TypeA(), hasBoth, new TypeA()));
263     Iterable&lt;TypeB&gt; blist = alist.filter(TypeB.class);
264     assertThat(blist).containsExactly(hasBoth).inOrder();
265   }
266   public void testAnyMatch() {
267     ArrayList&lt;String&gt; list = Lists.newArrayList();
268     FluentIterable&lt;String&gt; iterable = FluentIterable.&lt;String&gt;from(list);
269     Predicate&lt;String&gt; predicate = Predicates.equalTo("pants");
270     assertFalse(iterable.anyMatch(predicate));
271     list.add("cool");
272     assertFalse(iterable.anyMatch(predicate));
273     list.add("pants");
274     assertTrue(iterable.anyMatch(predicate));
275   }
276   public void testAllMatch() {
277     List&lt;String&gt; list = Lists.newArrayList();
278     FluentIterable&lt;String&gt; iterable = FluentIterable.&lt;String&gt;from(list);
279     Predicate&lt;String&gt; predicate = Predicates.equalTo("cool");
280     assertTrue(iterable.allMatch(predicate));
281     list.add("cool");
282     assertTrue(iterable.allMatch(predicate));
283     list.add("pants");
284     assertFalse(iterable.allMatch(predicate));
285   }
286   public void testFirstMatch() {
287     FluentIterable&lt;String&gt; iterable = FluentIterable.from(Lists.newArrayList("cool", "pants"));
288     assertThat(iterable.firstMatch(Predicates.equalTo("cool"))).hasValue("cool");
289     assertThat(iterable.firstMatch(Predicates.equalTo("pants"))).hasValue("pants");
290     assertThat(iterable.firstMatch(Predicates.alwaysFalse())).isAbsent();
291     assertThat(iterable.firstMatch(Predicates.alwaysTrue())).hasValue("cool");
292   }
293   private static final class IntegerValueOfFunction implements Function&lt;String, Integer&gt; {
294     @Override
295     public Integer apply(String from) {
296       return Integer.valueOf(from);
297     }
298   }
299   public void testTransformWith() {
300     List&lt;String&gt; input = asList("1", "2", "3");
301     Iterable&lt;Integer&gt; iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());
302     assertEquals(asList(1, 2, 3), Lists.newArrayList(iterable));
303     assertCanIterateAgain(iterable);
304     assertEquals("[1, 2, 3]", iterable.toString());
305   }
306   public void testTransformWith_poorlyBehavedTransform() {
307     List&lt;String&gt; input = asList("1", null, "3");
308     Iterable&lt;Integer&gt; iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());
309     Iterator&lt;Integer&gt; resultIterator = iterable.iterator();
310     resultIterator.next();
311     try {
312       resultIterator.next();
313       fail("Transforming null to int should throw NumberFormatException");
314     } catch (NumberFormatException expected) {
315     }
316   }
317   private static final class StringValueOfFunction implements Function&lt;Integer, String&gt; {
318     @Override
319     public String apply(Integer from) {
320       return String.valueOf(from);
321     }
322   }
323   public void testTransformWith_nullFriendlyTransform() {
324     List&lt;Integer&gt; input = asList(1, 2, null, 3);
325     Iterable&lt;String&gt; result = FluentIterable.from(input).transform(new StringValueOfFunction());
326     assertEquals(asList("1", "2", "null", "3"), Lists.newArrayList(result));
327   }
328   private static final class RepeatedStringValueOfFunction
329       implements Function&lt;Integer, List&lt;String&gt;&gt; {
330     @Override
331     public List&lt;String&gt; apply(Integer from) {
332       String value = String.valueOf(from);
333       return ImmutableList.of(value, value);
334     }
335   }
336   public void testTransformAndConcat() {
337     List&lt;Integer&gt; input = asList(1, 2, 3);
338     Iterable&lt;String&gt; result =
339         FluentIterable.from(input).transformAndConcat(new RepeatedStringValueOfFunction());
340     assertEquals(asList("1", "1", "2", "2", "3", "3"), Lists.newArrayList(result));
341   }
342   private static final class RepeatedStringValueOfWildcardFunction
343       implements Function&lt;Integer, List&lt;? extends String&gt;&gt; {
344     @Override
345     public List&lt;String&gt; apply(Integer from) {
346       String value = String.valueOf(from);
347       return ImmutableList.of(value, value);
348     }
349   }
350   public void testTransformAndConcat_wildcardFunctionGenerics() {
351     List&lt;Integer&gt; input = asList(1, 2, 3);
352     FluentIterable&lt;String&gt; unused =
353         FluentIterable.from(input).transformAndConcat(new RepeatedStringValueOfWildcardFunction());
354   }
355   public void testFirst_list() {
356     List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
357     assertThat(FluentIterable.from(list).first()).hasValue("a");
358   }
359   public void testFirst_null() {
360     List&lt;String&gt; list = Lists.newArrayList(null, "a", "b");
361     try {
362       FluentIterable.from(list).first();
363       fail();
364     } catch (NullPointerException expected) {
365     }
366   }
367   public void testFirst_emptyList() {
368     List&lt;String&gt; list = Collections.emptyList();
369     assertThat(FluentIterable.from(list).first()).isAbsent();
370   }
371   public void testFirst_sortedSet() {
372     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of("b", "c", "a");
373     assertThat(FluentIterable.from(sortedSet).first()).hasValue("a");
374   }
375   public void testFirst_emptySortedSet() {
376     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of();
377     assertThat(FluentIterable.from(sortedSet).first()).isAbsent();
378   }
379   public void testFirst_iterable() {
380     Set&lt;String&gt; set = ImmutableSet.of("a", "b", "c");
381     assertThat(FluentIterable.from(set).first()).hasValue("a");
382   }
383   public void testFirst_emptyIterable() {
384     Set&lt;String&gt; set = Sets.newHashSet();
385     assertThat(FluentIterable.from(set).first()).isAbsent();
386   }
387   public void testLast_list() {
388     List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
389     assertThat(FluentIterable.from(list).last()).hasValue("c");
390   }
391   public void testLast_null() {
392     List&lt;String&gt; list = Lists.newArrayList("a", "b", null);
393     try {
394       FluentIterable.from(list).last();
395       fail();
396     } catch (NullPointerException expected) {
397     }
398   }
399   public void testLast_emptyList() {
400     List&lt;String&gt; list = Collections.emptyList();
401     assertThat(FluentIterable.from(list).last()).isAbsent();
402   }
403   public void testLast_sortedSet() {
404     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of("b", "c", "a");
405     assertThat(FluentIterable.from(sortedSet).last()).hasValue("c");
406   }
407   public void testLast_emptySortedSet() {
408     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of();
409     assertThat(FluentIterable.from(sortedSet).last()).isAbsent();
410   }
411   public void testLast_iterable() {
412     Set&lt;String&gt; set = ImmutableSet.of("a", "b", "c");
413     assertThat(FluentIterable.from(set).last()).hasValue("c");
414   }
415   public void testLast_emptyIterable() {
416     Set&lt;String&gt; set = Sets.newHashSet();
417     assertThat(FluentIterable.from(set).last()).isAbsent();
418   }
419   public void testSkip_simple() {
420     Collection&lt;String&gt; set = ImmutableSet.of("a", "b", "c", "d", "e");
421     assertEquals(
422         Lists.newArrayList("c", "d", "e"), Lists.newArrayList(FluentIterable.from(set).skip(2)));
423     assertEquals("[c, d, e]", FluentIterable.from(set).skip(2).toString());
424   }
425   public void testSkip_simpleList() {
426     Collection&lt;String&gt; list = Lists.newArrayList("a", "b", "c", "d", "e");
427     assertEquals(
428         Lists.newArrayList("c", "d", "e"), Lists.newArrayList(FluentIterable.from(list).skip(2)));
429     assertEquals("[c, d, e]", FluentIterable.from(list).skip(2).toString());
430   }
431   public void testSkip_pastEnd() {
432     Collection&lt;String&gt; set = ImmutableSet.of("a", "b");
433     assertEquals(Collections.emptyList(), Lists.newArrayList(FluentIterable.from(set).skip(20)));
434   }
435   public void testSkip_pastEndList() {
436     Collection&lt;String&gt; list = Lists.newArrayList("a", "b");
437     assertEquals(Collections.emptyList(), Lists.newArrayList(FluentIterable.from(list).skip(20)));
438   }
439   public void testSkip_skipNone() {
440     Collection&lt;String&gt; set = ImmutableSet.of("a", "b");
441     assertEquals(
442         Lists.newArrayList("a", "b"), Lists.newArrayList(FluentIterable.from(set).skip(0)));
443   }
444   public void testSkip_skipNoneList() {
445     Collection&lt;String&gt; list = Lists.newArrayList("a", "b");
446     assertEquals(
447         Lists.newArrayList("a", "b"), Lists.newArrayList(FluentIterable.from(list).skip(0)));
448   }
449   public void testSkip_iterator() throws Exception {
450     new IteratorTester&lt;Integer&gt;(
451         5,
452         IteratorFeature.MODIFIABLE,
453         Lists.newArrayList(2, 3),
454         IteratorTester.KnownOrder.KNOWN_ORDER) {
455       @Override
456 <a name="3"></a>      protected Iterator&lt;Integer&gt; newTargetIterator() {
457         Collection&lt;Integer&gt; collection = Sets.newLinkedHashSet();
458         Collections.addAll(collection, 1, 2, 3);
459         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return FluentIterable.from(collection).skip(1).iterator();
460       }
461     }.test();
462   }
463   public void testSkip_</b></font>iteratorList() throws Exception {
464     new IteratorTester&lt;Integer&gt;(
465         5,
466 <a name="5"></a>        IteratorFeature.MODIFIABLE,
467         Lists.newArrayList(2, 3),
468         IteratorTester.KnownOrder.KNOWN_ORDER) {
469       <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
470       protected Iterator&lt;Integer&gt; newTargetIterator() {
471         return FluentIterable.from(Lists.newArrayList(1, 2, 3)).skip(1).iterator();
472       }</b></font>
473     }.test();
474   }
475   public void testSkip_nonStructurallyModifiedList() throws Exception {
476     List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
477     FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(1);
478     Iterator&lt;String&gt; tailIterator = tail.iterator();
479     list.set(2, "c2");
480     assertEquals("b", tailIterator.next());
481     assertEquals("c2", tailIterator.next());
482     assertFalse(tailIterator.hasNext());
483   }
484   public void testSkip_structurallyModifiedSkipSome() throws Exception {
485     Collection&lt;String&gt; set = Sets.newLinkedHashSet();
486     Collections.addAll(set, "a", "b", "c");
487     FluentIterable&lt;String&gt; tail = FluentIterable.from(set).skip(1);
488     set.remove("b");
489     set.addAll(Lists.newArrayList("X", "Y", "Z"));
490     assertThat(tail).containsExactly("c", "X", "Y", "Z").inOrder();
491   }
492   public void testSkip_structurallyModifiedSkipSomeList() throws Exception {
493     List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
494     FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(1);
495     list.subList(1, 3).clear();
496     list.addAll(0, Lists.newArrayList("X", "Y", "Z"));
497     assertThat(tail).containsExactly("Y", "Z", "a").inOrder();
498   }
499   public void testSkip_structurallyModifiedSkipAll() throws Exception {
500     Collection&lt;String&gt; set = Sets.newLinkedHashSet();
501     Collections.addAll(set, "a", "b", "c");
502     FluentIterable&lt;String&gt; tail = FluentIterable.from(set).skip(2);
503     set.remove("a");
504     set.remove("b");
505     assertFalse(tail.iterator().hasNext());
506   }
507   public void testSkip_structurallyModifiedSkipAllList() throws Exception {
508     List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
509     FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(2);
510     list.subList(0, 2).clear();
511     assertThat(tail).isEmpty();
512   }
513   public void testSkip_illegalArgument() {
514     try {
515       FluentIterable.from(asList("a", "b", "c")).skip(-1);
516       fail("Skipping negative number of elements should throw IllegalArgumentException.");
517     } catch (IllegalArgumentException expected) {
518     }
519   }
520   public void testLimit() {
521     Iterable&lt;String&gt; iterable = Lists.newArrayList("foo", "bar", "baz");
522     FluentIterable&lt;String&gt; limited = FluentIterable.from(iterable).limit(2);
523     assertEquals(ImmutableList.of("foo", "bar"), Lists.newArrayList(limited));
524     assertCanIterateAgain(limited);
525     assertEquals("[foo, bar]", limited.toString());
526   }
527   public void testLimit_illegalArgument() {
528     try {
529       FluentIterable&lt;String&gt; unused =
530           FluentIterable.from(Lists.newArrayList("a", "b", "c")).limit(-1);
531       fail("Passing negative number to limit(...) method should throw IllegalArgumentException");
532     } catch (IllegalArgumentException expected) {
533     }
534   }
535   public void testIsEmpty() {
536     assertTrue(FluentIterable.&lt;String&gt;from(Collections.&lt;String&gt;emptyList()).isEmpty());
537     assertFalse(FluentIterable.&lt;String&gt;from(Lists.newArrayList("foo")).isEmpty());
538   }
539   public void testToList() {
540     assertEquals(Lists.newArrayList(1, 2, 3, 4), fluent(1, 2, 3, 4).toList());
541   }
542   public void testToList_empty() {
543     assertTrue(fluent().toList().isEmpty());
544   }
545   public void testToSortedList_withComparator() {
546     assertEquals(
547         Lists.newArrayList(4, 3, 2, 1),
548         fluent(4, 1, 3, 2).toSortedList(Ordering.&lt;Integer&gt;natural().reverse()));
549   }
550   public void testToSortedList_withDuplicates() {
551     assertEquals(
552         Lists.newArrayList(4, 3, 1, 1),
553         fluent(1, 4, 1, 3).toSortedList(Ordering.&lt;Integer&gt;natural().reverse()));
554   }
555   public void testToSet() {
556     assertThat(fluent(1, 2, 3, 4).toSet()).containsExactly(1, 2, 3, 4).inOrder();
557   }
558   public void testToSet_removeDuplicates() {
559     assertThat(fluent(1, 2, 1, 2).toSet()).containsExactly(1, 2).inOrder();
560   }
561   public void testToSet_empty() {
562     assertTrue(fluent().toSet().isEmpty());
563   }
564   public void testToSortedSet() {
565     assertThat(fluent(1, 4, 2, 3).toSortedSet(Ordering.&lt;Integer&gt;natural().reverse()))
566         .containsExactly(4, 3, 2, 1)
567         .inOrder();
568   }
569   public void testToSortedSet_removeDuplicates() {
570     assertThat(fluent(1, 4, 1, 3).toSortedSet(Ordering.&lt;Integer&gt;natural().reverse()))
571         .containsExactly(4, 3, 1)
572         .inOrder();
573   }
574   public void testToMultiset() {
575     assertThat(fluent(1, 2, 1, 3, 2, 4).toMultiset()).containsExactly(1, 1, 2, 2, 3, 4).inOrder();
576   }
577   public void testToMultiset_empty() {
578     assertThat(fluent().toMultiset()).isEmpty();
579   }
580   public void testToMap() {
581     assertThat(fluent(1, 2, 3).toMap(Functions.toStringFunction()).entrySet())
582         .containsExactly(
583             Maps.immutableEntry(1, "1"), Maps.immutableEntry(2, "2"), Maps.immutableEntry(3, "3"))
584         .inOrder();
585   }
586   public void testToMap_nullKey() {
587     try {
588       fluent(1, null, 2).toMap(Functions.constant("foo"));
589       fail();
590     } catch (NullPointerException expected) {
591     }
592   }
593   public void testToMap_nullValue() {
594     try {
595       fluent(1, 2, 3).toMap(Functions.constant(null));
596       fail();
597     } catch (NullPointerException expected) {
598     }
599   }
600   public void testIndex() {
601     ImmutableListMultimap&lt;Integer, String&gt; expected =
602         ImmutableListMultimap.&lt;Integer, String&gt;builder()
603             .putAll(3, "one", "two")
604             .put(5, "three")
605             .put(4, "four")
606             .build();
607     ImmutableListMultimap&lt;Integer, String&gt; index =
608         FluentIterable.from(asList("one", "two", "three", "four"))
609             .index(
610                 new Function&lt;String, Integer&gt;() {
611                   @Override
612                   public Integer apply(String input) {
613                     return input.length();
614                   }
615                 });
616     assertEquals(expected, index);
617   }
618   public void testIndex_nullKey() {
619     try {
620       ImmutableListMultimap&lt;Object, Integer&gt; unused =
621           fluent(1, 2, 3).index(Functions.constant(null));
622       fail();
623     } catch (NullPointerException expected) {
624     }
625   }
626   public void testIndex_nullValue() {
627     try {
628       ImmutableListMultimap&lt;String, Integer&gt; unused =
629           fluent(1, null, 2).index(Functions.constant("foo"));
630       fail();
631     } catch (NullPointerException expected) {
632     }
633   }
634   public void testUniqueIndex() {
635     ImmutableMap&lt;Integer, String&gt; expected = ImmutableMap.of(3, "two", 5, "three", 4, "four");
636     ImmutableMap&lt;Integer, String&gt; index =
637         FluentIterable.from(asList("two", "three", "four"))
638             .uniqueIndex(
639                 new Function&lt;String, Integer&gt;() {
640                   @Override
641                   public Integer apply(String input) {
642                     return input.length();
643                   }
644                 });
645     assertEquals(expected, index);
646   }
647   public void testUniqueIndex_duplicateKey() {
648     try {
649       ImmutableMap&lt;Integer, String&gt; unused =
650           FluentIterable.from(asList("one", "two", "three", "four"))
651               .uniqueIndex(
652                   new Function&lt;String, Integer&gt;() {
653                     @Override
654                     public Integer apply(String input) {
655                       return input.length();
656                     }
657                   });
658       fail();
659     } catch (IllegalArgumentException expected) {
660     }
661   }
662   public void testUniqueIndex_nullKey() {
663     try {
664       fluent(1, 2, 3).uniqueIndex(Functions.constant(null));
665       fail();
666     } catch (NullPointerException expected) {
667     }
668   }
669   public void testUniqueIndex_nullValue() {
670     try {
671       ImmutableMap&lt;Object, Integer&gt; unused =
672 <a name="6"></a>          fluent(1, null, 2)
673               .uniqueIndex(
674                   new Function&lt;Integer, Object&gt;() {
675                     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
676                     public Object apply(@Nullable Integer input) {
677                       return String.valueOf(input);
678                     }</b></font>
679                   });
680       fail();
681     } catch (NullPointerException expected) {
682     }
683   }
684   public void testCopyInto_List() {
685     assertThat(fluent(1, 3, 5).copyInto(Lists.newArrayList(1, 2)))
686         .containsExactly(1, 2, 1, 3, 5)
687         .inOrder();
688   }
689   public void testCopyInto_Set() {
690     assertThat(fluent(1, 3, 5).copyInto(Sets.newHashSet(1, 2))).containsExactly(1, 2, 3, 5);
691   }
692   public void testCopyInto_SetAllDuplicates() {
693     assertThat(fluent(1, 3, 5).copyInto(Sets.newHashSet(1, 2, 3, 5))).containsExactly(1, 2, 3, 5);
694   }
695 <a name="1"></a>  public void testCopyInto_NonCollection() {
696     final ArrayList&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);
697     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final ArrayList&lt;Integer&gt; iterList = Lists.newArrayList(9, 8, 7);
698     Iterable&lt;Integer&gt; iterable =
699         new Iterable&lt;Integer&gt;() {
700           @Override
701           public Iterator&lt;Integer&gt; iterator() {
702             return iterList.iterator();
703           }</b></font>
704         };
705     assertThat(FluentIterable.from(iterable).copyInto(list))
706         .containsExactly(1, 2, 3, 9, 8, 7)
707         .inOrder();
708   }
709   public void testJoin() {
710     assertEquals("2,1,3,4", fluent(2, 1, 3, 4).join(Joiner.on(",")));
711   }
712   public void testJoin_empty() {
713     assertEquals("", fluent().join(Joiner.on(",")));
714   }
715   public void testGet() {
716     assertEquals("a", FluentIterable.from(Lists.newArrayList("a", "b", "c")).get(0));
717     assertEquals("b", FluentIterable.from(Lists.newArrayList("a", "b", "c")).get(1));
718     assertEquals("c", FluentIterable.from(Lists.newArrayList("a", "b", "c")).get(2));
719   }
720   public void testGet_outOfBounds() {
721     try {
722       FluentIterable.from(Lists.newArrayList("a", "b", "c")).get(-1);
723       fail();
724     } catch (IndexOutOfBoundsException expected) {
725     }
726     try {
727       FluentIterable.from(Lists.newArrayList("a", "b", "c")).get(3);
728       fail();
729     } catch (IndexOutOfBoundsException expected) {
730     }
731   }
732   /*
733    * Full and proper black-box testing of a Stream-returning method is extremely involved, and is
734    * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and
735    * just test that the toArray() contents are as expected.
736    */
737   public void testStream() {
738     assertThat(FluentIterable.of().stream()).isEmpty();
739     assertThat(FluentIterable.of("a").stream()).containsExactly("a");
740     assertThat(FluentIterable.of(1, 2, 3).stream().filter(n -&gt; n &gt; 1)).containsExactly(2, 3);
741   }
742 <a name="4"></a>
743   static class Help {
744     static IterableSubject assertThat(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Stream&lt;?&gt; stream) {
745       return Truth.assertThat(stream.toArray()).asList();
746     }
747   }
748   private static void a</b></font>ssertCanIterateAgain(Iterable&lt;?&gt; iterable) {
749     for (Object unused : iterable) {
750     }
751   }
752   private static FluentIterable&lt;Integer&gt; fluent(Integer... elements) {
753     return FluentIterable.from(Lists.newArrayList(elements));
754   }
755 <a name="2"></a>  private static Iterable&lt;String&gt; iterable(String... elements) {
756     final List&lt;String&gt; list = asList(elements);
757     return new Iterable&lt;String&gt;() {
758       <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
759       public Iterator&lt;String&gt; iterator() {
760         return list.iterator();
761       }
762     };
763   }</b></font>
764 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
