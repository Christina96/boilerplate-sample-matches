<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Sets_1.java & FluentIterableTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Sets_1.java & FluentIterableTest.java
      </h3>
      <h1 align="center">
        4.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Sets_1.java (3.9428077%)<TH>FluentIterableTest.java (5.7522125%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#0',2,'match1448961-1.html#0',3)" NAME="0">(29-70)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#0',2,'match1448961-1.html#0',3)" NAME="0">(19-54)</A><TD ALIGN=center><FONT COLOR="#ff0000">31</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#1',2,'match1448961-1.html#1',3)" NAME="1">(1406-1412)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#1',2,'match1448961-1.html#1',3)" NAME="1">(883-889)</A><TD ALIGN=center><FONT COLOR="#620000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#2',2,'match1448961-1.html#2',3)" NAME="2">(1744-1749)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#2',2,'match1448961-1.html#2',3)" NAME="2">(956-961)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#3',2,'match1448961-1.html#3',3)" NAME="3">(1725-1730)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#3',2,'match1448961-1.html#3',3)" NAME="3">(608-613)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#4',2,'match1448961-1.html#4',3)" NAME="4">(1272-1330)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#4',2,'match1448961-1.html#4',3)" NAME="4">(938-943)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#5',2,'match1448961-1.html#5',3)" NAME="5">(1206-1208)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#5',2,'match1448961-1.html#5',3)" NAME="5">(619-622)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match1448961-0.html#6',2,'match1448961-1.html#6',3)" NAME="6">(1133-1136)<TD><A HREF="javascript:ZweiFrames('match1448961-0.html#6',2,'match1448961-1.html#6',3)" NAME="6">(856-859)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Sets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
<A NAME="0"></A>import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Collections2.FilteredCollection;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1448961-1.html#0',3,'match1448961-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.math.IntMath;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.function.Consumer;
import java.util.stream.Collector;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts
 * {@link Lists}, {@link Maps} and {@link Queues}.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets&quot;&gt;{@code Sets}&lt;/a&gt;.
 *
 * @author Kevin Bourrillion
 * @author Jared Levy
 * @author Chris Povirk
 * @since 2.0
 */
@GwtCompatible(e</B></FONT>mulated = true)
@ElementTypesAreNonnullByDefault
public final class Sets {
  private Sets() {}

  /**
   * {@link AbstractSet} substitute without the potentially-quadratic {@code removeAll}
   * implementation.
   */
  abstract static class ImprovedAbstractSet&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
      return removeAllImpl(this, c);
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {
      return super.retainAll(checkNotNull(c)); // GWT compatibility
    }
  }

  /**
   * Returns an immutable set instance containing the given enum elements. Internally, the returned
   * set will be backed by an {@link EnumSet}.
   *
   * &lt;p&gt;The iteration order of the returned set follows the enum's iteration order, not the order in
   * which the elements are provided to the method.
   *
   * @param anElement one of the elements the set should contain
   * @param otherElements the rest of the elements the set should contain
   * @return an immutable set containing those elements, minus duplicates
   */
  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
  @GwtCompatible(serializable = true)
  public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(
      E anElement, E... otherElements) {
    return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
  }

  /**
   * Returns an immutable set instance containing the given enum elements. Internally, the returned
   * set will be backed by an {@link EnumSet}.
   *
   * &lt;p&gt;The iteration order of the returned set follows the enum's iteration order, not the order in
   * which the elements appear in the given collection.
   *
   * @param elements the elements, all of the same {@code enum} type, that the set should contain
   * @return an immutable set containing those elements, minus duplicates
   */
  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
  @GwtCompatible(serializable = true)
  public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(Iterable&lt;E&gt; elements) {
    if (elements instanceof ImmutableEnumSet) {
      return (ImmutableEnumSet&lt;E&gt;) elements;
    } else if (elements instanceof Collection) {
      Collection&lt;E&gt; collection = (Collection&lt;E&gt;) elements;
      if (collection.isEmpty()) {
        return ImmutableSet.of();
      } else {
        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
      }
    } else {
      Iterator&lt;E&gt; itr = elements.iterator();
      if (itr.hasNext()) {
        EnumSet&lt;E&gt; enumSet = EnumSet.of(itr.next());
        Iterators.addAll(enumSet, itr);
        return ImmutableEnumSet.asImmutable(enumSet);
      } else {
        return ImmutableSet.of();
      }
    }
  }

  /**
   * Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableSet}
   * with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the
   * resulting set will iterate over elements in their enum definition order, not encounter order.
   *
   * @since 21.0
   */
  public static &lt;E extends Enum&lt;E&gt;&gt; Collector&lt;E, ?, ImmutableSet&lt;E&gt;&gt; toImmutableEnumSet() {
    return CollectCollectors.toImmutableEnumSet();
  }

  /**
   * Returns a new, &lt;i&gt;mutable&lt;/i&gt; {@code EnumSet} instance containing the given elements in their
   * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also
   * accepts non-{@code Collection} iterables and empty iterables.
   */
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(
      Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
    EnumSet&lt;E&gt; set = EnumSet.noneOf(elementType);
    Iterables.addAll(set, iterable);
    return set;
  }

  // HashSet

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt;, initially empty {@code HashSet} instance.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required, use {@link ImmutableSet#of()} instead. If {@code
   * E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly consider
   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get
   * deterministic iteration behavior.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this method is now unnecessary and should be treated as deprecated. Instead,
   * use the {@code HashSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   */
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet() {
    return new HashSet&lt;E&gt;();
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt; {@code HashSet} instance initially containing the given elements.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if elements are non-null and won't be added or removed after this point, use
   * {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an
   * {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider
   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get
   * deterministic iteration behavior.
   *
   * &lt;p&gt;This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList
   * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.
   * This method is not actually very useful and will likely be deprecated in the future.
   */
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
    HashSet&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);
    Collections.addAll(set, elements);
    return set;
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt; {@code HashSet} instance containing the given elements. A very thin
   * convenience for creating an empty set then calling {@link Collection#addAll} or {@link
   * Iterables#addAll}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required and the elements are non-null, use {@link
   * ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link
   * FluentIterable} and call {@code elements.toSet()}.)
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}
   * instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if {@code elements} is a {@link Collection}, you don't need this method.
   * Instead, use the {@code HashSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   *
   * &lt;p&gt;Overall, this method is not very useful and will likely be deprecated in the future.
   */
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
    return (elements instanceof Collection)
        ? new HashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements)
        : newHashSet(elements.iterator());
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt; {@code HashSet} instance containing the given elements. A very thin
   * convenience for creating an empty set and then calling {@link Iterators#addAll}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required and the elements are non-null, use {@link
   * ImmutableSet#copyOf(Iterator)} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}
   * instead.
   *
   * &lt;p&gt;Overall, this method is not very useful and will likely be deprecated in the future.
   */
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
    HashSet&lt;E&gt; set = newHashSet();
    Iterators.addAll(set, elements);
    return set;
  }

  /**
   * Returns a new hash set using the smallest initial table size that can hold {@code expectedSize}
   * elements without resizing. Note that this is not what {@link HashSet#HashSet(int)} does, but it
   * is what most users want and expect it to do.
   *
   * &lt;p&gt;This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.
   *
   * @param expectedSize the number of elements you expect to add to the returned set
   * @return a new, empty hash set with enough capacity to hold {@code expectedSize} elements
   *     without resizing
   * @throws IllegalArgumentException if {@code expectedSize} is negative
   */
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(
      int expectedSize) {
    return new HashSet&lt;E&gt;(Maps.capacity(expectedSize));
  }

  /**
   * Creates a thread-safe set backed by a hash map. The set is backed by a {@link
   * ConcurrentHashMap} instance, and thus carries the same concurrency guarantees.
   *
   * &lt;p&gt;Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The
   * set is serializable.
   *
   * @return a new, empty thread-safe {@code Set}
   * @since 15.0
   */
  public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
    return Platform.newConcurrentHashSet();
  }

  /**
   * Creates a thread-safe set backed by a hash map and containing the given elements. The set is
   * backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency
   * guarantees.
   *
   * &lt;p&gt;Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The
   * set is serializable.
   *
   * @param elements the elements that the set should contain
   * @return a new thread-safe set containing those elements (minus duplicates)
   * @throws NullPointerException if {@code elements} or any of its contents is null
   * @since 15.0
   */
  public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
    Set&lt;E&gt; set = newConcurrentHashSet();
    Iterables.addAll(set, elements);
    return set;
  }

  // LinkedHashSet

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt;, empty {@code LinkedHashSet} instance.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required, use {@link ImmutableSet#of()} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this method is now unnecessary and should be treated as deprecated. Instead,
   * use the {@code LinkedHashSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   *
   * @return a new, empty {@code LinkedHashSet}
   */
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
    return new LinkedHashSet&lt;E&gt;();
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt; {@code LinkedHashSet} instance containing the given elements in order.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required and the elements are non-null, use {@link
   * ImmutableSet#copyOf(Iterable)} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if {@code elements} is a {@link Collection}, you don't need this method.
   * Instead, use the {@code LinkedHashSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   *
   * &lt;p&gt;Overall, this method is not very useful and will likely be deprecated in the future.
   *
   * @param elements the elements that the set should contain, in order
   * @return a new {@code LinkedHashSet} containing those elements (minus duplicates)
   */
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(
      Iterable&lt;? extends E&gt; elements) {
    if (elements instanceof Collection) {
      return new LinkedHashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements);
    }
    LinkedHashSet&lt;E&gt; set = newLinkedHashSet();
    Iterables.addAll(set, elements);
    return set;
  }

  /**
   * Creates a {@code LinkedHashSet} instance, with a high enough &quot;initial capacity&quot; that it
   * &lt;i&gt;should&lt;/i&gt; hold {@code expectedSize} elements without growth. This behavior cannot be
   * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed
   * that the method isn't inadvertently &lt;i&gt;oversizing&lt;/i&gt; the returned set.
   *
   * @param expectedSize the number of elements you expect to add to the returned set
   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold {@code expectedSize}
   *     elements without resizing
   * @throws IllegalArgumentException if {@code expectedSize} is negative
   * @since 11.0
   */
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(
      int expectedSize) {
    return new LinkedHashSet&lt;E&gt;(Maps.capacity(expectedSize));
  }

  // TreeSet

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt;, empty {@code TreeSet} instance sorted by the natural sort ordering of
   * its elements.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required, use {@link ImmutableSortedSet#of()} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this method is now unnecessary and should be treated as deprecated. Instead,
   * use the {@code TreeSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   *
   * @return a new, empty {@code TreeSet}
   */
  public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
    return new TreeSet&lt;E&gt;();
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt; {@code TreeSet} instance containing the given elements sorted by their
   * natural ordering.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required, use {@link ImmutableSortedSet#copyOf(Iterable)}
   * instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; If {@code elements} is a {@code SortedSet} with an explicit comparator, this
   * method has different behavior than {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code
   * TreeSet} with that comparator.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this method is now unnecessary and should be treated as deprecated. Instead,
   * use the {@code TreeSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;.
   *
   * &lt;p&gt;This method is just a small convenience for creating an empty set and then calling {@link
   * Iterables#addAll}. This method is not very useful and will likely be deprecated in the future.
   *
   * @param elements the elements that the set should contain
   * @return a new {@code TreeSet} containing those elements (minus duplicates)
   */
  public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
    TreeSet&lt;E&gt; set = newTreeSet();
    Iterables.addAll(set, elements);
    return set;
  }

  /**
   * Creates a &lt;i&gt;mutable&lt;/i&gt;, empty {@code TreeSet} instance with the given comparator.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if mutability is not required, use {@code
   * ImmutableSortedSet.orderedBy(comparator).build()} instead.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this method is now unnecessary and should be treated as deprecated. Instead,
   * use the {@code TreeSet} constructor directly, taking advantage of &lt;a
   * href=&quot;http://goo.gl/iz2Wi&quot;&gt;&quot;diamond&quot; syntax&lt;/a&gt;. One caveat to this is that the {@code TreeSet}
   * constructor uses a null {@code Comparator} to mean &quot;natural ordering,&quot; whereas this factory
   * rejects null. Clean your code accordingly.
   *
   * @param comparator the comparator to use to sort the set
   * @return a new, empty {@code TreeSet}
   * @throws NullPointerException if {@code comparator} is null
   */
  public static &lt;E extends @Nullable Object&gt; TreeSet&lt;E&gt; newTreeSet(
      Comparator&lt;? super E&gt; comparator) {
    return new TreeSet&lt;E&gt;(checkNotNull(comparator));
  }

  /**
   * Creates an empty {@code Set} that uses identity to determine equality. It compares object
   * references, instead of calling {@code equals}, to determine whether a provided object matches
   * an element in the set. For example, {@code contains} returns {@code false} when passed an
   * object that equals a set member, but isn't the same instance. This behavior is similar to the
   * way {@code IdentityHashMap} handles key lookups.
   *
   * @since 8.0
   */
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newIdentityHashSet() {
    return Collections.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());
  }

  /**
   * Creates an empty {@code CopyOnWriteArraySet} instance.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; if you need an immutable empty {@link Set}, use {@link Collections#emptySet}
   * instead.
   *
   * @return a new, empty {@code CopyOnWriteArraySet}
   * @since 12.0
   */
  @GwtIncompatible // CopyOnWriteArraySet
  public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
    return new CopyOnWriteArraySet&lt;E&gt;();
  }

  /**
   * Creates a {@code CopyOnWriteArraySet} instance containing the given elements.
   *
   * @param elements the elements that the set should contain, in order
   * @return a new {@code CopyOnWriteArraySet} containing those elements
   * @since 12.0
   */
  @GwtIncompatible // CopyOnWriteArraySet
  public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(
      Iterable&lt;? extends E&gt; elements) {
    // We copy elements to an ArrayList first, rather than incurring the
    // quadratic cost of adding them to the COWAS directly.
    Collection&lt;? extends E&gt; elementsCollection =
        (elements instanceof Collection)
            ? (Collection&lt;? extends E&gt;) elements
            : Lists.newArrayList(elements);
    return new CopyOnWriteArraySet&lt;E&gt;(elementsCollection);
  }

  /**
   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified
   * collection. If the collection is an {@link EnumSet}, this method has the same behavior as
   * {@link EnumSet#complementOf}. Otherwise, the specified collection must contain at least one
   * element, in order to determine the element type. If the collection could be empty, use {@link
   * #complementOf(Collection, Class)} instead of this method.
   *
   * @param collection the collection whose complement should be stored in the enum set
   * @return a new, modifiable {@code EnumSet} containing all values of the enum that aren't present
   *     in the given collection
   * @throws IllegalArgumentException if {@code collection} is not an {@code EnumSet} instance and
   *     contains no elements
   */
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
    if (collection instanceof EnumSet) {
      return EnumSet.complementOf((EnumSet&lt;E&gt;) collection);
    }
    checkArgument(
        !collection.isEmpty(), &quot;collection is empty; use the other version of this method&quot;);
    Class&lt;E&gt; type = collection.iterator().next().getDeclaringClass();
    return makeComplementByHand(collection, type);
  }

  /**
   * Creates an {@code EnumSet} consisting of all enum values that are not in the specified
   * collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input
   * collection, as long as the elements are of enum type.
   *
   * @param collection the collection whose complement should be stored in the {@code EnumSet}
   * @param type the type of the elements in the set
   * @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not
   *     present in the given collection
   */
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(
      Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
    checkNotNull(collection);
    return (collection instanceof EnumSet)
        ? EnumSet.complementOf((EnumSet&lt;E&gt;) collection)
        : makeComplementByHand(collection, type);
  }

  private static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; makeComplementByHand(
      Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
    EnumSet&lt;E&gt; result = EnumSet.allOf(type);
    result.removeAll(collection);
    return result;
  }

  /**
   * Returns a set backed by the specified map. The resulting set displays the same ordering,
   * concurrency, and performance characteristics as the backing map. In essence, this factory
   * method provides a {@link Set} implementation corresponding to any {@link Map} implementation.
   * There is no need to use this method on a {@link Map} implementation that already has a
   * corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link
   * java.util.TreeMap}).
   *
   * &lt;p&gt;Each method invocation on the set returned by this method results in exactly one method
   * invocation on the backing map or its {@code keySet} view, with one exception. The {@code
   * addAll} method is implemented as a sequence of {@code put} invocations on the backing map.
   *
   * &lt;p&gt;The specified map must be empty at the time this method is invoked, and should not be
   * accessed directly after this method returns. These conditions are ensured if the map is created
   * empty, passed directly to this method, and no reference to the map is retained, as illustrated
   * in the following code fragment:
   *
   * &lt;pre&gt;{@code
   * Set&lt;Object&gt; identityHashSet = Sets.newSetFromMap(
   *     new IdentityHashMap&lt;Object, Boolean&gt;());
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;The returned set is serializable if the backing map is.
   *
   * @param map the backing map
   * @return the set backed by the map
   * @throws IllegalArgumentException if {@code map} is not empty
   * @deprecated Use {@link Collections#newSetFromMap} instead.
   */
  @Deprecated
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newSetFromMap(
      Map&lt;E, Boolean&gt; map) {
    return Collections.newSetFromMap(map);
  }

  /**
   * An unmodifiable view of a set which may be backed by other sets; this view will change as the
   * backing sets do. Contains methods to copy the data into a new set which will then remain
   * stable. There is usually no reason to retain a reference of type {@code SetView}; typically,
   * you either use it as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or
   * {@link #copyInto} and forget the {@code SetView} itself.
   *
   * @since 2.0
   */
  public abstract static class SetView&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
    private SetView() {} // no subclasses but our own

    /**
     * Returns an immutable copy of the current contents of this set view. Does not support null
     * elements.
     *
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; this may have unexpected results if a backing set of this view uses a
     * nonstandard notion of equivalence, for example if it is a {@link TreeSet} using a comparator
     * that is inconsistent with {@link Object#equals(Object)}.
     */
    @SuppressWarnings(&quot;nullness&quot;) // Unsafe, but we can't fix it now.
    public ImmutableSet&lt;E&gt; immutableCopy() {
      return ImmutableSet.copyOf(this);
    }

    /**
     * Copies the current contents of this set view into an existing set. This method has equivalent
     * behavior to {@code set.addAll(this)}, assuming that all the sets involved are based on the
     * same notion of equivalence.
     *
     * @return a reference to {@code set}, for convenience
     */
    // Note: S should logically extend Set&lt;? super E&gt; but can't due to either
    // some javac bug or some weirdness in the spec, not sure which.
    @CanIgnoreReturnValue
    public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
      set.addAll(this);
      return set;
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean add(@ParametricNullness E e) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean remove(@CheckForNull Object object) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean addAll(Collection&lt;? extends E&gt; newElements) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean removeAll(Collection&lt;?&gt; oldElements) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final boolean retainAll(Collection&lt;?&gt; elementsToKeep) {
      throw new UnsupportedOperationException();
    }

    /**
     * Guaranteed to throw an exception and leave the collection unmodified.
     *
     * @throws UnsupportedOperationException always
     * @deprecated Unsupported operation.
     */
    @Deprecated
    @Override
    @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
    public final void clear() {
      throw new UnsupportedOperationException();
    }

    /**
     * Scope the return type to {@link UnmodifiableIterator} to ensure this is an unmodifiable view.
     *
     * @since 20.0 (present with return type {@link Iterator} since 2.0)
     */
    @Override
    public abstract UnmodifiableIterator&lt;E&gt; iterator();
  }

  /**
   * Returns an unmodifiable &lt;b&gt;view&lt;/b&gt; of the union of two sets. The returned set contains all
   * elements that are contained in either backing set. Iterating over the returned set iterates
   * first over all the elements of {@code set1}, then over each element of {@code set2}, in order,
   * that is not contained in {@code set1}.
   *
   * &lt;p&gt;Results are undefined if {@code set1} and {@code set2} are sets based on different
   * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
   * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
   */
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; union(
      final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
    checkNotNull(set1, &quot;set1&quot;);
    checkNotNull(set2, &quot;set2&quot;);

    return new SetView&lt;E&gt;() {
      @Override
      public int size() {
        int size = set1.size();
        for (E e : set2) {
          if (!set1.contains(e)) {
            size++;
          }
        }
        return size;
      }

      @Override
      public boolean isEmpty() {
        return set1.isEmpty() &amp;&amp; set2.isEmpty();
      }

      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
          final Iterator&lt;? extends E&gt; itr2 = set2.iterator();

          @Override
          @CheckForNull
          protected E computeNext() {
            if (itr1.hasNext()) {
              return itr1.next();
            }
            while (itr2.hasNext()) {
              E e = itr2.next();
              if (!set1.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      public Stream&lt;E&gt; stream() {
        return Stream.concat(set1.stream(), set2.stream().filter((E e) -&gt; !set1.contains(e)));
      }

      @Override
      public Stream&lt;E&gt; parallelStream() {
        return stream().parallel();
      }

      @Override
      public boolean contains(@CheckForNull Object object) {
        return set1.contains(object) || set2.contains(object);
      }

      @Override
      public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
        set.addAll(set1);
        set.addAll(set2);
        return set;
      }

      @Override
      @SuppressWarnings(&quot;nullness&quot;) // see supertype
      public ImmutableSet&lt;E&gt; immutableCopy() {
        return new ImmutableSet.Builder&lt;E&gt;().addAll(set1).addAll(set2).build();
      }
    };
  }

  /**
   * Returns an unmodifiable &lt;b&gt;view&lt;/b&gt; of the intersection of two sets. The returned set contains
   * all elements that are contained by both backing sets. The iteration order of the returned set
   * matches that of {@code set1}.
   *
   * &lt;p&gt;Results are undefined if {@code set1} and {@code set2} are sets based on different
   * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
   * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The returned view performs slightly better when {@code set1} is the smaller of
   * the two sets. If you have reason to believe one of your sets will generally be smaller than the
   * other, pass it first. Unfortunately, since this method sets the generic type of the returned
   * set based on the type of the first set passed, this could in rare cases force you to make a
   * cast, for example:
   *
   * &lt;pre&gt;{@code
   * Set&lt;Object&gt; aFewBadObjects = ...
   * Set&lt;String&gt; manyBadStrings = ...
   *
   * // impossible for a non-String to be in the intersection
   * SuppressWarnings(&quot;unchecked&quot;)
   * Set&lt;String&gt; badStrings = (Set) Sets.intersection(
   *     aFewBadObjects, manyBadStrings);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;This is unfortunate, but should come up only very rarely.
   */
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; intersection(
      final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    checkNotNull(set1, &quot;set1&quot;);
    checkNotNull(set2, &quot;set2&quot;);

    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;E&gt; itr = set1.iterator();

          @Override
          @CheckForNull
          protected E computeNext() {
            while (itr.hasNext()) {
              E e = itr.next();
              if (set2.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      public Stream&lt;E&gt; stream() {
        return set1.stream().filter(set2::contains);
      }

      @Override
      public Stream&lt;E&gt; parallelStream() {
        return set1.parallelStream().filter(set2::contains);
      }

      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (set2.contains(e)) {
            size++;
          }
        }
        return size;
      }

      @Override
      public boolean isEmpty() {
        return Collections.disjoint(set2, set1);
      }

      @Override
      public boolean contains(@CheckForNull Object object) {
        return set1.contains(object) &amp;&amp; set2.contains(object);
      }

      @Override
      public boolean containsAll(Collection&lt;?&gt; collection) {
        return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
      }
    };
  }

  /**
   * Returns an unmodifiable &lt;b&gt;view&lt;/b&gt; of the difference of two sets. The returned set contains
   * all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}
   * may also contain elements not present in {@code set1}; these are simply ignored. The iteration
   * order of the returned set matches that of {@code set1}.
   *
   * &lt;p&gt;Results are undefined if {@code set1} and {@code set2} are sets based on different
   * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
   * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
   */
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; difference(
      final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    checkNotNull(set1, &quot;set1&quot;);
    checkNotNull(set2, &quot;set2&quot;);

    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;E&gt; itr = set1.iterator();

          @Override
          @CheckForNull
          protected E computeNext() {
            while (itr.hasNext()) {
              E e = itr.next();
              if (!set2.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      public Stream&lt;E&gt; stream() {
        return set1.stream().filter(e -&gt; !set2.contains(e));
      }

      @Override
      public Stream&lt;E&gt; parallelStream() {
        return set1.parallelStream().filter(e -&gt; !set2.contains(e));
      }

      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (!set2.contains(e)) {
            size++;
          }
        }
        return size;
      }

      @Override
      public boolean isEmpty() {
        return set2.containsAll(set1);
      }

      @Override
      public boolean contains(@CheckForNull Object element) {
        return set1.contains(element) &amp;&amp; !set2.contains(element);
      }
    };
  }

  /**
   * Returns an unmodifiable &lt;b&gt;view&lt;/b&gt; of the symmetric difference of two sets. The returned set
   * contains all elements that are contained in either {@code set1} or {@code set2} but not in
   * both. The iteration order of the returned set is undefined.
   *
   * &lt;p&gt;Results are undefined if {@code set1} and {@code set2} are sets based on different
   * equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
   * {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.
   *
   * @since 3.0
   */
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; symmetricDifference(
      final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
    checkNotNull(set1, &quot;set1&quot;);
    checkNotNull(set2, &quot;set2&quot;);

    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
        final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
        return new AbstractIterator&lt;E&gt;() {
          @Override
          @CheckForNull
          public E computeNext() {
            while (itr1.hasNext()) {
              E elem1 = itr1.next();
              if (!set2.contains(elem1)) {
                return elem1;
              }
            }
            while (itr2.hasNext()) {
              E elem2 = itr2.next();
              if (!set1.contains(elem2)) {
                return elem2;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (!set2.contains(e)) {
            size++;
          }
        }
        for (E e : set2) {
          if (!set1.contains(e)) {
            size++;
          }
        }
        return size;
      }

      @Override
      public boolean isEmpty() {
        return set1.equals(set2);
      }

      @Override
      public boolean contains(@CheckForNull Object element) {
        return set1.contains(element) ^ set2.contains(element);
      }
    };
  }

  /**
   * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned set is a live
   * view of {@code unfiltered}; changes to one affect the other.
   *
   * &lt;p&gt;The resulting set's iterator does not support {@code remove()}, but all other set methods
   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code
   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
   * that satisfy the filter will be removed from the underlying set.
   *
   * &lt;p&gt;The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * &lt;p&gt;Many of the filtered set's methods, such as {@code size()}, iterate across every element in
   * the underlying set and determine which elements satisfy the filter. When a live view is
   * &lt;i&gt;not&lt;/i&gt; needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
   * use the copy.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code predicate} must be &lt;i&gt;consistent with equals&lt;/i&gt;, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * &lt;p&gt;&lt;b&gt;Java 8 users:&lt;/b&gt; many use cases for this method are better addressed by {@link
   * java.util.stream.Stream#filter}. This method is not being deprecated, but we gently encourage
   * you to migrate to streams.
   */
  // TODO(kevinb): how to omit that last sentence when building GWT javadoc?
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; filter(
      Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof SortedSet) {
      return filter((SortedSet&lt;E&gt;) unfiltered, predicate);
    }
    if (unfiltered instanceof FilteredSet) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredSet&lt;E&gt;((Set&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }

    return new FilteredSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }

  /**
   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that satisfy a predicate. The
   * returned set is a live view of {@code unfiltered}; changes to one affect the other.
   *
   * &lt;p&gt;The resulting set's iterator does not support {@code remove()}, but all other set methods
   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code
   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
   * that satisfy the filter will be removed from the underlying set.
   *
   * &lt;p&gt;The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * &lt;p&gt;Many of the filtered set's methods, such as {@code size()}, iterate across every element in
   * the underlying set and determine which elements satisfy the filter. When a live view is
   * &lt;i&gt;not&lt;/i&gt; needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
   * use the copy.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code predicate} must be &lt;i&gt;consistent with equals&lt;/i&gt;, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * @since 11.0
   */
  public static &lt;E extends @Nullable Object&gt; SortedSet&lt;E&gt; filter(
      SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredSet) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredSortedSet&lt;E&gt;((SortedSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }

    return new FilteredSortedSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }

  /**
   * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.
   * The returned set is a live view of {@code unfiltered}; changes to one affect the other.
   *
   * &lt;p&gt;The resulting set's iterator does not support {@code remove()}, but all other set methods
   * are supported. When given an element that doesn't satisfy the predicate, the set's {@code
   * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
   * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
   * that satisfy the filter will be removed from the underlying set.
   *
   * &lt;p&gt;The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * &lt;p&gt;Many of the filtered set's methods, such as {@code size()}, iterate across every element in
   * the underlying set and determine which elements satisfy the filter. When a live view is
   * &lt;i&gt;not&lt;/i&gt; needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
   * use the copy.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code predicate} must be &lt;i&gt;consistent with equals&lt;/i&gt;, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * @since 14.0
   */
  @GwtIncompatible // NavigableSet
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; filter(
      NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredSet) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredNavigableSet&lt;E&gt;((NavigableSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }

    return new FilteredNavigableSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }

  private static class FilteredSet&lt;E extends @Nullable Object&gt; extends FilteredCollection&lt;E&gt;
      implements Set&lt;E&gt; {
    FilteredSet(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
<A NAME="6"></A>      super(unfiltered, predicate);
    }

    <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match1448961-1.html#6',3,'match1448961-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    public boolean equals(@CheckForNull Object object) {
      return equalsImpl(this, object);
    }</B></FONT>

    @Override
    public int hashCode() {
      return hashCodeImpl(this);
    }
  }

  private static class FilteredSortedSet&lt;E extends @Nullable Object&gt; extends FilteredSet&lt;E&gt;
      implements SortedSet&lt;E&gt; {

    FilteredSortedSet(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      super(unfiltered, predicate);
    }

    @Override
    @CheckForNull
    public Comparator&lt;? super E&gt; comparator() {
      return ((SortedSet&lt;E&gt;) unfiltered).comparator();
    }

    @Override
    public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
      return new FilteredSortedSet&lt;E&gt;(
          ((SortedSet&lt;E&gt;) unfiltered).subSet(fromElement, toElement), predicate);
    }

    @Override
    public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
      return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).headSet(toElement), predicate);
    }

    @Override
    public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
      return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).tailSet(fromElement), predicate);
    }

    @Override
    @ParametricNullness
    public E first() {
      return Iterators.find(unfiltered.iterator(), predicate);
    }

    @Override
    @ParametricNullness
    public E last() {
      SortedSet&lt;E&gt; sortedUnfiltered = (SortedSet&lt;E&gt;) unfiltered;
      while (true) {
        E element = sortedUnfiltered.last();
        if (predicate.apply(element)) {
          return element;
        }
        sortedUnfiltered = sortedUnfiltered.headSet(element);
      }
    }
  }

  @GwtIncompatible // NavigableSet
  private static class FilteredNavigableSet&lt;E extends @Nullable Object&gt; extends FilteredSortedSet&lt;E&gt;
      implements NavigableSet&lt;E&gt; {
    FilteredNavigableSet(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      super(unfiltered, predicate);
    }

    NavigableSet&lt;E&gt; unfiltered() {
      return (NavigableSet&lt;E&gt;) unfiltered;
    }
<A NAME="5"></A>
    @Override
    @CheckForNull
    public E lower(<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1448961-1.html#5',3,'match1448961-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@ParametricNullness E e) {
      return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
    }</B></FONT>

    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
    }

    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
    }

    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
    }

    @Override
    @CheckForNull
    public E pollFirst() {
      return Iterables.removeFirstMatching(unfiltered(), predicate);
    }

    @Override
    @CheckForNull
    public E pollLast() {
      return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
    }

    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      return Sets.filter(unfiltered().descendingSet(), predicate);
    }

    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return Iterators.filter(unfiltered().descendingIterator(), predicate);
    }

    @Override
    @ParametricNullness
    public E last() {
      return Iterators.find(unfiltered().descendingIterator(), predicate);
    }

    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return filter(
          unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);
    }

    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return filter(unfiltered().headSet(toElement, inclusive), predicate);
<A NAME="4"></A>    }

    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1448961-1.html#4',3,'match1448961-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>boolean inclusive) {
      return filter(unfiltered().tailSet(fromElement, inclusive), predicate);
    }
  }

  /**
   * Returns every possible list that can be formed by choosing one element from each of the given
   * sets in order; the &quot;n-ary &lt;a href=&quot;http://en.wikipedia.org/wiki/Cartesian_product&quot;&gt;Cartesian
   * product&lt;/a&gt;&quot; of the sets. For example:
   *
   * &lt;pre&gt;{@code
   * Sets.cartesianProduct(ImmutableList.of(
   *     ImmutableSet.of(1, 2),
   *     ImmutableSet.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)))
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;returns a set containing six lists:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;A&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;B&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;C&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;A&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;B&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;C&quot;)}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;The result is guaranteed to be in the &quot;traditional&quot;, lexicographical order for Cartesian
   * products that you would get from nesting for loops:
   *
   * &lt;pre&gt;{@code
   * for (B b0 : sets.get(0)) {
   *   for (B b1 : sets.get(1)) {
   *     ...
   *     ImmutableList&lt;B&gt; tuple = ImmutableList.of(b0, b1, ...);
   *     // operate on tuple
   *   }
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
   * all are provided (an empty list), the resulting Cartesian product has one element, an empty
   * list (counter-intuitive, but mathematically consistent).
   *
   * &lt;p&gt;&lt;i&gt;Performance notes:&lt;/i&gt; while the cartesian product of sets of size {@code m, n, p} is a
   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the
   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
   * iterated are the individual lists created, and these are not retained after iteration.
   *
   * @param sets the sets to choose elements from, in the order that the elements chosen from those
   *     sets should appear in the resulting lists
   * @param &lt;B&gt; any common base class shared by all axes (often just {@link Object})
   * @return the Cartesian product, as an immutable set containing immutable lists
   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a
   *     provided set is null
   * @throws IllegalArgumentException if the cartesian product size exceeds the {@code int} range
   * @since 2.0
   */
  public static &lt;B</B></FONT>&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets) {
    return CartesianSet.create(sets);
  }

  /**
   * Returns every possible list that can be formed by choosing one element from each of the given
   * sets in order; the &quot;n-ary &lt;a href=&quot;http://en.wikipedia.org/wiki/Cartesian_product&quot;&gt;Cartesian
   * product&lt;/a&gt;&quot; of the sets. For example:
   *
   * &lt;pre&gt;{@code
   * Sets.cartesianProduct(
   *     ImmutableSet.of(1, 2),
   *     ImmutableSet.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;))
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;returns a set containing six lists:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;A&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;B&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(1, &quot;C&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;A&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;B&quot;)}
   *   &lt;li&gt;{@code ImmutableList.of(2, &quot;C&quot;)}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;The result is guaranteed to be in the &quot;traditional&quot;, lexicographical order for Cartesian
   * products that you would get from nesting for loops:
   *
   * &lt;pre&gt;{@code
   * for (B b0 : sets.get(0)) {
   *   for (B b1 : sets.get(1)) {
   *     ...
   *     ImmutableList&lt;B&gt; tuple = ImmutableList.of(b0, b1, ...);
   *     // operate on tuple
   *   }
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
   * all are provided (an empty list), the resulting Cartesian product has one element, an empty
   * list (counter-intuitive, but mathematically consistent).
   *
   * &lt;p&gt;&lt;i&gt;Performance notes:&lt;/i&gt; while the cartesian product of sets of size {@code m, n, p} is a
   * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the
   * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
   * iterated are the individual lists created, and these are not retained after iteration.
   *
   * @param sets the sets to choose elements from, in the order that the elements chosen from those
   *     sets should appear in the resulting lists
   * @param &lt;B&gt; any common base class shared by all axes (often just {@link Object})
   * @return the Cartesian product, as an immutable set containing immutable lists
   * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a
   *     provided set is null
   * @throws IllegalArgumentException if the cartesian product size exceeds the {@code int} range
   * @since 2.0
   */
  @SafeVarargs
  public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets) {
    return cartesianProduct(Arrays.asList(sets));
  }

  private static final class CartesianSet&lt;E&gt; extends ForwardingCollection&lt;List&lt;E&gt;&gt;
      implements Set&lt;List&lt;E&gt;&gt; {
    private final transient ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes;
    private final transient CartesianList&lt;E&gt; delegate;

    static &lt;E&gt; Set&lt;List&lt;E&gt;&gt; create(List&lt;? extends Set&lt;? extends E&gt;&gt; sets) {
      ImmutableList.Builder&lt;ImmutableSet&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder&lt;&gt;(sets.size());
      for (Set&lt;? extends E&gt; set : sets) {
        ImmutableSet&lt;E&gt; copy = ImmutableSet.copyOf(set);
        if (copy.isEmpty()) {
          return ImmutableSet.of();
<A NAME="1"></A>        }
        axesBuilder.add(copy);
      }
      <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1448961-1.html#1',3,'match1448961-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes = axesBuilder.build();
      ImmutableList&lt;List&lt;E&gt;&gt; listAxes =
          new ImmutableList&lt;List&lt;E&gt;&gt;() {
            @Override
            public int size() {
              return axes.size();
            }</B></FONT>

            @Override
            public List&lt;E&gt; get(int index) {
              return axes.get(index).asList();
            }

            @Override
            boolean isPartialView() {
              return true;
            }
          };
      return new CartesianSet&lt;E&gt;(axes, new CartesianList&lt;E&gt;(listAxes));
    }

    private CartesianSet(ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes, CartesianList&lt;E&gt; delegate) {
      this.axes = axes;
      this.delegate = delegate;
    }

    @Override
    protected Collection&lt;List&lt;E&gt;&gt; delegate() {
      return delegate;
    }

    @Override
    public boolean contains(@CheckForNull Object object) {
      if (!(object instanceof List)) {
        return false;
      }
      List&lt;?&gt; list = (List&lt;?&gt;) object;
      if (list.size() != axes.size()) {
        return false;
      }
      int i = 0;
      for (Object o : list) {
        if (!axes.get(i).contains(o)) {
          return false;
        }
        i++;
      }
      return true;
    }

    @Override
    public boolean equals(@CheckForNull Object object) {
      // Warning: this is broken if size() == 0, so it is critical that we
      // substitute an empty ImmutableSet to the user in place of this
      if (object instanceof CartesianSet) {
        CartesianSet&lt;?&gt; that = (CartesianSet&lt;?&gt;) object;
        return this.axes.equals(that.axes);
      }
      return super.equals(object);
    }

    @Override
    public int hashCode() {
      // Warning: this is broken if size() == 0, so it is critical that we
      // substitute an empty ImmutableSet to the user in place of this

      // It's a weird formula, but tests prove it works.
      int adjust = size() - 1;
      for (int i = 0; i &lt; axes.size(); i++) {
        adjust *= 31;
        adjust = ~~adjust;
        // in GWT, we have to deal with integer overflow carefully
      }
      int hash = 1;
      for (Set&lt;E&gt; axis : axes) {
        hash = 31 * hash + (size() / axis.size() * axis.hashCode());

        hash = ~~hash;
      }
      hash += adjust;
      return ~~hash;
    }
  }

  /**
   * Returns the set of all possible subsets of {@code set}. For example, {@code
   * powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}.
   *
   * &lt;p&gt;Elements appear in these subsets in the same iteration order as they appeared in the input
   * set. The order in which these subsets appear in the outer set is undefined. Note that the power
   * set of the empty set is not the empty set, but a one-element set containing the empty set.
   *
   * &lt;p&gt;The returned set and its constituent sets use {@code equals} to decide whether two elements
   * are identical, even if the input set uses a different concept of equivalence.
   *
   * &lt;p&gt;&lt;i&gt;Performance notes:&lt;/i&gt; while the power set of a set with size {@code n} is of size {@code
   * 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set
   * is merely copied. Only as the power set is iterated are the individual subsets created, and
   * these subsets themselves occupy only a small constant amount of memory.
   *
   * @param set the set of elements to construct a power set from
   * @return the power set, as an immutable set of immutable sets
   * @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the
   *     power set size to exceed the {@code int} range)
   * @throws NullPointerException if {@code set} is or contains {@code null}
   * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Power_set&quot;&gt;Power set article at Wikipedia&lt;/a&gt;
   * @since 4.0
   */
  @GwtCompatible(serializable = false)
  public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; powerSet(Set&lt;E&gt; set) {
    return new PowerSet&lt;E&gt;(set);
  }

  private static final class SubSet&lt;E&gt; extends AbstractSet&lt;E&gt; {
    private final ImmutableMap&lt;E, Integer&gt; inputSet;
    private final int mask;

    SubSet(ImmutableMap&lt;E, Integer&gt; inputSet, int mask) {
      this.inputSet = inputSet;
      this.mask = mask;
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return new UnmodifiableIterator&lt;E&gt;() {
        final ImmutableList&lt;E&gt; elements = inputSet.keySet().asList();
        int remainingSetBits = mask;

        @Override
        public boolean hasNext() {
          return remainingSetBits != 0;
        }

        @Override
        public E next() {
          int index = Integer.numberOfTrailingZeros(remainingSetBits);
          if (index == 32) {
            throw new NoSuchElementException();
          }
          remainingSetBits &amp;= ~(1 &lt;&lt; index);
          return elements.get(index);
        }
      };
    }

    @Override
    public int size() {
      return Integer.bitCount(mask);
    }

    @Override
    public boolean contains(@CheckForNull Object o) {
      Integer index = inputSet.get(o);
      return index != null &amp;&amp; (mask &amp; (1 &lt;&lt; index)) != 0;
    }
  }

  private static final class PowerSet&lt;E&gt; extends AbstractSet&lt;Set&lt;E&gt;&gt; {
    final ImmutableMap&lt;E, Integer&gt; inputSet;

    PowerSet(Set&lt;E&gt; input) {
      checkArgument(
          input.size() &lt;= 30, &quot;Too many elements to create power set: %s &gt; 30&quot;, input.size());
      this.inputSet = Maps.indexMap(input);
    }

    @Override
    public int size() {
      return 1 &lt;&lt; inputSet.size();
    }

    @Override
    public boolean isEmpty() {
      return false;
    }

    @Override
    public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
      return new AbstractIndexedListIterator&lt;Set&lt;E&gt;&gt;(size()) {
        @Override
        protected Set&lt;E&gt; get(final int setBits) {
          return new SubSet&lt;E&gt;(inputSet, setBits);
        }
      };
    }

    @Override
    public boolean contains(@CheckForNull Object obj) {
      if (obj instanceof Set) {
        Set&lt;?&gt; set = (Set&lt;?&gt;) obj;
        return inputSet.keySet().containsAll(set);
      }
      return false;
    }

    @Override
    public boolean equals(@CheckForNull Object obj) {
      if (obj instanceof PowerSet) {
        PowerSet&lt;?&gt; that = (PowerSet&lt;?&gt;) obj;
        return inputSet.keySet().equals(that.inputSet.keySet());
      }
      return super.equals(obj);
    }

    @Override
    public int hashCode() {
      /*
       * The sum of the sums of the hash codes in each subset is just the sum of
       * each input element's hash code times the number of sets that element
       * appears in. Each element appears in exactly half of the 2^n sets, so:
       */
      return inputSet.keySet().hashCode() &lt;&lt; (inputSet.size() - 1);
    }

    @Override
    public String toString() {
      return &quot;powerSet(&quot; + inputSet + &quot;)&quot;;
    }
  }

  /**
   * Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code
   * combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}.
   *
   * &lt;p&gt;Elements appear in these subsets in the same iteration order as they appeared in the input
   * set. The order in which these subsets appear in the outer set is undefined.
   *
   * &lt;p&gt;The returned set and its constituent sets use {@code equals} to decide whether two elements
   * are identical, even if the input set uses a different concept of equivalence.
   *
   * &lt;p&gt;&lt;i&gt;Performance notes:&lt;/i&gt; the memory usage of the returned set is only {@code O(n)}. When
   * the result set is constructed, the input set is merely copied. Only as the result set is
   * iterated are the individual subsets created. Each of these subsets occupies an additional O(n)
   * memory but only for as long as the user retains a reference to it. That is, the set returned by
   * {@code combinations} does not retain the individual subsets.
   *
   * @param set the set of elements to take combinations of
   * @param size the number of elements per combination
   * @return the set of all combinations of {@code size} elements from {@code set}
   * @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()}
   *     inclusive
   * @throws NullPointerException if {@code set} is or contains {@code null}
   * @since 23.0
   */
  @Beta
  public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; combinations(Set&lt;E&gt; set, final int size) {
    final ImmutableMap&lt;E, Integer&gt; index = Maps.indexMap(set);
    checkNonnegative(size, &quot;size&quot;);
    checkArgument(size &lt;= index.size(), &quot;size (%s) must be &lt;= set.size() (%s)&quot;, size, index.size());
    if (size == 0) {
      return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(ImmutableSet.&lt;E&gt;of());
    } else if (size == index.size()) {
      return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(index.keySet());
    }
    return new AbstractSet&lt;Set&lt;E&gt;&gt;() {
      @Override
      public boolean contains(@CheckForNull Object o) {
        if (o instanceof Set) {
          Set&lt;?&gt; s = (Set&lt;?&gt;) o;
          return s.size() == size &amp;&amp; index.keySet().containsAll(s);
        }
        return false;
      }

      @Override
      public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
        return new AbstractIterator&lt;Set&lt;E&gt;&gt;() {
          final BitSet bits = new BitSet(index.size());

          @Override
          @CheckForNull
          protected Set&lt;E&gt; computeNext() {
            if (bits.isEmpty()) {
              bits.set(0, size);
            } else {
              int firstSetBit = bits.nextSetBit(0);
              int bitToFlip = bits.nextClearBit(firstSetBit);

              if (bitToFlip == index.size()) {
                return endOfData();
              }

              /*
               * The current set in sorted order looks like
               * {firstSetBit, firstSetBit + 1, ..., bitToFlip - 1, ...}
               * where it does *not* contain bitToFlip.
               *
               * The next combination is
               *
               * {0, 1, ..., bitToFlip - firstSetBit - 2, bitToFlip, ...}
               *
               * This is lexicographically next if you look at the combinations in descending order
               * e.g. {2, 1, 0}, {3, 1, 0}, {3, 2, 0}, {3, 2, 1}, {4, 1, 0}...
               */

              bits.set(0, bitToFlip - firstSetBit - 1);
              bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);
              bits.set(bitToFlip);
            }
            final BitSet copy = (BitSet) bits.clone();
            return new AbstractSet&lt;E&gt;() {
              @Override
              public boolean contains(@CheckForNull Object o) {
                Integer i = index.get(o);
                return i != null &amp;&amp; copy.get(i);
              }

              @Override
              public Iterator&lt;E&gt; iterator() {
                return new AbstractIterator&lt;E&gt;() {
                  int i = -1;

                  @Override
                  @CheckForNull
                  protected E computeNext() {
                    i = copy.nextSetBit(i + 1);
<A NAME="3"></A>                    if (i == -1) {
                      return endOfData();
                    }
                    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1448961-1.html#3',3,'match1448961-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return index.keySet().asList().get(i);
                  }
                };
              }

              @Ove</B></FONT>rride
              public int size() {
                return size;
              }
            };
          }
        };
      }

      @Override
      public int size() {
<A NAME="2"></A>        return IntMath.binomial(index.size(), size);
      }

      <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1448961-1.html#2',3,'match1448961-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
      public String toString() {
        return &quot;Sets.combinations(&quot; + index.keySet() + &quot;, &quot; + size + &quot;)&quot;;
      }
    };
  }</B></FONT>

  /** An implementation for {@link Set#hashCode()}. */
  static int hashCodeImpl(Set&lt;?&gt; s) {
    int hashCode = 0;
    for (Object o : s) {
      hashCode += o != null ? o.hashCode() : 0;

      hashCode = ~~hashCode;
      // Needed to deal with unusual integer overflow in GWT.
    }
    return hashCode;
  }

  /** An implementation for {@link Set#equals(Object)}. */
  static boolean equalsImpl(Set&lt;?&gt; s, @CheckForNull Object object) {
    if (s == object) {
      return true;
    }
    if (object instanceof Set) {
      Set&lt;?&gt; o = (Set&lt;?&gt;) object;

      try {
        return s.size() == o.size() &amp;&amp; s.containsAll(o);
      } catch (NullPointerException | ClassCastException ignored) {
        return false;
      }
    }
    return false;
  }

  /**
   * Returns an unmodifiable view of the specified navigable set. This method allows modules to
   * provide users with &quot;read-only&quot; access to internal navigable sets. Query operations on the
   * returned set &quot;read through&quot; to the specified set, and attempts to modify the returned set,
   * whether direct or via its collection views, result in an {@code UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned navigable set will be serializable if the specified navigable set is
   * serializable.
   *
   * @param set the navigable set for which an unmodifiable view is to be returned
   * @return an unmodifiable view of the specified navigable set
   * @since 12.0
   */
  public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; unmodifiableNavigableSet(
      NavigableSet&lt;E&gt; set) {
    if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
      return set;
    }
    return new UnmodifiableNavigableSet&lt;E&gt;(set);
  }

  static final class UnmodifiableNavigableSet&lt;E extends @Nullable Object&gt;
      extends ForwardingSortedSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Serializable {
    private final NavigableSet&lt;E&gt; delegate;
    private final SortedSet&lt;E&gt; unmodifiableDelegate;

    UnmodifiableNavigableSet(NavigableSet&lt;E&gt; delegate) {
      this.delegate = checkNotNull(delegate);
      this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
    }

    @Override
    protected SortedSet&lt;E&gt; delegate() {
      return unmodifiableDelegate;
    }

    // default methods not forwarded by ForwardingSortedSet

    @Override
    public boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
      throw new UnsupportedOperationException();
    }

    @Override
    public Stream&lt;E&gt; stream() {
      return delegate.stream();
    }

    @Override
    public Stream&lt;E&gt; parallelStream() {
      return delegate.parallelStream();
    }

    @Override
    public void forEach(Consumer&lt;? super E&gt; action) {
      delegate.forEach(action);
    }

    @Override
    @CheckForNull
    public E lower(@ParametricNullness E e) {
      return delegate.lower(e);
    }

    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return delegate.floor(e);
    }

    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return delegate.ceiling(e);
    }

    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return delegate.higher(e);
    }

    @Override
    @CheckForNull
    public E pollFirst() {
      throw new UnsupportedOperationException();
    }

    @Override
    @CheckForNull
    public E pollLast() {
      throw new UnsupportedOperationException();
    }

    @CheckForNull private transient UnmodifiableNavigableSet&lt;E&gt; descendingSet;

    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      UnmodifiableNavigableSet&lt;E&gt; result = descendingSet;
      if (result == null) {
        result = descendingSet = new UnmodifiableNavigableSet&lt;E&gt;(delegate.descendingSet());
        result.descendingSet = this;
      }
      return result;
    }

    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return Iterators.unmodifiableIterator(delegate.descendingIterator());
    }

    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return unmodifiableNavigableSet(
          delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));
    }

    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));
    }

    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
      return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In
   * order to guarantee serial access, it is critical that &lt;b&gt;all&lt;/b&gt; access to the backing
   * navigable set is accomplished through the returned navigable set (or its views).
   *
   * &lt;p&gt;It is imperative that the user manually synchronize on the returned sorted set when
   * iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or
   * {@code tailSet} views.
   *
   * &lt;pre&gt;{@code
   * NavigableSet&lt;E&gt; set = synchronizedNavigableSet(new TreeSet&lt;E&gt;());
   *  ...
   * synchronized (set) {
   *   // Must be in the synchronized block
   *   Iterator&lt;E&gt; it = set.iterator();
   *   while (it.hasNext()) {
   *     foo(it.next());
   *   }
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;or:
   *
   * &lt;pre&gt;{@code
   * NavigableSet&lt;E&gt; set = synchronizedNavigableSet(new TreeSet&lt;E&gt;());
   * NavigableSet&lt;E&gt; set2 = set.descendingSet().headSet(foo);
   *  ...
   * synchronized (set) { // Note: set, not set2!!!
   *   // Must be in the synchronized block
   *   Iterator&lt;E&gt; it = set2.descendingIterator();
   *   while (it.hasNext())
   *     foo(it.next());
   *   }
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Failure to follow this advice may result in non-deterministic behavior.
   *
   * &lt;p&gt;The returned navigable set will be serializable if the specified navigable set is
   * serializable.
   *
   * @param navigableSet the navigable set to be &quot;wrapped&quot; in a synchronized navigable set.
   * @return a synchronized view of the specified navigable set.
   * @since 13.0
   */
  @GwtIncompatible // NavigableSet
  public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; synchronizedNavigableSet(
      NavigableSet&lt;E&gt; navigableSet) {
    return Synchronized.navigableSet(navigableSet);
  }

  /** Remove each element in an iterable from a set. */
  static boolean removeAllImpl(Set&lt;?&gt; set, Iterator&lt;?&gt; iterator) {
    boolean changed = false;
    while (iterator.hasNext()) {
      changed |= set.remove(iterator.next());
    }
    return changed;
  }

  static boolean removeAllImpl(Set&lt;?&gt; set, Collection&lt;?&gt; collection) {
    checkNotNull(collection); // for GWT
    if (collection instanceof Multiset) {
      collection = ((Multiset&lt;?&gt;) collection).elementSet();
    }
    /*
     * AbstractSet.removeAll(List) has quadratic behavior if the list size
     * is just more than the set's size.  We augment the test by
     * assuming that sets have fast contains() performance, and other
     * collections don't.  See
     * http://code.google.com/p/guava-libraries/issues/detail?id=1013
     */
    if (collection instanceof Set &amp;&amp; collection.size() &gt; set.size()) {
      return Iterators.removeAll(set.iterator(), collection);
    } else {
      return removeAllImpl(set, collection.iterator());
    }
  }

  @GwtIncompatible // NavigableSet
  static class DescendingSet&lt;E extends @Nullable Object&gt; extends ForwardingNavigableSet&lt;E&gt; {
    private final NavigableSet&lt;E&gt; forward;

    DescendingSet(NavigableSet&lt;E&gt; forward) {
      this.forward = forward;
    }

    @Override
    protected NavigableSet&lt;E&gt; delegate() {
      return forward;
    }

    @Override
    @CheckForNull
    public E lower(@ParametricNullness E e) {
      return forward.higher(e);
    }

    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return forward.ceiling(e);
    }

    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return forward.floor(e);
    }

    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return forward.lower(e);
    }

    @Override
    @CheckForNull
    public E pollFirst() {
      return forward.pollLast();
    }

    @Override
    @CheckForNull
    public E pollLast() {
      return forward.pollFirst();
    }

    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      return forward;
    }

    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return forward.iterator();
    }

    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
    }

    @Override
    public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
      return standardSubSet(fromElement, toElement);
    }

    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return forward.tailSet(toElement, inclusive).descendingSet();
    }

    @Override
    public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
      return standardHeadSet(toElement);
    }

    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
      return forward.headSet(fromElement, inclusive).descendingSet();
    }

    @Override
    public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
      return standardTailSet(fromElement);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Comparator&lt;? super E&gt; comparator() {
      Comparator&lt;? super E&gt; forwardComparator = forward.comparator();
      if (forwardComparator == null) {
        return (Comparator) Ordering.natural().reverse();
      } else {
        return reverse(forwardComparator);
      }
    }

    // If we inline this, we get a javac error.
    private static &lt;T extends @Nullable Object&gt; Ordering&lt;T&gt; reverse(Comparator&lt;T&gt; forward) {
      return Ordering.from(forward).reverse();
    }

    @Override
    @ParametricNullness
    public E first() {
      return forward.last();
    }

    @Override
    @ParametricNullness
    public E last() {
      return forward.first();
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return forward.descendingIterator();
    }

    @Override
    public @Nullable Object[] toArray() {
      return standardToArray();
    }

    @Override
    @SuppressWarnings(&quot;nullness&quot;) // b/192354773 in our checker affects toArray declarations
    public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
      return standardToArray(array);
    }

    @Override
    public String toString() {
      return standardToString();
    }
  }

  /**
   * Returns a view of the portion of {@code set} whose elements are contained by {@code range}.
   *
   * &lt;p&gt;This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link
   * NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link
   * NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,
   * boolean) headSet()}) to actually construct the view. Consult these methods for a full
   * description of the returned view's behavior.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code Range}s always represent a range of values using the values' natural
   * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link
   * Comparator}, which can violate the natural ordering. Using this method (or in general using
   * {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.
   *
   * @since 20.0
   */
  @Beta
  @GwtIncompatible // NavigableSet
  public static &lt;K extends Comparable&lt;? super K&gt;&gt; NavigableSet&lt;K&gt; subSet(
      NavigableSet&lt;K&gt; set, Range&lt;K&gt; range) {
    if (set.comparator() != null
        &amp;&amp; set.comparator() != Ordering.natural()
        &amp;&amp; range.hasLowerBound()
        &amp;&amp; range.hasUpperBound()) {
      checkArgument(
          set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) &lt;= 0,
          &quot;set is using a custom comparator which is inconsistent with the natural ordering.&quot;);
    }
    if (range.hasLowerBound() &amp;&amp; range.hasUpperBound()) {
      return set.subSet(
          range.lowerEndpoint(),
          range.lowerBoundType() == BoundType.CLOSED,
          range.upperEndpoint(),
          range.upperBoundType() == BoundType.CLOSED);
    } else if (range.hasLowerBound()) {
      return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);
    } else if (range.hasUpperBound()) {
      return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
    }
    return checkNotNull(set);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FluentIterableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.collect;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#0',2,'match1448961-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.collect.FluentIterableTest.Help.assertThat;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.truth.Truth.assertThat;
import static java.util.Arrays.asList;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.testing.IteratorFeature;
import com.google.common.collect.testing.IteratorTester;
import com.google.common.testing.NullPointerTester;
import com.google.common.truth.IterableSubject;
import com.google.common.truth.Truth;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;
import junit.framework.AssertionFailedError;
import junit.framework.TestCase;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Unit test for {@link FluentIterable}.
 *
 * @author Marcin Mikosik
 */
@GwtCompatible(e</B></FONT>mulated = true)
public class FluentIterableTest extends TestCase {

  @GwtIncompatible // NullPointerTester
  public void testNullPointerExceptions() {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(FluentIterable.class);
  }

  public void testFromArrayAndAppend() {
    FluentIterable&lt;TimeUnit&gt; units =
        FluentIterable.from(TimeUnit.values()).append(TimeUnit.SECONDS);
  }

  public void testFromArrayAndIteratorRemove() {
    FluentIterable&lt;TimeUnit&gt; units = FluentIterable.from(TimeUnit.values());
    try {
      Iterables.removeIf(units, Predicates.equalTo(TimeUnit.SECONDS));
      fail(&quot;Expected an UnsupportedOperationException to be thrown but it wasn't.&quot;);
    } catch (UnsupportedOperationException expected) {
    }
  }

  public void testFrom() {
    assertEquals(
        ImmutableList.of(1, 2, 3, 4),
        Lists.newArrayList(FluentIterable.from(ImmutableList.of(1, 2, 3, 4))));
  }

  @SuppressWarnings(&quot;deprecation&quot;) // test of deprecated method
  public void testFrom_alreadyFluentIterable() {
    FluentIterable&lt;Integer&gt; iterable = FluentIterable.from(asList(1));
    assertSame(iterable, FluentIterable.from(iterable));
  }

  public void testOf() {
    assertEquals(ImmutableList.of(1, 2, 3, 4), Lists.newArrayList(FluentIterable.of(1, 2, 3, 4)));
  }

  public void testFromArray() {
    assertEquals(
        ImmutableList.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;),
        Lists.newArrayList(FluentIterable.from(new Object[] {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;})));
  }

  public void testOf_empty() {
    assertEquals(ImmutableList.of(), Lists.newArrayList(FluentIterable.of()));
  }

  // Exhaustive tests are in IteratorsTest. These are copied from IterablesTest.
  public void testConcatIterable() {
    List&lt;Integer&gt; list1 = newArrayList(1);
    List&lt;Integer&gt; list2 = newArrayList(4);

    @SuppressWarnings(&quot;unchecked&quot;)
    List&lt;List&lt;Integer&gt;&gt; input = newArrayList(list1, list2);

    FluentIterable&lt;Integer&gt; result = FluentIterable.concat(input);
    assertEquals(asList(1, 4), newArrayList(result));

    // Now change the inputs and see result dynamically change as well

    list1.add(2);
    List&lt;Integer&gt; list3 = newArrayList(3);
    input.add(1, list3);

    assertEquals(asList(1, 2, 3, 4), newArrayList(result));
    assertEquals(&quot;[1, 2, 3, 4]&quot;, result.toString());
  }

  public void testConcatVarargs() {
    List&lt;Integer&gt; list1 = newArrayList(1);
    List&lt;Integer&gt; list2 = newArrayList(4);
    List&lt;Integer&gt; list3 = newArrayList(7, 8);
    List&lt;Integer&gt; list4 = newArrayList(9);
    List&lt;Integer&gt; list5 = newArrayList(10);
    @SuppressWarnings(&quot;unchecked&quot;)
    FluentIterable&lt;Integer&gt; result = FluentIterable.concat(list1, list2, list3, list4, list5);
    assertEquals(asList(1, 4, 7, 8, 9, 10), newArrayList(result));
    assertEquals(&quot;[1, 4, 7, 8, 9, 10]&quot;, result.toString());
  }

  public void testConcatNullPointerException() {
    List&lt;Integer&gt; list1 = newArrayList(1);
    List&lt;Integer&gt; list2 = newArrayList(4);

    try {
      FluentIterable.concat(list1, null, list2);
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testConcatPeformingFiniteCycle() {
    Iterable&lt;Integer&gt; iterable = asList(1, 2, 3);
    int n = 4;
    FluentIterable&lt;Integer&gt; repeated = FluentIterable.concat(Collections.nCopies(n, iterable));
    assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();
  }

  interface X {}

  interface Y {}

  static class A implements X, Y {}

  static class B implements X, Y {}

  /**
   * This test passes if the {@code concat().filter().filter()} statement at the end compiles.
   * That statement compiles only if {@link FluentIterable#concat concat(aIterable, bIterable)}
   * returns a {@link FluentIterable} of elements of an anonymous type whose supertypes are the &lt;a
   * href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9&quot;&gt;intersection&lt;/a&gt; of
   * the supertypes of {@code A} and the supertypes of {@code B}.
   */
  public void testConcatIntersectionType() {
    Iterable&lt;A&gt; aIterable = ImmutableList.of();
    Iterable&lt;B&gt; bIterable = ImmutableList.of();

    Predicate&lt;X&gt; xPredicate = Predicates.alwaysTrue();
    Predicate&lt;Y&gt; yPredicate = Predicates.alwaysTrue();

    FluentIterable&lt;?&gt; unused =
        FluentIterable.concat(aIterable, bIterable).filter(xPredicate).filter(yPredicate);

    /* The following fails to compile:
     *
     * The method append(Iterable&lt;? extends FluentIterableTest.A&gt;) in the type
     * FluentIterable&lt;FluentIterableTest.A&gt; is not applicable for the arguments
     * (Iterable&lt;FluentIterableTest.B&gt;)
     */
    // FluentIterable.from(aIterable).append(bIterable);

    /* The following fails to compile:
     *
     * The method filter(Predicate&lt;? super Object&gt;) in the type FluentIterable&lt;Object&gt; is not
     * applicable for the arguments (Predicate&lt;FluentIterableTest.X&gt;)
     */
    // FluentIterable.of().append(aIterable).append(bIterable).filter(xPredicate);
  }

  public void testSize0() {
    assertEquals(0, FluentIterable.&lt;String&gt;of().size());
  }

  public void testSize1Collection() {
    assertEquals(1, FluentIterable.from(asList(&quot;a&quot;)).size());
  }

  public void testSize2NonCollection() {
    Iterable&lt;Integer&gt; iterable =
        new Iterable&lt;Integer&gt;() {
          @Override
          public Iterator&lt;Integer&gt; iterator() {
            return asList(0, 1).iterator();
          }
        };
    assertEquals(2, FluentIterable.from(iterable).size());
  }

  public void testSize_collectionDoesntIterate() {
    List&lt;Integer&gt; nums = asList(1, 2, 3, 4, 5);
    List&lt;Integer&gt; collection =
        new ArrayList&lt;Integer&gt;(nums) {
          @Override
          public Iterator&lt;Integer&gt; iterator() {
            throw new AssertionFailedError(&quot;Don't iterate me!&quot;);
          }
        };
    assertEquals(5, FluentIterable.from(collection).size());
  }

  public void testContains_nullSetYes() {
    Iterable&lt;String&gt; set = Sets.newHashSet(&quot;a&quot;, null, &quot;b&quot;);
    assertTrue(FluentIterable.from(set).contains(null));
  }

  public void testContains_nullSetNo() {
    Iterable&lt;String&gt; set = ImmutableSortedSet.of(&quot;a&quot;, &quot;b&quot;);
    assertFalse(FluentIterable.from(set).contains(null));
  }

  public void testContains_nullIterableYes() {
    Iterable&lt;String&gt; iterable = iterable(&quot;a&quot;, null, &quot;b&quot;);
    assertTrue(FluentIterable.from(iterable).contains(null));
  }

  public void testContains_nullIterableNo() {
    Iterable&lt;String&gt; iterable = iterable(&quot;a&quot;, &quot;b&quot;);
    assertFalse(FluentIterable.from(iterable).contains(null));
  }

  public void testContains_nonNullSetYes() {
    Iterable&lt;String&gt; set = Sets.newHashSet(&quot;a&quot;, null, &quot;b&quot;);
    assertTrue(FluentIterable.from(set).contains(&quot;b&quot;));
  }

  public void testContains_nonNullSetNo() {
    Iterable&lt;String&gt; set = Sets.newHashSet(&quot;a&quot;, &quot;b&quot;);
    assertFalse(FluentIterable.from(set).contains(&quot;c&quot;));
  }

  public void testContains_nonNullIterableYes() {
    Iterable&lt;String&gt; set = iterable(&quot;a&quot;, null, &quot;b&quot;);
    assertTrue(FluentIterable.from(set).contains(&quot;b&quot;));
  }

  public void testContains_nonNullIterableNo() {
    Iterable&lt;String&gt; iterable = iterable(&quot;a&quot;, &quot;b&quot;);
    assertFalse(FluentIterable.from(iterable).contains(&quot;c&quot;));
  }

  public void testOfToString() {
    assertEquals(&quot;[yam, bam, jam, ham]&quot;, FluentIterable.of(&quot;yam&quot;, &quot;bam&quot;, &quot;jam&quot;, &quot;ham&quot;).toString());
  }

  public void testToString() {
    assertEquals(&quot;[]&quot;, FluentIterable.from(Collections.emptyList()).toString());
    assertEquals(&quot;[]&quot;, FluentIterable.&lt;String&gt;of().toString());

    assertEquals(
        &quot;[yam, bam, jam, ham]&quot;, FluentIterable.from(asList(&quot;yam&quot;, &quot;bam&quot;, &quot;jam&quot;, &quot;ham&quot;)).toString());
  }

  public void testCycle() {
    FluentIterable&lt;String&gt; cycle = FluentIterable.from(asList(&quot;a&quot;, &quot;b&quot;)).cycle();

    int howManyChecked = 0;
    for (String string : cycle) {
      String expected = (howManyChecked % 2 == 0) ? &quot;a&quot; : &quot;b&quot;;
      assertEquals(expected, string);
      if (howManyChecked++ == 5) {
        break;
      }
    }

    // We left the last iterator pointing to &quot;b&quot;. But a new iterator should
    // always point to &quot;a&quot;.
    assertEquals(&quot;a&quot;, cycle.iterator().next());
  }

  public void testCycle_emptyIterable() {
    FluentIterable&lt;Integer&gt; cycle = FluentIterable.&lt;Integer&gt;of().cycle();
    assertFalse(cycle.iterator().hasNext());
  }

  public void testCycle_removingAllElementsStopsCycle() {
    FluentIterable&lt;Integer&gt; cycle = fluent(1, 2).cycle();
    Iterator&lt;Integer&gt; iterator = cycle.iterator();
    iterator.next();
    iterator.remove();
    iterator.next();
    iterator.remove();
    assertFalse(iterator.hasNext());
    assertFalse(cycle.iterator().hasNext());
  }

  public void testAppend() {
    FluentIterable&lt;Integer&gt; result =
        FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(Lists.newArrayList(4, 5, 6));
    assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
    assertEquals(&quot;[1, 2, 3, 4, 5, 6]&quot;, result.toString());

    result = FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(4, 5, 6);
    assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
    assertEquals(&quot;[1, 2, 3, 4, 5, 6]&quot;, result.toString());
  }

  public void testAppend_toEmpty() {
    FluentIterable&lt;Integer&gt; result =
        FluentIterable.&lt;Integer&gt;of().append(Lists.newArrayList(1, 2, 3));
    assertEquals(asList(1, 2, 3), Lists.newArrayList(result));
  }

  public void testAppend_emptyList() {
    FluentIterable&lt;Integer&gt; result =
        FluentIterable.&lt;Integer&gt;from(asList(1, 2, 3)).append(Lists.&lt;Integer&gt;newArrayList());
    assertEquals(asList(1, 2, 3), Lists.newArrayList(result));
  }

  public void testAppend_nullPointerException() {
    try {
      FluentIterable&lt;Integer&gt; unused =
          FluentIterable.&lt;Integer&gt;from(asList(1, 2)).append((List&lt;Integer&gt;) null);
      fail(&quot;Appending null iterable should throw NPE.&quot;);
    } catch (NullPointerException expected) {
    }
  }

  /*
   * Tests for partition(int size) method.
   */

  /*
   * Tests for partitionWithPadding(int size) method.
   */

  public void testFilter() {
    FluentIterable&lt;String&gt; filtered =
        FluentIterable.from(asList(&quot;foo&quot;, &quot;bar&quot;)).filter(Predicates.equalTo(&quot;foo&quot;));

    List&lt;String&gt; expected = Collections.singletonList(&quot;foo&quot;);
    List&lt;String&gt; actual = Lists.newArrayList(filtered);
    assertEquals(expected, actual);
    assertCanIterateAgain(filtered);
    assertEquals(&quot;[foo]&quot;, filtered.toString());
  }

  private static class TypeA {}

  private interface TypeB {}

  private static class HasBoth extends TypeA implements TypeB {}

  @GwtIncompatible // Iterables.filter(Iterable, Class)
  public void testFilterByType() throws Exception {
    HasBoth hasBoth = new HasBoth();
    FluentIterable&lt;TypeA&gt; alist =
        FluentIterable.from(asList(new TypeA(), new TypeA(), hasBoth, new TypeA()));
    Iterable&lt;TypeB&gt; blist = alist.filter(TypeB.class);
    assertThat(blist).containsExactly(hasBoth).inOrder();
  }

  public void testAnyMatch() {
    ArrayList&lt;String&gt; list = Lists.newArrayList();
    FluentIterable&lt;String&gt; iterable = FluentIterable.&lt;String&gt;from(list);
    Predicate&lt;String&gt; predicate = Predicates.equalTo(&quot;pants&quot;);

    assertFalse(iterable.anyMatch(predicate));
    list.add(&quot;cool&quot;);
    assertFalse(iterable.anyMatch(predicate));
    list.add(&quot;pants&quot;);
    assertTrue(iterable.anyMatch(predicate));
  }

  public void testAllMatch() {
    List&lt;String&gt; list = Lists.newArrayList();
    FluentIterable&lt;String&gt; iterable = FluentIterable.&lt;String&gt;from(list);
    Predicate&lt;String&gt; predicate = Predicates.equalTo(&quot;cool&quot;);

    assertTrue(iterable.allMatch(predicate));
    list.add(&quot;cool&quot;);
    assertTrue(iterable.allMatch(predicate));
    list.add(&quot;pants&quot;);
    assertFalse(iterable.allMatch(predicate));
  }

  public void testFirstMatch() {
    FluentIterable&lt;String&gt; iterable = FluentIterable.from(Lists.newArrayList(&quot;cool&quot;, &quot;pants&quot;));
    assertThat(iterable.firstMatch(Predicates.equalTo(&quot;cool&quot;))).hasValue(&quot;cool&quot;);
    assertThat(iterable.firstMatch(Predicates.equalTo(&quot;pants&quot;))).hasValue(&quot;pants&quot;);
    assertThat(iterable.firstMatch(Predicates.alwaysFalse())).isAbsent();
    assertThat(iterable.firstMatch(Predicates.alwaysTrue())).hasValue(&quot;cool&quot;);
  }

  private static final class IntegerValueOfFunction implements Function&lt;String, Integer&gt; {
    @Override
    public Integer apply(String from) {
      return Integer.valueOf(from);
    }
  }

  public void testTransformWith() {
    List&lt;String&gt; input = asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
    Iterable&lt;Integer&gt; iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());

    assertEquals(asList(1, 2, 3), Lists.newArrayList(iterable));
    assertCanIterateAgain(iterable);
    assertEquals(&quot;[1, 2, 3]&quot;, iterable.toString());
  }

  public void testTransformWith_poorlyBehavedTransform() {
    List&lt;String&gt; input = asList(&quot;1&quot;, null, &quot;3&quot;);
    Iterable&lt;Integer&gt; iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());

    Iterator&lt;Integer&gt; resultIterator = iterable.iterator();
    resultIterator.next();

    try {
      resultIterator.next();
      fail(&quot;Transforming null to int should throw NumberFormatException&quot;);
    } catch (NumberFormatException expected) {
    }
  }

  private static final class StringValueOfFunction implements Function&lt;Integer, String&gt; {
    @Override
    public String apply(Integer from) {
      return String.valueOf(from);
    }
  }

  public void testTransformWith_nullFriendlyTransform() {
    List&lt;Integer&gt; input = asList(1, 2, null, 3);
    Iterable&lt;String&gt; result = FluentIterable.from(input).transform(new StringValueOfFunction());

    assertEquals(asList(&quot;1&quot;, &quot;2&quot;, &quot;null&quot;, &quot;3&quot;), Lists.newArrayList(result));
  }

  private static final class RepeatedStringValueOfFunction
      implements Function&lt;Integer, List&lt;String&gt;&gt; {
    @Override
    public List&lt;String&gt; apply(Integer from) {
      String value = String.valueOf(from);
      return ImmutableList.of(value, value);
    }
  }

  public void testTransformAndConcat() {
    List&lt;Integer&gt; input = asList(1, 2, 3);
    Iterable&lt;String&gt; result =
        FluentIterable.from(input).transformAndConcat(new RepeatedStringValueOfFunction());
    assertEquals(asList(&quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;), Lists.newArrayList(result));
  }

  private static final class RepeatedStringValueOfWildcardFunction
      implements Function&lt;Integer, List&lt;? extends String&gt;&gt; {
    @Override
    public List&lt;String&gt; apply(Integer from) {
      String value = String.valueOf(from);
      return ImmutableList.of(value, value);
    }
  }

  public void testTransformAndConcat_wildcardFunctionGenerics() {
    List&lt;Integer&gt; input = asList(1, 2, 3);
    FluentIterable&lt;String&gt; unused =
        FluentIterable.from(input).transformAndConcat(new RepeatedStringValueOfWildcardFunction());
  }

  public void testFirst_list() {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    assertThat(FluentIterable.from(list).first()).hasValue(&quot;a&quot;);
  }

  public void testFirst_null() {
    List&lt;String&gt; list = Lists.newArrayList(null, &quot;a&quot;, &quot;b&quot;);
    try {
      FluentIterable.from(list).first();
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testFirst_emptyList() {
    List&lt;String&gt; list = Collections.emptyList();
    assertThat(FluentIterable.from(list).first()).isAbsent();
  }

  public void testFirst_sortedSet() {
    SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of(&quot;b&quot;, &quot;c&quot;, &quot;a&quot;);
    assertThat(FluentIterable.from(sortedSet).first()).hasValue(&quot;a&quot;);
  }

  public void testFirst_emptySortedSet() {
    SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of();
    assertThat(FluentIterable.from(sortedSet).first()).isAbsent();
  }

  public void testFirst_iterable() {
    Set&lt;String&gt; set = ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    assertThat(FluentIterable.from(set).first()).hasValue(&quot;a&quot;);
  }

  public void testFirst_emptyIterable() {
    Set&lt;String&gt; set = Sets.newHashSet();
    assertThat(FluentIterable.from(set).first()).isAbsent();
  }

  public void testLast_list() {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    assertThat(FluentIterable.from(list).last()).hasValue(&quot;c&quot;);
  }

  public void testLast_null() {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, null);
    try {
      FluentIterable.from(list).last();
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testLast_emptyList() {
    List&lt;String&gt; list = Collections.emptyList();
    assertThat(FluentIterable.from(list).last()).isAbsent();
  }

  public void testLast_sortedSet() {
    SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of(&quot;b&quot;, &quot;c&quot;, &quot;a&quot;);
    assertThat(FluentIterable.from(sortedSet).last()).hasValue(&quot;c&quot;);
  }

  public void testLast_emptySortedSet() {
    SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of();
    assertThat(FluentIterable.from(sortedSet).last()).isAbsent();
  }

  public void testLast_iterable() {
    Set&lt;String&gt; set = ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    assertThat(FluentIterable.from(set).last()).hasValue(&quot;c&quot;);
  }

  public void testLast_emptyIterable() {
    Set&lt;String&gt; set = Sets.newHashSet();
    assertThat(FluentIterable.from(set).last()).isAbsent();
  }

  public void testSkip_simple() {
    Collection&lt;String&gt; set = ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
    assertEquals(
        Lists.newArrayList(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;), Lists.newArrayList(FluentIterable.from(set).skip(2)));
    assertEquals(&quot;[c, d, e]&quot;, FluentIterable.from(set).skip(2).toString());
  }

  public void testSkip_simpleList() {
    Collection&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
    assertEquals(
        Lists.newArrayList(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;), Lists.newArrayList(FluentIterable.from(list).skip(2)));
    assertEquals(&quot;[c, d, e]&quot;, FluentIterable.from(list).skip(2).toString());
  }

  public void testSkip_pastEnd() {
    Collection&lt;String&gt; set = ImmutableSet.of(&quot;a&quot;, &quot;b&quot;);
    assertEquals(Collections.emptyList(), Lists.newArrayList(FluentIterable.from(set).skip(20)));
  }

  public void testSkip_pastEndList() {
    Collection&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;);
    assertEquals(Collections.emptyList(), Lists.newArrayList(FluentIterable.from(list).skip(20)));
  }

  public void testSkip_skipNone() {
    Collection&lt;String&gt; set = ImmutableSet.of(&quot;a&quot;, &quot;b&quot;);
    assertEquals(
        Lists.newArrayList(&quot;a&quot;, &quot;b&quot;), Lists.newArrayList(FluentIterable.from(set).skip(0)));
  }

  public void testSkip_skipNoneList() {
    Collection&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;);
    assertEquals(
        Lists.newArrayList(&quot;a&quot;, &quot;b&quot;), Lists.newArrayList(FluentIterable.from(list).skip(0)));
  }

  public void testSkip_iterator() throws Exception {
    new IteratorTester&lt;Integer&gt;(
        5,
        IteratorFeature.MODIFIABLE,
        Lists.newArrayList(2, 3),
        IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
<A NAME="3"></A>      protected Iterator&lt;Integer&gt; newTargetIterator() {
        Collection&lt;Integer&gt; collection = Sets.newLinkedHashSet();
        Collections.addAll(collection, 1, 2, 3);
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#3',2,'match1448961-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return FluentIterable.from(collection).skip(1).iterator();
      }
    }.test();
  }

  public void testSkip_</B></FONT>iteratorList() throws Exception {
    new IteratorTester&lt;Integer&gt;(
        5,
<A NAME="5"></A>        IteratorFeature.MODIFIABLE,
        Lists.newArrayList(2, 3),
        IteratorTester.KnownOrder.KNOWN_ORDER) {
      <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#5',2,'match1448961-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
      protected Iterator&lt;Integer&gt; newTargetIterator() {
        return FluentIterable.from(Lists.newArrayList(1, 2, 3)).skip(1).iterator();
      }</B></FONT>
    }.test();
  }

  public void testSkip_nonStructurallyModifiedList() throws Exception {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(1);
    Iterator&lt;String&gt; tailIterator = tail.iterator();
    list.set(2, &quot;c2&quot;);
    assertEquals(&quot;b&quot;, tailIterator.next());
    assertEquals(&quot;c2&quot;, tailIterator.next());
    assertFalse(tailIterator.hasNext());
  }

  public void testSkip_structurallyModifiedSkipSome() throws Exception {
    Collection&lt;String&gt; set = Sets.newLinkedHashSet();
    Collections.addAll(set, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    FluentIterable&lt;String&gt; tail = FluentIterable.from(set).skip(1);
    set.remove(&quot;b&quot;);
    set.addAll(Lists.newArrayList(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;));
    assertThat(tail).containsExactly(&quot;c&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).inOrder();
  }

  public void testSkip_structurallyModifiedSkipSomeList() throws Exception {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(1);
    list.subList(1, 3).clear();
    list.addAll(0, Lists.newArrayList(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;));
    assertThat(tail).containsExactly(&quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;).inOrder();
  }

  public void testSkip_structurallyModifiedSkipAll() throws Exception {
    Collection&lt;String&gt; set = Sets.newLinkedHashSet();
    Collections.addAll(set, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    FluentIterable&lt;String&gt; tail = FluentIterable.from(set).skip(2);
    set.remove(&quot;a&quot;);
    set.remove(&quot;b&quot;);
    assertFalse(tail.iterator().hasNext());
  }

  public void testSkip_structurallyModifiedSkipAllList() throws Exception {
    List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    FluentIterable&lt;String&gt; tail = FluentIterable.from(list).skip(2);
    list.subList(0, 2).clear();
    assertThat(tail).isEmpty();
  }

  public void testSkip_illegalArgument() {
    try {
      FluentIterable.from(asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).skip(-1);
      fail(&quot;Skipping negative number of elements should throw IllegalArgumentException.&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testLimit() {
    Iterable&lt;String&gt; iterable = Lists.newArrayList(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;);
    FluentIterable&lt;String&gt; limited = FluentIterable.from(iterable).limit(2);

    assertEquals(ImmutableList.of(&quot;foo&quot;, &quot;bar&quot;), Lists.newArrayList(limited));
    assertCanIterateAgain(limited);
    assertEquals(&quot;[foo, bar]&quot;, limited.toString());
  }

  public void testLimit_illegalArgument() {
    try {
      FluentIterable&lt;String&gt; unused =
          FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).limit(-1);
      fail(&quot;Passing negative number to limit(...) method should throw IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testIsEmpty() {
    assertTrue(FluentIterable.&lt;String&gt;from(Collections.&lt;String&gt;emptyList()).isEmpty());
    assertFalse(FluentIterable.&lt;String&gt;from(Lists.newArrayList(&quot;foo&quot;)).isEmpty());
  }

  public void testToList() {
    assertEquals(Lists.newArrayList(1, 2, 3, 4), fluent(1, 2, 3, 4).toList());
  }

  public void testToList_empty() {
    assertTrue(fluent().toList().isEmpty());
  }

  public void testToSortedList_withComparator() {
    assertEquals(
        Lists.newArrayList(4, 3, 2, 1),
        fluent(4, 1, 3, 2).toSortedList(Ordering.&lt;Integer&gt;natural().reverse()));
  }

  public void testToSortedList_withDuplicates() {
    assertEquals(
        Lists.newArrayList(4, 3, 1, 1),
        fluent(1, 4, 1, 3).toSortedList(Ordering.&lt;Integer&gt;natural().reverse()));
  }

  public void testToSet() {
    assertThat(fluent(1, 2, 3, 4).toSet()).containsExactly(1, 2, 3, 4).inOrder();
  }

  public void testToSet_removeDuplicates() {
    assertThat(fluent(1, 2, 1, 2).toSet()).containsExactly(1, 2).inOrder();
  }

  public void testToSet_empty() {
    assertTrue(fluent().toSet().isEmpty());
  }

  public void testToSortedSet() {
    assertThat(fluent(1, 4, 2, 3).toSortedSet(Ordering.&lt;Integer&gt;natural().reverse()))
        .containsExactly(4, 3, 2, 1)
        .inOrder();
  }

  public void testToSortedSet_removeDuplicates() {
    assertThat(fluent(1, 4, 1, 3).toSortedSet(Ordering.&lt;Integer&gt;natural().reverse()))
        .containsExactly(4, 3, 1)
        .inOrder();
  }

  public void testToMultiset() {
    assertThat(fluent(1, 2, 1, 3, 2, 4).toMultiset()).containsExactly(1, 1, 2, 2, 3, 4).inOrder();
  }

  public void testToMultiset_empty() {
    assertThat(fluent().toMultiset()).isEmpty();
  }

  public void testToMap() {
    assertThat(fluent(1, 2, 3).toMap(Functions.toStringFunction()).entrySet())
        .containsExactly(
            Maps.immutableEntry(1, &quot;1&quot;), Maps.immutableEntry(2, &quot;2&quot;), Maps.immutableEntry(3, &quot;3&quot;))
        .inOrder();
  }

  public void testToMap_nullKey() {
    try {
      fluent(1, null, 2).toMap(Functions.constant(&quot;foo&quot;));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testToMap_nullValue() {
    try {
      fluent(1, 2, 3).toMap(Functions.constant(null));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testIndex() {
    ImmutableListMultimap&lt;Integer, String&gt; expected =
        ImmutableListMultimap.&lt;Integer, String&gt;builder()
            .putAll(3, &quot;one&quot;, &quot;two&quot;)
            .put(5, &quot;three&quot;)
            .put(4, &quot;four&quot;)
            .build();
    ImmutableListMultimap&lt;Integer, String&gt; index =
        FluentIterable.from(asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;))
            .index(
                new Function&lt;String, Integer&gt;() {
                  @Override
                  public Integer apply(String input) {
                    return input.length();
                  }
                });
    assertEquals(expected, index);
  }

  public void testIndex_nullKey() {
    try {
      ImmutableListMultimap&lt;Object, Integer&gt; unused =
          fluent(1, 2, 3).index(Functions.constant(null));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testIndex_nullValue() {
    try {
      ImmutableListMultimap&lt;String, Integer&gt; unused =
          fluent(1, null, 2).index(Functions.constant(&quot;foo&quot;));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testUniqueIndex() {
    ImmutableMap&lt;Integer, String&gt; expected = ImmutableMap.of(3, &quot;two&quot;, 5, &quot;three&quot;, 4, &quot;four&quot;);
    ImmutableMap&lt;Integer, String&gt; index =
        FluentIterable.from(asList(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;))
            .uniqueIndex(
                new Function&lt;String, Integer&gt;() {
                  @Override
                  public Integer apply(String input) {
                    return input.length();
                  }
                });
    assertEquals(expected, index);
  }

  public void testUniqueIndex_duplicateKey() {
    try {
      ImmutableMap&lt;Integer, String&gt; unused =
          FluentIterable.from(asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;))
              .uniqueIndex(
                  new Function&lt;String, Integer&gt;() {
                    @Override
                    public Integer apply(String input) {
                      return input.length();
                    }
                  });
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testUniqueIndex_nullKey() {
    try {
      fluent(1, 2, 3).uniqueIndex(Functions.constant(null));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testUniqueIndex_nullValue() {
    try {
      ImmutableMap&lt;Object, Integer&gt; unused =
<A NAME="6"></A>          fluent(1, null, 2)
              .uniqueIndex(
                  new Function&lt;Integer, Object&gt;() {
                    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#6',2,'match1448961-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
                    public Object apply(@Nullable Integer input) {
                      return String.valueOf(input);
                    }</B></FONT>
                  });
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testCopyInto_List() {
    assertThat(fluent(1, 3, 5).copyInto(Lists.newArrayList(1, 2)))
        .containsExactly(1, 2, 1, 3, 5)
        .inOrder();
  }

  public void testCopyInto_Set() {
    assertThat(fluent(1, 3, 5).copyInto(Sets.newHashSet(1, 2))).containsExactly(1, 2, 3, 5);
  }

  public void testCopyInto_SetAllDuplicates() {
    assertThat(fluent(1, 3, 5).copyInto(Sets.newHashSet(1, 2, 3, 5))).containsExactly(1, 2, 3, 5);
  }

<A NAME="1"></A>  public void testCopyInto_NonCollection() {
    final ArrayList&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);

    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#1',2,'match1448961-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final ArrayList&lt;Integer&gt; iterList = Lists.newArrayList(9, 8, 7);
    Iterable&lt;Integer&gt; iterable =
        new Iterable&lt;Integer&gt;() {
          @Override
          public Iterator&lt;Integer&gt; iterator() {
            return iterList.iterator();
          }</B></FONT>
        };

    assertThat(FluentIterable.from(iterable).copyInto(list))
        .containsExactly(1, 2, 3, 9, 8, 7)
        .inOrder();
  }

  public void testJoin() {
    assertEquals(&quot;2,1,3,4&quot;, fluent(2, 1, 3, 4).join(Joiner.on(&quot;,&quot;)));
  }

  public void testJoin_empty() {
    assertEquals(&quot;&quot;, fluent().join(Joiner.on(&quot;,&quot;)));
  }

  public void testGet() {
    assertEquals(&quot;a&quot;, FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).get(0));
    assertEquals(&quot;b&quot;, FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).get(1));
    assertEquals(&quot;c&quot;, FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).get(2));
  }

  public void testGet_outOfBounds() {
    try {
      FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).get(-1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      FluentIterable.from(Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)).get(3);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }

  /*
   * Full and proper black-box testing of a Stream-returning method is extremely involved, and is
   * overkill when nearly all Streams are produced using well-tested JDK calls. So, we cheat and
   * just test that the toArray() contents are as expected.
   */
  public void testStream() {
    assertThat(FluentIterable.of().stream()).isEmpty();
    assertThat(FluentIterable.of(&quot;a&quot;).stream()).containsExactly(&quot;a&quot;);
    assertThat(FluentIterable.of(1, 2, 3).stream().filter(n -&gt; n &gt; 1)).containsExactly(2, 3);
  }
<A NAME="4"></A>
  // TODO(kevinb): add assertThat(Stream) to Truth?
  static class Help {
    static IterableSubject assertThat(<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#4',2,'match1448961-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Stream&lt;?&gt; stream) {
      return Truth.assertThat(stream.toArray()).asList();
    }
  }

  private static void a</B></FONT>ssertCanIterateAgain(Iterable&lt;?&gt; iterable) {
    for (Object unused : iterable) {
      // do nothing
    }
  }

  private static FluentIterable&lt;Integer&gt; fluent(Integer... elements) {
    return FluentIterable.from(Lists.newArrayList(elements));
  }

<A NAME="2"></A>  private static Iterable&lt;String&gt; iterable(String... elements) {
    final List&lt;String&gt; list = asList(elements);
    return new Iterable&lt;String&gt;() {
      <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1448961-0.html#2',2,'match1448961-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
      public Iterator&lt;String&gt; iterator() {
        return list.iterator();
      }
    };
  }</B></FONT>
}
</PRE>
</div>
  </div>
</body>
</html>
