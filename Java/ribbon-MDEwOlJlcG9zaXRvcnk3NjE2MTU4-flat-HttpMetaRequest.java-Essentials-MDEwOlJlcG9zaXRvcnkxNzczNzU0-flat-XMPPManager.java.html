
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.003159557661927%, Tokens: 19</h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HttpMetaRequest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.netflix.ribbon.http;
2  import com.netflix.hystrix.HystrixInvokableInfo;
3  import com.netflix.hystrix.HystrixObservableCommand;
4  import com.netflix.ribbon.RequestWithMetaData;
5  import com.netflix.ribbon.RibbonResponse;
6  import com.netflix.ribbon.hystrix.HystrixObservableCommandChain;
7  import com.netflix.ribbon.hystrix.ResultCommandPair;
8  import io.netty.buffer.ByteBuf;
9  import rx.Notification;
10  import rx.Observable;
11  import rx.Observable.OnSubscribe;
12  import rx.Subscriber;
13  import rx.functions.Action1;
14  import rx.functions.Func1;
15  import rx.subjects.ReplaySubject;
16  import rx.subjects.Subject;
17  import java.util.concurrent.ExecutionException;
18  import java.util.concurrent.Future;
19  import java.util.concurrent.TimeUnit;
</span>20  import java.util.concurrent.TimeoutException;
21  import java.util.concurrent.atomic.AtomicBoolean;
22  class HttpMetaRequest<T> implements RequestWithMetaData<T> {
23      private static class ResponseWithSubject<T> extends RibbonResponse<Observable<T>> {
24          Subject<T, T> subject;
25          HystrixInvokableInfo<?> info;
26          public ResponseWithSubject(Subject<T, T> subject,
27                                     HystrixInvokableInfo<?> info) {
28              this.subject = subject;
29              this.info = info;
30          }
31          @Override
32          public Observable<T> content() {
33              return subject;
34          }
35          @Override
36          public HystrixInvokableInfo<?> getHystrixInfo() {
37              return info;
38          }
39      }
40      private final HttpRequest<T> request;
41      HttpMetaRequest(HttpRequest<T> request) {
42          this.request = request;
43      }
44      @Override
45      public Observable<RibbonResponse<Observable<T>>> toObservable() {
46          HystrixObservableCommandChain<T> commandChain = request.createHystrixCommandChain();
47          return convertToRibbonResponse(commandChain, commandChain.toResultCommandPairObservable());
48      }
49      @Override
50      public Observable<RibbonResponse<Observable<T>>> observe() {
51          HystrixObservableCommandChain<T> commandChain = request.createHystrixCommandChain();
52          Observable<ResultCommandPair<T>> notificationObservable = commandChain.toResultCommandPairObservable();
53          notificationObservable = retainBufferIfNeeded(notificationObservable);
54          ReplaySubject<ResultCommandPair<T>> subject = ReplaySubject.create();
55          notificationObservable.subscribe(subject);
56          return convertToRibbonResponse(commandChain, subject);
57      }
58      @Override
59      public Future<RibbonResponse<T>> queue() {
60          Observable<ResultCommandPair<T>> resultObservable = request.createHystrixCommandChain().toResultCommandPairObservable();
61          resultObservable = retainBufferIfNeeded(resultObservable);
62          final Future<ResultCommandPair<T>> f = resultObservable.toBlocking().toFuture();
63          return new Future<RibbonResponse<T>>() {
64              @Override
65              public boolean cancel(boolean mayInterruptIfRunning) {
66                  return f.cancel(mayInterruptIfRunning);
67              }
68              @Override
69              public RibbonResponse<T> get() throws InterruptedException,
70                      ExecutionException {
71                  final ResultCommandPair<T> pair = f.get();
72                  return new HttpMetaResponse<T>(pair.getResult(), pair.getCommand());
73              }
74              @Override
75              public RibbonResponse<T> get(long timeout, TimeUnit timeUnit)
76                      throws InterruptedException, ExecutionException,
77                      TimeoutException {
78                  final ResultCommandPair<T> pair = f.get(timeout, timeUnit);
79                  return new HttpMetaResponse<T>(pair.getResult(), pair.getCommand());
80              }
81              @Override
82              public boolean isCancelled() {
83                  return f.isCancelled();
84              }
85              @Override
86              public boolean isDone() {
87                  return f.isDone();
88              }
89          };
90      }
91      @Override
92      public RibbonResponse<T> execute() {
93          RibbonResponse<Observable<T>> response = observe().toBlocking().last();
94          return new HttpMetaResponse<T>(response.content().toBlocking().last(), response.getHystrixInfo());
95      }
96      private Observable<ResultCommandPair<T>> retainBufferIfNeeded(Observable<ResultCommandPair<T>> resultObservable) {
97          if (request.isByteBufResponse()) {
98              resultObservable = resultObservable.map(new Func1<ResultCommandPair<T>, ResultCommandPair<T>>() {
99                  @Override
100                  public ResultCommandPair<T> call(ResultCommandPair<T> pair) {
101                      ((ByteBuf) pair.getResult()).retain();
102                      return pair;
103                  }
104              });
105          }
106          return resultObservable;
107      }
108      private Observable<RibbonResponse<Observable<T>>> convertToRibbonResponse(
109              final HystrixObservableCommandChain<T> commandChain, final Observable<ResultCommandPair<T>> hystrixNotificationObservable) {
110          return Observable.create(new OnSubscribe<RibbonResponse<Observable<T>>>() {
111              @Override
112              public void call(
113                      final Subscriber<? super RibbonResponse<Observable<T>>> t1) {
114                  final Subject<T, T> subject = ReplaySubject.create();
115                  hystrixNotificationObservable.materialize().subscribe(new Action1<Notification<ResultCommandPair<T>>>() {
116                      AtomicBoolean first = new AtomicBoolean(true);
117                      @Override
118                      public void call(Notification<ResultCommandPair<T>> notification) {
119                          if (first.compareAndSet(true, false)) {
120                              HystrixObservableCommand<T> command = notification.isOnError() ? commandChain.getLastCommand() : notification.getValue().getCommand();
121                              t1.onNext(new ResponseWithSubject<T>(subject, command));
122                              t1.onCompleted();
123                          }
124                          if (notification.isOnNext()) {
125                              subject.onNext(notification.getValue().getResult());
126                          } else if (notification.isOnCompleted()) {
127                              subject.onCompleted();
128                          } else { 
129                              subject.onError(notification.getThrowable());
130                          }
131                      }
132                  });
133              }
134          });
135      }
136  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-XMPPManager.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.earth2me.essentials.xmpp;
2  import com.earth2me.essentials.Console;
3  import com.earth2me.essentials.EssentialsConf;
4  import com.earth2me.essentials.IConf;
5  import net.ess3.api.IUser;
6  import com.earth2me.essentials.utils.FormatUtil;
7  import java.io.File;
8  import java.util.*;
9  import java.util.logging.Handler;
10  import java.util.logging.Level;
11  import java.util.logging.LogRecord;
12  import java.util.logging.Logger;
13  import java.util.logging.SimpleFormatter;
14  import org.bukkit.entity.Player;
15  import org.jivesoftware.smack.*;
16  import org.jivesoftware.smack.Roster.SubscriptionMode;
17  import org.jivesoftware.smack.packet.Message;
18  import org.jivesoftware.smack.packet.Presence;
19  import org.jivesoftware.smack.util.StringUtils;
</span>20  public class XMPPManager extends Handler implements MessageListener, ChatManagerListener, IConf
21  {
22  	private static final Logger LOGGER = Logger.getLogger("Minecraft");
23  	private static final SimpleFormatter formatter = new SimpleFormatter();
24  	private final transient EssentialsConf config;
25  	private transient XMPPConnection connection;
26  	private transient ChatManager chatManager;
27  	private final transient Map<String, Chat> chats = Collections.synchronizedMap(new HashMap<String, Chat>());
28  	private final transient Set<LogRecord> logrecords = Collections.synchronizedSet(new HashSet<LogRecord>());
29  	private final transient IEssentialsXMPP parent;
30  	private transient List<String> logUsers;
31  	private transient Level logLevel;
32  	private transient boolean ignoreLagMessages = true;
33  	private transient Thread loggerThread;
34  	private transient boolean threadrunning = true;
35  	public XMPPManager(final IEssentialsXMPP parent)
36  	{
37  		super();
38  		this.parent = parent;
39  		config = new EssentialsConf(new File(parent.getDataFolder(), "config.yml"));
40  		config.setTemplateName("/config.yml", EssentialsXMPP.class);
41  		reloadConfig();
42  	}
43  	public boolean sendMessage(final String address, final String message)
44  	{
45  		if (address != null && !address.isEmpty())
46  		{
47  			try
48  			{
49  				startChat(address);
50  				final Chat chat;
51  				synchronized (chats)
52  				{
53  					chat = chats.get(address);
54  				}
55  				if (chat != null)
56  				{
57  					if (!connection.isConnected())
58  					{
59  						disconnect();
60  						connect();
61  					}
62  					chat.sendMessage(FormatUtil.stripFormat(message));
63  					return true;
64  				}
65  			}
66  			catch (XMPPException ex)
67  			{
68  				disableChat(address);
69  			}
70  		}
71  		return false;
72  	}
73  	@Override
74  	public void processMessage(final Chat chat, final Message msg)
75  	{
76  		if (msg.getType() != Message.Type.error && msg.getBody().length() > 0)
77  		{
78  			final String message = msg.getBody();
79  			switch (message.charAt(0))
80  			{
81  			case '@':
82  				sendPrivateMessage(chat, message);
83  				break;
84  			case '/':
85  				sendCommand(chat, message);
86  				break;
87  			default:
88  				final IUser sender = parent.getUserByAddress(StringUtils.parseBareAddress(chat.getParticipant()));
89  				parent.broadcastMessage(sender, "=" + sender.getBase().getDisplayName() + ": " + message, StringUtils.parseBareAddress(chat.getParticipant()));
90  			}
91  		}
92  	}
93  	private boolean connect()
94  	{
95  		final String server = config.getString("xmpp.server");
96  		if (server == null || server.equals("example.com"))
97  		{
98  			LOGGER.log(Level.WARNING, "config broken for xmpp");
99  			return false;
100  		}
101  		final int port = config.getInt("xmpp.port", 5222);
102  		final String serviceName = config.getString("xmpp.servicename", server);
103  		final String xmppuser = config.getString("xmpp.user");
104  		final String password = config.getString("xmpp.password");
105  		final ConnectionConfiguration connConf = new ConnectionConfiguration(server, port, serviceName);
106  		final StringBuilder stringBuilder = new StringBuilder();
107  		stringBuilder.append("Connecting to xmpp server ").append(server).append(":").append(port);
108  		stringBuilder.append(" as user ").append(xmppuser).append(".");
109  		LOGGER.log(Level.INFO, stringBuilder.toString());
110  		connConf.setSASLAuthenticationEnabled(config.getBoolean("xmpp.sasl-enabled", false));
111  		connConf.setSendPresence(true);
112  		connConf.setReconnectionAllowed(true);
113  		connConf.setDebuggerEnabled(config.getBoolean("debug", false));
114  		connection = new XMPPConnection(connConf);
115  		try
116  		{
117  			connection.connect();
118  			connection.login(xmppuser, password, "Essentials-XMPP");
119  			connection.sendPacket(new Presence(Presence.Type.available, "No one online.", 2, Presence.Mode.available));
120  			connection.getRoster().setSubscriptionMode(SubscriptionMode.accept_all);
121  			chatManager = connection.getChatManager();
122  			chatManager.addChatListener(this);
123  			return true;
124  		}
125  		catch (XMPPException ex)
126  		{
127  			LOGGER.log(Level.WARNING, "Failed to connect to server: " + server, ex);
128  			return false;
129  		}
130  	}
131  	public final void disconnect()
132  	{
133  		if (loggerThread != null)
134  		{
135  			loggerThread.interrupt();
136  		}
137  		if (chatManager != null)
138  		{
139  			chatManager.removeChatListener(this);
140  			chatManager = null;
141  		}
142  		if (connection != null)
143  		{
144  			connection.disconnect(new Presence(Presence.Type.unavailable));
145  		}
146  	}
147  	public final void updatePresence()
148  	{
149  		final int usercount;
150  		final StringBuilder stringBuilder = new StringBuilder();
151  		usercount = parent.getEss().getOnlinePlayers().size();
152  		if (usercount == 0)
153  		{
154  			final String presenceMsg = "No one online.";
155  			connection.sendPacket(new Presence(Presence.Type.available, presenceMsg, 2, Presence.Mode.dnd));
156  		}
157  		if (usercount == 1)
158  		{
159  			final String presenceMsg = "1 player online.";
160  			connection.sendPacket(new Presence(Presence.Type.available, presenceMsg, 2, Presence.Mode.available));
161  		}
162  		if (usercount > 1)
163  		{
164  			stringBuilder.append(usercount).append(" players online.");
165  			connection.sendPacket(new Presence(Presence.Type.available, stringBuilder.toString(), 2, Presence.Mode.available));
166  		}
167  	}
168  	@Override
169  	public void chatCreated(final Chat chat, final boolean createdLocally)
170  	{
171  		if (!createdLocally)
172  		{
173  			chat.addMessageListener(this);
174  			final Chat old = chats.put(StringUtils.parseBareAddress(chat.getParticipant()), chat);
175  			if (old != null)
176  			{
177  				old.removeMessageListener(this);
178  			}
179  		}
180  	}
181  	@Override
182  	public final void reloadConfig()
183  	{
184  		LOGGER.removeHandler(this);
185  		config.load();
186  		synchronized (chats)
187  		{
188  			disconnect();
189  			chats.clear();
190  			if (!connect())
191  			{
192  				return;
193  			}
194  			startLoggerThread();
195  		}
196  		if (config.getBoolean("log-enabled", false))
197  		{
198  			LOGGER.addHandler(this);
199  			logUsers = config.getStringList("log-users");
200  			final String level = config.getString("log-level", "info");
201  			try
202  			{
203  				logLevel = Level.parse(level.toUpperCase(Locale.ENGLISH));
204  			}
205  			catch (IllegalArgumentException e)
206  			{
207  				logLevel = Level.INFO;
208  			}
209  			ignoreLagMessages = config.getBoolean("ignore-lag-messages", true);
210  		}
211  	}
212  	@Override
213  	public void publish(final LogRecord logRecord)
214  	{
215  		try
216  		{
217  			if (ignoreLagMessages && logRecord.getMessage().equals("Can't keep up! Did the system time change, or is the server overloaded?"))
218  			{
219  				return;
220  			}
221  			if (logRecord.getLevel().intValue() >= logLevel.intValue())
222  			{
223  				synchronized (logrecords)
224  				{
225  					logrecords.add(logRecord);
226  				}
227  			}
228  		}
229  		catch (Exception e)
230  		{
231  		}
232  	}
233  	@Override
234  	public void flush()
235  	{
236  	}
237  	@Override
238  	public void close() throws SecurityException
239  	{
240  	}
241  	private void startLoggerThread()
242  	{
243  		loggerThread = new Thread(new Runnable()
244  		{
245  			@Override
246  			public void run()
247  			{
248  				final Set<LogRecord> copy = new HashSet<LogRecord>();
249  				final Set<String> failedUsers = new HashSet<String>();
250  				while (threadrunning)
251  				{
252  					synchronized (logrecords)
253  					{
254  						if (!logrecords.isEmpty())
255  						{
256  							copy.addAll(logrecords);
257  							logrecords.clear();
258  						}
259  					}
260  					if (!copy.isEmpty())
261  					{
262  						for (String user : logUsers)
263  						{
264  							try
265  							{
266  								XMPPManager.this.startChat(user);
267  								for (LogRecord logRecord : copy)
268  								{
269  									final String message = formatter.format(logRecord);
270  									if (!XMPPManager.this.sendMessage(user, FormatUtil.stripLogColorFormat(message)))
271  									{
272  										failedUsers.add(user);
273  										break;
274  									}
275  								}
276  							}
277  							catch (XMPPException ex)
278  							{
279  								failedUsers.add(user);
280  								LOGGER.removeHandler(XMPPManager.this);
281  								LOGGER.log(Level.SEVERE, "Failed to deliver log message! Disabling logging to XMPP.", ex);
282  							}
283  						}
284  						logUsers.removeAll(failedUsers);
285  						if (logUsers.isEmpty())
286  						{
287  							LOGGER.removeHandler(XMPPManager.this);
288  							threadrunning = false;
289  						}
290  						copy.clear();
291  					}
292  					try
293  					{
294  						Thread.sleep(2000);
295  					}
296  					catch (InterruptedException ex)
297  					{
298  						threadrunning = false;
299  					}
300  				}
301  				LOGGER.removeHandler(XMPPManager.this);
302  			}
303  		});
304  		loggerThread.start();
305  	}
306  	private void startChat(final String address) throws XMPPException
307  	{
308  		if (chatManager == null)
309  		{
310  			return;
311  		}
312  		synchronized (chats)
313  		{
314  			if (!chats.containsKey(address))
315  			{
316  				final Chat chat = chatManager.createChat(address, this);
317  				if (chat == null)
318  				{
319  					throw new XMPPException("Could not start Chat with " + address);
320  				}
321  				chats.put(address, chat);
322  			}
323  		}
324  	}
325  	private void sendPrivateMessage(final Chat chat, final String message)
326  	{
327  		final String[] parts = message.split(" ", 2);
328  		if (parts.length == 2)
329  		{
330  			final List<Player> matches = parent.getServer().matchPlayer(parts[0].substring(1));
331  			if (matches.isEmpty())
332  			{
333  				try
334  				{
335  					chat.sendMessage("User " + parts[0] + " not found");
336  				}
337  				catch (XMPPException ex)
338  				{
339  					LOGGER.log(Level.WARNING, "Failed to send xmpp message.", ex);
340  				}
341  			}
342  			else
343  			{
344  				final String from = "[" + parent.getUserByAddress(StringUtils.parseBareAddress(chat.getParticipant())) + ">";
345  				for (Player p : matches)
346  				{
347  					p.sendMessage(from + p.getDisplayName() + "]  " + message);
348  				}
349  			}
350  		}
351  	}
352  	private void sendCommand(final Chat chat, final String message)
353  	{
354  		if (config.getStringList("op-users").contains(StringUtils.parseBareAddress(chat.getParticipant())))
355  		{
356  			try
357  			{
358  				parent.getServer().dispatchCommand(Console.getCommandSender(parent.getServer()), message.substring(1));
359  			}
360  			catch (Exception ex)
361  			{
362  				LOGGER.log(Level.SEVERE, ex.getMessage(), ex);
363  			}
364  		}
365  	}
366  	private void disableChat(final String address)
367  	{
368  		final Chat chat = chats.get(address);
369  		if (chat != null)
370  		{
371  			chat.removeMessageListener(this);
372  			chats.remove(address);
373  		}
374  	}
375  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HttpMetaRequest.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-XMPPManager.java</div>
                <div class="column column_space"><pre><code>1  package com.netflix.ribbon.http;
2  import com.netflix.hystrix.HystrixInvokableInfo;
3  import com.netflix.hystrix.HystrixObservableCommand;
4  import com.netflix.ribbon.RequestWithMetaData;
5  import com.netflix.ribbon.RibbonResponse;
6  import com.netflix.ribbon.hystrix.HystrixObservableCommandChain;
7  import com.netflix.ribbon.hystrix.ResultCommandPair;
8  import io.netty.buffer.ByteBuf;
9  import rx.Notification;
10  import rx.Observable;
11  import rx.Observable.OnSubscribe;
12  import rx.Subscriber;
13  import rx.functions.Action1;
14  import rx.functions.Func1;
15  import rx.subjects.ReplaySubject;
16  import rx.subjects.Subject;
17  import java.util.concurrent.ExecutionException;
18  import java.util.concurrent.Future;
19  import java.util.concurrent.TimeUnit;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package com.earth2me.essentials.xmpp;
2  import com.earth2me.essentials.Console;
3  import com.earth2me.essentials.EssentialsConf;
4  import com.earth2me.essentials.IConf;
5  import net.ess3.api.IUser;
6  import com.earth2me.essentials.utils.FormatUtil;
7  import java.io.File;
8  import java.util.*;
9  import java.util.logging.Handler;
10  import java.util.logging.Level;
11  import java.util.logging.LogRecord;
12  import java.util.logging.Logger;
13  import java.util.logging.SimpleFormatter;
14  import org.bukkit.entity.Player;
15  import org.jivesoftware.smack.*;
16  import org.jivesoftware.smack.Roster.SubscriptionMode;
17  import org.jivesoftware.smack.packet.Message;
18  import org.jivesoftware.smack.packet.Presence;
19  import org.jivesoftware.smack.util.StringUtils;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    