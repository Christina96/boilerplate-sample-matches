<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for CleanerJava6.java & SocketStringEchoTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for CleanerJava6.java & SocketStringEchoTest.java
      </h3>
      <h1 align="center">
        7.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>CleanerJava6.java (9.947644%)<TH>SocketStringEchoTest.java (5.882353%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match559806-0.html#0',2,'match559806-1.html#0',3)" NAME="0">(145-150)<TD><A HREF="javascript:ZweiFrames('match559806-0.html#0',2,'match559806-1.html#0',3)" NAME="0">(174-180)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match559806-0.html#1',2,'match559806-1.html#1',3)" NAME="1">(18-35)<TD><A HREF="javascript:ZweiFrames('match559806-0.html#1',2,'match559806-1.html#1',3)" NAME="1">(32-43)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CleanerJava6.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
* Copyright 2014 The Netty Project
*
* The Netty Project licenses this file to you under the Apache License,
* version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at:
*
*   https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
* License for the specific language governing permissions and limitations
* under the License.
<A NAME="1"></A>*/
package io.netty.util.internal;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match559806-1.html#1',3,'match559806-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;


/**
 * Allows to free direct {@link ByteBuffer} by using Cleaner. This is encapsulated in an extra class to be able
 * to use {@link PlatformDependent0} on Android without problems.
 *
 * For more details see &lt;a href=&quot;https://github.com/netty/netty/issues/2604&quot;&gt;#2604&lt;/a&gt;.
 */
final class CleanerJava6 implements Cleaner {
    private static final long CLEANER_FIELD_OFFSET</B></FONT>;
    private static final Method CLEAN_METHOD;
    private static final Field CLEANER_FIELD;

    private static final InternalLogger logger = InternalLoggerFactory.getInstance(CleanerJava6.class);

    static {
        long fieldOffset;
        Method clean;
        Field cleanerField;
        Throwable error = null;
        final ByteBuffer direct = ByteBuffer.allocateDirect(1);
        try {
            Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
                @Override
                public Object run() {
                    try {
                        Field cleanerField =  direct.getClass().getDeclaredField(&quot;cleaner&quot;);
                        if (!PlatformDependent.hasUnsafe()) {
                            // We need to make it accessible if we do not use Unsafe as we will access it via
                            // reflection.
                            cleanerField.setAccessible(true);
                        }
                        return cleanerField;
                    } catch (Throwable cause) {
                        return cause;
                    }
                }
            });
            if (mayBeCleanerField instanceof Throwable) {
                throw (Throwable) mayBeCleanerField;
            }

            cleanerField = (Field) mayBeCleanerField;

            final Object cleaner;

            // If we have sun.misc.Unsafe we will use it as its faster then using reflection,
            // otherwise let us try reflection as last resort.
            if (PlatformDependent.hasUnsafe()) {
                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);
                cleaner = PlatformDependent0.getObject(direct, fieldOffset);
            } else {
                fieldOffset = -1;
                cleaner = cleanerField.get(direct);
            }
            clean = cleaner.getClass().getDeclaredMethod(&quot;clean&quot;);
            clean.invoke(cleaner);
        } catch (Throwable t) {
            // We don't have ByteBuffer.cleaner().
            fieldOffset = -1;
            clean = null;
            error = t;
            cleanerField = null;
        }

        if (error == null) {
            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): available&quot;);
        } else {
            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): unavailable&quot;, error);
        }
        CLEANER_FIELD = cleanerField;
        CLEANER_FIELD_OFFSET = fieldOffset;
        CLEAN_METHOD = clean;
    }

    static boolean isSupported() {
        return CLEANER_FIELD_OFFSET != -1 || CLEANER_FIELD != null;
    }

    @Override
    public void freeDirectBuffer(ByteBuffer buffer) {
        if (!buffer.isDirect()) {
            return;
        }
        if (System.getSecurityManager() == null) {
            try {
                freeDirectBuffer0(buffer);
            } catch (Throwable cause) {
                PlatformDependent0.throwException(cause);
            }
        } else {
            freeDirectBufferPrivileged(buffer);
        }
    }

    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {
        Throwable cause = AccessController.doPrivileged(new PrivilegedAction&lt;Throwable&gt;() {
            @Override
            public Throwable run() {
                try {
                    freeDirectBuffer0(buffer);
                    return null;
                } catch (Throwable cause) {
                    return cause;
                }
            }
        });
        if (cause != null) {
            PlatformDependent0.throwException(cause);
        }
    }

    private static void freeDirectBuffer0(ByteBuffer buffer) throws Exception {
        final Object cleaner;
        // If CLEANER_FIELD_OFFSET == -1 we need to use reflection to access the cleaner, otherwise we can use
        // sun.misc.Unsafe.
<A NAME="0"></A>        if (CLEANER_FIELD_OFFSET == -1) {
            cleaner = CLEANER_FIELD.get(buffer);
        } else {
            cleaner = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match559806-1.html#0',3,'match559806-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);
        }
        if (cleaner != null) {
            CLEAN_METHOD.invoke(cleaner);
        }
    }</B></FONT>
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SocketStringEchoTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.testsuite.transport.socket;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.Delimiters;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
<A NAME="1"></A>import io.netty.util.CharsetUtil;
import io.netty.util.concurrent.ImmediateEventExecutor;
import io.netty.util.concurrent.Promise;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match559806-0.html#1',2,'match559806-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;
import org.junit.jupiter.api.Timeout;

import java.io.IOException;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class SocketStringEchoTest extends AbstractSocketTest {

    static final Random random = new Random()</B></FONT>;
    static final String[] data = new String[1024];

    static {
        for (int i = 0; i &lt; data.length; i ++) {
            int eLen = random.nextInt(512);
            char[] e = new char[eLen];
            for (int j = 0; j &lt; eLen; j ++) {
                e[j] = (char) ('a' + random.nextInt(26));
            }

            data[i] = new String(e);
        }
    }

    @Test
    @Timeout(value = 60000, unit = TimeUnit.MILLISECONDS)
    public void testStringEcho(TestInfo testInfo) throws Throwable {
        run(testInfo, new Runner&lt;ServerBootstrap, Bootstrap&gt;() {
            @Override
            public void run(ServerBootstrap serverBootstrap, Bootstrap bootstrap) throws Throwable {
                testStringEcho(serverBootstrap, bootstrap);
            }
        });
    }

    public void testStringEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
        testStringEcho(sb, cb, true);
    }

    @Test
    @Timeout(value = 60000, unit = TimeUnit.MILLISECONDS)
    public void testStringEchoNotAutoRead(TestInfo testInfo) throws Throwable {
        run(testInfo, new Runner&lt;ServerBootstrap, Bootstrap&gt;() {
            @Override
            public void run(ServerBootstrap serverBootstrap, Bootstrap bootstrap) throws Throwable {
                testStringEchoNotAutoRead(serverBootstrap, bootstrap);
            }
        });
    }

    public void testStringEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
        testStringEcho(sb, cb, false);
    }

    private static void testStringEcho(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
        sb.childOption(ChannelOption.AUTO_READ, autoRead);
        cb.option(ChannelOption.AUTO_READ, autoRead);

        Promise&lt;Void&gt; serverDonePromise = ImmediateEventExecutor.INSTANCE.newPromise();
        Promise&lt;Void&gt; clientDonePromise = ImmediateEventExecutor.INSTANCE.newPromise();
        final StringEchoHandler sh = new StringEchoHandler(autoRead, serverDonePromise);
        final StringEchoHandler ch = new StringEchoHandler(autoRead, clientDonePromise);

        sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            public void initChannel(Channel sch) throws Exception {
                sch.pipeline().addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                sch.pipeline().addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.ISO_8859_1));
                sch.pipeline().addBefore(&quot;decoder&quot;, &quot;encoder&quot;, new StringEncoder(CharsetUtil.ISO_8859_1));
                sch.pipeline().addAfter(&quot;decoder&quot;, &quot;handler&quot;, sh);
            }
        });

        cb.handler(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            public void initChannel(Channel sch) throws Exception {
                sch.pipeline().addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                sch.pipeline().addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.ISO_8859_1));
                sch.pipeline().addBefore(&quot;decoder&quot;, &quot;encoder&quot;, new StringEncoder(CharsetUtil.ISO_8859_1));
                sch.pipeline().addAfter(&quot;decoder&quot;, &quot;handler&quot;, ch);
            }
        });

        Channel sc = sb.bind().sync().channel();
        Channel cc = cb.connect(sc.localAddress()).sync().channel();
        for (String element : data) {
            String delimiter = random.nextBoolean() ? &quot;\r\n&quot; : &quot;\n&quot;;
            cc.writeAndFlush(element + delimiter);
        }

        ch.donePromise.sync();
        sh.donePromise.sync();
        sh.channel.close().sync();
        ch.channel.close().sync();
        sc.close().sync();

        if (sh.exception.get() != null &amp;&amp; !(sh.exception.get() instanceof IOException)) {
            throw sh.exception.get();
        }
        if (ch.exception.get() != null &amp;&amp; !(ch.exception.get() instanceof IOException)) {
            throw ch.exception.get();
        }
        if (sh.exception.get() != null) {
            throw sh.exception.get();
        }
        if (ch.exception.get() != null) {
            throw ch.exception.get();
        }
    }

    static class StringEchoHandler extends SimpleChannelInboundHandler&lt;String&gt; {
        private final boolean autoRead;
        private final Promise&lt;Void&gt; donePromise;
        private int dataIndex;
        volatile Channel channel;
        final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();

        StringEchoHandler(boolean autoRead, Promise&lt;Void&gt; donePromise) {
            this.autoRead = autoRead;
            this.donePromise = donePromise;
        }

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            channel = ctx.channel();
            if (!autoRead) {
                ctx.read();
            }
        }

        @Override
        public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
            if (!data[dataIndex].equals(msg)) {
                donePromise.tryFailure(new IllegalStateException(&quot;index: &quot; + dataIndex + &quot; didn't match!&quot;));
                ctx.close();
                return;
            }
<A NAME="0"></A>
            if (channel.parent() != null) {
                String delimiter = random.nextBoolean() ? &quot;\r\n&quot; : &quot;\n&quot;;
                <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match559806-0.html#0',2,'match559806-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>channel.write(msg + delimiter);
            }

            if (++dataIndex &gt;= data.length) {
                donePromise.setSuccess(null);
            }
        }</B></FONT>

        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
            try {
                ctx.flush();
            } finally {
                if (!autoRead) {
                    ctx.read();
                }
            }
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            if (exception.compareAndSet(null, cause)) {
                donePromise.tryFailure(new IllegalStateException(&quot;exceptionCaught: &quot; + ctx.channel(), cause));
                ctx.close();
            }
        }

        @Override
        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
            donePromise.tryFailure(new IllegalStateException(&quot;channelInactive: &quot; + ctx.channel()));
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
