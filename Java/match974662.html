<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Functions.java &amp; MoreTypes.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Functions.java &amp; MoreTypes.java
      </h3>
<h1 align="center">
        16.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Functions.java (19.66759%)<th>MoreTypes.java (14.2%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-56)<td><a href="#" name="0">(20-51)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(535-551)<td><a href="#" name="1">(467-477)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(426-437)<td><a href="#" name="2">(413-420)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(304-308)<td><a href="#" name="3">(60-64)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(513-523)<td><a href="#" name="4">(438-446)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(190-196)<td><a href="#" name="5">(403-409)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(321-324)<td><a href="#" name="6">(196-198)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(297-300)<td><a href="#" name="7">(344-348)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(182-188)<td><a href="#" name="8">(497-504)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(479-485)<td><a href="#" name="9">(359-369)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(377-383)<td><a href="#" name="10">(64-67)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(172-176)<td><a href="#" name="11">(490-495)</a><td align="center"><font color="#680000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Functions.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package io.crate.metadata;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
<a name="0"></a>import io.crate.expression.symbol.format.Style;
import io.crate.metadata.functions.BoundVariables;
import io.crate.metadata.functions.Signature;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.metadata.functions.SignatureBinder;
import io.crate.metadata.pgcatalog.OidHash;
import io.crate.types.DataType;
import io.crate.types.DataTypes;
import io.crate.types.TypeSignature;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.logging.Loggers;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import static io.crate.common.collections.Lists2.getOnlyElement;
public class Functions {
    private static final Logger LOGGER = Loggers.getLogger(Functions.class)</b></font>;
    private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionImplementations = new ConcurrentHashMap&lt;&gt;();
    private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementations;
    public Functions copyOf() {
        var functions = new Functions(Map.copyOf(functionImplementations));
        functions.udfFunctionImplementations.putAll(udfFunctionImplementations);
        return functions;
    }
    @Inject
    public Functions(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementationsBySignature) {
        this.functionImplementations = functionImplementationsBySignature;
    }
    public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionResolvers() {
        return functionImplementations;
    }
    public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionResolvers() {
        return udfFunctionImplementations;
    }
    public void registerUdfFunctionImplementationsForSchema(
        String schema, Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions) {
        udfFunctionImplementations.entrySet()
            .removeIf(
                function -&gt;
                    schema.equals(function.getKey().schema())
                    &amp;&amp; functions.get(function.getKey()) == null);
        udfFunctionImplementations.putAll(functions);
    }
    public void deregisterUdfResolversForSchema(String schema) {
        udfFunctionImplementations.keySet()
            .removeIf(function -&gt; schema.equals(function.schema()));
    }
    @Nullable
    private static Signature findSignatureByOid(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions, int oid) {
        for (Map.Entry&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; func : functions.entrySet()) {
            for (FunctionProvider sig : func.getValue()) {
                if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {
                    return sig.getSignature();
                }
            }
        }
        return null;
    }
    @Nullable
    public Signature findFunctionSignatureByOid(int oid) {
        Signature sig = findSignatureByOid(udfFunctionImplementations, oid);
        return sig != null ? sig : findSignatureByOid(functionImplementations, oid);
    }
    public FunctionImplementation get(@Nullable String suppliedSchema,
                                      String functionName,
                                      List&lt;Symbol&gt; arguments,
                                      SearchPath searchPath) {
        return get(suppliedSchema, functionName, Symbols.typeView(arguments), arguments, searchPath);
    }
    private FunctionImplementation get(@Nullable String suppliedSchema,
                                       String functionName,
                                       List&lt;DataType&lt;?&gt;&gt; argumentTypes,
                                       List&lt;Symbol&gt; arguments,
                                       SearchPath searchPath) {
        FunctionName fqnName = new FunctionName(suppliedSchema, functionName);
        FunctionImplementation func = resolveFunctionBySignature(
            fqnName,
            argumentTypes,
            arguments,
            searchPath,
            functionImplementations
        );
        if (func == null) {
            func = resolveFunctionBySignature(
                fqnName,
                argumentTypes,
                arguments,
                searchPath,
                udfFunctionImplementations
            );
        }
        if (func == null) {
            raiseUnknownFunction(suppliedSchema, functionName, arguments, List.of());
        }
        return func;
    }
    @Nullable
    private FunctionImplementation get(Signature signature,
                                       List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
<a name="11"></a>                                       DataType&lt;?&gt; actualReturnType,
                                       Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = candidatesByName.get(signature.getName());
        if (candidates == null) <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
            return null;
        }
        for (var candidate : candidates) {
            if (candidate.getSignature().equals</b></font>(signature)) {
                var boundSignature = Signature.builder(signature)
                    .argumentTypes(Lists2.map(actualArgumentTypes, DataType::getTypeSignature))
<a name="8"></a>                    .returnType(actualReturnType.getTypeSignature())
                    .build();
                return candidate.getFactory().apply(signature, boundSignature);
            <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
        }
        return null;
    }
<a name="5"></a>    @Nullable
    private static FunctionImplementation resolveFunctionBySignature(FunctionName name</b></font>,
                                                                     List&lt;DataType&lt;?&gt;&gt; argumentTypes,
                                                                     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>List&lt;Symbol&gt; arguments,
                                                                     SearchPath searchPath,
                                                                     Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = getCandidates(name, searchPath, candidatesByName);
        if (candidates == null) {
            return null;
        }</b></font>
        assert candidates.stream().allMatch(f -&gt; f.getSignature().getBindingInfo() != null) :
            "Resolving/Matching of signatures can only be done with non-null signature's binding info";
        Iterable&lt;FunctionProvider&gt; exactCandidates = () -&gt; candidates.stream()
            .filter(function -&gt; function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
            .iterator();
        var match = matchFunctionCandidates(exactCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
        if (match != null) {
            return match;
        }
        Iterable&lt;FunctionProvider&gt; genericCandidates = () -&gt; candidates.stream()
            .filter(function -&gt; !function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
            .iterator();
        match = matchFunctionCandidates(genericCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
        if (match != null) {
            return match;
        }
        Iterable&lt;FunctionProvider&gt; candidatesAllowingCoercion = () -&gt; candidates.stream()
            .filter(function -&gt; function.getSignature().getBindingInfo().isCoercionAllowed())
            .iterator();
        match = matchFunctionCandidates(
            candidatesAllowingCoercion,
            argumentTypes,
            SignatureBinder.CoercionType.PRECEDENCE_ONLY
        );
        if (match != null) {
            return match;
        }
        match = matchFunctionCandidates(candidatesAllowingCoercion, argumentTypes, SignatureBinder.CoercionType.FULL);
        if (match == null) {
            raiseUnknownFunction(name.schema(), name.name(), arguments, candidates);
        }
        return match;
    }
    @Nullable
    private static List&lt;FunctionProvider&gt; getCandidates(FunctionName name,
                                                        SearchPath searchPath,
                                                        Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = candidatesByName.get(name);
        if (candidates == null &amp;&amp; name.schema() == null) {
            for (String pathSchema : searchPath) {
                FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());
                candidates = candidatesByName.get(searchPathFunctionName);
                if (candidates != null) {
                    return candidates;
                }
            }
        }
        return candidates;
    }
    @Nullable
    private static FunctionImplementation matchFunctionCandidates(Iterable&lt;FunctionProvider&gt; candidates,
                                                                  List&lt;DataType&lt;?&gt;&gt; arguments,
                                                                  SignatureBinder.CoercionType coercionType) {
        List&lt;ApplicableFunction&gt; applicableFunctions = new ArrayList&lt;&gt;();
        for (FunctionProvider candidate : candidates) {
            Signature boundSignature = new SignatureBinder(candidate.getSignature(), coercionType)
                .bind(Lists2.map(arguments, DataType::getTypeSignature));
            if (boundSignature != null) {
                applicableFunctions.add(
                    new ApplicableFunction(
                        candidate.getSignature(),
                        boundSignature,
                        candidate.getFactory()
                    )
                );
            }
        }
        if (coercionType != SignatureBinder.CoercionType.NONE) {
            applicableFunctions = selectMostSpecificFunctions(applicableFunctions, arguments);
            if (LOGGER.isDebugEnabled() &amp;&amp; applicableFunctions.isEmpty()) {
                LOGGER.debug("At least single function must be left after selecting most specific one");
            }
        }
        if (applicableFunctions.size() == 1) {
            return getOnlyElement(applicableFunctions).get();
        }
        if (applicableFunctions.size() &gt; 1) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Multiple candidates match! " + applicableFunctions);
            }
        }
        return null;
<a name="7"></a>    }
    public FunctionImplementation getQualified(io.crate.expression.symbol.Function function,
                                               <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SearchPath searchPath) {
        var signature = function.signature();
        if (signature != null) {
            return getQualified(signature, Symbols.typeView(function.arguments</b></font>()), function.valueType());
<a name="3"></a>        }
        return <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>get(
            function.info().ident().fqnName().schema(),
            function.info().ident().fqnName().name(),
            function.info().ident().argumentTypes(),
            function.arguments</b></font>(),
            searchPath
            );
    }
    public FunctionImplementation getQualified(io.crate.expression.symbol.Aggregation function,
                                               SearchPath searchPath) {
        var signature = function.signature();
        if (signature != null) {
            return getQualified(signature, Symbols.typeView(function.inputs()), function.boundSignatureReturnType());
<a name="6"></a>        }
        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return get(
            function.functionIdent().fqnName().schema(),
            function.functionIdent().fqnName().name(),
            function.functionIdent</b></font>().argumentTypes(),
            function.inputs(),
            searchPath
            );
    }
    public FunctionImplementation getQualified(Signature signature,
                                               List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
                                               DataType&lt;?&gt; actualReturnType) throws UnsupportedOperationException {
        FunctionImplementation impl = get(signature, actualArgumentTypes, actualReturnType, functionImplementations);
        if (impl == null) {
            impl = get(signature, actualArgumentTypes, actualReturnType, udfFunctionImplementations);
        }
        return impl;
    }
    @VisibleForTesting
    static void raiseUnknownFunction(@Nullable String suppliedSchema,
                                     String name,
                                     List&lt;Symbol&gt; arguments,
                                     List&lt;FunctionProvider&gt; candidates) {
        List&lt;DataType&lt;?&gt;&gt; argumentTypes = Symbols.typeView(arguments);
        var function = new io.crate.expression.symbol.Function(
            Signature.builder()
                .name(new FunctionName(suppliedSchema, name))
                .argumentTypes(Lists2.map(argumentTypes, DataType::getTypeSignature))
                .returnType(DataTypes.UNDEFINED.getTypeSignature())
                .kind(FunctionType.SCALAR)
                .build(),
            arguments,
            DataTypes.UNDEFINED
        );
        var message = "Unknown function: " + function.toString(Style.QUALIFIED);
        if (candidates.isEmpty() == false) {
            if (arguments.isEmpty() == false) {
                message = message + ", no overload found for matching argument types: "
                          + "(" + Lists2.joinOn(", ", argumentTypes, DataType::toString) + ").";
            } else {
                message = message + ".";
            }
            message = message + " Possible candidates: "
<a name="10"></a>                      + Lists2.joinOn(
                          ", ",
                          candidates,
                          c -&gt; <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>c.getSignature().getName().displayName()
                               + "("
                               + Lists2.joinOn(
                              ", ",
                              c.getSignature().getArgumentTypes(),
                              TypeSignature::toString)
                               + "):" + c.getSignature</b></font>().getReturnType().toString())
                      ;
        }
        throw new UnsupportedOperationException(message);
    }
    private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(List&lt;ApplicableFunction&gt; applicableFunctions,
                                                                        List&lt;DataType&lt;?&gt;&gt; arguments) {
        if (applicableFunctions.isEmpty()) {
            return applicableFunctions;
        }
        List&lt;TypeSignature&gt; argumentTypeSignatures = Lists2.map(arguments, DataType::getTypeSignature);
        List&lt;ApplicableFunction&gt; mostSpecificFunctions = selectMostSpecificFunctions(
            applicableFunctions,
            (l, r) -&gt; hasMoreExactTypeMatches(l, r, argumentTypeSignatures));
        if (mostSpecificFunctions.size() &lt;= 1) {
            return mostSpecificFunctions;
        }
        mostSpecificFunctions = selectMostSpecificFunctions(mostSpecificFunctions, Functions::isMoreSpecificThan);
        if (mostSpecificFunctions.size() &lt;= 1) {
            return mostSpecificFunctions;
        }
        //
        //
        //
        //
<a name="2"></a>        //
        if (returnTypeIsTheSame(mostSpecificFunctions)
            || arguments.stream().allMatch(s -&gt; s.id() == DataTypes.UNDEFINED.id())) {
            ApplicableFunction selectedFunction = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>mostSpecificFunctions.stream()
                .sorted(Comparator.comparing(Objects::toString))
                .iterator().next();
            return List.of(selectedFunction);
        }
        return mostSpecificFunctions;
    }
    private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(
        List&lt;ApplicableFunction&gt; candidates,
        BiFunction&lt;ApplicableFunction, ApplicableFunction, Boolean&gt; isMoreSpecific) {</b></font>
        List&lt;ApplicableFunction&gt; representatives = new ArrayList&lt;&gt;();
        for (ApplicableFunction current : candidates) {
            boolean found = false;
            for (int i = 0; i &lt; representatives.size(); i++) {
                ApplicableFunction representative = representatives.get(i);
                if (isMoreSpecific.apply(current, representative)) {
                    representatives.clear();
                    representatives.add(current);
                    found = true;
                    break;
                } else if (isMoreSpecific.apply(representative, current)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                representatives.add(current);
            }
        }
        return representatives;
    }
    private static boolean isMoreSpecificThan(ApplicableFunction left,
                                              ApplicableFunction right) {
        List&lt;TypeSignature&gt; resolvedTypes = left.getBoundSignature().getArgumentTypes();
        BoundVariables boundVariables = SignatureBinder.withPrecedenceOnly(right.getDeclaredSignature())
            .bindVariables(resolvedTypes);
        if (boundVariables == null) {
            return false;
<a name="9"></a>        }
        int leftArgsCount = left.getDeclaredSignature().getArgumentTypes().size();
        int rightArgsCount = <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>right.getDeclaredSignature().getArgumentTypes().size();
        return leftArgsCount &gt;= rightArgsCount;
    }
    private static boolean hasMoreExactTypeMatches(ApplicableFunction left,
                                                   ApplicableFunction right,
                                                   List&lt;TypeSignature&gt; actualArgumentTypes) {</b></font>
        int leftExactMatches = numberOfExactTypeMatches(
            actualArgumentTypes,
            left.getDeclaredSignature().getArgumentTypes()
        );
        int rightExactMatches = numberOfExactTypeMatches(
            actualArgumentTypes,
            right.getDeclaredSignature().getArgumentTypes()
        );
        return leftExactMatches &gt; rightExactMatches;
    }
    private static boolean returnTypeIsTheSame(List&lt;ApplicableFunction&gt; applicableFunctions) {
        Set&lt;DataType&lt;?&gt;&gt; returnTypes = applicableFunctions.stream()
            .map(function -&gt; function.getBoundSignature().getReturnType().createType())
            .collect(Collectors.toSet());
        return returnTypes.size() == 1;
    }
    private static int numberOfExactTypeMatches(List&lt;TypeSignature&gt; actualArgumentTypes,
                                                List&lt;TypeSignature&gt; declaredArgumentTypes) {
        int cnt = 0;
        for (int i = 0; i &lt; actualArgumentTypes.size(); i++) {
            if (declaredArgumentTypes.size() &gt; i &amp;&amp; actualArgumentTypes.get(i).equals(declaredArgumentTypes.get(i))) {
                cnt++;
<a name="4"></a>            }
        }
        return cnt;
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    private static class ApplicableFunction implements Supplier&lt;FunctionImplementation&gt; {
        private final Signature declaredSignature;
        private final Signature boundSignature;
        private final BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory;
        public ApplicableFunction(Signature declaredSignature,
                                  Signature boundSignature,
                                  BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory) {</b></font>
            this.declaredSignature = declaredSignature;
            this.boundSignature = boundSignature;
            this.factory = factory;
        }
        public Signature getDeclaredSignature() {
            return declaredSignature;
        }
<a name="1"></a>
        public Signature getBoundSignature() {
            return boundSignature;
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
        @Override
        public FunctionImplementation get() {
            return factory.apply(
                declaredSignature,
                boundSignature
            );
        }
        @Override
        public String toString() {
            return "ApplicableFunction{" +
                   "declaredSignature=" + declaredSignature +
                   ", boundSignature=" + boundSignature +
                   '}';
        }</b></font>
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreTypes.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package org.elasticsearch.common.inject.internal;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.common.inject.ConfigurationException;
import org.elasticsearch.common.inject.TypeLiteral;
import org.elasticsearch.common.inject.spi.Message;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import static java.util.Collections.singleton;
import static java.util.Collections.unmodifiableMap;
public class MoreTypes {
    public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{}</b></font>;
    private MoreTypes() {
    }
    private static final Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; PRIMITIVE_TO_WRAPPER;
<a name="3"></a>
    static {
        Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; primitiveToWrapper = new HashMap&lt;&gt;();
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>primitiveToWrapper.put(TypeLiteral.get(boolean.class), TypeLiteral.get(Boolean.class));
<a name="10"></a>        primitiveToWrapper.put(TypeLiteral.get(byte.class), TypeLiteral.get(Byte.class));
        primitiveToWrapper.put(TypeLiteral.get(short.class), TypeLiteral.get(Short.class));
        primitiveToWrapper.put(TypeLiteral.get(int.class), TypeLiteral.get(Integer.class));
        primitiveToWrapper.put</b></font>(<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>TypeLiteral.get(long.class), TypeLiteral.get(Long.class));
        primitiveToWrapper.put(TypeLiteral.get(float.class), TypeLiteral.get(Float.class));
        primitiveToWrapper.put(TypeLiteral.get(double.class), TypeLiteral.get(Double.class));
        primitiveToWrapper.put</b></font>(TypeLiteral.get(char.class), TypeLiteral.get(Character.class));
        primitiveToWrapper.put(TypeLiteral.get(void.class), TypeLiteral.get(Void.class));
        PRIMITIVE_TO_WRAPPER = unmodifiableMap(primitiveToWrapper);
    }
    public static &lt;T&gt; TypeLiteral&lt;T&gt; makeKeySafe(TypeLiteral&lt;T&gt; type) {
        if (!isFullySpecified(type.getType())) {
            String message = type + " cannot be used as a key; It is not fully specified.";
            throw new ConfigurationException(singleton(new Message(message)));
        }
        @SuppressWarnings("unchecked")
        TypeLiteral&lt;T&gt; wrappedPrimitives = (TypeLiteral&lt;T&gt;) PRIMITIVE_TO_WRAPPER.get(type);
        return wrappedPrimitives != null
                ? wrappedPrimitives
                : type;
    }
    private static boolean isFullySpecified(Type type) {
        if (type instanceof Class) {
            return true;
        } else if (type instanceof CompositeType) {
            return ((CompositeType) type).isFullySpecified();
        } else if (type instanceof TypeVariable) {
            return false;
        } else {
            return ((CompositeType) canonicalize(type)).isFullySpecified();
        }
    }
    public static Type canonicalize(Type type) {
        if (type instanceof ParameterizedTypeImpl
                || type instanceof GenericArrayTypeImpl
                || type instanceof WildcardTypeImpl) {
            return type;
        } else if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            return new ParameterizedTypeImpl(p.getOwnerType(),
                    p.getRawType(), p.getActualTypeArguments());
        } else if (type instanceof GenericArrayType) {
            GenericArrayType g = (GenericArrayType) type;
            return new GenericArrayTypeImpl(g.getGenericComponentType());
        } else if (type instanceof Class &amp;&amp; ((Class&lt;?&gt;) type).isArray()) {
            Class&lt;?&gt; c = (Class&lt;?&gt;) type;
            return new GenericArrayTypeImpl(c.getComponentType());
        } else if (type instanceof WildcardType) {
            WildcardType w = (WildcardType) type;
            return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
        } else {
            return type;
        }
    }
    public static Class&lt;?&gt; getRawType(Type type) {
        if (type instanceof Class&lt;?&gt;) {
            return (Class&lt;?&gt;) type;
        } else if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type rawType = parameterizedType.getRawType();
            if (!(rawType instanceof Class)) {
                throw new IllegalArgumentException(
                    "Expected a Class, but &lt;" + type + "&gt; is of type " + type.getClass().getName()
                );
            }
            return (Class&lt;?&gt;) rawType;
        } else if (type instanceof GenericArrayType) {
            return Object[].class;
        } else if (type instanceof TypeVariable) {
            return Object.class;
        } else {
            throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
                    + "GenericArrayType, but &lt;" + type + "&gt; is of type " + type.getClass().getName());
        }
    }
    public static boolean equals(Type a, Type b) {
        if (a == b) {
            return true;
        } else if (a instanceof Class) {
            return a.equals(b);
        } else if (a instanceof ParameterizedType) {
            if (!(b instanceof ParameterizedType)) {
                return false;
            }
<a name="6"></a>                        ParameterizedType pa = (ParameterizedType) a;
            ParameterizedType pb = (ParameterizedType) b;
            <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return Objects.equals(pa.getOwnerType(), pb.getOwnerType())
                    &amp;&amp; pa.getRawType().equals(pb.getRawType())
                    &amp;&amp; Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments</b></font>());
        } else if (a instanceof GenericArrayType) {
            if (!(b instanceof GenericArrayType)) {
                return false;
            }
            GenericArrayType ga = (GenericArrayType) a;
            GenericArrayType gb = (GenericArrayType) b;
            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
        } else if (a instanceof WildcardType) {
            if (!(b instanceof WildcardType)) {
                return false;
            }
            WildcardType wa = (WildcardType) a;
            WildcardType wb = (WildcardType) b;
            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
                    &amp;&amp; Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
        } else if (a instanceof TypeVariable) {
            if (!(b instanceof TypeVariable)) {
                return false;
            }
            TypeVariable&lt;?&gt; va = (TypeVariable) a;
            TypeVariable&lt;?&gt; vb = (TypeVariable) b;
            return va.getGenericDeclaration() == vb.getGenericDeclaration()
                    &amp;&amp; va.getName().equals(vb.getName());
        } else {
            return false;
        }
    }
    public static int hashCode(Type type) {
        if (type instanceof Class) {
            return type.hashCode();
        } else if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            return Arrays.hashCode(p.getActualTypeArguments())
                    ^ p.getRawType().hashCode()
                    ^ hashCodeOrZero(p.getOwnerType());
        } else if (type instanceof GenericArrayType) {
            return hashCode(((GenericArrayType) type).getGenericComponentType());
        } else if (type instanceof WildcardType) {
            WildcardType w = (WildcardType) type;
            return Arrays.hashCode(w.getLowerBounds()) ^ Arrays.hashCode(w.getUpperBounds());
        } else {
            return hashCodeOrZero(type);
        }
    }
    private static int hashCodeOrZero(Object o) {
        return o != null ? o.hashCode() : 0;
    }
    public static String toString(Type type) {
        if (type instanceof Class&lt;?&gt;) {
            return ((Class) type).getName();
        } else if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            Type ownerType = parameterizedType.getOwnerType();
            StringBuilder stringBuilder = new StringBuilder();
            if (ownerType != null) {
                stringBuilder.append(toString(ownerType)).append(".");
            }
            stringBuilder.append(toString(parameterizedType.getRawType()));
            if (arguments.length &gt; 0) {
                stringBuilder
                        .append("&lt;")
                        .append(toString(arguments[0]));
                for (int i = 1; i &lt; arguments.length; i++) {
                    stringBuilder.append(", ").append(toString(arguments[i]));
                }
            }
            return stringBuilder.append("&gt;").toString();
        } else if (type instanceof GenericArrayType) {
            return toString(((GenericArrayType) type).getGenericComponentType()) + "[]";
        } else if (type instanceof WildcardType) {
            WildcardType wildcardType = (WildcardType) type;
            Type[] lowerBounds = wildcardType.getLowerBounds();
            Type[] upperBounds = wildcardType.getUpperBounds();
            if (upperBounds.length != 1 || lowerBounds.length &gt; 1) {
                throw new UnsupportedOperationException("Unsupported wildcard type " + type);
            }
            if (lowerBounds.length == 1) {
                if (upperBounds[0] != Object.class) {
                    throw new UnsupportedOperationException("Unsupported wildcard type " + type);
                }
                return "? super " + toString(lowerBounds[0]);
            } else if (upperBounds[0] == Object.class) {
                return "?";
            } else {
                return "? extends " + toString(upperBounds[0]);
            }
        } else {
            return type.toString();
        }
    }
    public static Class&lt;? extends Member&gt; memberType(Member member) {
        Objects.requireNonNull(member, "member");
        if (member instanceof MemberImpl) {
            return ((MemberImpl) member).memberType;
        } else if (member instanceof Field) {
            return Field.class;
        } else if (member instanceof Method) {
            return Method.class;
        } else if (member instanceof Constructor) {
            return Constructor.class;
        } else {
            throw new IllegalArgumentException(
                    "Unsupported implementation class for Member, " + member.getClass());
        }
    }
    public static String toString(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Member member) {
        Class&lt;? extends Member&gt; memberType = memberType(member);
        if (memberType == Method.class) {
            return member.getDeclaringClass().getName() + "." + member.getName</b></font>() + "()";
        } else if (memberType == Field.class) {
            return member.getDeclaringClass().getName() + "." + member.getName();
        } else if (memberType == Constructor.class) {
            return member.getDeclaringClass().getName() + ".&lt;init&gt;()";
        } else {
            throw new AssertionError();
        }
<a name="9"></a>    }
    public static String memberKey(Member member) {
        <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Objects.requireNonNull(member, "member");
        return "&lt;NO_MEMBER_KEY&gt;";
    }
    public static Type getGenericSupertype(Type type, Class&lt;?&gt; rawType, Class&lt;?&gt; toResolve) {</b></font>
        if (toResolve == rawType) {
            return type;
        }
        if (toResolve.isInterface()) {
            Class[] interfaces = rawType.getInterfaces();
            for (int i = 0, length = interfaces.length; i &lt; length; i++) {
                if (interfaces[i] == toResolve) {
                    return rawType.getGenericInterfaces()[i];
                } else if (toResolve.isAssignableFrom(interfaces[i])) {
                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
                }
            }
        }
        if (!rawType.isInterface()) {
            while (rawType != Object.class) {
                Class&lt;?&gt; rawSupertype = rawType.getSuperclass();
                if (rawSupertype == toResolve) {
                    return rawType.getGenericSuperclass();
                } else if (toResolve.isAssignableFrom(rawSupertype)) {
                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
                }
                rawType = rawSupertype;
            }
        }
<a name="5"></a>        return toResolve;
    }
    public static Type resolveTypeVariable(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Type type, Class&lt;?&gt; rawType, TypeVariable unknown) {
        Class&lt;?&gt; declaredByRaw = declaringClassOf(unknown);
        if (declaredByRaw == null) {
            return unknown;
        }</b></font>
<a name="2"></a>
        Type declaredBy = getGenericSupertype(type, rawType, declaredByRaw);
        if (declaredBy instanceof ParameterizedType) {
            int index = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>indexOf(declaredByRaw.getTypeParameters(), unknown);
            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
        }
        return unknown;
    }
    private static int indexOf(Object[] array, Object toFind) {</b></font>
        for (int i = 0; i &lt; array.length; i++) {
            if (toFind.equals(array[i])) {
                return i;
            }
        }
        throw new NoSuchElementException();
    }
    private static Class&lt;?&gt; declaringClassOf(TypeVariable typeVariable) {
        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
<a name="4"></a>        return genericDeclaration instanceof Class
                ? (Class&lt;?&gt;) genericDeclaration
                : null;
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    public static class ParameterizedTypeImpl
            implements ParameterizedType, CompositeType {
        private final Type ownerType;
        private final Type rawType;
        private final Type[] typeArguments;
        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {</b></font>
            if (rawType instanceof Class&lt;?&gt;) {
                Class rawTypeAsClass = (Class) rawType;
                if (ownerType == null &amp;&amp; rawTypeAsClass.getEnclosingClass() != null) {
                    throw new IllegalArgumentException("No owner type for enclosed " + rawType);
                }
                if (ownerType != null &amp;&amp; rawTypeAsClass.getEnclosingClass() == null) {
                    throw new IllegalArgumentException("Owner type for unenclosed " + rawType);
                }
            }
            this.ownerType = ownerType == null ? null : canonicalize(ownerType);
            this.rawType = canonicalize(rawType);
            this.typeArguments = typeArguments.clone();
            for (int t = 0; t &lt; this.typeArguments.length; t++) {
                Objects.requireNonNull(this.typeArguments[t], "type parameter");
<a name="1"></a>                checkNotPrimitive(this.typeArguments[t], "type parameters");
                this.typeArguments[t] = canonicalize(this.typeArguments[t]);
            }
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
        @Override
        public Type[] getActualTypeArguments() {
            return typeArguments.clone();
        }
        @Override
        public Type getRawType() {
            return rawType;
        }</b></font>
        @Override
        public Type getOwnerType() {
            return ownerType;
        }
        @Override
        public boolean isFullySpecified() {
            if (ownerType != null &amp;&amp; !MoreTypes.isFullySpecified(ownerType)) {
<a name="11"></a>                return false;
            }
            if (!MoreTypes.isFullySpecified(rawType)) <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
                return false;
            }
<a name="8"></a>            for (Type type : typeArguments) {
                if (!MoreTypes.isFullySpecified</b></font>(type)) {
                    return false;
                <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
            }
            return true;
        }
        @Override
        public boolean equals(Object other</b></font>) {
            return other instanceof ParameterizedType
                    &amp;&amp; MoreTypes.equals(this, (ParameterizedType) other);
        }
        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }
        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }
    public static class GenericArrayTypeImpl
            implements GenericArrayType, CompositeType {
        private final Type componentType;
        public GenericArrayTypeImpl(Type componentType) {
            this.componentType = canonicalize(componentType);
        }
        @Override
        public Type getGenericComponentType() {
            return componentType;
        }
        @Override
        public boolean isFullySpecified() {
            return MoreTypes.isFullySpecified(componentType);
        }
        @Override
        public boolean equals(Object o) {
            return o instanceof GenericArrayType
                    &amp;&amp; MoreTypes.equals(this, (GenericArrayType) o);
        }
        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }
        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }
    public static class WildcardTypeImpl implements WildcardType, CompositeType {
        private final Type upperBound;
        private final Type lowerBound;
        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
            if (lowerBounds.length &gt; 1) {
                throw new IllegalArgumentException("Must have at most one lower bound.");
            }
            if (upperBounds.length != 1) {
                throw new IllegalArgumentException("Must have exactly one upper bound.");
            }
            if (lowerBounds.length == 1) {
                Objects.requireNonNull(lowerBounds[0], "lowerBound");
                checkNotPrimitive(lowerBounds[0], "wildcard bounds");
                if (upperBounds[0] != Object.class) {
                    throw new IllegalArgumentException("bounded both ways");
                }
                this.lowerBound = canonicalize(lowerBounds[0]);
                this.upperBound = Object.class;
            } else {
                Objects.requireNonNull(upperBounds[0], "upperBound");
                checkNotPrimitive(upperBounds[0], "wildcard bounds");
                this.lowerBound = null;
                this.upperBound = canonicalize(upperBounds[0]);
            }
        }
        @Override
        public Type[] getUpperBounds() {
            return new Type[]{upperBound};
        }
        @Override
        public Type[] getLowerBounds() {
            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
        }
        @Override
        public boolean isFullySpecified() {
            return MoreTypes.isFullySpecified(upperBound)
                    &amp;&amp; (lowerBound == null || MoreTypes.isFullySpecified(lowerBound));
        }
        @Override
        public boolean equals(Object other) {
            return other instanceof WildcardType
                    &amp;&amp; MoreTypes.equals(this, (WildcardType) other);
        }
        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }
        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }
    private static void checkNotPrimitive(Type type, String use) {
        if (type instanceof Class&lt;?&gt; &amp;&amp; ((Class) type).isPrimitive()) {
            throw new IllegalArgumentException("Primitive types are not allowed in " + use + ": " + type);
        }
    }
    public static class MemberImpl implements Member {
        private final Class&lt;?&gt; declaringClass;
        private final String name;
        private final int modifiers;
        private final boolean synthetic;
        private final Class&lt;? extends Member&gt; memberType;
        private final String memberKey;
        private MemberImpl(Member member) {
            this.declaringClass = member.getDeclaringClass();
            this.name = member.getName();
            this.modifiers = member.getModifiers();
            this.synthetic = member.isSynthetic();
            this.memberType = memberType(member);
            this.memberKey = memberKey(member);
        }
        @Override
        public Class getDeclaringClass() {
            return declaringClass;
        }
        @Override
        public String getName() {
            return name;
        }
        @Override
        public int getModifiers() {
            return modifiers;
        }
        @Override
        public boolean isSynthetic() {
            return synthetic;
        }
        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }
    private interface CompositeType {
        boolean isFullySpecified();
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
