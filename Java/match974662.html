<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Functions.java & MoreTypes.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Functions.java & MoreTypes.java
      </h3>
      <h1 align="center">
        16.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Functions.java (19.66759%)<TH>MoreTypes.java (14.2%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#0',2,'match974662-1.html#0',3)" NAME="0">(31-56)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#0',2,'match974662-1.html#0',3)" NAME="0">(20-51)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#1',2,'match974662-1.html#1',3)" NAME="1">(535-551)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#1',2,'match974662-1.html#1',3)" NAME="1">(467-477)</A><TD ALIGN=center><FONT COLOR="#ad0000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#2',2,'match974662-1.html#2',3)" NAME="2">(426-437)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#2',2,'match974662-1.html#2',3)" NAME="2">(413-420)</A><TD ALIGN=center><FONT COLOR="#960000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#3',2,'match974662-1.html#3',3)" NAME="3">(304-308)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#3',2,'match974662-1.html#3',3)" NAME="3">(60-64)</A><TD ALIGN=center><FONT COLOR="#960000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#4',2,'match974662-1.html#4',3)" NAME="4">(513-523)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#4',2,'match974662-1.html#4',3)" NAME="4">(438-446)</A><TD ALIGN=center><FONT COLOR="#7f0000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#5',2,'match974662-1.html#5',3)" NAME="5">(190-196)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#5',2,'match974662-1.html#5',3)" NAME="5">(403-409)</A><TD ALIGN=center><FONT COLOR="#7f0000">11</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#6',2,'match974662-1.html#6',3)" NAME="6">(321-324)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#6',2,'match974662-1.html#6',3)" NAME="6">(196-198)</A><TD ALIGN=center><FONT COLOR="#730000">10</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#7',2,'match974662-1.html#7',3)" NAME="7">(297-300)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#7',2,'match974662-1.html#7',3)" NAME="7">(344-348)</A><TD ALIGN=center><FONT COLOR="#730000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#8',2,'match974662-1.html#8',3)" NAME="8">(182-188)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#8',2,'match974662-1.html#8',3)" NAME="8">(497-504)</A><TD ALIGN=center><FONT COLOR="#730000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#9',2,'match974662-1.html#9',3)" NAME="9">(479-485)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#9',2,'match974662-1.html#9',3)" NAME="9">(359-369)</A><TD ALIGN=center><FONT COLOR="#680000">9</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#10',2,'match974662-1.html#10',3)" NAME="10">(377-383)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#10',2,'match974662-1.html#10',3)" NAME="10">(64-67)</A><TD ALIGN=center><FONT COLOR="#680000">9</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match974662-0.html#11',2,'match974662-1.html#11',3)" NAME="11">(172-176)<TD><A HREF="javascript:ZweiFrames('match974662-0.html#11',2,'match974662-1.html#11',3)" NAME="11">(490-495)</A><TD ALIGN=center><FONT COLOR="#680000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Functions.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.metadata;

import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
<A NAME="0"></A>import io.crate.expression.symbol.format.Style;
import io.crate.metadata.functions.BoundVariables;
import io.crate.metadata.functions.Signature;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match974662-1.html#0',3,'match974662-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.metadata.functions.SignatureBinder;
import io.crate.metadata.pgcatalog.OidHash;
import io.crate.types.DataType;
import io.crate.types.DataTypes;
import io.crate.types.TypeSignature;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.logging.Loggers;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static io.crate.common.collections.Lists2.getOnlyElement;

public class Functions {

    private static final Logger LOGGER = Loggers.getLogger(Functions.class)</B></FONT>;

    private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionImplementations = new ConcurrentHashMap&lt;&gt;();
    private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementations;

    public Functions copyOf() {
        var functions = new Functions(Map.copyOf(functionImplementations));
        functions.udfFunctionImplementations.putAll(udfFunctionImplementations);
        return functions;
    }

    @Inject
    public Functions(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementationsBySignature) {
        this.functionImplementations = functionImplementationsBySignature;
    }

    public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionResolvers() {
        return functionImplementations;
    }

    public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionResolvers() {
        return udfFunctionImplementations;
    }

    public void registerUdfFunctionImplementationsForSchema(
        String schema, Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions) {
        // remove deleted ones before re-registering all current ones for the given schema
        udfFunctionImplementations.entrySet()
            .removeIf(
                function -&gt;
                    schema.equals(function.getKey().schema())
                    &amp;&amp; functions.get(function.getKey()) == null);
        udfFunctionImplementations.putAll(functions);
    }

    public void deregisterUdfResolversForSchema(String schema) {
        udfFunctionImplementations.keySet()
            .removeIf(function -&gt; schema.equals(function.schema()));
    }

    @Nullable
    private static Signature findSignatureByOid(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions, int oid) {
        for (Map.Entry&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; func : functions.entrySet()) {
            for (FunctionProvider sig : func.getValue()) {
                if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {
                    return sig.getSignature();
                }
            }
        }
        return null;
    }

    @Nullable
    public Signature findFunctionSignatureByOid(int oid) {
        Signature sig = findSignatureByOid(udfFunctionImplementations, oid);
        return sig != null ? sig : findSignatureByOid(functionImplementations, oid);
    }

    /**
     * See {@link #get(String, String, List, List, SearchPath)}
     */
    public FunctionImplementation get(@Nullable String suppliedSchema,
                                      String functionName,
                                      List&lt;Symbol&gt; arguments,
                                      SearchPath searchPath) {
        return get(suppliedSchema, functionName, Symbols.typeView(arguments), arguments, searchPath);
    }

    /**
     * Return a function that matches the name/arguments.
     *
     * &lt;pre&gt;
     * {@code
     * Lookup logic:
     *     No schema:   Built-ins -&gt; Function or UDFs in searchPath
     *     With Schema: Function or UDFs in schema
     * }
     * &lt;/pre&gt;
     *
     * @throws UnsupportedOperationException if the function wasn't found
     */
    private FunctionImplementation get(@Nullable String suppliedSchema,
                                       String functionName,
                                       List&lt;DataType&lt;?&gt;&gt; argumentTypes,
                                       List&lt;Symbol&gt; arguments,
                                       SearchPath searchPath) {
        FunctionName fqnName = new FunctionName(suppliedSchema, functionName);
        FunctionImplementation func = resolveFunctionBySignature(
            fqnName,
            argumentTypes,
            arguments,
            searchPath,
            functionImplementations
        );
        if (func == null) {
            func = resolveFunctionBySignature(
                fqnName,
                argumentTypes,
                arguments,
                searchPath,
                udfFunctionImplementations
            );
        }
        if (func == null) {
            raiseUnknownFunction(suppliedSchema, functionName, arguments, List.of());
        }
        return func;
    }


    @Nullable
    private FunctionImplementation get(Signature signature,
                                       List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
<A NAME="11"></A>                                       DataType&lt;?&gt; actualReturnType,
                                       Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = candidatesByName.get(signature.getName());
        if (candidates == null) <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match974662-1.html#11',3,'match974662-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            return null;
        }
        for (var candidate : candidates) {
            if (candidate.getSignature().equals</B></FONT>(signature)) {
                var boundSignature = Signature.builder(signature)
                    .argumentTypes(Lists2.map(actualArgumentTypes, DataType::getTypeSignature))
<A NAME="8"></A>                    .returnType(actualReturnType.getTypeSignature())
                    .build();
                return candidate.getFactory().apply(signature, boundSignature);
            <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match974662-1.html#8',3,'match974662-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
        }
        return null;
    }

<A NAME="5"></A>    @Nullable
    private static FunctionImplementation resolveFunctionBySignature(FunctionName name</B></FONT>,
                                                                     List&lt;DataType&lt;?&gt;&gt; argumentTypes,
                                                                     <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match974662-1.html#5',3,'match974662-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>List&lt;Symbol&gt; arguments,
                                                                     SearchPath searchPath,
                                                                     Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = getCandidates(name, searchPath, candidatesByName);
        if (candidates == null) {
            return null;
        }</B></FONT>

        assert candidates.stream().allMatch(f -&gt; f.getSignature().getBindingInfo() != null) :
            &quot;Resolving/Matching of signatures can only be done with non-null signature's binding info&quot;;

        // First lets try exact candidates, no generic type variables, no coercion allowed.
        Iterable&lt;FunctionProvider&gt; exactCandidates = () -&gt; candidates.stream()
            .filter(function -&gt; function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
            .iterator();
        var match = matchFunctionCandidates(exactCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
        if (match != null) {
            return match;
        }

        // Second, try candidates with generic type variables, still no coercion allowed.
        Iterable&lt;FunctionProvider&gt; genericCandidates = () -&gt; candidates.stream()
            .filter(function -&gt; !function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
            .iterator();
        match = matchFunctionCandidates(genericCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
        if (match != null) {
            return match;
        }

        // Third, try all candidates which allow coercion with precedence based coercion.
        Iterable&lt;FunctionProvider&gt; candidatesAllowingCoercion = () -&gt; candidates.stream()
            .filter(function -&gt; function.getSignature().getBindingInfo().isCoercionAllowed())
            .iterator();
        match = matchFunctionCandidates(
            candidatesAllowingCoercion,
            argumentTypes,
            SignatureBinder.CoercionType.PRECEDENCE_ONLY
        );
        if (match != null) {
            return match;
        }

        // Last, try all candidates which allow coercion with full coercion.
        match = matchFunctionCandidates(candidatesAllowingCoercion, argumentTypes, SignatureBinder.CoercionType.FULL);

        if (match == null) {
            raiseUnknownFunction(name.schema(), name.name(), arguments, candidates);
        }
        return match;
    }

    @Nullable
    private static List&lt;FunctionProvider&gt; getCandidates(FunctionName name,
                                                        SearchPath searchPath,
                                                        Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
        var candidates = candidatesByName.get(name);
        if (candidates == null &amp;&amp; name.schema() == null) {
            for (String pathSchema : searchPath) {
                FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());
                candidates = candidatesByName.get(searchPathFunctionName);
                if (candidates != null) {
                    return candidates;
                }
            }
        }
        return candidates;
    }

    @Nullable
    private static FunctionImplementation matchFunctionCandidates(Iterable&lt;FunctionProvider&gt; candidates,
                                                                  List&lt;DataType&lt;?&gt;&gt; arguments,
                                                                  SignatureBinder.CoercionType coercionType) {
        List&lt;ApplicableFunction&gt; applicableFunctions = new ArrayList&lt;&gt;();
        for (FunctionProvider candidate : candidates) {
            Signature boundSignature = new SignatureBinder(candidate.getSignature(), coercionType)
                .bind(Lists2.map(arguments, DataType::getTypeSignature));
            if (boundSignature != null) {
                applicableFunctions.add(
                    new ApplicableFunction(
                        candidate.getSignature(),
                        boundSignature,
                        candidate.getFactory()
                    )
                );
            }
        }

        if (coercionType != SignatureBinder.CoercionType.NONE) {
            applicableFunctions = selectMostSpecificFunctions(applicableFunctions, arguments);
            if (LOGGER.isDebugEnabled() &amp;&amp; applicableFunctions.isEmpty()) {
                LOGGER.debug(&quot;At least single function must be left after selecting most specific one&quot;);
            }
        }

        if (applicableFunctions.size() == 1) {
            return getOnlyElement(applicableFunctions).get();
        }
        if (applicableFunctions.size() &gt; 1) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(&quot;Multiple candidates match! &quot; + applicableFunctions);
            }
        }

        return null;
<A NAME="7"></A>    }

    public FunctionImplementation getQualified(io.crate.expression.symbol.Function function,
                                               <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match974662-1.html#7',3,'match974662-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SearchPath searchPath) {
        var signature = function.signature();
        if (signature != null) {
            return getQualified(signature, Symbols.typeView(function.arguments</B></FONT>()), function.valueType());
<A NAME="3"></A>        }
        // Fallback to full function resolving
        // TODO: This is for BWC of older nodes, should be removed on the next major 5.0.
        return <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match974662-1.html#3',3,'match974662-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>get(
            function.info().ident().fqnName().schema(),
            function.info().ident().fqnName().name(),
            function.info().ident().argumentTypes(),
            function.arguments</B></FONT>(),
            searchPath
            );
    }

    public FunctionImplementation getQualified(io.crate.expression.symbol.Aggregation function,
                                               SearchPath searchPath) {
        var signature = function.signature();
        if (signature != null) {
            return getQualified(signature, Symbols.typeView(function.inputs()), function.boundSignatureReturnType());
<A NAME="6"></A>        }
        // Fallback to full function resolving
        // TODO: This is for BWC of older nodes, should be removed on the next major 5.0.
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match974662-1.html#6',3,'match974662-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return get(
            function.functionIdent().fqnName().schema(),
            function.functionIdent().fqnName().name(),
            function.functionIdent</B></FONT>().argumentTypes(),
            function.inputs(),
            searchPath
            );
    }

    /**
     * Returns the function implementation for the given function signature.
     * First look up function in built-ins then fallback to user-defined functions.
     *
     * @param signature The function signature.
     * @return The function implementation.
     * @throws UnsupportedOperationException if no implementation is found.
     */
    public FunctionImplementation getQualified(Signature signature,
                                               List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
                                               DataType&lt;?&gt; actualReturnType) throws UnsupportedOperationException {
        FunctionImplementation impl = get(signature, actualArgumentTypes, actualReturnType, functionImplementations);
        if (impl == null) {
            impl = get(signature, actualArgumentTypes, actualReturnType, udfFunctionImplementations);
        }
        return impl;
    }

    @VisibleForTesting
    static void raiseUnknownFunction(@Nullable String suppliedSchema,
                                     String name,
                                     List&lt;Symbol&gt; arguments,
                                     List&lt;FunctionProvider&gt; candidates) {
        List&lt;DataType&lt;?&gt;&gt; argumentTypes = Symbols.typeView(arguments);
        var function = new io.crate.expression.symbol.Function(
            Signature.builder()
                .name(new FunctionName(suppliedSchema, name))
                .argumentTypes(Lists2.map(argumentTypes, DataType::getTypeSignature))
                .returnType(DataTypes.UNDEFINED.getTypeSignature())
                .kind(FunctionType.SCALAR)
                .build(),
            arguments,
            DataTypes.UNDEFINED
        );

        var message = &quot;Unknown function: &quot; + function.toString(Style.QUALIFIED);
        if (candidates.isEmpty() == false) {
            if (arguments.isEmpty() == false) {
                message = message + &quot;, no overload found for matching argument types: &quot;
                          + &quot;(&quot; + Lists2.joinOn(&quot;, &quot;, argumentTypes, DataType::toString) + &quot;).&quot;;
            } else {
                message = message + &quot;.&quot;;
            }
            message = message + &quot; Possible candidates: &quot;
<A NAME="10"></A>                      + Lists2.joinOn(
                          &quot;, &quot;,
                          candidates,
                          c -&gt; <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match974662-1.html#10',3,'match974662-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>c.getSignature().getName().displayName()
                               + &quot;(&quot;
                               + Lists2.joinOn(
                              &quot;, &quot;,
                              c.getSignature().getArgumentTypes(),
                              TypeSignature::toString)
                               + &quot;):&quot; + c.getSignature</B></FONT>().getReturnType().toString())
                      ;
        }

        throw new UnsupportedOperationException(message);
    }

    private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(List&lt;ApplicableFunction&gt; applicableFunctions,
                                                                        List&lt;DataType&lt;?&gt;&gt; arguments) {
        if (applicableFunctions.isEmpty()) {
            return applicableFunctions;
        }

        // Find most specific by number of exact argument type matches
        List&lt;TypeSignature&gt; argumentTypeSignatures = Lists2.map(arguments, DataType::getTypeSignature);
        List&lt;ApplicableFunction&gt; mostSpecificFunctions = selectMostSpecificFunctions(
            applicableFunctions,
            (l, r) -&gt; hasMoreExactTypeMatches(l, r, argumentTypeSignatures));
        if (mostSpecificFunctions.size() &lt;= 1) {
            return mostSpecificFunctions;
        }

        // Find most specific by type precedence
        mostSpecificFunctions = selectMostSpecificFunctions(mostSpecificFunctions, Functions::isMoreSpecificThan);
        if (mostSpecificFunctions.size() &lt;= 1) {
            return mostSpecificFunctions;
        }

        // If the return type for all the selected function is the same
        // all the functions are semantically the same. We can return just any of those.
        //
        // Second, if all given arguments are UNDEFINED, we also return the first one.
        // This may not be 100% correct, but e.g. for
        //
        //   `concat(null, null)`
        //
        // we currently have no other option as we cannot specify which one should match by signatures.
        //
        //     `concat(text, text):text`
        //     `concat(array(E), array(E)):array(E)`
<A NAME="2"></A>        //
        if (returnTypeIsTheSame(mostSpecificFunctions)
            || arguments.stream().allMatch(s -&gt; s.id() == DataTypes.UNDEFINED.id())) {
            ApplicableFunction selectedFunction = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match974662-1.html#2',3,'match974662-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>mostSpecificFunctions.stream()
                .sorted(Comparator.comparing(Objects::toString))
                .iterator().next();

            return List.of(selectedFunction);
        }
        return mostSpecificFunctions;
    }

    private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(
        List&lt;ApplicableFunction&gt; candidates,
        BiFunction&lt;ApplicableFunction, ApplicableFunction, Boolean&gt; isMoreSpecific) {</B></FONT>
        List&lt;ApplicableFunction&gt; representatives = new ArrayList&lt;&gt;();

        for (ApplicableFunction current : candidates) {
            boolean found = false;
            for (int i = 0; i &lt; representatives.size(); i++) {
                ApplicableFunction representative = representatives.get(i);
                if (isMoreSpecific.apply(current, representative)) {
                    representatives.clear();
                    representatives.add(current);
                    found = true;
                    break;
                } else if (isMoreSpecific.apply(representative, current)) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                representatives.add(current);
            }
        }

        return representatives;
    }

    /**
     * One method is more specific than another if invocation handled by the first method
     * could be passed on to the other one.
     * Additionally possible variadic type signatures are taken into account,
     * an exact amount of declared type signatures is more specific than expanded variadic type signatures.
     */
    private static boolean isMoreSpecificThan(ApplicableFunction left,
                                              ApplicableFunction right) {
        List&lt;TypeSignature&gt; resolvedTypes = left.getBoundSignature().getArgumentTypes();
        BoundVariables boundVariables = SignatureBinder.withPrecedenceOnly(right.getDeclaredSignature())
            .bindVariables(resolvedTypes);
        if (boundVariables == null) {
            return false;
<A NAME="9"></A>        }

        int leftArgsCount = left.getDeclaredSignature().getArgumentTypes().size();
        int rightArgsCount = <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match974662-1.html#9',3,'match974662-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>right.getDeclaredSignature().getArgumentTypes().size();
        return leftArgsCount &gt;= rightArgsCount;
    }

    private static boolean hasMoreExactTypeMatches(ApplicableFunction left,
                                                   ApplicableFunction right,
                                                   List&lt;TypeSignature&gt; actualArgumentTypes) {</B></FONT>
        int leftExactMatches = numberOfExactTypeMatches(
            actualArgumentTypes,
            left.getDeclaredSignature().getArgumentTypes()
        );
        int rightExactMatches = numberOfExactTypeMatches(
            actualArgumentTypes,
            right.getDeclaredSignature().getArgumentTypes()
        );
        return leftExactMatches &gt; rightExactMatches;
    }

    private static boolean returnTypeIsTheSame(List&lt;ApplicableFunction&gt; applicableFunctions) {
        Set&lt;DataType&lt;?&gt;&gt; returnTypes = applicableFunctions.stream()
            .map(function -&gt; function.getBoundSignature().getReturnType().createType())
            .collect(Collectors.toSet());
        return returnTypes.size() == 1;
    }

    private static int numberOfExactTypeMatches(List&lt;TypeSignature&gt; actualArgumentTypes,
                                                List&lt;TypeSignature&gt; declaredArgumentTypes) {
        int cnt = 0;
        for (int i = 0; i &lt; actualArgumentTypes.size(); i++) {
            if (declaredArgumentTypes.size() &gt; i &amp;&amp; actualArgumentTypes.get(i).equals(declaredArgumentTypes.get(i))) {
                cnt++;
<A NAME="4"></A>            }
        }
        return cnt;
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match974662-1.html#4',3,'match974662-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    private static class ApplicableFunction implements Supplier&lt;FunctionImplementation&gt; {

        private final Signature declaredSignature;
        private final Signature boundSignature;
        private final BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory;

        public ApplicableFunction(Signature declaredSignature,
                                  Signature boundSignature,
                                  BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory) {</B></FONT>
            this.declaredSignature = declaredSignature;
            this.boundSignature = boundSignature;
            this.factory = factory;
        }

        public Signature getDeclaredSignature() {
            return declaredSignature;
        }
<A NAME="1"></A>
        public Signature getBoundSignature() {
            return boundSignature;
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match974662-1.html#1',3,'match974662-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

        @Override
        public FunctionImplementation get() {
            return factory.apply(
                declaredSignature,
                boundSignature
            );
        }

        @Override
        public String toString() {
            return &quot;ApplicableFunction{&quot; +
                   &quot;declaredSignature=&quot; + declaredSignature +
                   &quot;, boundSignature=&quot; + boundSignature +
                   '}';
        }</B></FONT>
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreTypes.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

<A NAME="0"></A>
package org.elasticsearch.common.inject.internal;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#0',2,'match974662-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.elasticsearch.common.inject.ConfigurationException;
import org.elasticsearch.common.inject.TypeLiteral;
import org.elasticsearch.common.inject.spi.Message;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;

import static java.util.Collections.singleton;
import static java.util.Collections.unmodifiableMap;

/**
 * Static methods for working with types that we aren't publishing in the
 * public {@code Types} API.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 */
public class MoreTypes {

    public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{}</B></FONT>;

    private MoreTypes() {
    }

    private static final Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; PRIMITIVE_TO_WRAPPER;
<A NAME="3"></A>
    static {
        Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; primitiveToWrapper = new HashMap&lt;&gt;();
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#3',2,'match974662-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>primitiveToWrapper.put(TypeLiteral.get(boolean.class), TypeLiteral.get(Boolean.class));
<A NAME="10"></A>        primitiveToWrapper.put(TypeLiteral.get(byte.class), TypeLiteral.get(Byte.class));
        primitiveToWrapper.put(TypeLiteral.get(short.class), TypeLiteral.get(Short.class));
        primitiveToWrapper.put(TypeLiteral.get(int.class), TypeLiteral.get(Integer.class));
        primitiveToWrapper.put</B></FONT>(<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#10',2,'match974662-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TypeLiteral.get(long.class), TypeLiteral.get(Long.class));
        primitiveToWrapper.put(TypeLiteral.get(float.class), TypeLiteral.get(Float.class));
        primitiveToWrapper.put(TypeLiteral.get(double.class), TypeLiteral.get(Double.class));
        primitiveToWrapper.put</B></FONT>(TypeLiteral.get(char.class), TypeLiteral.get(Character.class));
        primitiveToWrapper.put(TypeLiteral.get(void.class), TypeLiteral.get(Void.class));
        PRIMITIVE_TO_WRAPPER = unmodifiableMap(primitiveToWrapper);
    }

    /**
     * Returns an equivalent type that's safe for use in a key. The returned type will be free of
     * primitive types. Type literals of primitives will return the corresponding wrapper types.
     *
     * @throws ConfigurationException if {@code type} contains a type variable
     */
    public static &lt;T&gt; TypeLiteral&lt;T&gt; makeKeySafe(TypeLiteral&lt;T&gt; type) {
        if (!isFullySpecified(type.getType())) {
            String message = type + &quot; cannot be used as a key; It is not fully specified.&quot;;
            throw new ConfigurationException(singleton(new Message(message)));
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        TypeLiteral&lt;T&gt; wrappedPrimitives = (TypeLiteral&lt;T&gt;) PRIMITIVE_TO_WRAPPER.get(type);
        return wrappedPrimitives != null
                ? wrappedPrimitives
                : type;
    }

    /**
     * Returns true if {@code type} is free from type variables.
     */
    private static boolean isFullySpecified(Type type) {
        if (type instanceof Class) {
            return true;

        } else if (type instanceof CompositeType) {
            return ((CompositeType) type).isFullySpecified();

        } else if (type instanceof TypeVariable) {
            return false;

        } else {
            return ((CompositeType) canonicalize(type)).isFullySpecified();
        }
    }

    /**
     * Returns a type that is functionally equal but not necessarily equal
     * according to {@link Object#equals(Object) Object.equals()}.
     */
    public static Type canonicalize(Type type) {
        if (type instanceof ParameterizedTypeImpl
                || type instanceof GenericArrayTypeImpl
                || type instanceof WildcardTypeImpl) {
            return type;

        } else if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            return new ParameterizedTypeImpl(p.getOwnerType(),
                    p.getRawType(), p.getActualTypeArguments());

        } else if (type instanceof GenericArrayType) {
            GenericArrayType g = (GenericArrayType) type;
            return new GenericArrayTypeImpl(g.getGenericComponentType());

        } else if (type instanceof Class &amp;&amp; ((Class&lt;?&gt;) type).isArray()) {
            Class&lt;?&gt; c = (Class&lt;?&gt;) type;
            return new GenericArrayTypeImpl(c.getComponentType());

        } else if (type instanceof WildcardType) {
            WildcardType w = (WildcardType) type;
            return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());

        } else {
            // type is either serializable as-is or unsupported
            return type;
        }
    }

    public static Class&lt;?&gt; getRawType(Type type) {
        if (type instanceof Class&lt;?&gt;) {
            // type is a normal class.
            return (Class&lt;?&gt;) type;

        } else if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;

            // I'm not exactly sure why getRawType() returns Type instead of Class.
            // Neal isn't either but suspects some pathological case related
            // to nested classes exists.
            Type rawType = parameterizedType.getRawType();
            if (!(rawType instanceof Class)) {
                throw new IllegalArgumentException(
                    &quot;Expected a Class, but &lt;&quot; + type + &quot;&gt; is of type &quot; + type.getClass().getName()
                );
            }
            return (Class&lt;?&gt;) rawType;

        } else if (type instanceof GenericArrayType) {
            // TODO: Is this sufficient?
            return Object[].class;

        } else if (type instanceof TypeVariable) {
            // we could use the variable's bounds, but that'll won't work if there are multiple.
            // having a raw type that's more general than necessary is okay
            return Object.class;

        } else {
            throw new IllegalArgumentException(&quot;Expected a Class, ParameterizedType, or &quot;
                    + &quot;GenericArrayType, but &lt;&quot; + type + &quot;&gt; is of type &quot; + type.getClass().getName());
        }
    }

    /**
     * Returns true if {@code a} and {@code b} are equal.
     */
    public static boolean equals(Type a, Type b) {
        if (a == b) {
            // also handles (a == null &amp;&amp; b == null)
            return true;

        } else if (a instanceof Class) {
            // Class already specifies equals().
            return a.equals(b);

        } else if (a instanceof ParameterizedType) {
            if (!(b instanceof ParameterizedType)) {
                return false;
            }

<A NAME="6"></A>            // TODO: save a .clone() call
            ParameterizedType pa = (ParameterizedType) a;
            ParameterizedType pb = (ParameterizedType) b;
            <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#6',2,'match974662-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return Objects.equals(pa.getOwnerType(), pb.getOwnerType())
                    &amp;&amp; pa.getRawType().equals(pb.getRawType())
                    &amp;&amp; Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments</B></FONT>());

        } else if (a instanceof GenericArrayType) {
            if (!(b instanceof GenericArrayType)) {
                return false;
            }

            GenericArrayType ga = (GenericArrayType) a;
            GenericArrayType gb = (GenericArrayType) b;
            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());

        } else if (a instanceof WildcardType) {
            if (!(b instanceof WildcardType)) {
                return false;
            }

            WildcardType wa = (WildcardType) a;
            WildcardType wb = (WildcardType) b;
            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
                    &amp;&amp; Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());

        } else if (a instanceof TypeVariable) {
            if (!(b instanceof TypeVariable)) {
                return false;
            }
            TypeVariable&lt;?&gt; va = (TypeVariable) a;
            TypeVariable&lt;?&gt; vb = (TypeVariable) b;
            return va.getGenericDeclaration() == vb.getGenericDeclaration()
                    &amp;&amp; va.getName().equals(vb.getName());

        } else {
            // This isn't a type we support. Could be a generic array type, wildcard type, etc.
            return false;
        }
    }

    /**
     * Returns the hashCode of {@code type}.
     */
    public static int hashCode(Type type) {
        if (type instanceof Class) {
            // Class specifies hashCode().
            return type.hashCode();

        } else if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            return Arrays.hashCode(p.getActualTypeArguments())
                    ^ p.getRawType().hashCode()
                    ^ hashCodeOrZero(p.getOwnerType());

        } else if (type instanceof GenericArrayType) {
            return hashCode(((GenericArrayType) type).getGenericComponentType());

        } else if (type instanceof WildcardType) {
            WildcardType w = (WildcardType) type;
            return Arrays.hashCode(w.getLowerBounds()) ^ Arrays.hashCode(w.getUpperBounds());

        } else {
            // This isn't a type we support. Probably a type variable
            return hashCodeOrZero(type);
        }
    }

    private static int hashCodeOrZero(Object o) {
        return o != null ? o.hashCode() : 0;
    }

    public static String toString(Type type) {
        if (type instanceof Class&lt;?&gt;) {
            return ((Class) type).getName();

        } else if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            Type ownerType = parameterizedType.getOwnerType();
            StringBuilder stringBuilder = new StringBuilder();
            if (ownerType != null) {
                stringBuilder.append(toString(ownerType)).append(&quot;.&quot;);
            }
            stringBuilder.append(toString(parameterizedType.getRawType()));
            if (arguments.length &gt; 0) {
                stringBuilder
                        .append(&quot;&lt;&quot;)
                        .append(toString(arguments[0]));
                for (int i = 1; i &lt; arguments.length; i++) {
                    stringBuilder.append(&quot;, &quot;).append(toString(arguments[i]));
                }
            }
            return stringBuilder.append(&quot;&gt;&quot;).toString();

        } else if (type instanceof GenericArrayType) {
            return toString(((GenericArrayType) type).getGenericComponentType()) + &quot;[]&quot;;

        } else if (type instanceof WildcardType) {
            WildcardType wildcardType = (WildcardType) type;
            Type[] lowerBounds = wildcardType.getLowerBounds();
            Type[] upperBounds = wildcardType.getUpperBounds();

            if (upperBounds.length != 1 || lowerBounds.length &gt; 1) {
                throw new UnsupportedOperationException(&quot;Unsupported wildcard type &quot; + type);
            }

            if (lowerBounds.length == 1) {
                if (upperBounds[0] != Object.class) {
                    throw new UnsupportedOperationException(&quot;Unsupported wildcard type &quot; + type);
                }
                return &quot;? super &quot; + toString(lowerBounds[0]);
            } else if (upperBounds[0] == Object.class) {
                return &quot;?&quot;;
            } else {
                return &quot;? extends &quot; + toString(upperBounds[0]);
            }

        } else {
            return type.toString();
        }
    }

    /**
     * Returns {@code Field.class}, {@code Method.class} or {@code Constructor.class}.
     */
    public static Class&lt;? extends Member&gt; memberType(Member member) {
        Objects.requireNonNull(member, &quot;member&quot;);

        if (member instanceof MemberImpl) {
            return ((MemberImpl) member).memberType;

        } else if (member instanceof Field) {
            return Field.class;

        } else if (member instanceof Method) {
            return Method.class;

        } else if (member instanceof Constructor) {
            return Constructor.class;

        } else {
            throw new IllegalArgumentException(
                    &quot;Unsupported implementation class for Member, &quot; + member.getClass());
        }
    }

    /**
<A NAME="7"></A>     * Formats a member as concise string, such as {@code java.util.ArrayList.size},
     * {@code java.util.ArrayList&lt;init&gt;()} or {@code java.util.List.remove()}.
     */
    public static String toString(<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#7',2,'match974662-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Member member) {
        Class&lt;? extends Member&gt; memberType = memberType(member);

        if (memberType == Method.class) {
            return member.getDeclaringClass().getName() + &quot;.&quot; + member.getName</B></FONT>() + &quot;()&quot;;
        } else if (memberType == Field.class) {
            return member.getDeclaringClass().getName() + &quot;.&quot; + member.getName();
        } else if (memberType == Constructor.class) {
            return member.getDeclaringClass().getName() + &quot;.&lt;init&gt;()&quot;;
        } else {
            throw new AssertionError();
        }
<A NAME="9"></A>    }

    public static String memberKey(Member member) {
        <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#9',2,'match974662-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Objects.requireNonNull(member, &quot;member&quot;);

        return &quot;&lt;NO_MEMBER_KEY&gt;&quot;;
    }

    /**
     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set&lt;Integer&gt;} and the
     * result when the supertype is {@code Collection.class} is {@code Collection&lt;Integer&gt;}.
     */
    public static Type getGenericSupertype(Type type, Class&lt;?&gt; rawType, Class&lt;?&gt; toResolve) {</B></FONT>
        if (toResolve == rawType) {
            return type;
        }

        // we skip searching through interfaces if unknown is an interface
        if (toResolve.isInterface()) {
            Class[] interfaces = rawType.getInterfaces();
            for (int i = 0, length = interfaces.length; i &lt; length; i++) {
                if (interfaces[i] == toResolve) {
                    return rawType.getGenericInterfaces()[i];
                } else if (toResolve.isAssignableFrom(interfaces[i])) {
                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
                }
            }
        }

        // check our supertypes
        if (!rawType.isInterface()) {
            while (rawType != Object.class) {
                Class&lt;?&gt; rawSupertype = rawType.getSuperclass();
                if (rawSupertype == toResolve) {
                    return rawType.getGenericSuperclass();
                } else if (toResolve.isAssignableFrom(rawSupertype)) {
                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
                }
                rawType = rawSupertype;
            }
        }

        // we can't resolve this further
<A NAME="5"></A>        return toResolve;
    }

    public static Type resolveTypeVariable(<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#5',2,'match974662-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Type type, Class&lt;?&gt; rawType, TypeVariable unknown) {
        Class&lt;?&gt; declaredByRaw = declaringClassOf(unknown);

        // we can't reduce this further
        if (declaredByRaw == null) {
            return unknown;
        }</B></FONT>
<A NAME="2"></A>
        Type declaredBy = getGenericSupertype(type, rawType, declaredByRaw);
        if (declaredBy instanceof ParameterizedType) {
            int index = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#2',2,'match974662-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>indexOf(declaredByRaw.getTypeParameters(), unknown);
            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
        }

        return unknown;
    }

    private static int indexOf(Object[] array, Object toFind) {</B></FONT>
        for (int i = 0; i &lt; array.length; i++) {
            if (toFind.equals(array[i])) {
                return i;
            }
        }
        throw new NoSuchElementException();
    }

    /**
     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
     * a class.
     */
    private static Class&lt;?&gt; declaringClassOf(TypeVariable typeVariable) {
        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
<A NAME="4"></A>        return genericDeclaration instanceof Class
                ? (Class&lt;?&gt;) genericDeclaration
                : null;
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#4',2,'match974662-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public static class ParameterizedTypeImpl
            implements ParameterizedType, CompositeType {
        private final Type ownerType;
        private final Type rawType;
        private final Type[] typeArguments;

        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {</B></FONT>
            // require an owner type if the raw type needs it
            if (rawType instanceof Class&lt;?&gt;) {
                Class rawTypeAsClass = (Class) rawType;
                if (ownerType == null &amp;&amp; rawTypeAsClass.getEnclosingClass() != null) {
                    throw new IllegalArgumentException(&quot;No owner type for enclosed &quot; + rawType);
                }
                if (ownerType != null &amp;&amp; rawTypeAsClass.getEnclosingClass() == null) {
                    throw new IllegalArgumentException(&quot;Owner type for unenclosed &quot; + rawType);
                }

            }

            this.ownerType = ownerType == null ? null : canonicalize(ownerType);
            this.rawType = canonicalize(rawType);
            this.typeArguments = typeArguments.clone();
            for (int t = 0; t &lt; this.typeArguments.length; t++) {
                Objects.requireNonNull(this.typeArguments[t], &quot;type parameter&quot;);
<A NAME="1"></A>                checkNotPrimitive(this.typeArguments[t], &quot;type parameters&quot;);
                this.typeArguments[t] = canonicalize(this.typeArguments[t]);
            }
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#1',2,'match974662-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        @Override
        public Type[] getActualTypeArguments() {
            return typeArguments.clone();
        }

        @Override
        public Type getRawType() {
            return rawType;
        }</B></FONT>

        @Override
        public Type getOwnerType() {
            return ownerType;
        }

        @Override
        public boolean isFullySpecified() {
            if (ownerType != null &amp;&amp; !MoreTypes.isFullySpecified(ownerType)) {
<A NAME="11"></A>                return false;
            }

            if (!MoreTypes.isFullySpecified(rawType)) <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#11',2,'match974662-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                return false;
            }

<A NAME="8"></A>            for (Type type : typeArguments) {
                if (!MoreTypes.isFullySpecified</B></FONT>(type)) {
                    return false;
                <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match974662-0.html#8',2,'match974662-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }

            return true;
        }

        @Override
        public boolean equals(Object other</B></FONT>) {
            return other instanceof ParameterizedType
                    &amp;&amp; MoreTypes.equals(this, (ParameterizedType) other);
        }

        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }

        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }

    public static class GenericArrayTypeImpl
            implements GenericArrayType, CompositeType {
        private final Type componentType;

        public GenericArrayTypeImpl(Type componentType) {
            this.componentType = canonicalize(componentType);
        }

        @Override
        public Type getGenericComponentType() {
            return componentType;
        }

        @Override
        public boolean isFullySpecified() {
            return MoreTypes.isFullySpecified(componentType);
        }

        @Override
        public boolean equals(Object o) {
            return o instanceof GenericArrayType
                    &amp;&amp; MoreTypes.equals(this, (GenericArrayType) o);
        }

        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }

        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }

    /**
     * The WildcardType interface supports multiple upper bounds and multiple
     * lower bounds. We only support what the Java 6 language needs - at most one
     * bound. If a lower bound is set, the upper bound must be Object.class.
     */
    public static class WildcardTypeImpl implements WildcardType, CompositeType {
        private final Type upperBound;
        private final Type lowerBound;

        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
            if (lowerBounds.length &gt; 1) {
                throw new IllegalArgumentException(&quot;Must have at most one lower bound.&quot;);
            }
            if (upperBounds.length != 1) {
                throw new IllegalArgumentException(&quot;Must have exactly one upper bound.&quot;);
            }
            if (lowerBounds.length == 1) {
                Objects.requireNonNull(lowerBounds[0], &quot;lowerBound&quot;);
                checkNotPrimitive(lowerBounds[0], &quot;wildcard bounds&quot;);
                if (upperBounds[0] != Object.class) {
                    throw new IllegalArgumentException(&quot;bounded both ways&quot;);
                }
                this.lowerBound = canonicalize(lowerBounds[0]);
                this.upperBound = Object.class;

            } else {
                Objects.requireNonNull(upperBounds[0], &quot;upperBound&quot;);
                checkNotPrimitive(upperBounds[0], &quot;wildcard bounds&quot;);
                this.lowerBound = null;
                this.upperBound = canonicalize(upperBounds[0]);
            }
        }

        @Override
        public Type[] getUpperBounds() {
            return new Type[]{upperBound};
        }

        @Override
        public Type[] getLowerBounds() {
            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
        }

        @Override
        public boolean isFullySpecified() {
            return MoreTypes.isFullySpecified(upperBound)
                    &amp;&amp; (lowerBound == null || MoreTypes.isFullySpecified(lowerBound));
        }

        @Override
        public boolean equals(Object other) {
            return other instanceof WildcardType
                    &amp;&amp; MoreTypes.equals(this, (WildcardType) other);
        }

        @Override
        public int hashCode() {
            return MoreTypes.hashCode(this);
        }

        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }

    private static void checkNotPrimitive(Type type, String use) {
        if (type instanceof Class&lt;?&gt; &amp;&amp; ((Class) type).isPrimitive()) {
            throw new IllegalArgumentException(&quot;Primitive types are not allowed in &quot; + use + &quot;: &quot; + type);
        }
    }

    /**
     * We cannot serialize the built-in Java member classes, which prevents us from using Members in
     * our exception types. We workaround this with this serializable implementation. It includes all
     * of the API methods, plus everything we use for line numbers and messaging.
     */
    public static class MemberImpl implements Member {
        private final Class&lt;?&gt; declaringClass;
        private final String name;
        private final int modifiers;
        private final boolean synthetic;
        private final Class&lt;? extends Member&gt; memberType;
        private final String memberKey;

        private MemberImpl(Member member) {
            this.declaringClass = member.getDeclaringClass();
            this.name = member.getName();
            this.modifiers = member.getModifiers();
            this.synthetic = member.isSynthetic();
            this.memberType = memberType(member);
            this.memberKey = memberKey(member);
        }

        @Override
        public Class getDeclaringClass() {
            return declaringClass;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public int getModifiers() {
            return modifiers;
        }

        @Override
        public boolean isSynthetic() {
            return synthetic;
        }

        @Override
        public String toString() {
            return MoreTypes.toString(this);
        }
    }

    /**
     * A type formed from other types, such as arrays, parameterized types or wildcard types
     */
    private interface CompositeType {
        /**
         * Returns true if there are no type variables in this type.
         */
        boolean isFullySpecified();
    }
}
</PRE>
</div>
  </div>
</body>
</html>
