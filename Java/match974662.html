<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Functions.java &amp; MoreTypes.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Functions.java &amp; MoreTypes.java
      </h3>
<h1 align="center">
        16.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Functions.java (19.66759%)<th>MoreTypes.java (14.2%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-56)<td><a href="#" name="0">(20-51)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(535-551)<td><a href="#" name="1">(467-477)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(426-437)<td><a href="#" name="2">(413-420)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(304-308)<td><a href="#" name="3">(60-64)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(513-523)<td><a href="#" name="4">(438-446)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(190-196)<td><a href="#" name="5">(403-409)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(321-324)<td><a href="#" name="6">(196-198)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(297-300)<td><a href="#" name="7">(344-348)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(182-188)<td><a href="#" name="8">(497-504)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(479-485)<td><a href="#" name="9">(359-369)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(377-383)<td><a href="#" name="10">(64-67)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(172-176)<td><a href="#" name="11">(490-495)</a><td align="center"><font color="#680000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Functions.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.metadata;
2 import io.crate.common.annotations.VisibleForTesting;
3 import io.crate.common.collections.Lists2;
4 import io.crate.expression.symbol.Symbol;
5 import io.crate.expression.symbol.Symbols;
6 <a name="0"></a>import io.crate.expression.symbol.format.Style;
7 import io.crate.metadata.functions.BoundVariables;
8 import io.crate.metadata.functions.Signature;
9 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.metadata.functions.SignatureBinder;
10 import io.crate.metadata.pgcatalog.OidHash;
11 import io.crate.types.DataType;
12 import io.crate.types.DataTypes;
13 import io.crate.types.TypeSignature;
14 import org.apache.logging.log4j.Logger;
15 import org.elasticsearch.common.inject.Inject;
16 import org.elasticsearch.common.logging.Loggers;
17 import javax.annotation.Nullable;
18 import java.util.ArrayList;
19 import java.util.Comparator;
20 import java.util.List;
21 import java.util.Map;
22 import java.util.Objects;
23 import java.util.Set;
24 import java.util.concurrent.ConcurrentHashMap;
25 import java.util.function.BiFunction;
26 import java.util.function.Supplier;
27 import java.util.stream.Collectors;
28 import static io.crate.common.collections.Lists2.getOnlyElement;
29 public class Functions {
30     private static final Logger LOGGER = Loggers.getLogger(Functions.class)</b></font>;
31     private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionImplementations = new ConcurrentHashMap&lt;&gt;();
32     private final Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementations;
33     public Functions copyOf() {
34         var functions = new Functions(Map.copyOf(functionImplementations));
35         functions.udfFunctionImplementations.putAll(udfFunctionImplementations);
36         return functions;
37     }
38     @Inject
39     public Functions(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementationsBySignature) {
40         this.functionImplementations = functionImplementationsBySignature;
41     }
42     public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionResolvers() {
43         return functionImplementations;
44     }
45     public Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; udfFunctionResolvers() {
46         return udfFunctionImplementations;
47     }
48     public void registerUdfFunctionImplementationsForSchema(
49         String schema, Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions) {
50         udfFunctionImplementations.entrySet()
51             .removeIf(
52                 function -&gt;
53                     schema.equals(function.getKey().schema())
54                     &amp;&amp; functions.get(function.getKey()) == null);
55         udfFunctionImplementations.putAll(functions);
56     }
57     public void deregisterUdfResolversForSchema(String schema) {
58         udfFunctionImplementations.keySet()
59             .removeIf(function -&gt; schema.equals(function.schema()));
60     }
61     @Nullable
62     private static Signature findSignatureByOid(Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functions, int oid) {
63         for (Map.Entry&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; func : functions.entrySet()) {
64             for (FunctionProvider sig : func.getValue()) {
65                 if (Objects.equals(oid, OidHash.functionOid(sig.getSignature()))) {
66                     return sig.getSignature();
67                 }
68             }
69         }
70         return null;
71     }
72     @Nullable
73     public Signature findFunctionSignatureByOid(int oid) {
74         Signature sig = findSignatureByOid(udfFunctionImplementations, oid);
75         return sig != null ? sig : findSignatureByOid(functionImplementations, oid);
76     }
77     public FunctionImplementation get(@Nullable String suppliedSchema,
78                                       String functionName,
79                                       List&lt;Symbol&gt; arguments,
80                                       SearchPath searchPath) {
81         return get(suppliedSchema, functionName, Symbols.typeView(arguments), arguments, searchPath);
82     }
83     private FunctionImplementation get(@Nullable String suppliedSchema,
84                                        String functionName,
85                                        List&lt;DataType&lt;?&gt;&gt; argumentTypes,
86                                        List&lt;Symbol&gt; arguments,
87                                        SearchPath searchPath) {
88         FunctionName fqnName = new FunctionName(suppliedSchema, functionName);
89         FunctionImplementation func = resolveFunctionBySignature(
90             fqnName,
91             argumentTypes,
92             arguments,
93             searchPath,
94             functionImplementations
95         );
96         if (func == null) {
97             func = resolveFunctionBySignature(
98                 fqnName,
99                 argumentTypes,
100                 arguments,
101                 searchPath,
102                 udfFunctionImplementations
103             );
104         }
105         if (func == null) {
106             raiseUnknownFunction(suppliedSchema, functionName, arguments, List.of());
107         }
108         return func;
109     }
110     @Nullable
111     private FunctionImplementation get(Signature signature,
112                                        List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
113 <a name="11"></a>                                       DataType&lt;?&gt; actualReturnType,
114                                        Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
115         var candidates = candidatesByName.get(signature.getName());
116         if (candidates == null) <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
117             return null;
118         }
119         for (var candidate : candidates) {
120             if (candidate.getSignature().equals</b></font>(signature)) {
121                 var boundSignature = Signature.builder(signature)
122                     .argumentTypes(Lists2.map(actualArgumentTypes, DataType::getTypeSignature))
123 <a name="8"></a>                    .returnType(actualReturnType.getTypeSignature())
124                     .build();
125                 return candidate.getFactory().apply(signature, boundSignature);
126             <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
127         }
128         return null;
129     }
130 <a name="5"></a>    @Nullable
131     private static FunctionImplementation resolveFunctionBySignature(FunctionName name</b></font>,
132                                                                      List&lt;DataType&lt;?&gt;&gt; argumentTypes,
133                                                                      <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>List&lt;Symbol&gt; arguments,
134                                                                      SearchPath searchPath,
135                                                                      Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
136         var candidates = getCandidates(name, searchPath, candidatesByName);
137         if (candidates == null) {
138             return null;
139         }</b></font>
140         assert candidates.stream().allMatch(f -&gt; f.getSignature().getBindingInfo() != null) :
141             "Resolving/Matching of signatures can only be done with non-null signature's binding info";
142         Iterable&lt;FunctionProvider&gt; exactCandidates = () -&gt; candidates.stream()
143             .filter(function -&gt; function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
144             .iterator();
145         var match = matchFunctionCandidates(exactCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
146         if (match != null) {
147             return match;
148         }
149         Iterable&lt;FunctionProvider&gt; genericCandidates = () -&gt; candidates.stream()
150             .filter(function -&gt; !function.getSignature().getBindingInfo().getTypeVariableConstraints().isEmpty())
151             .iterator();
152         match = matchFunctionCandidates(genericCandidates, argumentTypes, SignatureBinder.CoercionType.NONE);
153         if (match != null) {
154             return match;
155         }
156         Iterable&lt;FunctionProvider&gt; candidatesAllowingCoercion = () -&gt; candidates.stream()
157             .filter(function -&gt; function.getSignature().getBindingInfo().isCoercionAllowed())
158             .iterator();
159         match = matchFunctionCandidates(
160             candidatesAllowingCoercion,
161             argumentTypes,
162             SignatureBinder.CoercionType.PRECEDENCE_ONLY
163         );
164         if (match != null) {
165             return match;
166         }
167         match = matchFunctionCandidates(candidatesAllowingCoercion, argumentTypes, SignatureBinder.CoercionType.FULL);
168         if (match == null) {
169             raiseUnknownFunction(name.schema(), name.name(), arguments, candidates);
170         }
171         return match;
172     }
173     @Nullable
174     private static List&lt;FunctionProvider&gt; getCandidates(FunctionName name,
175                                                         SearchPath searchPath,
176                                                         Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; candidatesByName) {
177         var candidates = candidatesByName.get(name);
178         if (candidates == null &amp;&amp; name.schema() == null) {
179             for (String pathSchema : searchPath) {
180                 FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());
181                 candidates = candidatesByName.get(searchPathFunctionName);
182                 if (candidates != null) {
183                     return candidates;
184                 }
185             }
186         }
187         return candidates;
188     }
189     @Nullable
190     private static FunctionImplementation matchFunctionCandidates(Iterable&lt;FunctionProvider&gt; candidates,
191                                                                   List&lt;DataType&lt;?&gt;&gt; arguments,
192                                                                   SignatureBinder.CoercionType coercionType) {
193         List&lt;ApplicableFunction&gt; applicableFunctions = new ArrayList&lt;&gt;();
194         for (FunctionProvider candidate : candidates) {
195             Signature boundSignature = new SignatureBinder(candidate.getSignature(), coercionType)
196                 .bind(Lists2.map(arguments, DataType::getTypeSignature));
197             if (boundSignature != null) {
198                 applicableFunctions.add(
199                     new ApplicableFunction(
200                         candidate.getSignature(),
201                         boundSignature,
202                         candidate.getFactory()
203                     )
204                 );
205             }
206         }
207         if (coercionType != SignatureBinder.CoercionType.NONE) {
208             applicableFunctions = selectMostSpecificFunctions(applicableFunctions, arguments);
209             if (LOGGER.isDebugEnabled() &amp;&amp; applicableFunctions.isEmpty()) {
210                 LOGGER.debug("At least single function must be left after selecting most specific one");
211             }
212         }
213         if (applicableFunctions.size() == 1) {
214             return getOnlyElement(applicableFunctions).get();
215         }
216         if (applicableFunctions.size() &gt; 1) {
217             if (LOGGER.isDebugEnabled()) {
218                 LOGGER.debug("Multiple candidates match! " + applicableFunctions);
219             }
220         }
221         return null;
222 <a name="7"></a>    }
223     public FunctionImplementation getQualified(io.crate.expression.symbol.Function function,
224                                                <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SearchPath searchPath) {
225         var signature = function.signature();
226         if (signature != null) {
227             return getQualified(signature, Symbols.typeView(function.arguments</b></font>()), function.valueType());
228 <a name="3"></a>        }
229         return <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>get(
230             function.info().ident().fqnName().schema(),
231             function.info().ident().fqnName().name(),
232             function.info().ident().argumentTypes(),
233             function.arguments</b></font>(),
234             searchPath
235             );
236     }
237     public FunctionImplementation getQualified(io.crate.expression.symbol.Aggregation function,
238                                                SearchPath searchPath) {
239         var signature = function.signature();
240         if (signature != null) {
241             return getQualified(signature, Symbols.typeView(function.inputs()), function.boundSignatureReturnType());
242 <a name="6"></a>        }
243         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return get(
244             function.functionIdent().fqnName().schema(),
245             function.functionIdent().fqnName().name(),
246             function.functionIdent</b></font>().argumentTypes(),
247             function.inputs(),
248             searchPath
249             );
250     }
251     public FunctionImplementation getQualified(Signature signature,
252                                                List&lt;DataType&lt;?&gt;&gt; actualArgumentTypes,
253                                                DataType&lt;?&gt; actualReturnType) throws UnsupportedOperationException {
254         FunctionImplementation impl = get(signature, actualArgumentTypes, actualReturnType, functionImplementations);
255         if (impl == null) {
256             impl = get(signature, actualArgumentTypes, actualReturnType, udfFunctionImplementations);
257         }
258         return impl;
259     }
260     @VisibleForTesting
261     static void raiseUnknownFunction(@Nullable String suppliedSchema,
262                                      String name,
263                                      List&lt;Symbol&gt; arguments,
264                                      List&lt;FunctionProvider&gt; candidates) {
265         List&lt;DataType&lt;?&gt;&gt; argumentTypes = Symbols.typeView(arguments);
266         var function = new io.crate.expression.symbol.Function(
267             Signature.builder()
268                 .name(new FunctionName(suppliedSchema, name))
269                 .argumentTypes(Lists2.map(argumentTypes, DataType::getTypeSignature))
270                 .returnType(DataTypes.UNDEFINED.getTypeSignature())
271                 .kind(FunctionType.SCALAR)
272                 .build(),
273             arguments,
274             DataTypes.UNDEFINED
275         );
276         var message = "Unknown function: " + function.toString(Style.QUALIFIED);
277         if (candidates.isEmpty() == false) {
278             if (arguments.isEmpty() == false) {
279                 message = message + ", no overload found for matching argument types: "
280                           + "(" + Lists2.joinOn(", ", argumentTypes, DataType::toString) + ").";
281             } else {
282                 message = message + ".";
283             }
284             message = message + " Possible candidates: "
285 <a name="10"></a>                      + Lists2.joinOn(
286                           ", ",
287                           candidates,
288                           c -&gt; <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>c.getSignature().getName().displayName()
289                                + "("
290                                + Lists2.joinOn(
291                               ", ",
292                               c.getSignature().getArgumentTypes(),
293                               TypeSignature::toString)
294                                + "):" + c.getSignature</b></font>().getReturnType().toString())
295                       ;
296         }
297         throw new UnsupportedOperationException(message);
298     }
299     private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(List&lt;ApplicableFunction&gt; applicableFunctions,
300                                                                         List&lt;DataType&lt;?&gt;&gt; arguments) {
301         if (applicableFunctions.isEmpty()) {
302             return applicableFunctions;
303         }
304         List&lt;TypeSignature&gt; argumentTypeSignatures = Lists2.map(arguments, DataType::getTypeSignature);
305         List&lt;ApplicableFunction&gt; mostSpecificFunctions = selectMostSpecificFunctions(
306             applicableFunctions,
307             (l, r) -&gt; hasMoreExactTypeMatches(l, r, argumentTypeSignatures));
308         if (mostSpecificFunctions.size() &lt;= 1) {
309             return mostSpecificFunctions;
310         }
311         mostSpecificFunctions = selectMostSpecificFunctions(mostSpecificFunctions, Functions::isMoreSpecificThan);
312         if (mostSpecificFunctions.size() &lt;= 1) {
313             return mostSpecificFunctions;
314         }
315         //
316         //
317         //
318         //
319 <a name="2"></a>        //
320         if (returnTypeIsTheSame(mostSpecificFunctions)
321             || arguments.stream().allMatch(s -&gt; s.id() == DataTypes.UNDEFINED.id())) {
322             ApplicableFunction selectedFunction = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>mostSpecificFunctions.stream()
323                 .sorted(Comparator.comparing(Objects::toString))
324                 .iterator().next();
325             return List.of(selectedFunction);
326         }
327         return mostSpecificFunctions;
328     }
329     private static List&lt;ApplicableFunction&gt; selectMostSpecificFunctions(
330         List&lt;ApplicableFunction&gt; candidates,
331         BiFunction&lt;ApplicableFunction, ApplicableFunction, Boolean&gt; isMoreSpecific) {</b></font>
332         List&lt;ApplicableFunction&gt; representatives = new ArrayList&lt;&gt;();
333         for (ApplicableFunction current : candidates) {
334             boolean found = false;
335             for (int i = 0; i &lt; representatives.size(); i++) {
336                 ApplicableFunction representative = representatives.get(i);
337                 if (isMoreSpecific.apply(current, representative)) {
338                     representatives.clear();
339                     representatives.add(current);
340                     found = true;
341                     break;
342                 } else if (isMoreSpecific.apply(representative, current)) {
343                     found = true;
344                     break;
345                 }
346             }
347             if (!found) {
348                 representatives.add(current);
349             }
350         }
351         return representatives;
352     }
353     private static boolean isMoreSpecificThan(ApplicableFunction left,
354                                               ApplicableFunction right) {
355         List&lt;TypeSignature&gt; resolvedTypes = left.getBoundSignature().getArgumentTypes();
356         BoundVariables boundVariables = SignatureBinder.withPrecedenceOnly(right.getDeclaredSignature())
357             .bindVariables(resolvedTypes);
358         if (boundVariables == null) {
359             return false;
360 <a name="9"></a>        }
361         int leftArgsCount = left.getDeclaredSignature().getArgumentTypes().size();
362         int rightArgsCount = <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>right.getDeclaredSignature().getArgumentTypes().size();
363         return leftArgsCount &gt;= rightArgsCount;
364     }
365     private static boolean hasMoreExactTypeMatches(ApplicableFunction left,
366                                                    ApplicableFunction right,
367                                                    List&lt;TypeSignature&gt; actualArgumentTypes) {</b></font>
368         int leftExactMatches = numberOfExactTypeMatches(
369             actualArgumentTypes,
370             left.getDeclaredSignature().getArgumentTypes()
371         );
372         int rightExactMatches = numberOfExactTypeMatches(
373             actualArgumentTypes,
374             right.getDeclaredSignature().getArgumentTypes()
375         );
376         return leftExactMatches &gt; rightExactMatches;
377     }
378     private static boolean returnTypeIsTheSame(List&lt;ApplicableFunction&gt; applicableFunctions) {
379         Set&lt;DataType&lt;?&gt;&gt; returnTypes = applicableFunctions.stream()
380             .map(function -&gt; function.getBoundSignature().getReturnType().createType())
381             .collect(Collectors.toSet());
382         return returnTypes.size() == 1;
383     }
384     private static int numberOfExactTypeMatches(List&lt;TypeSignature&gt; actualArgumentTypes,
385                                                 List&lt;TypeSignature&gt; declaredArgumentTypes) {
386         int cnt = 0;
387         for (int i = 0; i &lt; actualArgumentTypes.size(); i++) {
388             if (declaredArgumentTypes.size() &gt; i &amp;&amp; actualArgumentTypes.get(i).equals(declaredArgumentTypes.get(i))) {
389                 cnt++;
390 <a name="4"></a>            }
391         }
392         return cnt;
393     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
394     private static class ApplicableFunction implements Supplier&lt;FunctionImplementation&gt; {
395         private final Signature declaredSignature;
396         private final Signature boundSignature;
397         private final BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory;
398         public ApplicableFunction(Signature declaredSignature,
399                                   Signature boundSignature,
400                                   BiFunction&lt;Signature, Signature, FunctionImplementation&gt; factory) {</b></font>
401             this.declaredSignature = declaredSignature;
402             this.boundSignature = boundSignature;
403             this.factory = factory;
404         }
405         public Signature getDeclaredSignature() {
406             return declaredSignature;
407         }
408 <a name="1"></a>
409         public Signature getBoundSignature() {
410             return boundSignature;
411         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
412         @Override
413         public FunctionImplementation get() {
414             return factory.apply(
415                 declaredSignature,
416                 boundSignature
417             );
418         }
419         @Override
420         public String toString() {
421             return "ApplicableFunction{" +
422                    "declaredSignature=" + declaredSignature +
423                    ", boundSignature=" + boundSignature +
424                    '}';
425         }</b></font>
426     }
427 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreTypes.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.common.inject.internal;
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.common.inject.ConfigurationException;
4 import org.elasticsearch.common.inject.TypeLiteral;
5 import org.elasticsearch.common.inject.spi.Message;
6 import java.lang.reflect.Constructor;
7 import java.lang.reflect.Field;
8 import java.lang.reflect.GenericArrayType;
9 import java.lang.reflect.GenericDeclaration;
10 import java.lang.reflect.Member;
11 import java.lang.reflect.Method;
12 import java.lang.reflect.ParameterizedType;
13 import java.lang.reflect.Type;
14 import java.lang.reflect.TypeVariable;
15 import java.lang.reflect.WildcardType;
16 import java.util.Arrays;
17 import java.util.HashMap;
18 import java.util.Map;
19 import java.util.NoSuchElementException;
20 import java.util.Objects;
21 import static java.util.Collections.singleton;
22 import static java.util.Collections.unmodifiableMap;
23 public class MoreTypes {
24     public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{}</b></font>;
25     private MoreTypes() {
26     }
27     private static final Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; PRIMITIVE_TO_WRAPPER;
28 <a name="3"></a>
29     static {
30         Map&lt;TypeLiteral&lt;?&gt;, TypeLiteral&lt;?&gt;&gt; primitiveToWrapper = new HashMap&lt;&gt;();
31         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>primitiveToWrapper.put(TypeLiteral.get(boolean.class), TypeLiteral.get(Boolean.class));
32 <a name="10"></a>        primitiveToWrapper.put(TypeLiteral.get(byte.class), TypeLiteral.get(Byte.class));
33         primitiveToWrapper.put(TypeLiteral.get(short.class), TypeLiteral.get(Short.class));
34         primitiveToWrapper.put(TypeLiteral.get(int.class), TypeLiteral.get(Integer.class));
35         primitiveToWrapper.put</b></font>(<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>TypeLiteral.get(long.class), TypeLiteral.get(Long.class));
36         primitiveToWrapper.put(TypeLiteral.get(float.class), TypeLiteral.get(Float.class));
37         primitiveToWrapper.put(TypeLiteral.get(double.class), TypeLiteral.get(Double.class));
38         primitiveToWrapper.put</b></font>(TypeLiteral.get(char.class), TypeLiteral.get(Character.class));
39         primitiveToWrapper.put(TypeLiteral.get(void.class), TypeLiteral.get(Void.class));
40         PRIMITIVE_TO_WRAPPER = unmodifiableMap(primitiveToWrapper);
41     }
42     public static &lt;T&gt; TypeLiteral&lt;T&gt; makeKeySafe(TypeLiteral&lt;T&gt; type) {
43         if (!isFullySpecified(type.getType())) {
44             String message = type + " cannot be used as a key; It is not fully specified.";
45             throw new ConfigurationException(singleton(new Message(message)));
46         }
47         @SuppressWarnings("unchecked")
48         TypeLiteral&lt;T&gt; wrappedPrimitives = (TypeLiteral&lt;T&gt;) PRIMITIVE_TO_WRAPPER.get(type);
49         return wrappedPrimitives != null
50                 ? wrappedPrimitives
51                 : type;
52     }
53     private static boolean isFullySpecified(Type type) {
54         if (type instanceof Class) {
55             return true;
56         } else if (type instanceof CompositeType) {
57             return ((CompositeType) type).isFullySpecified();
58         } else if (type instanceof TypeVariable) {
59             return false;
60         } else {
61             return ((CompositeType) canonicalize(type)).isFullySpecified();
62         }
63     }
64     public static Type canonicalize(Type type) {
65         if (type instanceof ParameterizedTypeImpl
66                 || type instanceof GenericArrayTypeImpl
67                 || type instanceof WildcardTypeImpl) {
68             return type;
69         } else if (type instanceof ParameterizedType) {
70             ParameterizedType p = (ParameterizedType) type;
71             return new ParameterizedTypeImpl(p.getOwnerType(),
72                     p.getRawType(), p.getActualTypeArguments());
73         } else if (type instanceof GenericArrayType) {
74             GenericArrayType g = (GenericArrayType) type;
75             return new GenericArrayTypeImpl(g.getGenericComponentType());
76         } else if (type instanceof Class &amp;&amp; ((Class&lt;?&gt;) type).isArray()) {
77             Class&lt;?&gt; c = (Class&lt;?&gt;) type;
78             return new GenericArrayTypeImpl(c.getComponentType());
79         } else if (type instanceof WildcardType) {
80             WildcardType w = (WildcardType) type;
81             return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
82         } else {
83             return type;
84         }
85     }
86     public static Class&lt;?&gt; getRawType(Type type) {
87         if (type instanceof Class&lt;?&gt;) {
88             return (Class&lt;?&gt;) type;
89         } else if (type instanceof ParameterizedType) {
90             ParameterizedType parameterizedType = (ParameterizedType) type;
91             Type rawType = parameterizedType.getRawType();
92             if (!(rawType instanceof Class)) {
93                 throw new IllegalArgumentException(
94                     "Expected a Class, but &lt;" + type + "&gt; is of type " + type.getClass().getName()
95                 );
96             }
97             return (Class&lt;?&gt;) rawType;
98         } else if (type instanceof GenericArrayType) {
99             return Object[].class;
100         } else if (type instanceof TypeVariable) {
101             return Object.class;
102         } else {
103             throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
104                     + "GenericArrayType, but &lt;" + type + "&gt; is of type " + type.getClass().getName());
105         }
106     }
107     public static boolean equals(Type a, Type b) {
108         if (a == b) {
109             return true;
110         } else if (a instanceof Class) {
111             return a.equals(b);
112         } else if (a instanceof ParameterizedType) {
113             if (!(b instanceof ParameterizedType)) {
114                 return false;
115             }
116 <a name="6"></a>                        ParameterizedType pa = (ParameterizedType) a;
117             ParameterizedType pb = (ParameterizedType) b;
118             <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return Objects.equals(pa.getOwnerType(), pb.getOwnerType())
119                     &amp;&amp; pa.getRawType().equals(pb.getRawType())
120                     &amp;&amp; Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments</b></font>());
121         } else if (a instanceof GenericArrayType) {
122             if (!(b instanceof GenericArrayType)) {
123                 return false;
124             }
125             GenericArrayType ga = (GenericArrayType) a;
126             GenericArrayType gb = (GenericArrayType) b;
127             return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
128         } else if (a instanceof WildcardType) {
129             if (!(b instanceof WildcardType)) {
130                 return false;
131             }
132             WildcardType wa = (WildcardType) a;
133             WildcardType wb = (WildcardType) b;
134             return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
135                     &amp;&amp; Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
136         } else if (a instanceof TypeVariable) {
137             if (!(b instanceof TypeVariable)) {
138                 return false;
139             }
140             TypeVariable&lt;?&gt; va = (TypeVariable) a;
141             TypeVariable&lt;?&gt; vb = (TypeVariable) b;
142             return va.getGenericDeclaration() == vb.getGenericDeclaration()
143                     &amp;&amp; va.getName().equals(vb.getName());
144         } else {
145             return false;
146         }
147     }
148     public static int hashCode(Type type) {
149         if (type instanceof Class) {
150             return type.hashCode();
151         } else if (type instanceof ParameterizedType) {
152             ParameterizedType p = (ParameterizedType) type;
153             return Arrays.hashCode(p.getActualTypeArguments())
154                     ^ p.getRawType().hashCode()
155                     ^ hashCodeOrZero(p.getOwnerType());
156         } else if (type instanceof GenericArrayType) {
157             return hashCode(((GenericArrayType) type).getGenericComponentType());
158         } else if (type instanceof WildcardType) {
159             WildcardType w = (WildcardType) type;
160             return Arrays.hashCode(w.getLowerBounds()) ^ Arrays.hashCode(w.getUpperBounds());
161         } else {
162             return hashCodeOrZero(type);
163         }
164     }
165     private static int hashCodeOrZero(Object o) {
166         return o != null ? o.hashCode() : 0;
167     }
168     public static String toString(Type type) {
169         if (type instanceof Class&lt;?&gt;) {
170             return ((Class) type).getName();
171         } else if (type instanceof ParameterizedType) {
172             ParameterizedType parameterizedType = (ParameterizedType) type;
173             Type[] arguments = parameterizedType.getActualTypeArguments();
174             Type ownerType = parameterizedType.getOwnerType();
175             StringBuilder stringBuilder = new StringBuilder();
176             if (ownerType != null) {
177                 stringBuilder.append(toString(ownerType)).append(".");
178             }
179             stringBuilder.append(toString(parameterizedType.getRawType()));
180             if (arguments.length &gt; 0) {
181                 stringBuilder
182                         .append("&lt;")
183                         .append(toString(arguments[0]));
184                 for (int i = 1; i &lt; arguments.length; i++) {
185                     stringBuilder.append(", ").append(toString(arguments[i]));
186                 }
187             }
188             return stringBuilder.append("&gt;").toString();
189         } else if (type instanceof GenericArrayType) {
190             return toString(((GenericArrayType) type).getGenericComponentType()) + "[]";
191         } else if (type instanceof WildcardType) {
192             WildcardType wildcardType = (WildcardType) type;
193             Type[] lowerBounds = wildcardType.getLowerBounds();
194             Type[] upperBounds = wildcardType.getUpperBounds();
195             if (upperBounds.length != 1 || lowerBounds.length &gt; 1) {
196                 throw new UnsupportedOperationException("Unsupported wildcard type " + type);
197             }
198             if (lowerBounds.length == 1) {
199                 if (upperBounds[0] != Object.class) {
200                     throw new UnsupportedOperationException("Unsupported wildcard type " + type);
201                 }
202                 return "? super " + toString(lowerBounds[0]);
203             } else if (upperBounds[0] == Object.class) {
204                 return "?";
205             } else {
206                 return "? extends " + toString(upperBounds[0]);
207             }
208         } else {
209             return type.toString();
210         }
211     }
212     public static Class&lt;? extends Member&gt; memberType(Member member) {
213         Objects.requireNonNull(member, "member");
214         if (member instanceof MemberImpl) {
215             return ((MemberImpl) member).memberType;
216         } else if (member instanceof Field) {
217             return Field.class;
218         } else if (member instanceof Method) {
219             return Method.class;
220         } else if (member instanceof Constructor) {
221             return Constructor.class;
222         } else {
223             throw new IllegalArgumentException(
224                     "Unsupported implementation class for Member, " + member.getClass());
225         }
226     }
227     public static String toString(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Member member) {
228         Class&lt;? extends Member&gt; memberType = memberType(member);
229         if (memberType == Method.class) {
230             return member.getDeclaringClass().getName() + "." + member.getName</b></font>() + "()";
231         } else if (memberType == Field.class) {
232             return member.getDeclaringClass().getName() + "." + member.getName();
233         } else if (memberType == Constructor.class) {
234             return member.getDeclaringClass().getName() + ".&lt;init&gt;()";
235         } else {
236             throw new AssertionError();
237         }
238 <a name="9"></a>    }
239     public static String memberKey(Member member) {
240         <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Objects.requireNonNull(member, "member");
241         return "&lt;NO_MEMBER_KEY&gt;";
242     }
243     public static Type getGenericSupertype(Type type, Class&lt;?&gt; rawType, Class&lt;?&gt; toResolve) {</b></font>
244         if (toResolve == rawType) {
245             return type;
246         }
247         if (toResolve.isInterface()) {
248             Class[] interfaces = rawType.getInterfaces();
249             for (int i = 0, length = interfaces.length; i &lt; length; i++) {
250                 if (interfaces[i] == toResolve) {
251                     return rawType.getGenericInterfaces()[i];
252                 } else if (toResolve.isAssignableFrom(interfaces[i])) {
253                     return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
254                 }
255             }
256         }
257         if (!rawType.isInterface()) {
258             while (rawType != Object.class) {
259                 Class&lt;?&gt; rawSupertype = rawType.getSuperclass();
260                 if (rawSupertype == toResolve) {
261                     return rawType.getGenericSuperclass();
262                 } else if (toResolve.isAssignableFrom(rawSupertype)) {
263                     return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
264                 }
265                 rawType = rawSupertype;
266             }
267         }
268 <a name="5"></a>        return toResolve;
269     }
270     public static Type resolveTypeVariable(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Type type, Class&lt;?&gt; rawType, TypeVariable unknown) {
271         Class&lt;?&gt; declaredByRaw = declaringClassOf(unknown);
272         if (declaredByRaw == null) {
273             return unknown;
274         }</b></font>
275 <a name="2"></a>
276         Type declaredBy = getGenericSupertype(type, rawType, declaredByRaw);
277         if (declaredBy instanceof ParameterizedType) {
278             int index = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>indexOf(declaredByRaw.getTypeParameters(), unknown);
279             return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
280         }
281         return unknown;
282     }
283     private static int indexOf(Object[] array, Object toFind) {</b></font>
284         for (int i = 0; i &lt; array.length; i++) {
285             if (toFind.equals(array[i])) {
286                 return i;
287             }
288         }
289         throw new NoSuchElementException();
290     }
291     private static Class&lt;?&gt; declaringClassOf(TypeVariable typeVariable) {
292         GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
293 <a name="4"></a>        return genericDeclaration instanceof Class
294                 ? (Class&lt;?&gt;) genericDeclaration
295                 : null;
296     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
297     public static class ParameterizedTypeImpl
298             implements ParameterizedType, CompositeType {
299         private final Type ownerType;
300         private final Type rawType;
301         private final Type[] typeArguments;
302         public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {</b></font>
303             if (rawType instanceof Class&lt;?&gt;) {
304                 Class rawTypeAsClass = (Class) rawType;
305                 if (ownerType == null &amp;&amp; rawTypeAsClass.getEnclosingClass() != null) {
306                     throw new IllegalArgumentException("No owner type for enclosed " + rawType);
307                 }
308                 if (ownerType != null &amp;&amp; rawTypeAsClass.getEnclosingClass() == null) {
309                     throw new IllegalArgumentException("Owner type for unenclosed " + rawType);
310                 }
311             }
312             this.ownerType = ownerType == null ? null : canonicalize(ownerType);
313             this.rawType = canonicalize(rawType);
314             this.typeArguments = typeArguments.clone();
315             for (int t = 0; t &lt; this.typeArguments.length; t++) {
316                 Objects.requireNonNull(this.typeArguments[t], "type parameter");
317 <a name="1"></a>                checkNotPrimitive(this.typeArguments[t], "type parameters");
318                 this.typeArguments[t] = canonicalize(this.typeArguments[t]);
319             }
320         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
321         @Override
322         public Type[] getActualTypeArguments() {
323             return typeArguments.clone();
324         }
325         @Override
326         public Type getRawType() {
327             return rawType;
328         }</b></font>
329         @Override
330         public Type getOwnerType() {
331             return ownerType;
332         }
333         @Override
334         public boolean isFullySpecified() {
335             if (ownerType != null &amp;&amp; !MoreTypes.isFullySpecified(ownerType)) {
336 <a name="11"></a>                return false;
337             }
338             if (!MoreTypes.isFullySpecified(rawType)) <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
339                 return false;
340             }
341 <a name="8"></a>            for (Type type : typeArguments) {
342                 if (!MoreTypes.isFullySpecified</b></font>(type)) {
343                     return false;
344                 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
345             }
346             return true;
347         }
348         @Override
349         public boolean equals(Object other</b></font>) {
350             return other instanceof ParameterizedType
351                     &amp;&amp; MoreTypes.equals(this, (ParameterizedType) other);
352         }
353         @Override
354         public int hashCode() {
355             return MoreTypes.hashCode(this);
356         }
357         @Override
358         public String toString() {
359             return MoreTypes.toString(this);
360         }
361     }
362     public static class GenericArrayTypeImpl
363             implements GenericArrayType, CompositeType {
364         private final Type componentType;
365         public GenericArrayTypeImpl(Type componentType) {
366             this.componentType = canonicalize(componentType);
367         }
368         @Override
369         public Type getGenericComponentType() {
370             return componentType;
371         }
372         @Override
373         public boolean isFullySpecified() {
374             return MoreTypes.isFullySpecified(componentType);
375         }
376         @Override
377         public boolean equals(Object o) {
378             return o instanceof GenericArrayType
379                     &amp;&amp; MoreTypes.equals(this, (GenericArrayType) o);
380         }
381         @Override
382         public int hashCode() {
383             return MoreTypes.hashCode(this);
384         }
385         @Override
386         public String toString() {
387             return MoreTypes.toString(this);
388         }
389     }
390     public static class WildcardTypeImpl implements WildcardType, CompositeType {
391         private final Type upperBound;
392         private final Type lowerBound;
393         public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
394             if (lowerBounds.length &gt; 1) {
395                 throw new IllegalArgumentException("Must have at most one lower bound.");
396             }
397             if (upperBounds.length != 1) {
398                 throw new IllegalArgumentException("Must have exactly one upper bound.");
399             }
400             if (lowerBounds.length == 1) {
401                 Objects.requireNonNull(lowerBounds[0], "lowerBound");
402                 checkNotPrimitive(lowerBounds[0], "wildcard bounds");
403                 if (upperBounds[0] != Object.class) {
404                     throw new IllegalArgumentException("bounded both ways");
405                 }
406                 this.lowerBound = canonicalize(lowerBounds[0]);
407                 this.upperBound = Object.class;
408             } else {
409                 Objects.requireNonNull(upperBounds[0], "upperBound");
410                 checkNotPrimitive(upperBounds[0], "wildcard bounds");
411                 this.lowerBound = null;
412                 this.upperBound = canonicalize(upperBounds[0]);
413             }
414         }
415         @Override
416         public Type[] getUpperBounds() {
417             return new Type[]{upperBound};
418         }
419         @Override
420         public Type[] getLowerBounds() {
421             return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
422         }
423         @Override
424         public boolean isFullySpecified() {
425             return MoreTypes.isFullySpecified(upperBound)
426                     &amp;&amp; (lowerBound == null || MoreTypes.isFullySpecified(lowerBound));
427         }
428         @Override
429         public boolean equals(Object other) {
430             return other instanceof WildcardType
431                     &amp;&amp; MoreTypes.equals(this, (WildcardType) other);
432         }
433         @Override
434         public int hashCode() {
435             return MoreTypes.hashCode(this);
436         }
437         @Override
438         public String toString() {
439             return MoreTypes.toString(this);
440         }
441     }
442     private static void checkNotPrimitive(Type type, String use) {
443         if (type instanceof Class&lt;?&gt; &amp;&amp; ((Class) type).isPrimitive()) {
444             throw new IllegalArgumentException("Primitive types are not allowed in " + use + ": " + type);
445         }
446     }
447     public static class MemberImpl implements Member {
448         private final Class&lt;?&gt; declaringClass;
449         private final String name;
450         private final int modifiers;
451         private final boolean synthetic;
452         private final Class&lt;? extends Member&gt; memberType;
453         private final String memberKey;
454         private MemberImpl(Member member) {
455             this.declaringClass = member.getDeclaringClass();
456             this.name = member.getName();
457             this.modifiers = member.getModifiers();
458             this.synthetic = member.isSynthetic();
459             this.memberType = memberType(member);
460             this.memberKey = memberKey(member);
461         }
462         @Override
463         public Class getDeclaringClass() {
464             return declaringClass;
465         }
466         @Override
467         public String getName() {
468             return name;
469         }
470         @Override
471         public int getModifiers() {
472             return modifiers;
473         }
474         @Override
475         public boolean isSynthetic() {
476             return synthetic;
477         }
478         @Override
479         public String toString() {
480             return MoreTypes.toString(this);
481         }
482     }
483     private interface CompositeType {
484         boolean isFullySpecified();
485     }
486 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
