<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for HttpRequestDecoderTest.java & DefaultHttp2ConnectionEncoderTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for HttpRequestDecoderTest.java & DefaultHttp2ConnectionEncoderTest.java
      </h3>
      <h1 align="center">
        39.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>HttpRequestDecoderTest.java (62.264153%)<TH>DefaultHttp2ConnectionEncoderTest.java (28.767124%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#0',2,'match16902-1.html#0',3)" NAME="0">(354-380)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#0',2,'match16902-1.html#0',3)" NAME="0">(471-495)</A><TD ALIGN=center><FONT COLOR="#ff0000">36</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#1',2,'match16902-1.html#1',3)" NAME="1">(386-414)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#1',2,'match16902-1.html#1',3)" NAME="1">(555-579)</A><TD ALIGN=center><FONT COLOR="#e20000">32</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#2',2,'match16902-1.html#2',3)" NAME="2">(305-321)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#2',2,'match16902-1.html#2',3)" NAME="2">(442-456)</A><TD ALIGN=center><FONT COLOR="#b80000">26</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#3',2,'match16902-1.html#3',3)" NAME="3">(88-101)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#3',2,'match16902-1.html#3',3)" NAME="3">(362-374)</A><TD ALIGN=center><FONT COLOR="#9b0000">22</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#4',2,'match16902-1.html#4',3)" NAME="4">(223-238)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#4',2,'match16902-1.html#4',3)" NAME="4">(401-412)</A><TD ALIGN=center><FONT COLOR="#940000">21</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#5',2,'match16902-1.html#5',3)" NAME="5">(257-268)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#5',2,'match16902-1.html#5',3)" NAME="5">(620-629)</A><TD ALIGN=center><FONT COLOR="#8d0000">20</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#6',2,'match16902-1.html#6',3)" NAME="6">(18-40)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#6',2,'match16902-1.html#6',3)" NAME="6">(59-82)</A><TD ALIGN=center><FONT COLOR="#8d0000">20</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#7',2,'match16902-1.html#7',3)" NAME="7">(326-335)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#7',2,'match16902-1.html#7',3)" NAME="7">(682-693)</A><TD ALIGN=center><FONT COLOR="#860000">19</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#8',2,'match16902-1.html#8',3)" NAME="8">(559-565)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#8',2,'match16902-1.html#8',3)" NAME="8">(780-787)</A><TD ALIGN=center><FONT COLOR="#7f0000">18</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#9',2,'match16902-1.html#9',3)" NAME="9">(169-179)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#9',2,'match16902-1.html#9',3)" NAME="9">(391-399)</A><TD ALIGN=center><FONT COLOR="#7f0000">18</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#10',2,'match16902-1.html#10',3)" NAME="10">(69-82)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#10',2,'match16902-1.html#10',3)" NAME="10">(228-241)</A><TD ALIGN=center><FONT COLOR="#7f0000">18</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#11',2,'match16902-1.html#11',3)" NAME="11">(541-548)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#11',2,'match16902-1.html#11',3)" NAME="11">(333-339)</A><TD ALIGN=center><FONT COLOR="#780000">17</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#12',2,'match16902-1.html#12',3)" NAME="12">(339-348)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#12',2,'match16902-1.html#12',3)" NAME="12">(743-753)</A><TD ALIGN=center><FONT COLOR="#780000">17</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#13',2,'match16902-1.html#13',3)" NAME="13">(119-131)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#13',2,'match16902-1.html#13',3)" NAME="13">(524-536)</A><TD ALIGN=center><FONT COLOR="#780000">17</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#14',2,'match16902-1.html#14',3)" NAME="14">(287-292)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#14',2,'match16902-1.html#14',3)" NAME="14">(204-208)</A><TD ALIGN=center><FONT COLOR="#710000">16</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#15',2,'match16902-1.html#15',3)" NAME="15">(190-198)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#15',2,'match16902-1.html#15',3)" NAME="15">(804-811)</A><TD ALIGN=center><FONT COLOR="#710000">16</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#16',2,'match16902-1.html#16',3)" NAME="16">(577-582)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#16',2,'match16902-1.html#16',3)" NAME="16">(630-635)</A><TD ALIGN=center><FONT COLOR="#6a0000">15</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#17',2,'match16902-1.html#17',3)" NAME="17">(277-282)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#17',2,'match16902-1.html#17',3)" NAME="17">(264-270)</A><TD ALIGN=center><FONT COLOR="#630000">14</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#18',2,'match16902-1.html#18',3)" NAME="18">(420-434)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#18',2,'match16902-1.html#18',3)" NAME="18">(656-662)</A><TD ALIGN=center><FONT COLOR="#5c0000">13</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#19',2,'match16902-1.html#19',3)" NAME="19">(209-215)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#19',2,'match16902-1.html#19',3)" NAME="19">(711-716)</A><TD ALIGN=center><FONT COLOR="#550000">12</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#20',2,'match16902-1.html#20',3)" NAME="20">(153-160)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#20',2,'match16902-1.html#20',3)" NAME="20">(583-588)</A><TD ALIGN=center><FONT COLOR="#550000">12</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#21',2,'match16902-1.html#21',3)" NAME="21">(111-117)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#21',2,'match16902-1.html#21',3)" NAME="21">(612-619)</A><TD ALIGN=center><FONT COLOR="#550000">12</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#22',2,'match16902-1.html#22',3)" NAME="22">(293-300)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#22',2,'match16902-1.html#22',3)" NAME="22">(344-351)</A><TD ALIGN=center><FONT COLOR="#4d0000">11</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#23',2,'match16902-1.html#23',3)" NAME="23">(162-167)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#23',2,'match16902-1.html#23',3)" NAME="23">(700-704)</A><TD ALIGN=center><FONT COLOR="#4d0000">11</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#24',2,'match16902-1.html#24',3)" NAME="24">(248-253)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#24',2,'match16902-1.html#24',3)" NAME="24">(717-723)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#25',2,'match16902-1.html#25',3)" NAME="25">(102-110)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#25',2,'match16902-1.html#25',3)" NAME="25">(255-261)</A><TD ALIGN=center><FONT COLOR="#460000">10</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16902-0.html#26',2,'match16902-1.html#26',3)" NAME="26">(510-517)<TD><A HREF="javascript:ZweiFrames('match16902-0.html#26',2,'match16902-1.html#26',3)" NAME="26">(647-652)</A><TD ALIGN=center><FONT COLOR="#3f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>HttpRequestDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2013 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="6"></A> */
package io.netty.handler.codec.http;

<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match16902-1.html#6',3,'match16902-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.util.AsciiString;
import io.netty.util.CharsetUtil;
import org.junit.jupiter.api.Test;

import java.util.List;

import static io.netty.handler.codec.http.HttpHeaderNames.*;
import static io.netty.handler.codec.http.HttpHeadersTestUtils.of;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class HttpRequestDecoderTest {
    private static final byte[] CONTENT_CRLF_DELIMITERS = createContent(&quot;\r\n&quot;)</B></FONT>;
    private static final byte[] CONTENT_LF_DELIMITERS = createContent(&quot;\n&quot;);
    private static final byte[] CONTENT_MIXED_DELIMITERS = createContent(&quot;\r\n&quot;, &quot;\n&quot;);
    private static final int CONTENT_LENGTH = 8;

    private static byte[] createContent(String... lineDelimiters) {
        String lineDelimiter;
        String lineDelimiter2;
        if (lineDelimiters.length == 2) {
            lineDelimiter = lineDelimiters[0];
            lineDelimiter2 = lineDelimiters[1];
        } else {
            lineDelimiter = lineDelimiters[0];
            lineDelimiter2 = lineDelimiters[0];
        }
        return (&quot;GET /some/path?foo=bar&amp;wibble=eek HTTP/1.1&quot; + &quot;\r\n&quot; +
                &quot;Upgrade: WebSocket&quot; + lineDelimiter2 +
                &quot;Connection: Upgrade&quot; + lineDelimiter +
                &quot;Host: localhost&quot; + lineDelimiter2 +
                &quot;Origin: http://localhost:8080&quot; + lineDelimiter +
                &quot;Sec-WebSocket-Key1: 10  28 8V7 8 48     0&quot; + lineDelimiter2 +
                &quot;Sec-WebSocket-Key2: 8 Xt754O3Q3QW 0   _60&quot; + lineDelimiter +
                &quot;Content-Length: &quot; + CONTENT_LENGTH + lineDelimiter2 +
                &quot;\r\n&quot;  +
                &quot;12345678&quot;).getBytes(CharsetUtil.US_ASCII);
    }
<A NAME="10"></A>
    @Test
    public void testDecodeWholeRequestAtOnceCRLFDelimiters() {
        <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match16902-1.html#10',3,'match16902-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>testDecodeWholeRequestAtOnce(CONTENT_CRLF_DELIMITERS);
    }

    @Test
    public void testDecodeWholeRequestAtOnceLFDelimiters() {
        testDecodeWholeRequestAtOnce(CONTENT_LF_DELIMITERS);
    }

    @Test
    public void testDecodeWholeRequestAtOnceMixedDelimiters() {
        testDecodeWholeRequestAtOnce(CONTENT_MIXED_DELIMITERS);
    }

    private static void testDecodeWholeRequestAtOnce(byte[] content) {</B></FONT>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(content)));
<A NAME="3"></A>        HttpRequest req = channel.readInbound();
        assertNotNull(req);
        checkHeaders(req.headers());
        LastHttpContent c = <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match16902-1.html#3',3,'match16902-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertEquals(CONTENT_LENGTH, c.content().readableBytes());
        assertEquals(
                Unpooled.wrappedBuffer(content, content.length - CONTENT_LENGTH, CONTENT_LENGTH),
                c.content().readSlice(CONTENT_LENGTH));
        c.release();

        assertFalse(channel.finish());
        assertNull(channel.readInbound());
    }

<A NAME="25"></A>    private static void checkHeaders(HttpHeaders headers) {
        assertEquals(7, headers.names().size());
        checkHeader</B></FONT>(headers, &quot;Upgrade&quot;, &quot;WebSocket&quot;);
        <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match16902-1.html#25',3,'match16902-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkHeader(headers, &quot;Connection&quot;, &quot;Upgrade&quot;);
        checkHeader(headers, &quot;Host&quot;, &quot;localhost&quot;);
        checkHeader(headers, &quot;Origin&quot;, &quot;http://localhost:8080&quot;);
        checkHeader(headers, &quot;Sec-WebSocket-Key1&quot;, &quot;10  28 8V7 8 48     0&quot;);
        checkHeader(headers, &quot;Sec-WebSocket-Key2&quot;, &quot;8 Xt754O3Q3QW 0   _60&quot;);
        checkHeader(headers, &quot;Content-Length&quot;, String.valueOf(CONTENT_LENGTH));
<A NAME="21"></A>    }

    private sta</B></FONT>tic void checkHeader(HttpHeaders headers, String name, String value) {
        <FONT color="#947010"><A HREF="javascript:ZweiFrames('match16902-1.html#21',3,'match16902-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>List&lt;String&gt; header1 = headers.getAll(of(name));
        assertEquals(1, header1.size());
        assertEquals(value, header1.get(0));
    }

<A NAME="13"></A>    @Test
    public void testDecodeWholeRequestInMultipleStepsCRLFDelimiters() {</B></FONT>
        testDecodeWholeRequestInMultipleSteps(CONTENT_CRLF_DELIMITERS);
    <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match16902-1.html#13',3,'match16902-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testDecodeWholeRequestInMultipleStepsLFDelimiters() {
        testDecodeWholeRequestInMultipleSteps(CONTENT_LF_DELIMITERS);
    }

    @Test
    public void testDecodeWholeRequestInMultipleStepsMixedDelimiters() {
        testDecodeWholeRequestInMultipleSteps(CONTENT_MIXED_DELIMITERS);
    }

    private static void testDecodeWholeRequestInMultipleSteps(byte[] content) {</B></FONT>
        for (int i = 1; i &lt; content.length; i++) {
            testDecodeWholeRequestInMultipleSteps(content, i);
        }
    }

    private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fragmentSize) {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        int headerLength = content.length - CONTENT_LENGTH;

        // split up the header
        for (int a = 0; a &lt; headerLength;) {
            int amount = fragmentSize;
            if (a + amount &gt; headerLength) {
                amount = headerLength -  a;
            }

            // if header is done it should produce an HttpRequest
            channel.writeInbound(Unpooled.copiedBuffer(content, a, amount));
<A NAME="20"></A>            a += amount;
        }

        <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match16902-1.html#20',3,'match16902-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (int i = CONTENT_LENGTH; i &gt; 0; i --) {
            // Should produce HttpContent
            channel.writeInbound(Unpooled.copiedBuffer(content, content.length - i, 1));
        }

        HttpRequest req = channel.readInbound();
<A NAME="23"></A>        assertNotNull(req);
        checkHeaders(req.headers</B></FONT>());

        for (int i = CONTENT_LENGTH; i &gt; 1; i --) <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match16902-1.html#23',3,'match16902-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            HttpContent c = channel.readInbound();
            assertEquals(1, c.content().readableBytes());
            assertEquals(content[content.length - i], c.content().readByte());
<A NAME="9"></A>            c.release();
        }</B></FONT>

        <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match16902-1.html#9',3,'match16902-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>LastHttpContent c = channel.readInbound();
        assertEquals(1, c.content().readableBytes());
        assertEquals(content[content.length - 1], c.content().readByte());
        c.release();

        assertFalse(channel.finish());
        assertNull(channel.readInbound());
    }

    @Test
    public void testMultiLineHeader() {</B></FONT>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        String crlf = &quot;\r\n&quot;;
        String request =  &quot;GET /some/path HTTP/1.1&quot; + crlf +
                &quot;Host: localhost&quot; + crlf +
                &quot;MyTestHeader: part1&quot; + crlf +
                &quot;              newLinePart2&quot; + crlf +
                &quot;MyTestHeader2: part21&quot; + crlf +
<A NAME="15"></A>                &quot;\t            newLinePart22&quot;
                + crlf + crlf;
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));
        HttpRequest req = <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match16902-1.html#15',3,'match16902-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertEquals(&quot;part1 newLinePart2&quot;, req.headers().get(of(&quot;MyTestHeader&quot;)));
        assertEquals(&quot;part21 newLinePart22&quot;, req.headers().get(of(&quot;MyTestHeader2&quot;)));

        LastHttpContent c = channel.readInbound();
        c.release();

        assertFalse(channel.finish());
        assertNull(channel.readInbound</B></FONT>());
    }

    @Test
    public void testEmptyHeaderValue() {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        String crlf = &quot;\r\n&quot;;
        String request =  &quot;GET /some/path HTTP/1.1&quot; + crlf +
<A NAME="19"></A>                &quot;Host: localhost&quot; + crlf +
                &quot;EmptyHeader:&quot; + crlf + crlf;
        channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII));
        HttpRequest req = <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match16902-1.html#19',3,'match16902-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertEquals(&quot;&quot;, req.headers().get(of(&quot;EmptyHeader&quot;)));
    }

    @Test
    public void test100Continue() {
        HttpRequestDecoder decoder = new</B></FONT> HttpRequestDecoder();
        EmbeddedChannel channel = new EmbeddedChannel(decoder);
        String oversized =
                &quot;PUT /file HTTP/1.1\r\n&quot; +
                &quot;Expect: 100-continue\r\n&quot; +
<A NAME="4"></A>                &quot;Content-Length: 1048576000\r\n\r\n&quot;;

        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));
        assertThat(channel.readInbound(), is(<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match16902-1.html#4',3,'match16902-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>instanceOf(HttpRequest.class)));

        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection
        // so that the client can try again.
        decoder.reset();

        String query = &quot;GET /max-file-size HTTP/1.1\r\n\r\n&quot;;
        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));
        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));

        assertThat(channel.finish(), is(false));
    }

    @Test
    public void test100ContinueWithBadClient() {</B></FONT>
        HttpRequestDecoder decoder = new HttpRequestDecoder();
        EmbeddedChannel channel = new EmbeddedChannel(decoder);
        String oversized =
                &quot;PUT /file HTTP/1.1\r\n&quot; +
                &quot;Expect: 100-continue\r\n&quot; +
                &quot;Content-Length: 1048576000\r\n\r\n&quot; +
<A NAME="24"></A>                &quot;WAY_TOO_LARGE_DATA_BEGINS&quot;;

        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));
        assertThat(<FONT color="#79764d"><A HREF="javascript:ZweiFrames('match16902-1.html#24',3,'match16902-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound(), is(instanceOf(HttpRequest.class)));

        HttpContent prematureData = channel.readInbound();
        prematureData.release();

        assertThat(channel.readInbound(), is(nullValue</B></FONT>()));
<A NAME="5"></A>
        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection
        // so that the client can try again.
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match16902-1.html#5',3,'match16902-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>decoder.reset();

        String query = &quot;GET /max-file-size HTTP/1.1\r\n\r\n&quot;;
        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));
        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));

        assertThat(channel.finish(), is(false));
    }

    @Test
    public void testMessagesSplitBetweenMultipleBuffers() {</B></FONT>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        String crlf = &quot;\r\n&quot;;
        String str1 = &quot;GET /some/path HTTP/1.1&quot; + crlf +
                &quot;Host: localhost1&quot; + crlf + crlf +
                &quot;GET /some/other/path HTTP/1.0&quot; + crlf +
<A NAME="17"></A>                &quot;Hos&quot;;
        String str2 = &quot;t: localhost2&quot; + crlf +
                &quot;content-length: 0&quot; + crlf + crlf;
        channel.writeInbound(<FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match16902-1.html#17',3,'match16902-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Unpooled.copiedBuffer(str1, CharsetUtil.US_ASCII));
        HttpRequest req = channel.readInbound();
        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());
        assertEquals(&quot;/some/path&quot;, req.uri());
        assertEquals(1, req.headers().size());
        assertTrue(AsciiString.contentEqualsIgnoreCase(&quot;localhost1&quot;, req.headers</B></FONT>().get(HOST)));
        LastHttpContent cnt = channel.readInbound();
<A NAME="14"></A>        cnt.release();

        channel.writeInbound(Unpooled.copiedBuffer(str2, CharsetUtil.US_ASCII));
        <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match16902-1.html#14',3,'match16902-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>req = channel.readInbound();
        assertEquals(HttpVersion.HTTP_1_0, req.protocolVersion());
        assertEquals(&quot;/some/other/path&quot;, req.uri());
<A NAME="22"></A>        assertEquals(2, req.headers().size());
        assertTrue(AsciiString.contentEqualsIgnoreCase(&quot;localhost2&quot;, req.headers().get(HOST)));
        assertTrue(AsciiString.contentEqualsIgnoreCase(&quot;0&quot;, req.headers().get</B></FONT>(HttpHeaderNames.CONTENT_LENGTH)));
        cnt = <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match16902-1.html#22',3,'match16902-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        cnt.release();
        assertFalse(channel.finishAndReleaseAll());
    }

    @Test
    public void testTooLargeInitialLine() {
        EmbeddedChannel channel = new</B></FONT> EmbeddedChannel(new HttpRequestDecoder(10, 1024, 1024));
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
<A NAME="2"></A>                &quot;Host: localhost1\r\n\r\n&quot;;

        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match16902-1.html#2',3,'match16902-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertTrue(request.decoderResult().isFailure());
        assertTrue(request.decoderResult().cause() instanceof TooLongHttpLineException);
        assertFalse(channel.finish());
    }

    @Test
    public void testTooLargeInitialLineWithWSOnly() {
        testTooLargeInitialLineWithControlCharsOnly(&quot;                    &quot;);
    }

    @Test
    public void testTooLargeInitialLineWithCRLFOnly() {
        testTooLargeInitialLineWithControlCharsOnly(&quot;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&quot;);
    }

    private static void testTooLargeInitialLineWithControlCharsOnly(String controlChars) {</B></FONT>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(15, 1024, 1024));
<A NAME="7"></A>        String requestStr = controlChars + &quot;GET / HTTP/1.1\r\n&quot; +
                &quot;Host: localhost1\r\n\r\n&quot;;

        <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match16902-1.html#7',3,'match16902-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = channel.readInbound();
        assertTrue(request.decoderResult().isFailure());
        assertTrue(request.decoderResult().cause() instanceof TooLongHttpLineException);
        assertFalse(channel.finish());
    }

    @Test
    public void testInitialLineWithLeadingControlChars() {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder())</B></FONT>;
<A NAME="12"></A>        String crlf = &quot;\r\n&quot;;
        String request =  crlf + &quot;GET /some/path HTTP/1.1&quot; + crlf +
                &quot;Host: localhost&quot; + crlf + crlf;
        assertTrue(<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match16902-1.html#12',3,'match16902-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.writeInbound(Unpooled.copiedBuffer(request, CharsetUtil.US_ASCII)));
        HttpRequest req = channel.readInbound();
        assertEquals(HttpMethod.GET, req.method());
        assertEquals(&quot;/some/path&quot;, req.uri());
        assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());
        assertTrue(channel.finishAndReleaseAll());
    }

    @Test
    public void testTooLargeHeaders() {</B></FONT>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(1024, 10, 1024));
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
<A NAME="0"></A>                &quot;Host: localhost1\r\n\r\n&quot;;

        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match16902-1.html#0',3,'match16902-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertTrue(request.decoderResult().isFailure());
        assertTrue(request.decoderResult().cause() instanceof TooLongHttpHeaderException);
        assertFalse(channel.finish());
    }

    @Test
    public void testHeaderNameStartsWithControlChar1c() {
        testHeaderNameStartsWithControlChar(0x1c);
    }

    @Test
    public void testHeaderNameStartsWithControlChar1d() {
        testHeaderNameStartsWithControlChar(0x1d);
    }

    @Test
    public void testHeaderNameStartsWithControlChar1e() {
        testHeaderNameStartsWithControlChar(0x1e);
    }

    @Test
    public void testHeaderNameStartsWithControlChar1f() {
        testHeaderNameStartsWithControlChar(0x1f);
    }

    @Test</B></FONT>
    public void testHeaderNameStartsWithControlChar0c() {
        testHeaderNameStartsWithControlChar(0x0c);
<A NAME="1"></A>    }

    private void testHeaderNameStartsWithControlChar(int controlChar) {
        ByteBuf requestBuffer = <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match16902-1.html#1',3,'match16902-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Unpooled.buffer();
        requestBuffer.writeCharSequence(&quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Host: netty.io\r\n&quot;, CharsetUtil.US_ASCII);
        requestBuffer.writeByte(controlChar);
        requestBuffer.writeCharSequence(&quot;Transfer-Encoding: chunked\r\n\r\n&quot;, CharsetUtil.US_ASCII);
        testInvalidHeaders0(requestBuffer);
    }

    @Test
    public void testHeaderNameEndsWithControlChar1c() {
        testHeaderNameEndsWithControlChar(0x1c);
    }

    @Test
    public void testHeaderNameEndsWithControlChar1d() {
        testHeaderNameEndsWithControlChar(0x1d);
    }

    @Test
    public void testHeaderNameEndsWithControlChar1e() {
        testHeaderNameEndsWithControlChar(0x1e);
    }

    @Test
    public void testHeaderNameEndsWithControlChar1f() {
        testHeaderNameEndsWithControlChar(0x1f);
    }

    @Test</B></FONT>
    public void testHeaderNameEndsWithControlChar0c() {
        testHeaderNameEndsWithControlChar(0x0c);
<A NAME="18"></A>    }

    private void testHeaderNameEndsWithControlChar(int controlChar) {
        ByteBuf requestBuffer = <FONT color="#800517"><A HREF="javascript:ZweiFrames('match16902-1.html#18',3,'match16902-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Unpooled.buffer();
        requestBuffer.writeCharSequence(&quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Host: netty.io\r\n&quot;, CharsetUtil.US_ASCII);
        requestBuffer.writeCharSequence(&quot;Transfer-Encoding&quot;, CharsetUtil.US_ASCII);
        requestBuffer.writeByte(controlChar);
        requestBuffer.writeCharSequence(&quot;: chunked\r\n\r\n&quot;, CharsetUtil.US_ASCII);
        testInvalidHeaders0(requestBuffer);
    }

    @Test
    public void testWhitespace() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Transfer-Encoding : chunked\r\n&quot; +
                &quot;Host: netty.io\r\n\r\n&quot;;
        testInvalidHeaders0</B></FONT>(requestStr);
    }

    @Test
    public void testWhitespaceInTransferEncoding01() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Transfer-Encoding : chunked\r\n&quot; +
                &quot;Content-Length: 1\r\n&quot; +
                &quot;Host: netty.io\r\n\r\n&quot; +
                &quot;a&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testWhitespaceInTransferEncoding02() {
        String requestStr = &quot;POST / HTTP/1.1&quot; +
                &quot;Transfer-Encoding : chunked\r\n&quot; +
                &quot;Host: target.com&quot; +
                &quot;Content-Length: 65\r\n\r\n&quot; +
                &quot;0\r\n\r\n&quot; +
                &quot;GET /maliciousRequest HTTP/1.1\r\n&quot; +
                &quot;Host: evilServer.com\r\n&quot; +
                &quot;Foo: x&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testHeaderWithNoValueAndMissingColon() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Content-Length: 0\r\n&quot; +
                &quot;Host:\r\n&quot; +
                &quot;netty.io\r\n\r\n&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testMultipleContentLengthHeaders() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Content-Length: 1\r\n&quot; +
                &quot;Content-Length: 0\r\n\r\n&quot; +
                &quot;b&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testMultipleContentLengthHeaders2() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Content-Length: 1\r\n&quot; +
                &quot;Connection: close\r\n&quot; +
                &quot;Content-Length: 0\r\n\r\n&quot; +
                &quot;b&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testContentLengthHeaderWithCommaValue() {
        String requestStr = &quot;GET /some/path HTTP/1.1\r\n&quot; +
                &quot;Content-Length: 1,1\r\n\r\n&quot; +
                &quot;b&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testMultipleContentLengthHeadersWithFolding() {
        String requestStr = &quot;POST / HTTP/1.1\r\n&quot; +
                &quot;Host: example.com\r\n&quot; +
                &quot;Connection: close\r\n&quot; +
                &quot;Content-Length: 5\r\n&quot; +
                &quot;Content-Length:\r\n&quot; +
                &quot;\t6\r\n\r\n&quot; +
                &quot;123456&quot;;
        testInvalidHeaders0(requestStr);
    }
<A NAME="26"></A>
    @Test
    public void testContentLengthAndTransferEncodingHeadersWithVerticalTab() {
        <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match16902-1.html#26',3,'match16902-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, false);
        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0b, true);
    }

    @Test
    public void testContentLengthAndTransferEncodingHeadersWithCR() {
        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator((char) 0x0d, false);
        testContentLengthAndTransferEncodingHeadersWithInvalidSeparator</B></FONT>((char) 0x0d, true);
    }

    private static void testContentLengthAndTransferEncodingHeadersWithInvalidSeparator(
            char separator, boolean extraLine) {
        String requestStr = &quot;POST / HTTP/1.1\r\n&quot; +
                &quot;Host: example.com\r\n&quot; +
                &quot;Connection: close\r\n&quot; +
                &quot;Content-Length: 9\r\n&quot; +
                &quot;Transfer-Encoding:&quot; + separator + &quot;chunked\r\n\r\n&quot; +
                (extraLine ? &quot;0\r\n\r\n&quot; : &quot;&quot;) +
                &quot;something\r\n\r\n&quot;;
        testInvalidHeaders0(requestStr);
    }

    @Test
    public void testContentLengthHeaderAndChunked() {
        String requestStr = &quot;POST / HTTP/1.1\r\n&quot; +
                &quot;Host: example.com\r\n&quot; +
                &quot;Connection: close\r\n&quot; +
                &quot;Content-Length: 5\r\n&quot; +
<A NAME="11"></A>                &quot;Transfer-Encoding: chunked\r\n\r\n&quot; +
                &quot;0\r\n\r\n&quot;;
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        assertTrue(channel.writeInbound(<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match16902-1.html#11',3,'match16902-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = channel.readInbound();
        assertFalse(request.decoderResult().isFailure());
        assertTrue(request.headers().contains(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;, false));
        assertFalse(request.headers().contains(&quot;Content-Length&quot;));
        LastHttpContent c = channel.readInbound();
        c.release();
        assertFalse(channel.finish</B></FONT>());
    }

    @Test
    public void testHttpMessageDecoderResult() {
        String requestStr = &quot;PUT /some/path HTTP/1.1\r\n&quot; +
                &quot;Content-Length: 11\r\n&quot; +
                &quot;Connection: close\r\n\r\n&quot; +
<A NAME="8"></A>                &quot;Lorem ipsum&quot;;
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match16902-1.html#8',3,'match16902-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();
        assertTrue(request.decoderResult().isSuccess());
        assertThat(request.decoderResult(), instanceOf(HttpMessageDecoderResult.class));
        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) request.decoderResult();
        assertThat(decoderResult.initialLineLength(), is(23));
        assertThat(decoderResult.headerSize(), is(35));
        assertThat(decoderResult.totalSize(), is</B></FONT>(58));
        HttpContent c = channel.readInbound();
        c.release();
        assertFalse(channel.finish());
    }

    private static void testInvalidHeaders0(String requestStr) {
        testInvalidHeaders0(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII));
    }
<A NAME="16"></A>
    private static void testInvalidHeaders0(ByteBuf requestBuffer) {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match16902-1.html#16',3,'match16902-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(channel.writeInbound(requestBuffer));
        HttpRequest request = channel.readInbound();
        assertThat(request.decoderResult().cause(), instanceOf(IllegalArgumentException.class));
        assertTrue(request.decoderResult().isFailure());
        assertFalse(channel.finish());
    }</B></FONT>
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultHttp2ConnectionEncoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package io.netty.handler.codec.http2;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultChannelConfig;
import io.netty.channel.DefaultChannelPromise;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http2.Http2RemoteFlowController.FlowControlled;
import io.netty.util.concurrent.ImmediateEventExecutor;
import junit.framework.AssertionFailedError;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.util.ArrayList;
import java.util.List;

import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
import static io.netty.buffer.Unpooled.wrappedBuffer;
import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;
import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;
import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_LOCAL;
import static io.netty.handler.codec.http2.Http2TestUtil.newVoidPromise;
import static io.netty.util.CharsetUtil.UTF_8;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.CoreMatchers.instanceOf;
<A NAME="6"></A>import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#6',2,'match16902-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyBoolean;
import static org.mockito.Mockito.anyInt;
import static org.mockito.Mockito.anyLong;
import static org.mockito.Mockito.anyShort;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link DefaultHttp2ConnectionEncoder}
 */
public class DefaultHttp2ConnectionEncoderTest {
    private static final int STREAM_ID = 2</B></FONT>;
    private static final int PUSH_STREAM_ID = 4;

    @Mock
    private Http2RemoteFlowController remoteFlow;

    @Mock
    private ChannelHandlerContext ctx;

    @Mock
    private Channel channel;

    @Mock
    private Channel.Unsafe unsafe;

    @Mock
    private ChannelPipeline pipeline;

    @Mock
    private Http2FrameWriter writer;

    @Mock
    private Http2FrameWriter.Configuration writerConfig;

    @Mock
    private Http2FrameSizePolicy frameSizePolicy;

    @Mock
    private Http2LifecycleManager lifecycleManager;

    private DefaultHttp2ConnectionEncoder encoder;
    private Http2Connection connection;
    private ArgumentCaptor&lt;Http2RemoteFlowController.FlowControlled&gt; payloadCaptor;
    private List&lt;String&gt; writtenData;
    private List&lt;Integer&gt; writtenPadding;
    private boolean streamClosed;

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.initMocks(this);

        ChannelMetadata metadata = new ChannelMetadata(false, 16);
        when(channel.isActive()).thenReturn(true);
        when(channel.pipeline()).thenReturn(pipeline);
        when(channel.metadata()).thenReturn(metadata);
        when(channel.unsafe()).thenReturn(unsafe);
        ChannelConfig config = new DefaultChannelConfig(channel);
        when(channel.config()).thenReturn(config);
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) {
                return newPromise().setFailure((Throwable) in.getArgument(0));
            }
        }).when(channel).newFailedFuture(any(Throwable.class));

        when(writer.configuration()).thenReturn(writerConfig);
        when(writerConfig.frameSizePolicy()).thenReturn(frameSizePolicy);
        when(frameSizePolicy.maxFrameSize()).thenReturn(64);
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                return ((ChannelPromise) in.getArguments()[2]).setSuccess();
            }
        }).when(writer).writeSettings(eq(ctx), any(Http2Settings.class), any(ChannelPromise.class));
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                ((ByteBuf) in.getArguments()[3]).release();
                return ((ChannelPromise) in.getArguments()[4]).setSuccess();
            }
        }).when(writer).writeGoAway(eq(ctx), anyInt(), anyInt(), any(ByteBuf.class), any(ChannelPromise.class));
        writtenData = new ArrayList&lt;String&gt;();
        writtenPadding = new ArrayList&lt;Integer&gt;();
        when(writer.writeData(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean(),
                any(ChannelPromise.class))).then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                        // Make sure we only receive stream closure on the last frame and that void promises
                        // are used for all writes except the last one.
                        ChannelPromise promise = (ChannelPromise) in.getArguments()[5];
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = (Boolean) in.getArguments()[4];
                        }
                        writtenPadding.add((Integer) in.getArguments()[3]);
                        ByteBuf data = (ByteBuf) in.getArguments()[2];
                        writtenData.add(data.toString(UTF_8));
                        // Release the buffer just as DefaultHttp2FrameWriter does
                        data.release();
                        // Let the promise succeed to trigger listeners.
                        return promise.setSuccess();
                    }
                });
        when(writer.writeHeaders(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(),
                anyInt(), anyBoolean(), any(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) {
                        ChannelPromise promise = invocationOnMock.getArgument(8);
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = invocationOnMock.getArgument(5);
                        }
                        return promise.setSuccess();
                    }
                });
        when(writer.writeHeaders(eq(ctx), anyInt(), any(Http2Headers.class),
                anyInt(), anyBoolean(), any(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) {
                        ChannelPromise promise = invocationOnMock.getArgument(5);
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = invocationOnMock.getArgument(4);
                        }
<A NAME="14"></A>                        return promise.setSuccess();
                    }
                });
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#14',2,'match16902-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>payloadCaptor = ArgumentCaptor.forClass(Http2RemoteFlowController.FlowControlled.class);
        doNothing().when(remoteFlow).addFlowControlled(any(Http2Stream.class), payloadCaptor.capture());
        when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);
        when(ctx.channel()).thenReturn(channel);
        doAnswer</B></FONT>(new Answer&lt;ChannelPromise&gt;() {
            @Override
            public ChannelPromise answer(InvocationOnMock in) throws Throwable {
                return newPromise();
            }
        }).when(ctx).newPromise();
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                return newSucceededFuture();
            }
        }).when(ctx).newSucceededFuture();
        when(ctx.flush()).thenThrow(new AssertionFailedError(&quot;forbidden&quot;));
        when(channel.alloc()).thenReturn(PooledByteBufAllocator.DEFAULT);

        // Use a server-side connection so we can test server push.
        connection = new DefaultHttp2Connection(true);
<A NAME="10"></A>        connection.remote().flowController(remoteFlow);

        encoder = new DefaultHttp2ConnectionEncoder(connection, writer);
        <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#10',2,'match16902-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>encoder.lifecycleManager(lifecycleManager);
    }

    @Test
    public void dataWithEndOfStreamWriteShouldSignalThatFrameWasConsumedOnError() throws Exception {
        dataWriteShouldSignalThatFrameWasConsumedOnError0(true);
    }

    @Test
    public void dataWriteShouldSignalThatFrameWasConsumedOnError() throws Exception {
        dataWriteShouldSignalThatFrameWasConsumedOnError0(false);
    }

    private void dataWriteShouldSignalThatFrameWasConsumedOnError0(boolean endOfStream) throws Exception {</B></FONT>
        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData();
        ChannelPromise p = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, endOfStream, p);

        FlowControlled controlled = payloadCaptor.getValue();
        assertEquals(8, controlled.size());
        payloadCaptor.getValue().write(ctx, 4);
        assertEquals(4, controlled.size());

<A NAME="25"></A>        Throwable error = new IllegalStateException();
        payloadCaptor.getValue().error(ctx, error);
        payloadCaptor.getValue().write(ctx, 8);
        assertEquals(0, <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#25',2,'match16902-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>controlled.size());
        assertEquals(&quot;abcd&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());
        assertSame(error, p.cause());
    }

<A NAME="17"></A>    @Test</B></FONT>
    public void dataWriteShouldSucceed() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#17',2,'match16902-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dummyData();
        ChannelPromise p = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, p);
        assertEquals(8, payloadCaptor.getValue().size());
        payloadCaptor.getValue().write(ctx, 8);
        assertEquals(0, payloadCaptor.getValue().size());
        assertEquals(&quot;abcdefgh&quot;, writtenData.get</B></FONT>(0));
        assertEquals(0, data.refCnt());
        assertTrue(p.isSuccess());
    }

    @Test
    public void dataFramesShouldMerge() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData().retain();

        ChannelPromise promise1 = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise1);
        ChannelPromise promise2 = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise2);

        // Now merge the two payloads.
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        FlowControlled mergedPayload = capturedWrites.get(0);
        mergedPayload.merge(ctx, capturedWrites.get(1));
        assertEquals(16, mergedPayload.size());
        assertFalse(promise1.isDone());
        assertFalse(promise2.isDone());

        // Write the merged payloads and verify it was written correctly.
        mergedPayload.write(ctx, 16);
        assertEquals(0, mergedPayload.size());
        assertEquals(&quot;abcdefghabcdefgh&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());
        assertTrue(promise1.isSuccess());
        assertTrue(promise2.isSuccess());
    }

    @Test
    public void dataFramesShouldMergeUseVoidPromise() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData().retain();

        ChannelPromise promise1 = newVoidPromise(channel);
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise1);
        ChannelPromise promise2 = newVoidPromise(channel);
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise2);

        // Now merge the two payloads.
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        FlowControlled mergedPayload = capturedWrites.get(0);
        mergedPayload.merge(ctx, capturedWrites.get(1));
        assertEquals(16, mergedPayload.size());
        assertFalse(promise1.isSuccess());
        assertFalse(promise2.isSuccess());

        // Write the merged payloads and verify it was written correctly.
        mergedPayload.write(ctx, 16);
        assertEquals(0, mergedPayload.size());
        assertEquals(&quot;abcdefghabcdefgh&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());

        // The promises won't be set since there are no listeners.
        assertFalse(promise1.isSuccess());
        assertFalse(promise2.isSuccess());
    }
<A NAME="11"></A>
    @Test
    public void dataFramesDontMergeWithHeaders() throws Exception {
        <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#11',2,'match16902-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createStream(STREAM_ID, false);
        final ByteBuf data = dummyData().retain();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        when(remoteFlow.hasFlowControlled(any(Http2Stream.class))).thenReturn(true);
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newPromise());
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        assertFalse(capturedWrites.get</B></FONT>(0).merge(ctx, capturedWrites.get(1)));
    }
<A NAME="22"></A>
    @Test
    public void emptyFrameShouldSplitPadding() throws Exception {
        ByteBuf data = <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#22',2,'match16902-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Unpooled.buffer(0);
        assertSplitPaddingOnEmptyBuffer(data);
        assertEquals(0, data.refCnt());
    }

    @Test
    public void writeHeadersUsingVoidPromise() throws Exception {
        final Throwable cause = new</B></FONT> RuntimeException(&quot;fake exception&quot;);
        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), any(Http2Headers.class),
                                 anyInt(), anyBoolean(), any(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) throws Throwable {
                        ChannelPromise promise = invocationOnMock.getArgument(5);
                        assertFalse(promise.isVoid());
<A NAME="3"></A>                        return promise.setFailure(cause);
                    }
                });
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#3',2,'match16902-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createStream(STREAM_ID, false);
        // END_STREAM flag, so that a listener is added to the future.
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newVoidPromise(channel));

        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), any(Http2Headers.class),
                                    anyInt(), anyBoolean(), any(ChannelPromise.class));
        // When using a void promise, the error should be propagated via the channel pipeline.
        verify(pipeline).fireExceptionCaught(cause);
    }

    private void assertSplitPaddingOnEmptyBuffer(ByteBuf data) throws Exception {
        createStream(STREAM_ID, false);
        when(frameSizePolicy.maxFrameSize</B></FONT>()).thenReturn(5);
        ChannelPromise p = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 10, true, p);
        assertEquals(10, payloadCaptor.getValue().size());
        payloadCaptor.getValue().write(ctx, 10);
        // writer was called 2 times
        assertEquals(1, writtenData.size());
        assertEquals(&quot;&quot;, writtenData.get(0));
        assertEquals(10, (int) writtenPadding.get(0));
        assertEquals(0, data.refCnt());
        assertTrue(p.isSuccess());
    }

    @Test
<A NAME="9"></A>    public void headersWriteForUnknownStreamShouldCreateStream() throws Exception {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#9',2,'match16902-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),
                eq(false), eq(promise));
        assertTrue(promise.isSuccess());
    }

<A NAME="4"></A>    @Test
    public void headersWriteShouldOpenStreamForPush() throws Exception {</B></FONT>
        writeAllFlowControlledFrames();
        Http2Stream parent = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#4',2,'match16902-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createStream(STREAM_ID, false);
        reservePushStream(PUSH_STREAM_ID, parent);

        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        assertEquals(HALF_CLOSED_REMOTE, stream(PUSH_STREAM_ID).state());
        verify(writer).writeHeaders(eq(ctx), eq(PUSH_STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void trailersDoNotEndStreamThrows() {</B></FONT>
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        ChannelPromise promise2 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void trailersDoNotEndStreamWithDataThrows() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        Http2Stream stream = connection.stream(streamId);
        when(remoteFlow.hasFlowControlled(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);
<A NAME="2"></A>        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#2',2,'match16902-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void tooManyHeadersNoEOSThrows() {
        tooManyHeadersThrows(false);
    }

    @Test
    public void tooManyHeadersEOSThrows() {
        tooManyHeadersThrows(true);
    }

    private void tooManyHeadersThrows(boolean eos) {</B></FONT>
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        ChannelPromise promise2 = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());
<A NAME="0"></A>
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#0',2,'match16902-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(true), eq(promise2));
    }

    @Test
    public void infoHeadersAndTrailersAllowed() throws Exception {
        infoHeadersAndTrailers(true, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersAllowed() throws Exception {
        infoHeadersAndTrailers(true, 10);
    }

    @Test
    public void infoHeadersAndTrailersNoEOSThrows() throws Exception {
        infoHeadersAndTrailers(false, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersNoEOSThrows() throws Exception {
        infoHeadersAndTrailers(false, 10);
    }

    private void infoHeade</B></FONT>rsAndTrailers(boolean eos, int infoHeaderCount) {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        Http2Headers infoHeaders = informationalHeaders();
        for (int i = 0; i &lt; infoHeaderCount; ++i) {
            encoder.writeHeaders(ctx, streamId, infoHeaders, 0, false, newPromise());
        }
        ChannelPromise promise2 = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertEquals(eos, future.isSuccess());

        verify(writer, times(infoHeaderCount)).writeHeaders(eq(ctx), eq(streamId), eq(infoHeaders),
                eq(0), eq(false), any(ChannelPromise.class));
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise2));
        if (eos) {
            verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                    eq(0), eq(true), eq(promise3));
        }
    }

    private static Http2Headers informationalHeaders() {
<A NAME="13"></A>        Http2Headers headers = new DefaultHttp2Headers();
        headers.status(HttpResponseStatus.CONTINUE.codeAsText());
        return headers;
    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#13',2,'match16902-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Test
    public void tooManyHeadersWithDataNoEOSThrows() {
        tooManyHeadersWithDataThrows(false);
    }

    @Test
    public void tooManyHeadersWithDataEOSThrows() {
        tooManyHeadersWithDataThrows(true);
    }

    private void tooManyHeadersWithDataThrows(boolean eos) {</B></FONT>
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        Http2Stream stream = connection.stream(streamId);
        when(remoteFlow.hasFlowControlled(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());
<A NAME="1"></A>
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
        verify(writer, times(1)).writeHeaders(eq(ctx), <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#1',2,'match16902-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(true), eq(promise2));
    }

    @Test
    public void infoHeadersAndTrailersWithDataAllowed() {
        infoHeadersAndTrailersWithData(true, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersWithDataAllowed() {
        infoHeadersAndTrailersWithData(true, 10);
    }

    @Test
    public void infoHeadersAndTrailersWithDataNoEOSThrows() {
        infoHeadersAndTrailersWithData(false, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersWithDataNoEOSThrows() {
        infoHeadersAndTrailersWithData(false, 10);
    }

    private void infoHeadersAndTra</B></FONT>ilersWithData(boolean eos, int infoHeaderCount) {
<A NAME="20"></A>        writeAllFlowControlledFrames();
        final int streamId = 6;
        Http2Headers infoHeaders = informationalHeaders();
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#20',2,'match16902-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i = 0; i &lt; infoHeaderCount; ++i) {
            encoder.writeHeaders(ctx, streamId, infoHeaders, 0, false, newPromise());
        }

        Http2Stream stream = connection.stream(streamId);
        when(remoteFlow.hasFlowControlled</B></FONT>(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertEquals(eos, future.isSuccess());

        verify(writer, times(infoHeaderCount)).writeHeaders(eq(ctx), eq(streamId), eq(infoHeaders),
                eq(0), eq(false), any(ChannelPromise.class));
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise2));
        if (eos) {
            verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                    eq(0), eq(true), eq(promise3));
        }
    }

    @Test
<A NAME="21"></A>    public void pushPromiseWriteAfterGoAwayReceivedShouldFail() throws Exception {
        createStream(STREAM_ID, false);
        goAwayReceived(0);
        <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#21',2,'match16902-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ChannelFuture future = encoder.writePushPromise(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0,
                newPromise());
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());
    }
<A NAME="5"></A>
    @Test
    public void pushPromiseWriteShouldReserveStream() throws Exception {</B></FONT>
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#5',2,'match16902-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createStream(STREAM_ID, false);
        ChannelPromise promise = newPromise();
        encoder.writePushPromise(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, promise);
        assertEquals(RESERVED_LOCAL, stream(PUSH_STREAM_ID).state());
        verify(writer).writePushPromise(eq(ctx), eq(STREAM_ID), eq(PUSH_STREAM_ID),
                eq(EmptyHttp2Headers.INSTANCE), eq(0), eq(promise));
    }
<A NAME="16"></A>
    @Test
    public void priorityWriteAfterGoAwayShouldSucceed() throws Exception {</B></FONT>
        <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#16',2,'match16902-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createStream(STREAM_ID, false);
        goAwayReceived(Integer.MAX_VALUE);
        ChannelPromise promise = newPromise();
        encoder.writePriority(ctx, STREAM_ID, 0, (short) 255, true, promise);
        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), eq(true), eq(promise));
    }</B></FONT>

    @Test
    public void priorityWriteShouldSetPriorityForStream() throws Exception {
        ChannelPromise promise = newPromise();
        short weight = 255;
        encoder.writePriority(ctx, STREAM_ID, 0, weight, true, promise);

        // Verify that this did NOT create a stream object.
<A NAME="26"></A>        Http2Stream stream = stream(STREAM_ID);
        assertNull(stream);

        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#26',2,'match16902-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>eq(true), eq(promise));
    }

    @Test
    public void priorityWriteOnPreviouslyExistingStreamShouldSucceed() throws Exception {
        createStream</B></FONT>(STREAM_ID, false).close();
<A NAME="18"></A>        ChannelPromise promise = newPromise();
        short weight = 255;
        encoder.writePriority(ctx, STREAM_ID, 0, weight, true, promise);
        verify(writer).writePriority(<FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#18',2,'match16902-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>eq(ctx), eq(STREAM_ID), eq(0), eq(weight), eq(true), eq(promise));
    }

    @Test
    public void priorityWriteOnPreviouslyExistingParentStreamShouldSucceed() throws Exception {
        final int parentStreamId = STREAM_ID + 2;
        createStream</B></FONT>(STREAM_ID, false);
        createStream(parentStreamId, false).close();

        ChannelPromise promise = newPromise();
        short weight = 255;
        encoder.writePriority(ctx, STREAM_ID, parentStreamId, weight, true, promise);
        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(parentStreamId), eq(weight), eq(true), eq(promise));
    }

    @Test
    public void rstStreamWriteForUnknownStreamShouldIgnore() throws Exception {
        ChannelPromise promise = newPromise();
        encoder.writeRstStream(ctx, 5, PROTOCOL_ERROR.code(), promise);
        verify(writer, never()).writeRstStream(eq(ctx), anyInt(), anyLong(), eq(promise));
    }

    @Test
<A NAME="7"></A>    public void rstStreamShouldCloseStream() throws Exception {
        // Create the stream and send headers.
        writeAllFlowControlledFrames();
        <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#7',2,'match16902-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newPromise());

        // Now verify that a stream reset is performed.
        stream(STREAM_ID);
        ChannelPromise promise = newPromise();
        encoder.writeRstStream(ctx, STREAM_ID, PROTOCOL_ERROR.code(), promise);
        verify(lifecycleManager).resetStream(eq(ctx), eq(STREAM_ID), anyLong(), eq(promise));
    }

    @Test
    public void pingWriteAfterGoAwayShouldSucceed() throws Exception {
        ChannelPromise promise = newPromise()</B></FONT>;
        goAwayReceived(0);
        encoder.writePing(ctx, false, 0L, promise);
        verify(writer).writePing(eq(ctx), eq(false), eq(0L), eq(promise));
<A NAME="23"></A>    }

    @Test
    public void pingWriteShouldSucceed() throws Exception <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#23',2,'match16902-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        ChannelPromise promise = newPromise();
        encoder.writePing(ctx, false, 0L, promise);
        verify(writer).writePing(eq(ctx), eq(false), eq(0L), eq(promise));
    }</B></FONT>

    @Test
    public void settingsWriteAfterGoAwayShouldSucceed() throws Exception {
<A NAME="19"></A>        goAwayReceived(0);
        ChannelPromise promise = newPromise();
        encoder.writeSettings(ctx, new Http2Settings(), promise);
        <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#19',2,'match16902-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>verify(writer).writeSettings(eq(ctx), any(Http2Settings.class), eq(promise));
    }

<A NAME="24"></A>    @Test
    public void settingsWriteShouldNotUpdateSettings() throws Exception {
        Http2Settings settings = new</B></FONT> Http2Settings();
        <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#24',2,'match16902-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>settings.initialWindowSize(100);
        settings.maxConcurrentStreams(1000);
        settings.headerTableSize(2000);

        ChannelPromise promise = newPromise();
        encoder.writeSettings(ctx, settings, promise);
        verify(writer).writeSettings(eq(ctx), eq</B></FONT>(settings), eq(promise));
    }

    @Test
    public void dataWriteShouldCreateHalfClosedStream() throws Exception {
        writeAllFlowControlledFrames();

        Http2Stream stream = createStream(STREAM_ID, false);
        ByteBuf data = dummyData();
        ChannelPromise promise = newPromise();
        encoder.writeData(ctx, STREAM_ID, data.retain(), 0, true, promise);
        assertTrue(promise.isSuccess());
        verify(remoteFlow).addFlowControlled(eq(stream), any(FlowControlled.class));
        verify(lifecycleManager).closeStreamLocal(stream, promise);
        assertEquals(data.toString(UTF_8), writtenData.get(0));
        data.release();
    }
<A NAME="12"></A>
    @Test
    public void headersWriteShouldHalfCloseStream() throws Exception {
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#12',2,'match16902-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>writeAllFlowControlledFrames();
        createStream(STREAM_ID, false);
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isSuccess());
        verify(lifecycleManager).closeStreamLocal(eq(stream(STREAM_ID)), eq(promise));
    }

    @Test
    public void headersWriteShouldHalfClosePushStream() throws Exception {</B></FONT>
        writeAllFlowControlledFrames();
        Http2Stream parent = createStream(STREAM_ID, false);
        Http2Stream stream = reservePushStream(PUSH_STREAM_ID, parent);
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);
        assertEquals(HALF_CLOSED_REMOTE, stream.state());
        assertTrue(promise.isSuccess());
        verify(lifecycleManager).closeStreamLocal(eq(stream), eq(promise));
    }

    @Test
    public void headersWriteShouldHalfCloseAfterOnErrorForPreCreatedStream() throws Exception {
        final ChannelPromise promise = newPromise();
        final Throwable ex = new RuntimeException();
        // Fake an encoding error, like HPACK's HeaderListSizeException
        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0), eq(true), eq(promise)))
            .thenAnswer(new Answer&lt;ChannelFuture&gt;() {
                @Override
                public ChannelFuture answer(InvocationOnMock invocation) {
                    promise.setFailure(ex);
                    return promise;
                }
            });
<A NAME="8"></A>
        writeAllFlowControlledFrames();
        Http2Stream stream = createStream(STREAM_ID, false);
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#8',2,'match16902-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertFalse(stream.isHeadersSent());
        InOrder inOrder = inOrder(lifecycleManager);
        inOrder.verify(lifecycleManager).onError(eq(ctx), eq(true), eq(ex));
        inOrder.verify(lifecycleManager).closeStreamLocal(eq(stream</B></FONT>(STREAM_ID)), eq(promise));
    }

    @Test
    public void headersWriteShouldHalfCloseAfterOnErrorForImplicitlyCreatedStream() throws Exception {
        final ChannelPromise promise = newPromise();
        final Throwable ex = new RuntimeException();
        // Fake an encoding error, like HPACK's HeaderListSizeException
        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0), eq(true), eq(promise)))
            .thenAnswer(new Answer&lt;ChannelFuture&gt;() {
                @Override
                public ChannelFuture answer(InvocationOnMock invocation) {
                    promise.setFailure(ex);
                    return promise;
<A NAME="15"></A>                }
            });

        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16902-0.html#15',2,'match16902-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>writeAllFlowControlledFrames();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertFalse(stream(STREAM_ID).isHeadersSent());
        InOrder inOrder = inOrder(lifecycleManager);
        inOrder.verify(lifecycleManager).onError(eq(ctx), eq(true), eq</B></FONT>(ex));
        inOrder.verify(lifecycleManager).closeStreamLocal(eq(stream(STREAM_ID)), eq(promise));
    }

    @Test
    public void encoderDelegatesGoAwayToLifeCycleManager() {
        ChannelPromise promise = newPromise();
        encoder.writeGoAway(ctx, STREAM_ID, Http2Error.INTERNAL_ERROR.code(), null, promise);
        verify(lifecycleManager).goAway(eq(ctx), eq(STREAM_ID), eq(Http2Error.INTERNAL_ERROR.code()),
                eq((ByteBuf) null), eq(promise));
        verifyNoMoreInteractions(writer);
    }

    @Test
    public void dataWriteToClosedStreamShouldFail() throws Exception {
        createStream(STREAM_ID, false).close();
        ByteBuf data = mock(ByteBuf.class);
        ChannelPromise promise = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, promise);
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertThat(promise.cause(), instanceOf(IllegalArgumentException.class));
        verify(data).release();
    }

    @Test
    public void dataWriteToHalfClosedLocalStreamShouldFail() throws Exception {
        createStream(STREAM_ID, true);
        ByteBuf data = mock(ByteBuf.class);
        ChannelPromise promise = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, promise);
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertThat(promise.cause(), instanceOf(IllegalStateException.class));
        verify(data).release();
    }

    @Test
    public void canWriteDataFrameAfterGoAwaySent() throws Exception {
        Http2Stream stream = createStream(STREAM_ID, false);
        connection.goAwaySent(0, 0, EMPTY_BUFFER);
        ByteBuf data = mock(ByteBuf.class);
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        verify(remoteFlow).addFlowControlled(eq(stream), any(FlowControlled.class));
    }

    @Test
    public void canWriteHeaderFrameAfterGoAwaySent() throws Exception {
        writeAllFlowControlledFrames();
        createStream(STREAM_ID, false);
        goAwaySent(0);
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void canWriteDataFrameAfterGoAwayReceived() throws Exception {
        Http2Stream stream = createStream(STREAM_ID, false);
        goAwayReceived(STREAM_ID);
        ByteBuf data = mock(ByteBuf.class);
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        verify(remoteFlow).addFlowControlled(eq(stream), any(FlowControlled.class));
    }

    @Test
    public void canWriteHeaderFrameAfterGoAwayReceived() throws Http2Exception {
        writeAllFlowControlledFrames();
        goAwayReceived(STREAM_ID);
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void headersWithNoPriority() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void headersWithPriority() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 10, DEFAULT_PRIORITY_WEIGHT,
                true, 1, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(10),
                eq(DEFAULT_PRIORITY_WEIGHT), eq(true), eq(1), eq(false), eq(promise));
    }

    private void writeAllFlowControlledFrames() {
        doAnswer(new Answer&lt;Void&gt;() {
            @Override
            public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
                FlowControlled flowControlled = (FlowControlled) invocationOnMock.getArguments()[1];
                flowControlled.write(ctx, Integer.MAX_VALUE);
                flowControlled.writeComplete();
                return null;
            }
        }).when(remoteFlow).addFlowControlled(any(Http2Stream.class), payloadCaptor.capture());
    }

    private Http2Stream createStream(int streamId, boolean halfClosed) throws Http2Exception {
        return connection.local().createStream(streamId, halfClosed);
    }

    private Http2Stream reservePushStream(int pushStreamId, Http2Stream parent) throws Http2Exception {
        return connection.local().reservePushStream(pushStreamId, parent);
    }

    private Http2Stream stream(int streamId) {
        return connection.stream(streamId);
    }

    private void goAwayReceived(int lastStreamId) throws Http2Exception {
        connection.goAwayReceived(lastStreamId, 0, EMPTY_BUFFER);
    }

    private void goAwaySent(int lastStreamId) throws Http2Exception {
        connection.goAwaySent(lastStreamId, 0, EMPTY_BUFFER);
    }

    private ChannelPromise newPromise() {
        return new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
    }

    private ChannelFuture newSucceededFuture() {
        return newPromise().setSuccess();
    }

    private static ByteBuf dummyData() {
        // The buffer is purposely 8 bytes so it will even work for a ping frame.
        return wrappedBuffer(&quot;abcdefgh&quot;.getBytes(UTF_8));
    }
}
</PRE>
</div>
  </div>
</body>
</html>
