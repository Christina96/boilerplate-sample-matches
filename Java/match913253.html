<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for BurstCostExecutorsBenchmark.java &amp; ReplayingDecoderTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for BurstCostExecutorsBenchmark.java &amp; ReplayingDecoderTest.java
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>BurstCostExecutorsBenchmark.java (4.0963855%)<th>ReplayingDecoderTest.java (3.5123968%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-32)<td><a href="#" name="0">(16-35)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BurstCostExecutorsBenchmark.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.microbench.concurrent;
2 import io.netty.channel.epoll.Epoll;
3 import io.netty.channel.epoll.EpollEventLoopGroup;
4 import io.netty.channel.kqueue.KQueue;
5 import io.netty.channel.kqueue.KQueueEventLoopGroup;
6 import io.netty.channel.nio.NioEventLoopGroup;
7 import io.netty.microbench.util.AbstractMicrobenchmark;
8 import io.netty.util.concurrent.DefaultEventExecutor;
9 import io.netty.util.internal.PlatformDependent;
10 import org.openjdk.jmh.annotations.Benchmark;
11 import org.openjdk.jmh.annotations.BenchmarkMode;
12 import org.openjdk.jmh.annotations.Mode;
13 import org.openjdk.jmh.annotations.OutputTimeUnit;
14 import org.openjdk.jmh.annotations.Param;
15 import org.openjdk.jmh.annotations.Scope;
16 import org.openjdk.jmh.annotations.Setup;
17 import</b></font> org.openjdk.jmh.annotations.State;
18 import org.openjdk.jmh.annotations.TearDown;
19 import org.openjdk.jmh.annotations.Threads;
20 import org.openjdk.jmh.infra.Blackhole;
21 import java.util.Collection;
22 import java.util.List;
23 import java.util.Queue;
24 import java.util.concurrent.Callable;
25 import java.util.concurrent.ExecutionException;
26 import java.util.concurrent.ExecutorService;
27 import java.util.concurrent.Executors;
28 import java.util.concurrent.Future;
29 import java.util.concurrent.RejectedExecutionException;
30 import java.util.concurrent.TimeUnit;
31 import java.util.concurrent.TimeoutException;
32 import java.util.concurrent.atomic.AtomicBoolean;
33 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
34 @State(Scope.Benchmark)
35 @OutputTimeUnit(TimeUnit.NANOSECONDS)
36 public class BurstCostExecutorsBenchmark extends AbstractMicrobenchmark {
37     private static final class SpinExecutorService implements ExecutorService {
38         private static final Runnable POISON_PILL = new Runnable() {
39             @Override
40             public void run() {
41             }
42         };
43         private final Queue&lt;Runnable&gt; tasks;
44         private final AtomicBoolean poisoned = new AtomicBoolean();
45         private final Thread executorThread;
46         SpinExecutorService(int maxTasks) {
47             tasks = PlatformDependent.newFixedMpscQueue(maxTasks);
48             executorThread = new Thread(new Runnable() {
49                 @Override
50                 public void run() {
51                     final Queue&lt;Runnable&gt; tasks = SpinExecutorService.this.tasks;
52                     Runnable task;
53                     while ((task = tasks.poll()) != POISON_PILL) {
54                         if (task != null) {
55                             task.run();
56                         }
57                     }
58                 }
59             });
60             executorThread.start();
61         }
62         @Override
63         public void shutdown() {
64             if (poisoned.compareAndSet(false, true)) {
65                 while (!tasks.offer(POISON_PILL)) {
66                 }
67                 try {
68                     executorThread.join();
69                 } catch (InterruptedException e) {
70                     //We're quite trusty :)
71                 }
72             }
73         }
74         @Override
75         public List&lt;Runnable&gt; shutdownNow() {
76             throw new UnsupportedOperationException();
77         }
78         @Override
79         public boolean isShutdown() {
80             throw new UnsupportedOperationException();
81         }
82         @Override
83         public boolean isTerminated() {
84             throw new UnsupportedOperationException();
85         }
86         @Override
87         public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
88             throw new UnsupportedOperationException();
89         }
90         @Override
91         public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
92             throw new UnsupportedOperationException();
93         }
94         @Override
95         public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
96             throw new UnsupportedOperationException();
97         }
98         @Override
99         public Future&lt;?&gt; submit(Runnable task) {
100             throw new UnsupportedOperationException();
101         }
102         @Override
103         public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException {
104             throw new UnsupportedOperationException();
105         }
106         @Override
107         public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
108                 throws InterruptedException {
109             throw new UnsupportedOperationException();
110         }
111         @Override
112         public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
113                 throws InterruptedException, ExecutionException {
114             throw new UnsupportedOperationException();
115         }
116         @Override
117         public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
118                 throws InterruptedException, ExecutionException, TimeoutException {
119             throw new UnsupportedOperationException();
120         }
121         @Override
122         public void execute(Runnable command) {
123             if (!tasks.offer(command)) {
124                 throw new RejectedExecutionException(
125                         "If that happens, there is something wrong with the available capacity/burst size");
126             }
127         }
128     }
129     private enum ExecutorType {
130         spinning,
131         defaultEventExecutor,
132         juc,
133         nioEventLoop,
134         epollEventLoop,
135         kqueueEventLoop
136     }
137     @Param({ "1", "10" })
138     private int burstLength;
139     @Param({ "spinning", "epollEventLoop", "nioEventLoop", "defaultEventExecutor", "juc", "kqueueEventLoop" })
140     private String executorType;
141     @Param({ "0", "10" })
142     private int work;
143     private ExecutorService executor;
144     private ExecutorService executorToShutdown;
145     @Setup
146     public void setup() {
147         ExecutorType type = ExecutorType.valueOf(executorType);
148         switch (type) {
149         case spinning:
150             //The case with 3 producers can have a peak of 3*burstLength offers:
151             //4 is to leave some room between the offers and 1024 is to leave some room
152             //between producer/consumer when work is &gt; 0 and 1 producer.
153             //If work = 0 then the task queue is supposed to be near empty most of the time.
154             executor = new SpinExecutorService(Math.min(1024, burstLength * 4));
155             executorToShutdown = executor;
156             break;
157         case defaultEventExecutor:
158             executor = new DefaultEventExecutor();
159             executorToShutdown = executor;
160             break;
161         case juc:
162             executor = Executors.newSingleThreadScheduledExecutor();
163             executorToShutdown = executor;
164             break;
165         case nioEventLoop:
166             NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup(1);
167             nioEventLoopGroup.setIoRatio(1);
168             executor = nioEventLoopGroup.next();
169             executorToShutdown = nioEventLoopGroup;
170             break;
171         case epollEventLoop:
172             Epoll.ensureAvailability();
173             EpollEventLoopGroup epollEventLoopGroup = new EpollEventLoopGroup(1);
174             epollEventLoopGroup.setIoRatio(1);
175             executor = epollEventLoopGroup.next();
176             executorToShutdown = epollEventLoopGroup;
177             break;
178         case kqueueEventLoop:
179             KQueue.ensureAvailability();
180             KQueueEventLoopGroup kQueueEventLoopGroup = new KQueueEventLoopGroup(1);
181             kQueueEventLoopGroup.setIoRatio(1);
182             executor = kQueueEventLoopGroup.next();
183             executorToShutdown = kQueueEventLoopGroup;
184             break;
185         }
186     }
187     @TearDown
188     public void tearDown() {
189         executorToShutdown.shutdown();
190     }
191     @State(Scope.Thread)
192     public static class PerThreadState {
193         //To reduce the benchmark noise we avoid using AtomicInteger that would
194         //suffer of false sharing while reading/writing the counter due to the surrounding
195         //instances on heap: thanks to JMH the "completed" field will be padded
196         //avoiding false-sharing for free
197         private static final AtomicIntegerFieldUpdater&lt;PerThreadState&gt; DONE_UPDATER =
198                 AtomicIntegerFieldUpdater.newUpdater(PerThreadState.class, "completed");
199         private volatile int completed;
200         private Runnable completeTask;
201         @Setup
202         public void setup(BurstCostExecutorsBenchmark bench) {
203             final int work = bench.work;
204             if (work &gt; 0) {
205                 completeTask = new Runnable() {
206                     @Override
207                     public void run() {
208                         Blackhole.consumeCPU(work);
209                         //We can avoid the full barrier cost of a volatile set given that the
210                         //benchmark is focusing on executors with a single threaded consumer:
211                         //it would reduce the cost on consumer side while allowing to focus just
212                         //to the threads hand-off/wake-up cost
213                         DONE_UPDATER.lazySet(PerThreadState.this, completed + 1);
214                     }
215                 };
216             } else {
217                 completeTask = new Runnable() {
218                     @Override
219                     public void run() {
220                         //We can avoid the full barrier cost of a volatile set given that the
221                         //benchmark is focusing on executors with a single threaded consumer:
222                         //it would reduce the cost on consumer side while allowing to focus just
223                         //to the threads hand-off/wake-up cost
224                         DONE_UPDATER.lazySet(PerThreadState.this, completed + 1);
225                     }
226                 };
227             }
228         }
229         public void resetCompleted() {
230             //We can avoid the full barrier cost of a volatile set given that
231             //the counter can be reset from a single thread and it should be reset
232             //only after any submitted tasks are completed
233             DONE_UPDATER.lazySet(this, 0);
234         }
235         public int spinWaitCompletionOf(int value) {
236             while (true) {
237                 final int lastRead = this.completed;
238                 if (lastRead &gt;= value) {
239                     return lastRead;
240                 }
241             }
242         }
243     }
244     @Benchmark
245     @BenchmarkMode(Mode.SampleTime)
246     @Threads(1)
247     public int test1Producer(final PerThreadState state) {
248         return executeBurst(state);
249     }
250     @Benchmark
251     @BenchmarkMode(Mode.SampleTime)
252     @Threads(2)
253     public int test2Producers(final PerThreadState state) {
254         return executeBurst(state);
255     }
256     @Benchmark
257     @BenchmarkMode(Mode.SampleTime)
258     @Threads(3)
259     public int test3Producers(final PerThreadState state) {
260         return executeBurst(state);
261     }
262     private int executeBurst(final PerThreadState state) {
263         final ExecutorService executor = this.executor;
264         final int burstLength = this.burstLength;
265         final Runnable completeTask = state.completeTask;
266         for (int i = 0; i &lt; burstLength; i++) {
267             executor.execute(completeTask);
268         }
269         final int value = state.spinWaitCompletionOf(burstLength);
270         state.resetCompleted();
271         return value;
272     }
273 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReplayingDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2012 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13 <a name="0"></a> * License for the specific language governing permissions and limitations
14  * under the License.
15  */
16 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec;
17 import io.netty.buffer.ByteBuf;
18 import io.netty.buffer.Unpooled;
19 import io.netty.channel.ChannelHandlerContext;
20 import io.netty.channel.ChannelInboundHandlerAdapter;
21 import io.netty.channel.embedded.EmbeddedChannel;
22 import io.netty.channel.socket.ChannelInputShutdownEvent;
23 import io.netty.util.internal.PlatformDependent;
24 import org.junit.jupiter.api.Test;
25 import java.util.List;
26 import java.util.concurrent.BlockingQueue;
27 import java.util.concurrent.LinkedBlockingDeque;
28 import java.util.concurrent.atomic.AtomicReference;
29 import static org.junit.jupiter.api.Assertions.assertEquals;
30 import static org.junit.jupiter.api.Assertions.assertFalse;
31 import static org.junit.jupiter.api.Assertions.assertNull;
32 import</b></font> static org.junit.jupiter.api.Assertions.assertTrue;
33 public class ReplayingDecoderTest {
34     @Test
35     public void testLineProtocol() {
36         EmbeddedChannel ch = new EmbeddedChannel(new LineDecoder());
37         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A' }));
38         assertNull(ch.readInbound());
39         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'B' }));
40         assertNull(ch.readInbound());
41         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'C' }));
42         assertNull(ch.readInbound());
43         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { '\n' }));
44         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' });
45         ByteBuf buf2 = ch.readInbound();
46         assertEquals(buf, buf2);
47         buf.release();
48         buf2.release();
49         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A' }));
50         assertNull(ch.readInbound());
51         ch.finish();
52         assertNull(ch.readInbound());
53     }
54     private static final class LineDecoder extends ReplayingDecoder&lt;Void&gt; {
55         LineDecoder() {
56         }
57         @Override
58         protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {
59             ByteBuf msg = in.readBytes(in.bytesBefore((byte) '\n'));
60             out.add(msg);
61             in.skipBytes(1);
62         }
63     }
64     @Test
65     public void testReplacement() throws Exception {
66         EmbeddedChannel ch = new EmbeddedChannel(new BloatedLineDecoder());
67         ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'A', 'B'}));
68         assertNull(ch.readInbound());
69         ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'C', '\n'}));
70         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' });
71         ByteBuf buf2 = ch.readInbound();
72         assertEquals(buf, buf2);
73         buf.release();
74         buf2.release();
75         ch.finish();
76         assertNull(ch.readInbound());
77     }
78     private static final class BloatedLineDecoder extends ChannelInboundHandlerAdapter {
79         @Override
80         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
81             ctx.pipeline().replace(this, "less-bloated", new LineDecoder());
82             ctx.pipeline().fireChannelRead(msg);
83         }
84     }
85     @Test
86     public void testSingleDecode() throws Exception {
87         LineDecoder decoder = new LineDecoder();
88         decoder.setSingleDecode(true);
89         EmbeddedChannel ch = new EmbeddedChannel(decoder);
90         ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'C', '\n' , 'B', '\n'}));
91         ByteBuf buf  = Unpooled.wrappedBuffer(new byte[] {'C'});
92         ByteBuf buf2 = ch.readInbound();
93         assertEquals(buf, buf2);
94         buf.release();
95         buf2.release();
96         assertNull(ch.readInbound(), "Must be null as it must only decode one frame");
97         ch.read();
98         ch.finish();
99         buf  = Unpooled.wrappedBuffer(new byte[] {'B'});
100         buf2 = ch.readInbound();
101         assertEquals(buf, buf2);
102         buf.release();
103         buf2.release();
104         assertNull(ch.readInbound());
105     }
106     @Test
107     public void testRemoveItself() {
108         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder() {
109             private boolean removed;
110             @Override
111             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
112                 assertFalse(removed);
113                 in.readByte();
114                 ctx.pipeline().remove(this);
115                 removed = true;
116             }
117         });
118         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
119         channel.writeInbound(buf.copy());
120         ByteBuf b = channel.readInbound();
121         assertEquals(b, buf.skipBytes(1));
122         b.release();
123         buf.release();
124     }
125     @Test
126     public void testRemoveItselfWithReplayError() {
127         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder() {
128             private boolean removed;
129             @Override
130             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
131                 assertFalse(removed);
132                 ctx.pipeline().remove(this);
133                 in.readBytes(1000);
134                 removed = true;
135             }
136         });
137         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
138         channel.writeInbound(buf.copy());
139         ByteBuf b = channel.readInbound();
140         assertEquals(b, buf, "Expect to have still all bytes in the buffer");
141         b.release();
142         buf.release();
143     }
144     @Test
145     public void testRemoveItselfWriteBuffer() {
146         final ByteBuf buf = Unpooled.buffer().writeBytes(new byte[] {'a', 'b', 'c'});
147         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder() {
148             private boolean removed;
149             @Override
150             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
151                 assertFalse(removed);
152                 in.readByte();
153                 ctx.pipeline().remove(this);
154                 buf.writeByte('d');
155                 removed = true;
156             }
157         });
158         channel.writeInbound(buf.copy());
159         ByteBuf b = channel.readInbound();
160         assertEquals(b, Unpooled.wrappedBuffer(new byte[] { 'b', 'c'}));
161         b.release();
162         buf.release();
163     }
164     @Test
165     public void testFireChannelReadCompleteOnInactive() throws InterruptedException {
166         final BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingDeque&lt;Integer&gt;();
167         final ByteBuf buf = Unpooled.buffer().writeBytes(new byte[]{'a', 'b'});
168         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder&lt;Integer&gt;() {
169             @Override
170             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
171                 int readable = in.readableBytes();
172                 assertTrue(readable &gt; 0);
173                 in.skipBytes(readable);
174                 out.add("data");
175             }
176             @Override
177             protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
178                 assertFalse(in.isReadable());
179                 out.add("data");
180             }
181         }, new ChannelInboundHandlerAdapter() {
182             @Override
183             public void channelInactive(ChannelHandlerContext ctx) throws Exception {
184                 queue.add(3);
185             }
186             @Override
187             public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
188                 queue.add(1);
189             }
190             @Override
191             public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
192                 if (!ctx.channel().isActive()) {
193                     queue.add(2);
194                 }
195             }
196         });
197         assertFalse(channel.writeInbound(buf));
198         channel.finish();
199         assertEquals(1, (int) queue.take());
200         assertEquals(1, (int) queue.take());
201         assertEquals(2, (int) queue.take());
202         assertEquals(3, (int) queue.take());
203         assertTrue(queue.isEmpty());
204     }
205     @Test
206     public void testChannelInputShutdownEvent() {
207         final AtomicReference&lt;Error&gt; error = new AtomicReference&lt;Error&gt;();
208         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder&lt;Integer&gt;(0) {
209             private boolean decoded;
210             @Override
211             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
212                 if (!(in instanceof ReplayingDecoderByteBuf)) {
213                     error.set(new AssertionError("in must be of type " + ReplayingDecoderByteBuf.class
214                             + " but was " + in.getClass()));
215                     return;
216                 }
217                 if (!decoded) {
218                     decoded = true;
219                     in.readByte();
220                     state(1);
221                 } else {
222                     in.skipBytes(Integer.MAX_VALUE);
223                 }
224             }
225         });
226         assertFalse(channel.writeInbound(Unpooled.wrappedBuffer(new byte[] {0, 1})));
227         channel.pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
228         assertFalse(channel.finishAndReleaseAll());
229         Error err = error.get();
230         if (err != null) {
231             throw err;
232         }
233     }
234     @Test
235     public void handlerRemovedWillNotReleaseBufferIfDecodeInProgress() {
236         EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder&lt;Integer&gt;() {
237             @Override
238             protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
239                 ctx.pipeline().remove(this);
240                 assertTrue(in.refCnt() != 0);
241             }
242             @Override
243             protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
244                 assertCumulationReleased(internalBuffer());
245             }
246         });
247         byte[] bytes = new byte[1024];
248         PlatformDependent.threadLocalRandom().nextBytes(bytes);
249         assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
250         assertTrue(channel.finishAndReleaseAll());
251     }
252     private static void assertCumulationReleased(ByteBuf byteBuf) {
253         assertTrue(byteBuf == null || byteBuf == Unpooled.EMPTY_BUFFER || byteBuf.refCnt() == 0,
254                 "unexpected value: " + byteBuf);
255     }
256 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
