
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-UserConnection.java</h3>
            <pre><code>1  package net.md_5.bungee;
2  import com.google.common.base.Preconditions;
3  import com.google.common.collect.ImmutableMap;
4  import io.netty.bootstrap.Bootstrap;
5  import io.netty.channel.Channel;
6  import io.netty.channel.ChannelFuture;
7  import io.netty.channel.ChannelFutureListener;
8  import io.netty.channel.ChannelInitializer;
9  import io.netty.channel.ChannelOption;
10  import io.netty.util.internal.PlatformDependent;
11  import java.net.InetSocketAddress;
12  import java.net.SocketAddress;
13  import java.util.Collection;
14  import java.util.Collections;
15  import java.util.HashSet;
16  import java.util.LinkedList;
17  import java.util.Locale;
18  import java.util.Map;
19  import java.util.Objects;
20  import java.util.Queue;
21  import java.util.UUID;
22  import java.util.logging.Level;
23  import lombok.Getter;
24  import lombok.NonNull;
25  import lombok.RequiredArgsConstructor;
26  import lombok.Setter;
27  import net.md_5.bungee.api.Callback;
28  import net.md_5.bungee.api.ChatMessageType;
29  import net.md_5.bungee.api.ProxyServer;
30  import net.md_5.bungee.api.ServerConnectRequest;
31  import net.md_5.bungee.api.SkinConfiguration;
32  import net.md_5.bungee.api.Title;
33  import net.md_5.bungee.api.chat.BaseComponent;
34  import net.md_5.bungee.api.chat.TextComponent;
35  import net.md_5.bungee.api.config.ServerInfo;
36  import net.md_5.bungee.api.connection.ProxiedPlayer;
37  import net.md_5.bungee.api.event.PermissionCheckEvent;
38  import net.md_5.bungee.api.event.ServerConnectEvent;
39  import net.md_5.bungee.api.score.Scoreboard;
40  import net.md_5.bungee.chat.ComponentSerializer;
41  import net.md_5.bungee.connection.InitialHandler;
42  import net.md_5.bungee.entitymap.EntityMap;
43  import net.md_5.bungee.forge.ForgeClientHandler;
44  import net.md_5.bungee.forge.ForgeConstants;
45  import net.md_5.bungee.forge.ForgeServerHandler;
46  import net.md_5.bungee.netty.ChannelWrapper;
47  import net.md_5.bungee.netty.HandlerBoss;
48  import net.md_5.bungee.netty.PipelineUtils;
49  import net.md_5.bungee.protocol.DefinedPacket;
50  import net.md_5.bungee.protocol.MinecraftDecoder;
51  import net.md_5.bungee.protocol.MinecraftEncoder;
52  import net.md_5.bungee.protocol.PacketWrapper;
53  import net.md_5.bungee.protocol.Protocol;
54  import net.md_5.bungee.protocol.ProtocolConstants;
55  import net.md_5.bungee.protocol.packet.Chat;
56  import net.md_5.bungee.protocol.packet.ClientSettings;
57  import net.md_5.bungee.protocol.packet.Kick;
58  import net.md_5.bungee.protocol.packet.PlayerListHeaderFooter;
59  import net.md_5.bungee.protocol.packet.PluginMessage;
60  import net.md_5.bungee.protocol.packet.SetCompression;
61  import net.md_5.bungee.protocol.packet.SystemChat;
62  import net.md_5.bungee.tab.ServerUnique;
63  import net.md_5.bungee.tab.TabList;
64  import net.md_5.bungee.util.CaseInsensitiveSet;
65  import net.md_5.bungee.util.ChatComponentTransformer;
66  @RequiredArgsConstructor
67  public final class UserConnection implements ProxiedPlayer
68  {
69      @NonNull
70      private final ProxyServer bungee;
71      @NonNull
72      private final ChannelWrapper ch;
73      @Getter
74      @NonNull
75      private final String name;
76      @Getter
77      private final InitialHandler pendingConnection;
78      @Getter
79      @Setter
80      private ServerConnection server;
81      @Getter
82      @Setter
83      private Object dimension;
84      @Getter
85      @Setter
86      private boolean dimensionChange = true;
87      @Getter
88      private final Collection<ServerInfo> pendingConnects = new HashSet<>();
89      @Getter
90      @Setter
91      private int ping = 100;
92      @Getter
93      @Setter
94      private ServerInfo reconnectServer;
95      @Getter
96      private TabList tabListHandler;
97      @Getter
98      @Setter
99      private int gamemode;
100      @Getter
101      private int compressionThreshold = -1;
102      @Setter
103      private Queue<String> serverJoinQueue;
104      private final Collection<String> groups = new CaseInsensitiveSet();
105      private final Collection<String> permissions = new CaseInsensitiveSet();
106      @Getter
107      @Setter
108      private int clientEntityId;
109      @Getter
110      @Setter
111      private int serverEntityId;
112      @Getter
113      private ClientSettings settings;
114      @Getter
115      private final Scoreboard serverSentScoreboard = new Scoreboard();
116      @Getter
117      private final Collection<UUID> sentBossBars = new HashSet<>();
118      @Getter
119      private String displayName;
120      @Getter
121      private EntityMap entityRewrite;
122      private Locale locale;
123      @Getter
124      @Setter
125      private ForgeClientHandler forgeClientHandler;
126      @Getter
127      @Setter
128      private ForgeServerHandler forgeServerHandler;
129      private final Unsafe unsafe = new Unsafe()
130      {
131          @Override
132          public void sendPacket(DefinedPacket packet)
133          {
134              ch.write( packet );
135          }
136      };
137      public void init()
138      {
139          this.entityRewrite = EntityMap.getEntityMap( getPendingConnection().getVersion() );
140          this.displayName = name;
141          tabListHandler = new ServerUnique( this );
142          Collection<String> g = bungee.getConfigurationAdapter().getGroups( name );
143          g.addAll( bungee.getConfigurationAdapter().getGroups( getUniqueId().toString() ) );
144          for ( String s : g )
145          {
146              addGroups( s );
147          }
148          forgeClientHandler = new ForgeClientHandler( this );
149          forgeClientHandler.setFmlTokenInHandshake( this.getPendingConnection().getExtraDataInHandshake().contains( ForgeConstants.FML_HANDSHAKE_TOKEN ) );
150      }
151      public void sendPacket(PacketWrapper packet)
152      {
153          ch.write( packet );
154      }
155      @Deprecated
156      public boolean isActive()
157      {
158          return !ch.isClosed();
159      }
160      @Override
161      public void setDisplayName(String name)
162      {
163          Preconditions.checkNotNull( name, "displayName" );
164          displayName = name;
165      }
166      @Override
167      public void connect(ServerInfo target)
168      {
169          connect( target, null, ServerConnectEvent.Reason.PLUGIN );
170      }
171      @Override
172      public void connect(ServerInfo target, ServerConnectEvent.Reason reason)
173      {
174          connect( target, null, false, reason );
175      }
176      @Override
177      public void connect(ServerInfo target, Callback<Boolean> callback)
178      {
179          connect( target, callback, false, ServerConnectEvent.Reason.PLUGIN );
180      }
181      @Override
182      public void connect(ServerInfo target, Callback<Boolean> callback, ServerConnectEvent.Reason reason)
183      {
184          connect( target, callback, false, reason );
185      }
186      @Deprecated
187      public void connectNow(ServerInfo target)
188      {
189          connectNow( target, ServerConnectEvent.Reason.UNKNOWN );
190      }
191      public void connectNow(ServerInfo target, ServerConnectEvent.Reason reason)
192      {
193          dimensionChange = true;
194          connect( target, reason );
195      }
196      public ServerInfo updateAndGetNextServer(ServerInfo currentTarget)
197      {
198          if ( serverJoinQueue == null )
199          {
200              serverJoinQueue = new LinkedList<>( getPendingConnection().getListener().getServerPriority() );
201          }
202          ServerInfo next = null;
203          while ( !serverJoinQueue.isEmpty() )
204          {
205              ServerInfo candidate = ProxyServer.getInstance().getServerInfo( serverJoinQueue.remove() );
206              if ( !Objects.equals( currentTarget, candidate ) )
207              {
208                  next = candidate;
209                  break;
210              }
211          }
212          return next;
213      }
214      public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry)
215      {
216          connect( info, callback, retry, ServerConnectEvent.Reason.PLUGIN );
217      }
218      public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, ServerConnectEvent.Reason reason)
219      {
220          Preconditions.checkNotNull( info, "info" );
221          ServerConnectRequest.Builder builder = ServerConnectRequest.builder().retry( retry ).reason( reason ).target( info );
222          if ( callback != null )
223          {
224              builder.callback( new Callback<ServerConnectRequest.Result>()
225              {
226                  @Override
227                  public void done(ServerConnectRequest.Result result, Throwable error)
228                  {
229                      callback.done( ( result == ServerConnectRequest.Result.SUCCESS ) ? Boolean.TRUE : Boolean.FALSE, error );
230                  }
231              } );
232          }
233          connect( builder.build() );
234      }
235      @Override
236      public void connect(final ServerConnectRequest request)
237      {
238          Preconditions.checkNotNull( request, "request" );
239          final Callback<ServerConnectRequest.Result> callback = request.getCallback();
240          ServerConnectEvent event = new ServerConnectEvent( this, request.getTarget(), request.getReason(), request );
241          if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
242          {
243              if ( callback != null )
244              {
245                  callback.done( ServerConnectRequest.Result.EVENT_CANCEL, null );
246              }
247              if ( getServer() == null && !ch.isClosing() )
248              {
249                  throw new IllegalStateException( "Cancelled ServerConnectEvent with no server or disconnect." );
250              }
251              return;
252          }
253          final BungeeServerInfo target = (BungeeServerInfo) event.getTarget(); 
254          if ( getServer() != null && Objects.equals( getServer().getInfo(), target ) )
255          {
256              if ( callback != null )
257              {
258                  callback.done( ServerConnectRequest.Result.ALREADY_CONNECTED, null );
259              }
260              sendMessage( bungee.getTranslation( "already_connected" ) );
261              return;
262          }
263          if ( pendingConnects.contains( target ) )
264          {
265              if ( callback != null )
266              {
267                  callback.done( ServerConnectRequest.Result.ALREADY_CONNECTING, null );
268              }
269              sendMessage( bungee.getTranslation( "already_connecting" ) );
270              return;
271          }
272          pendingConnects.add( target );
273          ChannelInitializer initializer = new ChannelInitializer()
274          {
275              @Override
276              protected void initChannel(Channel ch) throws Exception
277              {
278                  PipelineUtils.BASE_SERVERSIDE.initChannel( ch );
279                  ch.pipeline().addAfter( PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
280                  ch.pipeline().addAfter( PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
281                  ch.pipeline().get( HandlerBoss.class ).setHandler( new ServerConnector( bungee, UserConnection.this, target ) );
282              }
283          };
284          ChannelFutureListener listener = new ChannelFutureListener()
285          {
286              @Override
287              @SuppressWarnings("ThrowableResultIgnored")
288              public void operationComplete(ChannelFuture future) throws Exception
289              {
290                  if ( callback != null )
291                  {
292                      callback.done( ( future.isSuccess() ) ? ServerConnectRequest.Result.SUCCESS : ServerConnectRequest.Result.FAIL, future.cause() );
293                  }
294                  if ( !future.isSuccess() )
295                  {
296                      future.channel().close();
297                      pendingConnects.remove( target );
298                      ServerInfo def = updateAndGetNextServer( target );
299                      if ( request.isRetry() && def != null && ( getServer() == null || def != getServer().getInfo() ) )
300                      {
301                          sendMessage( bungee.getTranslation( "fallback_lobby" ) );
302                          connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK );
303                      } else if ( dimensionChange )
304                      {
305                          disconnect( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
306                      } else
307                      {
308                          sendMessage( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
309                      }
310                  }
311              }
312          };
313          Bootstrap b = new Bootstrap()
314                  .channel( PipelineUtils.getChannel( target.getAddress() ) )
315                  .group( ch.getHandle().eventLoop() )
316                  .handler( initializer )
317                  .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
318                  .remoteAddress( target.getAddress() );
319          if ( getPendingConnection().getListener().isSetLocalAddress() && !PlatformDependent.isWindows() && getPendingConnection().getListener().getSocketAddress() instanceof InetSocketAddress )
320          {
321              b.localAddress( getPendingConnection().getListener().getHost().getHostString(), 0 );
322          }
323          b.connect().addListener( listener );
324      }
325      private String connectionFailMessage(Throwable cause)
326      {
327          return groups.contains( "admin" ) ? Util.exception( cause, false ) : cause.getClass().getName();
328      }
329      @Override
330      public void disconnect(String reason)
331      {
332          disconnect0( TextComponent.fromLegacyText( reason ) );
333      }
334      @Override
335      public void disconnect(BaseComponent... reason)
336      {
337          disconnect0( reason );
338      }
339      @Override
340      public void disconnect(BaseComponent reason)
341      {
342          disconnect0( reason );
343      }
344      public void disconnect0(final BaseComponent... reason)
345      {
346          if ( !ch.isClosing() )
347          {
348              bungee.getLogger().log( Level.INFO, "[{0}] disconnected with: {1}", new Object[]
349              {
350                  getName(), BaseComponent.toLegacyText( reason )
351              } );
352              ch.close( new Kick( ComponentSerializer.toString( reason ) ) );
353              if ( server != null )
354              {
355                  server.setObsolete( true );
356                  server.disconnect( "Quitting" );
357              }
358          }
359      }
360      @Override
361      public void chat(String message)
362      {
363          Preconditions.checkState( server != null, "Not connected to server" );
364          if ( getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_19 )
365          {
366              throw new UnsupportedOperationException( "Cannot spoof chat on this client version!" );
367          }
368          server.getCh().write( new Chat( message ) );
369      }
370      @Override
371      public void sendMessage(String message)
372      {
373          sendMessage( TextComponent.fromLegacyText( message ) );
374      }
375      @Override
376      public void sendMessages(String... messages)
377      {
378          for ( String message : messages )
379          {
380              sendMessage( message );
381          }
382      }
383      @Override
384      public void sendMessage(BaseComponent... message)
385      {
386          sendMessage( ChatMessageType.SYSTEM, message );
387      }
388      @Override
389      public void sendMessage(BaseComponent message)
390      {
391          sendMessage( ChatMessageType.SYSTEM, message );
392      }
393      @Override
394      public void sendMessage(ChatMessageType position, BaseComponent... message)
395      {
396          sendMessage( position, null, message );
397      }
398      @Override
399      public void sendMessage(ChatMessageType position, BaseComponent message)
400      {
401          sendMessage( position, (UUID) null, message );
402      }
403      @Override
404      public void sendMessage(UUID sender, BaseComponent... message)
405      {
406          sendMessage( ChatMessageType.CHAT, sender, message );
407      }
408      @Override
409      public void sendMessage(UUID sender, BaseComponent message)
410      {
411          sendMessage( ChatMessageType.CHAT, sender, message );
412      }
413      private void sendMessage(ChatMessageType position, UUID sender, String message)
414      {
415          if ( getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_19 )
416          {
417              if ( position == ChatMessageType.CHAT )
418              {
419                  position = ChatMessageType.SYSTEM;
420              }
421              unsafe().sendPacket( new SystemChat( message, position.ordinal() ) );
422          } else
423          {
424              unsafe().sendPacket( new Chat( message, (byte) position.ordinal(), sender ) );
425          }
426      }
427      private void sendMessage(ChatMessageType position, UUID sender, BaseComponent... message)
428      {
429          message = ChatComponentTransformer.getInstance().transform( this, true, message );
430          if ( position == ChatMessageType.ACTION_BAR && getPendingConnection().getVersion() < ProtocolConstants.MINECRAFT_1_17 )
431          {
432              if ( getPendingConnection().getVersion() <= ProtocolConstants.MINECRAFT_1_10 )
433              {
434                  sendMessage( position, sender, ComponentSerializer.toString( new TextComponent( BaseComponent.toLegacyText( message ) ) ) );
435              } else
436              {
437                  net.md_5.bungee.protocol.packet.Title title = new net.md_5.bungee.protocol.packet.Title();
438                  title.setAction( net.md_5.bungee.protocol.packet.Title.Action.ACTIONBAR );
439                  title.setText( ComponentSerializer.toString( message ) );
440                  unsafe.sendPacket( title );
441              }
442          } else
443          {
444              sendMessage( position, sender, ComponentSerializer.toString( message ) );
445          }
446      }
447      @Override
448      public void sendData(String channel, byte[] data)
449      {
450          unsafe().sendPacket( new PluginMessage( channel, data, forgeClientHandler.isForgeUser() ) );
451      }
452      @Override
453      public InetSocketAddress getAddress()
454      {
455          return (InetSocketAddress) getSocketAddress();
456      }
457      @Override
458      public SocketAddress getSocketAddress()
459      {
460          return ch.getRemoteAddress();
461      }
462      @Override
463      public Collection<String> getGroups()
464      {
465          return Collections.unmodifiableCollection( groups );
466      }
467      @Override
<span onclick='openModal()' class='match'>468      public void addGroups(String... groups)
469      {
470          for ( String group : groups )
471          {
472              this.groups.add( group );
</span>473              for ( String permission : bungee.getConfigurationAdapter().getPermissions( group ) )
474              {
475                  setPermission( permission, true );
476              }
477          }
478      }
479      @Override
480      public void removeGroups(String... groups)
481      {
482          for ( String group : groups )
483          {
484              this.groups.remove( group );
485              for ( String permission : bungee.getConfigurationAdapter().getPermissions( group ) )
486              {
487                  setPermission( permission, false );
488              }
489          }
490      }
491      @Override
492      public boolean hasPermission(String permission)
493      {
494          return bungee.getPluginManager().callEvent( new PermissionCheckEvent( this, permission, permissions.contains( permission ) ) ).hasPermission();
495      }
496      @Override
497      public void setPermission(String permission, boolean value)
498      {
499          if ( value )
500          {
501              permissions.add( permission );
502          } else
503          {
504              permissions.remove( permission );
505          }
506      }
507      @Override
508      public Collection<String> getPermissions()
509      {
510          return Collections.unmodifiableCollection( permissions );
511      }
512      @Override
513      public String toString()
514      {
515          return name;
516      }
517      @Override
518      public Unsafe unsafe()
519      {
520          return unsafe;
521      }
522      @Override
523      public String getUUID()
524      {
525          return getPendingConnection().getUUID();
526      }
527      @Override
528      public UUID getUniqueId()
529      {
530          return getPendingConnection().getUniqueId();
531      }
532      public void setSettings(ClientSettings settings)
533      {
534          this.settings = settings;
535          this.locale = null;
536      }
537      @Override
538      public Locale getLocale()
539      {
540          return ( locale == null && settings != null ) ? locale = Locale.forLanguageTag( settings.getLocale().replace( '_', '-' ) ) : locale;
541      }
542      @Override
543      public byte getViewDistance()
544      {
545          return ( settings != null ) ? settings.getViewDistance() : 10;
546      }
547      @Override
548      public ProxiedPlayer.ChatMode getChatMode()
549      {
550          if ( settings == null )
551          {
552              return ProxiedPlayer.ChatMode.SHOWN;
553          }
554          switch ( settings.getChatFlags() )
555          {
556              default:
557              case 0:
558                  return ProxiedPlayer.ChatMode.SHOWN;
559              case 1:
560                  return ProxiedPlayer.ChatMode.COMMANDS_ONLY;
561              case 2:
562                  return ProxiedPlayer.ChatMode.HIDDEN;
563          }
564      }
565      @Override
566      public boolean hasChatColors()
567      {
568          return settings == null || settings.isChatColours();
569      }
570      @Override
571      public SkinConfiguration getSkinParts()
572      {
573          return ( settings != null ) ? new PlayerSkinConfiguration( settings.getSkinParts() ) : PlayerSkinConfiguration.SKIN_SHOW_ALL;
574      }
575      @Override
576      public ProxiedPlayer.MainHand getMainHand()
577      {
578          return ( settings == null || settings.getMainHand() == 1 ) ? ProxiedPlayer.MainHand.RIGHT : ProxiedPlayer.MainHand.LEFT;
579      }
580      @Override
581      public boolean isForgeUser()
582      {
583          return forgeClientHandler.isForgeUser();
584      }
585      @Override
586      public Map<String, String> getModList()
587      {
588          if ( forgeClientHandler.getClientModList() == null )
589          {
590              return ImmutableMap.of();
591          }
592          return ImmutableMap.copyOf( forgeClientHandler.getClientModList() );
593      }
594      @Override
595      public void setTabHeader(BaseComponent header, BaseComponent footer)
596      {
597          header = ChatComponentTransformer.getInstance().transform( this, true, header )[0];
598          footer = ChatComponentTransformer.getInstance().transform( this, true, footer )[0];
599          unsafe().sendPacket( new PlayerListHeaderFooter(
600                  ComponentSerializer.toString( header ),
601                  ComponentSerializer.toString( footer )
602          ) );
603      }
604      @Override
605      public void setTabHeader(BaseComponent[] header, BaseComponent[] footer)
606      {
607          header = ChatComponentTransformer.getInstance().transform( this, true, header );
608          footer = ChatComponentTransformer.getInstance().transform( this, true, footer );
609          unsafe().sendPacket( new PlayerListHeaderFooter(
610                  ComponentSerializer.toString( header ),
611                  ComponentSerializer.toString( footer )
612          ) );
613      }
614      @Override
615      public void resetTabHeader()
616      {
617          setTabHeader( (BaseComponent) null, null );
618      }
619      @Override
620      public void sendTitle(Title title)
621      {
622          title.send( this );
623      }
624      public String getExtraDataInHandshake()
625      {
626          return this.getPendingConnection().getExtraDataInHandshake();
627      }
628      public void setCompressionThreshold(int compressionThreshold)
629      {
630          if ( !ch.isClosing() && this.compressionThreshold == -1 && compressionThreshold >= 0 )
631          {
632              this.compressionThreshold = compressionThreshold;
633              unsafe.sendPacket( new SetCompression( compressionThreshold ) );
634              ch.setCompressionThreshold( compressionThreshold );
635          }
636      }
637      @Override
638      public boolean isConnected()
639      {
640          return !ch.isClosed();
641      }
642      @Override
643      public Scoreboard getScoreboard()
644      {
645          return serverSentScoreboard;
646      }
647  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-UserConnection.java</h3>
            <pre><code>1  package net.md_5.bungee;
2  import com.google.common.base.Preconditions;
3  import com.google.common.collect.ImmutableMap;
4  import io.netty.bootstrap.Bootstrap;
5  import io.netty.channel.Channel;
6  import io.netty.channel.ChannelFuture;
7  import io.netty.channel.ChannelFutureListener;
8  import io.netty.channel.ChannelInitializer;
9  import io.netty.channel.ChannelOption;
10  import io.netty.util.internal.PlatformDependent;
11  import java.net.InetSocketAddress;
12  import java.net.SocketAddress;
13  import java.util.Collection;
14  import java.util.Collections;
15  import java.util.HashSet;
16  import java.util.LinkedList;
17  import java.util.Locale;
18  import java.util.Map;
19  import java.util.Objects;
20  import java.util.Queue;
21  import java.util.UUID;
22  import java.util.logging.Level;
23  import lombok.Getter;
24  import lombok.NonNull;
25  import lombok.RequiredArgsConstructor;
26  import lombok.Setter;
27  import net.md_5.bungee.api.Callback;
28  import net.md_5.bungee.api.ChatMessageType;
29  import net.md_5.bungee.api.ProxyServer;
30  import net.md_5.bungee.api.ServerConnectRequest;
31  import net.md_5.bungee.api.SkinConfiguration;
32  import net.md_5.bungee.api.Title;
33  import net.md_5.bungee.api.chat.BaseComponent;
34  import net.md_5.bungee.api.chat.TextComponent;
35  import net.md_5.bungee.api.config.ServerInfo;
36  import net.md_5.bungee.api.connection.ProxiedPlayer;
37  import net.md_5.bungee.api.event.PermissionCheckEvent;
38  import net.md_5.bungee.api.event.ServerConnectEvent;
39  import net.md_5.bungee.api.score.Scoreboard;
40  import net.md_5.bungee.chat.ComponentSerializer;
41  import net.md_5.bungee.connection.InitialHandler;
42  import net.md_5.bungee.entitymap.EntityMap;
43  import net.md_5.bungee.forge.ForgeClientHandler;
44  import net.md_5.bungee.forge.ForgeConstants;
45  import net.md_5.bungee.forge.ForgeServerHandler;
46  import net.md_5.bungee.netty.ChannelWrapper;
47  import net.md_5.bungee.netty.HandlerBoss;
48  import net.md_5.bungee.netty.PipelineUtils;
49  import net.md_5.bungee.protocol.DefinedPacket;
50  import net.md_5.bungee.protocol.MinecraftDecoder;
51  import net.md_5.bungee.protocol.MinecraftEncoder;
52  import net.md_5.bungee.protocol.PacketWrapper;
53  import net.md_5.bungee.protocol.Protocol;
54  import net.md_5.bungee.protocol.ProtocolConstants;
55  import net.md_5.bungee.protocol.packet.Chat;
56  import net.md_5.bungee.protocol.packet.ClientSettings;
57  import net.md_5.bungee.protocol.packet.Kick;
58  import net.md_5.bungee.protocol.packet.PlayerListHeaderFooter;
59  import net.md_5.bungee.protocol.packet.PluginMessage;
60  import net.md_5.bungee.protocol.packet.SetCompression;
61  import net.md_5.bungee.protocol.packet.SystemChat;
62  import net.md_5.bungee.tab.ServerUnique;
63  import net.md_5.bungee.tab.TabList;
64  import net.md_5.bungee.util.CaseInsensitiveSet;
65  import net.md_5.bungee.util.ChatComponentTransformer;
66  @RequiredArgsConstructor
67  public final class UserConnection implements ProxiedPlayer
68  {
69      @NonNull
70      private final ProxyServer bungee;
71      @NonNull
72      private final ChannelWrapper ch;
73      @Getter
74      @NonNull
75      private final String name;
76      @Getter
77      private final InitialHandler pendingConnection;
78      @Getter
79      @Setter
80      private ServerConnection server;
81      @Getter
82      @Setter
83      private Object dimension;
84      @Getter
85      @Setter
86      private boolean dimensionChange = true;
87      @Getter
88      private final Collection<ServerInfo> pendingConnects = new HashSet<>();
89      @Getter
90      @Setter
91      private int ping = 100;
92      @Getter
93      @Setter
94      private ServerInfo reconnectServer;
95      @Getter
96      private TabList tabListHandler;
97      @Getter
98      @Setter
99      private int gamemode;
100      @Getter
101      private int compressionThreshold = -1;
102      @Setter
103      private Queue<String> serverJoinQueue;
104      private final Collection<String> groups = new CaseInsensitiveSet();
105      private final Collection<String> permissions = new CaseInsensitiveSet();
106      @Getter
107      @Setter
108      private int clientEntityId;
109      @Getter
110      @Setter
111      private int serverEntityId;
112      @Getter
113      private ClientSettings settings;
114      @Getter
115      private final Scoreboard serverSentScoreboard = new Scoreboard();
116      @Getter
117      private final Collection<UUID> sentBossBars = new HashSet<>();
118      @Getter
119      private String displayName;
120      @Getter
121      private EntityMap entityRewrite;
122      private Locale locale;
123      @Getter
124      @Setter
125      private ForgeClientHandler forgeClientHandler;
126      @Getter
127      @Setter
128      private ForgeServerHandler forgeServerHandler;
129      private final Unsafe unsafe = new Unsafe()
130      {
131          @Override
132          public void sendPacket(DefinedPacket packet)
133          {
134              ch.write( packet );
135          }
136      };
137      public void init()
138      {
139          this.entityRewrite = EntityMap.getEntityMap( getPendingConnection().getVersion() );
140          this.displayName = name;
141          tabListHandler = new ServerUnique( this );
142          Collection<String> g = bungee.getConfigurationAdapter().getGroups( name );
143          g.addAll( bungee.getConfigurationAdapter().getGroups( getUniqueId().toString() ) );
144          for ( String s : g )
145          {
146              addGroups( s );
147          }
148          forgeClientHandler = new ForgeClientHandler( this );
149          forgeClientHandler.setFmlTokenInHandshake( this.getPendingConnection().getExtraDataInHandshake().contains( ForgeConstants.FML_HANDSHAKE_TOKEN ) );
150      }
151      public void sendPacket(PacketWrapper packet)
152      {
153          ch.write( packet );
154      }
155      @Deprecated
156      public boolean isActive()
157      {
158          return !ch.isClosed();
159      }
160      @Override
161      public void setDisplayName(String name)
162      {
163          Preconditions.checkNotNull( name, "displayName" );
164          displayName = name;
165      }
166      @Override
167      public void connect(ServerInfo target)
168      {
169          connect( target, null, ServerConnectEvent.Reason.PLUGIN );
170      }
171      @Override
172      public void connect(ServerInfo target, ServerConnectEvent.Reason reason)
173      {
174          connect( target, null, false, reason );
175      }
176      @Override
177      public void connect(ServerInfo target, Callback<Boolean> callback)
178      {
179          connect( target, callback, false, ServerConnectEvent.Reason.PLUGIN );
180      }
181      @Override
182      public void connect(ServerInfo target, Callback<Boolean> callback, ServerConnectEvent.Reason reason)
183      {
184          connect( target, callback, false, reason );
185      }
186      @Deprecated
187      public void connectNow(ServerInfo target)
188      {
189          connectNow( target, ServerConnectEvent.Reason.UNKNOWN );
190      }
191      public void connectNow(ServerInfo target, ServerConnectEvent.Reason reason)
192      {
193          dimensionChange = true;
194          connect( target, reason );
195      }
196      public ServerInfo updateAndGetNextServer(ServerInfo currentTarget)
197      {
198          if ( serverJoinQueue == null )
199          {
200              serverJoinQueue = new LinkedList<>( getPendingConnection().getListener().getServerPriority() );
201          }
202          ServerInfo next = null;
203          while ( !serverJoinQueue.isEmpty() )
204          {
205              ServerInfo candidate = ProxyServer.getInstance().getServerInfo( serverJoinQueue.remove() );
206              if ( !Objects.equals( currentTarget, candidate ) )
207              {
208                  next = candidate;
209                  break;
210              }
211          }
212          return next;
213      }
214      public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry)
215      {
216          connect( info, callback, retry, ServerConnectEvent.Reason.PLUGIN );
217      }
218      public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, ServerConnectEvent.Reason reason)
219      {
220          Preconditions.checkNotNull( info, "info" );
221          ServerConnectRequest.Builder builder = ServerConnectRequest.builder().retry( retry ).reason( reason ).target( info );
222          if ( callback != null )
223          {
224              builder.callback( new Callback<ServerConnectRequest.Result>()
225              {
226                  @Override
227                  public void done(ServerConnectRequest.Result result, Throwable error)
228                  {
229                      callback.done( ( result == ServerConnectRequest.Result.SUCCESS ) ? Boolean.TRUE : Boolean.FALSE, error );
230                  }
231              } );
232          }
233          connect( builder.build() );
234      }
235      @Override
236      public void connect(final ServerConnectRequest request)
237      {
238          Preconditions.checkNotNull( request, "request" );
239          final Callback<ServerConnectRequest.Result> callback = request.getCallback();
240          ServerConnectEvent event = new ServerConnectEvent( this, request.getTarget(), request.getReason(), request );
241          if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
242          {
243              if ( callback != null )
244              {
245                  callback.done( ServerConnectRequest.Result.EVENT_CANCEL, null );
246              }
247              if ( getServer() == null && !ch.isClosing() )
248              {
249                  throw new IllegalStateException( "Cancelled ServerConnectEvent with no server or disconnect." );
250              }
251              return;
252          }
253          final BungeeServerInfo target = (BungeeServerInfo) event.getTarget(); 
254          if ( getServer() != null && Objects.equals( getServer().getInfo(), target ) )
255          {
256              if ( callback != null )
257              {
258                  callback.done( ServerConnectRequest.Result.ALREADY_CONNECTED, null );
259              }
260              sendMessage( bungee.getTranslation( "already_connected" ) );
261              return;
262          }
263          if ( pendingConnects.contains( target ) )
264          {
265              if ( callback != null )
266              {
267                  callback.done( ServerConnectRequest.Result.ALREADY_CONNECTING, null );
268              }
269              sendMessage( bungee.getTranslation( "already_connecting" ) );
270              return;
271          }
272          pendingConnects.add( target );
273          ChannelInitializer initializer = new ChannelInitializer()
274          {
275              @Override
276              protected void initChannel(Channel ch) throws Exception
277              {
278                  PipelineUtils.BASE_SERVERSIDE.initChannel( ch );
279                  ch.pipeline().addAfter( PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
280                  ch.pipeline().addAfter( PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
281                  ch.pipeline().get( HandlerBoss.class ).setHandler( new ServerConnector( bungee, UserConnection.this, target ) );
282              }
283          };
284          ChannelFutureListener listener = new ChannelFutureListener()
285          {
286              @Override
287              @SuppressWarnings("ThrowableResultIgnored")
288              public void operationComplete(ChannelFuture future) throws Exception
289              {
290                  if ( callback != null )
291                  {
292                      callback.done( ( future.isSuccess() ) ? ServerConnectRequest.Result.SUCCESS : ServerConnectRequest.Result.FAIL, future.cause() );
293                  }
294                  if ( !future.isSuccess() )
295                  {
296                      future.channel().close();
297                      pendingConnects.remove( target );
298                      ServerInfo def = updateAndGetNextServer( target );
299                      if ( request.isRetry() && def != null && ( getServer() == null || def != getServer().getInfo() ) )
300                      {
301                          sendMessage( bungee.getTranslation( "fallback_lobby" ) );
302                          connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK );
303                      } else if ( dimensionChange )
304                      {
305                          disconnect( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
306                      } else
307                      {
308                          sendMessage( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
309                      }
310                  }
311              }
312          };
313          Bootstrap b = new Bootstrap()
314                  .channel( PipelineUtils.getChannel( target.getAddress() ) )
315                  .group( ch.getHandle().eventLoop() )
316                  .handler( initializer )
317                  .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
318                  .remoteAddress( target.getAddress() );
319          if ( getPendingConnection().getListener().isSetLocalAddress() && !PlatformDependent.isWindows() && getPendingConnection().getListener().getSocketAddress() instanceof InetSocketAddress )
320          {
321              b.localAddress( getPendingConnection().getListener().getHost().getHostString(), 0 );
322          }
323          b.connect().addListener( listener );
324      }
325      private String connectionFailMessage(Throwable cause)
326      {
327          return groups.contains( "admin" ) ? Util.exception( cause, false ) : cause.getClass().getName();
328      }
329      @Override
330      public void disconnect(String reason)
331      {
332          disconnect0( TextComponent.fromLegacyText( reason ) );
333      }
334      @Override
335      public void disconnect(BaseComponent... reason)
336      {
337          disconnect0( reason );
338      }
339      @Override
340      public void disconnect(BaseComponent reason)
341      {
342          disconnect0( reason );
343      }
344      public void disconnect0(final BaseComponent... reason)
345      {
346          if ( !ch.isClosing() )
347          {
348              bungee.getLogger().log( Level.INFO, "[{0}] disconnected with: {1}", new Object[]
349              {
350                  getName(), BaseComponent.toLegacyText( reason )
351              } );
352              ch.close( new Kick( ComponentSerializer.toString( reason ) ) );
353              if ( server != null )
354              {
355                  server.setObsolete( true );
356                  server.disconnect( "Quitting" );
357              }
358          }
359      }
360      @Override
361      public void chat(String message)
362      {
363          Preconditions.checkState( server != null, "Not connected to server" );
364          if ( getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_19 )
365          {
366              throw new UnsupportedOperationException( "Cannot spoof chat on this client version!" );
367          }
368          server.getCh().write( new Chat( message ) );
369      }
370      @Override
371      public void sendMessage(String message)
372      {
373          sendMessage( TextComponent.fromLegacyText( message ) );
374      }
375      @Override
<span onclick='openModal()' class='match'>376      public void sendMessages(String... messages)
377      {
378          for ( String message : messages )
379          {
380              sendMessage( message );
</span>381          }
382      }
383      @Override
384      public void sendMessage(BaseComponent... message)
385      {
386          sendMessage( ChatMessageType.SYSTEM, message );
387      }
388      @Override
389      public void sendMessage(BaseComponent message)
390      {
391          sendMessage( ChatMessageType.SYSTEM, message );
392      }
393      @Override
394      public void sendMessage(ChatMessageType position, BaseComponent... message)
395      {
396          sendMessage( position, null, message );
397      }
398      @Override
399      public void sendMessage(ChatMessageType position, BaseComponent message)
400      {
401          sendMessage( position, (UUID) null, message );
402      }
403      @Override
404      public void sendMessage(UUID sender, BaseComponent... message)
405      {
406          sendMessage( ChatMessageType.CHAT, sender, message );
407      }
408      @Override
409      public void sendMessage(UUID sender, BaseComponent message)
410      {
411          sendMessage( ChatMessageType.CHAT, sender, message );
412      }
413      private void sendMessage(ChatMessageType position, UUID sender, String message)
414      {
415          if ( getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_19 )
416          {
417              if ( position == ChatMessageType.CHAT )
418              {
419                  position = ChatMessageType.SYSTEM;
420              }
421              unsafe().sendPacket( new SystemChat( message, position.ordinal() ) );
422          } else
423          {
424              unsafe().sendPacket( new Chat( message, (byte) position.ordinal(), sender ) );
425          }
426      }
427      private void sendMessage(ChatMessageType position, UUID sender, BaseComponent... message)
428      {
429          message = ChatComponentTransformer.getInstance().transform( this, true, message );
430          if ( position == ChatMessageType.ACTION_BAR && getPendingConnection().getVersion() < ProtocolConstants.MINECRAFT_1_17 )
431          {
432              if ( getPendingConnection().getVersion() <= ProtocolConstants.MINECRAFT_1_10 )
433              {
434                  sendMessage( position, sender, ComponentSerializer.toString( new TextComponent( BaseComponent.toLegacyText( message ) ) ) );
435              } else
436              {
437                  net.md_5.bungee.protocol.packet.Title title = new net.md_5.bungee.protocol.packet.Title();
438                  title.setAction( net.md_5.bungee.protocol.packet.Title.Action.ACTIONBAR );
439                  title.setText( ComponentSerializer.toString( message ) );
440                  unsafe.sendPacket( title );
441              }
442          } else
443          {
444              sendMessage( position, sender, ComponentSerializer.toString( message ) );
445          }
446      }
447      @Override
448      public void sendData(String channel, byte[] data)
449      {
450          unsafe().sendPacket( new PluginMessage( channel, data, forgeClientHandler.isForgeUser() ) );
451      }
452      @Override
453      public InetSocketAddress getAddress()
454      {
455          return (InetSocketAddress) getSocketAddress();
456      }
457      @Override
458      public SocketAddress getSocketAddress()
459      {
460          return ch.getRemoteAddress();
461      }
462      @Override
463      public Collection<String> getGroups()
464      {
465          return Collections.unmodifiableCollection( groups );
466      }
467      @Override
468      public void addGroups(String... groups)
469      {
470          for ( String group : groups )
471          {
472              this.groups.add( group );
473              for ( String permission : bungee.getConfigurationAdapter().getPermissions( group ) )
474              {
475                  setPermission( permission, true );
476              }
477          }
478      }
479      @Override
480      public void removeGroups(String... groups)
481      {
482          for ( String group : groups )
483          {
484              this.groups.remove( group );
485              for ( String permission : bungee.getConfigurationAdapter().getPermissions( group ) )
486              {
487                  setPermission( permission, false );
488              }
489          }
490      }
491      @Override
492      public boolean hasPermission(String permission)
493      {
494          return bungee.getPluginManager().callEvent( new PermissionCheckEvent( this, permission, permissions.contains( permission ) ) ).hasPermission();
495      }
496      @Override
497      public void setPermission(String permission, boolean value)
498      {
499          if ( value )
500          {
501              permissions.add( permission );
502          } else
503          {
504              permissions.remove( permission );
505          }
506      }
507      @Override
508      public Collection<String> getPermissions()
509      {
510          return Collections.unmodifiableCollection( permissions );
511      }
512      @Override
513      public String toString()
514      {
515          return name;
516      }
517      @Override
518      public Unsafe unsafe()
519      {
520          return unsafe;
521      }
522      @Override
523      public String getUUID()
524      {
525          return getPendingConnection().getUUID();
526      }
527      @Override
528      public UUID getUniqueId()
529      {
530          return getPendingConnection().getUniqueId();
531      }
532      public void setSettings(ClientSettings settings)
533      {
534          this.settings = settings;
535          this.locale = null;
536      }
537      @Override
538      public Locale getLocale()
539      {
540          return ( locale == null && settings != null ) ? locale = Locale.forLanguageTag( settings.getLocale().replace( '_', '-' ) ) : locale;
541      }
542      @Override
543      public byte getViewDistance()
544      {
545          return ( settings != null ) ? settings.getViewDistance() : 10;
546      }
547      @Override
548      public ProxiedPlayer.ChatMode getChatMode()
549      {
550          if ( settings == null )
551          {
552              return ProxiedPlayer.ChatMode.SHOWN;
553          }
554          switch ( settings.getChatFlags() )
555          {
556              default:
557              case 0:
558                  return ProxiedPlayer.ChatMode.SHOWN;
559              case 1:
560                  return ProxiedPlayer.ChatMode.COMMANDS_ONLY;
561              case 2:
562                  return ProxiedPlayer.ChatMode.HIDDEN;
563          }
564      }
565      @Override
566      public boolean hasChatColors()
567      {
568          return settings == null || settings.isChatColours();
569      }
570      @Override
571      public SkinConfiguration getSkinParts()
572      {
573          return ( settings != null ) ? new PlayerSkinConfiguration( settings.getSkinParts() ) : PlayerSkinConfiguration.SKIN_SHOW_ALL;
574      }
575      @Override
576      public ProxiedPlayer.MainHand getMainHand()
577      {
578          return ( settings == null || settings.getMainHand() == 1 ) ? ProxiedPlayer.MainHand.RIGHT : ProxiedPlayer.MainHand.LEFT;
579      }
580      @Override
581      public boolean isForgeUser()
582      {
583          return forgeClientHandler.isForgeUser();
584      }
585      @Override
586      public Map<String, String> getModList()
587      {
588          if ( forgeClientHandler.getClientModList() == null )
589          {
590              return ImmutableMap.of();
591          }
592          return ImmutableMap.copyOf( forgeClientHandler.getClientModList() );
593      }
594      @Override
595      public void setTabHeader(BaseComponent header, BaseComponent footer)
596      {
597          header = ChatComponentTransformer.getInstance().transform( this, true, header )[0];
598          footer = ChatComponentTransformer.getInstance().transform( this, true, footer )[0];
599          unsafe().sendPacket( new PlayerListHeaderFooter(
600                  ComponentSerializer.toString( header ),
601                  ComponentSerializer.toString( footer )
602          ) );
603      }
604      @Override
605      public void setTabHeader(BaseComponent[] header, BaseComponent[] footer)
606      {
607          header = ChatComponentTransformer.getInstance().transform( this, true, header );
608          footer = ChatComponentTransformer.getInstance().transform( this, true, footer );
609          unsafe().sendPacket( new PlayerListHeaderFooter(
610                  ComponentSerializer.toString( header ),
611                  ComponentSerializer.toString( footer )
612          ) );
613      }
614      @Override
615      public void resetTabHeader()
616      {
617          setTabHeader( (BaseComponent) null, null );
618      }
619      @Override
620      public void sendTitle(Title title)
621      {
622          title.send( this );
623      }
624      public String getExtraDataInHandshake()
625      {
626          return this.getPendingConnection().getExtraDataInHandshake();
627      }
628      public void setCompressionThreshold(int compressionThreshold)
629      {
630          if ( !ch.isClosing() && this.compressionThreshold == -1 && compressionThreshold >= 0 )
631          {
632              this.compressionThreshold = compressionThreshold;
633              unsafe.sendPacket( new SetCompression( compressionThreshold ) );
634              ch.setCompressionThreshold( compressionThreshold );
635          }
636      }
637      @Override
638      public boolean isConnected()
639      {
640          return !ch.isClosed();
641      }
642      @Override
643      public Scoreboard getScoreboard()
644      {
645          return serverSentScoreboard;
646      }
647  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-UserConnection.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-UserConnection.java</div>
                </div>
                <div class="column column_space"><pre><code>468      public void addGroups(String... groups)
469      {
470          for ( String group : groups )
471          {
472              this.groups.add( group );
</pre></code></div>
                <div class="column column_space"><pre><code>376      public void sendMessages(String... messages)
377      {
378          for ( String message : messages )
379          {
380              sendMessage( message );
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    