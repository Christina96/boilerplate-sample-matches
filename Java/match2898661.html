<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for SysSchemaInfo.java &amp; IndexMetadata.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for SysSchemaInfo.java &amp; IndexMetadata.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>SysSchemaInfo.java (60.13986%)<th>IndexMetadata.java (4.1586075%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-69)<td><a href="#" name="0">(655-670)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(51-57)<td><a href="#" name="1">(671-682)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(57-61)<td><a href="#" name="2">(688-695)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(22-37)<td><a href="#" name="3">(20-34)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(70-78)<td><a href="#" name="4">(496-504)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(48-50)<td><a href="#" name="5">(723-729)</a><td align="center"><font color="#7f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SysSchemaInfo.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.metadata.sys;
2 import io.crate.metadata.settings.CrateSettings;
3 import io.crate.metadata.table.SchemaInfo;
4 import io.crate.metadata.table.TableInfo;
5 import io.crate.metadata.view.ViewInfo;
6 import org.elasticsearch.cluster.ClusterChangedEvent;
7 import org.elasticsearch.cluster.node.DiscoveryNode;
8 import org.elasticsearch.cluster.service.ClusterService;
9 import org.elasticsearch.common.inject.Inject;
10 import org.elasticsearch.common.inject.Singleton;
11 import java.util.Collections;
12 import java.util.HashMap;
13 import java.util.Map;
14 import</b></font> java.util.function.Supplier;
15 @Singleton
16 public class SysSchemaInfo implements SchemaInfo {
17     public static final String NAME = "sys";
18     private final Map&lt;String, TableInfo&gt; tableInfos;
19 <a name="5"></a>    @Inject
20     public SysSchemaInfo(ClusterService clusterService, CrateSettings crateSettings) {
21         tableInfos = new HashMap&lt;&gt;();
22 <a name="1"></a>        <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>tableInfos.put(SysClusterTableInfo.IDENT.name(), SysClusterTableInfo.of(clusterService, crateSettings));
23         tableInfos.put(SysNodesTableInfo.IDENT.name(), SysNodesTableInfo.create());
24         tableInfos.put(SysShardsTableInfo.IDENT.name(), SysShardsTableInfo.create</b></font>());
25         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Supplier&lt;DiscoveryNode&gt; localNode = clusterService::localNode;
26         tableInfos.put(SysJobsTableInfo.IDENT.name(), SysJobsTableInfo.create(localNode));
27         tableInfos.put(SysJobsLogTableInfo.IDENT.name(), SysJobsLogTableInfo.create(localNode));
28 <a name="2"></a>        tableInfos.put(SysOperationsTableInfo.IDENT.name(), SysOperationsTableInfo.create(localNode));
29         tableInfos.put(SysOperationsLogTableInfo.IDENT.name(), SysOperationsLogTableInfo.create());
30         tableInfos.put(SysChecksTableInfo.IDENT.name(), SysChecksTableInfo.create());
31         tableInfos.put</b></font>(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SysNodeChecksTableInfo.IDENT.name(), SysNodeChecksTableInfo.create());
32         tableInfos.put(SysRepositoriesTableInfo.IDENT.name(), SysRepositoriesTableInfo.create(clusterService.getClusterSettings().maskedSettings()));
33 <a name="0"></a>        tableInfos.put(SysSnapshotsTableInfo.IDENT.name(), SysSnapshotsTableInfo.create());
34         tableInfos.put(SysSnapshotRestoreTableInfo.IDENT.name(), SysSnapshotRestoreTableInfo.create());
35         tableInfos.put(SysSummitsTableInfo.IDENT.name(), SysSummitsTableInfo.create</b></font>());
36         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>tableInfos.put(SysAllocationsTableInfo.IDENT.name(), SysAllocationsTableInfo.create());
37         tableInfos.put(SysHealth.IDENT.name(), SysHealth.create());
38         tableInfos.put(SysMetricsTableInfo.NAME.name(), SysMetricsTableInfo.create(localNode));
39         tableInfos.put(SysSegmentsTableInfo.IDENT.name(), SysSegmentsTableInfo.create(clusterService::localNode));
40     }
41 <a name="4"></a>
42     @Override
43     public TableInfo getTableInfo(String name) {</b></font>
44         <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return tableInfos.get(name);
45     }
46     @Override
47     public String name() {
48         return NAME;
49     }
50     @</b></font>Override
51     public void invalidateTableCache(String tableName) {
52     }
53     @Override
54     public Iterable&lt;TableInfo&gt; getTables() {
55         return tableInfos.values();
56     }
57     @Override
58     public Iterable&lt;ViewInfo&gt; getViews() {
59         return Collections.emptyList();
60     }
61     @Override
62     public void close() throws Exception {
63     }
64     @Override
65     public void update(ClusterChangedEvent event) {
66     }
67     public void registerSysTable(TableInfo tableInfo) {
68         assert tableInfo.ident().schema().equals("sys") : "table is not in sys schema";
69         assert !tableInfos.containsKey(tableInfo.ident().name()) : "table already exists";
70         tableInfos.put(tableInfo.ident().name(), tableInfo);
71     }
72 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IndexMetadata.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.cluster.metadata;
2 import com.carrotsearch.hppc.LongArrayList;
3 import com.carrotsearch.hppc.cursors.IntObjectCursor;
4 import com.carrotsearch.hppc.cursors.ObjectCursor;
5 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
6 import io.crate.common.collections.MapBuilder;
7 import io.crate.types.DataTypes;
8 import org.elasticsearch.Assertions;
9 import org.elasticsearch.Version;
10 import org.elasticsearch.action.support.ActiveShardCount;
11 import org.elasticsearch.cluster.Diff;
12 import org.elasticsearch.cluster.Diffable;
13 import org.elasticsearch.cluster.DiffableUtils;
14 import</b></font> org.elasticsearch.cluster.block.ClusterBlock;
15 import org.elasticsearch.cluster.block.ClusterBlockLevel;
16 import org.elasticsearch.cluster.node.DiscoveryNodeFilters;
17 import org.elasticsearch.cluster.routing.allocation.IndexMetadataUpdater;
18 import org.elasticsearch.common.bytes.BytesArray;
19 import org.elasticsearch.common.collect.ImmutableOpenIntMap;
20 import org.elasticsearch.common.collect.ImmutableOpenMap;
21 import org.elasticsearch.common.compress.CompressedXContent;
22 import org.elasticsearch.common.io.stream.StreamInput;
23 import org.elasticsearch.common.io.stream.StreamOutput;
24 import org.elasticsearch.common.settings.Setting;
25 import org.elasticsearch.common.settings.Setting.Property;
26 import org.elasticsearch.common.settings.Settings;
27 import org.elasticsearch.common.xcontent.ToXContent;
28 import org.elasticsearch.common.xcontent.ToXContentFragment;
29 import org.elasticsearch.common.xcontent.XContentBuilder;
30 import org.elasticsearch.common.xcontent.XContentFactory;
31 import org.elasticsearch.common.xcontent.XContentHelper;
32 import org.elasticsearch.common.xcontent.XContentParser;
33 import org.elasticsearch.gateway.MetadataStateFormat;
34 import org.elasticsearch.index.Index;
35 import org.elasticsearch.index.shard.ShardId;
36 import org.elasticsearch.rest.RestStatus;
37 import javax.annotation.Nullable;
38 import java.io.IOException;
39 import java.time.Instant;
40 import java.time.ZoneOffset;
41 import java.time.ZonedDateTime;
42 import java.util.Arrays;
43 import java.util.Collections;
44 import java.util.EnumSet;
45 import java.util.HashSet;
46 import java.util.Iterator;
47 import java.util.List;
48 import java.util.Locale;
49 import java.util.Map;
50 import java.util.Set;
51 import java.util.function.Function;
52 import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.IP_VALIDATOR;
53 import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.OpType.AND;
54 import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.OpType.OR;
55 import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;
56 import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;
57 public class IndexMetadata implements Diffable&lt;IndexMetadata&gt;, ToXContentFragment {
58     public static final ClusterBlock INDEX_CLOSED_BLOCK = new ClusterBlock(4, "index closed", false, false, false, RestStatus.FORBIDDEN, ClusterBlockLevel.READ_WRITE);
59     public static final ClusterBlock INDEX_READ_ONLY_BLOCK = new ClusterBlock(5, "index read-only (api)", false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA_WRITE));
60     public static final ClusterBlock INDEX_READ_BLOCK = new ClusterBlock(7, "index read (api)", false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.READ));
61     public static final ClusterBlock INDEX_WRITE_BLOCK = new ClusterBlock(8, "index write (api)", false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.WRITE));
62     public static final ClusterBlock INDEX_METADATA_BLOCK = new ClusterBlock(9, "index metadata (api)", false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.METADATA_WRITE, ClusterBlockLevel.METADATA_READ));
63     public static final ClusterBlock INDEX_READ_ONLY_ALLOW_DELETE_BLOCK = new ClusterBlock(12, "index read-only / allow delete (api)", false, false, true, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.METADATA_WRITE, ClusterBlockLevel.WRITE));
64     public enum State {
65         OPEN((byte) 0),
66         CLOSE((byte) 1);
67         private final byte id;
68         State(byte id) {
69             this.id = id;
70         }
71         public byte id() {
72             return this.id;
73         }
74         public static State fromId(byte id) {
75             if (id == 0) {
76                 return OPEN;
77             } else if (id == 1) {
78                 return CLOSE;
79             }
80             throw new IllegalStateException("No state match for id [" + id + "]");
81         }
82         public static State fromString(String state) {
83             if ("open".equals(state)) {
84                 return OPEN;
85             } else if ("close".equals(state)) {
86                 return CLOSE;
87             }
88             throw new IllegalStateException("No state match for [" + state + "]");
89         }
90     }
91     static Setting&lt;Integer&gt; buildNumberOfShardsSetting() {
92         final int maxNumShards = Integer.parseInt(System.getProperty("es.index.max_number_of_shards", "1024"));
93         if (maxNumShards &lt; 1) {
94             throw new IllegalArgumentException("es.index.max_number_of_shards must be &gt; 0");
95         }
96         return Setting.intSetting(SETTING_NUMBER_OF_SHARDS, Math.min(5, maxNumShards), 1, maxNumShards,
97             Property.IndexScope, Property.Final);
98     }
99     public static final String INDEX_SETTING_PREFIX = "index.";
100     public static final String SETTING_NUMBER_OF_SHARDS = "index.number_of_shards";
101     public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_SHARDS_SETTING = buildNumberOfShardsSetting();
102     public static final String SETTING_NUMBER_OF_REPLICAS = "index.number_of_replicas";
103     public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_REPLICAS_SETTING =
104         Setting.intSetting(SETTING_NUMBER_OF_REPLICAS, 1, 0, Property.Dynamic, Property.IndexScope);
105     public static final String SETTING_ROUTING_PARTITION_SIZE = "index.routing_partition_size";
106     public static final Setting&lt;Integer&gt; INDEX_ROUTING_PARTITION_SIZE_SETTING =
107             Setting.intSetting(SETTING_ROUTING_PARTITION_SIZE, 1, 1, Property.IndexScope);
108     public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_ROUTING_SHARDS_SETTING =
109         Setting.intSetting(
110             "index.number_of_routing_shards",
111             INDEX_NUMBER_OF_SHARDS_SETTING,
112             1,
113             new Setting.Validator&lt;Integer&gt;() {
114                 @Override
115                 public void validate(final Integer value) {
116                 }
117                 @Override
118                 public void validate(Integer numRoutingShards, Map&lt;Setting&lt;?&gt;, Object&gt; settings) {
119                     int numShards = (int) settings.get(INDEX_NUMBER_OF_SHARDS_SETTING);
120                     if (numRoutingShards &lt; numShards) {
121                         throw new IllegalArgumentException("index.number_of_routing_shards [" + numRoutingShards
122                                                            + "] must be &gt;= index.number_of_shards [" + numShards + "]");
123                     }
124                     getRoutingFactor(numShards, numRoutingShards);
125                 }
126                 @Override
127                 public Iterator&lt;Setting&lt;?&gt;&gt; settings() {
128                     final List&lt;Setting&lt;?&gt;&gt; settings = Collections.singletonList(INDEX_NUMBER_OF_SHARDS_SETTING);
129                     return settings.iterator();
130                 }
131             },
132             Property.IndexScope);
133     public static final String SETTING_AUTO_EXPAND_REPLICAS = "index.auto_expand_replicas";
134     public static final Setting&lt;AutoExpandReplicas&gt; INDEX_AUTO_EXPAND_REPLICAS_SETTING = AutoExpandReplicas.SETTING;
135     public static final String SETTING_READ_ONLY = "index.blocks.read_only";
136     public static final Setting&lt;Boolean&gt; INDEX_READ_ONLY_SETTING =
137         Setting.boolSetting(SETTING_READ_ONLY, false, Property.Dynamic, Property.IndexScope);
138     public static final String SETTING_BLOCKS_READ = "index.blocks.read";
139     public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_READ_SETTING =
140         Setting.boolSetting(SETTING_BLOCKS_READ, false, Property.Dynamic, Property.IndexScope);
141     public static final String SETTING_BLOCKS_WRITE = "index.blocks.write";
142     public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_WRITE_SETTING =
143         Setting.boolSetting(SETTING_BLOCKS_WRITE, false, Property.Dynamic, Property.IndexScope);
144     public static final String SETTING_BLOCKS_METADATA = "index.blocks.metadata";
145     public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_METADATA_SETTING =
146         Setting.boolSetting(SETTING_BLOCKS_METADATA, false, Property.Dynamic, Property.IndexScope);
147     public static final String SETTING_READ_ONLY_ALLOW_DELETE = "index.blocks.read_only_allow_delete";
148     public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING =
149         Setting.boolSetting(SETTING_READ_ONLY_ALLOW_DELETE, false, Property.Dynamic, Property.IndexScope);
150     public static final String SETTING_VERSION_CREATED = "index.version.created";
151     public static final Setting&lt;Version&gt; SETTING_INDEX_VERSION_CREATED =
152             Setting.versionSetting(SETTING_VERSION_CREATED, Version.V_EMPTY, Property.IndexScope, Property.PrivateIndex);
153     public static final String SETTING_VERSION_CREATED_STRING = "index.version.created_string";
154     public static final String SETTING_VERSION_UPGRADED = "index.version.upgraded";
155     public static final String SETTING_VERSION_UPGRADED_STRING = "index.version.upgraded_string";
156     public static final String SETTING_CREATION_DATE = "index.creation_date";
157     public static final String SETTING_INDEX_PROVIDED_NAME = "index.provided_name";
158     public static final String SETTING_PRIORITY = "index.priority";
159     public static final Setting&lt;Integer&gt; INDEX_PRIORITY_SETTING =
160         Setting.intSetting("index.priority", 1, 0, Property.Dynamic, Property.IndexScope);
161     public static final String SETTING_CREATION_DATE_STRING = "index.creation_date_string";
162     public static final String SETTING_INDEX_UUID = "index.uuid";
163     public static final String SETTING_DATA_PATH = "index.data_path";
164     public static final Setting&lt;String&gt; INDEX_DATA_PATH_SETTING =
165         new Setting&lt;&gt;(SETTING_DATA_PATH, "", Function.identity(), DataTypes.STRING, Property.IndexScope);
166     public static final String INDEX_UUID_NA_VALUE = "_na_";
167     public static final String INDEX_ROUTING_REQUIRE_GROUP_PREFIX = "index.routing.allocation.require";
168     public static final String INDEX_ROUTING_INCLUDE_GROUP_PREFIX = "index.routing.allocation.include";
169     public static final String INDEX_ROUTING_EXCLUDE_GROUP_PREFIX = "index.routing.allocation.exclude";
170     public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_REQUIRE_GROUP_SETTING =
171         Setting.prefixKeySetting(INDEX_ROUTING_REQUIRE_GROUP_PREFIX + ".", key -&gt;
172             Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));
173     public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_INCLUDE_GROUP_SETTING =
174         Setting.prefixKeySetting(INDEX_ROUTING_INCLUDE_GROUP_PREFIX + ".", key -&gt;
175             Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));
176     public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_EXCLUDE_GROUP_SETTING =
177         Setting.prefixKeySetting(INDEX_ROUTING_EXCLUDE_GROUP_PREFIX + ".", key -&gt;
178             Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));
179     public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING =
180         Setting.prefixKeySetting("index.routing.allocation.initial_recovery.", key -&gt; Setting.simpleString(key));
181     public static final Setting&lt;ActiveShardCount&gt; SETTING_WAIT_FOR_ACTIVE_SHARDS =
182         new Setting&lt;&gt;("index.write.wait_for_active_shards",
183                       "1",
184                       ActiveShardCount::parseString,
185                       DataTypes.STRING,
186                       Setting.Property.Dynamic,
187                       Setting.Property.IndexScope);
188     private static final String INDEX_FORMAT = "index.format";
189     public static final Setting&lt;Integer&gt; INDEX_FORMAT_SETTING =
190             Setting.intSetting(INDEX_FORMAT, 0, Setting.Property.IndexScope, Setting.Property.Final);
191     public static final Setting&lt;Boolean&gt; VERIFIED_BEFORE_CLOSE_SETTING =
192         Setting.boolSetting("index.verified_before_close", false, Setting.Property.IndexScope, Setting.Property.PrivateIndex);
193     public static final String KEY_IN_SYNC_ALLOCATIONS = "in_sync_allocations";
194     static final String KEY_VERSION = "version";
195     static final String KEY_MAPPING_VERSION = "mapping_version";
196     static final String KEY_SETTINGS_VERSION = "settings_version";
197     static final String KEY_ROUTING_NUM_SHARDS = "routing_num_shards";
198     static final String KEY_SETTINGS = "settings";
199     static final String KEY_STATE = "state";
200     static final String KEY_MAPPINGS = "mappings";
201     static final String KEY_ALIASES = "aliases";
202     public static final String KEY_PRIMARY_TERMS = "primary_terms";
203     public static final String INDEX_STATE_FILE_PREFIX = "state-";
204     private final int routingNumShards;
205     private final int routingFactor;
206     private final int routingPartitionSize;
207     private final int numberOfShards;
208     private final int numberOfReplicas;
209     private final Index index;
210     private final long version;
211     private final long mappingVersion;
212     private final long settingsVersion;
213     private final long[] primaryTerms;
214     private final State state;
215     private final ImmutableOpenMap&lt;String, AliasMetadata&gt; aliases;
216     private final Settings settings;
217     private final ImmutableOpenMap&lt;String, MappingMetadata&gt; mappings;
218     private final ImmutableOpenMap&lt;String, DiffableStringMap&gt; customData;
219     private final ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; inSyncAllocationIds;
220     private final transient int totalNumberOfShards;
221     private final DiscoveryNodeFilters requireFilters;
222     private final DiscoveryNodeFilters includeFilters;
223     private final DiscoveryNodeFilters excludeFilters;
224     private final DiscoveryNodeFilters initialRecoveryFilters;
225     private final Version indexCreatedVersion;
226     private final Version indexUpgradedVersion;
227     private final ActiveShardCount waitForActiveShards;
228     private IndexMetadata(Index index, long version, long mappingVersion, long settingsVersion, long[] primaryTerms, State state, int numberOfShards, int numberOfReplicas, Settings settings,
229                           ImmutableOpenMap&lt;String, MappingMetadata&gt; mappings, ImmutableOpenMap&lt;String, AliasMetadata&gt; aliases,
230                           ImmutableOpenMap&lt;String, DiffableStringMap&gt; customData, ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; inSyncAllocationIds,
231                           DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters initialRecoveryFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,
232                           Version indexCreatedVersion, Version indexUpgradedVersion,
233                           int routingNumShards, int routingPartitionSize, ActiveShardCount waitForActiveShards) {
234         this.index = index;
235         this.version = version;
236         assert mappingVersion &gt;= 0 : mappingVersion;
237         this.mappingVersion = mappingVersion;
238         assert settingsVersion &gt;= 0 : settingsVersion;
239         this.settingsVersion = settingsVersion;
240         this.primaryTerms = primaryTerms;
241         assert primaryTerms.length == numberOfShards;
242         this.state = state;
243         this.numberOfShards = numberOfShards;
244         this.numberOfReplicas = numberOfReplicas;
245         this.totalNumberOfShards = numberOfShards * (numberOfReplicas + 1);
246         this.settings = settings;
247         this.mappings = mappings;
248         this.customData = customData;
249         this.aliases = aliases;
250         this.inSyncAllocationIds = inSyncAllocationIds;
251         this.requireFilters = requireFilters;
252         this.includeFilters = includeFilters;
253         this.excludeFilters = excludeFilters;
254         this.initialRecoveryFilters = initialRecoveryFilters;
255         this.indexCreatedVersion = indexCreatedVersion;
256         this.indexUpgradedVersion = indexUpgradedVersion;
257         this.routingNumShards = routingNumShards;
258         this.routingFactor = routingNumShards / numberOfShards;
259         this.routingPartitionSize = routingPartitionSize;
260         this.waitForActiveShards = waitForActiveShards;
261         assert numberOfShards * routingFactor == routingNumShards : routingNumShards + " must be a multiple of " + numberOfShards;
262     }
263     public Index getIndex() {
264         return index;
265     }
266     public String getIndexUUID() {
267         return index.getUUID();
268     }
269     public boolean isSameUUID(String otherUUID) {
270         assert otherUUID != null;
271         assert getIndexUUID() != null;
272         if (INDEX_UUID_NA_VALUE.equals(otherUUID) || INDEX_UUID_NA_VALUE.equals(getIndexUUID())) {
273             return true;
274         }
275         return otherUUID.equals(getIndexUUID());
276     }
277     public long getVersion() {
278         return this.version;
279     }
280     public long getMappingVersion() {
281         return mappingVersion;
282     }
283     public long getSettingsVersion() {
284         return settingsVersion;
285     }
286     public long primaryTerm(int shardId) {
287         return this.primaryTerms[shardId];
288     }
289     public Version getCreationVersion() {
290         return indexCreatedVersion;
291     }
292     public Version getUpgradedVersion() {
293         return indexUpgradedVersion;
294     }
295     public long getCreationDate() {
296         return settings.getAsLong(SETTING_CREATION_DATE, -1L);
297     }
298     public State getState() {
299         return this.state;
300     }
301     public int getNumberOfShards() {
302         return numberOfShards;
303     }
304     public int getNumberOfReplicas() {
305         return numberOfReplicas;
306     }
307     public int getRoutingPartitionSize() {
308         return routingPartitionSize;
309     }
310     public boolean isRoutingPartitionedIndex() {
311         return routingPartitionSize != 1;
312     }
313     public int getTotalNumberOfShards() {
314         return totalNumberOfShards;
315     }
316     public ActiveShardCount getWaitForActiveShards() {
317         return waitForActiveShards;
318     }
319     public Settings getSettings() {
320         return settings;
321     }
322     public ImmutableOpenMap&lt;String, AliasMetadata&gt; getAliases() {
323         return this.aliases;
324     }
325     @Nullable
326     public MappingMetadata mapping() {
327         for (var cursor : mappings) {
328             return cursor.value;
329         }
330         return null;
331     }
332     public static final String INDEX_SHRINK_SOURCE_UUID_KEY = "index.shrink.source.uuid";
333     public static final String INDEX_SHRINK_SOURCE_NAME_KEY = "index.shrink.source.name";
334     public static final String INDEX_RESIZE_SOURCE_UUID_KEY = "index.resize.source.uuid";
335     public static final String INDEX_RESIZE_SOURCE_NAME_KEY = "index.resize.source.name";
336     public static final Setting&lt;String&gt; INDEX_SHRINK_SOURCE_UUID = Setting.simpleString(INDEX_SHRINK_SOURCE_UUID_KEY);
337     public static final Setting&lt;String&gt; INDEX_SHRINK_SOURCE_NAME = Setting.simpleString(INDEX_SHRINK_SOURCE_NAME_KEY);
338     public static final Setting&lt;String&gt; INDEX_RESIZE_SOURCE_UUID = Setting.simpleString(INDEX_RESIZE_SOURCE_UUID_KEY,
339         INDEX_SHRINK_SOURCE_UUID);
340     public static final Setting&lt;String&gt; INDEX_RESIZE_SOURCE_NAME = Setting.simpleString(INDEX_RESIZE_SOURCE_NAME_KEY,
341         INDEX_SHRINK_SOURCE_NAME);
342     public Index getResizeSourceIndex() {
343         return INDEX_RESIZE_SOURCE_UUID.exists(settings) || INDEX_SHRINK_SOURCE_UUID.exists(settings)
344             ? new Index(INDEX_RESIZE_SOURCE_NAME.get(settings), INDEX_RESIZE_SOURCE_UUID.get(settings)) : null;
345     }
346     ImmutableOpenMap&lt;String, DiffableStringMap&gt; getCustomData() {
347         return this.customData;
348     }
349     public Map&lt;String, String&gt; getCustomData(final String key) {
350         return this.customData.get(key);
351     }
352     public ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; getInSyncAllocationIds() {
353         return inSyncAllocationIds;
354     }
355 <a name="4"></a>
356     public Set&lt;String&gt; inSyncAllocationIds(int shardId) {
357         assert shardId &gt;= 0 &amp;&amp; shardId &lt; numberOfShards;
358         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return inSyncAllocationIds.get(shardId);
359     }
360     @Nullable
361     public DiscoveryNodeFilters requireFilters() {
362         return requireFilters;
363     }
364     @</b></font>Nullable
365     public DiscoveryNodeFilters getInitialRecoveryFilters() {
366         return initialRecoveryFilters;
367     }
368     @Nullable
369     public DiscoveryNodeFilters includeFilters() {
370         return includeFilters;
371     }
372     @Nullable
373     public DiscoveryNodeFilters excludeFilters() {
374         return excludeFilters;
375     }
376     @Override
377     public boolean equals(Object o) {
378         if (this == o) {
379             return true;
380         }
381         if (o == null || getClass() != o.getClass()) {
382             return false;
383         }
384         IndexMetadata that = (IndexMetadata) o;
385         if (version != that.version) {
386             return false;
387         }
388         if (!aliases.equals(that.aliases)) {
389             return false;
390         }
391         if (!index.equals(that.index)) {
392             return false;
393         }
394         if (!mappings.equals(that.mappings)) {
395             return false;
396         }
397         if (!settings.equals(that.settings)) {
398             return false;
399         }
400         if (state != that.state) {
401             return false;
402         }
403         if (!customData.equals(that.customData)) {
404             return false;
405         }
406         if (routingNumShards != that.routingNumShards) {
407             return false;
408         }
409         if (routingFactor != that.routingFactor) {
410             return false;
411         }
412         if (Arrays.equals(primaryTerms, that.primaryTerms) == false) {
413             return false;
414         }
415         if (!inSyncAllocationIds.equals(that.inSyncAllocationIds)) {
416             return false;
417         }
418         return true;
419     }
420     @Override
421     public int hashCode() {
422         int result = index.hashCode();
423         result = 31 * result + Long.hashCode(version);
424         result = 31 * result + state.hashCode();
425         result = 31 * result + aliases.hashCode();
426         result = 31 * result + settings.hashCode();
427         result = 31 * result + mappings.hashCode();
428         result = 31 * result + customData.hashCode();
429         result = 31 * result + Long.hashCode(routingFactor);
430         result = 31 * result + Long.hashCode(routingNumShards);
431         result = 31 * result + Arrays.hashCode(primaryTerms);
432         result = 31 * result + inSyncAllocationIds.hashCode();
433         return result;
434     }
435     @Override
436     public Diff&lt;IndexMetadata&gt; diff(IndexMetadata previousState) {
437         return new IndexMetadataDiff(previousState, this);
438     }
439     public static Diff&lt;IndexMetadata&gt; readDiffFrom(StreamInput in) throws IOException {
440         return new IndexMetadataDiff(in);
441     }
442     public static IndexMetadata fromXContent(XContentParser parser) throws IOException {
443         return Builder.fromXContent(parser);
444     }
445     @Override
446     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
447         Builder.toXContent(this, builder, params);
448         return builder;
449     }
450     private static class IndexMetadataDiff implements Diff&lt;IndexMetadata&gt; {
451         private final String index;
452         private final int routingNumShards;
453         private final long version;
454         private final long mappingVersion;
455         private final long settingsVersion;
456         private final long[] primaryTerms;
457         private final State state;
458         private final Settings settings;
459         private final Diff&lt;ImmutableOpenMap&lt;String, MappingMetadata&gt;&gt; mappings;
460         private final Diff&lt;ImmutableOpenMap&lt;String, AliasMetadata&gt;&gt; aliases;
461         private final Diff&lt;ImmutableOpenMap&lt;String, DiffableStringMap&gt;&gt; customData;
462         private final Diff&lt;ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt;&gt; inSyncAllocationIds;
463         IndexMetadataDiff(IndexMetadata before, IndexMetadata after) {
464             index = after.index.getName();
465             version = after.version;
466             mappingVersion = after.mappingVersion;
467             settingsVersion = after.settingsVersion;
468             routingNumShards = after.routingNumShards;
469             state = after.state;
470             settings = after.settings;
471             primaryTerms = after.primaryTerms;
472             mappings = DiffableUtils.diff(before.mappings, after.mappings, DiffableUtils.getStringKeySerializer());
473             aliases = DiffableUtils.diff(before.aliases, after.aliases, DiffableUtils.getStringKeySerializer());
474             customData = DiffableUtils.diff(before.customData, after.customData, DiffableUtils.getStringKeySerializer());
475             inSyncAllocationIds = DiffableUtils.diff(before.inSyncAllocationIds, after.inSyncAllocationIds,
476                 DiffableUtils.getVIntKeySerializer(), DiffableUtils.StringSetValueSerializer.getInstance());
477         }
478         IndexMetadataDiff(StreamInput in) throws IOException {
479             index = in.readString();
480             routingNumShards = in.readInt();
481             version = in.readLong();
482             mappingVersion = in.readVLong();
483             settingsVersion = in.readVLong();
484             state = State.fromId(in.readByte());
485             settings = Settings.readSettingsFromStream(in);
486             primaryTerms = in.readVLongArray();
487             mappings = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), MappingMetadata::new,
488                                                               MappingMetadata::readDiffFrom);
489             aliases = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), AliasMetadata::new,
490                                                              AliasMetadata::readDiffFrom);
491             customData = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), DiffableStringMap::new,
492                 DiffableStringMap::readDiffFrom);
493             inSyncAllocationIds = DiffableUtils.readImmutableOpenIntMapDiff(in, DiffableUtils.getVIntKeySerializer(),
494                 DiffableUtils.StringSetValueSerializer.getInstance());
495         }
496 <a name="0"></a>
497         @Override
498         public void writeTo(StreamOutput out) throws IOException {
499             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>out.writeString(index);
500             out.writeInt(routingNumShards);
501             out.writeLong(version);
502             out.writeVLong(mappingVersion);
503             out.writeVLong(settingsVersion);
504             out.writeByte(state.id);
505             Settings.writeSettingsToStream(settings, out);
506             out.writeVLongArray(primaryTerms);
507             mappings.writeTo(out);
508             aliases.writeTo(out);
509             customData.writeTo(out);
510             inSyncAllocationIds.writeTo(out);
511         }
512 <a name="1"></a>
513         @Override
514         public IndexMetadata apply(IndexMetadata part) {</b></font>
515             <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Builder builder = builder(index);
516             builder.version(version);
517             builder.mappingVersion(mappingVersion);
518             builder.settingsVersion(settingsVersion);
519             builder.setRoutingNumShards(routingNumShards);
520             builder.state(state);
521             builder.settings(settings);
522             builder.primaryTerms(primaryTerms);
523             builder.mappings.putAll(mappings.apply(part.mappings));
524             builder.aliases.putAll(aliases.apply(part.aliases));
525             builder.customMetadata.putAll(customData.apply(part.customData));
526             builder.inSyncAllocationIds.putAll(inSyncAllocationIds.apply</b></font>(part.inSyncAllocationIds));
527             return builder.build();
528         }
529 <a name="2"></a>    }
530     public static IndexMetadata readFrom(StreamInput in) throws IOException {
531         Builder builder = new Builder(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>in.readString());
532         builder.version(in.readLong());
533         builder.mappingVersion(in.readVLong());
534         builder.settingsVersion(in.readVLong());
535         builder.setRoutingNumShards(in.readInt());
536         builder.state(State.fromId(in.readByte()));
537         builder.settings(readSettingsFromStream(in));
538         builder.primaryTerms(in.readVLongArray</b></font>());
539         int mappingsSize = in.readVInt();
540         for (int i = 0; i &lt; mappingsSize; i++) {
541             MappingMetadata mappingMd = new MappingMetadata(in);
542             builder.putMapping(mappingMd);
543         }
544         int aliasesSize = in.readVInt();
545         for (int i = 0; i &lt; aliasesSize; i++) {
546             AliasMetadata aliasMd = new AliasMetadata(in);
547             builder.putAlias(aliasMd);
548         }
549         int customSize = in.readVInt();
550         for (int i = 0; i &lt; customSize; i++) {
551             String key = in.readString();
552             DiffableStringMap custom = new DiffableStringMap(in);
553             builder.putCustom(key, custom);
554         }
555         int inSyncAllocationIdsSize = in.readVInt();
556         for (int i = 0; i &lt; inSyncAllocationIdsSize; i++) {
557             int key = in.readVInt();
558             Set&lt;String&gt; allocationIds = DiffableUtils.StringSetValueSerializer.getInstance().read(in, key);
559             builder.putInSyncAllocationIds(key, allocationIds);
560         }
561         return builder.build();
562     }
563 <a name="5"></a>
564     @Override
565     public void writeTo(StreamOutput out) throws IOException {
566         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>out.writeString(index.getName());         out.writeLong(version);
567         out.writeVLong(mappingVersion);
568         out.writeVLong(settingsVersion);
569         out.writeInt(routingNumShards);
570         out.writeByte(state.id());
571         writeSettingsToStream</b></font>(settings, out);
572         out.writeVLongArray(primaryTerms);
573         out.writeVInt(mappings.size());
574         for (ObjectCursor&lt;MappingMetadata&gt; cursor : mappings.values()) {
575             cursor.value.writeTo(out);
576         }
577         out.writeVInt(aliases.size());
578         for (ObjectCursor&lt;AliasMetadata&gt; cursor : aliases.values()) {
579             cursor.value.writeTo(out);
580         }
581         out.writeVInt(customData.size());
582         for (final ObjectObjectCursor&lt;String, DiffableStringMap&gt; cursor : customData) {
583             out.writeString(cursor.key);
584             cursor.value.writeTo(out);
585         }
586         out.writeVInt(inSyncAllocationIds.size());
587         for (IntObjectCursor&lt;Set&lt;String&gt;&gt; cursor : inSyncAllocationIds) {
588             out.writeVInt(cursor.key);
589             DiffableUtils.StringSetValueSerializer.getInstance().write(cursor.value, out);
590         }
591     }
592     public static Builder builder(String index) {
593         return new Builder(index);
594     }
595     public static Builder builder(IndexMetadata indexMetadata) {
596         return new Builder(indexMetadata);
597     }
598     public static class Builder {
599         private String index;
600         private State state = State.OPEN;
601         private long version = 1;
602         private long mappingVersion = 1;
603         private long settingsVersion = 1;
604         private long[] primaryTerms = null;
605         private Settings settings = Settings.Builder.EMPTY_SETTINGS;
606         private final ImmutableOpenMap.Builder&lt;String, MappingMetadata&gt; mappings;
607         private final ImmutableOpenMap.Builder&lt;String, AliasMetadata&gt; aliases;
608         private final ImmutableOpenMap.Builder&lt;String, DiffableStringMap&gt; customMetadata;
609         private final ImmutableOpenIntMap.Builder&lt;Set&lt;String&gt;&gt; inSyncAllocationIds;
610         private Integer routingNumShards;
611         public Builder(String index) {
612             this.index = index;
613             this.mappings = ImmutableOpenMap.builder();
614             this.aliases = ImmutableOpenMap.builder();
615             this.customMetadata = ImmutableOpenMap.builder();
616             this.inSyncAllocationIds = ImmutableOpenIntMap.builder();
617         }
618         public Builder(IndexMetadata indexMetadata) {
619             this.index = indexMetadata.getIndex().getName();
620             this.state = indexMetadata.state;
621             this.version = indexMetadata.version;
622             this.mappingVersion = indexMetadata.mappingVersion;
623             this.settingsVersion = indexMetadata.settingsVersion;
624             this.settings = indexMetadata.getSettings();
625             this.primaryTerms = indexMetadata.primaryTerms.clone();
626             this.mappings = ImmutableOpenMap.builder(indexMetadata.mappings);
627             this.aliases = ImmutableOpenMap.builder(indexMetadata.aliases);
628             this.customMetadata = ImmutableOpenMap.builder(indexMetadata.customData);
629             this.routingNumShards = indexMetadata.routingNumShards;
630             this.inSyncAllocationIds = ImmutableOpenIntMap.builder(indexMetadata.inSyncAllocationIds);
631         }
632         public String index() {
633             return index;
634         }
635         public Builder index(String index) {
636             this.index = index;
637             return this;
638         }
639         public Builder numberOfShards(int numberOfShards) {
640             settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_SHARDS, numberOfShards).build();
641             return this;
642         }
643         public Builder setRoutingNumShards(int routingNumShards) {
644             this.routingNumShards = routingNumShards;
645             return this;
646         }
647         public int getRoutingNumShards() {
648             return routingNumShards == null ? numberOfShards() : routingNumShards;
649         }
650         public int numberOfShards() {
651             return settings.getAsInt(SETTING_NUMBER_OF_SHARDS, -1);
652         }
653         public Builder numberOfReplicas(int numberOfReplicas) {
654             settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).build();
655             return this;
656         }
657         public int numberOfReplicas() {
658             return settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, -1);
659         }
660         public Builder routingPartitionSize(int routingPartitionSize) {
661             settings = Settings.builder().put(settings).put(SETTING_ROUTING_PARTITION_SIZE, routingPartitionSize).build();
662             return this;
663         }
664         public int routingPartitionSize() {
665             return settings.getAsInt(SETTING_ROUTING_PARTITION_SIZE, -1);
666         }
667         public Builder creationDate(long creationDate) {
668             settings = Settings.builder().put(settings).put(SETTING_CREATION_DATE, creationDate).build();
669             return this;
670         }
671         public Builder settings(Settings.Builder settings) {
672             return settings(settings.build());
673         }
674         public Builder settings(Settings settings) {
675             this.settings = settings;
676             return this;
677         }
678         public MappingMetadata mapping(String type) {
679             return mappings.get(type);
680         }
681         public Builder putMapping(String type, String source) throws IOException {
682             putMapping(new MappingMetadata(type, XContentHelper.convertToMap(XContentFactory.xContent(source), source, true)));
683             return this;
684         }
685         public Builder putMapping(MappingMetadata mappingMd) {
686             mappings.clear();
687             if (mappingMd != null) {
688                 mappings.put(mappingMd.type(), mappingMd);
689             }
690             return this;
691         }
692         public Builder state(State state) {
693             this.state = state;
694             return this;
695         }
696         public Builder putAlias(AliasMetadata aliasMetadata) {
697             aliases.put(aliasMetadata.alias(), aliasMetadata);
698             return this;
699         }
700         public Builder putAlias(AliasMetadata.Builder aliasMetadata) {
701             aliases.put(aliasMetadata.alias(), aliasMetadata.build());
702             return this;
703         }
704         public Builder removeAlias(String alias) {
705             aliases.remove(alias);
706             return this;
707         }
708         public Builder removeAllAliases() {
709             aliases.clear();
710             return this;
711         }
712         public Builder putCustom(String type, Map&lt;String, String&gt; customIndexMetadata) {
713             this.customMetadata.put(type, new DiffableStringMap(customIndexMetadata));
714             return this;
715         }
716         public Map&lt;String, String&gt; removeCustom(String type) {
717             return this.customMetadata.remove(type);
718         }
719         public Set&lt;String&gt; getInSyncAllocationIds(int shardId) {
720             return inSyncAllocationIds.get(shardId);
721         }
722         public Builder putInSyncAllocationIds(int shardId, Set&lt;String&gt; allocationIds) {
723             inSyncAllocationIds.put(shardId, new HashSet&lt;&gt;(allocationIds));
724             return this;
725         }
726         public long version() {
727             return this.version;
728         }
729         public Builder version(long version) {
730             this.version = version;
731             return this;
732         }
733         public long mappingVersion() {
734             return mappingVersion;
735         }
736         public long settingsVersion() {
737             return settingsVersion;
738         }
739         public Builder mappingVersion(final long mappingVersion) {
740             this.mappingVersion = mappingVersion;
741             return this;
742         }
743         public Builder settingsVersion(final long settingsVersion) {
744             this.settingsVersion = settingsVersion;
745             return this;
746         }
747         public long primaryTerm(int shardId) {
748             if (primaryTerms == null) {
749                 initializePrimaryTerms();
750             }
751             return this.primaryTerms[shardId];
752         }
753         public Builder primaryTerm(int shardId, long primaryTerm) {
754             if (primaryTerms == null) {
755                 initializePrimaryTerms();
756             }
757             this.primaryTerms[shardId] = primaryTerm;
758             return this;
759         }
760         private void primaryTerms(long[] primaryTerms) {
761             this.primaryTerms = primaryTerms.clone();
762         }
763         private void initializePrimaryTerms() {
764             assert primaryTerms == null;
765             if (numberOfShards() &lt; 0) {
766                 throw new IllegalStateException("you must set the number of shards before setting/reading primary terms");
767             }
768             primaryTerms = new long[numberOfShards()];
769         }
770         public IndexMetadata build() {
771             final ImmutableOpenMap.Builder&lt;String, AliasMetadata&gt; tmpAliases = aliases;
772             final Settings tmpSettings = settings;
773             Integer maybeNumberOfShards = settings.getAsInt(SETTING_NUMBER_OF_SHARDS, null);
774             if (maybeNumberOfShards == null) {
775                 throw new IllegalArgumentException("must specify numberOfShards for index [" + index + "]");
776             }
777             int numberOfShards = maybeNumberOfShards;
778             if (numberOfShards &lt;= 0) {
779                 throw new IllegalArgumentException("must specify positive number of shards for index [" + index + "]");
780             }
781             Integer maybeNumberOfReplicas = settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, null);
782             if (maybeNumberOfReplicas == null) {
783                 throw new IllegalArgumentException("must specify numberOfReplicas for index [" + index + "]");
784             }
785             int numberOfReplicas = maybeNumberOfReplicas;
786             if (numberOfReplicas &lt; 0) {
787                 throw new IllegalArgumentException("must specify non-negative number of shards for index [" + index + "]");
788             }
789             int routingPartitionSize = INDEX_ROUTING_PARTITION_SIZE_SETTING.get(settings);
790             if (routingPartitionSize != 1 &amp;&amp; routingPartitionSize &gt;= getRoutingNumShards()) {
791                 throw new IllegalArgumentException("routing partition size [" + routingPartitionSize + "] should be a positive number"
792                         + " less than the number of shards [" + getRoutingNumShards() + "] for [" + index + "]");
793             }
794             ImmutableOpenIntMap.Builder&lt;Set&lt;String&gt;&gt; filledInSyncAllocationIds = ImmutableOpenIntMap.builder();
795             for (int i = 0; i &lt; numberOfShards; i++) {
796                 if (inSyncAllocationIds.containsKey(i)) {
797                     filledInSyncAllocationIds.put(i, Collections.unmodifiableSet(new HashSet&lt;&gt;(inSyncAllocationIds.get(i))));
798                 } else {
799                     filledInSyncAllocationIds.put(i, Collections.emptySet());
800                 }
801             }
802             final Map&lt;String, String&gt; requireMap = INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(settings);
803             final DiscoveryNodeFilters requireFilters;
804             if (requireMap.isEmpty()) {
805                 requireFilters = null;
806             } else {
807                 requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap);
808             }
809             Map&lt;String, String&gt; includeMap = INDEX_ROUTING_INCLUDE_GROUP_SETTING.getAsMap(settings);
810             final DiscoveryNodeFilters includeFilters;
811             if (includeMap.isEmpty()) {
812                 includeFilters = null;
813             } else {
814                 includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap);
815             }
816             Map&lt;String, String&gt; excludeMap = INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getAsMap(settings);
817             final DiscoveryNodeFilters excludeFilters;
818             if (excludeMap.isEmpty()) {
819                 excludeFilters = null;
820             } else {
821                 excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap);
822             }
823             Map&lt;String, String&gt; initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.getAsMap(settings);
824             final DiscoveryNodeFilters initialRecoveryFilters;
825             if (initialRecoveryMap.isEmpty()) {
826                 initialRecoveryFilters = null;
827             } else {
828                 initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap);
829             }
830             Version indexCreatedVersion = Version.indexCreated(settings);
831             Version indexUpgradedVersion = settings.getAsVersion(IndexMetadata.SETTING_VERSION_UPGRADED, indexCreatedVersion);
832             if (primaryTerms == null) {
833                 initializePrimaryTerms();
834             } else if (primaryTerms.length != numberOfShards) {
835                 throw new IllegalStateException("primaryTerms length is [" + primaryTerms.length
836                     + "] but should be equal to number of shards [" + numberOfShards() + "]");
837             }
838             final ActiveShardCount waitForActiveShards = SETTING_WAIT_FOR_ACTIVE_SHARDS.get(settings);
839             if (waitForActiveShards.validate(numberOfReplicas) == false) {
840                 throw new IllegalArgumentException("invalid " + SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey() +
841                                                    "[" + waitForActiveShards + "]: cannot be greater than " +
842                                                    "number of shard copies [" + (numberOfReplicas + 1) + "]");
843             }
844             final String uuid = settings.get(SETTING_INDEX_UUID, INDEX_UUID_NA_VALUE);
845             return new IndexMetadata(
846                 new Index(index, uuid),
847                 version,
848                 mappingVersion,
849                 settingsVersion,
850                 primaryTerms,
851                 state,
852                 numberOfShards,
853                 numberOfReplicas,
854                 tmpSettings,
855                 mappings.build(),
856                 tmpAliases.build(),
857                 customMetadata.build(),
858                 filledInSyncAllocationIds.build(),
859                 requireFilters,
860                 initialRecoveryFilters,
861                 includeFilters,
862                 excludeFilters,
863                 indexCreatedVersion,
864                 indexUpgradedVersion,
865                 getRoutingNumShards(),
866                 routingPartitionSize,
867                 waitForActiveShards
868             );
869         }
870         public static void toXContent(IndexMetadata indexMetadata, XContentBuilder builder, ToXContent.Params params) throws IOException {
871             builder.startObject(indexMetadata.getIndex().getName());
872             builder.field(KEY_VERSION, indexMetadata.getVersion());
873             builder.field(KEY_MAPPING_VERSION, indexMetadata.getMappingVersion());
874             builder.field(KEY_SETTINGS_VERSION, indexMetadata.getSettingsVersion());
875             builder.field(KEY_ROUTING_NUM_SHARDS, indexMetadata.getRoutingNumShards());
876             builder.field(KEY_STATE, indexMetadata.getState().toString().toLowerCase(Locale.ENGLISH));
877             boolean binary = params.paramAsBoolean("binary", false);
878             builder.startObject(KEY_SETTINGS);
879             indexMetadata.getSettings().toXContent(builder, new MapParams(Collections.singletonMap("flat_settings", "true")));
880             builder.endObject();
881             builder.startArray(KEY_MAPPINGS);
882             MappingMetadata mmd = indexMetadata.mapping();
883             if (mmd != null) {
884                 if (binary) {
885                     builder.value(mmd.source().compressed());
886                 } else {
887                     builder.map(XContentHelper.convertToMap(new BytesArray(mmd.source().uncompressed()), true).v2());
888                 }
889             }
890             builder.endArray();
891             for (ObjectObjectCursor&lt;String, DiffableStringMap&gt; cursor : indexMetadata.customData) {
892                 builder.field(cursor.key);
893                 builder.map(cursor.value);
894             }
895             builder.startObject(KEY_ALIASES);
896             for (ObjectCursor&lt;AliasMetadata&gt; cursor : indexMetadata.getAliases().values()) {
897                 AliasMetadata.Builder.toXContent(cursor.value, builder, params);
898             }
899             builder.endObject();
900             builder.startArray(KEY_PRIMARY_TERMS);
901             for (int i = 0; i &lt; indexMetadata.getNumberOfShards(); i++) {
902                 builder.value(indexMetadata.primaryTerm(i));
903             }
904             builder.endArray();
905             builder.startObject(KEY_IN_SYNC_ALLOCATIONS);
906             for (IntObjectCursor&lt;Set&lt;String&gt;&gt; cursor : indexMetadata.inSyncAllocationIds) {
907                 builder.startArray(String.valueOf(cursor.key));
908                 for (String allocationId : cursor.value) {
909                     builder.value(allocationId);
910                 }
911                 builder.endArray();
912             }
913             builder.endObject();
914             builder.endObject();
915         }
916         public static IndexMetadata fromXContent(XContentParser parser) throws IOException {
917             if (parser.currentToken() == null) {                 parser.nextToken();
918             }
919             if (parser.currentToken() == XContentParser.Token.START_OBJECT) {                  parser.nextToken();
920             }
921             if (parser.currentToken() != XContentParser.Token.FIELD_NAME) {
922                 throw new IllegalArgumentException("expected field name but got a " + parser.currentToken());
923             }
924             Builder builder = new Builder(parser.currentName());
925             String currentFieldName = null;
926             XContentParser.Token token = parser.nextToken();
927             if (token != XContentParser.Token.START_OBJECT) {
928                 throw new IllegalArgumentException("expected object but got a " + token);
929             }
930             boolean mappingVersion = false;
931             boolean settingsVersion = false;
932             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
933                 if (token == XContentParser.Token.FIELD_NAME) {
934                     currentFieldName = parser.currentName();
935                 } else if (token == XContentParser.Token.START_OBJECT) {
936                     if (KEY_SETTINGS.equals(currentFieldName)) {
937                         builder.settings(Settings.fromXContent(parser));
938                     } else if (KEY_MAPPINGS.equals(currentFieldName)) {
939                         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
940                             if (token == XContentParser.Token.FIELD_NAME) {
941                                 currentFieldName = parser.currentName();
942                             } else if (token == XContentParser.Token.START_OBJECT) {
943                                 String mappingType = currentFieldName;
944                                 Map&lt;String, Object&gt; mappingSource = MapBuilder.&lt;String, Object&gt;newMapBuilder().put(mappingType, parser.mapOrdered()).map();
945                                 builder.putMapping(new MappingMetadata(mappingType, mappingSource));
946                             } else {
947                                 throw new IllegalArgumentException("Unexpected token: " + token);
948                             }
949                         }
950                     } else if (KEY_ALIASES.equals(currentFieldName)) {
951                         while (parser.nextToken() != XContentParser.Token.END_OBJECT) {
952                             builder.putAlias(AliasMetadata.Builder.fromXContent(parser));
953                         }
954                     } else if (KEY_IN_SYNC_ALLOCATIONS.equals(currentFieldName)) {
955                         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
956                             if (token == XContentParser.Token.FIELD_NAME) {
957                                 currentFieldName = parser.currentName();
958                             } else if (token == XContentParser.Token.START_ARRAY) {
959                                 String shardId = currentFieldName;
960                                 Set&lt;String&gt; allocationIds = new HashSet&lt;&gt;();
961                                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
962                                     if (token == XContentParser.Token.VALUE_STRING) {
963                                         allocationIds.add(parser.text());
964                                     }
965                                 }
966                                 builder.putInSyncAllocationIds(Integer.valueOf(shardId), allocationIds);
967                             } else {
968                                 throw new IllegalArgumentException("Unexpected token: " + token);
969                             }
970                         }
971                     } else if ("warmers".equals(currentFieldName)) {
972                         assert Version.CURRENT.major &lt;= 5;
973                         parser.skipChildren();
974                     } else {
975                         builder.putCustom(currentFieldName, parser.mapStrings());
976                     }
977                 } else if (token == XContentParser.Token.START_ARRAY) {
978                     if (KEY_MAPPINGS.equals(currentFieldName)) {
979                         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
980                             if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {
981                                 builder.putMapping(new MappingMetadata(new CompressedXContent(parser.binaryValue())));
982                             } else {
983                                 Map&lt;String, Object&gt; mapping = parser.mapOrdered();
984                                 if (mapping.size() == 1) {
985                                     String mappingType = mapping.keySet().iterator().next();
986                                     builder.putMapping(new MappingMetadata(mappingType, mapping));
987                                 }
988                             }
989                         }
990                     } else if (KEY_PRIMARY_TERMS.equals(currentFieldName)) {
991                         LongArrayList list = new LongArrayList();
992                         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
993                             if (token == XContentParser.Token.VALUE_NUMBER) {
994                                 list.add(parser.longValue());
995                             } else {
996                                 throw new IllegalStateException("found a non-numeric value under [" + KEY_PRIMARY_TERMS + "]");
997                             }
998                         }
999                         builder.primaryTerms(list.toArray());
1000                     } else {
1001                         throw new IllegalArgumentException("Unexpected field for an array " + currentFieldName);
1002                     }
1003                 } else if (token.isValue()) {
1004                     if (KEY_STATE.equals(currentFieldName)) {
1005                         builder.state(State.fromString(parser.text()));
1006                     } else if (KEY_VERSION.equals(currentFieldName)) {
1007                         builder.version(parser.longValue());
1008                     } else if (KEY_MAPPING_VERSION.equals(currentFieldName)) {
1009                         mappingVersion = true;
1010                         builder.mappingVersion(parser.longValue());
1011                     } else if (KEY_SETTINGS_VERSION.equals(currentFieldName)) {
1012                         settingsVersion = true;
1013                         builder.settingsVersion(parser.longValue());
1014                     } else if (KEY_ROUTING_NUM_SHARDS.equals(currentFieldName)) {
1015                         builder.setRoutingNumShards(parser.intValue());
1016                     } else {
1017                         throw new IllegalArgumentException("Unexpected field [" + currentFieldName + "]");
1018                     }
1019                 } else {
1020                     throw new IllegalArgumentException("Unexpected token " + token);
1021                 }
1022             }
1023             if (Assertions.ENABLED &amp;&amp; Version.indexCreated(builder.settings).onOrAfter(Version.V_3_2_0)) {
1024                 assert mappingVersion : "mapping version should be present for indices created on or after 6.5.0";
1025             }
1026             if (Assertions.ENABLED &amp;&amp; Version.indexCreated(builder.settings).onOrAfter(Version.V_3_2_0)) {
1027                 assert settingsVersion : "settings version should be present for indices created on or after 6.5.0";
1028             }
1029             return builder.build();
1030         }
1031     }
1032     public static Settings addHumanReadableSettings(Settings settings) {
1033         Settings.Builder builder = Settings.builder().put(settings);
1034         Version version = SETTING_INDEX_VERSION_CREATED.get(settings);
1035         if (version != Version.V_EMPTY) {
1036             builder.put(SETTING_VERSION_CREATED_STRING, version.toString());
1037         }
1038         Version versionUpgraded = settings.getAsVersion(SETTING_VERSION_UPGRADED, null);
1039         if (versionUpgraded != null) {
1040             builder.put(SETTING_VERSION_UPGRADED_STRING, versionUpgraded.toString());
1041         }
1042         Long creationDate = settings.getAsLong(SETTING_CREATION_DATE, null);
1043         if (creationDate != null) {
1044             ZonedDateTime creationDateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(creationDate), ZoneOffset.UTC);
1045             builder.put(SETTING_CREATION_DATE_STRING, creationDateTime.toString());
1046         }
1047         return builder.build();
1048     }
1049     private static final ToXContent.Params FORMAT_PARAMS = new MapParams(Collections.singletonMap("binary", "true"));
1050     public static final MetadataStateFormat&lt;IndexMetadata&gt; FORMAT = new MetadataStateFormat&lt;IndexMetadata&gt;(INDEX_STATE_FILE_PREFIX) {
1051         @Override
1052         public void toXContent(XContentBuilder builder, IndexMetadata state) throws IOException {
1053             Builder.toXContent(state, builder, FORMAT_PARAMS);
1054         }
1055         @Override
1056         public IndexMetadata fromXContent(XContentParser parser) throws IOException {
1057             return Builder.fromXContent(parser);
1058         }
1059     };
1060     public int getRoutingNumShards() {
1061         return routingNumShards;
1062     }
1063     public int getRoutingFactor() {
1064         return routingFactor;
1065     }
1066     public static ShardId selectSplitShard(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
1067         if (shardId &gt;= numTargetShards) {
1068             throw new IllegalArgumentException("the number of target shards (" + numTargetShards + ") must be greater than the shard id: "
1069                 + shardId);
1070         }
1071         int numSourceShards = sourceIndexMetadata.getNumberOfShards();
1072         if (numSourceShards &gt; numTargetShards) {
1073             throw new IllegalArgumentException("the number of source shards [" + numSourceShards
1074                  + "] must be less that the number of target shards [" + numTargetShards + "]");
1075         }
1076         int routingFactor = getRoutingFactor(numSourceShards, numTargetShards);
1077         int routingNumShards = sourceIndexMetadata.getRoutingNumShards();
1078         if (routingNumShards % numTargetShards != 0) {
1079             throw new IllegalStateException("the number of routing shards ["
1080                 + routingNumShards + "] must be a multiple of the target shards [" + numTargetShards + "]");
1081         }
1082         assert getRoutingFactor(numTargetShards, sourceIndexMetadata.getRoutingNumShards()) &gt;= 0;
1083         return new ShardId(sourceIndexMetadata.getIndex(), shardId / routingFactor);
1084     }
1085     public static Set&lt;ShardId&gt; selectRecoverFromShards(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
1086         if (sourceIndexMetadata.getNumberOfShards() &gt; numTargetShards) {
1087             return selectShrinkShards(shardId, sourceIndexMetadata, numTargetShards);
1088         } else if (sourceIndexMetadata.getNumberOfShards() &lt; numTargetShards) {
1089             return Collections.singleton(selectSplitShard(shardId, sourceIndexMetadata, numTargetShards));
1090         }
1091         throw new IllegalArgumentException("can't select recover from shards if both indices have the same number of shards");
1092     }
1093     public static Set&lt;ShardId&gt; selectShrinkShards(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
1094         if (shardId &gt;= numTargetShards) {
1095             throw new IllegalArgumentException("the number of target shards (" + numTargetShards + ") must be greater than the shard id: "
1096                 + shardId);
1097         }
1098         if (sourceIndexMetadata.getNumberOfShards() &lt; numTargetShards) {
1099             throw new IllegalArgumentException("the number of target shards [" + numTargetShards
1100                 + "] must be less that the number of source shards [" + sourceIndexMetadata.getNumberOfShards() + "]");
1101         }
1102         int routingFactor = getRoutingFactor(sourceIndexMetadata.getNumberOfShards(), numTargetShards);
1103         Set&lt;ShardId&gt; shards = new HashSet&lt;&gt;(routingFactor);
1104         for (int i = shardId * routingFactor; i &lt; routingFactor * shardId + routingFactor; i++) {
1105             shards.add(new ShardId(sourceIndexMetadata.getIndex(), i));
1106         }
1107         return shards;
1108     }
1109     public static int getRoutingFactor(int sourceNumberOfShards, int targetNumberOfShards) {
1110         final int factor;
1111         if (sourceNumberOfShards &lt; targetNumberOfShards) {             factor = targetNumberOfShards / sourceNumberOfShards;
1112             if (factor * sourceNumberOfShards != targetNumberOfShards || factor &lt;= 1) {
1113                 throw new IllegalArgumentException("the number of source shards [" + sourceNumberOfShards + "] must be a must be a " +
1114                     "factor of ["
1115                     + targetNumberOfShards + "]");
1116             }
1117         } else if (sourceNumberOfShards &gt; targetNumberOfShards) {             factor = sourceNumberOfShards / targetNumberOfShards;
1118             if (factor * targetNumberOfShards != sourceNumberOfShards || factor &lt;= 1) {
1119                 throw new IllegalArgumentException("the number of source shards [" + sourceNumberOfShards + "] must be a must be a " +
1120                     "multiple of ["
1121                     + targetNumberOfShards + "]");
1122             }
1123         } else {
1124             factor = 1;
1125         }
1126         return factor;
1127     }
1128     public static boolean isIndexVerifiedBeforeClosed(final IndexMetadata indexMetadata) {
1129         return indexMetadata.getState() == IndexMetadata.State.CLOSE
1130             &amp;&amp; VERIFIED_BEFORE_CLOSE_SETTING.exists(indexMetadata.getSettings())
1131             &amp;&amp; VERIFIED_BEFORE_CLOSE_SETTING.get(indexMetadata.getSettings());
1132     }
1133 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
