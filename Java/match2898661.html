<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for SysSchemaInfo.java & IndexMetadata.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for SysSchemaInfo.java & IndexMetadata.java
      </h3>
      <h1 align="center">
        7.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>SysSchemaInfo.java (60.13986%)<TH>IndexMetadata.java (4.1586075%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#0',2,'match2898661-1.html#0',3)" NAME="0">(62-69)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#0',2,'match2898661-1.html#0',3)" NAME="0">(655-670)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#1',2,'match2898661-1.html#1',3)" NAME="1">(51-57)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#1',2,'match2898661-1.html#1',3)" NAME="1">(671-682)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#2',2,'match2898661-1.html#2',3)" NAME="2">(57-61)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#2',2,'match2898661-1.html#2',3)" NAME="2">(688-695)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#3',2,'match2898661-1.html#3',3)" NAME="3">(22-37)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#3',2,'match2898661-1.html#3',3)" NAME="3">(20-34)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#4',2,'match2898661-1.html#4',3)" NAME="4">(70-78)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#4',2,'match2898661-1.html#4',3)" NAME="4">(496-504)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match2898661-0.html#5',2,'match2898661-1.html#5',3)" NAME="5">(48-50)<TD><A HREF="javascript:ZweiFrames('match2898661-0.html#5',2,'match2898661-1.html#5',3)" NAME="5">(723-729)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SysSchemaInfo.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="3"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2898661-1.html#3',3,'match2898661-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.metadata.sys;

import io.crate.metadata.settings.CrateSettings;
import io.crate.metadata.table.SchemaInfo;
import io.crate.metadata.table.TableInfo;
import io.crate.metadata.view.ViewInfo;
import org.elasticsearch.cluster.ClusterChangedEvent;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.inject.Singleton;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import</B></FONT> java.util.function.Supplier;

@Singleton
public class SysSchemaInfo implements SchemaInfo {

    public static final String NAME = &quot;sys&quot;;
    private final Map&lt;String, TableInfo&gt; tableInfos;

<A NAME="5"></A>    @Inject
    public SysSchemaInfo(ClusterService clusterService, CrateSettings crateSettings) {
        tableInfos = new HashMap&lt;&gt;();
<A NAME="1"></A>        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match2898661-1.html#5',3,'match2898661-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>tableInfos.put(SysClusterTableInfo.IDENT.name(), SysClusterTableInfo.of(clusterService, crateSettings));
        tableInfos.put(SysNodesTableInfo.IDENT.name(), SysNodesTableInfo.create());
        tableInfos.put(SysShardsTableInfo.IDENT.name(), SysShardsTableInfo.create</B></FONT>());
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2898661-1.html#1',3,'match2898661-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Supplier&lt;DiscoveryNode&gt; localNode = clusterService::localNode;
        tableInfos.put(SysJobsTableInfo.IDENT.name(), SysJobsTableInfo.create(localNode));
        tableInfos.put(SysJobsLogTableInfo.IDENT.name(), SysJobsLogTableInfo.create(localNode));
<A NAME="2"></A>        tableInfos.put(SysOperationsTableInfo.IDENT.name(), SysOperationsTableInfo.create(localNode));
        tableInfos.put(SysOperationsLogTableInfo.IDENT.name(), SysOperationsLogTableInfo.create());
        tableInfos.put(SysChecksTableInfo.IDENT.name(), SysChecksTableInfo.create());
        tableInfos.put</B></FONT>(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2898661-1.html#2',3,'match2898661-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SysNodeChecksTableInfo.IDENT.name(), SysNodeChecksTableInfo.create());
        tableInfos.put(SysRepositoriesTableInfo.IDENT.name(), SysRepositoriesTableInfo.create(clusterService.getClusterSettings().maskedSettings()));
<A NAME="0"></A>        tableInfos.put(SysSnapshotsTableInfo.IDENT.name(), SysSnapshotsTableInfo.create());
        tableInfos.put(SysSnapshotRestoreTableInfo.IDENT.name(), SysSnapshotRestoreTableInfo.create());
        tableInfos.put(SysSummitsTableInfo.IDENT.name(), SysSummitsTableInfo.create</B></FONT>());
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2898661-1.html#0',3,'match2898661-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>tableInfos.put(SysAllocationsTableInfo.IDENT.name(), SysAllocationsTableInfo.create());
        tableInfos.put(SysHealth.IDENT.name(), SysHealth.create());
        tableInfos.put(SysMetricsTableInfo.NAME.name(), SysMetricsTableInfo.create(localNode));
        tableInfos.put(SysSegmentsTableInfo.IDENT.name(), SysSegmentsTableInfo.create(clusterService::localNode));
    }
<A NAME="4"></A>
    @Override
    public TableInfo getTableInfo(String name) {</B></FONT>
        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match2898661-1.html#4',3,'match2898661-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return tableInfos.get(name);
    }

    @Override
    public String name() {
        return NAME;
    }

    @</B></FONT>Override
    public void invalidateTableCache(String tableName) {

    }

    @Override
    public Iterable&lt;TableInfo&gt; getTables() {
        return tableInfos.values();
    }

    @Override
    public Iterable&lt;ViewInfo&gt; getViews() {
        return Collections.emptyList();
    }

    @Override
    public void close() throws Exception {

    }

    @Override
    public void update(ClusterChangedEvent event) {

    }

    public void registerSysTable(TableInfo tableInfo) {
        assert tableInfo.ident().schema().equals(&quot;sys&quot;) : &quot;table is not in sys schema&quot;;
        assert !tableInfos.containsKey(tableInfo.ident().name()) : &quot;table already exists&quot;;
        tableInfos.put(tableInfo.ident().name(), tableInfo);
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>IndexMetadata.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="3"></A> * under the License.
 */

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#3',2,'match2898661-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.cluster.metadata;

import com.carrotsearch.hppc.LongArrayList;
import com.carrotsearch.hppc.cursors.IntObjectCursor;
import com.carrotsearch.hppc.cursors.ObjectCursor;
import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
import io.crate.common.collections.MapBuilder;
import io.crate.types.DataTypes;
import org.elasticsearch.Assertions;
import org.elasticsearch.Version;
import org.elasticsearch.action.support.ActiveShardCount;
import org.elasticsearch.cluster.Diff;
import org.elasticsearch.cluster.Diffable;
import org.elasticsearch.cluster.DiffableUtils;
import</B></FONT> org.elasticsearch.cluster.block.ClusterBlock;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.node.DiscoveryNodeFilters;
import org.elasticsearch.cluster.routing.allocation.IndexMetadataUpdater;
import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.collect.ImmutableOpenIntMap;
import org.elasticsearch.common.collect.ImmutableOpenMap;
import org.elasticsearch.common.compress.CompressedXContent;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.settings.Setting;
import org.elasticsearch.common.settings.Setting.Property;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.ToXContent;
import org.elasticsearch.common.xcontent.ToXContentFragment;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentHelper;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.gateway.MetadataStateFormat;
import org.elasticsearch.index.Index;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.rest.RestStatus;

import javax.annotation.Nullable;
import java.io.IOException;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.IP_VALIDATOR;
import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.OpType.AND;
import static org.elasticsearch.cluster.node.DiscoveryNodeFilters.OpType.OR;
import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;
import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;

public class IndexMetadata implements Diffable&lt;IndexMetadata&gt;, ToXContentFragment {

    public static final ClusterBlock INDEX_CLOSED_BLOCK = new ClusterBlock(4, &quot;index closed&quot;, false, false, false, RestStatus.FORBIDDEN, ClusterBlockLevel.READ_WRITE);
    public static final ClusterBlock INDEX_READ_ONLY_BLOCK = new ClusterBlock(5, &quot;index read-only (api)&quot;, false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA_WRITE));
    public static final ClusterBlock INDEX_READ_BLOCK = new ClusterBlock(7, &quot;index read (api)&quot;, false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.READ));
    public static final ClusterBlock INDEX_WRITE_BLOCK = new ClusterBlock(8, &quot;index write (api)&quot;, false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.WRITE));
    public static final ClusterBlock INDEX_METADATA_BLOCK = new ClusterBlock(9, &quot;index metadata (api)&quot;, false, false, false, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.METADATA_WRITE, ClusterBlockLevel.METADATA_READ));
    public static final ClusterBlock INDEX_READ_ONLY_ALLOW_DELETE_BLOCK = new ClusterBlock(12, &quot;index read-only / allow delete (api)&quot;, false, false, true, RestStatus.FORBIDDEN, EnumSet.of(ClusterBlockLevel.METADATA_WRITE, ClusterBlockLevel.WRITE));

    public enum State {
        OPEN((byte) 0),
        CLOSE((byte) 1);

        private final byte id;

        State(byte id) {
            this.id = id;
        }

        public byte id() {
            return this.id;
        }

        public static State fromId(byte id) {
            if (id == 0) {
                return OPEN;
            } else if (id == 1) {
                return CLOSE;
            }
            throw new IllegalStateException(&quot;No state match for id [&quot; + id + &quot;]&quot;);
        }

        public static State fromString(String state) {
            if (&quot;open&quot;.equals(state)) {
                return OPEN;
            } else if (&quot;close&quot;.equals(state)) {
                return CLOSE;
            }
            throw new IllegalStateException(&quot;No state match for [&quot; + state + &quot;]&quot;);
        }
    }

    static Setting&lt;Integer&gt; buildNumberOfShardsSetting() {
        /* This is a safety limit that should only be exceeded in very rare and special cases. The assumption is that
         * 99% of the users have less than 1024 shards per index. We also make it a hard check that requires restart of nodes
         * if a cluster should allow to create more than 1024 shards per index. NOTE: this does not limit the number of shards per cluster.
         * this also prevents creating stuff like a new index with millions of shards by accident which essentially kills the entire cluster
         * with OOM on the spot.*/
        final int maxNumShards = Integer.parseInt(System.getProperty(&quot;es.index.max_number_of_shards&quot;, &quot;1024&quot;));
        if (maxNumShards &lt; 1) {
            throw new IllegalArgumentException(&quot;es.index.max_number_of_shards must be &gt; 0&quot;);
        }
        return Setting.intSetting(SETTING_NUMBER_OF_SHARDS, Math.min(5, maxNumShards), 1, maxNumShards,
            Property.IndexScope, Property.Final);
    }

    public static final String INDEX_SETTING_PREFIX = &quot;index.&quot;;
    public static final String SETTING_NUMBER_OF_SHARDS = &quot;index.number_of_shards&quot;;
    public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_SHARDS_SETTING = buildNumberOfShardsSetting();
    public static final String SETTING_NUMBER_OF_REPLICAS = &quot;index.number_of_replicas&quot;;
    public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_REPLICAS_SETTING =
        Setting.intSetting(SETTING_NUMBER_OF_REPLICAS, 1, 0, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_ROUTING_PARTITION_SIZE = &quot;index.routing_partition_size&quot;;
    public static final Setting&lt;Integer&gt; INDEX_ROUTING_PARTITION_SIZE_SETTING =
            Setting.intSetting(SETTING_ROUTING_PARTITION_SIZE, 1, 1, Property.IndexScope);

    public static final Setting&lt;Integer&gt; INDEX_NUMBER_OF_ROUTING_SHARDS_SETTING =
        Setting.intSetting(
            &quot;index.number_of_routing_shards&quot;,
            INDEX_NUMBER_OF_SHARDS_SETTING,
            1,
            new Setting.Validator&lt;Integer&gt;() {
                @Override
                public void validate(final Integer value) {
                }

                @Override
                public void validate(Integer numRoutingShards, Map&lt;Setting&lt;?&gt;, Object&gt; settings) {
                    int numShards = (int) settings.get(INDEX_NUMBER_OF_SHARDS_SETTING);
                    if (numRoutingShards &lt; numShards) {
                        throw new IllegalArgumentException(&quot;index.number_of_routing_shards [&quot; + numRoutingShards
                                                           + &quot;] must be &gt;= index.number_of_shards [&quot; + numShards + &quot;]&quot;);
                    }
                    getRoutingFactor(numShards, numRoutingShards);
                }

                @Override
                public Iterator&lt;Setting&lt;?&gt;&gt; settings() {
                    final List&lt;Setting&lt;?&gt;&gt; settings = Collections.singletonList(INDEX_NUMBER_OF_SHARDS_SETTING);
                    return settings.iterator();
                }
            },
            Property.IndexScope);

    public static final String SETTING_AUTO_EXPAND_REPLICAS = &quot;index.auto_expand_replicas&quot;;
    public static final Setting&lt;AutoExpandReplicas&gt; INDEX_AUTO_EXPAND_REPLICAS_SETTING = AutoExpandReplicas.SETTING;
    public static final String SETTING_READ_ONLY = &quot;index.blocks.read_only&quot;;
    public static final Setting&lt;Boolean&gt; INDEX_READ_ONLY_SETTING =
        Setting.boolSetting(SETTING_READ_ONLY, false, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_BLOCKS_READ = &quot;index.blocks.read&quot;;
    public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_READ_SETTING =
        Setting.boolSetting(SETTING_BLOCKS_READ, false, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_BLOCKS_WRITE = &quot;index.blocks.write&quot;;
    public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_WRITE_SETTING =
        Setting.boolSetting(SETTING_BLOCKS_WRITE, false, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_BLOCKS_METADATA = &quot;index.blocks.metadata&quot;;
    public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_METADATA_SETTING =
        Setting.boolSetting(SETTING_BLOCKS_METADATA, false, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_READ_ONLY_ALLOW_DELETE = &quot;index.blocks.read_only_allow_delete&quot;;
    public static final Setting&lt;Boolean&gt; INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING =
        Setting.boolSetting(SETTING_READ_ONLY_ALLOW_DELETE, false, Property.Dynamic, Property.IndexScope);

    public static final String SETTING_VERSION_CREATED = &quot;index.version.created&quot;;

    public static final Setting&lt;Version&gt; SETTING_INDEX_VERSION_CREATED =
            Setting.versionSetting(SETTING_VERSION_CREATED, Version.V_EMPTY, Property.IndexScope, Property.PrivateIndex);

    public static final String SETTING_VERSION_CREATED_STRING = &quot;index.version.created_string&quot;;
    public static final String SETTING_VERSION_UPGRADED = &quot;index.version.upgraded&quot;;
    public static final String SETTING_VERSION_UPGRADED_STRING = &quot;index.version.upgraded_string&quot;;
    public static final String SETTING_CREATION_DATE = &quot;index.creation_date&quot;;
    /**
     * The user provided name for an index. This is the plain string provided by the user when the index was created.
     * It might still contain date math expressions etc. (added in 5.0)
     */
    public static final String SETTING_INDEX_PROVIDED_NAME = &quot;index.provided_name&quot;;
    public static final String SETTING_PRIORITY = &quot;index.priority&quot;;
    public static final Setting&lt;Integer&gt; INDEX_PRIORITY_SETTING =
        Setting.intSetting(&quot;index.priority&quot;, 1, 0, Property.Dynamic, Property.IndexScope);
    public static final String SETTING_CREATION_DATE_STRING = &quot;index.creation_date_string&quot;;
    public static final String SETTING_INDEX_UUID = &quot;index.uuid&quot;;
    public static final String SETTING_DATA_PATH = &quot;index.data_path&quot;;
    public static final Setting&lt;String&gt; INDEX_DATA_PATH_SETTING =
        new Setting&lt;&gt;(SETTING_DATA_PATH, &quot;&quot;, Function.identity(), DataTypes.STRING, Property.IndexScope);
    public static final String INDEX_UUID_NA_VALUE = &quot;_na_&quot;;

    public static final String INDEX_ROUTING_REQUIRE_GROUP_PREFIX = &quot;index.routing.allocation.require&quot;;
    public static final String INDEX_ROUTING_INCLUDE_GROUP_PREFIX = &quot;index.routing.allocation.include&quot;;
    public static final String INDEX_ROUTING_EXCLUDE_GROUP_PREFIX = &quot;index.routing.allocation.exclude&quot;;
    public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_REQUIRE_GROUP_SETTING =
        Setting.prefixKeySetting(INDEX_ROUTING_REQUIRE_GROUP_PREFIX + &quot;.&quot;, key -&gt;
            Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));
    public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_INCLUDE_GROUP_SETTING =
        Setting.prefixKeySetting(INDEX_ROUTING_INCLUDE_GROUP_PREFIX + &quot;.&quot;, key -&gt;
            Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));
    public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_EXCLUDE_GROUP_SETTING =
        Setting.prefixKeySetting(INDEX_ROUTING_EXCLUDE_GROUP_PREFIX + &quot;.&quot;, key -&gt;
            Setting.simpleString(key, value -&gt; IP_VALIDATOR.accept(key, value), Property.Dynamic, Property.IndexScope));

    // this is only setable internally not a registered setting!!
    public static final Setting.AffixSetting&lt;String&gt; INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING =
        Setting.prefixKeySetting(&quot;index.routing.allocation.initial_recovery.&quot;, key -&gt; Setting.simpleString(key));

    /**
     * The number of active shard copies to check for before proceeding with a write operation.
     */
    public static final Setting&lt;ActiveShardCount&gt; SETTING_WAIT_FOR_ACTIVE_SHARDS =
        new Setting&lt;&gt;(&quot;index.write.wait_for_active_shards&quot;,
                      &quot;1&quot;,
                      ActiveShardCount::parseString,
                      DataTypes.STRING,
                      Setting.Property.Dynamic,
                      Setting.Property.IndexScope);

    /**
     * an internal index format description, allowing us to find out if this index is upgraded or needs upgrading
     */
    private static final String INDEX_FORMAT = &quot;index.format&quot;;
    public static final Setting&lt;Integer&gt; INDEX_FORMAT_SETTING =
            Setting.intSetting(INDEX_FORMAT, 0, Setting.Property.IndexScope, Setting.Property.Final);


    public static final Setting&lt;Boolean&gt; VERIFIED_BEFORE_CLOSE_SETTING =
        Setting.boolSetting(&quot;index.verified_before_close&quot;, false, Setting.Property.IndexScope, Setting.Property.PrivateIndex);

    public static final String KEY_IN_SYNC_ALLOCATIONS = &quot;in_sync_allocations&quot;;
    static final String KEY_VERSION = &quot;version&quot;;
    static final String KEY_MAPPING_VERSION = &quot;mapping_version&quot;;
    static final String KEY_SETTINGS_VERSION = &quot;settings_version&quot;;
    static final String KEY_ROUTING_NUM_SHARDS = &quot;routing_num_shards&quot;;
    static final String KEY_SETTINGS = &quot;settings&quot;;
    static final String KEY_STATE = &quot;state&quot;;
    static final String KEY_MAPPINGS = &quot;mappings&quot;;
    static final String KEY_ALIASES = &quot;aliases&quot;;
    public static final String KEY_PRIMARY_TERMS = &quot;primary_terms&quot;;

    public static final String INDEX_STATE_FILE_PREFIX = &quot;state-&quot;;
    private final int routingNumShards;
    private final int routingFactor;
    private final int routingPartitionSize;

    private final int numberOfShards;
    private final int numberOfReplicas;

    private final Index index;
    private final long version;

    private final long mappingVersion;

    private final long settingsVersion;

    private final long[] primaryTerms;

    private final State state;

    private final ImmutableOpenMap&lt;String, AliasMetadata&gt; aliases;

    private final Settings settings;

    private final ImmutableOpenMap&lt;String, MappingMetadata&gt; mappings;

    private final ImmutableOpenMap&lt;String, DiffableStringMap&gt; customData;

    private final ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; inSyncAllocationIds;

    private final transient int totalNumberOfShards;

    private final DiscoveryNodeFilters requireFilters;
    private final DiscoveryNodeFilters includeFilters;
    private final DiscoveryNodeFilters excludeFilters;
    private final DiscoveryNodeFilters initialRecoveryFilters;

    private final Version indexCreatedVersion;
    private final Version indexUpgradedVersion;

    private final ActiveShardCount waitForActiveShards;

    private IndexMetadata(Index index, long version, long mappingVersion, long settingsVersion, long[] primaryTerms, State state, int numberOfShards, int numberOfReplicas, Settings settings,
                          ImmutableOpenMap&lt;String, MappingMetadata&gt; mappings, ImmutableOpenMap&lt;String, AliasMetadata&gt; aliases,
                          ImmutableOpenMap&lt;String, DiffableStringMap&gt; customData, ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; inSyncAllocationIds,
                          DiscoveryNodeFilters requireFilters, DiscoveryNodeFilters initialRecoveryFilters, DiscoveryNodeFilters includeFilters, DiscoveryNodeFilters excludeFilters,
                          Version indexCreatedVersion, Version indexUpgradedVersion,
                          int routingNumShards, int routingPartitionSize, ActiveShardCount waitForActiveShards) {

        this.index = index;
        this.version = version;
        assert mappingVersion &gt;= 0 : mappingVersion;
        this.mappingVersion = mappingVersion;
        assert settingsVersion &gt;= 0 : settingsVersion;
        this.settingsVersion = settingsVersion;
        this.primaryTerms = primaryTerms;
        assert primaryTerms.length == numberOfShards;
        this.state = state;
        this.numberOfShards = numberOfShards;
        this.numberOfReplicas = numberOfReplicas;
        this.totalNumberOfShards = numberOfShards * (numberOfReplicas + 1);
        this.settings = settings;
        this.mappings = mappings;
        this.customData = customData;
        this.aliases = aliases;
        this.inSyncAllocationIds = inSyncAllocationIds;
        this.requireFilters = requireFilters;
        this.includeFilters = includeFilters;
        this.excludeFilters = excludeFilters;
        this.initialRecoveryFilters = initialRecoveryFilters;
        this.indexCreatedVersion = indexCreatedVersion;
        this.indexUpgradedVersion = indexUpgradedVersion;
        this.routingNumShards = routingNumShards;
        this.routingFactor = routingNumShards / numberOfShards;
        this.routingPartitionSize = routingPartitionSize;
        this.waitForActiveShards = waitForActiveShards;
        assert numberOfShards * routingFactor == routingNumShards : routingNumShards + &quot; must be a multiple of &quot; + numberOfShards;
    }

    public Index getIndex() {
        return index;
    }

    public String getIndexUUID() {
        return index.getUUID();
    }

    /**
     * Test whether the current index UUID is the same as the given one. Returns true if either are _na_
     */
    public boolean isSameUUID(String otherUUID) {
        assert otherUUID != null;
        assert getIndexUUID() != null;
        if (INDEX_UUID_NA_VALUE.equals(otherUUID) || INDEX_UUID_NA_VALUE.equals(getIndexUUID())) {
            return true;
        }
        return otherUUID.equals(getIndexUUID());
    }

    public long getVersion() {
        return this.version;
    }

    public long getMappingVersion() {
        return mappingVersion;
    }

    public long getSettingsVersion() {
        return settingsVersion;
    }

    /**
     * The term of the current selected primary. This is a non-negative number incremented when
     * a primary shard is assigned after a full cluster restart or a replica shard is promoted to a primary.
     *
     * Note: since we increment the term every time a shard is assigned, the term for any operational shard (i.e., a shard
     * that can be indexed into) is larger than 0. See {@link IndexMetadataUpdater#applyChanges}.
     **/
    public long primaryTerm(int shardId) {
        return this.primaryTerms[shardId];
    }

    /**
     * Return the {@link Version} on which this index has been created. This
     * information is typically useful for backward compatibility.
     */
    public Version getCreationVersion() {
        return indexCreatedVersion;
    }

    /**
     * Return the {@link Version} on which this index has been upgraded. This
     * information is typically useful for backward compatibility.
     */
    public Version getUpgradedVersion() {
        return indexUpgradedVersion;
    }

    public long getCreationDate() {
        return settings.getAsLong(SETTING_CREATION_DATE, -1L);
    }

    public State getState() {
        return this.state;
    }

    public int getNumberOfShards() {
        return numberOfShards;
    }

    public int getNumberOfReplicas() {
        return numberOfReplicas;
    }

    public int getRoutingPartitionSize() {
        return routingPartitionSize;
    }

    public boolean isRoutingPartitionedIndex() {
        return routingPartitionSize != 1;
    }

    public int getTotalNumberOfShards() {
        return totalNumberOfShards;
    }

    /**
     * Returns the configured {@link #SETTING_WAIT_FOR_ACTIVE_SHARDS}, which defaults
     * to an active shard count of 1 if not specified.
     */
    public ActiveShardCount getWaitForActiveShards() {
        return waitForActiveShards;
    }

    public Settings getSettings() {
        return settings;
    }

    public ImmutableOpenMap&lt;String, AliasMetadata&gt; getAliases() {
        return this.aliases;
    }

    /**
     * Return the concrete mapping for this index or {@code null} if this index has no mappings at all.
     */
    @Nullable
    public MappingMetadata mapping() {
        for (var cursor : mappings) {
            return cursor.value;
        }
        return null;
    }

    // we keep the shrink settings for BWC - this can be removed in 8.0
    // we can't remove in 7 since this setting might be baked into an index coming in via a full cluster restart from 6.0
    public static final String INDEX_SHRINK_SOURCE_UUID_KEY = &quot;index.shrink.source.uuid&quot;;
    public static final String INDEX_SHRINK_SOURCE_NAME_KEY = &quot;index.shrink.source.name&quot;;
    public static final String INDEX_RESIZE_SOURCE_UUID_KEY = &quot;index.resize.source.uuid&quot;;
    public static final String INDEX_RESIZE_SOURCE_NAME_KEY = &quot;index.resize.source.name&quot;;
    public static final Setting&lt;String&gt; INDEX_SHRINK_SOURCE_UUID = Setting.simpleString(INDEX_SHRINK_SOURCE_UUID_KEY);
    public static final Setting&lt;String&gt; INDEX_SHRINK_SOURCE_NAME = Setting.simpleString(INDEX_SHRINK_SOURCE_NAME_KEY);
    public static final Setting&lt;String&gt; INDEX_RESIZE_SOURCE_UUID = Setting.simpleString(INDEX_RESIZE_SOURCE_UUID_KEY,
        INDEX_SHRINK_SOURCE_UUID);
    public static final Setting&lt;String&gt; INDEX_RESIZE_SOURCE_NAME = Setting.simpleString(INDEX_RESIZE_SOURCE_NAME_KEY,
        INDEX_SHRINK_SOURCE_NAME);

    public Index getResizeSourceIndex() {
        return INDEX_RESIZE_SOURCE_UUID.exists(settings) || INDEX_SHRINK_SOURCE_UUID.exists(settings)
            ? new Index(INDEX_RESIZE_SOURCE_NAME.get(settings), INDEX_RESIZE_SOURCE_UUID.get(settings)) : null;
    }


    ImmutableOpenMap&lt;String, DiffableStringMap&gt; getCustomData() {
        return this.customData;
    }

    public Map&lt;String, String&gt; getCustomData(final String key) {
        return this.customData.get(key);
    }

    public ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt; getInSyncAllocationIds() {
        return inSyncAllocationIds;
    }
<A NAME="4"></A>
    public Set&lt;String&gt; inSyncAllocationIds(int shardId) {
        assert shardId &gt;= 0 &amp;&amp; shardId &lt; numberOfShards;
        <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#4',2,'match2898661-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return inSyncAllocationIds.get(shardId);
    }

    @Nullable
    public DiscoveryNodeFilters requireFilters() {
        return requireFilters;
    }

    @</B></FONT>Nullable
    public DiscoveryNodeFilters getInitialRecoveryFilters() {
        return initialRecoveryFilters;
    }

    @Nullable
    public DiscoveryNodeFilters includeFilters() {
        return includeFilters;
    }

    @Nullable
    public DiscoveryNodeFilters excludeFilters() {
        return excludeFilters;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IndexMetadata that = (IndexMetadata) o;

        if (version != that.version) {
            return false;
        }

        if (!aliases.equals(that.aliases)) {
            return false;
        }
        if (!index.equals(that.index)) {
            return false;
        }
        if (!mappings.equals(that.mappings)) {
            return false;
        }
        if (!settings.equals(that.settings)) {
            return false;
        }
        if (state != that.state) {
            return false;
        }
        if (!customData.equals(that.customData)) {
            return false;
        }
        if (routingNumShards != that.routingNumShards) {
            return false;
        }
        if (routingFactor != that.routingFactor) {
            return false;
        }
        if (Arrays.equals(primaryTerms, that.primaryTerms) == false) {
            return false;
        }
        if (!inSyncAllocationIds.equals(that.inSyncAllocationIds)) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int result = index.hashCode();
        result = 31 * result + Long.hashCode(version);
        result = 31 * result + state.hashCode();
        result = 31 * result + aliases.hashCode();
        result = 31 * result + settings.hashCode();
        result = 31 * result + mappings.hashCode();
        result = 31 * result + customData.hashCode();
        result = 31 * result + Long.hashCode(routingFactor);
        result = 31 * result + Long.hashCode(routingNumShards);
        result = 31 * result + Arrays.hashCode(primaryTerms);
        result = 31 * result + inSyncAllocationIds.hashCode();
        return result;
    }


    @Override
    public Diff&lt;IndexMetadata&gt; diff(IndexMetadata previousState) {
        return new IndexMetadataDiff(previousState, this);
    }

    public static Diff&lt;IndexMetadata&gt; readDiffFrom(StreamInput in) throws IOException {
        return new IndexMetadataDiff(in);
    }

    public static IndexMetadata fromXContent(XContentParser parser) throws IOException {
        return Builder.fromXContent(parser);
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        Builder.toXContent(this, builder, params);
        return builder;
    }

    private static class IndexMetadataDiff implements Diff&lt;IndexMetadata&gt; {

        private final String index;
        private final int routingNumShards;
        private final long version;
        private final long mappingVersion;
        private final long settingsVersion;
        private final long[] primaryTerms;
        private final State state;
        private final Settings settings;
        private final Diff&lt;ImmutableOpenMap&lt;String, MappingMetadata&gt;&gt; mappings;
        private final Diff&lt;ImmutableOpenMap&lt;String, AliasMetadata&gt;&gt; aliases;
        private final Diff&lt;ImmutableOpenMap&lt;String, DiffableStringMap&gt;&gt; customData;
        private final Diff&lt;ImmutableOpenIntMap&lt;Set&lt;String&gt;&gt;&gt; inSyncAllocationIds;

        IndexMetadataDiff(IndexMetadata before, IndexMetadata after) {
            index = after.index.getName();
            version = after.version;
            mappingVersion = after.mappingVersion;
            settingsVersion = after.settingsVersion;
            routingNumShards = after.routingNumShards;
            state = after.state;
            settings = after.settings;
            primaryTerms = after.primaryTerms;
            mappings = DiffableUtils.diff(before.mappings, after.mappings, DiffableUtils.getStringKeySerializer());
            aliases = DiffableUtils.diff(before.aliases, after.aliases, DiffableUtils.getStringKeySerializer());
            customData = DiffableUtils.diff(before.customData, after.customData, DiffableUtils.getStringKeySerializer());
            inSyncAllocationIds = DiffableUtils.diff(before.inSyncAllocationIds, after.inSyncAllocationIds,
                DiffableUtils.getVIntKeySerializer(), DiffableUtils.StringSetValueSerializer.getInstance());
        }

        IndexMetadataDiff(StreamInput in) throws IOException {
            index = in.readString();
            routingNumShards = in.readInt();
            version = in.readLong();
            mappingVersion = in.readVLong();
            settingsVersion = in.readVLong();
            state = State.fromId(in.readByte());
            settings = Settings.readSettingsFromStream(in);
            primaryTerms = in.readVLongArray();
            mappings = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), MappingMetadata::new,
                                                              MappingMetadata::readDiffFrom);
            aliases = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), AliasMetadata::new,
                                                             AliasMetadata::readDiffFrom);
            customData = DiffableUtils.readImmutableOpenMapDiff(in, DiffableUtils.getStringKeySerializer(), DiffableStringMap::new,
                DiffableStringMap::readDiffFrom);
            inSyncAllocationIds = DiffableUtils.readImmutableOpenIntMapDiff(in, DiffableUtils.getVIntKeySerializer(),
                DiffableUtils.StringSetValueSerializer.getInstance());
        }
<A NAME="0"></A>
        @Override
        public void writeTo(StreamOutput out) throws IOException {
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#0',2,'match2898661-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>out.writeString(index);
            out.writeInt(routingNumShards);
            out.writeLong(version);
            out.writeVLong(mappingVersion);
            out.writeVLong(settingsVersion);
            out.writeByte(state.id);
            Settings.writeSettingsToStream(settings, out);
            out.writeVLongArray(primaryTerms);
            mappings.writeTo(out);
            aliases.writeTo(out);
            customData.writeTo(out);
            inSyncAllocationIds.writeTo(out);
        }
<A NAME="1"></A>
        @Override
        public IndexMetadata apply(IndexMetadata part) {</B></FONT>
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#1',2,'match2898661-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Builder builder = builder(index);
            builder.version(version);
            builder.mappingVersion(mappingVersion);
            builder.settingsVersion(settingsVersion);
            builder.setRoutingNumShards(routingNumShards);
            builder.state(state);
            builder.settings(settings);
            builder.primaryTerms(primaryTerms);
            builder.mappings.putAll(mappings.apply(part.mappings));
            builder.aliases.putAll(aliases.apply(part.aliases));
            builder.customMetadata.putAll(customData.apply(part.customData));
            builder.inSyncAllocationIds.putAll(inSyncAllocationIds.apply</B></FONT>(part.inSyncAllocationIds));
            return builder.build();
        }
<A NAME="2"></A>    }

    public static IndexMetadata readFrom(StreamInput in) throws IOException {
        Builder builder = new Builder(<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#2',2,'match2898661-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>in.readString());
        builder.version(in.readLong());
        builder.mappingVersion(in.readVLong());
        builder.settingsVersion(in.readVLong());
        builder.setRoutingNumShards(in.readInt());
        builder.state(State.fromId(in.readByte()));
        builder.settings(readSettingsFromStream(in));
        builder.primaryTerms(in.readVLongArray</B></FONT>());
        int mappingsSize = in.readVInt();
        for (int i = 0; i &lt; mappingsSize; i++) {
            MappingMetadata mappingMd = new MappingMetadata(in);
            builder.putMapping(mappingMd);
        }
        int aliasesSize = in.readVInt();
        for (int i = 0; i &lt; aliasesSize; i++) {
            AliasMetadata aliasMd = new AliasMetadata(in);
            builder.putAlias(aliasMd);
        }
        int customSize = in.readVInt();
        for (int i = 0; i &lt; customSize; i++) {
            String key = in.readString();
            DiffableStringMap custom = new DiffableStringMap(in);
            builder.putCustom(key, custom);
        }
        int inSyncAllocationIdsSize = in.readVInt();
        for (int i = 0; i &lt; inSyncAllocationIdsSize; i++) {
            int key = in.readVInt();
            Set&lt;String&gt; allocationIds = DiffableUtils.StringSetValueSerializer.getInstance().read(in, key);
            builder.putInSyncAllocationIds(key, allocationIds);
        }
        return builder.build();
    }
<A NAME="5"></A>
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2898661-0.html#5',2,'match2898661-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>out.writeString(index.getName()); // uuid will come as part of settings
        out.writeLong(version);
        out.writeVLong(mappingVersion);
        out.writeVLong(settingsVersion);
        out.writeInt(routingNumShards);
        out.writeByte(state.id());
        writeSettingsToStream</B></FONT>(settings, out);
        out.writeVLongArray(primaryTerms);
        out.writeVInt(mappings.size());
        for (ObjectCursor&lt;MappingMetadata&gt; cursor : mappings.values()) {
            cursor.value.writeTo(out);
        }
        out.writeVInt(aliases.size());
        for (ObjectCursor&lt;AliasMetadata&gt; cursor : aliases.values()) {
            cursor.value.writeTo(out);
        }
        out.writeVInt(customData.size());
        for (final ObjectObjectCursor&lt;String, DiffableStringMap&gt; cursor : customData) {
            out.writeString(cursor.key);
            cursor.value.writeTo(out);
        }
        out.writeVInt(inSyncAllocationIds.size());
        for (IntObjectCursor&lt;Set&lt;String&gt;&gt; cursor : inSyncAllocationIds) {
            out.writeVInt(cursor.key);
            DiffableUtils.StringSetValueSerializer.getInstance().write(cursor.value, out);
        }
    }

    public static Builder builder(String index) {
        return new Builder(index);
    }

    public static Builder builder(IndexMetadata indexMetadata) {
        return new Builder(indexMetadata);
    }

    public static class Builder {

        private String index;
        private State state = State.OPEN;
        private long version = 1;
        private long mappingVersion = 1;
        private long settingsVersion = 1;
        private long[] primaryTerms = null;
        private Settings settings = Settings.Builder.EMPTY_SETTINGS;
        private final ImmutableOpenMap.Builder&lt;String, MappingMetadata&gt; mappings;
        private final ImmutableOpenMap.Builder&lt;String, AliasMetadata&gt; aliases;
        private final ImmutableOpenMap.Builder&lt;String, DiffableStringMap&gt; customMetadata;
        private final ImmutableOpenIntMap.Builder&lt;Set&lt;String&gt;&gt; inSyncAllocationIds;
        private Integer routingNumShards;

        public Builder(String index) {
            this.index = index;
            this.mappings = ImmutableOpenMap.builder();
            this.aliases = ImmutableOpenMap.builder();
            this.customMetadata = ImmutableOpenMap.builder();
            this.inSyncAllocationIds = ImmutableOpenIntMap.builder();
        }

        public Builder(IndexMetadata indexMetadata) {
            this.index = indexMetadata.getIndex().getName();
            this.state = indexMetadata.state;
            this.version = indexMetadata.version;
            this.mappingVersion = indexMetadata.mappingVersion;
            this.settingsVersion = indexMetadata.settingsVersion;
            this.settings = indexMetadata.getSettings();
            this.primaryTerms = indexMetadata.primaryTerms.clone();
            this.mappings = ImmutableOpenMap.builder(indexMetadata.mappings);
            this.aliases = ImmutableOpenMap.builder(indexMetadata.aliases);
            this.customMetadata = ImmutableOpenMap.builder(indexMetadata.customData);
            this.routingNumShards = indexMetadata.routingNumShards;
            this.inSyncAllocationIds = ImmutableOpenIntMap.builder(indexMetadata.inSyncAllocationIds);
        }

        public String index() {
            return index;
        }

        public Builder index(String index) {
            this.index = index;
            return this;
        }

        public Builder numberOfShards(int numberOfShards) {
            settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_SHARDS, numberOfShards).build();
            return this;
        }

        /**
         * Sets the number of shards that should be used for routing. This should only be used if the number of shards in
         * an index has changed ie if the index is shrunk.
         */
        public Builder setRoutingNumShards(int routingNumShards) {
            this.routingNumShards = routingNumShards;
            return this;
        }

        /**
         * Returns number of shards that should be used for routing. By default this method will return the number of shards
         * for this index.
         *
         * @see #setRoutingNumShards(int)
         * @see #numberOfShards()
         */
        public int getRoutingNumShards() {
            return routingNumShards == null ? numberOfShards() : routingNumShards;
        }

        /**
         * Returns the number of shards.
         *
         * @return the provided value or -1 if it has not been set.
         */
        public int numberOfShards() {
            return settings.getAsInt(SETTING_NUMBER_OF_SHARDS, -1);
        }

        public Builder numberOfReplicas(int numberOfReplicas) {
            settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).build();
            return this;
        }

        /**
         * Returns the number of replicas.
         *
         * @return the provided value or -1 if it has not been set.
         */
        public int numberOfReplicas() {
            return settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, -1);
        }

        public Builder routingPartitionSize(int routingPartitionSize) {
            settings = Settings.builder().put(settings).put(SETTING_ROUTING_PARTITION_SIZE, routingPartitionSize).build();
            return this;
        }

        /**
         * Returns the routing partition size.
         *
         * @return the provided value or -1 if it has not been set.
         */
        public int routingPartitionSize() {
            return settings.getAsInt(SETTING_ROUTING_PARTITION_SIZE, -1);
        }

        public Builder creationDate(long creationDate) {
            settings = Settings.builder().put(settings).put(SETTING_CREATION_DATE, creationDate).build();
            return this;
        }

        public Builder settings(Settings.Builder settings) {
            return settings(settings.build());
        }

        public Builder settings(Settings settings) {
            this.settings = settings;
            return this;
        }

        public MappingMetadata mapping(String type) {
            return mappings.get(type);
        }

        // TODO remove type here
        public Builder putMapping(String type, String source) throws IOException {
            putMapping(new MappingMetadata(type, XContentHelper.convertToMap(XContentFactory.xContent(source), source, true)));
            return this;
        }

        public Builder putMapping(MappingMetadata mappingMd) {
            mappings.clear();
            if (mappingMd != null) {
                mappings.put(mappingMd.type(), mappingMd);
            }
            return this;
        }

        public Builder state(State state) {
            this.state = state;
            return this;
        }

        public Builder putAlias(AliasMetadata aliasMetadata) {
            aliases.put(aliasMetadata.alias(), aliasMetadata);
            return this;
        }

        public Builder putAlias(AliasMetadata.Builder aliasMetadata) {
            aliases.put(aliasMetadata.alias(), aliasMetadata.build());
            return this;
        }

        public Builder removeAlias(String alias) {
            aliases.remove(alias);
            return this;
        }

        public Builder removeAllAliases() {
            aliases.clear();
            return this;
        }

        public Builder putCustom(String type, Map&lt;String, String&gt; customIndexMetadata) {
            this.customMetadata.put(type, new DiffableStringMap(customIndexMetadata));
            return this;
        }

        public Map&lt;String, String&gt; removeCustom(String type) {
            return this.customMetadata.remove(type);
        }

        public Set&lt;String&gt; getInSyncAllocationIds(int shardId) {
            return inSyncAllocationIds.get(shardId);
        }

        public Builder putInSyncAllocationIds(int shardId, Set&lt;String&gt; allocationIds) {
            inSyncAllocationIds.put(shardId, new HashSet&lt;&gt;(allocationIds));
            return this;
        }

        public long version() {
            return this.version;
        }

        public Builder version(long version) {
            this.version = version;
            return this;
        }

        public long mappingVersion() {
            return mappingVersion;
        }

        public long settingsVersion() {
            return settingsVersion;
        }

        public Builder mappingVersion(final long mappingVersion) {
            this.mappingVersion = mappingVersion;
            return this;
        }

        public Builder settingsVersion(final long settingsVersion) {
            this.settingsVersion = settingsVersion;
            return this;
        }

        /**
         * returns the primary term for the given shard.
         * See {@link IndexMetadata#primaryTerm(int)} for more information.
         */
        public long primaryTerm(int shardId) {
            if (primaryTerms == null) {
                initializePrimaryTerms();
            }
            return this.primaryTerms[shardId];
        }

        /**
         * sets the primary term for the given shard.
         * See {@link IndexMetadata#primaryTerm(int)} for more information.
         */
        public Builder primaryTerm(int shardId, long primaryTerm) {
            if (primaryTerms == null) {
                initializePrimaryTerms();
            }
            this.primaryTerms[shardId] = primaryTerm;
            return this;
        }

        private void primaryTerms(long[] primaryTerms) {
            this.primaryTerms = primaryTerms.clone();
        }

        private void initializePrimaryTerms() {
            assert primaryTerms == null;
            if (numberOfShards() &lt; 0) {
                throw new IllegalStateException(&quot;you must set the number of shards before setting/reading primary terms&quot;);
            }
            primaryTerms = new long[numberOfShards()];
        }


        public IndexMetadata build() {
            final ImmutableOpenMap.Builder&lt;String, AliasMetadata&gt; tmpAliases = aliases;
            final Settings tmpSettings = settings;

            Integer maybeNumberOfShards = settings.getAsInt(SETTING_NUMBER_OF_SHARDS, null);
            if (maybeNumberOfShards == null) {
                throw new IllegalArgumentException(&quot;must specify numberOfShards for index [&quot; + index + &quot;]&quot;);
            }
            int numberOfShards = maybeNumberOfShards;
            if (numberOfShards &lt;= 0) {
                throw new IllegalArgumentException(&quot;must specify positive number of shards for index [&quot; + index + &quot;]&quot;);
            }

            Integer maybeNumberOfReplicas = settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, null);
            if (maybeNumberOfReplicas == null) {
                throw new IllegalArgumentException(&quot;must specify numberOfReplicas for index [&quot; + index + &quot;]&quot;);
            }
            int numberOfReplicas = maybeNumberOfReplicas;
            if (numberOfReplicas &lt; 0) {
                throw new IllegalArgumentException(&quot;must specify non-negative number of shards for index [&quot; + index + &quot;]&quot;);
            }

            int routingPartitionSize = INDEX_ROUTING_PARTITION_SIZE_SETTING.get(settings);
            if (routingPartitionSize != 1 &amp;&amp; routingPartitionSize &gt;= getRoutingNumShards()) {
                throw new IllegalArgumentException(&quot;routing partition size [&quot; + routingPartitionSize + &quot;] should be a positive number&quot;
                        + &quot; less than the number of shards [&quot; + getRoutingNumShards() + &quot;] for [&quot; + index + &quot;]&quot;);
            }
            // fill missing slots in inSyncAllocationIds with empty set if needed and make all entries immutable
            ImmutableOpenIntMap.Builder&lt;Set&lt;String&gt;&gt; filledInSyncAllocationIds = ImmutableOpenIntMap.builder();
            for (int i = 0; i &lt; numberOfShards; i++) {
                if (inSyncAllocationIds.containsKey(i)) {
                    filledInSyncAllocationIds.put(i, Collections.unmodifiableSet(new HashSet&lt;&gt;(inSyncAllocationIds.get(i))));
                } else {
                    filledInSyncAllocationIds.put(i, Collections.emptySet());
                }
            }
            final Map&lt;String, String&gt; requireMap = INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(settings);
            final DiscoveryNodeFilters requireFilters;
            if (requireMap.isEmpty()) {
                requireFilters = null;
            } else {
                requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap);
            }
            Map&lt;String, String&gt; includeMap = INDEX_ROUTING_INCLUDE_GROUP_SETTING.getAsMap(settings);
            final DiscoveryNodeFilters includeFilters;
            if (includeMap.isEmpty()) {
                includeFilters = null;
            } else {
                includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap);
            }
            Map&lt;String, String&gt; excludeMap = INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getAsMap(settings);
            final DiscoveryNodeFilters excludeFilters;
            if (excludeMap.isEmpty()) {
                excludeFilters = null;
            } else {
                excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap);
            }
            Map&lt;String, String&gt; initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.getAsMap(settings);
            final DiscoveryNodeFilters initialRecoveryFilters;
            if (initialRecoveryMap.isEmpty()) {
                initialRecoveryFilters = null;
            } else {
                initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap);
            }
            Version indexCreatedVersion = Version.indexCreated(settings);
            Version indexUpgradedVersion = settings.getAsVersion(IndexMetadata.SETTING_VERSION_UPGRADED, indexCreatedVersion);

            if (primaryTerms == null) {
                initializePrimaryTerms();
            } else if (primaryTerms.length != numberOfShards) {
                throw new IllegalStateException(&quot;primaryTerms length is [&quot; + primaryTerms.length
                    + &quot;] but should be equal to number of shards [&quot; + numberOfShards() + &quot;]&quot;);
            }

            final ActiveShardCount waitForActiveShards = SETTING_WAIT_FOR_ACTIVE_SHARDS.get(settings);
            if (waitForActiveShards.validate(numberOfReplicas) == false) {
                throw new IllegalArgumentException(&quot;invalid &quot; + SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey() +
                                                   &quot;[&quot; + waitForActiveShards + &quot;]: cannot be greater than &quot; +
                                                   &quot;number of shard copies [&quot; + (numberOfReplicas + 1) + &quot;]&quot;);
            }

            final String uuid = settings.get(SETTING_INDEX_UUID, INDEX_UUID_NA_VALUE);

            return new IndexMetadata(
                new Index(index, uuid),
                version,
                mappingVersion,
                settingsVersion,
                primaryTerms,
                state,
                numberOfShards,
                numberOfReplicas,
                tmpSettings,
                mappings.build(),
                tmpAliases.build(),
                customMetadata.build(),
                filledInSyncAllocationIds.build(),
                requireFilters,
                initialRecoveryFilters,
                includeFilters,
                excludeFilters,
                indexCreatedVersion,
                indexUpgradedVersion,
                getRoutingNumShards(),
                routingPartitionSize,
                waitForActiveShards
            );
        }

        public static void toXContent(IndexMetadata indexMetadata, XContentBuilder builder, ToXContent.Params params) throws IOException {
            builder.startObject(indexMetadata.getIndex().getName());

            builder.field(KEY_VERSION, indexMetadata.getVersion());
            builder.field(KEY_MAPPING_VERSION, indexMetadata.getMappingVersion());
            builder.field(KEY_SETTINGS_VERSION, indexMetadata.getSettingsVersion());
            builder.field(KEY_ROUTING_NUM_SHARDS, indexMetadata.getRoutingNumShards());
            builder.field(KEY_STATE, indexMetadata.getState().toString().toLowerCase(Locale.ENGLISH));

            boolean binary = params.paramAsBoolean(&quot;binary&quot;, false);

            builder.startObject(KEY_SETTINGS);
            indexMetadata.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(&quot;flat_settings&quot;, &quot;true&quot;)));
            builder.endObject();

            builder.startArray(KEY_MAPPINGS);
            MappingMetadata mmd = indexMetadata.mapping();
            if (mmd != null) {
                if (binary) {
                    builder.value(mmd.source().compressed());
                } else {
                    builder.map(XContentHelper.convertToMap(new BytesArray(mmd.source().uncompressed()), true).v2());
                }
            }
            builder.endArray();

            for (ObjectObjectCursor&lt;String, DiffableStringMap&gt; cursor : indexMetadata.customData) {
                builder.field(cursor.key);
                builder.map(cursor.value);
            }

            builder.startObject(KEY_ALIASES);
            for (ObjectCursor&lt;AliasMetadata&gt; cursor : indexMetadata.getAliases().values()) {
                AliasMetadata.Builder.toXContent(cursor.value, builder, params);
            }
            builder.endObject();

            builder.startArray(KEY_PRIMARY_TERMS);
            for (int i = 0; i &lt; indexMetadata.getNumberOfShards(); i++) {
                builder.value(indexMetadata.primaryTerm(i));
            }
            builder.endArray();

            builder.startObject(KEY_IN_SYNC_ALLOCATIONS);
            for (IntObjectCursor&lt;Set&lt;String&gt;&gt; cursor : indexMetadata.inSyncAllocationIds) {
                builder.startArray(String.valueOf(cursor.key));
                for (String allocationId : cursor.value) {
                    builder.value(allocationId);
                }
                builder.endArray();
            }
            builder.endObject();

            builder.endObject();
        }

        public static IndexMetadata fromXContent(XContentParser parser) throws IOException {
            if (parser.currentToken() == null) { // fresh parser? move to the first token
                parser.nextToken();
            }
            if (parser.currentToken() == XContentParser.Token.START_OBJECT) {  // on a start object move to next token
                parser.nextToken();
            }
            if (parser.currentToken() != XContentParser.Token.FIELD_NAME) {
                throw new IllegalArgumentException(&quot;expected field name but got a &quot; + parser.currentToken());
            }
            Builder builder = new Builder(parser.currentName());

            String currentFieldName = null;
            XContentParser.Token token = parser.nextToken();
            if (token != XContentParser.Token.START_OBJECT) {
                throw new IllegalArgumentException(&quot;expected object but got a &quot; + token);
            }
            boolean mappingVersion = false;
            boolean settingsVersion = false;
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if (KEY_SETTINGS.equals(currentFieldName)) {
                        builder.settings(Settings.fromXContent(parser));
                    } else if (KEY_MAPPINGS.equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_OBJECT) {
                                String mappingType = currentFieldName;
                                Map&lt;String, Object&gt; mappingSource = MapBuilder.&lt;String, Object&gt;newMapBuilder().put(mappingType, parser.mapOrdered()).map();
                                builder.putMapping(new MappingMetadata(mappingType, mappingSource));
                            } else {
                                throw new IllegalArgumentException(&quot;Unexpected token: &quot; + token);
                            }
                        }
                    } else if (KEY_ALIASES.equals(currentFieldName)) {
                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {
                            builder.putAlias(AliasMetadata.Builder.fromXContent(parser));
                        }
                    } else if (KEY_IN_SYNC_ALLOCATIONS.equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_ARRAY) {
                                String shardId = currentFieldName;
                                Set&lt;String&gt; allocationIds = new HashSet&lt;&gt;();
                                while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                                    if (token == XContentParser.Token.VALUE_STRING) {
                                        allocationIds.add(parser.text());
                                    }
                                }
                                builder.putInSyncAllocationIds(Integer.valueOf(shardId), allocationIds);
                            } else {
                                throw new IllegalArgumentException(&quot;Unexpected token: &quot; + token);
                            }
                        }
                    } else if (&quot;warmers&quot;.equals(currentFieldName)) {
                        // TODO: do this in 6.0:
                        // throw new IllegalArgumentException(&quot;Warmers are not supported anymore - are you upgrading from 1.x?&quot;);
                        // ignore: warmers have been removed in 5.0 and are
                        // simply ignored when upgrading from 2.x
                        assert Version.CURRENT.major &lt;= 5;
                        parser.skipChildren();
                    } else {
                        // assume it's custom index metadata
                        builder.putCustom(currentFieldName, parser.mapStrings());
                    }
                } else if (token == XContentParser.Token.START_ARRAY) {
                    if (KEY_MAPPINGS.equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {
                                builder.putMapping(new MappingMetadata(new CompressedXContent(parser.binaryValue())));
                            } else {
                                Map&lt;String, Object&gt; mapping = parser.mapOrdered();
                                if (mapping.size() == 1) {
                                    String mappingType = mapping.keySet().iterator().next();
                                    builder.putMapping(new MappingMetadata(mappingType, mapping));
                                }
                            }
                        }
                    } else if (KEY_PRIMARY_TERMS.equals(currentFieldName)) {
                        LongArrayList list = new LongArrayList();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            if (token == XContentParser.Token.VALUE_NUMBER) {
                                list.add(parser.longValue());
                            } else {
                                throw new IllegalStateException(&quot;found a non-numeric value under [&quot; + KEY_PRIMARY_TERMS + &quot;]&quot;);
                            }
                        }
                        builder.primaryTerms(list.toArray());
                    } else {
                        throw new IllegalArgumentException(&quot;Unexpected field for an array &quot; + currentFieldName);
                    }
                } else if (token.isValue()) {
                    if (KEY_STATE.equals(currentFieldName)) {
                        builder.state(State.fromString(parser.text()));
                    } else if (KEY_VERSION.equals(currentFieldName)) {
                        builder.version(parser.longValue());
                    } else if (KEY_MAPPING_VERSION.equals(currentFieldName)) {
                        mappingVersion = true;
                        builder.mappingVersion(parser.longValue());
                    } else if (KEY_SETTINGS_VERSION.equals(currentFieldName)) {
                        settingsVersion = true;
                        builder.settingsVersion(parser.longValue());
                    } else if (KEY_ROUTING_NUM_SHARDS.equals(currentFieldName)) {
                        builder.setRoutingNumShards(parser.intValue());
                    } else {
                        throw new IllegalArgumentException(&quot;Unexpected field [&quot; + currentFieldName + &quot;]&quot;);
                    }
                } else {
                    throw new IllegalArgumentException(&quot;Unexpected token &quot; + token);
                }
            }
            if (Assertions.ENABLED &amp;&amp; Version.indexCreated(builder.settings).onOrAfter(Version.V_3_2_0)) {
                assert mappingVersion : &quot;mapping version should be present for indices created on or after 6.5.0&quot;;
            }
            if (Assertions.ENABLED &amp;&amp; Version.indexCreated(builder.settings).onOrAfter(Version.V_3_2_0)) {
                assert settingsVersion : &quot;settings version should be present for indices created on or after 6.5.0&quot;;
            }
            return builder.build();
        }
    }

    /**
     * Adds human readable version and creation date settings.
     * This method is used to display the settings in a human readable format in REST API
     */
    public static Settings addHumanReadableSettings(Settings settings) {
        Settings.Builder builder = Settings.builder().put(settings);
        Version version = SETTING_INDEX_VERSION_CREATED.get(settings);
        if (version != Version.V_EMPTY) {
            builder.put(SETTING_VERSION_CREATED_STRING, version.toString());
        }
        Version versionUpgraded = settings.getAsVersion(SETTING_VERSION_UPGRADED, null);
        if (versionUpgraded != null) {
            builder.put(SETTING_VERSION_UPGRADED_STRING, versionUpgraded.toString());
        }
        Long creationDate = settings.getAsLong(SETTING_CREATION_DATE, null);
        if (creationDate != null) {
            ZonedDateTime creationDateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(creationDate), ZoneOffset.UTC);
            builder.put(SETTING_CREATION_DATE_STRING, creationDateTime.toString());
        }
        return builder.build();
    }

    private static final ToXContent.Params FORMAT_PARAMS = new MapParams(Collections.singletonMap(&quot;binary&quot;, &quot;true&quot;));

    /**
     * State format for {@link IndexMetadata} to write to and load from disk
     */
    public static final MetadataStateFormat&lt;IndexMetadata&gt; FORMAT = new MetadataStateFormat&lt;IndexMetadata&gt;(INDEX_STATE_FILE_PREFIX) {

        @Override
        public void toXContent(XContentBuilder builder, IndexMetadata state) throws IOException {
            Builder.toXContent(state, builder, FORMAT_PARAMS);
        }

        @Override
        public IndexMetadata fromXContent(XContentParser parser) throws IOException {
            return Builder.fromXContent(parser);
        }
    };

    /**
     * Returns the number of shards that should be used for routing. This basically defines the hash space we use in
     * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetadata, String, String)} to route documents
     * to shards based on their ID or their specific routing value. The default value is {@link #getNumberOfShards()}. This value only
     * changes if and index is shrunk.
     */
    public int getRoutingNumShards() {
        return routingNumShards;
    }

    /**
     * Returns the routing factor for this index. The default is {@code 1}.
     *
     * @see #getRoutingFactor(int, int) for details
     */
    public int getRoutingFactor() {
        return routingFactor;
    }

    /**
     * Returns the source shard ID to split the given target shard off
     * @param shardId the id of the target shard to split into
     * @param sourceIndexMetadata the source index metadata
     * @param numTargetShards the total number of shards in the target index
     * @return a the source shard ID to split off from
     */
    public static ShardId selectSplitShard(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
        if (shardId &gt;= numTargetShards) {
            throw new IllegalArgumentException(&quot;the number of target shards (&quot; + numTargetShards + &quot;) must be greater than the shard id: &quot;
                + shardId);
        }
        int numSourceShards = sourceIndexMetadata.getNumberOfShards();
        if (numSourceShards &gt; numTargetShards) {
            throw new IllegalArgumentException(&quot;the number of source shards [&quot; + numSourceShards
                 + &quot;] must be less that the number of target shards [&quot; + numTargetShards + &quot;]&quot;);
        }
        int routingFactor = getRoutingFactor(numSourceShards, numTargetShards);
        // now we verify that the numRoutingShards is valid in the source index
        int routingNumShards = sourceIndexMetadata.getRoutingNumShards();
        if (routingNumShards % numTargetShards != 0) {
            throw new IllegalStateException(&quot;the number of routing shards [&quot;
                + routingNumShards + &quot;] must be a multiple of the target shards [&quot; + numTargetShards + &quot;]&quot;);
        }
        // this is just an additional assertion that ensures we are a factor of the routing num shards.
        assert getRoutingFactor(numTargetShards, sourceIndexMetadata.getRoutingNumShards()) &gt;= 0;
        return new ShardId(sourceIndexMetadata.getIndex(), shardId / routingFactor);
    }

    /**
     * Selects the source shards for a local shard recovery. This might either be a split or a shrink operation.
     * @param shardId the target shard ID to select the source shards for
     * @param sourceIndexMetadata the source metadata
     * @param numTargetShards the number of target shards
     */
    public static Set&lt;ShardId&gt; selectRecoverFromShards(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
        if (sourceIndexMetadata.getNumberOfShards() &gt; numTargetShards) {
            return selectShrinkShards(shardId, sourceIndexMetadata, numTargetShards);
        } else if (sourceIndexMetadata.getNumberOfShards() &lt; numTargetShards) {
            return Collections.singleton(selectSplitShard(shardId, sourceIndexMetadata, numTargetShards));
        }
        throw new IllegalArgumentException(&quot;can't select recover from shards if both indices have the same number of shards&quot;);
    }

    /**
     * Returns the source shard ids to shrink into the given shard id.
     * @param shardId the id of the target shard to shrink to
     * @param sourceIndexMetadata the source index metadata
     * @param numTargetShards the total number of shards in the target index
     * @return a set of shard IDs to shrink into the given shard ID.
     */
    public static Set&lt;ShardId&gt; selectShrinkShards(int shardId, IndexMetadata sourceIndexMetadata, int numTargetShards) {
        if (shardId &gt;= numTargetShards) {
            throw new IllegalArgumentException(&quot;the number of target shards (&quot; + numTargetShards + &quot;) must be greater than the shard id: &quot;
                + shardId);
        }
        if (sourceIndexMetadata.getNumberOfShards() &lt; numTargetShards) {
            throw new IllegalArgumentException(&quot;the number of target shards [&quot; + numTargetShards
                + &quot;] must be less that the number of source shards [&quot; + sourceIndexMetadata.getNumberOfShards() + &quot;]&quot;);
        }
        int routingFactor = getRoutingFactor(sourceIndexMetadata.getNumberOfShards(), numTargetShards);
        Set&lt;ShardId&gt; shards = new HashSet&lt;&gt;(routingFactor);
        for (int i = shardId * routingFactor; i &lt; routingFactor * shardId + routingFactor; i++) {
            shards.add(new ShardId(sourceIndexMetadata.getIndex(), i));
        }
        return shards;
    }

    /**
     * Returns the routing factor for and shrunk index with the given number of target shards.
     * This factor is used in the hash function in
     * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetadata, String, String)} to guarantee consistent
     * hashing / routing of documents even if the number of shards changed (ie. a shrunk index).
     *
     * @param sourceNumberOfShards the total number of shards in the source index
     * @param targetNumberOfShards the total number of shards in the target index
     * @return the routing factor for and shrunk index with the given number of target shards.
     * @throws IllegalArgumentException if the number of source shards is less than the number of target shards or if the source shards
     * are not divisible by the number of target shards.
     */
    public static int getRoutingFactor(int sourceNumberOfShards, int targetNumberOfShards) {
        final int factor;
        if (sourceNumberOfShards &lt; targetNumberOfShards) { // split
            factor = targetNumberOfShards / sourceNumberOfShards;
            if (factor * sourceNumberOfShards != targetNumberOfShards || factor &lt;= 1) {
                throw new IllegalArgumentException(&quot;the number of source shards [&quot; + sourceNumberOfShards + &quot;] must be a must be a &quot; +
                    &quot;factor of [&quot;
                    + targetNumberOfShards + &quot;]&quot;);
            }
        } else if (sourceNumberOfShards &gt; targetNumberOfShards) { // shrink
            factor = sourceNumberOfShards / targetNumberOfShards;
            if (factor * targetNumberOfShards != sourceNumberOfShards || factor &lt;= 1) {
                throw new IllegalArgumentException(&quot;the number of source shards [&quot; + sourceNumberOfShards + &quot;] must be a must be a &quot; +
                    &quot;multiple of [&quot;
                    + targetNumberOfShards + &quot;]&quot;);
            }
        } else {
            factor = 1;
        }
        return factor;
    }


    public static boolean isIndexVerifiedBeforeClosed(final IndexMetadata indexMetadata) {
        return indexMetadata.getState() == IndexMetadata.State.CLOSE
            &amp;&amp; VERIFIED_BEFORE_CLOSE_SETTING.exists(indexMetadata.getSettings())
            &amp;&amp; VERIFIED_BEFORE_CLOSE_SETTING.get(indexMetadata.getSettings());
    }
}
</PRE>
</div>
  </div>
</body>
</html>
