<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for NetworkDisruption.java &amp; InsertFromValues.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for NetworkDisruption.java &amp; InsertFromValues.java
      </h3>
<h1 align="center">
        10.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>NetworkDisruption.java (14.048338%)<th>InsertFromValues.java (7.9965606%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(94-117)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(496-507)<td><a href="#" name="1">(846-857)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(378-383)<td><a href="#" name="2">(837-842)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(173-180)<td><a href="#" name="3">(817-824)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(56-63)<td><a href="#" name="4">(118-126)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(477-488)<td><a href="#" name="5">(732-736)</a><td align="center"><font color="#6d0000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(250-254)<td><a href="#" name="6">(656-660)</a><td align="center"><font color="#6d0000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(180-186)<td><a href="#" name="7">(825-831)</a><td align="center"><font color="#6d0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>NetworkDisruption.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.test.disruption;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.carrotsearch.randomizedtesting.generators.RandomPicks;
4 import org.apache.logging.log4j.LogManager;
5 import org.apache.logging.log4j.Logger;
6 import org.elasticsearch.cluster.ClusterState;
7 import org.elasticsearch.cluster.NodeConnectionsService;
8 import org.elasticsearch.cluster.service.ClusterService;
9 import io.crate.common.unit.TimeValue;
10 import io.crate.common.collections.Sets;
11 import org.elasticsearch.test.InternalTestCluster;
12 import org.elasticsearch.test.transport.MockTransportService;
13 import org.elasticsearch.transport.ConnectTransportException;
14 import org.elasticsearch.transport.TransportService;
15 import java.util.Collection;
16 import java.util.Collections;
17 import java.util.HashSet;
18 import java.util.Random;
19 import java.util.Set;
20 import java.util.concurrent.CountDownLatch;
21 import java.util.function.BiConsumer;
22 public class NetworkDisruption implements ServiceDisruptionScheme {
23     private final Logger logger = LogManager.getLogger(NetworkDisruption.class)</b></font>;
24     private final DisruptedLinks disruptedLinks;
25 <a name="4"></a>    private final NetworkLinkDisruptionType networkLinkDisruptionType;
26     protected volatile InternalTestCluster cluster;
27     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>protected volatile boolean activeDisruption = false;
28     public NetworkDisruption(DisruptedLinks disruptedLinks, NetworkLinkDisruptionType networkLinkDisruptionType) {
29         this.disruptedLinks = disruptedLinks;
30         this.networkLinkDisruptionType = networkLinkDisruptionType;
31     }
32     public DisruptedL</b></font>inks getDisruptedLinks() {
33         return disruptedLinks;
34     }
35     public NetworkLinkDisruptionType getNetworkLinkDisruptionType() {
36         return networkLinkDisruptionType;
37     }
38     @Override
39     public void applyToCluster(InternalTestCluster cluster) {
40         this.cluster = cluster;
41     }
42     @Override
43     public void removeFromCluster(InternalTestCluster cluster) {
44         stopDisrupting();
45     }
46     @Override
47     public void removeAndEnsureHealthy(InternalTestCluster cluster) {
48         removeFromCluster(cluster);
49         ensureHealthy(cluster);
50     }
51     public void ensureHealthy(InternalTestCluster cluster) {
52         assert activeDisruption == false;
53         ensureNodeCount(cluster);
54         ensureFullyConnectedCluster(cluster);
55     }
56     public static void ensureFullyConnectedCluster(InternalTestCluster cluster) {
57         final String[] nodeNames = cluster.getNodeNames();
58         final CountDownLatch countDownLatch = new CountDownLatch(nodeNames.length);
59         for (String node : nodeNames) {
60             ClusterState stateOnNode = cluster.getInstance(ClusterService.class, node).state();
61             cluster.getInstance(NodeConnectionsService.class, node).reconnectToNodes(stateOnNode.nodes(), countDownLatch::countDown);
62         }
63         try {
64             countDownLatch.await();
65         } catch (InterruptedException e) {
66             throw new AssertionError(e);
67         }
68     }
69     protected void ensureNodeCount(InternalTestCluster cluster) {
70         cluster.validateClusterFormed();
71     }
72     @Override
73     public synchronized void applyToNode(String node, InternalTestCluster cluster) {
74     }
75     @Override
76     public synchronized void removeFromNode(String node1, InternalTestCluster cluster) {
77         logger.info("stop disrupting node (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
78         applyToNodes(new String[]{ node1 }, cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption);
79         applyToNodes(cluster.getNodeNames(), new String[]{ node1 }, networkLinkDisruptionType::removeDisruption);
80     }
81     @Override
82     public synchronized void testClusterClosed() {
83     }
84     @Override
85     public synchronized void startDisrupting() {
86         logger.info("start disrupting (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
87         applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::applyDisruption);
88         activeDisruption = true;
89     }
90     @Override
91     public synchronized void stopDisrupting() {
92         if (!activeDisruption) {
93             return;
94         }
95         logger.info("stop disrupting (disruption scheme: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
96         applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption);
97         activeDisruption = false;
98     }
99     private void applyToNodes(String[] nodes1, String[] nodes2, BiConsumer&lt;MockTransportService, MockTransportService&gt; consumer) {
100         for (String node1 : nodes1) {
101             if (disruptedLinks.nodes().contains(node1)) {
102                 for (String node2 : nodes2) {
103                     if (disruptedLinks.nodes().contains(node2)) {
104                         if (node1.equals(node2) == false) {
105                             if (disruptedLinks.disrupt(node1, node2)) {
106                                 consumer.accept(transport(node1), transport(node2));
107                             }
108                         }
109                     }
110 <a name="3"></a>                }
111             }
112         }
113     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
114     @Override
115     public TimeValue expectedTimeToHeal() {
116 <a name="7"></a>        return networkLinkDisruptionType.expectedTimeToHeal();
117     }
118     private M</b></font>ockTransportService transport(String node) <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
119         return (MockTransportService) cluster.getInstance(TransportService.class, node);
120     }
121     @Override
122     public String toString() {
123         return</b></font> "network disruption (disruption type: " + networkLinkDisruptionType + ", disrupted links: " + disruptedLinks + ")";
124     }
125     public abstract static class DisruptedLinks {
126         private final Set&lt;String&gt; nodes;
127         protected DisruptedLinks(Set&lt;String&gt;... nodeSets) {
128             Set&lt;String&gt; allNodes = new HashSet&lt;&gt;();
129             for (Set&lt;String&gt; nodeSet : nodeSets) {
130                 allNodes.addAll(nodeSet);
131             }
132             this.nodes = allNodes;
133         }
134         public Set&lt;String&gt; nodes() {
135             return nodes;
136         }
137         public abstract boolean disrupt(String node1, String node2);
138     }
139     public static class TwoPartitions extends DisruptedLinks {
140         protected final Set&lt;String&gt; nodesSideOne;
141         protected final Set&lt;String&gt; nodesSideTwo;
142         public TwoPartitions(String node1, String node2) {
143             this(Collections.singleton(node1), Collections.singleton(node2));
144         }
145         public TwoPartitions(Set&lt;String&gt; nodesSideOne, Set&lt;String&gt; nodesSideTwo) {
146             super(nodesSideOne, nodesSideTwo);
147             this.nodesSideOne = nodesSideOne;
148             this.nodesSideTwo = nodesSideTwo;
149             assert nodesSideOne.isEmpty() == false;
150             assert nodesSideTwo.isEmpty() == false;
151             assert Sets.haveEmptyIntersection(nodesSideOne, nodesSideTwo);
152         }
153         public static TwoPartitions random(Random random, String... nodes) {
154             return random(random, Set.of(nodes));
155         }
156         public static TwoPartitions random(Random random, Set&lt;String&gt; nodes) {
157             assert nodes.size() &gt;= 2 : "two partitions topology requires at least 2 nodes";
158             Set&lt;String&gt; nodesSideOne = new HashSet&lt;&gt;();
159             Set&lt;String&gt; nodesSideTwo = new HashSet&lt;&gt;();
160             for (String node : nodes) {
161                 if (nodesSideOne.isEmpty()) {
162 <a name="6"></a>                    nodesSideOne.add(node);
163                 } else if (nodesSideTwo.isEmpty()) {
164                     nodesSideTwo.add(node);
165                 } else if (<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>random.nextBoolean()) {
166                     nodesSideOne.add(node);
167                 } else {
168                     nodesSideTwo.add(node);
169                 }</b></font>
170             }
171             return new TwoPartitions(nodesSideOne, nodesSideTwo);
172         }
173         @Override
174         public boolean disrupt(String node1, String node2) {
175             if (nodesSideOne.contains(node1) &amp;&amp; nodesSideTwo.contains(node2)) {
176                 return true;
177             }
178             if (nodesSideOne.contains(node2) &amp;&amp; nodesSideTwo.contains(node1)) {
179                 return true;
180             }
181             return false;
182         }
183         public Set&lt;String&gt; getNodesSideOne() {
184             return Collections.unmodifiableSet(nodesSideOne);
185         }
186         public Set&lt;String&gt; getNodesSideTwo() {
187             return Collections.unmodifiableSet(nodesSideTwo);
188         }
189         public Collection&lt;String&gt; getMajoritySide() {
190             if (nodesSideOne.size() &gt;= nodesSideTwo.size()) {
191                 return getNodesSideOne();
192             } else {
193                 return getNodesSideTwo();
194             }
195         }
196         public Collection&lt;String&gt; getMinoritySide() {
197             if (nodesSideOne.size() &gt;= nodesSideTwo.size()) {
198                 return getNodesSideTwo();
199             } else {
200                 return getNodesSideOne();
201             }
202         }
203         @Override
204         public String toString() {
205             return "two partitions (partition 1: " + nodesSideOne + " and partition 2: " + nodesSideTwo + ")";
206         }
207     }
208     public static class Bridge extends DisruptedLinks {
209         private final String bridgeNode;
210         private final Set&lt;String&gt; nodesSideOne;
211         private final Set&lt;String&gt; nodesSideTwo;
212         public Bridge(String bridgeNode, Set&lt;String&gt; nodesSideOne, Set&lt;String&gt; nodesSideTwo) {
213             super(Collections.singleton(bridgeNode), nodesSideOne, nodesSideTwo);
214             this.bridgeNode = bridgeNode;
215             this.nodesSideOne = nodesSideOne;
216             this.nodesSideTwo = nodesSideTwo;
217             assert nodesSideOne.isEmpty() == false;
218             assert nodesSideTwo.isEmpty() == false;
219             assert Sets.haveEmptyIntersection(nodesSideOne, nodesSideTwo);
220             assert nodesSideOne.contains(bridgeNode) == false &amp;&amp; nodesSideTwo.contains(bridgeNode) == false;
221         }
222         public static Bridge random(Random random, String... nodes) {
223             return random(random, Set.of(nodes));
224         }
225         public static Bridge random(Random random, Set&lt;String&gt; nodes) {
226             assert nodes.size() &gt;= 3 : "bridge topology requires at least 3 nodes";
227             String bridgeNode = RandomPicks.randomFrom(random, nodes);
228             Set&lt;String&gt; nodesSideOne = new HashSet&lt;&gt;();
229             Set&lt;String&gt; nodesSideTwo = new HashSet&lt;&gt;();
230             for (String node : nodes) {
231                 if (node.equals(bridgeNode) == false) {
232                     if (nodesSideOne.isEmpty()) {
233                         nodesSideOne.add(node);
234                     } else if (nodesSideTwo.isEmpty()) {
235                         nodesSideTwo.add(node);
236                     } else if (random.nextBoolean()) {
237                         nodesSideOne.add(node);
238                     } else {
239                         nodesSideTwo.add(node);
240                     }
241                 }
242             }
243             return new Bridge(bridgeNode, nodesSideOne, nodesSideTwo);
244         }
245         @Override
246         public boolean disrupt(String node1, String node2) {
247             if (nodesSideOne.contains(node1) &amp;&amp; nodesSideTwo.contains(node2)) {
248                 return true;
249             }
250             if (nodesSideOne.contains(node2) &amp;&amp; nodesSideTwo.contains(node1)) {
251                 return true;
252             }
253             return false;
254         }
255         public String getBridgeNode() {
256             return bridgeNode;
257         }
258         public Set&lt;String&gt; getNodesSideOne() {
259             return nodesSideOne;
260         }
261         public Set&lt;String&gt; getNodesSideTwo() {
262             return nodesSideTwo;
263         }
264         public String toString() {
265             return "bridge partition (super connected node: [" + bridgeNode + "], partition 1: " + nodesSideOne +
266                 " and partition 2: " + nodesSideTwo + ")";
267         }
268     }
269     public static class IsolateAllNodes extends DisruptedLinks {
270 <a name="2"></a>
271         public IsolateAllNodes(Set&lt;String&gt; nodes) {
272             super(nodes);
273         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
274         @Override
275         public boolean disrupt(String node1, String node2) {
276             return true;
277         }</b></font>
278     }
279     public abstract static class NetworkLinkDisruptionType {
280         public abstract void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService);
281         public void removeDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
282             sourceTransportService.clearOutboundRules(targetTransportService);
283         }
284         public TimeValue expectedTimeToHeal() {
285             return TimeValue.timeValueMillis(0);
286         }
287     }
288     public static class NetworkDisconnect extends NetworkLinkDisruptionType {
289         @Override
290         public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
291             sourceTransportService.addFailToSendNoConnectRule(targetTransportService);
292         }
293         @Override
294         public String toString() {
295             return "network disconnects";
296         }
297     }
298     public static class NetworkUnresponsive extends NetworkLinkDisruptionType {
299         @Override
300         public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
301             sourceTransportService.addUnresponsiveRule(targetTransportService);
302         }
303         @Override
304         public String toString() {
305             return "network unresponsive";
306         }
307     }
308     public static class NetworkDelay extends NetworkLinkDisruptionType {
309         public static TimeValue DEFAULT_DELAY_MIN = TimeValue.timeValueSeconds(10);
310         public static TimeValue DEFAULT_DELAY_MAX = TimeValue.timeValueSeconds(90);
311         private final TimeValue delay;
312         public NetworkDelay(TimeValue delay) {
313             this.delay = delay;
314         }
315         public static NetworkDelay random(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Random random) {
316             return random(random, DEFAULT_DELAY_MIN, DEFAULT_DELAY_MAX);
317         }
318         public static NetworkDelay random(Random random, TimeValue delayMin</b></font>, TimeValue delayMax) {
319             return new NetworkDelay(TimeValue.timeValueMillis(delayMin.millis() == delayMax.millis() ?
320                     delayMin.millis() :
321                     delayMin.millis() + random.nextInt((int) (delayMax.millis() - delayMin.millis()))));
322         }
323 <a name="1"></a>
324         @Override
325         public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
326             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sourceTransportService.addUnresponsiveRule(targetTransportService, delay);
327         }
328         @Override
329         public TimeValue expectedTimeToHeal() {
330             return delay;
331         }
332         @Override
333         public String toString() {
334             return "network delays for [" + delay + "]";
335         }</b></font>
336     }
337 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>InsertFromValues.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.planner.operators;
2 import static io.crate.data.SentinelRow.SENTINEL;
3 import static io.crate.execution.engine.indexing.ShardingUpsertExecutor.BULK_REQUEST_TIMEOUT_SETTING;
4 import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_CLOSED_BLOCK;
5 import java.util.ArrayList;
6 import java.util.Arrays;
7 import java.util.Collection;
8 import java.util.HashMap;
9 import java.util.Iterator;
10 import java.util.List;
11 import java.util.Map;
12 import java.util.Set;
13 import java.util.UUID;
14 import java.util.concurrent.CompletableFuture;
15 import java.util.concurrent.ScheduledExecutorService;
16 import java.util.concurrent.atomic.AtomicInteger;
17 import java.util.concurrent.atomic.AtomicReference;
18 import java.util.function.Consumer;
19 import java.util.function.Function;
20 import java.util.function.Supplier;
21 import java.util.stream.StreamSupport;
22 import javax.annotation.Nullable;
23 import com.carrotsearch.hppc.IntArrayList;
24 import org.elasticsearch.action.ActionListener;
25 import org.elasticsearch.action.admin.indices.create.CreatePartitionsRequest;
26 import org.elasticsearch.action.admin.indices.create.TransportCreatePartitionsAction;
27 import org.elasticsearch.action.bulk.BackoffPolicy;
28 import org.elasticsearch.action.support.master.AcknowledgedResponse;
29 import org.elasticsearch.cluster.ClusterState;
30 import org.elasticsearch.cluster.block.ClusterBlock;
31 import org.elasticsearch.cluster.block.ClusterBlockException;
32 import org.elasticsearch.cluster.metadata.Metadata;
33 import org.elasticsearch.cluster.routing.ShardIterator;
34 import org.elasticsearch.cluster.routing.ShardRouting;
35 import org.elasticsearch.cluster.service.ClusterService;
36 import org.elasticsearch.common.io.stream.NotSerializableExceptionWrapper;
37 import org.elasticsearch.index.IndexNotFoundException;
38 import io.crate.action.FutureActionListener;
39 import io.crate.analyze.OrderBy;
40 import io.crate.analyze.SymbolEvaluator;
41 import io.crate.analyze.relations.AbstractTableRelation;
42 import io.crate.analyze.relations.TableFunctionRelation;
43 import io.crate.breaker.RamAccounting;
44 import io.crate.breaker.TypeGuessEstimateRowSize;
45 import io.crate.concurrent.limits.ConcurrencyLimit;
46 import io.crate.data.CollectionBucket;
47 import io.crate.data.InMemoryBatchIterator;
48 import io.crate.data.Input;
49 import io.crate.data.Row;
50 import io.crate.data.Row1;
51 import io.crate.data.RowConsumer;
52 import io.crate.data.RowN;
53 import io.crate.exceptions.ColumnValidationException;
54 import io.crate.exceptions.SQLExceptions;
55 import io.crate.execution.dml.ShardRequest;
56 import io.crate.execution.dml.ShardResponse;
57 import io.crate.execution.dml.upsert.InsertSourceFromCells;
58 import io.crate.execution.dml.upsert.ShardUpsertRequest;
59 import io.crate.execution.dml.upsert.TransportShardUpsertAction;
60 import io.crate.execution.dsl.projection.ColumnIndexWriterProjection;
61 import io.crate.execution.dsl.projection.builder.InputColumns;
62 import io.crate.execution.dsl.projection.builder.ProjectionBuilder;
63 import io.crate.execution.engine.collect.CollectExpression;
64 <a name="0"></a>import io.crate.execution.engine.collect.RowShardResolver;
65 import io.crate.execution.engine.indexing.GroupRowsByShard;
66 import io.crate.execution.engine.indexing.IndexNameResolver;
67 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io.crate.execution.engine.indexing.ShardLocation;
68 import io.crate.execution.engine.indexing.ShardedRequests;
69 import io.crate.execution.jobs.NodeLimits;
70 import io.crate.execution.support.RetryListener;
71 import io.crate.expression.InputFactory;
72 import io.crate.expression.InputRow;
73 import io.crate.expression.symbol.Assignments;
74 import io.crate.expression.symbol.SelectSymbol;
75 import io.crate.expression.symbol.Symbol;
76 import io.crate.metadata.IndexParts;
77 import io.crate.metadata.Reference;
78 import io.crate.metadata.doc.DocTableInfo;
79 import io.crate.metadata.table.Operation;
80 import io.crate.metadata.tablefunctions.TableFunctionImplementation;
81 import io.crate.planner.DependencyCarrier;
82 import io.crate.planner.ExecutionPlan;
83 import io.crate.planner.PlannerContext;
84 import io.crate.statistics.TableStats;
85 import io.crate.types.DataType;
86 <a name="4"></a>public class InsertFromValues implements LogicalPlan {
87     private final TableFunctionRelation tableFunctionRelation</b></font>;
88     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final ColumnIndexWriterProjection writerProjection;
89     InsertFromValues(TableFunctionRelation tableFunctionRelation,
90                      ColumnIndexWriterProjection writerProjection) {
91         this.tableFunctionRelation = tableFunctionRelation;
92         this.writerProjection = writerProjection;
93     }
94     @Ove</b></font>rride
95     public StatementType type() {
96         return StatementType.INSERT;
97     }
98     @Override
99     public void execute(DependencyCarrier dependencies,
100                         PlannerContext plannerContext,
101                         RowConsumer consumer,
102                         Row params,
103                         SubQueryResults subQueryResults) {
104         DocTableInfo tableInfo = dependencies
105             .schemas()
106             .getTableInfo(writerProjection.tableIdent(), Operation.INSERT);
107         //
108         //
109         //
110         InputFactory inputFactory = new InputFactory(dependencies.nodeContext());
111         InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; context =
112             inputFactory.ctxForInputColumns(plannerContext.transactionContext());
113         var allColumnSymbols = InputColumns.create(
114             writerProjection.allTargetColumns(),
115             new InputColumns.SourceSymbols(writerProjection.allTargetColumns()));
116         ArrayList&lt;Input&lt;?&gt;&gt; insertInputs = new ArrayList&lt;&gt;(allColumnSymbols.size());
117         for (Symbol symbol : allColumnSymbols) {
118             insertInputs.add(context.add(symbol));
119         }
120         ArrayList&lt;Input&lt;?&gt;&gt; partitionedByInputs = new ArrayList&lt;&gt;(writerProjection.partitionedBySymbols().size());
121         for (Symbol partitionedBySymbol : writerProjection.partitionedBySymbols()) {
122             partitionedByInputs.add(context.add(partitionedBySymbol));
123         }
124         ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs = new ArrayList&lt;&gt;(writerProjection.ids().size());
125         for (Symbol symbol : writerProjection.ids()) {
126             primaryKeyInputs.add(context.add(symbol));
127         }
128         Input&lt;?&gt; clusterByInput;
129         if (writerProjection.clusteredBy() != null) {
130             clusterByInput = context.add(writerProjection.clusteredBy());
131         } else {
132             clusterByInput = null;
133         }
134         String[] updateColumnNames;
135         Symbol[] assignmentSources;
136         if (writerProjection.onDuplicateKeyAssignments() == null) {
137             updateColumnNames = null;
138             assignmentSources = null;
139         } else {
140             Assignments assignments = Assignments.convert(
141                 writerProjection.onDuplicateKeyAssignments(),
142                 dependencies.nodeContext()
143             );
144             assignmentSources = assignments.bindSources(tableInfo, params, subQueryResults);
145             updateColumnNames = assignments.targetNames();
146         }
147         var indexNameResolver = IndexNameResolver.create(
148             writerProjection.tableIdent(),
149             writerProjection.partitionIdent(),
150             partitionedByInputs);
151         GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt; grouper =
152             createRowsByShardGrouper(
153                 assignmentSources,
154                 insertInputs,
155                 indexNameResolver,
156                 context,
157                 plannerContext,
158                 dependencies.clusterService());
159         ArrayList&lt;Row&gt; rows = new ArrayList&lt;&gt;();
160         evaluateValueTableFunction(
161             tableFunctionRelation.functionImplementation(),
162             tableFunctionRelation.function().arguments(),
163             writerProjection.allTargetColumns(),
164             tableInfo,
165             params,
166             plannerContext,
167             subQueryResults
168         ).forEachRemaining(rows::add);
169         List&lt;Symbol&gt; returnValues = this.writerProjection.returnValues();
170         ShardUpsertRequest.Builder builder = new ShardUpsertRequest.Builder(
171             plannerContext.transactionContext().sessionSettings(),
172             BULK_REQUEST_TIMEOUT_SETTING.get(dependencies.settings()),
173             writerProjection.isIgnoreDuplicateKeys()
174                 ? ShardUpsertRequest.DuplicateKeyAction.IGNORE
175                 : ShardUpsertRequest.DuplicateKeyAction.UPDATE_OR_FAIL,
176             rows.size() &gt; 1,             updateColumnNames,
177             writerProjection.allTargetColumns().toArray(new Reference[0]),
178             returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[0]),
179             plannerContext.jobId(),
180             false);
181         var shardedRequests = new ShardedRequests&lt;&gt;(builder::newRequest, RamAccounting.NO_ACCOUNTING);
182         HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache = new HashMap&lt;&gt;();
183         for (Row row : rows) {
184             grouper.accept(shardedRequests, row);
185             try {
186                 checkPrimaryKeyValuesNotNull(primaryKeyInputs);
187                 checkClusterByValueNotNull(clusterByInput);
188                 checkConstraintsOnGeneratedSource(
189                     row.materialize(),
190                     indexNameResolver.get(),
191                     tableInfo,
192                     plannerContext,
193                     validatorsCache);
194             } catch (Throwable t) {
195                 consumer.accept(null, t);
196                 return;
197             }
198         }
199         validatorsCache.clear();
200         var actionProvider = dependencies.transportActionProvider();
201         createIndices(
202             actionProvider.transportBulkCreateIndicesAction(),
203             shardedRequests.itemsByMissingIndex().keySet(),
204             dependencies.clusterService(),
205             plannerContext.jobId()
206         ).thenCompose(acknowledgedResponse -&gt; {
207             var shardUpsertRequests = resolveAndGroupShardRequests(
208                 shardedRequests,
209                 dependencies.clusterService()).values();
210             return execute(
211                 dependencies.nodeLimits(),
212                 dependencies.clusterService().state(),
213                 shardUpsertRequests,
214                 actionProvider.transportShardUpsertAction(),
215                 dependencies.scheduler());
216         }).whenComplete((response, t) -&gt; {
217             if (t == null) {
218                 if (returnValues.isEmpty()) {
219                     consumer.accept(InMemoryBatchIterator.of(new Row1((long) response.numSuccessfulWrites()), SENTINEL),
220                                     null);
221                 } else {
222                     consumer.accept(InMemoryBatchIterator.of(new CollectionBucket(response.resultRows()), SENTINEL, false), null);
223                 }
224             } else {
225                 consumer.accept(null, t);
226             }
227         });
228     }
229     @Override
230     public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier dependencies,
231                                                      PlannerContext plannerContext,
232                                                      List&lt;Row&gt; bulkParams,
233                                                      SubQueryResults subQueryResults) {
234         DocTableInfo tableInfo = dependencies
235             .schemas()
236             .getTableInfo(writerProjection.tableIdent(), Operation.INSERT);
237         String[] updateColumnNames;
238         Assignments assignments;
239         if (writerProjection.onDuplicateKeyAssignments() == null) {
240             assignments = null;
241             updateColumnNames = null;
242         } else {
243             assignments = Assignments.convert(writerProjection.onDuplicateKeyAssignments(), dependencies.nodeContext());
244             updateColumnNames = assignments.targetNames();
245         }
246         InputFactory inputFactory = new InputFactory(dependencies.nodeContext());
247         InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; context =
248             inputFactory.ctxForInputColumns(plannerContext.transactionContext());
249         var allColumnSymbols = InputColumns.create(
250             writerProjection.allTargetColumns(),
251             new InputColumns.SourceSymbols(writerProjection.allTargetColumns()));
252         ArrayList&lt;Input&lt;?&gt;&gt; insertInputs = new ArrayList&lt;&gt;(allColumnSymbols.size());
253         for (Symbol symbol : allColumnSymbols) {
254             insertInputs.add(context.add(symbol));
255         }
256         ArrayList&lt;Input&lt;?&gt;&gt; partitionedByInputs = new ArrayList&lt;&gt;(writerProjection.partitionedBySymbols().size());
257         for (Symbol partitionedBySymbol : writerProjection.partitionedBySymbols()) {
258             partitionedByInputs.add(context.add(partitionedBySymbol));
259         }
260         ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs = new ArrayList&lt;&gt;(writerProjection.ids().size());
261         for (Symbol symbol : writerProjection.ids()) {
262             primaryKeyInputs.add(context.add(symbol));
263         }
264         Input&lt;?&gt; clusterByInput;
265         if (writerProjection.clusteredBy() != null) {
266             clusterByInput = context.add(writerProjection.clusteredBy());
267         } else {
268             clusterByInput = null;
269         }
270         var indexNameResolver = IndexNameResolver.create(
271             writerProjection.tableIdent(),
272             writerProjection.partitionIdent(),
273             partitionedByInputs);
274         ShardUpsertRequest.Builder builder = new ShardUpsertRequest.Builder(
275             plannerContext.transactionContext().sessionSettings(),
276             BULK_REQUEST_TIMEOUT_SETTING.get(dependencies.settings()),
277             writerProjection.isIgnoreDuplicateKeys()
278                 ? ShardUpsertRequest.DuplicateKeyAction.IGNORE
279                 : ShardUpsertRequest.DuplicateKeyAction.UPDATE_OR_FAIL,
280             true,             updateColumnNames,
281             writerProjection.allTargetColumns().toArray(new Reference[0]),
282             null,
283             plannerContext.jobId(),
284             true);
285         var shardedRequests = new ShardedRequests&lt;&gt;(builder::newRequest, RamAccounting.NO_ACCOUNTING);
286         HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache = new HashMap&lt;&gt;();
287         IntArrayList bulkIndices = new IntArrayList();
288         List&lt;CompletableFuture&lt;Long&gt;&gt; results = createUnsetFutures(bulkParams.size());
289         for (int bulkIdx = 0; bulkIdx &lt; bulkParams.size(); bulkIdx++) {
290             Row param = bulkParams.get(bulkIdx);
291             final Symbol[] assignmentSources;
292             if (assignments != null) {
293                 assignmentSources = assignments.bindSources(tableInfo, param, subQueryResults);
294             } else {
295                 assignmentSources = null;
296             }
297             GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt; grouper =
298                 createRowsByShardGrouper(
299                     assignmentSources,
300                     insertInputs,
301                     indexNameResolver,
302                     context,
303                     plannerContext,
304                     dependencies.clusterService());
305             try {
306                 Iterator&lt;Row&gt; rows = evaluateValueTableFunction(
307                     tableFunctionRelation.functionImplementation(),
308                     tableFunctionRelation.function().arguments(),
309                     writerProjection.allTargetColumns(),
310                     tableInfo,
311                     param,
312                     plannerContext,
313                     subQueryResults);
314                 while (rows.hasNext()) {
315                     Row row = rows.next();
316                     grouper.accept(shardedRequests, row);
317                     checkPrimaryKeyValuesNotNull(primaryKeyInputs);
318                     checkClusterByValueNotNull(clusterByInput);
319                     checkConstraintsOnGeneratedSource(
320                         row.materialize(),
321                         indexNameResolver.get(),
322                         tableInfo,
323                         plannerContext,
324                         validatorsCache);
325                     bulkIndices.add(bulkIdx);
326                 }
327             } catch (Throwable t) {
328                 for (CompletableFuture&lt;Long&gt; result : results) {
329                     result.completeExceptionally(t);
330                 }
331                 return results;
332             }
333         }
334         validatorsCache.clear();
335         var actionProvider = dependencies.transportActionProvider();
336         createIndices(
337             actionProvider.transportBulkCreateIndicesAction(),
338             shardedRequests.itemsByMissingIndex().keySet(),
339             dependencies.clusterService(), plannerContext.jobId()
340         ).thenCompose(acknowledgedResponse -&gt; {
341             var shardUpsertRequests = resolveAndGroupShardRequests(
342                 shardedRequests,
343                 dependencies.clusterService()).values();
344             return execute(
345                 dependencies.nodeLimits(),
346                 dependencies.clusterService().state(),
347                 shardUpsertRequests,
348                 actionProvider.transportShardUpsertAction(),
349                 dependencies.scheduler());
350         }).whenComplete((response, t) -&gt; {
351             if (t == null) {
352                 long[] resultRowCount = createBulkResponse(response, bulkParams.size(), bulkIndices);
353                 for (int i = 0; i &lt; bulkParams.size(); i++) {
354                     results.get(i).complete(resultRowCount[i]);
355                 }
356             } else {
357                 for (CompletableFuture&lt;Long&gt; result : results) {
358                     result.completeExceptionally(t);
359                 }
360             }
361         });
362         return results;
363     }
364     private GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt;
365         createRowsByShardGrouper(Symbol[] assignmentSources,
366                                  ArrayList&lt;Input&lt;?&gt;&gt; insertInputs,
367                                  Supplier&lt;String&gt; indexNameResolver,
368                                  InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; collectContext,
369                                  PlannerContext plannerContext,
370                                  ClusterService clusterService) {
371         InputRow insertValues = new InputRow(insertInputs);
372         Function&lt;String, ShardUpsertRequest.Item&gt; itemFactory = id -&gt;
373             new ShardUpsertRequest.Item(
374                 id,
375                 assignmentSources,
376                 insertValues.materialize(),
377                 null, null, null);
378         var rowShardResolver = new RowShardResolver(
379             plannerContext.transactionContext(),
380             plannerContext.nodeContext(),
381             writerProjection.primaryKeys(),
382             writerProjection.ids(),
383             writerProjection.clusteredByIdent(),
384             writerProjection.clusteredBy());
385         return new GroupRowsByShard&lt;&gt;(
386             clusterService,
387             rowShardResolver,
388             new TypeGuessEstimateRowSize(),
389             indexNameResolver,
390             collectContext.expressions(),
391             itemFactory,
392             true
393         );
394     }
395     private static void checkPrimaryKeyValuesNotNull(ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs) {
396         for (var primaryKey : primaryKeyInputs) {
397             if (primaryKey.value() == null) {
398                 throw new IllegalArgumentException("Primary key value must not be NULL");
399             }
400         }
401     }
402     private static void checkClusterByValueNotNull(@Nullable Input&lt;?&gt; clusterByInput) {
403         if (clusterByInput != null &amp;&amp; clusterByInput.value() == null) {
404             throw new IllegalArgumentException("Clustered by value must not be NULL");
405         }
406     }
407     private void checkConstraintsOnGeneratedSource(Object[] cells,
408                                                    String indexName,
409                                                    DocTableInfo tableInfo,
410                                                    PlannerContext plannerContext,
411                                                    HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache) throws Throwable {
412         var validator = validatorsCache.computeIfAbsent(
413             indexName,
414             index -&gt; new InsertSourceFromCells(
415                 plannerContext.transactionContext(),
416                 plannerContext.nodeContext(),
417                 tableInfo,
418                 index,
419                 true,
420                 writerProjection.allTargetColumns()));
421         validator.generateSourceAndCheckConstraints(cells);
422     }
423     private static Iterator&lt;Row&gt; evaluateValueTableFunction(TableFunctionImplementation&lt;?&gt; funcImplementation,
424                                                             List&lt;Symbol&gt; arguments,
425                                                             List&lt;Reference&gt; allTargetReferences,
426                                                             DocTableInfo tableInfo,
427                                                             Row params,
428                                                             PlannerContext plannerContext,
429                                                             SubQueryResults subQueryResults) {
430         SymbolEvaluator symbolEval = new SymbolEvaluator(
431             plannerContext.transactionContext(),
432             plannerContext.nodeContext(),
433             subQueryResults);
434         Function&lt;? super Symbol, Input&lt;?&gt;&gt; eval = (symbol) -&gt; symbol.accept(symbolEval, params);
435         ArrayList&lt;Input&lt;?&gt;&gt; boundArguments = new ArrayList&lt;&gt;(arguments.size());
436         for (int i = 0; i &lt; arguments.size(); i++) {
437             boundArguments.add(eval.apply(arguments.get(i)));
438         }
439         //noinspection unchecked
440         Iterable&lt;Row&gt; rows = funcImplementation.evaluate(
441             plannerContext.transactionContext(),
442             plannerContext.nodeContext(),
443             boundArguments.toArray(new Input[0]));
444         return StreamSupport.stream(rows.spliterator(), false)
445             .map(row -&gt; cast(row, allTargetReferences, tableInfo))
446             .iterator();
447     }
448     private static Row cast(Row row, List&lt;Reference&gt; columnReferences, DocTableInfo tableInfo) {
449         if (row == null) {
450             return null;
451         }
452         Object[] cells = new Object[row.numColumns()];
453         for (int i = 0; i &lt; cells.length; i++) {
454             Reference reference = columnReferences.get(i);
455             DataType&lt;?&gt; targetType = reference.valueType();
456             Object value = row.get(i);
457             try {
458                 cells[i] = targetType.implicitCast(value);
459             } catch (IllegalArgumentException | ClassCastException e) {
460                 throw new ColumnValidationException(
461                     reference.column().name(),
462                     tableInfo.ident(),
463                     "Invalid value '" + value + "' for type '" + targetType + "'");
464             }
465         }
466         return new RowN(cells);
467     }
468     private static ShardLocation getShardLocation(String indexName,
469                                                   String id,
470                                                   @Nullable String routing,
471                                                   ClusterService clusterService) {
472         ShardIterator shardIterator = clusterService.operationRouting().indexShards(
473             clusterService.state(),
474             indexName,
475             id,
476             routing);
477         final String nodeId;
478         ShardRouting shardRouting = shardIterator.nextOrNull();
479         if (shardRouting == null) {
480             nodeId = null;
481         } else if (shardRouting.active() == false) {
482             nodeId = shardRouting.relocatingNodeId();
483         } else {
484             nodeId = shardRouting.currentNodeId();
485         }
486         return new ShardLocation(shardIterator.shardId(), nodeId);
487     }
488     private static &lt;TReq extends ShardRequest&lt;TReq, TItem&gt;, TItem extends ShardRequest.Item&gt;
489         Map&lt;ShardLocation, TReq&gt; resolveAndGroupShardRequests(ShardedRequests&lt;TReq, TItem&gt; shardedRequests,
490                                                           ClusterService clusterService) {
491         var itemsByMissingIndex = shardedRequests.itemsByMissingIndex().entrySet().iterator();
492         while (itemsByMissingIndex.hasNext()) {
493             var entry = itemsByMissingIndex.next();
494             var index = entry.getKey();
495             var requestItems = entry.getValue();
496             var requestItemsIterator = requestItems.iterator();
497             while (requestItemsIterator.hasNext()) {
498                 var itemAndRoutingAndSourceInfo = requestItemsIterator.next();
499                 ShardLocation shardLocation;
500                 try {
501                     shardLocation = getShardLocation(
502                         index,
503                         itemAndRoutingAndSourceInfo.item().id(),
504                         itemAndRoutingAndSourceInfo.routing(),
505                         clusterService);
506                 } catch (IndexNotFoundException e) {
507                     if (IndexParts.isPartitioned(index)) {
508                         requestItemsIterator.remove();
509                         continue;
510                     } else {
511                         throw e;
512                     }
513                 }
514                 shardedRequests.add(itemAndRoutingAndSourceInfo.item(), 0, shardLocation, null);
515                 requestItemsIterator.remove();
516             }
517             if (requestItems.isEmpty()) {
518                 itemsByMissingIndex.remove();
519             }
520         }
521         return shardedRequests.itemsByShard();
522     }
523     private CompletableFuture&lt;ShardResponse.CompressedResult&gt; execute(NodeLimits nodeLimits,
524                                                                       ClusterState state,
525                                                                       Collection&lt;ShardUpsertRequest&gt; shardUpsertRequests,
526                                                                       TransportShardUpsertAction shardUpsertAction,
527                                                                       ScheduledExecutorService scheduler) {
528         ShardResponse.CompressedResult compressedResult = new ShardResponse.CompressedResult();
529         if (shardUpsertRequests.isEmpty()) {
530             return CompletableFuture.completedFuture(compressedResult);
531         }
532         CompletableFuture&lt;ShardResponse.CompressedResult&gt; result = new CompletableFuture&lt;&gt;();
533         AtomicInteger numRequests = new AtomicInteger(shardUpsertRequests.size());
534         AtomicReference&lt;Throwable&gt; lastFailure = new AtomicReference&lt;&gt;(null);
535         Consumer&lt;ShardUpsertRequest&gt; countdown = request -&gt; {
536             if (numRequests.decrementAndGet() == 0) {
537                 Throwable throwable = lastFailure.get();
538                 if (throwable == null) {
539                     result.complete(compressedResult);
540                 } else {
541                     throwable = SQLExceptions.unwrap(throwable, t -&gt; t instanceof RuntimeException);
542 <a name="6"></a>                    if (!SQLExceptions.isDocumentAlreadyExistsException(throwable) &amp;&amp;
543                             (partitionWasDeleted(throwable, request.index())
544                                     || partitionClosed(throwable, request.index())
545                                     || <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mixedArgumentTypesFailure(throwable))) {
546                         result.complete(compressedResult);
547                     } else {
548                         result.completeExceptionally(throwable);
549                     }</b></font>
550                 }
551             }
552         };
553         for (ShardUpsertRequest request : shardUpsertRequests) {
554             String nodeId;
555             try {
556                 nodeId = state.routingTable()
557                     .shardRoutingTable(request.shardId())
558                     .primaryShard()
559                     .currentNodeId();
560             } catch (IndexNotFoundException e) {
561                 lastFailure.set(e);
562                 if (!IndexParts.isPartitioned(request.index())) {
563                     synchronized (compressedResult) {
564                         compressedResult.markAsFailed(request.items());
565                     }
566                 }
567                 countdown.accept(request);
568                 continue;
569             }
570             final ConcurrencyLimit nodeLimit = nodeLimits.get(nodeId);
571             final long startTime = nodeLimit.startSample();
572             ActionListener&lt;ShardResponse&gt; listener = new ActionListener&lt;&gt;() {
573                 @Override
574                 public void onResponse(ShardResponse shardResponse) {
575                     Throwable throwable = shardResponse.failure();
576                     if (throwable == null) {
577                         nodeLimit.onSample(startTime, false);
578                         synchronized (compressedResult) {
579                             compressedResult.update(shardResponse);
580                         }
581                     } else {
582                         nodeLimit.onSample(startTime, true);
583                         lastFailure.set(throwable);
584                     }
585                     countdown.accept(request);
586                 }
587                 @Override
588                 public void onFailure(Exception e) {
589                     nodeLimit.onSample(startTime, true);
590                     Throwable t = SQLExceptions.unwrap(e);
591                     if (!partitionWasDeleted(t, request.index())) {
592                         synchronized (compressedResult) {
593                             compressedResult.markAsFailed(request.items());
594                         }
595                     }
596                     lastFailure.set(t);
597                     countdown.accept(request);
598                 }
599             };
600             shardUpsertAction.execute(
601                 request,
602                 new RetryListener&lt;&gt;(
603                     scheduler,
604                     l -&gt; shardUpsertAction.execute(request, l),
605                     listener,
606                     BackoffPolicy.limitedDynamic(nodeLimit)
607                 )
608             );
609         }
610         return result;
611     }
612     private static boolean mixedArgumentTypesFailure(Throwable throwable) {
613         return throwable instanceof ClassCastException
614 <a name="5"></a>               || throwable instanceof NotSerializableExceptionWrapper;
615     }
616     private static boolean partitionWasDeleted(Throwable throwable, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String index) {
617         return throwable instanceof IndexNotFoundException &amp;&amp; IndexParts.isPartitioned(index);
618     }
619     private static boolean partitionClosed(Throwable throwable, String index</b></font>) {
620         if (throwable instanceof ClusterBlockException &amp;&amp; IndexParts.isPartitioned(index)) {
621             for (ClusterBlock clusterBlock : ((ClusterBlockException) throwable).blocks()) {
622                 if (clusterBlock.equals(INDEX_CLOSED_BLOCK)) {
623                     return true;
624                 }
625             }
626         }
627         return false;
628     }
629     private static CompletableFuture&lt;AcknowledgedResponse&gt; createIndices(TransportCreatePartitionsAction createPartitionsAction,
630                                                                          Set&lt;String&gt; indices,
631                                                                          ClusterService clusterService,
632                                                                          UUID jobId) {
633         Metadata metadata = clusterService.state().getMetadata();
634         List&lt;String&gt; indicesToCreate = new ArrayList&lt;&gt;();
635         for (var index : indices) {
636             if (IndexParts.isPartitioned(index) &amp;&amp; metadata.hasIndex(index) == false) {
637                 indicesToCreate.add(index);
638             }
639         }
640         if (indicesToCreate.isEmpty()) {
641             return CompletableFuture.completedFuture(new AcknowledgedResponse(true));
642         }
643         FutureActionListener&lt;AcknowledgedResponse, AcknowledgedResponse&gt; listener = new FutureActionListener&lt;&gt;(r -&gt; r);
644         createPartitionsAction.execute(new CreatePartitionsRequest(indicesToCreate, jobId), listener);
645         return listener;
646     }
647     private static long[] createBulkResponse(ShardResponse.CompressedResult result,
648                                              int bulkResponseSize,
649                                              IntArrayList bulkIndices) {
650         long[] resultRowCount = new long[bulkResponseSize];
651         Arrays.fill(resultRowCount, 0L);
652         for (int i = 0; i &lt; bulkIndices.size(); i++) {
653             int resultIdx = bulkIndices.get(i);
654             if (result.successfulWrites(i)) {
655                 resultRowCount[resultIdx]++;
656             } else if (result.failed(i)) {
657                 resultRowCount[resultIdx] = Row1.ERROR;
658             }
659         }
660         return resultRowCount;
661     }
662     private static &lt;T&gt; List&lt;CompletableFuture&lt;T&gt;&gt; createUnsetFutures(int num) {
663         ArrayList&lt;CompletableFuture&lt;T&gt;&gt; results = new ArrayList&lt;&gt;(num);
664         for (int i = 0; i &lt; num; i++) {
665             results.add(new CompletableFuture&lt;&gt;());
666         }
667         return results;
668     }
669     @Override
670     public ExecutionPlan build(PlannerContext plannerContext,
671                                Set&lt;PlanHint&gt; hints,
672                                ProjectionBuilder projectionBuilder,
673                                int limit,
674                                int offset,
675                                @Nullable OrderBy order,
676                                @Nullable Integer pageSizeHint,
677 <a name="3"></a>                               Row params,
678                                SubQueryResults subQueryResults) {
679         return null;
680     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
681     @Override
682     public List&lt;Symbol&gt; outputs() {
683         return List.of();
684 <a name="7"></a>    }
685     @Override</b></font>
686     public List&lt;AbstractTableRelation&lt;?&gt;&gt; baseTables() <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
687         return List.of();
688     }
689     @Override
690     public List&lt;LogicalPlan&gt; sources() {
691         return</b></font> List.of();
692     }
693 <a name="2"></a>    @Override
694     public LogicalPlan replaceSources(List&lt;LogicalPlan&gt; sources) {
695         return this;
696     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
697     @Override
698     public LogicalPlan pruneOutputsExcept(TableStats tableStats, Collection&lt;Symbol&gt; outputsToKeep) {
699         return this;
700     }</b></font>
701 <a name="1"></a>
702     @Override
703     public Map&lt;LogicalPlan, SelectSymbol&gt; dependencies() {
704         return <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Map.of();
705     }
706     @Override
707     public long numExpectedRows() {
708         return -1L;
709     }
710     @Override
711     public long estimatedRowSize() {
712         return 0L;
713     }</b></font>
714     @Override
715     public &lt;C, R&gt; R accept(LogicalPlanVisitor&lt;C, R&gt; visitor, C context) {
716         return visitor.visitInsert(this, context);
717     }
718 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
