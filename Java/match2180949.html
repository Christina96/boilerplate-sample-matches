<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for NetworkDisruption.java &amp; InsertFromValues.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for NetworkDisruption.java &amp; InsertFromValues.java
      </h3>
<h1 align="center">
        10.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>NetworkDisruption.java (14.048338%)<th>InsertFromValues.java (7.9965606%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(94-117)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(496-507)<td><a href="#" name="1">(846-857)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(378-383)<td><a href="#" name="2">(837-842)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(173-180)<td><a href="#" name="3">(817-824)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(56-63)<td><a href="#" name="4">(118-126)</a><td align="center"><font color="#790000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(477-488)<td><a href="#" name="5">(732-736)</a><td align="center"><font color="#6d0000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(250-254)<td><a href="#" name="6">(656-660)</a><td align="center"><font color="#6d0000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(180-186)<td><a href="#" name="7">(825-831)</a><td align="center"><font color="#6d0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>NetworkDisruption.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
<a name="0"></a>
package org.elasticsearch.test.disruption;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.carrotsearch.randomizedtesting.generators.RandomPicks;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.NodeConnectionsService;
import org.elasticsearch.cluster.service.ClusterService;
import io.crate.common.unit.TimeValue;
import io.crate.common.collections.Sets;
import org.elasticsearch.test.InternalTestCluster;
import org.elasticsearch.test.transport.MockTransportService;
import org.elasticsearch.transport.ConnectTransportException;
import org.elasticsearch.transport.TransportService;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.function.BiConsumer;

/**
 * Network disruptions are modeled using two components:
 * 1) the {@link DisruptedLinks} represents the links in the network that are to be disrupted
 * 2) the {@link NetworkLinkDisruptionType} represents the failure mode that is to be applied to the links
 */
public class NetworkDisruption implements ServiceDisruptionScheme {

    private final Logger logger = LogManager.getLogger(NetworkDisruption.class)</b></font>;

    private final DisruptedLinks disruptedLinks;
<a name="4"></a>    private final NetworkLinkDisruptionType networkLinkDisruptionType;

    protected volatile InternalTestCluster cluster;
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>protected volatile boolean activeDisruption = false;

    public NetworkDisruption(DisruptedLinks disruptedLinks, NetworkLinkDisruptionType networkLinkDisruptionType) {
        this.disruptedLinks = disruptedLinks;
        this.networkLinkDisruptionType = networkLinkDisruptionType;
    }

    public DisruptedL</b></font>inks getDisruptedLinks() {
        return disruptedLinks;
    }

    public NetworkLinkDisruptionType getNetworkLinkDisruptionType() {
        return networkLinkDisruptionType;
    }

    @Override
    public void applyToCluster(InternalTestCluster cluster) {
        this.cluster = cluster;
    }

    @Override
    public void removeFromCluster(InternalTestCluster cluster) {
        stopDisrupting();
    }

    @Override
    public void removeAndEnsureHealthy(InternalTestCluster cluster) {
        removeFromCluster(cluster);
        ensureHealthy(cluster);
    }

    /**
     * ensures the cluster is healthy after the disruption
     */
    public void ensureHealthy(InternalTestCluster cluster) {
        assert activeDisruption == false;
        ensureNodeCount(cluster);
        ensureFullyConnectedCluster(cluster);
    }

    /**
     * Ensures that all nodes in the cluster are connected to each other.
     *
     * Some network disruptions may leave nodes that are not the master disconnected from each other.
     * {@link org.elasticsearch.cluster.NodeConnectionsService} will eventually reconnect but it's
     * handy to be able to ensure this happens faster
     */
    public static void ensureFullyConnectedCluster(InternalTestCluster cluster) {
        final String[] nodeNames = cluster.getNodeNames();
        final CountDownLatch countDownLatch = new CountDownLatch(nodeNames.length);
        for (String node : nodeNames) {
            ClusterState stateOnNode = cluster.getInstance(ClusterService.class, node).state();
            cluster.getInstance(NodeConnectionsService.class, node).reconnectToNodes(stateOnNode.nodes(), countDownLatch::countDown);
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            throw new AssertionError(e);
        }
    }

    protected void ensureNodeCount(InternalTestCluster cluster) {
        cluster.validateClusterFormed();
    }

    @Override
    public synchronized void applyToNode(String node, InternalTestCluster cluster) {

    }

    @Override
    public synchronized void removeFromNode(String node1, InternalTestCluster cluster) {
        logger.info("stop disrupting node (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
        applyToNodes(new String[]{ node1 }, cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption);
        applyToNodes(cluster.getNodeNames(), new String[]{ node1 }, networkLinkDisruptionType::removeDisruption);
    }

    @Override
    public synchronized void testClusterClosed() {

    }

    @Override
    public synchronized void startDisrupting() {
        logger.info("start disrupting (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
        applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::applyDisruption);
        activeDisruption = true;
    }

    @Override
    public synchronized void stopDisrupting() {
        if (!activeDisruption) {
            return;
        }
        logger.info("stop disrupting (disruption scheme: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks);
        applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption);
        activeDisruption = false;
    }

    /**
     * Applies action to all disrupted links between two sets of nodes.
     */
    private void applyToNodes(String[] nodes1, String[] nodes2, BiConsumer&lt;MockTransportService, MockTransportService&gt; consumer) {
        for (String node1 : nodes1) {
            if (disruptedLinks.nodes().contains(node1)) {
                for (String node2 : nodes2) {
                    if (disruptedLinks.nodes().contains(node2)) {
                        if (node1.equals(node2) == false) {
                            if (disruptedLinks.disrupt(node1, node2)) {
                                consumer.accept(transport(node1), transport(node2));
                            }
                        }
                    }
<a name="3"></a>                }
            }
        }
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public TimeValue expectedTimeToHeal() {
<a name="7"></a>        return networkLinkDisruptionType.expectedTimeToHeal();
    }

    private M</b></font>ockTransportService transport(String node) <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
        return (MockTransportService) cluster.getInstance(TransportService.class, node);
    }

    @Override
    public String toString() {
        return</b></font> "network disruption (disruption type: " + networkLinkDisruptionType + ", disrupted links: " + disruptedLinks + ")";
    }

    /**
     * Represents a set of nodes with connections between nodes that are to be disrupted
     */
    public abstract static class DisruptedLinks {
        private final Set&lt;String&gt; nodes;

        protected DisruptedLinks(Set&lt;String&gt;... nodeSets) {
            Set&lt;String&gt; allNodes = new HashSet&lt;&gt;();
            for (Set&lt;String&gt; nodeSet : nodeSets) {
                allNodes.addAll(nodeSet);
            }
            this.nodes = allNodes;
        }

        /**
         * Set of all nodes that can participate in disruptions
         */
        public Set&lt;String&gt; nodes() {
            return nodes;
        }

        /**
         * Returns true iff network should be disrupted between the two nodes
         */
        public abstract boolean disrupt(String node1, String node2);
    }

    /**
     * Creates two partitions with symmetric failures
     */
    public static class TwoPartitions extends DisruptedLinks {

        protected final Set&lt;String&gt; nodesSideOne;
        protected final Set&lt;String&gt; nodesSideTwo;

        public TwoPartitions(String node1, String node2) {
            this(Collections.singleton(node1), Collections.singleton(node2));
        }

        public TwoPartitions(Set&lt;String&gt; nodesSideOne, Set&lt;String&gt; nodesSideTwo) {
            super(nodesSideOne, nodesSideTwo);
            this.nodesSideOne = nodesSideOne;
            this.nodesSideTwo = nodesSideTwo;
            assert nodesSideOne.isEmpty() == false;
            assert nodesSideTwo.isEmpty() == false;
            assert Sets.haveEmptyIntersection(nodesSideOne, nodesSideTwo);
        }

        public static TwoPartitions random(Random random, String... nodes) {
            return random(random, Set.of(nodes));
        }

        public static TwoPartitions random(Random random, Set&lt;String&gt; nodes) {
            assert nodes.size() &gt;= 2 : "two partitions topology requires at least 2 nodes";
            Set&lt;String&gt; nodesSideOne = new HashSet&lt;&gt;();
            Set&lt;String&gt; nodesSideTwo = new HashSet&lt;&gt;();
            for (String node : nodes) {
                if (nodesSideOne.isEmpty()) {
<a name="6"></a>                    nodesSideOne.add(node);
                } else if (nodesSideTwo.isEmpty()) {
                    nodesSideTwo.add(node);
                } else if (<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>random.nextBoolean()) {
                    nodesSideOne.add(node);
                } else {
                    nodesSideTwo.add(node);
                }</b></font>
            }
            return new TwoPartitions(nodesSideOne, nodesSideTwo);
        }

        @Override
        public boolean disrupt(String node1, String node2) {
            if (nodesSideOne.contains(node1) &amp;&amp; nodesSideTwo.contains(node2)) {
                return true;
            }
            if (nodesSideOne.contains(node2) &amp;&amp; nodesSideTwo.contains(node1)) {
                return true;
            }
            return false;
        }

        public Set&lt;String&gt; getNodesSideOne() {
            return Collections.unmodifiableSet(nodesSideOne);
        }

        public Set&lt;String&gt; getNodesSideTwo() {
            return Collections.unmodifiableSet(nodesSideTwo);
        }

        public Collection&lt;String&gt; getMajoritySide() {
            if (nodesSideOne.size() &gt;= nodesSideTwo.size()) {
                return getNodesSideOne();
            } else {
                return getNodesSideTwo();
            }
        }

        public Collection&lt;String&gt; getMinoritySide() {
            if (nodesSideOne.size() &gt;= nodesSideTwo.size()) {
                return getNodesSideTwo();
            } else {
                return getNodesSideOne();
            }
        }

        @Override
        public String toString() {
            return "two partitions (partition 1: " + nodesSideOne + " and partition 2: " + nodesSideTwo + ")";
        }
    }

    /**
     * Creates two partitions with symmetric failures and a bridge node that can connect to both of the partitions
     */
    public static class Bridge extends DisruptedLinks {

        private final String bridgeNode;
        private final Set&lt;String&gt; nodesSideOne;
        private final Set&lt;String&gt; nodesSideTwo;

        public Bridge(String bridgeNode, Set&lt;String&gt; nodesSideOne, Set&lt;String&gt; nodesSideTwo) {
            super(Collections.singleton(bridgeNode), nodesSideOne, nodesSideTwo);
            this.bridgeNode = bridgeNode;
            this.nodesSideOne = nodesSideOne;
            this.nodesSideTwo = nodesSideTwo;
            assert nodesSideOne.isEmpty() == false;
            assert nodesSideTwo.isEmpty() == false;
            assert Sets.haveEmptyIntersection(nodesSideOne, nodesSideTwo);
            assert nodesSideOne.contains(bridgeNode) == false &amp;&amp; nodesSideTwo.contains(bridgeNode) == false;
        }

        public static Bridge random(Random random, String... nodes) {
            return random(random, Set.of(nodes));
        }

        public static Bridge random(Random random, Set&lt;String&gt; nodes) {
            assert nodes.size() &gt;= 3 : "bridge topology requires at least 3 nodes";
            String bridgeNode = RandomPicks.randomFrom(random, nodes);
            Set&lt;String&gt; nodesSideOne = new HashSet&lt;&gt;();
            Set&lt;String&gt; nodesSideTwo = new HashSet&lt;&gt;();
            for (String node : nodes) {
                if (node.equals(bridgeNode) == false) {
                    if (nodesSideOne.isEmpty()) {
                        nodesSideOne.add(node);
                    } else if (nodesSideTwo.isEmpty()) {
                        nodesSideTwo.add(node);
                    } else if (random.nextBoolean()) {
                        nodesSideOne.add(node);
                    } else {
                        nodesSideTwo.add(node);
                    }
                }
            }
            return new Bridge(bridgeNode, nodesSideOne, nodesSideTwo);
        }

        @Override
        public boolean disrupt(String node1, String node2) {
            if (nodesSideOne.contains(node1) &amp;&amp; nodesSideTwo.contains(node2)) {
                return true;
            }
            if (nodesSideOne.contains(node2) &amp;&amp; nodesSideTwo.contains(node1)) {
                return true;
            }
            return false;
        }

        public String getBridgeNode() {
            return bridgeNode;
        }

        public Set&lt;String&gt; getNodesSideOne() {
            return nodesSideOne;
        }

        public Set&lt;String&gt; getNodesSideTwo() {
            return nodesSideTwo;
        }

        public String toString() {
            return "bridge partition (super connected node: [" + bridgeNode + "], partition 1: " + nodesSideOne +
                " and partition 2: " + nodesSideTwo + ")";
        }
    }

    public static class IsolateAllNodes extends DisruptedLinks {
<a name="2"></a>
        public IsolateAllNodes(Set&lt;String&gt; nodes) {
            super(nodes);
        <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

        @Override
        public boolean disrupt(String node1, String node2) {
            return true;
        }</b></font>
    }

    /**
     * Abstract class representing various types of network disruptions. Instances of this class override the {@link #applyDisruption}
     * method to apply their specific disruption type to requests that are send from a source to a target node.
     */
    public abstract static class NetworkLinkDisruptionType {

        /**
         * Applies network disruption for requests send from the node represented by the source transport service to the node represented
         * by the target transport service.
         *
         * @param sourceTransportService source transport service from which requests are sent
         * @param targetTransportService target transport service to which requests are sent
         */
        public abstract void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService);

        /**
         * Removes network disruption that was added by {@link #applyDisruption}.
         *
         * @param sourceTransportService source transport service from which requests are sent
         * @param targetTransportService target transport service to which requests are sent
         */
        public void removeDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
            sourceTransportService.clearOutboundRules(targetTransportService);
        }

        /**
         * Returns expected time to heal after disruption has been removed. Defaults to instant healing.
         */
        public TimeValue expectedTimeToHeal() {
            return TimeValue.timeValueMillis(0);
        }

    }

    /**
     * Simulates a network disconnect. Sending a request from source to target node throws a {@link ConnectTransportException}.
     */
    public static class NetworkDisconnect extends NetworkLinkDisruptionType {

        @Override
        public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
            sourceTransportService.addFailToSendNoConnectRule(targetTransportService);
        }

        @Override
        public String toString() {
            return "network disconnects";
        }
    }

    /**
     * Simulates an unresponsive target node by dropping requests sent from source to target node.
     */
    public static class NetworkUnresponsive extends NetworkLinkDisruptionType {

        @Override
        public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
            sourceTransportService.addUnresponsiveRule(targetTransportService);
        }

        @Override
        public String toString() {
            return "network unresponsive";
        }
    }

    /**
     * Simulates slow or congested network. Delivery of requests that are sent from source to target node are delayed by a configurable
     * time amount.
     */
    public static class NetworkDelay extends NetworkLinkDisruptionType {

        public static TimeValue DEFAULT_DELAY_MIN = TimeValue.timeValueSeconds(10);
        public static TimeValue DEFAULT_DELAY_MAX = TimeValue.timeValueSeconds(90);

        private final TimeValue delay;

        /**
         * Delays requests by a fixed time value.
         *
         * @param delay time to delay requests
         */
        public NetworkDelay(TimeValue delay) {
            this.delay = delay;
        }

        /**
         * Delays requests by a random but fixed time value between {@link #DEFAULT_DELAY_MIN} and {@link #DEFAULT_DELAY_MAX}.
<a name="5"></a>         *
         * @param random instance to use for randomization of delay
         */
        public static NetworkDelay random(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Random random) {
            return random(random, DEFAULT_DELAY_MIN, DEFAULT_DELAY_MAX);
        }

        /**
         * Delays requests by a random but fixed time value between delayMin and delayMax.
         *
         * @param random   instance to use for randomization of delay
         * @param delayMin minimum delay
         * @param delayMax maximum delay
         */
        public static NetworkDelay random(Random random, TimeValue delayMin</b></font>, TimeValue delayMax) {
            return new NetworkDelay(TimeValue.timeValueMillis(delayMin.millis() == delayMax.millis() ?
                    delayMin.millis() :
                    delayMin.millis() + random.nextInt((int) (delayMax.millis() - delayMin.millis()))));
        }
<a name="1"></a>
        @Override
        public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sourceTransportService.addUnresponsiveRule(targetTransportService, delay);
        }

        @Override
        public TimeValue expectedTimeToHeal() {
            return delay;
        }

        @Override
        public String toString() {
            return "network delays for [" + delay + "]";
        }</b></font>
    }

}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>InsertFromValues.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.planner.operators;

import static io.crate.data.SentinelRow.SENTINEL;
import static io.crate.execution.engine.indexing.ShardingUpsertExecutor.BULK_REQUEST_TIMEOUT_SETTING;
import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_CLOSED_BLOCK;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.StreamSupport;

import javax.annotation.Nullable;

import com.carrotsearch.hppc.IntArrayList;

import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.admin.indices.create.CreatePartitionsRequest;
import org.elasticsearch.action.admin.indices.create.TransportCreatePartitionsAction;
import org.elasticsearch.action.bulk.BackoffPolicy;
import org.elasticsearch.action.support.master.AcknowledgedResponse;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.block.ClusterBlock;
import org.elasticsearch.cluster.block.ClusterBlockException;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.routing.ShardIterator;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.io.stream.NotSerializableExceptionWrapper;
import org.elasticsearch.index.IndexNotFoundException;

import io.crate.action.FutureActionListener;
import io.crate.analyze.OrderBy;
import io.crate.analyze.SymbolEvaluator;
import io.crate.analyze.relations.AbstractTableRelation;
import io.crate.analyze.relations.TableFunctionRelation;
import io.crate.breaker.RamAccounting;
import io.crate.breaker.TypeGuessEstimateRowSize;
import io.crate.concurrent.limits.ConcurrencyLimit;
import io.crate.data.CollectionBucket;
import io.crate.data.InMemoryBatchIterator;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.data.Row1;
import io.crate.data.RowConsumer;
import io.crate.data.RowN;
import io.crate.exceptions.ColumnValidationException;
import io.crate.exceptions.SQLExceptions;
import io.crate.execution.dml.ShardRequest;
import io.crate.execution.dml.ShardResponse;
import io.crate.execution.dml.upsert.InsertSourceFromCells;
import io.crate.execution.dml.upsert.ShardUpsertRequest;
import io.crate.execution.dml.upsert.TransportShardUpsertAction;
import io.crate.execution.dsl.projection.ColumnIndexWriterProjection;
import io.crate.execution.dsl.projection.builder.InputColumns;
import io.crate.execution.dsl.projection.builder.ProjectionBuilder;
import io.crate.execution.engine.collect.CollectExpression;
<a name="0"></a>import io.crate.execution.engine.collect.RowShardResolver;
import io.crate.execution.engine.indexing.GroupRowsByShard;
import io.crate.execution.engine.indexing.IndexNameResolver;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io.crate.execution.engine.indexing.ShardLocation;
import io.crate.execution.engine.indexing.ShardedRequests;
import io.crate.execution.jobs.NodeLimits;
import io.crate.execution.support.RetryListener;
import io.crate.expression.InputFactory;
import io.crate.expression.InputRow;
import io.crate.expression.symbol.Assignments;
import io.crate.expression.symbol.SelectSymbol;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.IndexParts;
import io.crate.metadata.Reference;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.metadata.table.Operation;
import io.crate.metadata.tablefunctions.TableFunctionImplementation;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.ExecutionPlan;
import io.crate.planner.PlannerContext;
import io.crate.statistics.TableStats;
import io.crate.types.DataType;


<a name="4"></a>public class InsertFromValues implements LogicalPlan {

    private final TableFunctionRelation tableFunctionRelation</b></font>;
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final ColumnIndexWriterProjection writerProjection;

    InsertFromValues(TableFunctionRelation tableFunctionRelation,
                     ColumnIndexWriterProjection writerProjection) {
        this.tableFunctionRelation = tableFunctionRelation;
        this.writerProjection = writerProjection;
    }

    @Ove</b></font>rride
    public StatementType type() {
        return StatementType.INSERT;
    }

    @Override
    public void execute(DependencyCarrier dependencies,
                        PlannerContext plannerContext,
                        RowConsumer consumer,
                        Row params,
                        SubQueryResults subQueryResults) {
        DocTableInfo tableInfo = dependencies
            .schemas()
            .getTableInfo(writerProjection.tableIdent(), Operation.INSERT);

        // For instance, the target table of the insert from values
        // statement is the table with the following schema:
        //
        // CREATE TABLE users (
        //      dep_id TEXT,
        //      name TEXT,
        //      id INT,
        //      country_id INT,
        //      PRIMARY KEY (dep_id, id, country_id))
        // CLUSTERED BY (dep_id)
        // PARTITIONED BY (country_id)
        //
        // The insert from values statement below would have the column
        // index writer projection of its plan that contains the column
        // idents and symbols required to create corresponding inputs.
        // The diagram below shows the projection's column symbols used
        // in the plan and relation between symbols sub-/sets.
        //
        //                        +------------------------+
        //                        |          +-------------+  PK symbols
        //    cluster by +------+ |          |      +------+
        //    symbol            | |          |      |
        //                      + +          +      +
        // INSERT INTO users (dep_id, name, id, country_id) VALUES (?, ?, ?, ?)
        //                       +      +    +     +   +
        //               +-------+      |    |     |   |
        //   all target  +--------------+    |     |   +---+  partitioned by
        //   column      +-------------------+     |          symbols
        //   symbols     +-------------------------+

        InputFactory inputFactory = new InputFactory(dependencies.nodeContext());
        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; context =
            inputFactory.ctxForInputColumns(plannerContext.transactionContext());

        var allColumnSymbols = InputColumns.create(
            writerProjection.allTargetColumns(),
            new InputColumns.SourceSymbols(writerProjection.allTargetColumns()));

        ArrayList&lt;Input&lt;?&gt;&gt; insertInputs = new ArrayList&lt;&gt;(allColumnSymbols.size());
        for (Symbol symbol : allColumnSymbols) {
            insertInputs.add(context.add(symbol));
        }

        ArrayList&lt;Input&lt;?&gt;&gt; partitionedByInputs = new ArrayList&lt;&gt;(writerProjection.partitionedBySymbols().size());
        for (Symbol partitionedBySymbol : writerProjection.partitionedBySymbols()) {
            partitionedByInputs.add(context.add(partitionedBySymbol));
        }

        ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs = new ArrayList&lt;&gt;(writerProjection.ids().size());
        for (Symbol symbol : writerProjection.ids()) {
            primaryKeyInputs.add(context.add(symbol));
        }

        Input&lt;?&gt; clusterByInput;
        if (writerProjection.clusteredBy() != null) {
            clusterByInput = context.add(writerProjection.clusteredBy());
        } else {
            clusterByInput = null;
        }

        String[] updateColumnNames;
        Symbol[] assignmentSources;
        if (writerProjection.onDuplicateKeyAssignments() == null) {
            updateColumnNames = null;
            assignmentSources = null;
        } else {
            Assignments assignments = Assignments.convert(
                writerProjection.onDuplicateKeyAssignments(),
                dependencies.nodeContext()
            );
            assignmentSources = assignments.bindSources(tableInfo, params, subQueryResults);
            updateColumnNames = assignments.targetNames();
        }
        var indexNameResolver = IndexNameResolver.create(
            writerProjection.tableIdent(),
            writerProjection.partitionIdent(),
            partitionedByInputs);

        GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt; grouper =
            createRowsByShardGrouper(
                assignmentSources,
                insertInputs,
                indexNameResolver,
                context,
                plannerContext,
                dependencies.clusterService());

        ArrayList&lt;Row&gt; rows = new ArrayList&lt;&gt;();
        evaluateValueTableFunction(
            tableFunctionRelation.functionImplementation(),
            tableFunctionRelation.function().arguments(),
            writerProjection.allTargetColumns(),
            tableInfo,
            params,
            plannerContext,
            subQueryResults
        ).forEachRemaining(rows::add);

        List&lt;Symbol&gt; returnValues = this.writerProjection.returnValues();

        ShardUpsertRequest.Builder builder = new ShardUpsertRequest.Builder(
            plannerContext.transactionContext().sessionSettings(),
            BULK_REQUEST_TIMEOUT_SETTING.get(dependencies.settings()),
            writerProjection.isIgnoreDuplicateKeys()
                ? ShardUpsertRequest.DuplicateKeyAction.IGNORE
                : ShardUpsertRequest.DuplicateKeyAction.UPDATE_OR_FAIL,
            rows.size() &gt; 1, // continueOnErrors
            updateColumnNames,
            writerProjection.allTargetColumns().toArray(new Reference[0]),
            returnValues.isEmpty() ? null : returnValues.toArray(new Symbol[0]),
            plannerContext.jobId(),
            false);

        var shardedRequests = new ShardedRequests&lt;&gt;(builder::newRequest, RamAccounting.NO_ACCOUNTING);
        HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache = new HashMap&lt;&gt;();
        for (Row row : rows) {
            grouper.accept(shardedRequests, row);

            try {
                checkPrimaryKeyValuesNotNull(primaryKeyInputs);
                checkClusterByValueNotNull(clusterByInput);
                checkConstraintsOnGeneratedSource(
                    row.materialize(),
                    indexNameResolver.get(),
                    tableInfo,
                    plannerContext,
                    validatorsCache);
            } catch (Throwable t) {
                consumer.accept(null, t);
                return;
            }
        }
        validatorsCache.clear();

        var actionProvider = dependencies.transportActionProvider();
        createIndices(
            actionProvider.transportBulkCreateIndicesAction(),
            shardedRequests.itemsByMissingIndex().keySet(),
            dependencies.clusterService(),
            plannerContext.jobId()
        ).thenCompose(acknowledgedResponse -&gt; {
            var shardUpsertRequests = resolveAndGroupShardRequests(
                shardedRequests,
                dependencies.clusterService()).values();
            return execute(
                dependencies.nodeLimits(),
                dependencies.clusterService().state(),
                shardUpsertRequests,
                actionProvider.transportShardUpsertAction(),
                dependencies.scheduler());
        }).whenComplete((response, t) -&gt; {
            if (t == null) {
                if (returnValues.isEmpty()) {
                    consumer.accept(InMemoryBatchIterator.of(new Row1((long) response.numSuccessfulWrites()), SENTINEL),
                                    null);
                } else {
                    consumer.accept(InMemoryBatchIterator.of(new CollectionBucket(response.resultRows()), SENTINEL, false), null);
                }
            } else {
                consumer.accept(null, t);
            }
        });
    }

    @Override
    public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier dependencies,
                                                     PlannerContext plannerContext,
                                                     List&lt;Row&gt; bulkParams,
                                                     SubQueryResults subQueryResults) {
        DocTableInfo tableInfo = dependencies
            .schemas()
            .getTableInfo(writerProjection.tableIdent(), Operation.INSERT);

        String[] updateColumnNames;
        Assignments assignments;
        if (writerProjection.onDuplicateKeyAssignments() == null) {
            assignments = null;
            updateColumnNames = null;
        } else {
            assignments = Assignments.convert(writerProjection.onDuplicateKeyAssignments(), dependencies.nodeContext());
            updateColumnNames = assignments.targetNames();
        }

        InputFactory inputFactory = new InputFactory(dependencies.nodeContext());
        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; context =
            inputFactory.ctxForInputColumns(plannerContext.transactionContext());

        var allColumnSymbols = InputColumns.create(
            writerProjection.allTargetColumns(),
            new InputColumns.SourceSymbols(writerProjection.allTargetColumns()));

        ArrayList&lt;Input&lt;?&gt;&gt; insertInputs = new ArrayList&lt;&gt;(allColumnSymbols.size());
        for (Symbol symbol : allColumnSymbols) {
            insertInputs.add(context.add(symbol));
        }

        ArrayList&lt;Input&lt;?&gt;&gt; partitionedByInputs = new ArrayList&lt;&gt;(writerProjection.partitionedBySymbols().size());
        for (Symbol partitionedBySymbol : writerProjection.partitionedBySymbols()) {
            partitionedByInputs.add(context.add(partitionedBySymbol));
        }

        ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs = new ArrayList&lt;&gt;(writerProjection.ids().size());
        for (Symbol symbol : writerProjection.ids()) {
            primaryKeyInputs.add(context.add(symbol));
        }
        Input&lt;?&gt; clusterByInput;
        if (writerProjection.clusteredBy() != null) {
            clusterByInput = context.add(writerProjection.clusteredBy());
        } else {
            clusterByInput = null;
        }

        var indexNameResolver = IndexNameResolver.create(
            writerProjection.tableIdent(),
            writerProjection.partitionIdent(),
            partitionedByInputs);

        ShardUpsertRequest.Builder builder = new ShardUpsertRequest.Builder(
            plannerContext.transactionContext().sessionSettings(),
            BULK_REQUEST_TIMEOUT_SETTING.get(dependencies.settings()),
            writerProjection.isIgnoreDuplicateKeys()
                ? ShardUpsertRequest.DuplicateKeyAction.IGNORE
                : ShardUpsertRequest.DuplicateKeyAction.UPDATE_OR_FAIL,
            true, // continueOnErrors
            updateColumnNames,
            writerProjection.allTargetColumns().toArray(new Reference[0]),
            null,
            plannerContext.jobId(),
            true);
        var shardedRequests = new ShardedRequests&lt;&gt;(builder::newRequest, RamAccounting.NO_ACCOUNTING);

        HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache = new HashMap&lt;&gt;();
        IntArrayList bulkIndices = new IntArrayList();
        List&lt;CompletableFuture&lt;Long&gt;&gt; results = createUnsetFutures(bulkParams.size());
        for (int bulkIdx = 0; bulkIdx &lt; bulkParams.size(); bulkIdx++) {
            Row param = bulkParams.get(bulkIdx);

            final Symbol[] assignmentSources;
            if (assignments != null) {
                assignmentSources = assignments.bindSources(tableInfo, param, subQueryResults);
            } else {
                assignmentSources = null;
            }

            GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt; grouper =
                createRowsByShardGrouper(
                    assignmentSources,
                    insertInputs,
                    indexNameResolver,
                    context,
                    plannerContext,
                    dependencies.clusterService());

            try {
                Iterator&lt;Row&gt; rows = evaluateValueTableFunction(
                    tableFunctionRelation.functionImplementation(),
                    tableFunctionRelation.function().arguments(),
                    writerProjection.allTargetColumns(),
                    tableInfo,
                    param,
                    plannerContext,
                    subQueryResults);

                while (rows.hasNext()) {
                    Row row = rows.next();
                    grouper.accept(shardedRequests, row);

                    checkPrimaryKeyValuesNotNull(primaryKeyInputs);
                    checkClusterByValueNotNull(clusterByInput);
                    checkConstraintsOnGeneratedSource(
                        row.materialize(),
                        indexNameResolver.get(),
                        tableInfo,
                        plannerContext,
                        validatorsCache);
                    bulkIndices.add(bulkIdx);
                }
            } catch (Throwable t) {
                for (CompletableFuture&lt;Long&gt; result : results) {
                    result.completeExceptionally(t);
                }
                return results;
            }
        }
        validatorsCache.clear();

        var actionProvider = dependencies.transportActionProvider();
        createIndices(
            actionProvider.transportBulkCreateIndicesAction(),
            shardedRequests.itemsByMissingIndex().keySet(),
            dependencies.clusterService(), plannerContext.jobId()
        ).thenCompose(acknowledgedResponse -&gt; {
            var shardUpsertRequests = resolveAndGroupShardRequests(
                shardedRequests,
                dependencies.clusterService()).values();
            return execute(
                dependencies.nodeLimits(),
                dependencies.clusterService().state(),
                shardUpsertRequests,
                actionProvider.transportShardUpsertAction(),
                dependencies.scheduler());
        }).whenComplete((response, t) -&gt; {
            if (t == null) {
                long[] resultRowCount = createBulkResponse(response, bulkParams.size(), bulkIndices);
                for (int i = 0; i &lt; bulkParams.size(); i++) {
                    results.get(i).complete(resultRowCount[i]);
                }
            } else {
                for (CompletableFuture&lt;Long&gt; result : results) {
                    result.completeExceptionally(t);
                }
            }
        });
        return results;
    }

    private GroupRowsByShard&lt;ShardUpsertRequest, ShardUpsertRequest.Item&gt;
        createRowsByShardGrouper(Symbol[] assignmentSources,
                                 ArrayList&lt;Input&lt;?&gt;&gt; insertInputs,
                                 Supplier&lt;String&gt; indexNameResolver,
                                 InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; collectContext,
                                 PlannerContext plannerContext,
                                 ClusterService clusterService) {
        InputRow insertValues = new InputRow(insertInputs);
        Function&lt;String, ShardUpsertRequest.Item&gt; itemFactory = id -&gt;
            new ShardUpsertRequest.Item(
                id,
                assignmentSources,
                insertValues.materialize(),
                null, null, null);

        var rowShardResolver = new RowShardResolver(
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            writerProjection.primaryKeys(),
            writerProjection.ids(),
            writerProjection.clusteredByIdent(),
            writerProjection.clusteredBy());

        return new GroupRowsByShard&lt;&gt;(
            clusterService,
            rowShardResolver,
            new TypeGuessEstimateRowSize(),
            indexNameResolver,
            collectContext.expressions(),
            itemFactory,
            true
        );
    }

    private static void checkPrimaryKeyValuesNotNull(ArrayList&lt;Input&lt;?&gt;&gt; primaryKeyInputs) {
        for (var primaryKey : primaryKeyInputs) {
            if (primaryKey.value() == null) {
                throw new IllegalArgumentException("Primary key value must not be NULL");
            }
        }
    }

    private static void checkClusterByValueNotNull(@Nullable Input&lt;?&gt; clusterByInput) {
        if (clusterByInput != null &amp;&amp; clusterByInput.value() == null) {
            throw new IllegalArgumentException("Clustered by value must not be NULL");
        }
    }

    private void checkConstraintsOnGeneratedSource(Object[] cells,
                                                   String indexName,
                                                   DocTableInfo tableInfo,
                                                   PlannerContext plannerContext,
                                                   HashMap&lt;String, InsertSourceFromCells&gt; validatorsCache) throws Throwable {
        var validator = validatorsCache.computeIfAbsent(
            indexName,
            index -&gt; new InsertSourceFromCells(
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                tableInfo,
                index,
                true,
                writerProjection.allTargetColumns()));
        validator.generateSourceAndCheckConstraints(cells);
    }

    private static Iterator&lt;Row&gt; evaluateValueTableFunction(TableFunctionImplementation&lt;?&gt; funcImplementation,
                                                            List&lt;Symbol&gt; arguments,
                                                            List&lt;Reference&gt; allTargetReferences,
                                                            DocTableInfo tableInfo,
                                                            Row params,
                                                            PlannerContext plannerContext,
                                                            SubQueryResults subQueryResults) {
        SymbolEvaluator symbolEval = new SymbolEvaluator(
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            subQueryResults);
        Function&lt;? super Symbol, Input&lt;?&gt;&gt; eval = (symbol) -&gt; symbol.accept(symbolEval, params);

        ArrayList&lt;Input&lt;?&gt;&gt; boundArguments = new ArrayList&lt;&gt;(arguments.size());
        for (int i = 0; i &lt; arguments.size(); i++) {
            boundArguments.add(eval.apply(arguments.get(i)));
        }
        //noinspection unchecked
        Iterable&lt;Row&gt; rows = funcImplementation.evaluate(
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            boundArguments.toArray(new Input[0]));

        return StreamSupport.stream(rows.spliterator(), false)
            .map(row -&gt; cast(row, allTargetReferences, tableInfo))
            .iterator();
    }

    private static Row cast(Row row, List&lt;Reference&gt; columnReferences, DocTableInfo tableInfo) {
        if (row == null) {
            return null;
        }
        Object[] cells = new Object[row.numColumns()];
        for (int i = 0; i &lt; cells.length; i++) {
            Reference reference = columnReferences.get(i);
            DataType&lt;?&gt; targetType = reference.valueType();
            Object value = row.get(i);
            try {
                cells[i] = targetType.implicitCast(value);
            } catch (IllegalArgumentException | ClassCastException e) {
                throw new ColumnValidationException(
                    reference.column().name(),
                    tableInfo.ident(),
                    "Invalid value '" + value + "' for type '" + targetType + "'");
            }
        }
        return new RowN(cells);
    }

    private static ShardLocation getShardLocation(String indexName,
                                                  String id,
                                                  @Nullable String routing,
                                                  ClusterService clusterService) {
        ShardIterator shardIterator = clusterService.operationRouting().indexShards(
            clusterService.state(),
            indexName,
            id,
            routing);

        final String nodeId;
        ShardRouting shardRouting = shardIterator.nextOrNull();
        if (shardRouting == null) {
            nodeId = null;
        } else if (shardRouting.active() == false) {
            nodeId = shardRouting.relocatingNodeId();
        } else {
            nodeId = shardRouting.currentNodeId();
        }
        return new ShardLocation(shardIterator.shardId(), nodeId);
    }

    private static &lt;TReq extends ShardRequest&lt;TReq, TItem&gt;, TItem extends ShardRequest.Item&gt;
        Map&lt;ShardLocation, TReq&gt; resolveAndGroupShardRequests(ShardedRequests&lt;TReq, TItem&gt; shardedRequests,
                                                          ClusterService clusterService) {
        var itemsByMissingIndex = shardedRequests.itemsByMissingIndex().entrySet().iterator();
        while (itemsByMissingIndex.hasNext()) {
            var entry = itemsByMissingIndex.next();
            var index = entry.getKey();
            var requestItems = entry.getValue();

            var requestItemsIterator = requestItems.iterator();
            while (requestItemsIterator.hasNext()) {
                var itemAndRoutingAndSourceInfo = requestItemsIterator.next();
                ShardLocation shardLocation;
                try {
                    shardLocation = getShardLocation(
                        index,
                        itemAndRoutingAndSourceInfo.item().id(),
                        itemAndRoutingAndSourceInfo.routing(),
                        clusterService);
                } catch (IndexNotFoundException e) {
                    if (IndexParts.isPartitioned(index)) {
                        requestItemsIterator.remove();
                        continue;
                    } else {
                        throw e;
                    }
                }
                shardedRequests.add(itemAndRoutingAndSourceInfo.item(), 0, shardLocation, null);
                requestItemsIterator.remove();
            }
            if (requestItems.isEmpty()) {
                itemsByMissingIndex.remove();
            }
        }

        return shardedRequests.itemsByShard();
    }

    private CompletableFuture&lt;ShardResponse.CompressedResult&gt; execute(NodeLimits nodeLimits,
                                                                      ClusterState state,
                                                                      Collection&lt;ShardUpsertRequest&gt; shardUpsertRequests,
                                                                      TransportShardUpsertAction shardUpsertAction,
                                                                      ScheduledExecutorService scheduler) {
        ShardResponse.CompressedResult compressedResult = new ShardResponse.CompressedResult();
        if (shardUpsertRequests.isEmpty()) {
            return CompletableFuture.completedFuture(compressedResult);
        }

        CompletableFuture&lt;ShardResponse.CompressedResult&gt; result = new CompletableFuture&lt;&gt;();
        AtomicInteger numRequests = new AtomicInteger(shardUpsertRequests.size());
        AtomicReference&lt;Throwable&gt; lastFailure = new AtomicReference&lt;&gt;(null);

        Consumer&lt;ShardUpsertRequest&gt; countdown = request -&gt; {
            if (numRequests.decrementAndGet() == 0) {
                Throwable throwable = lastFailure.get();
                if (throwable == null) {
                    result.complete(compressedResult);
                } else {
                    throwable = SQLExceptions.unwrap(throwable, t -&gt; t instanceof RuntimeException);
                    // we want to report duplicate key exceptions
<a name="6"></a>                    if (!SQLExceptions.isDocumentAlreadyExistsException(throwable) &amp;&amp;
                            (partitionWasDeleted(throwable, request.index())
                                    || partitionClosed(throwable, request.index())
                                    || <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mixedArgumentTypesFailure(throwable))) {
                        result.complete(compressedResult);
                    } else {
                        result.completeExceptionally(throwable);
                    }</b></font>
                }
            }
        };
        for (ShardUpsertRequest request : shardUpsertRequests) {
            String nodeId;
            try {
                nodeId = state.routingTable()
                    .shardRoutingTable(request.shardId())
                    .primaryShard()
                    .currentNodeId();
            } catch (IndexNotFoundException e) {
                lastFailure.set(e);
                if (!IndexParts.isPartitioned(request.index())) {
                    synchronized (compressedResult) {
                        compressedResult.markAsFailed(request.items());
                    }
                }
                countdown.accept(request);
                continue;
            }
            final ConcurrencyLimit nodeLimit = nodeLimits.get(nodeId);
            final long startTime = nodeLimit.startSample();

            ActionListener&lt;ShardResponse&gt; listener = new ActionListener&lt;&gt;() {
                @Override
                public void onResponse(ShardResponse shardResponse) {
                    Throwable throwable = shardResponse.failure();
                    if (throwable == null) {
                        nodeLimit.onSample(startTime, false);
                        synchronized (compressedResult) {
                            compressedResult.update(shardResponse);
                        }
                    } else {
                        nodeLimit.onSample(startTime, true);
                        lastFailure.set(throwable);
                    }
                    countdown.accept(request);
                }

                @Override
                public void onFailure(Exception e) {
                    nodeLimit.onSample(startTime, true);
                    Throwable t = SQLExceptions.unwrap(e);
                    if (!partitionWasDeleted(t, request.index())) {
                        synchronized (compressedResult) {
                            compressedResult.markAsFailed(request.items());
                        }
                    }
                    lastFailure.set(t);
                    countdown.accept(request);
                }
            };

            shardUpsertAction.execute(
                request,
                new RetryListener&lt;&gt;(
                    scheduler,
                    l -&gt; shardUpsertAction.execute(request, l),
                    listener,
                    BackoffPolicy.limitedDynamic(nodeLimit)
                )
            );
        }
        return result;
    }

    private static boolean mixedArgumentTypesFailure(Throwable throwable) {
        return throwable instanceof ClassCastException
<a name="5"></a>               || throwable instanceof NotSerializableExceptionWrapper;
    }

    private static boolean partitionWasDeleted(Throwable throwable, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String index) {
        return throwable instanceof IndexNotFoundException &amp;&amp; IndexParts.isPartitioned(index);
    }

    private static boolean partitionClosed(Throwable throwable, String index</b></font>) {
        if (throwable instanceof ClusterBlockException &amp;&amp; IndexParts.isPartitioned(index)) {
            for (ClusterBlock clusterBlock : ((ClusterBlockException) throwable).blocks()) {
                if (clusterBlock.equals(INDEX_CLOSED_BLOCK)) {
                    return true;
                }
            }
        }
        return false;
    }

    private static CompletableFuture&lt;AcknowledgedResponse&gt; createIndices(TransportCreatePartitionsAction createPartitionsAction,
                                                                         Set&lt;String&gt; indices,
                                                                         ClusterService clusterService,
                                                                         UUID jobId) {
        Metadata metadata = clusterService.state().getMetadata();
        List&lt;String&gt; indicesToCreate = new ArrayList&lt;&gt;();
        for (var index : indices) {
            if (IndexParts.isPartitioned(index) &amp;&amp; metadata.hasIndex(index) == false) {
                indicesToCreate.add(index);
            }
        }
        if (indicesToCreate.isEmpty()) {
            return CompletableFuture.completedFuture(new AcknowledgedResponse(true));
        }
        FutureActionListener&lt;AcknowledgedResponse, AcknowledgedResponse&gt; listener = new FutureActionListener&lt;&gt;(r -&gt; r);
        createPartitionsAction.execute(new CreatePartitionsRequest(indicesToCreate, jobId), listener);
        return listener;
    }

    /**
     * Create bulk-response depending on number of bulk responses
     * &lt;pre&gt;
     *     compressedResult
     *          success: [1, 1, 1, 1]
     *          failure: []
     *
     *     insert into t (x) values (?), (?)   -- bulkParams: [[1, 2], [3, 4]]
     *     Response:
     *      [2, 2]
     *
     *     insert into t (x) values (?)        -- bulkParams: [[1], [2], [3], [4]]
     *     Response:
     *      [1, 1, 1, 1]
     * &lt;/pre&gt;
     */
    private static long[] createBulkResponse(ShardResponse.CompressedResult result,
                                             int bulkResponseSize,
                                             IntArrayList bulkIndices) {
        long[] resultRowCount = new long[bulkResponseSize];
        Arrays.fill(resultRowCount, 0L);
        for (int i = 0; i &lt; bulkIndices.size(); i++) {
            int resultIdx = bulkIndices.get(i);
            if (result.successfulWrites(i)) {
                resultRowCount[resultIdx]++;
            } else if (result.failed(i)) {
                resultRowCount[resultIdx] = Row1.ERROR;
            }
        }
        return resultRowCount;
    }

    private static &lt;T&gt; List&lt;CompletableFuture&lt;T&gt;&gt; createUnsetFutures(int num) {
        ArrayList&lt;CompletableFuture&lt;T&gt;&gt; results = new ArrayList&lt;&gt;(num);
        for (int i = 0; i &lt; num; i++) {
            results.add(new CompletableFuture&lt;&gt;());
        }
        return results;
    }

    @Override
    public ExecutionPlan build(PlannerContext plannerContext,
                               Set&lt;PlanHint&gt; hints,
                               ProjectionBuilder projectionBuilder,
                               int limit,
                               int offset,
                               @Nullable OrderBy order,
                               @Nullable Integer pageSizeHint,
<a name="3"></a>                               Row params,
                               SubQueryResults subQueryResults) {
        return null;
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public List&lt;Symbol&gt; outputs() {
        return List.of();
<a name="7"></a>    }

    @Override</b></font>
    public List&lt;AbstractTableRelation&lt;?&gt;&gt; baseTables() <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
        return List.of();
    }

    @Override
    public List&lt;LogicalPlan&gt; sources() {
        return</b></font> List.of();
    }

<a name="2"></a>    @Override
    public LogicalPlan replaceSources(List&lt;LogicalPlan&gt; sources) {
        return this;
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public LogicalPlan pruneOutputsExcept(TableStats tableStats, Collection&lt;Symbol&gt; outputsToKeep) {
        return this;
    }</b></font>
<a name="1"></a>
    @Override
    public Map&lt;LogicalPlan, SelectSymbol&gt; dependencies() {
        return <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Map.of();
    }

    @Override
    public long numExpectedRows() {
        return -1L;
    }

    @Override
    public long estimatedRowSize() {
        return 0L;
    }</b></font>

    @Override
    public &lt;C, R&gt; R accept(LogicalPlanVisitor&lt;C, R&gt; visitor, C context) {
        return visitor.visitInsert(this, context);
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
