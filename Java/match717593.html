<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for QuoteOfTheMomentClient.java &amp; ReferenceCountedOpenSslServerContext.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for QuoteOfTheMomentClient.java &amp; ReferenceCountedOpenSslServerContext.java
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>QuoteOfTheMomentClient.java (24.528301%)<th>ReferenceCountedOpenSslServerContext.java (3.233831%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(18-37)<td><a href="#" name="0">(29-51)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>QuoteOfTheMomentClient.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.example.qotm;
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.bootstrap.Bootstrap;
3 import io.netty.buffer.Unpooled;
4 import io.netty.channel.Channel;
5 import io.netty.channel.ChannelOption;
6 import io.netty.channel.EventLoopGroup;
7 import io.netty.channel.nio.NioEventLoopGroup;
8 import io.netty.channel.socket.DatagramPacket;
9 import io.netty.channel.socket.nio.NioDatagramChannel;
10 import io.netty.util.CharsetUtil;
11 import io.netty.util.internal.SocketUtils;
12 public final class QuoteOfTheMomentClient {
13     static final int PORT = Integer.parseInt</b></font>(System.getProperty("port", "7686"));
14     public static void main(String[] args) throws Exception {
15         EventLoopGroup group = new NioEventLoopGroup();
16         try {
17             Bootstrap b = new Bootstrap();
18             b.group(group)
19              .channel(NioDatagramChannel.class)
20              .option(ChannelOption.SO_BROADCAST, true)
21              .handler(new QuoteOfTheMomentClientHandler());
22             Channel ch = b.bind(0).sync().channel();
23             ch.writeAndFlush(new DatagramPacket(
24                     Unpooled.copiedBuffer("QOTM?", CharsetUtil.UTF_8),
25                     SocketUtils.socketAddress("255.255.255.255", PORT))).sync();
26             if (!ch.closeFuture().await(5000)) {
27                 System.err.println("QOTM request timed out.");
28             }
29         } finally {
30             group.shutdownGracefully();
31         }
32     }
33 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReferenceCountedOpenSslServerContext.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.ssl;
2 import io.netty.buffer.ByteBufAllocator;
3 import io.netty.internal.tcnative.CertificateCallback;
4 import io.netty.internal.tcnative.SSL;
5 import io.netty.internal.tcnative.SSLContext;
6 import io.netty.internal.tcnative.SniHostNameMatcher;
7 import io.netty.util.CharsetUtil;
8 import io.netty.util.internal.PlatformDependent;
9 import io.netty.util.internal.SuppressJava6Requirement;
10 <a name="0"></a>import io.netty.util.internal.logging.InternalLogger;
11 import io.netty.util.internal.logging.InternalLoggerFactory;
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.security.KeyStore;
13 import java.security.PrivateKey;
14 import java.security.cert.X509Certificate;
15 import java.util.Map;
16 import javax.net.ssl.KeyManagerFactory;
17 import javax.net.ssl.SSLException;
18 import javax.net.ssl.TrustManagerFactory;
19 import javax.net.ssl.X509ExtendedTrustManager;
20 import javax.net.ssl.X509TrustManager;
21 import static io.netty.util.internal.ObjectUtil.checkNotNull;
22 public final class ReferenceCountedOpenSslServerContext extends ReferenceCountedOpenSslContext {
23     private static final InternalLogger logger =
24             InternalLoggerFactory.getInstance</b></font>(ReferenceCountedOpenSslServerContext.class);
25     private static final byte[] ID = {'n', 'e', 't', 't', 'y'};
26     private final OpenSslServerSessionContext sessionContext;
27     ReferenceCountedOpenSslServerContext(
28             X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory,
29             X509Certificate[] keyCertChain, PrivateKey key, String keyPassword, KeyManagerFactory keyManagerFactory,
30             Iterable&lt;String&gt; ciphers, CipherSuiteFilter cipherFilter, ApplicationProtocolConfig apn,
31             long sessionCacheSize, long sessionTimeout, ClientAuth clientAuth, String[] protocols, boolean startTls,
32             boolean enableOcsp, String keyStore, Map.Entry&lt;SslContextOption&lt;?&gt;, Object&gt;... options)
33             throws SSLException {
34         this(trustCertCollection, trustManagerFactory, keyCertChain, key, keyPassword, keyManagerFactory, ciphers,
35                 cipherFilter, toNegotiator(apn), sessionCacheSize, sessionTimeout, clientAuth, protocols, startTls,
36                 enableOcsp, keyStore, options);
37     }
38     ReferenceCountedOpenSslServerContext(
39             X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory,
40             X509Certificate[] keyCertChain, PrivateKey key, String keyPassword, KeyManagerFactory keyManagerFactory,
41             Iterable&lt;String&gt; ciphers, CipherSuiteFilter cipherFilter, OpenSslApplicationProtocolNegotiator apn,
42             long sessionCacheSize, long sessionTimeout, ClientAuth clientAuth, String[] protocols, boolean startTls,
43             boolean enableOcsp, String keyStore, Map.Entry&lt;SslContextOption&lt;?&gt;, Object&gt;... options)
44             throws SSLException {
45         super(ciphers, cipherFilter, apn, SSL.SSL_MODE_SERVER, keyCertChain,
46               clientAuth, protocols, startTls, enableOcsp, true, options);
47         boolean success = false;
48         try {
49             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
50                     keyCertChain, key, keyPassword, keyManagerFactory, keyStore,
51                     sessionCacheSize, sessionTimeout);
52             if (SERVER_ENABLE_SESSION_TICKET) {
53                 sessionContext.setTicketKeys();
54             }
55             success = true;
56         } finally {
57             if (!success) {
58                 release();
59             }
60         }
61     }
62     @Override
63     public OpenSslServerSessionContext sessionContext() {
64         return sessionContext;
65     }
66     static OpenSslServerSessionContext newSessionContext(ReferenceCountedOpenSslContext thiz, long ctx,
67                                                          OpenSslEngineMap engineMap,
68                                                          X509Certificate[] trustCertCollection,
69                                                          TrustManagerFactory trustManagerFactory,
70                                                          X509Certificate[] keyCertChain, PrivateKey key,
71                                                          String keyPassword, KeyManagerFactory keyManagerFactory,
72                                                          String keyStore, long sessionCacheSize, long sessionTimeout)
73             throws SSLException {
74         OpenSslKeyMaterialProvider keyMaterialProvider = null;
75         try {
76             try {
77                 SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, VERIFY_DEPTH);
78                 if (!OpenSsl.useKeyManagerFactory()) {
79                     if (keyManagerFactory != null) {
80                         throw new IllegalArgumentException(
81                                 "KeyManagerFactory not supported");
82                     }
83                     checkNotNull(keyCertChain, "keyCertChain");
84                     setKeyMaterial(ctx, keyCertChain, key, keyPassword);
85                 } else {
86                     if (keyManagerFactory == null) {
87                         char[] keyPasswordChars = keyStorePassword(keyPassword);
88                         KeyStore ks = buildKeyStore(keyCertChain, key, keyPasswordChars, keyStore);
89                         if (ks.aliases().hasMoreElements()) {
90                             keyManagerFactory = new OpenSslX509KeyManagerFactory();
91                         } else {
92                             keyManagerFactory = new OpenSslCachingX509KeyManagerFactory(
93                                     KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()));
94                         }
95                         keyManagerFactory.init(ks, keyPasswordChars);
96                     }
97                     keyMaterialProvider = providerFor(keyManagerFactory, keyPassword);
98                     SSLContext.setCertificateCallback(ctx, new OpenSslServerCertificateCallback(
99                             engineMap, new OpenSslKeyMaterialManager(keyMaterialProvider)));
100                 }
101             } catch (Exception e) {
102                 throw new SSLException("failed to set certificate and key", e);
103             }
104             try {
105                 if (trustCertCollection != null) {
106                     trustManagerFactory = buildTrustManagerFactory(trustCertCollection, trustManagerFactory, keyStore);
107                 } else if (trustManagerFactory == null) {
108                     trustManagerFactory = TrustManagerFactory.getInstance(
109                             TrustManagerFactory.getDefaultAlgorithm());
110                     trustManagerFactory.init((KeyStore) null);
111                 }
112                 final X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());
113                 //
114                 setVerifyCallback(ctx, engineMap, manager);
115                 X509Certificate[] issuers = manager.getAcceptedIssuers();
116                 if (issuers != null &amp;&amp; issuers.length &gt; 0) {
117                     long bio = 0;
118                     try {
119                         bio = toBIO(ByteBufAllocator.DEFAULT, issuers);
120                         if (!SSLContext.setCACertificateBio(ctx, bio)) {
121                             throw new SSLException("unable to setup accepted issuers for trustmanager " + manager);
122                         }
123                     } finally {
124                         freeBio(bio);
125                     }
126                 }
127                 if (PlatformDependent.javaVersion() &gt;= 8) {
128                     SSLContext.setSniHostnameMatcher(ctx, new OpenSslSniHostnameMatcher(engineMap));
129                 }
130             } catch (SSLException e) {
131                 throw e;
132             } catch (Exception e) {
133                 throw new SSLException("unable to setup trustmanager", e);
134             }
135             OpenSslServerSessionContext sessionContext = new OpenSslServerSessionContext(thiz, keyMaterialProvider);
136             sessionContext.setSessionIdContext(ID);
137             sessionContext.setSessionCacheEnabled(SERVER_ENABLE_SESSION_CACHE);
138             if (sessionCacheSize &gt; 0) {
139                 sessionContext.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));
140             }
141             if (sessionTimeout &gt; 0) {
142                 sessionContext.setSessionTimeout((int) Math.min(sessionTimeout, Integer.MAX_VALUE));
143             }
144             keyMaterialProvider = null;
145             return sessionContext;
146         } finally {
147             if (keyMaterialProvider != null) {
148                 keyMaterialProvider.destroy();
149             }
150         }
151     }
152     @SuppressJava6Requirement(reason = "Guarded by java version check")
153     private static void setVerifyCallback(long ctx, OpenSslEngineMap engineMap, X509TrustManager manager) {
154         if (useExtendedTrustManager(manager)) {
155             SSLContext.setCertVerifyCallback(ctx, new ExtendedTrustManagerVerifyCallback(
156                     engineMap, (X509ExtendedTrustManager) manager));
157         } else {
158             SSLContext.setCertVerifyCallback(ctx, new TrustManagerVerifyCallback(engineMap, manager));
159         }
160     }
161     private static final class OpenSslServerCertificateCallback implements CertificateCallback {
162         private final OpenSslEngineMap engineMap;
163         private final OpenSslKeyMaterialManager keyManagerHolder;
164         OpenSslServerCertificateCallback(OpenSslEngineMap engineMap, OpenSslKeyMaterialManager keyManagerHolder) {
165             this.engineMap = engineMap;
166             this.keyManagerHolder = keyManagerHolder;
167         }
168         @Override
169         public void handle(long ssl, byte[] keyTypeBytes, byte[][] asn1DerEncodedPrincipals) throws Exception {
170             final ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);
171             if (engine == null) {
172                 return;
173             }
174             try {
175                 keyManagerHolder.setKeyMaterialServerSide(engine);
176             } catch (Throwable cause) {
177                 engine.initHandshakeException(cause);
178                 if (cause instanceof Exception) {
179                     throw (Exception) cause;
180                 }
181                 throw new SSLException(cause);
182             }
183         }
184     }
185     private static final class TrustManagerVerifyCallback extends AbstractCertificateVerifier {
186         private final X509TrustManager manager;
187         TrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509TrustManager manager) {
188             super(engineMap);
189             this.manager = manager;
190         }
191         @Override
192         void verify(ReferenceCountedOpenSslEngine engine, X509Certificate[] peerCerts, String auth)
193                 throws Exception {
194             manager.checkClientTrusted(peerCerts, auth);
195         }
196     }
197     @SuppressJava6Requirement(reason = "Usage guarded by java version check")
198     private static final class ExtendedTrustManagerVerifyCallback extends AbstractCertificateVerifier {
199         private final X509ExtendedTrustManager manager;
200         ExtendedTrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509ExtendedTrustManager manager) {
201             super(engineMap);
202             this.manager = manager;
203         }
204         @Override
205         void verify(ReferenceCountedOpenSslEngine engine, X509Certificate[] peerCerts, String auth)
206                 throws Exception {
207             manager.checkClientTrusted(peerCerts, auth, engine);
208         }
209     }
210     private static final class OpenSslSniHostnameMatcher implements SniHostNameMatcher {
211         private final OpenSslEngineMap engineMap;
212         OpenSslSniHostnameMatcher(OpenSslEngineMap engineMap) {
213             this.engineMap = engineMap;
214         }
215         @Override
216         public boolean match(long ssl, String hostname) {
217             ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);
218             if (engine != null) {
219                 return engine.checkSniHostnameMatch(hostname.getBytes(CharsetUtil.UTF_8));
220             }
221             logger.warn("No ReferenceCountedOpenSslEngine found for SSL pointer: {}", ssl);
222             return false;
223         }
224     }
225 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
