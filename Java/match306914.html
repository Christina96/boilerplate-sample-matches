<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>Matches for DocIndexMetadataTest.java & InternalEngineTests.java</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>.modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgb(0, 0, 0);
        background-color: rgba(0, 0, 0, 0.4);
    }

    .modal-content {
        height: 250%;
        background-color: #fefefe;
        margin: 5% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
    }

    .close {
        color: #aaa;
        float: right;
        font-size: 20px;
        font-weight: bold;
    }

    .close:hover, .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }

    .column {
        float: left;
        width: 50%;
    }

    .row:after {
        content: ;
        display: table;
        clear: both;
    }

    #column1, #column2 {
        white-space: pre-wrap;
    }</style>
</HEAD>
<>
<div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
        <h3 align="center">
            Matches for DocIndexMetadataTest.java & InternalEngineTests.java
        </h3>
        <h1 align="center">
            26.6%
        </h1>
        <center>
            <a href="index.html" target="_top">
                INDEX
            </a>
            <span>-</span>
            <a href="help-en.html" target="_top">
                HELP
            </a>
        </center>
    </div>
    <div>
        <TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TH>
                <TH>DocIndexMetadataTest.java (82.48537%)
                <TH>InternalEngineTests.java (15.857353%)
                <TH>Tokens
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#0',2,'match306914-1.html#0',3)" NAME="0">(24-103)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#0',2,'match306914-1.html#0',3)" NAME="0">(132-209)</A>
                <TD ALIGN=center><FONT COLOR="#ff0000">75</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#1',2,'match306914-1.html#1',3)" NAME="1">(218-277)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#1',2,'match306914-1.html#1',3)" NAME="1">(390-409)</A>
                <TD ALIGN=center><FONT COLOR="#c80000">59</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#2',2,'match306914-1.html#2',3)" NAME="2">(421-468)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#2',2,'match306914-1.html#2',3)" NAME="2">(368-383)</A>
                <TD ALIGN=center><FONT COLOR="#a60000">49</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#3',2,'match306914-1.html#3',3)" NAME="3">(163-163)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#3',2,'match306914-1.html#3',3)" NAME="3">(335-347)</A>
                <TD ALIGN=center><FONT COLOR="#8e0000">42</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#4',2,'match306914-1.html#4',3)" NAME="4">(1295-1295)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#4',2,'match306914-1.html#4',3)" NAME="4">(662-672)</A>
                <TD ALIGN=center><FONT COLOR="#840000">39</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#5',2,'match306914-1.html#5',3)" NAME="5">(340-340)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#5',2,'match306914-1.html#5',3)" NAME="5">(413-423)</A>
                <TD ALIGN=center><FONT COLOR="#770000">35</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#6',2,'match306914-1.html#6',3)" NAME="6">(1345-1345)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#6',2,'match306914-1.html#6',3)" NAME="6">(311-319)</A>
                <TD ALIGN=center><FONT COLOR="#6c0000">32</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#7',2,'match306914-1.html#7',3)" NAME="7">(469-479)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#7',2,'match306914-1.html#7',3)" NAME="7">(459-468)</A>
                <TD ALIGN=center><FONT COLOR="#660000">30</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#8',2,'match306914-1.html#8',3)" NAME="8">(1273-1286)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#8',2,'match306914-1.html#8',3)" NAME="8">(423-431)</A>
                <TD ALIGN=center><FONT COLOR="#620000">29</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#9',2,'match306914-1.html#9',3)" NAME="9">(914-937)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#9',2,'match306914-1.html#9',3)" NAME="9">(5212-5221)</A>
                <TD ALIGN=center><FONT COLOR="#5b0000">27</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#10',2,'match306914-1.html#10',3)" NAME="10">(753-757)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#10',2,'match306914-1.html#10',3)" NAME="10">(437-446)</A>
                <TD ALIGN=center><FONT COLOR="#5b0000">27</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#11',2,'match306914-1.html#11',3)" NAME="11">(812-837)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#11',2,'match306914-1.html#11',3)" NAME="11">(323-331)</A>
                <TD ALIGN=center><FONT COLOR="#580000">26</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#12',2,'match306914-1.html#12',3)" NAME="12">(624-624)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#12',2,'match306914-1.html#12',3)" NAME="12">(5162-5171)</A>
                <TD ALIGN=center><FONT COLOR="#580000">26</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#13',2,'match306914-1.html#13',3)" NAME="13">(511-512)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#13',2,'match306914-1.html#13',3)" NAME="13">(639-653)</A>
                <TD ALIGN=center><FONT COLOR="#580000">26</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#14',2,'match306914-1.html#14',3)" NAME="14">(1502-1502)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#14',2,'match306914-1.html#14',3)" NAME="14">(446-453)</A>
                <TD ALIGN=center><FONT COLOR="#4e0000">23</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#15',2,'match306914-1.html#15',3)" NAME="15">(1004-1010)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#15',2,'match306914-1.html#15',3)" NAME="15">(608-615)</A>
                <TD ALIGN=center><FONT COLOR="#4e0000">23</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#16',2,'match306914-1.html#16',3)" NAME="16">(1226-1245)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#16',2,'match306914-1.html#16',3)" NAME="16">(6129-6136)</A>
                <TD ALIGN=center><FONT COLOR="#470000">21</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#17',2,'match306914-1.html#17',3)" NAME="17">(880-898)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#17',2,'match306914-1.html#17',3)" NAME="17">(5269-5275)</A>
                <TD ALIGN=center><FONT COLOR="#470000">21</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#18',2,'match306914-1.html#18',3)" NAME="18">(401-410)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#18',2,'match306914-1.html#18',3)" NAME="18">(2454-2459)</A>
                <TD ALIGN=center><FONT COLOR="#470000">21</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#19',2,'match306914-1.html#19',3)" NAME="19">(1209-1225)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#19',2,'match306914-1.html#19',3)" NAME="19">(4904-4912)</A>
                <TD ALIGN=center><FONT COLOR="#440000">20</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#20',2,'match306914-1.html#20',3)" NAME="20">(1172-1175)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#20',2,'match306914-1.html#20',3)" NAME="20">(4651-4658)</A>
                <TD ALIGN=center><FONT COLOR="#440000">20</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#21',2,'match306914-1.html#21',3)" NAME="21">(870-876)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#21',2,'match306914-1.html#21',3)" NAME="21">(1562-1573)</A>
                <TD ALIGN=center><FONT COLOR="#440000">20</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#22',2,'match306914-1.html#22',3)" NAME="22">(536-556)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#22',2,'match306914-1.html#22',3)" NAME="22">(3965-3975)</A>
                <TD ALIGN=center><FONT COLOR="#440000">20</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#23',2,'match306914-1.html#23',3)" NAME="23">(134-134)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#23',2,'match306914-1.html#23',3)" NAME="23">(6336-6341)</A>
                <TD ALIGN=center><FONT COLOR="#440000">20</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#24',2,'match306914-1.html#24',3)" NAME="24">(966-981)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#24',2,'match306914-1.html#24',3)" NAME="24">(5367-5377)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#25',2,'match306914-1.html#25',3)" NAME="25">(849-849)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#25',2,'match306914-1.html#25',3)" NAME="25">(2549-2559)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#26',2,'match306914-1.html#26',3)" NAME="26">(782-782)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#26',2,'match306914-1.html#26',3)" NAME="26">(2527-2538)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#27',2,'match306914-1.html#27',3)" NAME="27">(736-752)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#27',2,'match306914-1.html#27',3)" NAME="27">(5238-5245)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#28',2,'match306914-1.html#28',3)" NAME="28">(706-706)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#28',2,'match306914-1.html#28',3)" NAME="28">(453-459)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#29',2,'match306914-1.html#29',3)" NAME="29">(483-483)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#29',2,'match306914-1.html#29',3)" NAME="29">(6179-6184)</A>
                <TD ALIGN=center><FONT COLOR="#400000">19</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ae694a"><FONT COLOR="#ae694a">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#30',2,'match306914-1.html#30',3)" NAME="30">(1191-1208)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#30',2,'match306914-1.html#30',3)" NAME="30">(575-581)</A>
                <TD ALIGN=center><FONT COLOR="#3d0000">18</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3ea99f"><FONT COLOR="#3ea99f">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#31',2,'match306914-1.html#31',3)" NAME="31">(842-849)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#31',2,'match306914-1.html#31',3)" NAME="31">(2880-2888)</A>
                <TD ALIGN=center><FONT COLOR="#3d0000">18</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#5b8daf"><FONT COLOR="#5b8daf">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#32',2,'match306914-1.html#32',3)" NAME="32">(1472-1488)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#32',2,'match306914-1.html#32',3)" NAME="32">(3053-3061)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#736aff"><FONT COLOR="#736aff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#33',2,'match306914-1.html#33',3)" NAME="33">(1423-1428)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#33',2,'match306914-1.html#33',3)" NAME="33">(1225-1230)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#827d6b"><FONT COLOR="#827d6b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#34',2,'match306914-1.html#34',3)" NAME="34">(1337-1344)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#34',2,'match306914-1.html#34',3)" NAME="34">(5860-5869)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#41a317"><FONT COLOR="#41a317">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#35',2,'match306914-1.html#35',3)" NAME="35">(1287-1294)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#35',2,'match306914-1.html#35',3)" NAME="35">(891-901)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ff00ff"><FONT COLOR="#ff00ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#36',2,'match306914-1.html#36',3)" NAME="36">(1147-1151)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#36',2,'match306914-1.html#36',3)" NAME="36">(3630-3638)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#810541"><FONT COLOR="#810541">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#37',2,'match306914-1.html#37',3)" NAME="37">(1129-1133)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#37',2,'match306914-1.html#37',3)" NAME="37">(3618-3626)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#348781"><FONT COLOR="#348781">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#38',2,'match306914-1.html#38',3)" NAME="38">(721-730)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#38',2,'match306914-1.html#38',3)" NAME="38">(5819-5825)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#152dc6"><FONT COLOR="#152dc6">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#39',2,'match306914-1.html#39',3)" NAME="39">(681-681)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#39',2,'match306914-1.html#39',3)" NAME="39">(5179-5187)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#347235"><FONT COLOR="#347235">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#40',2,'match306914-1.html#40',3)" NAME="40">(656-668)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#40',2,'match306914-1.html#40',3)" NAME="40">(3413-3420)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f87a17"><FONT COLOR="#f87a17">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#41',2,'match306914-1.html#41',3)" NAME="41">(207-210)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#41',2,'match306914-1.html#41',3)" NAME="41">(4417-4423)</A>
                <TD ALIGN=center><FONT COLOR="#390000">17</FONT>
            <TR  onclick='openModal("#c57717")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c57717"><FONT COLOR="#c57717">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#42',2,'match306914-1.html#42',3)" NAME="42">(1529-1535)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#42',2,'match306914-1.html#42',3)" NAME="42">(1157-1164)</A>
                <TD ALIGN=center><FONT COLOR="#360000">16</FONT>
            <TR  onclick='openModal("#c22817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c22817"><FONT COLOR="#c22817">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#43',2,'match306914-1.html#43',3)" NAME="43">(1405-1405)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#43',2,'match306914-1.html#43',3)" NAME="43">(2150-2154)</A>
                <TD ALIGN=center><FONT COLOR="#360000">16</FONT>
            <TR  onclick='openModal("#a057a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#a057a5"><FONT COLOR="#a057a5">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#44',2,'match306914-1.html#44',3)" NAME="44">(987-987)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#44',2,'match306914-1.html#44',3)" NAME="44">(431-436)</A>
                <TD ALIGN=center><FONT COLOR="#360000">16</FONT>
            <TR  onclick='openModal("#549748")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#549748"><FONT COLOR="#549748">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#45',2,'match306914-1.html#45',3)" NAME="45">(949-959)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#45',2,'match306914-1.html#45',3)" NAME="45">(6079-6091)</A>
                <TD ALIGN=center><FONT COLOR="#360000">16</FONT>
            <TR  onclick='openModal("#668b8b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#668b8b"><FONT COLOR="#668b8b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#46',2,'match306914-1.html#46',3)" NAME="46">(938-948)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#46',2,'match306914-1.html#46',3)" NAME="46">(553-560)</A>
                <TD ALIGN=center><FONT COLOR="#360000">16</FONT>
            <TR  onclick='openModal("#d16587")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#d16587"><FONT COLOR="#d16587">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#47',2,'match306914-1.html#47',3)" NAME="47">(1156-1157)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#47',2,'match306914-1.html#47',3)" NAME="47">(2717-2730)</A>
                <TD ALIGN=center><FONT COLOR="#330000">15</FONT>
            <TR  onclick='openModal("#c57726")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c57726"><FONT COLOR="#c57726">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#48',2,'match306914-1.html#48',3)" NAME="48">(1072-1084)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#48',2,'match306914-1.html#48',3)" NAME="48">(4698-4703)</A>
                <TD ALIGN=center><FONT COLOR="#330000">15</FONT>
            <TR  onclick='openModal("#8e35ef")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#8e35ef"><FONT COLOR="#8e35ef">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#49',2,'match306914-1.html#49',3)" NAME="49">(1016-1032)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#49',2,'match306914-1.html#49',3)" NAME="49">(1766-1775)</A>
                <TD ALIGN=center><FONT COLOR="#330000">15</FONT>
            <TR  onclick='openModal("#ff0000")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ff0000"><FONT COLOR="#ff0000">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#50',2,'match306914-1.html#50',3)" NAME="50">(1544-1558)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#50',2,'match306914-1.html#50',3)" NAME="50">(2964-2972)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#b38481")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#b38481"><FONT COLOR="#b38481">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#51',2,'match306914-1.html#51',3)" NAME="51">(1495-1502)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#51',2,'match306914-1.html#51',3)" NAME="51">(4463-4475)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#2b60de")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#2b60de"><FONT COLOR="#2b60de">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#52',2,'match306914-1.html#52',3)" NAME="52">(1383-1391)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#52',2,'match306914-1.html#52',3)" NAME="52">(1496-1503)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#ad5a3d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ad5a3d"><FONT COLOR="#ad5a3d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#53',2,'match306914-1.html#53',3)" NAME="53">(1107-1113)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#53',2,'match306914-1.html#53',3)" NAME="53">(1197-1204)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#4e8975")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4e8975"><FONT COLOR="#4e8975">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#54',2,'match306914-1.html#54',3)" NAME="54">(900-911)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#54',2,'match306914-1.html#54',3)" NAME="54">(4059-4066)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#4863a0")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4863a0"><FONT COLOR="#4863a0">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#55',2,'match306914-1.html#55',3)" NAME="55">(804-812)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#55',2,'match306914-1.html#55',3)" NAME="55">(4091-4100)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#52d017")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#52d017"><FONT COLOR="#52d017">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#56',2,'match306914-1.html#56',3)" NAME="56">(700-706)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#56',2,'match306914-1.html#56',3)" NAME="56">(3275-3288)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#57',2,'match306914-1.html#57',3)" NAME="57">(378-384)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#57',2,'match306914-1.html#57',3)" NAME="57">(5205-5211)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#58',2,'match306914-1.html#58',3)" NAME="58">(288-293)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#58',2,'match306914-1.html#58',3)" NAME="58">(4047-4054)</A>
                <TD ALIGN=center><FONT COLOR="#2f0000">14</FONT>
            <TR  onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#59',2,'match306914-1.html#59',3)" NAME="59">(1459-1466)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#59',2,'match306914-1.html#59',3)" NAME="59">(1297-1304)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#60',2,'match306914-1.html#60',3)" NAME="60">(1452-1458)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#60',2,'match306914-1.html#60',3)" NAME="60">(786-792)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#61',2,'match306914-1.html#61',3)" NAME="61">(1447-1451)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#61',2,'match306914-1.html#61',3)" NAME="61">(1277-1282)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#62',2,'match306914-1.html#62',3)" NAME="62">(1431-1433)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#62',2,'match306914-1.html#62',3)" NAME="62">(2402-2413)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#63',2,'match306914-1.html#63',3)" NAME="63">(1379-1382)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#63',2,'match306914-1.html#63',3)" NAME="63">(6062-6077)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#64',2,'match306914-1.html#64',3)" NAME="64">(1258-1272)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#64',2,'match306914-1.html#64',3)" NAME="64">(5762-5769)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#65',2,'match306914-1.html#65',3)" NAME="65">(1254-1257)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#65',2,'match306914-1.html#65',3)" NAME="65">(3497-3513)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#66',2,'match306914-1.html#66',3)" NAME="66">(1133-1147)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#66',2,'match306914-1.html#66',3)" NAME="66">(1315-1322)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#67',2,'match306914-1.html#67',3)" NAME="67">(1046-1052)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#67',2,'match306914-1.html#67',3)" NAME="67">(1468-1475)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#68',2,'match306914-1.html#68',3)" NAME="68">(670-677)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#68',2,'match306914-1.html#68',3)" NAME="68">(2814-2820)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#69',2,'match306914-1.html#69',3)" NAME="69">(590-595)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#69',2,'match306914-1.html#69',3)" NAME="69">(5449-5459)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#70',2,'match306914-1.html#70',3)" NAME="70">(572-576)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#70',2,'match306914-1.html#70',3)" NAME="70">(5739-5744)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#71',2,'match306914-1.html#71',3)" NAME="71">(324-329)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#71',2,'match306914-1.html#71',3)" NAME="71">(5745-5759)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#72',2,'match306914-1.html#72',3)" NAME="72">(210-212)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#72',2,'match306914-1.html#72',3)" NAME="72">(3447-3462)</A>
                <TD ALIGN=center><FONT COLOR="#2c0000">13</FONT>
            <TR  onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#73',2,'match306914-1.html#73',3)" NAME="73">(1466-1472)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#73',2,'match306914-1.html#73',3)" NAME="73">(1332-1338)</A>
                <TD ALIGN=center><FONT COLOR="#280000">12</FONT>
            <TR  onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#74',2,'match306914-1.html#74',3)" NAME="74">(595-608)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#74',2,'match306914-1.html#74',3)" NAME="74">(6035-6037)</A>
                <TD ALIGN=center><FONT COLOR="#280000">12</FONT>
            <TR  onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#75',2,'match306914-1.html#75',3)" NAME="75">(501-507)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#75',2,'match306914-1.html#75',3)" NAME="75">(3024-3028)</A>
                <TD ALIGN=center><FONT COLOR="#280000">12</FONT>
            <TR  onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#76',2,'match306914-1.html#76',3)" NAME="76">(278-283)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#76',2,'match306914-1.html#76',3)" NAME="76">(2841-2846)</A>
                <TD ALIGN=center><FONT COLOR="#280000">12</FONT>
            <TR  onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#77',2,'match306914-1.html#77',3)" NAME="77">(1489-1490)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#77',2,'match306914-1.html#77',3)" NAME="77">(2443-2446)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#78',2,'match306914-1.html#78',3)" NAME="78">(1035-1044)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#78',2,'match306914-1.html#78',3)" NAME="78">(1574-1579)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#79',2,'match306914-1.html#79',3)" NAME="79">(865-869)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#79',2,'match306914-1.html#79',3)" NAME="79">(5494-5496)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#80',2,'match306914-1.html#80',3)" NAME="80">(774-777)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#80',2,'match306914-1.html#80',3)" NAME="80">(385-389)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#81',2,'match306914-1.html#81',3)" NAME="81">(649-654)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#81',2,'match306914-1.html#81',3)" NAME="81">(1115-1123)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#82',2,'match306914-1.html#82',3)" NAME="82">(579-583)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#82',2,'match306914-1.html#82',3)" NAME="82">(287-292)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#83',2,'match306914-1.html#83',3)" NAME="83">(283-286)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#83',2,'match306914-1.html#83',3)" NAME="83">(269-283)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#84',2,'match306914-1.html#84',3)" NAME="84">(109-118)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#84',2,'match306914-1.html#84',3)" NAME="84">(1167-1171)</A>
                <TD ALIGN=center><FONT COLOR="#250000">11</FONT>
            <TR  onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#85',2,'match306914-1.html#85',3)" NAME="85">(1558-1561)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#85',2,'match306914-1.html#85',3)" NAME="85">(1243-1257)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#86',2,'match306914-1.html#86',3)" NAME="86">(1536-1539)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#86',2,'match306914-1.html#86',3)" NAME="86">(856-859)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ae694a"><FONT COLOR="#ae694a">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#87',2,'match306914-1.html#87',3)" NAME="87">(1418-1422)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#87',2,'match306914-1.html#87',3)" NAME="87">(1837-1839)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#3ea99f"><FONT COLOR="#3ea99f">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#88',2,'match306914-1.html#88',3)" NAME="88">(1118-1123)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#88',2,'match306914-1.html#88',3)" NAME="88">(694-700)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#5b8daf"><FONT COLOR="#5b8daf">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#89',2,'match306914-1.html#89',3)" NAME="89">(962-966)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#89',2,'match306914-1.html#89',3)" NAME="89">(862-867)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#736aff"><FONT COLOR="#736aff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#90',2,'match306914-1.html#90',3)" NAME="90">(959-961)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#90',2,'match306914-1.html#90',3)" NAME="90">(348-360)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#827d6b"><FONT COLOR="#827d6b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#91',2,'match306914-1.html#91',3)" NAME="91">(393-397)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#91',2,'match306914-1.html#91',3)" NAME="91">(3202-3210)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#41a317")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#41a317"><FONT COLOR="#41a317">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#92',2,'match306914-1.html#92',3)" NAME="92">(385-388)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#92',2,'match306914-1.html#92',3)" NAME="92">(5465-5469)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#ff00ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#ff00ff"><FONT COLOR="#ff00ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#93',2,'match306914-1.html#93',3)" NAME="93">(317-320)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#93',2,'match306914-1.html#93',3)" NAME="93">(5091-5094)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#810541")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#810541"><FONT COLOR="#810541">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#94',2,'match306914-1.html#94',3)" NAME="94">(313-316)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#94',2,'match306914-1.html#94',3)" NAME="94">(3605-3616)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#348781")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#348781"><FONT COLOR="#348781">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#95',2,'match306914-1.html#95',3)" NAME="95">(309-312)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#95',2,'match306914-1.html#95',3)" NAME="95">(3539-3544)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#152dc6")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#152dc6"><FONT COLOR="#152dc6">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#96',2,'match306914-1.html#96',3)" NAME="96">(305-308)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#96',2,'match306914-1.html#96',3)" NAME="96">(3526-3531)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#347235")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#347235"><FONT COLOR="#347235">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#97',2,'match306914-1.html#97',3)" NAME="97">(301-304)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#97',2,'match306914-1.html#97',3)" NAME="97">(2908-2911)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#f87a17")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#f87a17"><FONT COLOR="#f87a17">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#98',2,'match306914-1.html#98',3)" NAME="98">(297-300)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#98',2,'match306914-1.html#98',3)" NAME="98">(482-486)</A>
                <TD ALIGN=center><FONT COLOR="#220000">10</FONT>
            <TR  onclick='openModal("#c57717")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c57717"><FONT COLOR="#c57717">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#99',2,'match306914-1.html#99',3)" NAME="99">(1525-1528)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#99',2,'match306914-1.html#99',3)" NAME="99">(3129-3131)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#c22817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c22817"><FONT COLOR="#c22817">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#100',2,'match306914-1.html#100',3)" NAME="100">(1032-1034)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#100',2,'match306914-1.html#100',3)" NAME="100">(946-951)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#a057a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#a057a5"><FONT COLOR="#a057a5">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#101',2,'match306914-1.html#101',3)" NAME="101">(410-421)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#101',2,'match306914-1.html#101',3)" NAME="101">(5626-5631)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#549748")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#549748"><FONT COLOR="#549748">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#102',2,'match306914-1.html#102',3)" NAME="102">(388-393)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#102',2,'match306914-1.html#102',3)" NAME="102">(2291-2297)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#668b8b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#668b8b"><FONT COLOR="#668b8b">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#103',2,'match306914-1.html#103',3)" NAME="103">(329-340)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#103',2,'match306914-1.html#103',3)" NAME="103">(5230-5235)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#d16587")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#d16587"><FONT COLOR="#d16587">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#104',2,'match306914-1.html#104',3)" NAME="104">(320-324)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#104',2,'match306914-1.html#104',3)" NAME="104">(1948-1959)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#c57726")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#c57726"><FONT COLOR="#c57726">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#105',2,'match306914-1.html#105',3)" NAME="105">(293-296)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#105',2,'match306914-1.html#105',3)" NAME="105">(3755-3756)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
            <TR  onclick='openModal("#8e35ef")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#8e35ef"><FONT COLOR="#8e35ef">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#106',2,'match306914-1.html#106',3)" NAME="106">(154-158)
                <TD><A HREF="javascript:ZweiFrames('match306914-0.html#106',2,'match306914-1.html#106',3)" NAME="106">(1272-1276)</A>
                <TD ALIGN=center><FONT COLOR="#1e0000">9</FONT>
        </TABLE>
    </div>
</div>
<hr>
<div style="display: flex;">
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>DocIndexMetadataTest.java</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.metadata.doc;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match306914-1.html#0',3,'match306914-top.html#0',1)"><IMG
        SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.Constants;
import io.crate.action.sql.SessionContext;
import io.crate.analyze.Analysis;
import io.crate.analyze.AnalyzedCreateTable;
import io.crate.analyze.BoundCreateTable;
import io.crate.analyze.CreateTableStatementAnalyzer;
import io.crate.analyze.NumberOfShards;
import io.crate.analyze.ParamTypeHints;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.FulltextAnalyzerResolver;
import io.crate.metadata.GeneratedReference;
import io.crate.metadata.IndexReference;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Reference;
import io.crate.metadata.RelationName;
import io.crate.metadata.Schemas;
import io.crate.metadata.view.ViewInfoFactory;
import io.crate.planner.node.ddl.CreateTablePlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.sql.parser.SqlParser;
import io.crate.sql.tree.CheckConstraint;
import io.crate.sql.tree.ColumnPolicy;
import io.crate.sql.tree.CreateTable;
import io.crate.sql.tree.Expression;
import io.crate.sql.tree.Statement;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.types.ArrayType;
import io.crate.types.DataType;
import io.crate.types.DataTypes;
import io.crate.types.ObjectType;
import io.crate.types.StringType;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.metadata.MappingMetadata;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentHelper;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.env.Environment;
import org.elasticsearch.index.analysis.AnalysisRegistry;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;

import static io.crate.testing.TestingHelpers.createNodeContext;
import static io.crate.testing.SymbolMatchers.isFunction;
import static io.crate.testing.SymbolMatchers.isLiteral;
import static io.crate.testing.SymbolMatchers.isReference;
import static java.util.Collections.emptyMap;
import static org.hamcrest.Matchers.contains;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.collection.IsCollectionWithSize.hasSize;

// @formatter:off
public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {

    private UserDefinedFunctionService udfService</B></FONT>;
    private NodeContext nodeCtx;

<A NAME="84"></A>    private IndexMetadata getIndexMetadata(String indexName,
                                           XContentBuilder builder) throws IOException {
        Map&lt;String, Object&gt; mappingSource = XContentHelper.convertToMap(BytesReference.bytes(builder), true, XContentType.JSON).v2();
        mappingSource = <FONT color="#e77471"><A
                HREF="javascript:ZweiFrames('match306914-1.html#84',3,'match306914-top.html#84',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>sortProperties(mappingSource);

        Settings.Builder settingsBuilder = Settings.builder()
            .put(&quot;index.number_of_shards&quot;, 1)
            .put(&quot;index.number_of_replicas&quot;, 0)
            .put(&quot;index.version.created&quot;, org.elasticsearch.Version.CURRENT);

        IndexMetadata.Builder mdBuilder = IndexMetadata.builder(indexName)
            .settings(settingsBuilder)
            .putMapping(new</B></FONT> MappingMetadata(Constants.DEFAULT_MAPPING_TYPE, mappingSource));
        return mdBuilder.build();
    }

    private DocIndexMetadata newMeta(IndexMetadata metadata, String name) throws IOException {
        return new DocIndexMetadata(nodeCtx, metadata, new RelationName(Schemas.DOC_SCHEMA_NAME, name)).build();
    }

    @Before
    public void setupUdfService() {
        nodeCtx = createNodeContext();
        udfService = new UserDefinedFunctionService(clusterService, nodeCtx);
    }
<A NAME="23"></A>
    @Test
    public void testNestedColumnIdent() throws Exception {
        <FONT color="#f660ab"><A
                HREF="javascript:ZweiFrames('match306914-1.html#23',3,'match306914-top.html#23',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;person&quot;)
                        .startObject(&quot;properties&quot;)
                            .startObject(&quot;addresses&quot;)
                                .startObject(&quot;properties&quot;)
                                    .startObject(&quot;city&quot;)
                                        .field(&quot;type&quot;, &quot;string&quot;)
                                    .endObject()
                                    .startObject(&quot;country&quot;)
                                        .field(&quot;type&quot;, &quot;string&quot;)
                                    .endObject()
                                .endObject()
                            .endObject()
                        .endObject()
                    .endObject()
<A NAME="106"></A>                .endObject()
            .endObject();

        IndexMetadata metadata = <FONT color="#8e35ef"><A
                HREF="javascript:ZweiFrames('match306914-1.html#106',3,'match306914-top.html#106',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);

        Reference reference = md.references().get(new ColumnIdent(&quot;person&quot;, Arrays.asList(&quot;addresses&quot;, &quot;city&quot;)));
        assertNotNull</B></FONT>(reference);
    }
<A NAME="3"></A>
    @Test
    public void testExtractObjectColumnDefinitions() throws Exception {
        XContentBuilder builder = <FONT color="#53858b"><A
                HREF="javascript:ZweiFrames('match306914-1.html#3',3,'match306914-top.html#3',1)"><IMG SRC="forward.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;implicit_dynamic&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;name&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .endObject()
            .endObject()
            .startObject(&quot;explicit_dynamic&quot;)
            .field(&quot;dynamic&quot;, &quot;true&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;name&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .startObject(&quot;age&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .endObject()
            .endObject()
            .startObject(&quot;ignored&quot;)
            .field(&quot;dynamic&quot;, &quot;false&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;name&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .startObject(&quot;age&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .endObject()
            .endObject()
            .startObject(&quot;strict&quot;)
            .field(&quot;dynamic&quot;, &quot;strict&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;age&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject()
<A NAME="41"></A>            .endObject();
        IndexMetadata metadata = getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);
<A NAME="72"></A>        assertThat(<FONT color="#f87a17"><A
                HREF="javascript:ZweiFrames('match306914-1.html#41',3,'match306914-top.html#41',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.columns().size(), is(4));
        assertThat(md.references().size(), is(20));
        assertThat(md.references().get(new ColumnIdent(&quot;implicit_dynamic&quot;)).columnPolicy(), is(ColumnPolicy.DYNAMIC));
        assertThat(md.references</B></FONT>().get(new ColumnIdent(&quot;explicit_dynamic&quot;)).columnPolicy(), <FONT
                color="#f52887"><A
                HREF="javascript:ZweiFrames('match306914-1.html#72',3,'match306914-top.html#72',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(ColumnPolicy.DYNAMIC));
        assertThat(md.references().get(new ColumnIdent(&quot;ignored&quot;)).columnPolicy(), is(ColumnPolicy.IGNORED));
        assertThat(md.references().get(new ColumnIdent(&quot;strict&quot;)).columnPolicy(), is</B></FONT>(ColumnPolicy.STRICT));
    }

<A NAME="1"></A>    @Test
    public void testExtractColumnDefinitions() throws Exception {
        // @formatter:off
        XContentBuilder builder = <FONT color="#f63526"><A
                HREF="javascript:ZweiFrames('match306914-1.html#1',3,'match306914-top.html#1',1)"><IMG SRC="forward.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="right"></A><B>XContentFactory.jsonBuilder()
            .startObject()
                .startObject(&quot;_meta&quot;)
                    .field(&quot;primary_keys&quot;, &quot;integerIndexed&quot;)
                .endObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;integerIndexed&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                    .endObject()
                    .startObject(&quot;integerIndexedBWC&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                        .field(&quot;index&quot;, &quot;not_analyzed&quot;)
                    .endObject()
                    .startObject(&quot;integerNotIndexed&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                        .field(&quot;index&quot;, &quot;false&quot;)
                    .endObject()
                    .startObject(&quot;integerNotIndexedBWC&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                        .field(&quot;index&quot;, &quot;no&quot;)
                    .endObject()
                    .startObject(&quot;stringNotIndexed&quot;)
                        .field(&quot;type&quot;, &quot;string&quot;)
                        .field(&quot;index&quot;, &quot;false&quot;)
                    .endObject()
                    .startObject(&quot;stringNotIndexedBWC&quot;)
                        .field(&quot;type&quot;, &quot;string&quot;)
                        .field(&quot;index&quot;, &quot;no&quot;)
                    .endObject()
                    .startObject(&quot;stringNotAnalyzed&quot;)
                        .field(&quot;type&quot;, &quot;keyword&quot;)
                    .endObject()
                    .startObject(&quot;stringNotAnalyzedBWC&quot;)
                        .field(&quot;type&quot;, &quot;string&quot;)
                        .field(&quot;index&quot;, &quot;not_analyzed&quot;)
                    .endObject()
                    .startObject(&quot;stringAnalyzed&quot;)
                        .field(&quot;type&quot;, &quot;text&quot;)
                        .field(&quot;analyzer&quot;, &quot;standard&quot;)
                    .endObject()
                    .startObject(&quot;stringAnalyzedBWC&quot;)
                        .field(&quot;type&quot;, &quot;string&quot;)
                        .field(&quot;index&quot;, &quot;analyzed&quot;)
                        .field(&quot;analyzer&quot;, &quot;standard&quot;)
                    .endObject()
                    .startObject(&quot;person&quot;)
                        .startObject(&quot;properties&quot;)
                            .startObject(&quot;first_name&quot;)
                                .field(&quot;type&quot;, &quot;string&quot;)
                            .endObject()
                            .startObject(&quot;birthday&quot;)
                                .field(&quot;type&quot;, &quot;date&quot;)
                            .endObject()
                        .endObject()
                    .endObject()
                .endObject()
            .endObject();
<A NAME="76"></A>        // @formatter:on

        IndexMetadata metadata = getIndexMetadata</B></FONT>(&quot;test1&quot;, builder);
        <FONT color="#f62817"><A
                HREF="javascript:ZweiFrames('match306914-1.html#76',3,'match306914-top.html#76',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);

<A NAME="83"></A>        assertThat(md.columns().size(), is(11));
        assertThat(md.references().size(), is(23));

        Reference birthday = <FONT color="#68818b"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#83',3,'match306914-top.html#83',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get</B></FONT>(new ColumnIdent(&quot;person&quot;, &quot;birthday&quot;));
        assertThat(birthday.valueType(), is(DataTypes.TIMESTAMPZ));
<A NAME="58"></A>        assertThat(birthday.indexType(), is(Reference.IndexType.PLAIN));
        assertThat(birthday.defaultExpression(), is</B></FONT>(nullValue()) );

        Reference integerIndexed = <FONT color="#f63526"><A
                HREF="javascript:ZweiFrames('match306914-1.html#58',3,'match306914-top.html#58',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get(new ColumnIdent(&quot;integerIndexed&quot;));
        assertThat(integerIndexed.indexType(), is(Reference.IndexType.PLAIN));
<A NAME="105"></A>        assertThat(integerIndexed.defaultExpression(), is(nullValue()) );

        Reference integerIndexedBWC = md.references().get(new ColumnIdent(&quot;integerIndexedBWC&quot;));
        assertThat</B></FONT>(<FONT color="#c57726"><A
                HREF="javascript:ZweiFrames('match306914-1.html#105',3,'match306914-top.html#105',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>integerIndexedBWC.indexType(), is(Reference.IndexType.PLAIN));
<A NAME="98"></A>        assertThat(integerIndexedBWC.defaultExpression(), is(nullValue()) );

        Reference integerNotIndexed = md.references</B></FONT>().get(new ColumnIdent(&quot;integerNotIndexed&quot;));
        <FONT color="#f87a17"><A
                HREF="javascript:ZweiFrames('match306914-1.html#98',3,'match306914-top.html#98',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(integerNotIndexed.indexType(), is(Reference.IndexType.NONE));
<A NAME="97"></A>        assertThat(integerNotIndexed.defaultExpression(), is(nullValue()) );

        Reference integerNotIndexedBWC = md.references</B></FONT>().get(new ColumnIdent(&quot;integerNotIndexedBWC&quot;));
        <FONT color="#347235"><A
                HREF="javascript:ZweiFrames('match306914-1.html#97',3,'match306914-top.html#97',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(integerNotIndexedBWC.indexType(), is(Reference.IndexType.NONE));
<A NAME="96"></A>        assertThat(integerNotIndexedBWC.defaultExpression(), is(nullValue()) );

        Reference stringNotIndexed = md.references</B></FONT>().get(new ColumnIdent(&quot;stringNotIndexed&quot;));
        <FONT color="#152dc6"><A
                HREF="javascript:ZweiFrames('match306914-1.html#96',3,'match306914-top.html#96',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(stringNotIndexed.indexType(), is(Reference.IndexType.NONE));
<A NAME="95"></A>        assertThat(stringNotIndexed.defaultExpression(), is(nullValue()) );

        Reference stringNotIndexedBWC = md.references</B></FONT>().get(new ColumnIdent(&quot;stringNotIndexedBWC&quot;));
        <FONT color="#348781"><A
                HREF="javascript:ZweiFrames('match306914-1.html#95',3,'match306914-top.html#95',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(stringNotIndexedBWC.indexType(), is(Reference.IndexType.NONE));
<A NAME="94"></A>        assertThat(stringNotIndexedBWC.defaultExpression(), is(nullValue()) );

        Reference stringNotAnalyzed = md.references</B></FONT>().get(new ColumnIdent(&quot;stringNotAnalyzed&quot;));
        <FONT color="#810541"><A
                HREF="javascript:ZweiFrames('match306914-1.html#94',3,'match306914-top.html#94',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(stringNotAnalyzed.indexType(), is(Reference.IndexType.PLAIN));
<A NAME="93"></A>        assertThat(stringNotAnalyzed.defaultExpression(), is(nullValue()) );

        Reference stringNotAnalyzedBWC = md.references</B></FONT>().get(new ColumnIdent(&quot;stringNotAnalyzedBWC&quot;));
<A NAME="104"></A>        <FONT color="#ff00ff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#93',3,'match306914-top.html#93',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(stringNotAnalyzedBWC.indexType(), is(Reference.IndexType.PLAIN));
        assertThat(stringNotAnalyzedBWC.defaultExpression(), is(nullValue()) );

        Reference stringAnalyzed = md.references</B></FONT>().get(<FONT color="#d16587"><A
                HREF="javascript:ZweiFrames('match306914-1.html#104',3,'match306914-top.html#104',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ColumnIdent(&quot;stringAnalyzed&quot;));
<A NAME="71"></A>        assertThat(stringAnalyzed.indexType(), is(Reference.IndexType.FULLTEXT));
        assertThat(stringAnalyzed.defaultExpression(), is(nullValue()) );

        Reference stringAnalyzedBWC = <FONT color="#842dce"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#71',3,'match306914-top.html#71',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get(new ColumnIdent(&quot;stringAnalyzedBWC&quot;))</B></FONT>;
        assertThat(stringAnalyzedBWC.indexType(), is(Reference.IndexType.FULLTEXT));
<A NAME="103"></A>        assertThat(stringAnalyzedBWC.defaultExpression(), is(nullValue()) );

        assertThat(
            Lists2.map(md.references</B></FONT>().values(), r -&gt; <FONT color="#668b8b"><A
                HREF="javascript:ZweiFrames('match306914-1.html#103',3,'match306914-top.html#103',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>r.column().fqn()),
            containsInAnyOrder(&quot;_doc&quot;, &quot;_fetchid&quot;, &quot;_id&quot;, &quot;_raw&quot;, &quot;_score&quot;, &quot;_uid&quot;, &quot;_version&quot;, &quot;_docid&quot;, &quot;_seq_no&quot;,
                &quot;_primary_term&quot;, &quot;integerIndexed&quot;, &quot;integerIndexedBWC&quot;, &quot;integerNotIndexed&quot;, &quot;integerNotIndexedBWC&quot;,
                &quot;person&quot;, &quot;person.birthday&quot;, &quot;person.first_name&quot;,
                &quot;stringAnalyzed&quot;, &quot;stringAnalyzedBWC&quot;, &quot;stringNotAnalyzed&quot;, &quot;stringNotAnalyzedBWC&quot;,
                &quot;stringNotIndexed&quot;, &quot;stringNotIndexedBWC&quot;));
    }

<A NAME="5"></A>    @Test
    public void testExtractColumnDefinitionsWithDefaultExpression() throws Exception {
        // @formatter:off
        XContentBuilder builder = <FONT color="#151b8d"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#5',3,'match306914-top.html#5',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()</B></FONT>
            .startObject()
                .startObject(&quot;_meta&quot;)
                    .field(&quot;primary_keys&quot;, &quot;integerIndexed&quot;)
                .endObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;integerIndexed&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                        .field(&quot;default_expr&quot;, &quot;1&quot;)
                    .endObject()
                    .startObject(&quot;integerNotIndexed&quot;)
                        .field(&quot;type&quot;, &quot;integer&quot;)
                        .field(&quot;index&quot;, &quot;false&quot;)
                        .field(&quot;default_expr&quot;, &quot;1&quot;)
                    .endObject()
                    .startObject(&quot;stringNotIndexed&quot;)
                        .field(&quot;type&quot;, &quot;string&quot;)
                        .field(&quot;index&quot;, &quot;false&quot;)
                        .field(&quot;default_expr&quot;, &quot;'default'&quot;)
                    .endObject()
                    .startObject(&quot;stringNotAnalyzed&quot;)
                        .field(&quot;type&quot;, &quot;keyword&quot;)
                        .field(&quot;default_expr&quot;, &quot;'default'&quot;)
                    .endObject()
                    .startObject(&quot;stringAnalyzed&quot;)
                        .field(&quot;type&quot;, &quot;text&quot;)
                        .field(&quot;analyzer&quot;, &quot;standard&quot;)
                        .field(&quot;default_expr&quot;, &quot;'default'&quot;)
                    .endObject()

                    .startObject(&quot;birthday&quot;)
                        .field(&quot;type&quot;, &quot;date&quot;)
                        .field(&quot;default_expr&quot;, &quot;current_timestamp(3)&quot;)
                    .endObject()
                .endObject()
<A NAME="57"></A>            .endObject();
        // @formatter:on

        IndexMetadata metadata = <FONT color="#0000ff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#57',3,'match306914-top.html#57',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);

        assertThat(md.columns().size(), is(6));
<A NAME="92"></A>        assertThat(md.references().size(), is(16));

        Reference birthday = md.references</B></FONT>().get(new ColumnIdent(&quot;birthday&quot;));
<A NAME="102"></A>        <FONT color="#41a317"><A
                HREF="javascript:ZweiFrames('match306914-1.html#92',3,'match306914-top.html#92',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(birthday.valueType(), is(DataTypes.TIMESTAMPZ));
        assertThat(birthday.defaultExpression(), isFunction(&quot;current_timestamp&quot;, List.of(DataTypes.INTEGER)));

        Reference integerIndexed = md.references</B></FONT>().get(<FONT color="#549748"><A
                HREF="javascript:ZweiFrames('match306914-1.html#102',3,'match306914-top.html#102',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ColumnIdent(&quot;integerIndexed&quot;));
        assertThat(integerIndexed.indexType(), is(Reference.IndexType.PLAIN));
<A NAME="91"></A>        assertThat(integerIndexed.defaultExpression(), isLiteral(1));


        Reference integerNotIndexed = <FONT color="#827d6b"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#91',3,'match306914-top.html#91',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get</B></FONT>(new ColumnIdent(&quot;integerNotIndexed&quot;));
        assertThat(integerNotIndexed.indexType(), is(Reference.IndexType.NONE));
        assertThat(integerNotIndexed.defaultExpression(), isLiteral(1));

        Reference stringNotIndexed = md.references().get</B></FONT>(new ColumnIdent(&quot;stringNotIndexed&quot;));
<A NAME="18"></A>        assertThat(stringNotIndexed.indexType(), is(Reference.IndexType.NONE));
        assertThat(stringNotIndexed.defaultExpression(), isLiteral(&quot;default&quot;));

        Reference stringNotAnalyzed = <FONT color="#800517"><A
                HREF="javascript:ZweiFrames('match306914-1.html#18',3,'match306914-top.html#18',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get(new ColumnIdent(&quot;stringNotAnalyzed&quot;));
        assertThat(stringNotAnalyzed.indexType(), is(Reference.IndexType.PLAIN));
        assertThat(stringNotAnalyzed.defaultExpression(), isLiteral(&quot;default&quot;));

        Reference stringAnalyzed = md.references().get(new ColumnIdent(&quot;stringAnalyzed&quot;));
        assertThat(stringAnalyzed.indexType(), is(Reference.IndexType.FULLTEXT));
<A NAME="101"></A>        assertThat(stringAnalyzed.defaultExpression(), isLiteral(&quot;default&quot;));

        assertThat(
            Lists2.map</B></FONT>(md.references().values(), r -&gt; <FONT color="#a057a5"><A
                HREF="javascript:ZweiFrames('match306914-1.html#101',3,'match306914-top.html#101',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>r.column().fqn()),
            containsInAnyOrder(
                &quot;_raw&quot;, &quot;_doc&quot;, &quot;_seq_no&quot;, &quot;_version&quot;, &quot;_id&quot;, &quot;_uid&quot;,
                &quot;_score&quot;, &quot;_fetchid&quot;, &quot;_primary_term&quot;, &quot;_docid&quot;,
                &quot;birthday&quot;, &quot;integerIndexed&quot;, &quot;integerNotIndexed&quot;,
                &quot;stringAnalyzed&quot;, &quot;stringNotAnalyzed&quot;, &quot;stringNotIndexed&quot;));
    }

<A NAME="2"></A>    @Test
    public void testExtractPartitionedByColumns() throws Exception {
        // @formatter:off
        XContentBuilder builder = <FONT color="#980517"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#2',3,'match306914-top.html#2',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0"
                    ALIGN="right"></A><B>XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(&quot;_meta&quot;)
                .field(&quot;primary_keys&quot;, &quot;id&quot;)
                .startArray(&quot;partitioned_by&quot;)
                    .startArray()
                    .value(&quot;datum&quot;).value(&quot;date&quot;)
                    .endArray()
                .endArray()
            .endObject()
            .startObject(&quot;properties&quot;)
                .startObject(&quot;id&quot;)
                    .field(&quot;type&quot;, &quot;integer&quot;)
                .endObject()
                .startObject(&quot;title&quot;)
                    .field(&quot;type&quot;, &quot;string&quot;)
                    .field(&quot;index&quot;, &quot;false&quot;)
                .endObject()
                .startObject(&quot;datum&quot;)
                    .field(&quot;type&quot;, &quot;date&quot;)
                .endObject()
                .startObject(&quot;content&quot;)
                    .field(&quot;type&quot;, &quot;string&quot;)
                    .field(&quot;index&quot;, &quot;true&quot;)
                    .field(&quot;analyzer&quot;, &quot;standard&quot;)
                .endObject()
                .startObject(&quot;person&quot;)
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;first_name&quot;)
                            .field(&quot;type&quot;, &quot;string&quot;)
                        .endObject()
                        .startObject(&quot;birthday&quot;)
                            .field(&quot;type&quot;, &quot;date&quot;)
                        .endObject()
                    .endObject()
                .endObject()
                .startObject(&quot;nested&quot;)
                    .field(&quot;type&quot;, &quot;nested&quot;)
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;inner_nested&quot;)
                            .field(&quot;type&quot;, &quot;date&quot;)
                        .endObject()
                    .endObject()
                .endObject()
            .endObject()
<A NAME="7"></A>            .endObject();
        // @formatter:on
        IndexMetadata metadata = getIndexMetadata</B></FONT>(&quot;test1&quot;, builder);
        DocIndexMetadata md = <FONT color="#38a4a5"><A
                HREF="javascript:ZweiFrames('match306914-1.html#7',3,'match306914-top.html#7',1)"><IMG SRC="forward.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="right"></A><B>newMeta(metadata, &quot;test1&quot;);

        assertEquals(6, md.columns().size());
        assertEquals(19, md.references().size());
        assertEquals(1, md.partitionedByColumns().size());
        assertEquals(DataTypes.TIMESTAMPZ, md.partitionedByColumns().get(0).valueType());
        assertThat(md.partitionedByColumns().get(0).column().fqn(), is(&quot;datum&quot;));

        assertThat(md.partitionedBy().size(), is(1));
        assertThat(md.partitionedBy().get(0), is(ColumnIdent.fromPath(&quot;datum&quot;)));
    }</B></FONT>
<A NAME="29"></A>
    @Test
    public void testExtractPartitionedByWithPartitionedByInColumns() throws Exception {
        <FONT color="#af7a82"><A
                HREF="javascript:ZweiFrames('match306914-1.html#29',3,'match306914-top.html#29',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(&quot;_meta&quot;)
            .startArray(&quot;partitioned_by&quot;)
            .startArray()
            .value(&quot;datum&quot;).value(&quot;date&quot;)
            .endArray()
            .endArray()
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;datum&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
<A NAME="75"></A>            .endObject()
            .endObject()
            .endObject();
        IndexMetadata metadata = <FONT color="#800517"><A
                HREF="javascript:ZweiFrames('match306914-1.html#75',3,'match306914-top.html#75',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);

        // partitioned by column is not added twice
        assertEquals(2, md.columns().size());
        assertEquals(12, md.references().size());
        assertEquals(1, md.partitionedByColumns</B></FONT>().size());
<A NAME="13"></A>    }

    @Test
    public void testExtractPartitionedByWithNestedPartitionedByInColumns() throws Exception <FONT color="#3b9c9c"><A
                HREF="javascript:ZweiFrames('match306914-1.html#13',3,'match306914-top.html#13',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        XContentBuilder builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(&quot;_meta&quot;)
            .startArray(&quot;partitioned_by&quot;)
            .startArray()
            .value(&quot;nested.datum&quot;).value(&quot;date&quot;)
            .endArray()
            .endArray()
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;nested&quot;)
            .field(&quot;type&quot;, &quot;nested&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;datum&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
            .endObject()
            .endObject()
            .endObject()
<A NAME="22"></A>            .endObject()
            .endObject();
        IndexMetadata metadata = getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = <FONT color="#4cc417"><A
                HREF="javascript:ZweiFrames('match306914-1.html#22',3,'match306914-top.html#22',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newMeta(metadata, &quot;test1&quot;);

        // partitioned by column is not added twice
        assertEquals(2, md.columns().size());
        assertEquals(13, md.references().size());
        assertEquals(1, md.partitionedByColumns().size());
    }

    private Map&lt;String, Object&gt; sortProperties(Map&lt;String, Object&gt; mappingSource) {
        return sortProperties(mappingSource, false);
    }

    /**
     * in the DocumentMapper that ES uses at some place the properties of the mapping are sorted.
     * this logic doesn't seem to be triggered if the IndexMetadata is created using the
     * IndexMetadata.Builder.
     * &lt;p/&gt;
     * in order to have the same behaviour as if a Node was started and a index with mapping was created
     * using the ES tools pre-sort the mapping here.
     */
    @SuppressWarni</B></FONT>ngs(&quot;unchecked&quot;)
    private Map&lt;String, Object&gt; sortProperties(Map&lt;String, Object&gt; mappingSource, boolean doSort) {
        Map&lt;String, Object&gt; map;
        if (doSort) {
            map = new TreeMap&lt;&gt;();
        } else {
            map = new HashMap&lt;&gt;();
        }

        boolean sortNext;
        Object value;
        for (Map.Entry&lt;String, Object&gt; entry : mappingSource.entrySet()) {
            value = entry.getValue();
<A NAME="70"></A>            sortNext = entry.getKey().equals(&quot;properties&quot;);

            if (value instanceof Map) {
                <FONT color="#3b9c9c"><A
                        HREF="javascript:ZweiFrames('match306914-1.html#70',3,'match306914-top.html#70',1)"><IMG
                        SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>map.put(entry.getKey(), sortProperties((Map) entry.getValue(), sortNext));
            } else {
                map.put(entry.getKey(), entry.getValue());
            }
<A NAME="82"></A>        }</B></FONT>

        return map;
    <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match306914-1.html#82',3,'match306914-top.html#82',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testExtractColumnDefinitionsFromEmptyIndex() throws Exception {
        XContentBuilder builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .endObject()
<A NAME="69"></A>            .endObject();
        IndexMetadata metadata = getIndexMetadata(&quot;test2&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test2&quot;);
        <FONT color="#571b7e"><A
                HREF="javascript:ZweiFrames('match306914-1.html#69',3,'match306914-top.html#69',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(md.columns(), hasSize(0));
    }
<A NAME="74"></A>
    @Test
    public void testDocSysColumnReferences() throws Exception {
        XContentBuilder builder = <FONT color="#3090c7"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#74',3,'match306914-top.html#74',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0"
                    ALIGN="right"></A><B>XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();

        DocIndexMetadata metadata = newMeta(getIndexMetadata(&quot;test&quot;, builder), &quot;test&quot;);
        Map&lt;ColumnIdent,Reference&gt; references = metadata.references();
        Reference id = references.get</B></FONT>(new ColumnIdent(&quot;_id&quot;));
        assertNotNull(id);

        Reference version = references.get(new ColumnIdent(&quot;_version&quot;));
        assertNotNull(version);

        Reference score = references.get(new ColumnIdent(&quot;_score&quot;));
        assertNotNull(score);

        Reference docId = references.get(new ColumnIdent(&quot;_docid&quot;));
        assertNotNull(docId);
    }

<A NAME="12"></A>    @Test
    public void testExtractPrimaryKey() throws Exception {

        <FONT color="#571b7e"><A
                HREF="javascript:ZweiFrames('match306914-1.html#12',3,'match306914-top.html#12',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .field(&quot;primary_keys&quot;, &quot;id&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .startObject(&quot;datum&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;true&quot;)
            .field(&quot;analyzer&quot;, &quot;standard&quot;)
            .endObject()
<A NAME="81"></A>            .endObject()
            .endObject()
            .endObject();
        IndexMetadata metadata = <FONT color="#79764d"><A
                HREF="javascript:ZweiFrames('match306914-1.html#81',3,'match306914-top.html#81',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test3&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test3&quot;);


<A NAME="40"></A>        assertThat(md.primaryKey().size(), is(1));
        assertThat(md.primaryKey(), contains(new</B></FONT> ColumnIdent(&quot;id&quot;)));

        builder = <FONT color="#347235"><A
                HREF="javascript:ZweiFrames('match306914-1.html#40',3,'match306914-top.html#40',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();

<A NAME="68"></A>        md = newMeta(getIndexMetadata(&quot;test4&quot;, builder), &quot;test4&quot;);
        assertThat(md.primaryKey().size(), is</B></FONT>(1)); // _id is always the fallback primary key

        builder = <FONT color="#b041ff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#68',3,'match306914-top.html#68',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .endObject()
            .endObject();
        md = newMeta(getIndexMetadata(&quot;test5&quot;, builder), &quot;test5&quot;);
        assertThat(md.primaryKey().size(), is(1));
    }</B></FONT>
<A NAME="39"></A>
    @Test
    public void testExtractMultiplePrimaryKeys() throws Exception {
        <FONT color="#152dc6"><A
                HREF="javascript:ZweiFrames('match306914-1.html#39',3,'match306914-top.html#39',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .array(&quot;primary_keys&quot;, &quot;id&quot;, &quot;title&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
            .endObject()
<A NAME="56"></A>            .endObject();
        IndexMetadata metadata = getIndexMetadata(&quot;test_multi_pk&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test_multi_pk&quot;);
        assertThat(<FONT color="#52d017"><A
                HREF="javascript:ZweiFrames('match306914-1.html#56',3,'match306914-top.html#56',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.primaryKey().size(), is(2));
        assertThat(md.primaryKey(), hasItems(ColumnIdent.fromPath(&quot;id&quot;), ColumnIdent.fromPath(&quot;title&quot;)));
    }
<A NAME="28"></A>
    @Test
    public void testExtractCheckConstraints() throws Exception {
        XContentBuilder builder = <FONT color="#717d7d"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#28',3,'match306914-top.html#28',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()</B></FONT>
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .startObject(&quot;check_constraints&quot;)
            .field(&quot;test3_check_1&quot;, &quot;id &gt;= 0&quot;)
            .field(&quot;test3_check_2&quot;, &quot;title != 'Programming Clojure'&quot;)
            .endObject()
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;).field(&quot;type&quot;, &quot;integer&quot;).endObject()
            .startObject(&quot;title&quot;).field(&quot;type&quot;, &quot;string&quot;).endObject()
<A NAME="38"></A>            .endObject()
            .endObject()
            .endObject();
        <FONT color="#348781"><A
                HREF="javascript:ZweiFrames('match306914-1.html#38',3,'match306914-top.html#38',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IndexMetadata metadata = getIndexMetadata(&quot;test3&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test3&quot;);
        assertThat(md.checkConstraints().size(), is(2));
        assertThat(md.checkConstraints()
                       .stream()
                       .map(CheckConstraint::expressionStr)
                       .collect(Collectors.toList()),
                   containsInAnyOrder(
                       equalTo(&quot;id &gt;= 0&quot;),
                       equalTo</B></FONT>(&quot;title != 'Programming Clojure'&quot;)
        ));
    }
<A NAME="27"></A>
    @Test
    public void testExtractNoPrimaryKey() throws Exception {
        <FONT color="#e77471"><A
                HREF="javascript:ZweiFrames('match306914-1.html#27',3,'match306914-top.html#27',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
<A NAME="10"></A>            .endObject()
            .endObject();
        IndexMetadata metadata = getIndexMetadata</B></FONT>(&quot;test_no_pk&quot;, builder);
        DocIndexMetadata md = <FONT color="#ad5910"><A
                HREF="javascript:ZweiFrames('match306914-1.html#10',3,'match306914-top.html#10',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newMeta(metadata, &quot;test_no_pk&quot;);
        assertThat(md.primaryKey().size(), is(1));
        assertThat(md.primaryKey(), hasItems(ColumnIdent.fromPath(&quot;_id&quot;)));

        builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .array(&quot;primary_keys&quot;) // results in empty list
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
<A NAME="80"></A>            .endObject()
            .endObject()
            .endObject();
        metadata = <FONT color="#f660ab"><A
                HREF="javascript:ZweiFrames('match306914-1.html#80',3,'match306914-top.html#80',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test_no_pk2&quot;, builder);
        md = newMeta(metadata, &quot;test_no_pk2&quot;);
        assertThat(md.primaryKey().size(), is(1));
        assertThat(md.primaryKey(), hasItems(ColumnIdent.fromPath</B></FONT>(&quot;_id&quot;)));
    }
<A NAME="26"></A>
    @Test
    public void testSchemaWithNotNullColumns() throws Exception {
        XContentBuilder builder = <FONT color="#68818b"><A
                HREF="javascript:ZweiFrames('match306914-1.html#26',3,'match306914-top.html#26',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .startObject(&quot;constraints&quot;)
            .array(&quot;not_null&quot;, &quot;id&quot;, &quot;title&quot;)
            .endObject()
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();
<A NAME="55"></A>        IndexMetadata metadata = getIndexMetadata(&quot;test_notnull_columns&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test_notnull_columns&quot;);

        <FONT color="#4863a0"><A
                HREF="javascript:ZweiFrames('match306914-1.html#55',3,'match306914-top.html#55',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(
            md.columns().stream().map(Reference::isNullable).collect(Collectors.toList()),
            contains(false, false)
        );
    }
<A NAME="11"></A>
    @Test
    public void testSchemaWithNotNullNestedColumns() throws Exception {
        XContentBuilder builder = <FONT color="#b041ff"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#11',3,'match306914-top.html#11',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0"
                    ALIGN="right"></A><B>XContentFactory.jsonBuilder()</B></FONT>
        .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
                .startObject(&quot;_meta&quot;)
                    .startObject(&quot;constraints&quot;)
                        .array(&quot;not_null&quot;, &quot;nested.level1&quot;, &quot;nested.level1.level2&quot;)
                    .endObject()
                .endObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;nested&quot;)
                        .field(&quot;type&quot;, &quot;object&quot;)
                            .startObject(&quot;properties&quot;)
                                .startObject(&quot;level1&quot;)
                                    .field(&quot;type&quot;, &quot;object&quot;)
                                    .startObject(&quot;properties&quot;)
                                        .startObject(&quot;level2&quot;)
                                            .field(&quot;type&quot;, &quot;string&quot;)
                                        .endObject()
                                    .endObject()
                                .endObject()
                             .endObject()
                    .endObject()
                .endObject()
            .endObject()
        .endObject();
        IndexMetadata metadata = getIndexMetadata</B></FONT>(&quot;test_notnull_columns&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test_notnull_columns&quot;);
<A NAME="31"></A>
        ColumnIdent level1 = new ColumnIdent(&quot;nested&quot;, &quot;level1&quot;);
        ColumnIdent level2 = new ColumnIdent(&quot;nested&quot;, Arrays.asList(&quot;level1&quot;, &quot;level2&quot;));
        assertThat(<FONT color="#3ea99f"><A
                HREF="javascript:ZweiFrames('match306914-1.html#31',3,'match306914-top.html#31',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.notNullColumns(), containsInAnyOrder(level1, level2));
        assertThat(md.references().get(level1).isNullable(), is(false));
        assertThat(md.references().get(level2).isNullable(), is(false));
    }
<A NAME="25"></A>
    @Test
    public void testSchemaWithNotNullGeneratedColumn() throws Exception {
        XContentBuilder builder = <FONT color="#5eac10"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#25',3,'match306914-top.html#25',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()</B></FONT>
            .startObject()
                .startObject(&quot;_meta&quot;)
                    .startObject(&quot;generated_columns&quot;)
                        .field(&quot;week&quot;, &quot;date_trunc('week', ts)&quot;)
                    .endObject()
                    .startObject(&quot;constraints&quot;)
                        .array(&quot;not_null&quot;, &quot;week&quot;)
                    .endObject()
                .endObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;ts&quot;).field(&quot;type&quot;, &quot;date&quot;).endObject()
                    .startObject(&quot;week&quot;).field(&quot;type&quot;, &quot;long&quot;).endObject()
<A NAME="79"></A>                .endObject()
            .endObject();

        <FONT color="#4cc417"><A
                HREF="javascript:ZweiFrames('match306914-1.html#79',3,'match306914-top.html#79',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IndexMetadata metadata = getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);
<A NAME="21"></A>
        assertThat(md.columns().size(), is(2));
        Reference week = md.references</B></FONT>().get(new ColumnIdent(&quot;week&quot;));
        <FONT color="#947010"><A
                HREF="javascript:ZweiFrames('match306914-1.html#21',3,'match306914-top.html#21',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(week, Matchers.notNullValue());
        assertThat(week.isNullable(), is(false));
        assertThat(week, instanceOf(GeneratedReference.class));
        assertThat(((GeneratedReference) week).formattedGeneratedExpression(), is(&quot;date_trunc('week', ts)&quot;));
        assertThat(((GeneratedReference) week).generatedExpression(), isFunction(&quot;date_trunc&quot;, isLiteral(&quot;week&quot;), isReference(&quot;ts&quot;)));
        assertThat(((GeneratedReference) week).referencedReferences(), contains(isReference(&quot;ts&quot;)));
    }</B></FONT>
<A NAME="17"></A>
    @Test
    public void extractRoutingColumn() throws Exception {
        <FONT color="#3090c7"><A
                HREF="javascript:ZweiFrames('match306914-1.html#17',3,'match306914-top.html#17',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .field(&quot;primary_keys&quot;, &quot;id&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;datum&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();

<A NAME="54"></A>        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test8&quot;, builder), &quot;test8&quot;);
        assertThat</B></FONT>(md.routingCol(), is(new ColumnIdent(&quot;id&quot;)));

        <FONT color="#4e8975"><A
                HREF="javascript:ZweiFrames('match306914-1.html#54',3,'match306914-top.html#54',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>builder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();

<A NAME="9"></A>        md = newMeta(getIndexMetadata</B></FONT>(&quot;test9&quot;, builder), &quot;test8&quot;);
        assertThat(md.routingCol(), is(new ColumnIdent(&quot;_id&quot;)));

        builder = <FONT color="#83a33a"><A
                HREF="javascript:ZweiFrames('match306914-1.html#9',3,'match306914-top.html#9',1)"><IMG SRC="forward.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="right"></A><B>XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;_meta&quot;)
            .array(&quot;primary_keys&quot;, &quot;id&quot;, &quot;num&quot;)
            .field(&quot;routing&quot;, &quot;num&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;num&quot;)
            .field(&quot;type&quot;, &quot;long&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();
<A NAME="46"></A>
        md = newMeta(getIndexMetadata(&quot;test10&quot;, builder), &quot;test10&quot;);
        assertThat(md.routingCol(), is</B></FONT>(new ColumnIdent(&quot;num&quot;)));
    <FONT color="#668b8b"><A HREF="javascript:ZweiFrames('match306914-1.html#46',3,'match306914-top.html#46',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void extractRoutingColumnFromEmptyIndex() throws Exception {
        XContentBuilder builder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .endObject()
<A NAME="45"></A>            .endObject();
        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test11&quot;, builder), &quot;test11&quot;);
        assertThat(md.routingCol</B></FONT>(), is(new ColumnIdent(&quot;_id&quot;)));
    <FONT color="#549748"><A HREF="javascript:ZweiFrames('match306914-1.html#45',3,'match306914-top.html#45',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testAutogeneratedPrimaryKey() throws Exception {
        XContentBuilder builder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
<A NAME="90"></A>            .endObject()
            .endObject();
        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test11&quot;, builder), &quot;test11&quot;);
<A NAME="89"></A>        assertThat(<FONT color="#736aff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#90',3,'match306914-top.html#90',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.primaryKey().size</B></FONT>(), is(1));
        assertThat(md.primaryKey().get(0), is(new ColumnIdent(&quot;_id&quot;)));
        assertThat(md.hasAutoGeneratedPrimaryKey(), is</B></FONT>(true));
    <FONT color="#5b8daf"><A HREF="javascript:ZweiFrames('match306914-1.html#89',3,'match306914-top.html#89',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
<A NAME="24"></A>
    @Test
    public void testNoAutogeneratedPrimaryKey() throws Exception {
        XContentBuilder builder = <FONT color="#79764d"><A
                HREF="javascript:ZweiFrames('match306914-1.html#24',3,'match306914-top.html#24',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
                .startObject(Constants.DEFAULT_MAPPING_TYPE)
                    .startObject(&quot;_meta&quot;)
                        .field(&quot;primary_keys&quot;, &quot;id&quot;)
                    .endObject()
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;id&quot;)
                            .field(&quot;type&quot;, &quot;integer&quot;)
                        .endObject()
                    .endObject()
                .endObject()
            .endObject();
        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test11&quot;, builder), &quot;test11&quot;);
        assertThat(md.primaryKey().size(), is(1));
        assertThat(md.primaryKey().get(0), is</B></FONT>(new ColumnIdent(&quot;id&quot;)));
        assertThat(md.hasAutoGeneratedPrimaryKey(), is(false));
    }
<A NAME="44"></A>
    @Test
    public void testAnalyzedColumnWithAnalyzer() throws Exception {
        XContentBuilder builder = <FONT color="#a057a5"><A
                HREF="javascript:ZweiFrames('match306914-1.html#44',3,'match306914-top.html#44',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
                .startObject(Constants.DEFAULT_MAPPING_TYPE)
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;content_de&quot;)
                            .field(&quot;type&quot;, &quot;text&quot;)
                            .field(&quot;index&quot;, &quot;true&quot;)
                            .field(&quot;analyzer&quot;, &quot;german&quot;)
                        .endObject()
                        .startObject(&quot;content_en&quot;)
                            .field(&quot;type&quot;, &quot;text&quot;)
                            .field(&quot;analyzer&quot;, &quot;english&quot;)
                        .endObject()
                    .endObject()
<A NAME="15"></A>                .endObject()
            .endObject();
        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test_analyzer&quot;, builder), &quot;test_analyzer&quot;);
        List&lt;Reference&gt; columns = new ArrayList&lt;&gt;(<FONT color="#f52887"><A
                HREF="javascript:ZweiFrames('match306914-1.html#15',3,'match306914-top.html#15',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.columns());
        assertThat(columns.size(), is(2));
        assertThat(columns.get(0).indexType(), is(Reference.IndexType.FULLTEXT));
        assertThat(columns.get(0).column().fqn(), is(&quot;content_de&quot;));
        assertThat(columns.get(1).indexType(), is(Reference.IndexType.FULLTEXT));
        assertThat(columns.get(1).column().fqn(), is(&quot;content_en&quot;));
    }</B></FONT>

    @Test
<A NAME="49"></A>    public void testGeoPointType() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table foo (p geo_point)&quot;);
        assertThat(md.columns().size(), is(1));
        Reference reference = <FONT color="#8e35ef"><A
                HREF="javascript:ZweiFrames('match306914-1.html#49',3,'match306914-top.html#49',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.columns().iterator().next();
        assertThat(reference.valueType(), equalTo(DataTypes.GEO_POINT));
    }

    @Test
    public void testCreateTableMappingGenerationAndParsingCompat() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table foo (&quot; +
                                                               &quot;id int primary key,&quot; +
                                                               &quot;tags array(string),&quot; +
                                                               &quot;o object as (&quot; +
                                                               &quot;   age int,&quot; +
                                                               &quot;   name string&quot; +
                                                               &quot;),&quot; +
<A NAME="100"></A>                                                               &quot;date timestamp with time zone primary key&quot; +
                                                               &quot;) partitioned by (date)&quot;);

<A NAME="78"></A>        assertThat(<FONT color="#c22817"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#100',3,'match306914-top.html#100',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.columns().size</B></FONT>(), is(4));
        assertThat(md.primaryKey(), Matchers.contains(new ColumnIdent(&quot;id&quot;), new ColumnIdent(&quot;date&quot;)));
        assertThat(md.references().get(new ColumnIdent(&quot;tags&quot;)).valueType</B></FONT>(), is(new ArrayType(DataTypes.STRING)));
    <FONT color="#947010"><A HREF="javascript:ZweiFrames('match306914-1.html#78',3,'match306914-top.html#78',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testCreateTableMappingGenerationAndParsingArrayInsideObject() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(
            &quot;create table t1 (&quot; +
            &quot;id int primary key,&quot; +
            &quot;details object as (names array(string))&quot; +
<A NAME="67"></A>            &quot;) with (number_of_replicas=0)&quot;);
        DataType type = md.references</B></FONT>().get(new ColumnIdent(&quot;details&quot;, &quot;names&quot;)).valueType();
        assertThat(type, Matchers.equalTo(new ArrayType(DataTypes.STRING)));
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match306914-1.html#67',3,'match306914-top.html#67',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testCreateTableMappingGenerationAndParsingCompatNoMeta() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table foo (id int, name string)&quot;);
        assertThat(md.columns().size(), is(2));
        assertThat(md.hasAutoGeneratedPrimaryKey</B></FONT>(), is(true));
    }

    private DocIndexMetadata getDocIndexMetadataFromStatement(String stmt) throws IOException {
        Statement statement = SqlParser.createStatement(stmt);

        DocTableInfoFactory docTableInfoFactory = new InternalDocTableInfoFactory(
            nodeCtx,
            new IndexNameExpressionResolver()
        );
        ViewInfoFactory viewInfoFactory = (ident, state) -&gt; null;
        DocSchemaInfo docSchemaInfo = new DocSchemaInfo(Schemas.DOC_SCHEMA_NAME, clusterService, nodeCtx, udfService, viewInfoFactory, docTableInfoFactory );
        Path homeDir = createTempDir();
        Schemas schemas = new Schemas(
                Map.of(&quot;doc&quot;, docSchemaInfo),
                clusterService,
                new DocSchemaInfoFactory(docTableInfoFactory, viewInfoFactory, nodeCtx, udfService));
<A NAME="48"></A>        FulltextAnalyzerResolver fulltextAnalyzerResolver = new FulltextAnalyzerResolver(
            clusterService,
            new AnalysisRegistry(
                <FONT color="#c57726"><A
                        HREF="javascript:ZweiFrames('match306914-1.html#48',3,'match306914-top.html#48',1)"><IMG
                        SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new Environment(Settings.builder()
                    .put(Environment.PATH_HOME_SETTING.getKey(), homeDir.toString())
                    .build(),
                    homeDir.resolve(&quot;config&quot;)
                ),
                emptyMap(),
                emptyMap(),
                emptyMap(),
                emptyMap(),
                emptyMap(),
                emptyMap(),
                emptyMap(),
                emptyMap</B></FONT>(),
                emptyMap()
            ));

        CreateTableStatementAnalyzer analyzer = new CreateTableStatementAnalyzer(nodeCtx);

        Analysis analysis = new Analysis(new CoordinatorTxnCtx(SessionContext.systemSessionContext()), ParamTypeHints.EMPTY);
        CoordinatorTxnCtx txnCtx = new CoordinatorTxnCtx(SessionContext.systemSessionContext());
        AnalyzedCreateTable analyzedCreateTable = analyzer.analyze(
            (CreateTable&lt;Expression&gt;) statement,
            analysis.paramTypeHints(),
            analysis.transactionContext());
        BoundCreateTable analyzedStatement = CreateTablePlan.bind(
            analyzedCreateTable,
            txnCtx,
            nodeCtx,
            Row.EMPTY,
            SubQueryResults.EMPTY,
            new NumberOfShards(clusterService),
            schemas,
<A NAME="53"></A>            fulltextAnalyzerResolver
        );

        Settings.Builder settingsBuilder = <FONT color="#ad5a3d"><A
                HREF="javascript:ZweiFrames('match306914-1.html#53',3,'match306914-top.html#53',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Settings.builder()
            .put(&quot;index.number_of_shards&quot;, 1)
            .put(&quot;index.number_of_replicas&quot;, 0)
            .put(&quot;index.version.created&quot;, org.elasticsearch.Version.CURRENT)
            .put(analyzedStatement.tableParameter().settings());

        IndexMetadata indexMetadata = IndexMetadata.builder(analyzedStatement.tableIdent</B></FONT>().name())
            .settings(settingsBuilder)
<A NAME="88"></A>            .putMapping(new MappingMetadata(Constants.DEFAULT_MAPPING_TYPE, analyzedStatement.mapping()))
            .build();

        return <FONT color="#3ea99f"><A
                HREF="javascript:ZweiFrames('match306914-1.html#88',3,'match306914-top.html#88',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newMeta(indexMetadata, analyzedStatement.tableIdent().name());
    }

    @Test
    public void testCompoundIndexColumn() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement</B></FONT>(&quot;create table t (&quot; +
                                                               &quot;  id integer primary key,&quot; +
                                                               &quot;  name string,&quot; +
<A NAME="37"></A>                                                               &quot;  fun string index off,&quot; +
                                                               &quot;  INDEX fun_name_ft using fulltext(name, fun)&quot; +
                                                               &quot;)&quot;);
        assertThat(<FONT color="#810541"><A
                HREF="javascript:ZweiFrames('match306914-1.html#37',3,'match306914-top.html#37',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.indices().size(), is(1));
<A NAME="66"></A>        assertThat(md.columns().size(), is(3));
        assertThat(md.indices().get(ColumnIdent.fromPath(&quot;fun_name_ft&quot;)), instanceOf(IndexReference.class));
        IndexReference indexInfo = md.indices().get(ColumnIdent.fromPath(&quot;fun_name_ft&quot;));
        assertThat</B></FONT>(indexInfo.indexType(), <FONT color="#83a33a"><A
                HREF="javascript:ZweiFrames('match306914-1.html#66',3,'match306914-top.html#66',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(Reference.IndexType.FULLTEXT));
        assertThat(indexInfo.column().fqn(), is(&quot;fun_name_ft&quot;));
    }

    @Test
    public void testCompoundIndexColumnNested() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table t (&quot; +
                                                               &quot;  id integer primary key,&quot; +
                                                               &quot;  name string,&quot; +
                                                               &quot;  o object as (&quot; +
                                                               &quot;    fun string&quot; +
<A NAME="36"></A>                                                               &quot;  ),&quot; +
                                                               &quot;  INDEX fun_name_ft using fulltext(name, o['fun'])&quot; +
                                                               &quot;)&quot;);
        assertThat</B></FONT>(<FONT color="#ff00ff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#36',3,'match306914-top.html#36',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.indices().size(), is(1));
        assertThat(md.columns().size(), is(3));
        assertThat(md.indices().get(ColumnIdent.fromPath(&quot;fun_name_ft&quot;)), instanceOf(IndexReference.class));
        IndexReference indexInfo = md.indices().get(ColumnIdent.fromPath(&quot;fun_name_ft&quot;));
        assertThat</B></FONT>(indexInfo.indexType(), is(Reference.IndexType.FULLTEXT));
        assertThat(indexInfo.column().fqn(), is(&quot;fun_name_ft&quot;));
<A NAME="47"></A>    }

    @Test
    public void testExtractColumnPolicy() throws Exception <FONT color="#d16587"><A
                HREF="javascript:ZweiFrames('match306914-1.html#47',3,'match306914-top.html#47',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        XContentBuilder ignoredBuilder = XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .field(&quot;dynamic&quot;, false)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
<A NAME="20"></A>            .endObject()
            .endObject()
            .endObject();
        DocIndexMetadata mdIgnored = <FONT color="#4e9258"><A
                HREF="javascript:ZweiFrames('match306914-1.html#20',3,'match306914-top.html#20',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newMeta(getIndexMetadata(&quot;test_ignored&quot;, ignoredBuilder), &quot;test_ignored&quot;);
        assertThat(mdIgnored.columnPolicy(), is(ColumnPolicy.IGNORED));

        XContentBuilder strictBuilder = XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .field(&quot;dynamic&quot;, &quot;strict&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
<A NAME="30"></A>            .endObject()
            .endObject();
        DocIndexMetadata mdStrict = newMeta(getIndexMetadata(&quot;test_strict&quot;, strictBuilder), &quot;test_strict&quot;);
        assertThat(mdStrict.columnPolicy(), <FONT color="#ae694a"><A
                HREF="javascript:ZweiFrames('match306914-1.html#30',3,'match306914-top.html#30',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(ColumnPolicy.STRICT));

        XContentBuilder dynamicBuilder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .field(&quot;dynamic&quot;, true)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
<A NAME="19"></A>            .endObject()
            .endObject();
        DocIndexMetadata mdDynamic = newMeta(getIndexMetadata(&quot;test_dynamic&quot;, dynamicBuilder), &quot;test_dynamic&quot;)</B></FONT>;
        <FONT color="#f62817"><A
                HREF="javascript:ZweiFrames('match306914-1.html#19',3,'match306914-top.html#19',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(mdDynamic.columnPolicy(), is(ColumnPolicy.DYNAMIC));

        XContentBuilder missingBuilder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
<A NAME="16"></A>            .endObject()
            .endObject();
        DocIndexMetadata mdMissing = newMeta</B></FONT>(getIndexMetadata(&quot;test_missing&quot;, missingBuilder), &quot;test_missing&quot;);
        assertThat(mdMissing.columnPolicy(), <FONT color="#2981b2"><A
                HREF="javascript:ZweiFrames('match306914-1.html#16',3,'match306914-top.html#16',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(ColumnPolicy.DYNAMIC));

        XContentBuilder wrongBuilder = XContentFactory.jsonBuilder()
            .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
            .field(&quot;dynamic&quot;, &quot;wrong&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;content&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject();
        expectedException.expectMessage(&quot;Invalid column policy: wrong&quot;);
        newMeta(getIndexMetadata(&quot;test_wrong&quot;, wrongBuilder), &quot;test_wrong&quot;);
    }</B></FONT>

    @Test
    public void testCreateArrayMapping() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table t (&quot; +
                                                               &quot;  id integer primary key,&quot; +
<A NAME="65"></A>                                                               &quot;  tags array(string),&quot; +
                                                               &quot;  scores array(short)&quot; +
                                                               &quot;)&quot;);
        <FONT color="#c58917"><A
                HREF="javascript:ZweiFrames('match306914-1.html#65',3,'match306914-top.html#65',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags&quot;)).valueType(),
<A NAME="64"></A>            is(new ArrayType(DataTypes.STRING)));
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;scores&quot;)).valueType(),
            is</B></FONT>(new ArrayType(DataTypes.SHORT)));
    <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match306914-1.html#64',3,'match306914-top.html#64',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testCreateObjectArrayMapping() throws Exception {
        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table t (&quot; +
                                                               &quot;  id integer primary key,&quot; +
                                                               &quot;  tags array(object(strict) as (&quot; +
                                                               &quot;    size double index off,&quot; +
                                                               &quot;    numbers array(integer),&quot; +
                                                               &quot;    quote string index using fulltext&quot; +
                                                               &quot;  ))&quot; +
                                                               &quot;)&quot;);
<A NAME="8"></A>        assertThat(
            md.references().get(ColumnIdent.fromPath(&quot;tags&quot;)).valueType(),
            is</B></FONT>(new ArrayType&lt;&gt;(
                <FONT color="#c58917"><A
                        HREF="javascript:ZweiFrames('match306914-1.html#8',3,'match306914-top.html#8',1)"><IMG
                        SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ObjectType.builder()
                    .setInnerType(&quot;size&quot;, DataTypes.DOUBLE)
                    .setInnerType(&quot;numbers&quot;, DataTypes.INTEGER_ARRAY)
                    .setInnerType(&quot;quote&quot;, DataTypes.STRING)
                    .build()))
        );
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags&quot;)).columnPolicy(),
            is(ColumnPolicy.STRICT));
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags.size&quot;)).valueType(),
            is(DataTypes.DOUBLE));
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags.size&quot;)).indexType(),
<A NAME="35"></A>            is(Reference.IndexType.NONE));
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags.numbers&quot;)).valueType(),
            is</B></FONT>(new ArrayType&lt;&gt;(DataTypes.INTEGER)));
        <FONT color="#41a317"><A
                HREF="javascript:ZweiFrames('match306914-1.html#35',3,'match306914-top.html#35',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags.quote&quot;)).valueType(),
            is(DataTypes.STRING));
        assertThat(md.references().get(ColumnIdent.fromPath(&quot;tags.quote&quot;)).indexType(),
            is(Reference.IndexType.FULLTEXT));
    }
<A NAME="4"></A>
    @Test
    public void testNoBackwardCompatibleArrayMapping() throws Exception {</B></FONT>
        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match306914-1.html#4',3,'match306914-top.html#4',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentBuilder builder = XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(&quot;_meta&quot;)
            .field(&quot;primary_keys&quot;, &quot;id&quot;)
            .startObject(&quot;columns&quot;)
            .startObject(&quot;array_col&quot;)
            .field(&quot;collection_type&quot;, &quot;array&quot;)
            .endObject()
            .startObject(&quot;nested&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;inner_nested&quot;)
            .field(&quot;collection_type&quot;, &quot;array&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject()
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .startObject(&quot;array_col&quot;)
            .field(&quot;type&quot;, &quot;ip&quot;)
            .endObject()
            .startObject(&quot;nested&quot;)
            .field(&quot;type&quot;, &quot;nested&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;inner_nested&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject()
            .endObject();
        IndexMetadata indexMetadata = getIndexMetadata(&quot;test1&quot;, builder);
<A NAME="34"></A>        DocIndexMetadata docIndexMetadata = newMeta(indexMetadata, &quot;test1&quot;);

        // ARRAY TYPES NOT DETECTED
        <FONT color="#827d6b"><A
                HREF="javascript:ZweiFrames('match306914-1.html#34',3,'match306914-top.html#34',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath(&quot;array_col&quot;)).valueType(),
            is(DataTypes.IP));
        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath(&quot;nested.inner_nested&quot;)).valueType(),
            is(DataTypes.TIMESTAMPZ));
    }
<A NAME="6"></A>
    @Test
    public void testNewArrayMapping() throws Exception {</B></FONT>
        XContentBuilder builder = <FONT color="#8c8774"><A
                HREF="javascript:ZweiFrames('match306914-1.html#6',3,'match306914-top.html#6',1)"><IMG SRC="forward.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
            .startObject(&quot;_meta&quot;)
            .field(&quot;primary_keys&quot;, &quot;id&quot;)
            .endObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;id&quot;)
            .field(&quot;type&quot;, &quot;integer&quot;)
            .endObject()
            .startObject(&quot;title&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;index&quot;, &quot;false&quot;)
            .endObject()
            .startObject(&quot;array_col&quot;)
            .field(&quot;type&quot;, &quot;array&quot;)
            .startObject(&quot;inner&quot;)
            .field(&quot;type&quot;, &quot;ip&quot;)
            .endObject()
            .endObject()
            .startObject(&quot;nested&quot;)
            .field(&quot;type&quot;, &quot;object&quot;)
            .startObject(&quot;properties&quot;)
            .startObject(&quot;inner_nested&quot;)
            .field(&quot;type&quot;, &quot;array&quot;)
            .startObject(&quot;inner&quot;)
            .field(&quot;type&quot;, &quot;date&quot;)
            .endObject()
            .endObject()
            .endObject()
            .endObject()
            .endObject()
<A NAME="63"></A>            .endObject();
        IndexMetadata indexMetadata = getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata docIndexMetadata = newMeta(indexMetadata, &quot;test1&quot;);
        <FONT color="#8c8774"><A
                HREF="javascript:ZweiFrames('match306914-1.html#63',3,'match306914-top.html#63',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath(&quot;array_col&quot;)).valueType(),
<A NAME="52"></A>            is(new ArrayType(DataTypes.IP)));
        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath(&quot;nested.inner_nested&quot;)).valueType(),
            is</B></FONT>(new ArrayType(DataTypes.TIMESTAMPZ)));
    <FONT color="#2b60de"><A HREF="javascript:ZweiFrames('match306914-1.html#52',3,'match306914-top.html#52',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testStringArrayWithFulltextIndex() throws Exception {
        DocIndexMetadata metadata = getDocIndexMetadataFromStatement(
            &quot;create table t (tags array(string) index using fulltext)&quot;);

        Reference reference = metadata.columns().iterator().next();
        assertThat(reference.valueType(), equalTo</B></FONT>(new ArrayType(DataTypes.STRING)));
    }

    @Test
    public void testCreateTableWithNestedPrimaryKey() throws Exception {
        DocIndexMetadata metadata = getDocIndexMetadataFromStatement(&quot;create table t (o object as (x int primary key))&quot;);
        assertThat(metadata.primaryKey(), contains(new ColumnIdent(&quot;o&quot;, &quot;x&quot;)));

        metadata = getDocIndexMetadataFromStatement(&quot;create table t (x object as (y object as (z int primary key)))&quot;);
        assertThat(metadata.primaryKey(), contains(new ColumnIdent(&quot;x&quot;, Arrays.asList(&quot;y&quot;, &quot;z&quot;))));
    }
<A NAME="43"></A>
    @Test
    public void testSchemaWithGeneratedColumn() throws Exception {
        XContentBuilder builder = <FONT color="#c22817"><A
                HREF="javascript:ZweiFrames('match306914-1.html#43',3,'match306914-top.html#43',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()
            .startObject()
                .startObject(&quot;_meta&quot;)
                    .startObject(&quot;generated_columns&quot;)
                        .field(&quot;week&quot;, &quot;date_trunc('week', ts)&quot;)
                    .endObject()
                .endObject()
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;ts&quot;).field(&quot;type&quot;, &quot;date&quot;).endObject()
                    .startObject(&quot;week&quot;).field(&quot;type&quot;, &quot;long&quot;).endObject()
<A NAME="87"></A>                .endObject()
            .endObject();

        IndexMetadata metadata = <FONT color="#ae694a"><A
                HREF="javascript:ZweiFrames('match306914-1.html#87',3,'match306914-top.html#87',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);
<A NAME="33"></A>
        assertThat(md.columns().size(), is(2));
        Reference week = md.references</B></FONT>().get(new ColumnIdent(&quot;week&quot;));
        <FONT color="#736aff"><A
                HREF="javascript:ZweiFrames('match306914-1.html#33',3,'match306914-top.html#33',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(week, Matchers.notNullValue());
        assertThat(week, instanceOf(GeneratedReference.class));
        assertThat(((GeneratedReference) week).formattedGeneratedExpression(), is(&quot;date_trunc('week', ts)&quot;));
        assertThat(((GeneratedReference) week).generatedExpression(), isFunction(&quot;date_trunc&quot;, isLiteral(&quot;week&quot;), isReference(&quot;ts&quot;)));
        assertThat(((GeneratedReference) week).referencedReferences(), contains(isReference(&quot;ts&quot;)));
<A NAME="62"></A>    }</B></FONT>

    @Test
    public void testCopyToWithoutMetaIndices() throws Exception <FONT color="#151b8d"><A
                HREF="javascript:ZweiFrames('match306914-1.html#62',3,'match306914-top.html#62',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        // regression test... this mapping used to cause an NPE
        XContentBuilder builder = XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
            .startObject(&quot;properties&quot;)
            .startObject(&quot;description&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .array(&quot;copy_to&quot;, &quot;description_ft&quot;)
            .endObject()
            .startObject(&quot;description_ft&quot;)
            .field(&quot;type&quot;, &quot;string&quot;)
            .field(&quot;analyzer&quot;, &quot;english&quot;)
            .endObject()
<A NAME="61"></A>            .endObject()
            .endObject();

        IndexMetadata metadata = <FONT color="#6cc417"><A
                HREF="javascript:ZweiFrames('match306914-1.html#61',3,'match306914-top.html#61',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>getIndexMetadata(&quot;test1&quot;, builder);
        DocIndexMetadata md = newMeta(metadata, &quot;test1&quot;);
<A NAME="60"></A>
        assertThat(md.indices().size(), is(1));
        assertThat(md.indices().keySet().iterator().next(), is</B></FONT>(new ColumnIdent(&quot;description_ft&quot;)));
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match306914-1.html#60',3,'match306914-top.html#60',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testArrayAsGeneratedColumn() throws Exception {
<A NAME="59"></A>        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table t1 (x as ([10, 20]))&quot;);
        GeneratedReference generatedReference = md.generatedColumnReferences().get(0);
        assertThat(generatedReference.valueType(), is</B></FONT>(new ArrayType&lt;&gt;(DataTypes.INTEGER)));
    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match306914-1.html#59',3,'match306914-top.html#59',1)"><IMG
            SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testColumnWithDefaultExpression() throws Exception {
<A NAME="73"></A>        DocIndexMetadata md = getDocIndexMetadataFromStatement(&quot;create table t1 (&quot; +
                                                               &quot; ts timestamp with time zone default current_timestamp)&quot;);
        Reference reference = md.references().get(new ColumnIdent(&quot;ts&quot;));
        assertThat(reference.valueType</B></FONT>(), <FONT color="#2981b2"><A
                HREF="javascript:ZweiFrames('match306914-1.html#73',3,'match306914-top.html#73',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(DataTypes.TIMESTAMPZ));
        assertThat(reference.defaultExpression(), isFunction(&quot;current_timestamp&quot;));
    }
<A NAME="32"></A>
    @Test
    public void testTimestampColumnReferences() throws Exception {
        XContentBuilder builder = <FONT color="#5b8daf"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#32',3,'match306914-top.html#32',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0"
                    ALIGN="right"></A><B>XContentFactory.jsonBuilder()</B></FONT>
            .startObject()
                .startObject(Constants.DEFAULT_MAPPING_TYPE)
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;tz&quot;)
                            .field(&quot;type&quot;, &quot;date&quot;)
                        .endObject()
                        .startObject(&quot;t&quot;)
                            .field(&quot;type&quot;, &quot;date&quot;)
                            .field(&quot;ignore_timezone&quot;, true)
                        .endObject()
                    .endObject()
                .endObject()
            .endObject();
<A NAME="77"></A>        DocIndexMetadata md = newMeta(getIndexMetadata(&quot;test&quot;, builder), &quot;test&quot;);

        assertThat(md.columns</B></FONT>().size(), is(2));
        assertThat(<FONT color="#4e9258"><A
                HREF="javascript:ZweiFrames('match306914-1.html#77',3,'match306914-top.html#77',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>md.references().get(new ColumnIdent(&quot;tz&quot;)).valueType(), is(DataTypes.TIMESTAMPZ));
        assertThat(md.references().get(new ColumnIdent(&quot;t&quot;)).valueType(), is</B></FONT>(DataTypes.TIMESTAMP));
    }
<A NAME="51"></A>
    @Test
    public void testColumnStoreBooleanIsParsedCorrectly() throws Exception {
        <FONT color="#b38481"><A
                HREF="javascript:ZweiFrames('match306914-1.html#51',3,'match306914-top.html#51',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>DocIndexMetadata md = getDocIndexMetadataFromStatement(
            &quot;create table t1 (x string STORAGE WITH (columnstore = false))&quot;);
        assertThat(md.columns().iterator().next().hasDocValues(), is(false));
    }
<A NAME="14"></A>
    @Test
    public void test_resolve_inner_object_types() throws Exception {
        XContentBuilder builder = <FONT color="#842dce"><A
                    HREF="javascript:ZweiFrames('match306914-1.html#14',3,'match306914-top.html#14',1)"><IMG
                    SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder</B></FONT>()</B></FONT>
        .startObject()
            .startObject(Constants.DEFAULT_MAPPING_TYPE)
                .startObject(&quot;properties&quot;)
                    .startObject(&quot;object&quot;)
                        .field(&quot;type&quot;, &quot;object&quot;)
                            .startObject(&quot;properties&quot;)
                                .startObject(&quot;nestedObject&quot;)
                                    .field(&quot;type&quot;, &quot;object&quot;)
                                    .startObject(&quot;properties&quot;)
                                        .startObject(&quot;nestedNestedString&quot;)
                                            .field(&quot;type&quot;, &quot;string&quot;)
                                        .endObject()
                                    .endObject()
                                .endObject()
                                .startObject(&quot;nestedString&quot;)
                                    .field(&quot;type&quot;, &quot;string&quot;)
                                .endObject()
                             .endObject()
                    .endObject()
<A NAME="99"></A>                .endObject()
            .endObject()
        .endObject();
        <FONT color="#c57717"><A
                HREF="javascript:ZweiFrames('match306914-1.html#99',3,'match306914-top.html#99',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IndexMetadata metadata = getIndexMetadata(&quot;test&quot;, builder);
<A NAME="42"></A>        DocIndexMetadata md = newMeta(metadata, &quot;test&quot;);

        ObjectType objectType = (ObjectType) md.references().get(new</B></FONT> ColumnIdent(&quot;object&quot;)).valueType();
        assertThat(objectType.resolveInnerType(<FONT color="#c57717"><A
                HREF="javascript:ZweiFrames('match306914-1.html#42',3,'match306914-top.html#42',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>List.of(&quot;nestedString&quot;)), is(DataTypes.STRING));
        assertThat(objectType.resolveInnerType(List.of(&quot;nestedObject&quot;)).id(), is(ObjectType.ID));
        assertThat(objectType.resolveInnerType(List.of(&quot;nestedObject&quot;, &quot;nestedNestedString&quot;)), is(DataTypes.STRING));
    }
<A NAME="86"></A>
    @Test
    public void test_nested_geo_shape_column_is_not_added_as_top_level_column() throws Exception {</B></FONT>
        <FONT color="#af7a82"><A
                HREF="javascript:ZweiFrames('match306914-1.html#86',3,'match306914-top.html#86',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>DocIndexMetadata md = getDocIndexMetadataFromStatement(
            &quot;create table tbl (x int, y object as (z geo_shape))&quot;);
        assertThat(md.columns(), contains(isReference(&quot;x&quot;), isReference(&quot;y&quot;)));
        assertThat(md.references(), hasKey</B></FONT>(new ColumnIdent(&quot;y&quot;, &quot;z&quot;)));
    }
<A NAME="50"></A>
    @Test
    public void test_resolve_string_type_with_length_from_mappings_with_text_and_keyword_types() throws Exception {
        XContentBuilder builder = <FONT color="#ff0000"><A
                HREF="javascript:ZweiFrames('match306914-1.html#50',3,'match306914-top.html#50',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>XContentFactory.jsonBuilder()
            .startObject()
                .startObject(Constants.DEFAULT_MAPPING_TYPE)
                    .startObject(&quot;properties&quot;)
                        .startObject(&quot;col&quot;)
                            .field(&quot;type&quot;, &quot;keyword&quot;)
                            .field(&quot;length_limit&quot;, 10)
                            .field(&quot;index&quot;, &quot;false&quot;)
                        .endObject()
                    .endObject()
                .endObject()
<A NAME="85"></A>            .endObject();
        var docIndexMetadata = newMeta(getIndexMetadata(&quot;test&quot;, builder), &quot;test&quot;);

        var column = docIndexMetadata.references</B></FONT>().get(<FONT color="#717d7d"><A
                HREF="javascript:ZweiFrames('match306914-1.html#85',3,'match306914-top.html#85',1)"><IMG
                SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ColumnIdent(&quot;col&quot;));
        assertThat(column, is(not(nullValue())));
        assertThat(column.valueType(), is(StringType.of(10)));
    }</B></FONT>
}
</PRE>
    </div>
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>InternalEngineTests.java</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.index.engine;

import static java.util.Collections.shuffle;
import static org.elasticsearch.index.engine.Engine.Operation.Origin.LOCAL_RESET;
import static org.elasticsearch.index.engine.Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY;
import static org.elasticsearch.index.engine.Engine.Operation.Origin.PEER_RECOVERY;
import static org.elasticsearch.index.engine.Engine.Operation.Origin.PRIMARY;
import static org.elasticsearch.index.engine.Engine.Operation.Origin.REPLICA;
import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;
import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_PRIMARY_TERM;
import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_SEQ_NO;
import static org.elasticsearch.index.translog.TranslogDeletionPolicies.createTranslogDeletionPolicy;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.Matchers.contains;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.isIn;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.Matchers.sameInstance;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import java.io.Closeable;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.Supplier;
import java.util.function.ToLongBiFunction;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

import com.carrotsearch.randomizedtesting.generators.RandomNumbers;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.appender.AbstractAppender;
import org.apache.logging.log4j.core.filter.RegexFilter;
import org.apache.lucene.codecs.lucene87.Lucene87StoredFieldsFormat;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.LongPoint;
import org.apache.lucene.document.NumericDocValuesField;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexCommit;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.LiveIndexWriterConfig;
import org.apache.lucene.index.LogByteSizeMergePolicy;
import org.apache.lucene.index.LogDocMergePolicy;
import org.apache.lucene.index.MergePolicy;
import org.apache.lucene.index.NoMergePolicy;
import org.apache.lucene.index.NumericDocValues;
import org.apache.lucene.index.PointValues;
import org.apache.lucene.index.SegmentInfos;
import org.apache.lucene.index.SoftDeletesRetentionMergePolicy;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.index.TieredMergePolicy;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.MatchAllDocsQuery;
import org.apache.lucene.search.ReferenceManager;
import org.apache.lucene.search.TermQuery;
<A NAME="0"></A>import org.apache.lucene.search.TopDocs;
import org.apache.lucene.search.TotalHitCountCollector;
import org.apache.lucene.store.AlreadyClosedException;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A
        HREF="javascript:ZweiFrames('match306914-0.html#0',2,'match306914-top.html#0',1)"><IMG SRC="back.gif"
                                                                                               ALT="other" BORDER="0"
                                                                                               ALIGN="left"></A></div><B>import org.apache.lucene.store.Directory;
import org.apache.lucene.store.Lock;
import org.apache.lucene.store.MockDirectoryWrapper;
import org.apache.lucene.util.Bits;
import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.FixedBitSet;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.Version;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.support.TransportActions;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.cluster.routing.ShardRoutingState;
import org.elasticsearch.cluster.routing.TestShardRouting;
import org.elasticsearch.common.CheckedBiConsumer;
import org.elasticsearch.common.CheckedRunnable;
import org.elasticsearch.common.Randomness;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.TriFunction;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.logging.Loggers;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.lucene.index.ElasticsearchDirectoryReader;
import org.elasticsearch.common.lucene.index.SequentialStoredFieldsLeafReader;
import org.elasticsearch.common.lucene.uid.Versions;
import org.elasticsearch.common.lucene.uid.VersionsAndSeqNoResolver;
import org.elasticsearch.common.lucene.uid.VersionsAndSeqNoResolver.DocIdAndSeqNo;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.unit.ByteSizeValue;
import org.elasticsearch.common.util.BigArrays;
import org.elasticsearch.common.util.concurrent.AbstractRunnable;
import org.elasticsearch.common.util.concurrent.ConcurrentCollections;
import org.elasticsearch.index.IndexSettings;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.codec.CodecService;
import org.elasticsearch.index.engine.Engine.Searcher;
import org.elasticsearch.index.fieldvisitor.FieldsVisitor;
import org.elasticsearch.index.mapper.IdFieldMapper;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.index.mapper.ParseContext;
import org.elasticsearch.index.mapper.ParseContext.Document;
import org.elasticsearch.index.mapper.ParsedDocument;
import org.elasticsearch.index.mapper.SeqNoFieldMapper;
import org.elasticsearch.index.mapper.SourceFieldMapper;
import org.elasticsearch.index.mapper.Uid;
import org.elasticsearch.index.mapper.VersionFieldMapper;
import org.elasticsearch.index.seqno.LocalCheckpointTracker;
import org.elasticsearch.index.seqno.ReplicationTracker;
import org.elasticsearch.index.seqno.RetentionLease;
import org.elasticsearch.index.seqno.RetentionLeases;
import org.elasticsearch.index.seqno.SeqNoStats;
import org.elasticsearch.index.seqno.SequenceNumbers;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.index.shard.ShardUtils;
import org.elasticsearch.index.store.Store;
import org.elasticsearch.index.translog.SnapshotMatchers;
import org.elasticsearch.index.translog.TestTranslog;
import org.elasticsearch.index.translog.Translog;
import org.elasticsearch.index.translog.TranslogConfig;
import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
import org.elasticsearch.test.IndexSettingsModule;
import org.elasticsearch.test.VersionUtils;
import org.elasticsearch.threadpool.ThreadPool;
import org.hamcrest.Matcher;
import org.hamcrest.MatcherAssert;
import org.hamcrest.Matchers;
import org.junit.Test;

import io.crate.common.collections.Tuple;
import io.crate.common.io.IOUtils;
import io.crate.common.unit.TimeValue;

public class InternalEngineTests extends EngineTestCase {

    static final long UNSET_AUTO_GENERATED_TIMESTAMP = -1L</B></FONT>;

    @Test
    public void testVersionMapAfterAutoIDDocument() throws IOException {
        engine.refresh(&quot;warm_up&quot;);
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(&quot;test&quot;),
                                                new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        Engine.Index operation = randomBoolean() ?
            appendOnlyPrimary(doc, false, 1)
            : appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
        engine.index(operation);
        assertFalse(engine.isSafeAccessRequired());
        doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(&quot;updated&quot;),
                                 new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        Engine.Index update = indexForDoc(doc);
        engine.index(update);
        assertTrue(engine.isSafeAccessRequired());
        assertThat(engine.getVersionMap().values(), hasSize(1));
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(0, searcher.getIndexReader().numDocs());
        }

        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
            assertEquals(1, searcher.getIndexReader().numDocs());
            TopDocs search = searcher.search(new MatchAllDocsQuery(), 1);
            org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[0].doc);
            assertEquals(&quot;test&quot;, luceneDoc.get(&quot;value&quot;));
        }

        // now lets make this document visible
        engine.refresh(&quot;test&quot;);
        if (randomBoolean()) { // random empty refresh
            engine.refresh(&quot;test&quot;);
        }
        assertTrue(&quot;safe access should be required we carried it over&quot;, engine.isSafeAccessRequired());
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(1, searcher.getIndexReader().numDocs());
            TopDocs search = searcher.search(new MatchAllDocsQuery(), 1);
            org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[0].doc);
            assertEquals(&quot;updated&quot;, luceneDoc.get(&quot;value&quot;));
        }

        doc = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(&quot;test&quot;),
                                 new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        operation = randomBoolean() ?
            appendOnlyPrimary(doc, false, 1)
            : appendOnlyReplica(doc, false, 1, generateNewSeqNo(engine));
        engine.index(operation);
        assertTrue(&quot;safe access should be required&quot;, engine.isSafeAccessRequired());
        assertThat(engine.getVersionMap().values(), hasSize(1)); // now we add this to the map
        engine.refresh(&quot;test&quot;);
        if (randomBoolean()) { // randomly refresh here again
            engine.refresh(&quot;test&quot;);
        }
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(2, searcher.getIndexReader().numDocs());
        }
<A NAME="83"></A>        if (operation.origin() == PRIMARY) {
            assertFalse(&quot;safe access should NOT be required last indexing round was only append only&quot;, engine.isSafeAccessRequired());
        }
        <FONT color="#68818b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#83',2,'match306914-top.html#83',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.delete(new Engine.Delete(
            operation.id(),
            operation.uid(),
            UNASSIGNED_SEQ_NO,
            primaryTerm.get(),
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY,
            System.nanoTime(),
            UNASSIGNED_SEQ_NO,
            0
        ));
        assertTrue(&quot;safe access should be required&quot;, engine.isSafeAccessRequired());
        engine.refresh(&quot;test&quot;);
        assertTrue(&quot;safe access should be required&quot;, engine.isSafeAccessRequired</B></FONT>());
<A NAME="82"></A>        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(1, searcher.getIndexReader().numDocs());
        }
    <FONT color="#5eac10"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#82',2,'match306914-top.html#82',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testSegmentsWithoutSoftDeletes() throws Exception {
        Settings settings = Settings.builder()
            .put(defaultSettings.getSettings</B></FONT>())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false).build();
        IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
            List&lt;Segment&gt; segments = engine.segments(false);
            assertThat(segments.isEmpty(), equalTo(true));

            // create two docs and refresh
            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
            Engine.Index first = indexForDoc(doc);
            Engine.IndexResult firstResult = engine.index(first);
            ParsedDocument doc2 = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(), B_2, null);
            Engine.Index second = indexForDoc(doc2);
            Engine.IndexResult secondResult = engine.index(second);
<A NAME="6"></A>            assertThat(secondResult.getTranslogLocation(), greaterThan(firstResult.getTranslogLocation()));
            engine.refresh(&quot;test&quot;);

            segments = <FONT color="#8c8774"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#6',2,'match306914-top.html#6',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>engine.segments(false);
            assertThat(segments.size(), equalTo(1));
            assertThat(segments.get(0).isCommitted(), equalTo(false));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(2));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(0).isCompound(), equalTo(true));
            assertThat(segments.get(0).ramTree, nullValue());
            assertThat(segments.get(0).getAttributes().keySet(), Matchers.contains</B></FONT>(Lucene87StoredFieldsFormat.MODE_KEY));
<A NAME="11"></A>
            engine.flush();

            segments = <FONT color="#b041ff"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#11',2,'match306914-top.html#11',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.segments(false);
            assertThat(segments.size(), equalTo(1));
            assertThat(segments.get(0).isCommitted(), equalTo(true));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(2));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(0).isCompound(), equalTo(true));

            ParsedDocument doc3 = testParsedDocument</B></FONT>(&quot;3&quot;, null, testDocumentWithTextField(), B_3, null);
<A NAME="3"></A>            engine.index(indexForDoc(doc3));
            engine.refresh(&quot;test&quot;);

            segments = <FONT color="#53858b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#3',2,'match306914-top.html#3',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>engine.segments(false);
            assertThat(segments.size(), equalTo(2));
            assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
            assertThat(segments.get(0).isCommitted(), equalTo(true));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(2));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(0).isCompound(), equalTo(true));


<A NAME="90"></A>            assertThat(segments.get(1).isCommitted(), equalTo(false));
            assertThat(segments.get(1).isSearch(), equalTo(true));
            assertThat(segments.get(1).getNumDocs(), equalTo</B></FONT>(1));
            assertThat(segments.get(1).getDeletedDocs(), <FONT color="#736aff"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#90',2,'match306914-top.html#90',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>equalTo(0));
            assertThat(segments.get(1).isCompound(), equalTo(true));


            engine.delete(new Engine.Delete(
                &quot;1&quot;,
                newUid(doc),
                UNASSIGNED_SEQ_NO,
                primaryTerm.get(),
                Versions.MATCH_ANY,
                VersionType.INTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime</B></FONT>(),
                UNASSIGNED_SEQ_NO,
                0
            ));
            engine.refresh(&quot;test&quot;);
<A NAME="2"></A>
            segments = engine.segments(false);
            assertThat(segments.size(), equalTo(2));
            assertThat(segments.get(0).getGeneration() &lt; <FONT color="#980517"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#2',2,'match306914-top.html#2',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>segments.get(1).getGeneration(), equalTo(true));
            assertThat(segments.get(0).isCommitted(), equalTo(true));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(1));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
            assertThat(segments.get(0).isCompound(), equalTo(true));

            assertThat(segments.get(1).isCommitted(), equalTo(false));
            assertThat(segments.get(1).isSearch(), equalTo(true));
            assertThat(segments.get(1).getNumDocs(), equalTo(1));
            assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(1).isCompound(), equalTo(true));

            engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
<A NAME="80"></A>                                     indexSettings.getSoftDeleteRetentionOperations());
            ParsedDocument doc4 = testParsedDocument</B></FONT>(&quot;4&quot;, null, testDocumentWithTextField(), B_3, null);
            engine.index(indexForDoc(doc4));
            <FONT color="#f660ab"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#80',2,'match306914-top.html#80',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.refresh(&quot;test&quot;);

<A NAME="1"></A>            segments = engine.segments(false);
            assertThat(segments.size(), equalTo(3));
            assertThat(segments.get(0).getGeneration() &lt; segments.get</B></FONT>(1).getGeneration(), equalTo(true));
            assertThat(segments.get(0).isCommitted(), <FONT color="#f63526"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#1',2,'match306914-top.html#1',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>equalTo(true));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(1));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
            assertThat(segments.get(0).isCompound(), equalTo(true));

            assertThat(segments.get(1).isCommitted(), equalTo(false));
            assertThat(segments.get(1).isSearch(), equalTo(true));
            assertThat(segments.get(1).getNumDocs(), equalTo(1));
            assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(1).isCompound(), equalTo(true));

            assertThat(segments.get(2).isCommitted(), equalTo(false));
            assertThat(segments.get(2).isSearch(), equalTo(true));
            assertThat(segments.get(2).getNumDocs(), equalTo(1));
            assertThat(segments.get(2).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(2).isCompound(), equalTo(true));

            // internal refresh - lets make sure we see those segments in the stats
            ParsedDocument doc5 = testParsedDocument</B></FONT>(&quot;5&quot;, null, testDocumentWithTextField(), B_3, null);
<A NAME="5"></A>            engine.index(indexForDoc(doc5));
            engine.refresh(&quot;test&quot;, Engine.SearcherScope.INTERNAL, true);

            segments = <FONT color="#151b8d"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#5',2,'match306914-top.html#5',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>engine.segments(false);
            assertThat(segments.size(), equalTo(4));
            assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
            assertThat(segments.get(0).isCommitted(), equalTo(true));
            assertThat(segments.get(0).isSearch(), equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(1));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
<A NAME="8"></A>            assertThat(segments.get(0).isCompound(), equalTo(true));

            assertThat(segments.get(1).isCommitted(), equalTo(false));
            assertThat</B></FONT>(<FONT color="#c58917"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#8',2,'match306914-top.html#8',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>segments.get(1).isSearch(), equalTo(true));
            assertThat(segments.get(1).getNumDocs(), equalTo(1));
            assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(1).isCompound(), equalTo(true));

<A NAME="44"></A>            assertThat(segments.get(2).isCommitted(), equalTo(false));
            assertThat(segments.get(2).isSearch(), equalTo(true));
            assertThat(segments.get(2).getNumDocs(), equalTo(1));
            assertThat(<FONT color="#a057a5"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#44',2,'match306914-top.html#44',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0"
                    ALIGN="left"></A></div><B>segments.get(2).getDeletedDocs</B></FONT>(), equalTo(0));
            assertThat(segments.get(2).isCompound(), equalTo(true));

<A NAME="10"></A>            assertThat(segments.get(3).isCommitted(), equalTo(false));
            assertThat(segments.get(3).isSearch(), equalTo(false));
            assertThat(segments.get(3).getNumDocs</B></FONT>(), equalTo(1));
            <FONT color="#ad5910"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#10',2,'match306914-top.html#10',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(segments.get(3).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(3).isCompound(), equalTo(true));

            // now refresh the external searcher and make sure it has the new segment
            engine.refresh(&quot;test&quot;);
            segments = engine.segments(false);
<A NAME="14"></A>            assertThat(segments.size(), equalTo(4));
            assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
            assertThat(segments.get(0).isCommitted(), equalTo(true));
            assertThat(segments.get</B></FONT>(0).isSearch(), <FONT color="#842dce"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#14',2,'match306914-top.html#14',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>equalTo(true));
            assertThat(segments.get(0).getNumDocs(), equalTo(1));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
            assertThat(segments.get(0).isCompound(), equalTo(true));
<A NAME="28"></A>
            assertThat(segments.get(1).isCommitted(), equalTo(false));
            assertThat(segments.get(1).isSearch(), equalTo(true));
            assertThat(<FONT color="#717d7d"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#28',2,'match306914-top.html#28',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0"
                    ALIGN="left"></A></div><B>segments.get(1).getNumDocs</B></FONT>(), equalTo(1));
            assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(1).isCompound(), equalTo(true));
<A NAME="7"></A>
            assertThat(segments.get(2).isCommitted(), equalTo(false));
            assertThat(segments.get(2).isSearch(), equalTo(true));
            assertThat</B></FONT>(segments.get(2).getNumDocs(), <FONT color="#38a4a5"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#7',2,'match306914-top.html#7',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>equalTo(1));
            assertThat(segments.get(2).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(2).isCompound(), equalTo(true));

            assertThat(segments.get(3).isCommitted(), equalTo(false));
            assertThat(segments.get(3).isSearch(), equalTo(true));
            assertThat(segments.get(3).getNumDocs(), equalTo(1));
            assertThat(segments.get(3).getDeletedDocs(), equalTo(0));
            assertThat(segments.get(3).isCompound(), equalTo(true));
        }</B></FONT>
    }

    @Test
    public void testVerboseSegments() throws Exception {
        try (Store store = createStore();
             Engine engine = createEngine(defaultSettings, store, createTempDir(), NoMergePolicy.INSTANCE)) {
            List&lt;Segment&gt; segments = engine.segments(true);
            assertThat(segments.isEmpty(), equalTo(true));

            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
<A NAME="98"></A>            engine.index(indexForDoc(doc));
            engine.refresh(&quot;test&quot;);

            segments = <FONT color="#f87a17"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#98',2,'match306914-top.html#98',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.segments(true);
            assertThat(segments.size(), equalTo(1));
            assertThat(segments.get(0).ramTree, notNullValue());

            ParsedDocument doc2 = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField</B></FONT>(), B_2, null);
            engine.index(indexForDoc(doc2));
            engine.refresh(&quot;test&quot;);
            ParsedDocument doc3 = testParsedDocument(&quot;3&quot;, null, testDocumentWithTextField(), B_3, null);
            engine.index(indexForDoc(doc3));
            engine.refresh(&quot;test&quot;);

            segments = engine.segments(true);
            assertThat(segments.size(), equalTo(3));
            assertThat(segments.get(0).ramTree, notNullValue());
            assertThat(segments.get(1).ramTree, notNullValue());
            assertThat(segments.get(2).ramTree, notNullValue());
        }
    }

    @Test
    public void testSegmentsWithMergeFlag() throws Exception {
        try (Store store = createStore();
             Engine engine = createEngine(defaultSettings, store, createTempDir(), new TieredMergePolicy())) {
            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), B_1, null);
            Engine.Index index = indexForDoc(doc);
            engine.index(index);
            engine.flush();
            assertThat(engine.segments(false).size(), equalTo(1));
            index = indexForDoc(testParsedDocument(&quot;2&quot;, null, testDocument(), B_1, null));
            engine.index(index);
            engine.flush();
            List&lt;Segment&gt; segments = engine.segments(false);
            assertThat(segments.size(), equalTo(2));
            for (Segment segment : segments) {
                assertThat(segment.getMergeId(), nullValue());
            }
            index = indexForDoc(testParsedDocument(&quot;3&quot;, null, testDocument(), B_1, null));
            engine.index(index);
            engine.flush();
            segments = engine.segments(false);
            assertThat(segments.size(), equalTo(3));
            for (Segment segment : segments) {
                assertThat(segment.getMergeId(), nullValue());
            }

            index = indexForDoc(doc);
            engine.index(index);
            engine.flush();
            final long gen1 = store.readLastCommittedSegmentsInfo().getGeneration();
            // now, optimize and wait for merges, see that we have no merge flag
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());

            for (Segment segment : engine.segments(false)) {
                assertThat(segment.getMergeId(), nullValue());
            }
            // we could have multiple underlying merges, so the generation may increase more than once
            assertTrue(store.readLastCommittedSegmentsInfo().getGeneration() &gt; gen1);

            final boolean flush = randomBoolean();
            final long gen2 = store.readLastCommittedSegmentsInfo().getGeneration();
            engine.forceMerge(flush, 1, false, false, false, UUIDs.randomBase64UUID());

            for (Segment segment : engine.segments(false)) {
                assertThat(segment.getMergeId(), nullValue());
            }

            if (flush) {
                // we should have had just 1 merge, so last generation should be exact
<A NAME="46"></A>                assertEquals(gen2, store.readLastCommittedSegmentsInfo().getLastGeneration());
            }
        }
    <FONT color="#668b8b"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#46',2,'match306914-top.html#46',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testSegmentsWithSoftDeletes() throws Exception {
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata</B></FONT>()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null,
                                                         null, globalCheckpoint::get))) {
            assertThat(engine.segments(false), empty());
            int numDocsFirstSegment = randomIntBetween(5, 50);
            Set&lt;String&gt; liveDocsFirstSegment = new HashSet&lt;&gt;();
            for (int i = 0; i &lt; numDocsFirstSegment; i++) {
                String id = Integer.toString(i);
                ParsedDocument doc = testParsedDocument(id, null, testDocument(), B_1, null);
<A NAME="30"></A>                engine.index(indexForDoc(doc));
                liveDocsFirstSegment.add(id);
            }
            <FONT color="#ae694a"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#30',2,'match306914-top.html#30',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.refresh(&quot;test&quot;);
            List&lt;Segment&gt; segments = engine.segments(randomBoolean());
            assertThat(segments, hasSize(1));
            assertThat(segments.get(0).getNumDocs(), equalTo(liveDocsFirstSegment.size()));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
            assertFalse(segments.get(0).committed);
            int deletes = 0</B></FONT>;
            int updates = 0;
            int appends = 0;
            int iterations = scaledRandomIntBetween(1, 50);
            for (int i = 0; i &lt; iterations &amp;&amp; liveDocsFirstSegment.isEmpty() == false; i++) {
                String idToUpdate = randomFrom(liveDocsFirstSegment);
                liveDocsFirstSegment.remove(idToUpdate);
                ParsedDocument doc = testParsedDocument(idToUpdate, null, testDocument(), B_1, null);
                if (randomBoolean()) {
                    engine.delete(new Engine.Delete(doc.id(), newUid(doc), primaryTerm.get()));
                    deletes++;
                } else {
                    engine.index(indexForDoc(doc));
                    updates++;
                }
                if (randomBoolean()) {
                    engine.index(indexForDoc(testParsedDocument(UUIDs.randomBase64UUID(), null, testDocument(), B_1, null)));
                    appends++;
                }
            }
            boolean committed = randomBoolean();
            if (committed) {
                engine.flush();
            }
<A NAME="15"></A>            engine.refresh(&quot;test&quot;);
            segments = engine.segments(randomBoolean());
            assertThat(segments, hasSize(2));
            assertThat(<FONT color="#f52887"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#15',2,'match306914-top.html#15',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>segments.get(0).getNumDocs(), equalTo(liveDocsFirstSegment.size()));
            assertThat(segments.get(0).getDeletedDocs(), equalTo(updates + deletes));
            assertThat(segments.get(0).committed, equalTo(committed));

            assertThat(segments.get(1).getNumDocs(), equalTo(updates + appends));
            assertThat(segments.get(1).getDeletedDocs(), equalTo(deletes)); // delete tombstones
            assertThat(segments.get(1).committed, equalTo(committed));
        }</B></FONT>
    }


    @Test
    public void testCommitStats() throws IOException {
        final AtomicLong maxSeqNo = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final AtomicLong localCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final AtomicLong globalCheckpoint = new AtomicLong(UNASSIGNED_SEQ_NO);
        try (
            Store store = createStore();
            InternalEngine engine = createEngine(store, createTempDir(), (maxSeq, localCP) -&gt; new LocalCheckpointTracker(
                                                     maxSeq,
                                                     localCP) {
                                                     @Override
                                                     public long getMaxSeqNo() {
                                                         return maxSeqNo.get();
                                                     }

                                                     @Override
                                                     public long getProcessedCheckpoint() {
<A NAME="13"></A>                                                         return localCheckpoint.get();
                                                     }
                    }
            )) <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#13',2,'match306914-top.html#13',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>{
            CommitStats stats1 = engine.commitStats();
            assertThat(stats1.getGeneration(), greaterThan(0L));
            assertThat(stats1.getId(), notNullValue());
            assertThat(stats1.getUserData(), hasKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
            assertThat(
                Long.parseLong(stats1.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
                equalTo(SequenceNumbers.NO_OPS_PERFORMED));

            assertThat(stats1.getUserData(), hasKey(SequenceNumbers.MAX_SEQ_NO));
            assertThat(
                Long.parseLong(stats1.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                equalTo(SequenceNumbers.NO_OPS_PERFORMED));

            maxSeqNo.set</B></FONT>(rarely() ? SequenceNumbers.NO_OPS_PERFORMED : randomIntBetween(0, 1024));
            localCheckpoint.set(
                rarely() || maxSeqNo.get() == SequenceNumbers.NO_OPS_PERFORMED ?
                    SequenceNumbers.NO_OPS_PERFORMED : randomIntBetween(0, 1024));
            globalCheckpoint.set(rarely() || localCheckpoint.get() == SequenceNumbers.NO_OPS_PERFORMED ?
                                     UNASSIGNED_SEQ_NO : randomIntBetween(0, (int) localCheckpoint.get()));
<A NAME="4"></A>
            final Engine.CommitId commitId = engine.flush(true, true);

            <FONT color="#6cc417"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#4',2,'match306914-top.html#4',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CommitStats stats2 = engine.commitStats();
            assertThat(stats2.getRawCommitId(), equalTo(commitId));
            assertThat(stats2.getGeneration(), greaterThan(stats1.getGeneration()));
            assertThat(stats2.getId(), notNullValue());
            assertThat(stats2.getId(), not(equalTo(stats1.getId())));
            assertThat(stats2.getUserData(), hasKey(Translog.TRANSLOG_UUID_KEY));
            assertThat(stats2.getUserData().get(Translog.TRANSLOG_UUID_KEY),
                       equalTo(stats1.getUserData().get(Translog.TRANSLOG_UUID_KEY)));
            assertThat(Long.parseLong(stats2.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)), equalTo(localCheckpoint.get()));
            assertThat(stats2.getUserData(), hasKey(SequenceNumbers.MAX_SEQ_NO));
            assertThat(Long.parseLong(stats2.getUserData</B></FONT>().get(SequenceNumbers.MAX_SEQ_NO)), equalTo(maxSeqNo.get()));
        }
    }

    @Test
    public void testFlushIsDisabledDuringTranslogRecovery() throws IOException {
        engine.ensureCanFlush(); // recovered already
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), SOURCE, null);
        engine.index(indexForDoc(doc));
        engine.close();

        engine = new InternalEngine(engine.config());
        expectThrows(IllegalStateException.class, engine::ensureCanFlush);
        expectThrows(IllegalStateException.class, () -&gt; engine.flush(true, true));
        if (randomBoolean()) {
            engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
        } else {
            engine.skipTranslogRecovery();
        }
<A NAME="88"></A>        engine.ensureCanFlush(); // ready

        doc = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(), SOURCE, null);
        <FONT color="#3ea99f"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#88',2,'match306914-top.html#88',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.index(indexForDoc(doc));
        engine.flush();
    }

    @Test
    public void testTranslogMultipleOperationsSameDocument() throws IOException {
        final int ops = randomIntBetween</B></FONT>(1, 32);
        Engine initialEngine;
        final List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;();
        try {
            initialEngine = engine;
            for (int i = 0; i &lt; ops; i++) {
                final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), SOURCE, null);
                if (randomBoolean()) {
                        final Engine.Index operation = new Engine.Index(
                            newUid(doc),
                            doc,
                            UNASSIGNED_SEQ_NO,
                            0,
                            i,
                            VersionType.EXTERNAL,
                            Engine.Operation.Origin.PRIMARY,
                            System.nanoTime(),
                            -1,
                            false,
                            UNASSIGNED_SEQ_NO,
                            0
                        );
                    operations.add(operation);
                    initialEngine.index(operation);
                } else {
                    final Engine.Delete operation = new Engine.Delete(
                        &quot;1&quot;,
                        newUid(doc),
                        UNASSIGNED_SEQ_NO,
                        0,
                        i,
                        VersionType.EXTERNAL,
                        Engine.Operation.Origin.PRIMARY,
                        System.nanoTime(),
                        UNASSIGNED_SEQ_NO,
                        0
                    );
                    operations.add(operation);
                    initialEngine.delete(operation);
                }
            }
        } finally {
            IOUtils.close(engine);
        }
        try (Engine recoveringEngine = new InternalEngine(engine.config())) {
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            recoveringEngine.refresh(&quot;test&quot;);
            try (Engine.Searcher searcher = recoveringEngine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                searcher.search(new MatchAllDocsQuery(), collector);
                assertThat(collector.getTotalHits(), equalTo(operations.get(operations.size() - 1) instanceof Engine.Delete ? 0 : 1));
            }
        }
    }

    @Test
    public void testTranslogRecoveryDoesNotReplayIntoTranslog() throws IOException {
        final int docs = randomIntBetween(1, 32);
        Engine initialEngine = null;
        try {
            initialEngine = engine;
            for (int i = 0; i &lt; docs; i++) {
                final String id = Integer.toString(i);
                final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
                initialEngine.index(indexForDoc(doc));
            }
        } finally {
            IOUtils.close(initialEngine);
        }

        Engine recoveringEngine = null;
        try {
            final AtomicBoolean committed = new AtomicBoolean();
            recoveringEngine = new InternalEngine(initialEngine.config()) {

                @Override
                protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
                    committed.set(true);
                    super.commitIndexWriter(writer, translog, syncId);
                }
            };
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            assertTrue(committed.get());
<A NAME="60"></A>        } finally {
            IOUtils.close(recoveringEngine);
        }
    <FONT color="#53858b"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#60',2,'match306914-top.html#60',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testTranslogRecoveryWithMultipleGenerations() throws IOException {
        final int docs = randomIntBetween(1, 4096);
        final List&lt;Long&gt; seqNos = LongStream.range(0, docs).boxed().collect(Collectors.toList());
        Randomness.shuffle</B></FONT>(seqNos);
        Engine initialEngine = null;
        Engine recoveringEngine = null;
        Store store = createStore();
        final AtomicInteger counter = new AtomicInteger();
        try {
            initialEngine = createEngine(
                store,
                createTempDir(),
                LocalCheckpointTracker::new,
                (engine, operation) -&gt; seqNos.get(counter.getAndIncrement()));
            for (int i = 0; i &lt; docs; i++) {
                final String id = Integer.toString(i);
                final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
                initialEngine.index(indexForDoc(doc));
                if (rarely()) {
                    getTranslog(initialEngine).rollGeneration();
                } else if (rarely()) {
                    initialEngine.flush();
                }
            }
            initialEngine.close();
            recoveringEngine = new InternalEngine(initialEngine.config());
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            recoveringEngine.refresh(&quot;test&quot;);
            try (Engine.Searcher searcher = recoveringEngine.acquireSearcher(&quot;test&quot;)) {
                TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), docs);
                assertEquals(docs, topDocs.totalHits.value);
            }
        } finally {
            IOUtils.close(initialEngine, recoveringEngine, store);
        }
    }

    @Test
    public void testRecoveryFromTranslogUpToSeqNo() throws IOException {
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (Store store = createStore()) {
            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(),
                                         null, null, globalCheckpoint::get);
            final long maxSeqNo;
            try (InternalEngine engine = createEngine(config)) {
                final int docs = randomIntBetween(1, 100);
                for (int i = 0; i &lt; docs; i++) {
                    final String id = Integer.toString(i);
                    final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(),
                                                                  SOURCE, null);
                    engine.index(indexForDoc(doc));
                    if (rarely()) {
                        engine.rollTranslogGeneration();
                    } else if (rarely()) {
                        engine.flush(randomBoolean(), true);
                    }
                }
                maxSeqNo = engine.getLocalCheckpointTracker().getMaxSeqNo();
                globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getProcessedLocalCheckpoint()));
                engine.syncTranslog();
            }
            try (InternalEngine engine = new InternalEngine(config)) {
                engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                assertThat(engine.getProcessedLocalCheckpoint(), equalTo(maxSeqNo));
<A NAME="86"></A>                assertThat(engine.getLocalCheckpointTracker().getMaxSeqNo(), equalTo(maxSeqNo));
            }
            try (InternalEngine engine = new InternalEngine(config)) {
                <FONT color="#af7a82"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#86',2,'match306914-top.html#86',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>long upToSeqNo = randomLongBetween(globalCheckpoint.get(), maxSeqNo);
                engine.recoverFromTranslog(translogHandler, upToSeqNo);
                assertThat(engine.getProcessedLocalCheckpoint(), equalTo(upToSeqNo));
<A NAME="89"></A>                assertThat(engine.getLocalCheckpointTracker</B></FONT>().getMaxSeqNo(), equalTo(upToSeqNo));
            }
        }
    <FONT color="#5b8daf"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#89',2,'match306914-top.html#89',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testConcurrentGetAndFlush() throws Exception {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
        engine.index(indexForDoc</B></FONT>(doc));

        final AtomicReference&lt;Engine.GetResult&gt; latestGetResult = new AtomicReference&lt;&gt;();
        final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
        latestGetResult.set(engine.get(newGet(doc), searcherFactory));
        final AtomicBoolean flushFinished = new AtomicBoolean(false);
        final CyclicBarrier barrier = new CyclicBarrier(2);
        Thread getThread = new Thread(() -&gt; {
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
            while (flushFinished.get() == false) {
                Engine.GetResult previousGetResult = latestGetResult.get();
                if (previousGetResult != null) {
                    previousGetResult.close();
                }
                latestGetResult.set(engine.get(newGet(doc), searcherFactory));
                if (latestGetResult.get().docIdAndVersion() == null) {
                    break;
<A NAME="35"></A>                }
            }
        });
        <FONT color="#41a317"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#35',2,'match306914-top.html#35',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>getThread.start();
        barrier.await();
        engine.flush();
        flushFinished.set(true);
        getThread.join();
        assertThat(latestGetResult.get().docIdAndVersion(), is(notNullValue()));
        latestGetResult.get().close();
    }

    @Test
    public void testSimpleOperations() throws Exception {</B></FONT>
        engine.refresh(&quot;warm_up&quot;);
        Engine.Searcher searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        searchResult.close();

        final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;

        // create a document
        Document document = testDocumentWithTextField();
        document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        engine.index(indexForDoc(doc));

        // its not there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        searchResult.close();

        // we can get it in realtime
        try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
            assertThat(getResult.docIdAndVersion(), is(notNullValue()));
        }


        // refresh and it should be there
        engine.refresh(&quot;test&quot;);

        // now its there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        searchResult.close();

        // now do an update
        document = testDocument();
        document.add(new TextField(&quot;value&quot;, &quot;test1&quot;, Field.Store.YES));
        document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_2), SourceFieldMapper.Defaults.FIELD_TYPE));
        doc = testParsedDocument(&quot;1&quot;, null, document, B_2, null);
<A NAME="100"></A>        engine.index(indexForDoc(doc));

        // its not updated yet...
        searchResult = <FONT color="#c22817"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#100',2,'match306914-top.html#100',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits</B></FONT>(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 0));
        searchResult.close();

        // but, we can still get it (in realtime)
        try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
            assertThat(getResult.docIdAndVersion(), is(notNullValue()));
        }

        // refresh and it should be updated
        engine.refresh(&quot;test&quot;);

        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 1));
        searchResult.close();

        // now delete
        engine.delete(new Engine.Delete(
            &quot;1&quot;,
            newUid(doc),
            UNASSIGNED_SEQ_NO,
            primaryTerm.get(),
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY,
            System.nanoTime(),
            UNASSIGNED_SEQ_NO,
            0
        ));

        // its not deleted yet
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 1));
        searchResult.close();

        // but, get should not see it (in realtime)
        try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
            assertThat(getResult.docIdAndVersion(), is(nullValue()));
        }

        // refresh and it should be deleted
        engine.refresh(&quot;test&quot;);

        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 0));
        searchResult.close();

        // add it back
        document = testDocumentWithTextField();
        document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
        doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        engine.index(new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            Versions.MATCH_DELETED, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));

        // its not there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 0));
        searchResult.close();

        // refresh and it should be there
        engine.refresh(&quot;test&quot;);

        // now its there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 0));
        searchResult.close();

        // now flush
        engine.flush();

        // and, verify get (in real time)
        try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
            assertThat(getResult.docIdAndVersion(), is(notNullValue()));
        }

        // make sure we can still work with the engine
        // now do an update
        document = testDocument();
        document.add(new TextField(&quot;value&quot;, &quot;test1&quot;, Field.Store.YES));
        doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        engine.index(indexForDoc(doc));

        // its not updated yet...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 0));
        searchResult.close();

        // refresh and it should be updated
        engine.refresh(&quot;test&quot;);

        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test1&quot;)), 1));
        searchResult.close();
    }

    public void testSearchResultRelease() throws Exception {
        engine.refresh(&quot;warm_up&quot;);
        Engine.Searcher searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        searchResult.close();

        // create a document
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
        engine.index(indexForDoc(doc));

        // its not there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 0));
        searchResult.close();

        // refresh and it should be there
        engine.refresh(&quot;test&quot;);

        // now its there...
        searchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        // don't release the search result yet...

        // delete, refresh and do a new search, it should not be there
        engine.delete(new Engine.Delete(
            &quot;1&quot;,
            newUid(doc),
            UNASSIGNED_SEQ_NO,
            primaryTerm.get(),
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY,
            System.nanoTime(),
<A NAME="81"></A>            UNASSIGNED_SEQ_NO,
            0
        ));
        <FONT color="#79764d"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#81',2,'match306914-top.html#81',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.refresh(&quot;test&quot;);
        Engine.Searcher updateSearchResult = engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(updateSearchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
        updateSearchResult.close();

        // the non release search result should not see the deleted yet...
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new</B></FONT> TermQuery(new Term(&quot;value&quot;, &quot;test&quot;)), 1));
        searchResult.close();
    }

    @Test
    public void testCommitAdvancesMinTranslogForRecovery() throws IOException {
        IOUtils.close(engine, store);
        final Path translogPath = createTempDir();
        store = createStore();
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final LongSupplier globalCheckpointSupplier = () -&gt; globalCheckpoint.get();
        engine = createEngine(config(defaultSettings, store, translogPath, newMergePolicy(), null, null,
            globalCheckpointSupplier));
        engine.onSettingsChanged(TimeValue.MINUS_ONE, ByteSizeValue.ZERO, randomNonNegativeLong());
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
        engine.index(indexForDoc(doc));
        boolean inSync = randomBoolean();
        if (inSync) {
            engine.syncTranslog(); // to advance persisted local checkpoint
            globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
        }

        engine.flush();
        assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
        assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));

        engine.flush();
        assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
        assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));

        engine.flush(true, true);
<A NAME="42"></A>        assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
        assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));

        <FONT color="#c57717"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#42',2,'match306914-top.html#42',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
        engine.flush(true, true);
        assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
        assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(3L));
    }

    @Test
<A NAME="84"></A>    public void testSyncedFlush() throws IOException {</B></FONT>
        try (Store store = createStore();
             Engine engine = createEngine(defaultSettings, store, createTempDir(), new LogByteSizeMergePolicy(), null)) {
            final String syncId = <FONT color="#e77471"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#84',2,'match306914-top.html#84',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>randomUnicodeOfCodepointLengthBetween(10, 20);
            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
            engine.index(indexForDoc(doc));
            Engine.CommitId commitID = engine.flush();
            assertThat(commitID, equalTo(new</B></FONT> Engine.CommitId(store.readLastCommittedSegmentsInfo().getId())));
            byte[] wrongBytes = Base64.getDecoder().decode(commitID.toString());
            wrongBytes[0] = (byte) ~wrongBytes[0];
            Engine.CommitId wrongId = new Engine.CommitId(wrongBytes);
            assertEquals(&quot;should fail to sync flush with wrong id (but no docs)&quot;, engine.syncFlush(syncId + &quot;1&quot;, wrongId),
                         Engine.SyncedFlushResult.COMMIT_MISMATCH);
            engine.index(indexForDoc(doc));
            assertEquals(&quot;should fail to sync flush with right id but pending doc&quot;,
                         engine.syncFlush(syncId + &quot;2&quot;, commitID), Engine.SyncedFlushResult.PENDING_OPERATIONS);
            commitID = engine.flush();
            assertEquals(&quot;should succeed to flush commit with right id and no pending doc&quot;, engine.syncFlush(syncId, commitID),
                         Engine.SyncedFlushResult.SUCCESS);
            assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
            assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
        }
    }

    @Test
    public void testRenewSyncFlush() throws Exception {
        final int iters = randomIntBetween(2, 5); // run this a couple of times to get some coverage
        for (int i = 0; i &lt; iters; i++) {
            try (Store store = createStore();
                 InternalEngine engine =
<A NAME="53"></A>                     createEngine(config(defaultSettings, store, createTempDir(), new LogDocMergePolicy(), null))) {
                final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
                Engine.Index doc1 =
                    indexForDoc(<FONT color="#ad5a3d"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#53',2,'match306914-top.html#53',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null));
                engine.index(doc1);
                assertEquals(engine.getLastWriteNanos(), doc1.startTime());
                engine.flush();
                Engine.Index doc2 =
                    indexForDoc(testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(), B_1, null));
                engine.index(doc2);
                assertEquals(engine.getLastWriteNanos</B></FONT>(), doc2.startTime());
                engine.flush();
                final boolean forceMergeFlushes = randomBoolean();
                final ParsedDocument parsedDoc3 =
                    testParsedDocument(&quot;3&quot;, null, testDocumentWithTextField(), B_1, null);
                if (forceMergeFlushes) {
                    engine.index(new Engine.Index(newUid(parsedDoc3), parsedDoc3, UNASSIGNED_SEQ_NO, 0,
                                                  Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY,
                                                  System.nanoTime() - engine.engineConfig.getFlushMergesAfter().nanos(),
                                                  -1, false, UNASSIGNED_SEQ_NO, 0));
                } else {
                    engine.index(indexForDoc(parsedDoc3));
                }
                Engine.CommitId commitID = engine.flush();
                assertEquals(&quot;should succeed to flush commit with right id and no pending doc&quot;, engine.syncFlush(syncId, commitID),
                             Engine.SyncedFlushResult.SUCCESS);
                assertEquals(3, engine.segments(false).size());

<A NAME="33"></A>                engine.forceMerge(forceMergeFlushes, 1, false, false, false, UUIDs.randomBase64UUID());
                if (forceMergeFlushes == false) {
                    engine.refresh(&quot;make all segments visible&quot;);
                    <FONT color="#736aff"><div style="position:absolute;left:0"><A
                            HREF="javascript:ZweiFrames('match306914-0.html#33',2,'match306914-top.html#33',1)"><IMG
                            SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(4, engine.segments(false).size());
                    assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
                    assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
                    assertTrue(engine.tryRenewSyncCommit());
                    assertEquals(1, engine.segments(false).size());
                }</B></FONT> else {
                    engine.refresh(&quot;test&quot;);
                    assertBusy(() -&gt; assertEquals(1, engine.segments(false).size()));
                }
                assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
                assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);

                if (randomBoolean()) {
                    Engine.Index doc4 =
                        indexForDoc(testParsedDocument(&quot;4&quot;, null, testDocumentWithTextField(), B_1, null));
<A NAME="85"></A>                    engine.index(doc4);
                    assertEquals(engine.getLastWriteNanos(), doc4.startTime());
                } else {
                    Engine.Delete delete = <FONT color="#717d7d"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#85',2,'match306914-top.html#85',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>new Engine.Delete(
                        doc1.id(),
                        doc1.uid(),
                        UNASSIGNED_SEQ_NO,
                        primaryTerm.get(),
                        Versions.MATCH_ANY,
                        VersionType.INTERNAL,
                        Engine.Operation.Origin.PRIMARY,
                        System.nanoTime(),
                        UNASSIGNED_SEQ_NO,
                        0
                    );
                    engine.delete(delete);
                    assertEquals(engine.getLastWriteNanos(), delete.startTime());
                }</B></FONT>
                assertFalse(engine.tryRenewSyncCommit());
                // we might hit a concurrent flush from a finishing merge here - just wait if ongoing...
                engine.flush(false, true);
                assertNull(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID));
                assertNull(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID));
            }
        }
    }

    @Test
    public void testSyncedFlushSurvivesEngineRestart() throws IOException {
<A NAME="106"></A>        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        IOUtils.close(store, engine);
        store = createStore();
        engine = <FONT color="#8e35ef"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#106',2,'match306914-top.html#106',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createEngine(store, primaryTranslogDir, globalCheckpoint::get);
        final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
<A NAME="61"></A>        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
                                                new BytesArray(&quot;{}&quot;), null);
        engine.index(indexForDoc</B></FONT>(doc));
        <FONT color="#6cc417"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#61',2,'match306914-top.html#61',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>globalCheckpoint.set(0L);
        final Engine.CommitId commitID = engine.flush();
        assertEquals(&quot;should succeed to flush commit with right id and no pending doc&quot;, engine.syncFlush(syncId, commitID),
                     Engine.SyncedFlushResult.SUCCESS);
        assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
        assertEquals(engine.getLastCommittedSegmentInfos</B></FONT>().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
        EngineConfig config = engine.config();
        if (randomBoolean()) {
            engine.close();
        } else {
            engine.flushAndClose();
        }
        if (randomBoolean()) {
            final String translogUUID = Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
                                                                     UNASSIGNED_SEQ_NO, shardId, primaryTerm.get());
            store.associateIndexWithNewTranslog(translogUUID);
        }
<A NAME="59"></A>        engine = new InternalEngine(config);
        engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
        assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
    <FONT color="#980517"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#59',2,'match306914-top.html#59',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testSyncedFlushVanishesOnReplay() throws IOException {
        final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null,
                                                testDocumentWithTextField(), new BytesArray(&quot;{}&quot;), null);
        engine.index(indexForDoc</B></FONT>(doc));
        final Engine.CommitId commitID = engine.flush();
        assertEquals(&quot;should succeed to flush commit with right id and no pending doc&quot;, engine.syncFlush(syncId, commitID),
                     Engine.SyncedFlushResult.SUCCESS);
        assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
        assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
        doc = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(), new BytesArray(&quot;{}&quot;), null);
        engine.index(indexForDoc(doc));
<A NAME="66"></A>        EngineConfig config = engine.config();
        engine.close();
        engine = new InternalEngine(config);
        <FONT color="#83a33a"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#66',2,'match306914-top.html#66',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
        assertNull(&quot;Sync ID must be gone since we have a document to replay&quot;,
                   engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID));
    }

    @Test
    public void testVersioningNewCreate() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument</B></FONT>(), B_1, null);
        Engine.Index create = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            Versions.MATCH_DELETED, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexResult = engine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));
<A NAME="73"></A>
        create = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), create.primaryTerm(), indexResult.getVersion(),
                                  null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        indexResult = <FONT color="#2981b2"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#73',2,'match306914-top.html#73',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>replicaEngine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));
    }

    @Test
    public void testReplicatedVersioningWithFlush() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument</B></FONT>(), B_1, null);
        Engine.Index create = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            Versions.MATCH_DELETED, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexResult = engine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));
        assertTrue(indexResult.isCreated());


        create = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), create.primaryTerm(), indexResult.getVersion(),
                                  null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        indexResult = replicaEngine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));
        assertTrue(indexResult.isCreated());

        if (randomBoolean()) {
            engine.flush();
        }
        if (randomBoolean()) {
            replicaEngine.flush();
        }

        Engine.Index update = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            1, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult updateResult = engine.index(update);
        assertThat(updateResult.getVersion(), equalTo(2L));
        assertFalse(updateResult.isCreated());


        update = new Engine.Index(newUid(doc), doc, updateResult.getSeqNo(), update.primaryTerm(), updateResult.getVersion(),
                                  null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        updateResult = replicaEngine.index(update);
        assertThat(updateResult.getVersion(), equalTo(2L));
        assertFalse(updateResult.isCreated());
        replicaEngine.refresh(&quot;test&quot;);
        try (Searcher searcher = replicaEngine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(1, searcher.getDirectoryReader().numDocs());
        }

        engine.refresh(&quot;test&quot;);
        try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            assertEquals(1, searcher.getDirectoryReader().numDocs());
        }
    }

    /**
     * simulates what an upsert / update API does
     */
    @Test
    public void testVersionedUpdate() throws IOException {
        final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;

        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), B_1, null);
        Engine.Index create = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            Versions.MATCH_DELETED, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexResult = engine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));
        try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
            assertEquals(1, get.docIdAndVersion().version);
        }

        Engine.Index update_1 = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            1, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult update_1_result = engine.index(update_1);
        assertThat(update_1_result.getVersion(), equalTo(2L));

        try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
            assertEquals(2, get.docIdAndVersion().version);
        }

        Engine.Index update_2 = new Engine.Index(
            newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
            2, VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult update_2_result = engine.index(update_2);
        assertThat(update_2_result.getVersion(), equalTo(3L));

        try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
            assertEquals(3, get.docIdAndVersion().version);
        }

    }

    @Test
    public void testVersioningNewIndex() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), B_1, null);
        Engine.Index index = indexForDoc(doc);
        Engine.IndexResult indexResult = engine.index(index);
        assertThat(indexResult.getVersion(), equalTo(1L));

        index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
                                 null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        indexResult = replicaEngine.index(index);
        assertThat(indexResult.getVersion(), equalTo(1L));
    }

    /*
     * we are testing an edge case here where we have a fully deleted segment that is retained but has all it's IDs pruned away.
     */
    @Test
    public void testLookupVersionWithPrunedAwayIds() throws IOException {
        try (Directory dir = newDirectory()) {
            IndexWriterConfig indexWriterConfig = new IndexWriterConfig(Lucene.STANDARD_ANALYZER);
            indexWriterConfig.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD);
            try (IndexWriter writer = new IndexWriter(dir,
                                                      indexWriterConfig.setMergePolicy(new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD,
                                                                                                                           MatchAllDocsQuery::new, new PrunePostingsMergePolicy(indexWriterConfig.getMergePolicy(), &quot;_id&quot;))))) {
                org.apache.lucene.document.Document doc = new org.apache.lucene.document.Document();
                doc.add(new Field(IdFieldMapper.NAME, &quot;1&quot;, IdFieldMapper.Defaults.FIELD_TYPE));
                doc.add(new NumericDocValuesField(VersionFieldMapper.NAME, -1));
                doc.add(new NumericDocValuesField(SeqNoFieldMapper.NAME, 1));
                doc.add(new NumericDocValuesField(SeqNoFieldMapper.PRIMARY_TERM_NAME, 1));
                writer.addDocument(doc);
                writer.flush();
                writer.softUpdateDocument(new Term(IdFieldMapper.NAME, &quot;1&quot;), doc, new NumericDocValuesField(Lucene.SOFT_DELETES_FIELD, 1));
                writer.updateNumericDocValue(new Term(IdFieldMapper.NAME, &quot;1&quot;), Lucene.SOFT_DELETES_FIELD, 1);
                writer.forceMerge(1);
                try (DirectoryReader reader = DirectoryReader.open(writer)) {
                    assertEquals(1, reader.leaves().size());
                    assertNull(VersionsAndSeqNoResolver.loadDocIdAndVersion(reader, new Term(IdFieldMapper.NAME, &quot;1&quot;), false));
<A NAME="67"></A>                }
            }
        }
    <FONT color="#ad5910"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#67',2,'match306914-top.html#67',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testUpdateWithFullyDeletedSegments() throws IOException {
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey</B></FONT>(), Integer.MAX_VALUE);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
                                                         null, globalCheckpoint::get))) {
            int numDocs = scaledRandomIntBetween(10, 100);
            for (int i = 0; i &lt; numDocs; i++) {
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
                engine.index(indexForDoc(doc));
                liveDocs.add(doc.id());
            }

            for (int i = 0; i &lt; numDocs; i++) {
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
                engine.index(indexForDoc(doc));
<A NAME="52"></A>                liveDocs.add(doc.id());
            }
        }
    <FONT color="#2b60de"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#52',2,'match306914-top.html#52',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testForceMergeWithSoftDeletesRetention() throws Exception {
        final long retainedExtraOps = randomLongBetween(0, 10);
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey</B></FONT>(), true)
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), retainedExtraOps);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final MapperService mapperService = createMapperService(&quot;test&quot;);
        final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
                                                         null, globalCheckpoint::get))) {
            int numDocs = scaledRandomIntBetween(10, 100);
            for (int i = 0; i &lt; numDocs; i++) {
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
                engine.index(indexForDoc(doc));
                liveDocs.add(doc.id());
            }
            for (int i = 0; i &lt; numDocs; i++) {
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
                if (randomBoolean()) {
                    engine.delete(new Engine.Delete(doc.id(), newUid(doc.id()), primaryTerm.get()));
                    liveDocs.remove(doc.id());
                }
                if (randomBoolean()) {
                    engine.index(indexForDoc(doc));
                    liveDocs.add(doc.id());
                }
                if (randomBoolean()) {
                    engine.flush(randomBoolean(), true);
                }
            }
            engine.flush();

            long localCheckpoint = engine.getProcessedLocalCheckpoint();
            globalCheckpoint.set(randomLongBetween(0, localCheckpoint));
            engine.syncTranslog();
            final long safeCommitCheckpoint;
            try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {
                safeCommitCheckpoint = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
            }
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
            Map&lt;Long, Translog.Operation&gt; ops = readAllOperationsInLucene(engine, mapperService)
                .stream().collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()));
            for (long seqno = 0; seqno &lt;= localCheckpoint; seqno++) {
                long minSeqNoToRetain = Math.min(globalCheckpoint.get() + 1 - retainedExtraOps,
                                                 safeCommitCheckpoint + 1);
                String msg = &quot;seq# [&quot; + seqno + &quot;], global checkpoint [&quot; + globalCheckpoint + &quot;], retained-ops [&quot; +
                             retainedExtraOps + &quot;]&quot;;
                if (seqno &lt; minSeqNoToRetain) {
                    Translog.Operation op = ops.get(seqno);
                    if (op != null) {
                        assertThat(op, instanceOf(Translog.Index.class));
                        assertThat(msg, ((Translog.Index) op).id(), isIn(liveDocs));
                        assertEquals(msg, ((Translog.Index) op).source(), B_1);
                    }
                } else {
<A NAME="21"></A>                    assertThat(msg, ops.get(seqno), notNullValue());
                }
            }
            settings.put(<FONT color="#947010"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#21',2,'match306914-top.html#21',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0);
            indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(
                settings).build());
            engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
                                     indexSettings.getSoftDeleteRetentionOperations());
            globalCheckpoint.set(localCheckpoint);
            engine.syncTranslog();

            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
<A NAME="78"></A>            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
            assertThat(readAllOperationsInLucene(engine, mapperService), hasSize(liveDocs.size()));
        }</B></FONT>
    <FONT color="#947010"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#78',2,'match306914-top.html#78',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testForceMergeWithSoftDeletesRetentionAndRecoverySource() throws Exception {
        final long retainedExtraOps = randomLongBetween(0, 10);
        Settings.Builder settings = Settings.builder()</B></FONT>
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), retainedExtraOps);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final MapperService mapperService = createMapperService(&quot;test&quot;);
        final boolean omitSourceAllTheTime = randomBoolean();
        final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
        final Set&lt;String&gt; liveDocsWithSource = new HashSet&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
                                                         null,
                                                         globalCheckpoint::get))) {
            int numDocs = scaledRandomIntBetween(10, 100);
            for (int i = 0; i &lt; numDocs; i++) {
                boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null,
                                                        useRecoverySource);
                engine.index(indexForDoc(doc));
                liveDocs.add(doc.id());
                if (useRecoverySource == false) {
                    liveDocsWithSource.add(Integer.toString(i));
                }
            }
            for (int i = 0; i &lt; numDocs; i++) {
                boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
                ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null,
                                                        useRecoverySource);
                if (randomBoolean()) {
                    engine.delete(new Engine.Delete(doc.id(), newUid(doc.id()), primaryTerm.get()));
                    liveDocs.remove(doc.id());
                    liveDocsWithSource.remove(doc.id());
                }
                if (randomBoolean()) {
                    engine.index(indexForDoc(doc));
                    liveDocs.add(doc.id());
                    if (useRecoverySource == false) {
                        liveDocsWithSource.add(doc.id());
                    } else {
                        liveDocsWithSource.remove(doc.id());
                    }
                }
                if (randomBoolean()) {
                    engine.flush(randomBoolean(), true);
                }
            }
            engine.flush();
            globalCheckpoint.set(randomLongBetween(0, engine.getPersistedLocalCheckpoint()));
            engine.syncTranslog();
            final long minSeqNoToRetain;
            try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {
                long safeCommitLocalCheckpoint = Long.parseLong(
                    safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
                minSeqNoToRetain = Math.min(globalCheckpoint.get() + 1 - retainedExtraOps,
                                            safeCommitLocalCheckpoint + 1);
            }
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
            Map&lt;Long, Translog.Operation&gt; ops = readAllOperationsInLucene(engine, mapperService)
                .stream().collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()));
            for (long seqno = 0; seqno &lt;= engine.getPersistedLocalCheckpoint(); seqno++) {
                String msg = &quot;seq# [&quot; + seqno + &quot;], global checkpoint [&quot; + globalCheckpoint + &quot;], retained-ops [&quot; +
                             retainedExtraOps + &quot;]&quot;;
                if (seqno &lt; minSeqNoToRetain) {
                    Translog.Operation op = ops.get(seqno);
                    if (op != null) {
                        assertThat(op, instanceOf(Translog.Index.class));
                        assertThat(msg, ((Translog.Index) op).id(), isIn(liveDocs));
                    }
                } else {
                    Translog.Operation op = ops.get(seqno);
                    assertThat(msg, op, notNullValue());
                    if (op instanceof Translog.Index) {
                        assertEquals(msg, ((Translog.Index) op).source(), B_1);
                    }
                }
            }
            settings.put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0);
            indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(
                settings).build());
            engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
                                     indexSettings.getSoftDeleteRetentionOperations());
            // If we already merged down to 1 segment, then the next force-merge will be a noop. We need to add an extra segment to make
            // merges happen so we can verify that _recovery_source are pruned. See: https://github.com/elastic/elasticsearch/issues/41628.
            final int numSegments;
            try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
                numSegments = searcher.getDirectoryReader().leaves().size();
            }
            if (numSegments == 1) {
                boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
                ParsedDocument doc = testParsedDocument(&quot;dummy&quot;, null, testDocument(), B_1, null, useRecoverySource);
                engine.index(indexForDoc(doc));
                if (useRecoverySource == false) {
                    liveDocsWithSource.add(doc.id());
                }
                engine.syncTranslog();
                globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
                engine.flush(randomBoolean(), true);
            } else {
                globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
                engine.syncTranslog();
            }
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
            assertThat(readAllOperationsInLucene(engine, mapperService), hasSize(liveDocsWithSource.size()));
        }
    }


    @Test
    public void testForceMergeAndClose() throws IOException, InterruptedException {
        int numIters = randomIntBetween(2, 10);
        for (int j = 0; j &lt; numIters; j++) {
            try (Store store = createStore()) {
                final InternalEngine engine = createEngine(store, createTempDir());
                final CountDownLatch startGun = new CountDownLatch(1);
                final CountDownLatch indexed = new CountDownLatch(1);

                Thread thread = new Thread() {
                    @Override
                    public void run() {
                        try {
                            try {
                                startGun.await();
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                            int i = 0;
                            while (true) {
                                int numDocs = randomIntBetween(1, 20);
                                for (int j = 0; j &lt; numDocs; j++) {
                                    i++;
                                    ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1,
                                                                            null);
                                    Engine.Index index = indexForDoc(doc);
                                    engine.index(index);
                                }
                                engine.refresh(&quot;test&quot;);
                                indexed.countDown();
                                try {
                                    engine.forceMerge(
                                        randomBoolean(),
                                        1,
                                        false,
                                        randomBoolean(),
                                        randomBoolean(),
                                        UUIDs.randomBase64UUID()
                                    );
                                } catch (IOException e) {
                                    return;
                                }
                            }
                        } catch (AlreadyClosedException ex) {
                            // fine
                        } catch (IOException e) {
                            throw new AssertionError(e);
                        }
                    }
                };

                thread.start();
                startGun.countDown();
                int someIters = randomIntBetween(1, 10);
                for (int i = 0; i &lt; someIters; i++) {
                    engine.forceMerge(randomBoolean(), 1, false, randomBoolean(), randomBoolean(), UUIDs.randomBase64UUID());
                }
                indexed.await();
                IOUtils.close(engine);
                thread.join();
            }
        }

    }

    @Test
    public void testVersioningCreateExistsException() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), B_1, null);
        Engine.Index create = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
                                               Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexResult = engine.index(create);
        assertThat(indexResult.getVersion(), equalTo(1L));

<A NAME="49"></A>        create = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, Versions.MATCH_DELETED,
                                  VersionType.INTERNAL, PRIMARY, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
        indexResult = engine.index(create);
        <FONT color="#8e35ef"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#49',2,'match306914-top.html#49',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
        assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));
    }

    @Test
    public void testOutOfOrderDocsOnReplica() throws IOException {
        final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL, VersionType.EXTERNAL_GTE),
            2, 2, 20, &quot;1&quot;);
        assertOpsOnReplica</B></FONT>(ops, replicaEngine, true, logger);
    }

    @Test
    public void testConcurrentOutOfOrderDocsOnReplica() throws IOException, InterruptedException {
        final List&lt;Engine.Operation&gt; opsDoc1 = generateSingleDocHistory(
            true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, &quot;1&quot;);
        final Engine.Operation lastOpDoc1 = opsDoc1.get(opsDoc1.size() - 1);
        final String lastFieldValueDoc1;
        if (lastOpDoc1 instanceof Engine.Index) {
            Engine.Index index = (Engine.Index) lastOpDoc1;
            lastFieldValueDoc1 = index.docs().get(0).get(&quot;value&quot;);
        } else {
            // delete
            lastFieldValueDoc1 = null;
        }
        final List&lt;Engine.Operation&gt; opsDoc2 =
            generateSingleDocHistory(
                true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, &quot;2&quot;);
        final Engine.Operation lastOpDoc2 = opsDoc2.get(opsDoc2.size() - 1);
        final String lastFieldValueDoc2;
        if (lastOpDoc2 instanceof Engine.Index) {
            Engine.Index index = (Engine.Index) lastOpDoc2;
            lastFieldValueDoc2 = index.docs().get(0).get(&quot;value&quot;);
        } else {
            // delete
            lastFieldValueDoc2 = null;
        }
        // randomly interleave
        final AtomicLong seqNoGenerator = new AtomicLong();
        BiFunction&lt;Engine.Operation, Long, Engine.Operation&gt; seqNoUpdater = (operation, newSeqNo) -&gt; {
            if (operation instanceof Engine.Index) {
                Engine.Index index = (Engine.Index) operation;
                Document doc = testDocumentWithTextField(index.docs().get(0).get(&quot;value&quot;));
                ParsedDocument parsedDocument = testParsedDocument(index.id(), index.routing(), doc, index.source(), null);
                return new Engine.Index(index.uid(), parsedDocument, newSeqNo, index.primaryTerm(), index.version(),
                                        index.versionType(), index.origin(), index.startTime(), index.getAutoGeneratedIdTimestamp(), index.isRetry(),
                                        UNASSIGNED_SEQ_NO, 0);
            } else {
                Engine.Delete delete = (Engine.Delete) operation;
                return new Engine.Delete(
                    delete.id(),
                    delete.uid(),
                    newSeqNo,
                    delete.primaryTerm(),
                    delete.version(),
                    delete.versionType(),
                    delete.origin(),
                    delete.startTime(),
                    UNASSIGNED_SEQ_NO,
                    0
                );
            }
        };
        final List&lt;Engine.Operation&gt; allOps = new ArrayList&lt;&gt;();
        Iterator&lt;Engine.Operation&gt; iter1 = opsDoc1.iterator();
        Iterator&lt;Engine.Operation&gt; iter2 = opsDoc2.iterator();
        while (iter1.hasNext() &amp;&amp; iter2.hasNext()) {
            final Engine.Operation next = randomBoolean() ? iter1.next() : iter2.next();
<A NAME="87"></A>            allOps.add(seqNoUpdater.apply(next, seqNoGenerator.getAndIncrement()));
        }
        iter1.forEachRemaining(o -&gt; allOps.add(seqNoUpdater.apply(o, seqNoGenerator.getAndIncrement())));
        <FONT color="#ae694a"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#87',2,'match306914-top.html#87',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>iter2.forEachRemaining(o -&gt; allOps.add(seqNoUpdater.apply(o, seqNoGenerator.getAndIncrement())));
        // insert some duplicates
        randomSubsetOf(allOps).forEach(op -&gt; allOps.add(seqNoUpdater.apply</B></FONT>(op, op.seqNo())));

        shuffle(allOps, random());
        concurrentlyApplyOps(allOps, engine);

        engine.refresh(&quot;test&quot;);

        if (lastFieldValueDoc1 != null) {
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValueDoc1)), collector);
                assertThat(collector.getTotalHits(), equalTo(1));
            }
        }
        if (lastFieldValueDoc2 != null) {
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValueDoc2)), collector);
                assertThat(collector.getTotalHits(), equalTo(1));
            }
        }

        int totalExpectedOps = 0;
        if (lastFieldValueDoc1 != null) {
            totalExpectedOps++;
        }
        if (lastFieldValueDoc2 != null) {
            totalExpectedOps++;
        }
        assertVisibleCount(engine, totalExpectedOps);
    }

    @Test
    public void testInternalVersioningOnPrimary() throws IOException {
        final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            false, VersionType.INTERNAL, 2, 2, 20, &quot;1&quot;);
        assertOpsOnPrimary(ops, Versions.NOT_FOUND, true, engine);
    }

    @Test
    public void testVersionOnPrimaryWithConcurrentRefresh() throws Exception {
        List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            false, VersionType.INTERNAL, 2, 10, 100, &quot;1&quot;);
        CountDownLatch latch = new CountDownLatch(1);
        AtomicBoolean running = new AtomicBoolean(true);
        Thread refreshThread = new Thread(() -&gt; {
            latch.countDown();
            while (running.get()) {
                engine.refresh(&quot;test&quot;);
            }
        });
        refreshThread.start();
        try {
            latch.await();
            assertOpsOnPrimary(ops, Versions.NOT_FOUND, true, engine);
        } finally {
            running.set(false);
            refreshThread.join();
        }
    }

    private int assertOpsOnPrimary(List&lt;Engine.Operation&gt; ops,
                                   long currentOpVersion,
                                   boolean docDeleted,
                                   InternalEngine engine)
        throws IOException {
        String lastFieldValue = null;
        int opsPerformed = 0;
        long lastOpVersion = currentOpVersion;
        long lastOpSeqNo = UNASSIGNED_SEQ_NO;
        long lastOpTerm = UNASSIGNED_PRIMARY_TERM;
        PrimaryTermSupplier currentTerm = (PrimaryTermSupplier) engine.engineConfig.getPrimaryTermSupplier();
        BiFunction&lt;Long, Engine.Index, Engine.Index&gt; indexWithVersion = (version, index) -&gt; new Engine.Index(
            index.uid(),
            index.parsedDoc(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            version,
            index.versionType(),
            index.origin(),
            index.startTime(),
            index.getAutoGeneratedIdTimestamp(),
            index.isRetry(),
            UNASSIGNED_SEQ_NO,
            0);
        BiFunction&lt;Long, Engine.Delete, Engine.Delete&gt; delWithVersion = (version, delete) -&gt; new Engine.Delete(
            delete.id(),
            delete.uid(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            version,
            delete.versionType(),
            delete.origin(),
            delete.startTime(),
            UNASSIGNED_SEQ_NO,
            0);
        TriFunction&lt;Long, Long, Engine.Index, Engine.Index&gt; indexWithSeq = (seqNo, term, index) -&gt; new Engine.Index(
            index.uid(),
            index.parsedDoc(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            index.version(),
            index.versionType(),
            index.origin(),
            index.startTime(),
            index.getAutoGeneratedIdTimestamp(),
<A NAME="104"></A>            index.isRetry(),
            seqNo,
            term);
        TriFunction&lt;Long, Long, Engine.Delete, Engine.Delete&gt; delWithSeq = (seqNo, term, delete) -&gt; <FONT
                color="#d16587"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#104',2,'match306914-top.html#104',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Engine.Delete(
            delete.id(),
            delete.uid(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            delete.version(),
            delete.versionType(),
            delete.origin(),
            delete.startTime(),
            seqNo,
            term);
        Function&lt;Engine.Index, Engine.Index&gt; indexWithCurrentTerm = index -&gt; new Engine.Index(</B></FONT>
            index.uid(),
            index.parsedDoc(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            index.version(),
            index.versionType(),
            index.origin(),
            index.startTime(),
            index.getAutoGeneratedIdTimestamp(),
            index.isRetry(),
            index.getIfSeqNo(),
            index.getIfPrimaryTerm());
        Function&lt;Engine.Delete, Engine.Delete&gt; deleteWithCurrentTerm = delete -&gt; new Engine.Delete(
            delete.id(),
            delete.uid(),
            UNASSIGNED_SEQ_NO,
            currentTerm.get(),
            delete.version(),
            delete.versionType(),
            delete.origin(),
            delete.startTime(),
            delete.getIfSeqNo(),
            delete.getIfPrimaryTerm());
        for (Engine.Operation op : ops) {
            final boolean versionConflict = rarely();
            final boolean versionedOp = versionConflict || randomBoolean();
            final long conflictingVersion = docDeleted || randomBoolean() ?
                lastOpVersion + (randomBoolean() ? 1 : -1) :
                Versions.MATCH_DELETED;
            final long conflictingSeqNo = lastOpSeqNo == UNASSIGNED_SEQ_NO  || randomBoolean() ?
                lastOpSeqNo + 5 : // use 5 to go above 0 for magic numbers
                lastOpSeqNo;
            final long conflictingTerm = conflictingSeqNo == lastOpSeqNo || randomBoolean() ? lastOpTerm + 1 : lastOpTerm;
            if (rarely()) {
                currentTerm.set(currentTerm.get() + 1L);
                engine.rollTranslogGeneration();
            }
            final long correctVersion = docDeleted ? Versions.MATCH_DELETED : lastOpVersion;
            logger.info(&quot;performing [{}]{}{}&quot;,
                        op.operationType().name().charAt(0),
                        versionConflict ? &quot; (conflict &quot; + conflictingVersion + &quot;)&quot; : &quot;&quot;,
                        versionedOp ? &quot; (versioned &quot; + correctVersion + &quot;, seqNo &quot; + lastOpSeqNo + &quot;, term &quot; + lastOpTerm + &quot; )&quot; : &quot;&quot;);
            if (op instanceof Engine.Index) {
                final Engine.Index index = (Engine.Index) op;
                if (versionConflict) {
                    // generate a conflict
                    final Engine.IndexResult result;
                    if (randomBoolean()) {
                        result = engine.index(indexWithSeq.apply(conflictingSeqNo, conflictingTerm, index));
                    } else {
                        result = engine.index(indexWithVersion.apply(conflictingVersion, index));
                    }
                    assertThat(result.isCreated(), equalTo(false));
                    assertThat(result.getVersion(), equalTo(lastOpVersion));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
                    assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
                } else {
                    final Engine.IndexResult result;
                    if (versionedOp) {
                        // TODO: add support for non-existing docs
                        if (randomBoolean() &amp;&amp; lastOpSeqNo != SequenceNumbers.UNASSIGNED_SEQ_NO &amp;&amp; docDeleted == false) {
                            result = engine.index(indexWithSeq.apply(lastOpSeqNo, lastOpTerm, index));
                        } else {
                            result = engine.index(indexWithVersion.apply(correctVersion, index));
                        }
                    } else {
                        result = engine.index(indexWithCurrentTerm.apply(index));
                    }
                    assertThat(result.isCreated(), equalTo(docDeleted));
                    assertThat(result.getVersion(), equalTo(Math.max(lastOpVersion + 1, 1)));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
                    assertThat(result.getFailure(), nullValue());
                    lastFieldValue = index.docs().get(0).get(&quot;value&quot;);
                    assert lastFieldValue != null : &quot;lastFieldValue is null after getting it from index docs&quot;;
                    docDeleted = false;
                    lastOpVersion = result.getVersion();
                    lastOpSeqNo = result.getSeqNo();
                    lastOpTerm = result.getTerm();
                    opsPerformed++;
                }
            } else {
                final Engine.Delete delete = (Engine.Delete) op;
                if (versionConflict) {
                    // generate a conflict
                    Engine.DeleteResult result;
                    if (randomBoolean()) {
                        result = engine.delete(delWithSeq.apply(conflictingSeqNo, conflictingTerm, delete));
                    } else {
                        result = engine.delete(delWithVersion.apply(conflictingVersion, delete));
                    }
                    assertThat(result.isFound(), equalTo(docDeleted == false));
                    assertThat(result.getVersion(), equalTo(lastOpVersion));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
                    assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
                } else {
                    final Engine.DeleteResult result;
                    long correctSeqNo = docDeleted ? UNASSIGNED_SEQ_NO : lastOpSeqNo;
                    if (versionedOp &amp;&amp; lastOpSeqNo != UNASSIGNED_SEQ_NO &amp;&amp; randomBoolean()) {
                        result = engine.delete(delWithSeq.apply(correctSeqNo, lastOpTerm, delete));
                    } else if (versionedOp) {
                        result = engine.delete(delWithVersion.apply(correctVersion, delete));
                    } else {
                        result = engine.delete(deleteWithCurrentTerm.apply(delete));
                    }
                    assertThat(result.isFound(), equalTo(docDeleted == false));
                    assertThat(result.getVersion(), equalTo(Math.max(lastOpVersion + 1, 1)));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
                    assertThat(result.getFailure(), nullValue());
                    docDeleted = true;
                    lastOpVersion = result.getVersion();
                    lastOpSeqNo = result.getSeqNo();
                    lastOpTerm = result.getTerm();
                    opsPerformed++;
                }
            }
            if (randomBoolean()) {
                // refresh and take the chance to check everything is ok so far
                assertVisibleCount(engine, docDeleted ? 0 : 1);
                // even if doc is not not deleted, lastFieldValue can still be null if this is the
                // first op and it failed.
                if (docDeleted == false &amp;&amp; lastFieldValue != null) {
                    try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                        final TotalHitCountCollector collector = new TotalHitCountCollector();
                        searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValue)), collector);
                        assertThat(collector.getTotalHits(), equalTo(1));
                    }
                }
            }
            if (randomBoolean()) {
                engine.flush();
                engine.refresh(&quot;test&quot;);
            }

            if (rarely()) {
                // simulate GC deletes
                engine.refresh(&quot;gc_simulation&quot;, Engine.SearcherScope.INTERNAL, true);
                engine.clearDeletedTombstones();
                if (docDeleted) {
                    lastOpVersion = Versions.NOT_FOUND;
                    lastOpSeqNo = UNASSIGNED_SEQ_NO;
                    lastOpTerm = UNASSIGNED_PRIMARY_TERM;
                }
            }
        }

        assertVisibleCount(engine, docDeleted ? 0 : 1);
        if (docDeleted == false) {
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                // lastFieldValue can be null if all index ops had a version conflict
                if (lastFieldValue != null) {
                    searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValue)), collector);
                    assertThat(collector.getTotalHits(), equalTo(1));
                }
            }
        }
        return opsPerformed;
    }

    @Test
    public void testNonInternalVersioningOnPrimary() throws IOException {
        final Set&lt;VersionType&gt; nonInternalVersioning = new HashSet&lt;&gt;(Arrays.asList(VersionType.values()));
        nonInternalVersioning.remove(VersionType.INTERNAL);
        final VersionType versionType = randomFrom(nonInternalVersioning);
        final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            false, versionType, 2, 2, 20, &quot;1&quot;);
        final Engine.Operation lastOp = ops.get(ops.size() - 1);
        final String lastFieldValue;
        if (lastOp instanceof Engine.Index) {
            Engine.Index index = (Engine.Index) lastOp;
            lastFieldValue = index.docs().get(0).get(&quot;value&quot;);
        } else {
            // delete
            lastFieldValue = null;
        }
        // other version types don't support out of order processing.
        if (versionType == VersionType.EXTERNAL) {
            shuffle(ops, random());
        }
        long highestOpVersion = Versions.NOT_FOUND;
        long seqNo = -1;
        boolean docDeleted = true;
        for (Engine.Operation op : ops) {
            logger.info(&quot;performing [{}], v [{}], seq# [{}], term [{}]&quot;,
                        op.operationType().name().charAt(0), op.version(), op.seqNo(), op.primaryTerm());
            if (op instanceof Engine.Index) {
                final Engine.Index index = (Engine.Index) op;
<A NAME="43"></A>                Engine.IndexResult result = engine.index(index);
                if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {
                    seqNo++;
                    <FONT color="#c22817"><div style="position:absolute;left:0"><A
                            HREF="javascript:ZweiFrames('match306914-0.html#43',2,'match306914-top.html#43',1)"><IMG
                            SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(result.getSeqNo(), equalTo(seqNo));
                    assertThat(result.isCreated(), equalTo(docDeleted));
                    assertThat(result.getVersion(), equalTo(op.version()));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
                    assertThat(result.getFailure(), nullValue</B></FONT>());
                    docDeleted = false;
                    highestOpVersion = op.version();
                } else {
                    assertThat(result.isCreated(), equalTo(false));
                    assertThat(result.getVersion(), equalTo(highestOpVersion));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
                    assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
                }
            } else {
                final Engine.Delete delete = (Engine.Delete) op;
                Engine.DeleteResult result = engine.delete(delete);
                if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {
                    seqNo++;
                    assertThat(result.getSeqNo(), equalTo(seqNo));
                    assertThat(result.isFound(), equalTo(docDeleted == false));
                    assertThat(result.getVersion(), equalTo(op.version()));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
                    assertThat(result.getFailure(), nullValue());
                    docDeleted = true;
                    highestOpVersion = op.version();
                } else {
                    assertThat(result.isFound(), equalTo(docDeleted == false));
                    assertThat(result.getVersion(), equalTo(highestOpVersion));
                    assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
                    assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
                }
            }
            if (randomBoolean()) {
                engine.refresh(&quot;test&quot;);
            }
            if (randomBoolean()) {
                engine.flush();
                engine.refresh(&quot;test&quot;);
            }
        }

        assertVisibleCount(engine, docDeleted ? 0 : 1);
        if (docDeleted == false) {
            logger.info(&quot;searching for [{}]&quot;, lastFieldValue);
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValue)), collector);
                assertThat(collector.getTotalHits(), equalTo(1));
            }
        }
    }

    @Test
    public void testVersioningPromotedReplica() throws IOException {
        final List&lt;Engine.Operation&gt; replicaOps = generateSingleDocHistory(
            true, VersionType.INTERNAL, 1, 2, 20, &quot;1&quot;);
        List&lt;Engine.Operation&gt; primaryOps = generateSingleDocHistory(
            false, VersionType.INTERNAL, 2, 2, 20, &quot;1&quot;);
        Engine.Operation lastReplicaOp = replicaOps.get(replicaOps.size() - 1);
        final boolean deletedOnReplica = lastReplicaOp instanceof Engine.Delete;
        final long finalReplicaVersion = lastReplicaOp.version();
        final long finalReplicaSeqNo = lastReplicaOp.seqNo();
        assertOpsOnReplica(replicaOps, replicaEngine, true, logger);
        final int opsOnPrimary = assertOpsOnPrimary(primaryOps, finalReplicaVersion, deletedOnReplica, replicaEngine);
        final long currentSeqNo = getSequenceID(
            replicaEngine,
            new Engine.Get(lastReplicaOp.uid().text(), lastReplicaOp.uid())).v1();
        try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
            final TotalHitCountCollector collector = new TotalHitCountCollector();
            searcher.search(new MatchAllDocsQuery(), collector);
            if (collector.getTotalHits() &gt; 0) {
                // last op wasn't delete
                assertThat(currentSeqNo, equalTo(finalReplicaSeqNo + opsOnPrimary));
            }
        }
    }

    @Test
    public void testConcurrentExternalVersioningOnPrimary() throws IOException, InterruptedException {
        final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            false, VersionType.EXTERNAL, 2, 100, 300, &quot;1&quot;);
        final Engine.Operation lastOp = ops.get(ops.size() - 1);
        final String lastFieldValue;
        if (lastOp instanceof Engine.Index) {
            Engine.Index index = (Engine.Index) lastOp;
            lastFieldValue = index.docs().get(0).get(&quot;value&quot;);
        } else {
            // delete
            lastFieldValue = null;
        }
        shuffle(ops, random());
        concurrentlyApplyOps(ops, engine);

        assertVisibleCount(engine, lastFieldValue == null ? 0 : 1);
        if (lastFieldValue != null) {
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                final TotalHitCountCollector collector = new TotalHitCountCollector();
                searcher.search(new TermQuery(new Term(&quot;value&quot;, lastFieldValue)), collector);
                assertThat(collector.getTotalHits(), equalTo(1));
            }
        }
    }

    @Test
    public void testConcurrentGetAndSetOnPrimary() throws IOException, InterruptedException {
        Thread[] thread = new Thread[randomIntBetween(3, 5)];
        CountDownLatch startGun = new CountDownLatch(thread.length);
        final int opsPerThread = randomIntBetween(10, 20);
        class OpAndVersion {
            final long version;
            final String removed;
            final String added;

            OpAndVersion(long version, String removed, String added) {
                this.version = version;
                this.removed = removed;
                this.added = added;
            }
        }
        final AtomicInteger idGenerator = new AtomicInteger();
        final Queue&lt;OpAndVersion&gt; history = ConcurrentCollections.newQueue();
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), bytesArray(&quot;&quot;), null);
        final Term uidTerm = newUid(doc);
        engine.index(indexForDoc(doc));
        final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
        for (int i = 0; i &lt; thread.length; i++) {
            thread[i] = new Thread(() -&gt; {
                startGun.countDown();
                try {
                    startGun.await();
                } catch (InterruptedException e) {
                    throw new AssertionError(e);
                }
                for (int op = 0; op &lt; opsPerThread; op++) {
                    try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), uidTerm), searcherFactory)) {
                        FieldsVisitor visitor = new FieldsVisitor(true);
                        get.docIdAndVersion().reader.document(get.docIdAndVersion().docId, visitor);
                        List&lt;String&gt; values = new ArrayList&lt;&gt;(Strings.commaDelimitedListToSet(visitor.source().utf8ToString()));
<A NAME="102"></A>                        String removed = op % 3 == 0 &amp;&amp; values.size() &gt; 0 ? values.remove(0) : null;
                        String added = &quot;v_&quot; + idGenerator.incrementAndGet();
                        values.add(added);
                        Engine.Index index = <FONT color="#549748"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#102',2,'match306914-top.html#102',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Engine.Index(uidTerm,
                                                              testParsedDocument(&quot;1&quot;, null, testDocument(),
                                                                                 bytesArray(Strings.collectionToCommaDelimitedString(values)), null),
                                                              UNASSIGNED_SEQ_NO, 2,
                                                              get.docIdAndVersion().version, VersionType.INTERNAL,
                                                              PRIMARY, System.currentTimeMillis(), -1, false, UNASSIGNED_SEQ_NO, 0);
                        Engine.IndexResult indexResult = engine.index</B></FONT>(index);
                        if (indexResult.getResultType() == Engine.Result.Type.SUCCESS) {
                            history.add(new OpAndVersion(indexResult.getVersion(), removed, added));
                        }

                    } catch (IOException e) {
                        throw new AssertionError(e);
                    }
                }
            });
            thread[i].start();
        }
        for (int i = 0; i &lt; thread.length; i++) {
            thread[i].join();
        }
        List&lt;OpAndVersion&gt; sortedHistory = new ArrayList&lt;&gt;(history);
        sortedHistory.sort(Comparator.comparing(o -&gt; o.version));
        Set&lt;String&gt; currentValues = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; sortedHistory.size(); i++) {
            OpAndVersion op = sortedHistory.get(i);
            if (i &gt; 0) {
                assertThat(&quot;duplicate version&quot;, op.version, not(equalTo(sortedHistory.get(i - 1).version)));
            }
            boolean exists = op.removed == null ? true : currentValues.remove(op.removed);
            assertTrue(op.removed + &quot; should exist&quot;, exists);
            exists = currentValues.add(op.added);
            assertTrue(op.added + &quot; should not exist&quot;, exists);
        }

        try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), uidTerm), searcherFactory)) {
            FieldsVisitor visitor = new FieldsVisitor(true);
            get.docIdAndVersion().reader.document(get.docIdAndVersion().docId, visitor);
            List&lt;String&gt; values = Arrays.asList(Strings.commaDelimitedListToStringArray(visitor.source().utf8ToString()));
            assertThat(currentValues, equalTo(new HashSet&lt;&gt;(values)));
        }
    }

    @Test
    public void testBasicCreatedFlag() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(), B_1, null);
        Engine.Index index = indexForDoc(doc);
        Engine.IndexResult indexResult = engine.index(index);
        assertTrue(indexResult.isCreated());

        index = indexForDoc(doc);
        indexResult = engine.index(index);
        assertFalse(indexResult.isCreated());

        engine.delete(new Engine.Delete(
            &quot;1&quot;,
            newUid(doc),
            UNASSIGNED_SEQ_NO,
            primaryTerm.get(),
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY,
            System.nanoTime(),
            UNASSIGNED_SEQ_NO,
            0
        ));

        index = indexForDoc(doc);
        indexResult = engine.index(index);
        assertTrue(indexResult.isCreated());
    }

    private static class MockAppender extends AbstractAppender {
        public boolean sawIndexWriterMessage;

        public boolean sawIndexWriterIFDMessage;

        MockAppender(final String name) throws IllegalAccessException {
            super(name, RegexFilter.createFilter(&quot;.*(\n.*)*&quot;, new String[0],
                                                 false, null, null), null);
        }

        @Override
        public void append(LogEvent event) {
            final String formattedMessage = event.getMessage().getFormattedMessage();
            if (event.getLevel() == Level.TRACE &amp;&amp; event.getMarker().getName().contains(&quot;[index][0]&quot;)) {
                if (event.getLoggerName().endsWith(&quot;.IW&quot;) &amp;&amp;
                    formattedMessage.contains(&quot;IW: now apply all deletes&quot;)) {
                    sawIndexWriterMessage = true;
                }
                if (event.getLoggerName().endsWith(&quot;.IFD&quot;)) {
                    sawIndexWriterIFDMessage = true;
                }
            }
        }
    }

    // #5891: make sure IndexWriter's infoStream output is
    // sent to lucene.iw with log level TRACE:
    @Test
    public void testIndexWriterInfoStream() throws IllegalAccessException, IOException {
        assumeFalse(&quot;who tests the tester?&quot;, VERBOSE);
        MockAppender mockAppender = new MockAppender(&quot;testIndexWriterInfoStream&quot;);
        mockAppender.start();

        Logger rootLogger = LogManager.getRootLogger();
        Level savedLevel = rootLogger.getLevel();
        Loggers.addAppender(rootLogger, mockAppender);
<A NAME="62"></A>        Loggers.setLevel(rootLogger, Level.DEBUG);
        rootLogger = LogManager.getRootLogger();

        try <FONT color="#151b8d"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#62',2,'match306914-top.html#62',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>{
            // First, with DEBUG, which should NOT log IndexWriter output:
            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
            engine.index(indexForDoc(doc));
            engine.flush();
            assertFalse(mockAppender.sawIndexWriterMessage);

            // Again, with TRACE, which should log IndexWriter output:
            Loggers.setLevel(rootLogger, Level.TRACE);
            engine.index(indexForDoc(doc));
            engine.flush();
            assertTrue</B></FONT>(mockAppender.sawIndexWriterMessage);

        } finally {
            Loggers.removeAppender(rootLogger, mockAppender);
            mockAppender.stop();
            Loggers.setLevel(rootLogger, savedLevel);
        }
    }

    @Test
    public void testSeqNoAndCheckpoints() throws IOException, InterruptedException {
        final int opCount = randomIntBetween(1, 256);
        long primarySeqNo = SequenceNumbers.NO_OPS_PERFORMED;
        final String[] ids = new String[]{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
        final Set&lt;String&gt; indexedIds = new HashSet&lt;&gt;();
        long localCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
        long replicaLocalCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
        final long globalCheckpoint;
        long maxSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
        IOUtils.close(store, engine);
        store = createStore();
        InternalEngine initialEngine = null;

        try {
            initialEngine = createEngine(defaultSettings, store, createTempDir(), newLogMergePolicy(), null);
            final ShardRouting primary = TestShardRouting.newShardRouting(&quot;test&quot;,
                                                                          shardId.id(), &quot;node1&quot;, null, true,
<A NAME="77"></A>                                                                          ShardRoutingState.STARTED, allocationId);
            final ShardRouting initializingReplica =
                TestShardRouting.newShardRouting(shardId, &quot;node2&quot;, false, ShardRoutingState.INITIALIZING);
            ReplicationTracker gcpTracker = (ReplicationTracker) <FONT color="#4e9258"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#77',2,'match306914-top.html#77',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>initialEngine.config().getGlobalCheckpointSupplier();
            gcpTracker.updateFromMaster(1L, new HashSet&lt;&gt;(Collections.singletonList(primary.allocationId().getId())),
                new IndexShardRoutingTable.Builder(shardId).addShard(primary).build());
            gcpTracker.activatePrimaryMode</B></FONT>(primarySeqNo);
            if (defaultSettings.isSoftDeleteEnabled()) {
                final CountDownLatch countDownLatch = new CountDownLatch(1);
                gcpTracker.addPeerRecoveryRetentionLease(initializingReplica.currentNodeId(),
                    SequenceNumbers.NO_OPS_PERFORMED, ActionListener.wrap(countDownLatch::countDown));
<A NAME="18"></A>                countDownLatch.await(5, TimeUnit.SECONDS);
            }
            gcpTracker.updateFromMaster(2L, new HashSet&lt;&gt;(Collections.singletonList(primary.allocationId().getId())),
                <FONT color="#800517"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#18',2,'match306914-top.html#18',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new IndexShardRoutingTable.Builder(shardId).addShard(primary).addShard(initializingReplica).build());
            gcpTracker.initiateTracking(initializingReplica.allocationId().getId());
            gcpTracker.markAllocationIdAsInSync(initializingReplica.allocationId().getId(), replicaLocalCheckpoint);
            final ShardRouting replica = initializingReplica.moveToStarted();
            gcpTracker.updateFromMaster(3L, new HashSet&lt;&gt;(Arrays.asList(primary.allocationId().getId(), replica.allocationId().getId())),
                new IndexShardRoutingTable.Builder(shardId).addShard</B></FONT>(primary).addShard(replica).build());

            for (int op = 0; op &lt; opCount; op++) {
                final String id;
                // mostly index, sometimes delete
                if (rarely() &amp;&amp; indexedIds.isEmpty() == false) {
                    // we have some docs indexed, so delete one of them
                    id = randomFrom(indexedIds);
                    final Engine.Delete delete = new Engine.Delete(
                        id,
                        newUid(id),
                        UNASSIGNED_SEQ_NO,
                        primaryTerm.get(),
                        rarely() ? 100 : Versions.MATCH_ANY,
                        VersionType.INTERNAL,
                        PRIMARY,
                        System.nanoTime(),
                        UNASSIGNED_SEQ_NO,
                        0
                    );
                    final Engine.DeleteResult result = initialEngine.delete(delete);
                    if (result.getResultType() == Engine.Result.Type.SUCCESS) {
                        assertThat(result.getSeqNo(), equalTo(primarySeqNo + 1));
                        assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo + 1));
                        indexedIds.remove(id);
                        primarySeqNo++;
                    } else {
                        assertThat(result.getSeqNo(), equalTo(UNASSIGNED_SEQ_NO));
                        assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
                    }
                } else {
                    // index a document
                    id = randomFrom(ids);
                    ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
                    final Engine.Index index = new Engine.Index(newUid(doc), doc,
                                                                UNASSIGNED_SEQ_NO, primaryTerm.get(),
                                                                rarely() ? 100 : Versions.MATCH_ANY, VersionType.INTERNAL,
                                                                PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
                    final Engine.IndexResult result = initialEngine.index(index);
                    if (result.getResultType() == Engine.Result.Type.SUCCESS) {
                        assertThat(result.getSeqNo(), equalTo(primarySeqNo + 1));
                        assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo + 1));
                        indexedIds.add(id);
                        primarySeqNo++;
                    } else {
                        assertThat(result.getSeqNo(), equalTo(UNASSIGNED_SEQ_NO));
                        assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
                    }
                }

                initialEngine.syncTranslog(); // to advance persisted local checkpoint

                if (randomInt(10) &lt; 3) {
                    // only update rarely as we do it every doc
                    replicaLocalCheckpoint = randomIntBetween(Math.toIntExact(replicaLocalCheckpoint), Math.toIntExact(primarySeqNo));
                }
                gcpTracker.updateLocalCheckpoint(primary.allocationId().getId(),
                    initialEngine.getPersistedLocalCheckpoint());
                gcpTracker.updateLocalCheckpoint(initializingReplica.allocationId().getId(), replicaLocalCheckpoint);

                if (rarely()) {
                    localCheckpoint = primarySeqNo;
                    maxSeqNo = primarySeqNo;
                    initialEngine.flush(true, true);
                }
<A NAME="26"></A>            }

            logger.info(&quot;localcheckpoint {}, global {}&quot;, replicaLocalCheckpoint, primarySeqNo);
            globalCheckpoint = <FONT color="#68818b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#26',2,'match306914-top.html#26',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>gcpTracker.getGlobalCheckpoint();

            assertEquals(primarySeqNo, initialEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertEquals(primarySeqNo, initialEngine.getPersistedLocalCheckpoint());
            assertThat(globalCheckpoint, equalTo(replicaLocalCheckpoint));

            assertThat(
                Long.parseLong(initialEngine.commitStats().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
                equalTo(localCheckpoint));
            initialEngine.getTranslog().sync(); // to guarantee the global checkpoint is written to the translog checkpoint
            assertThat(
                initialEngine.getTranslog</B></FONT>().getLastSyncedGlobalCheckpoint(),
                equalTo(globalCheckpoint));
            assertThat(
                Long.parseLong(initialEngine.commitStats().getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                equalTo(maxSeqNo));

        } finally {
            IOUtils.close(initialEngine);
<A NAME="25"></A>        }

        try (InternalEngine recoveringEngine = new InternalEngine(initialEngine.config())) {
            <FONT color="#5eac10"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#25',2,'match306914-top.html#25',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);

            assertEquals(primarySeqNo, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertThat(
                Long.parseLong(recoveringEngine.commitStats().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
                equalTo(primarySeqNo));
            assertThat(
                recoveringEngine.getTranslog().getLastSyncedGlobalCheckpoint(),
                equalTo(globalCheckpoint));
            assertThat(
                Long.parseLong(recoveringEngine.commitStats</B></FONT>().getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                // after recovering from translog, all docs have been flushed to Lucene segments, so here we will assert
                // that the committed max seq no is equivalent to what the current primary seq no is, as all data
                // we have assigned sequence numbers to should be in the commit
                equalTo(primarySeqNo));
            assertThat(recoveringEngine.getProcessedLocalCheckpoint(), equalTo(primarySeqNo));
            assertThat(recoveringEngine.getPersistedLocalCheckpoint(), equalTo(primarySeqNo));
            assertThat(recoveringEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
            assertThat(generateNewSeqNo(recoveringEngine), equalTo(primarySeqNo + 1));
        }
    }

    // this test writes documents to the engine while concurrently flushing/commit
    // and ensuring that the commit points contain the correct sequence number data
    @Test
    public void testConcurrentWritesAndCommits() throws Exception {
        List&lt;Engine.IndexCommitRef&gt; commits = new ArrayList&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(defaultSettings, store, createTempDir(), newMergePolicy(), null))) {
            final int numIndexingThreads = scaledRandomIntBetween(2, 4);
            final int numDocsPerThread = randomIntBetween(500, 1000);
            final CyclicBarrier barrier = new CyclicBarrier(numIndexingThreads + 1);
            final List&lt;Thread&gt; indexingThreads = new ArrayList&lt;&gt;();
            final CountDownLatch doneLatch = new CountDownLatch(numIndexingThreads);
            // create N indexing threads to index documents simultaneously
            for (int threadNum = 0; threadNum &lt; numIndexingThreads; threadNum++) {
                final int threadIdx = threadNum;
                Thread indexingThread = new Thread(() -&gt; {
                    try {
                        barrier.await(); // wait for all threads to start at the same time
                        // index random number of docs
                        for (int i = 0; i &lt; numDocsPerThread; i++) {
                            final String id = &quot;thread&quot; + threadIdx + &quot;#&quot; + i;
                            ParsedDocument doc = testParsedDocument(id, null, testDocument(), B_1, null);
                            engine.index(indexForDoc(doc));
                        }
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    } finally {
                        doneLatch.countDown();
                    }

                });
                indexingThreads.add(indexingThread);
            }

            // start the indexing threads
            for (Thread thread : indexingThreads) {
                thread.start();
            }
            barrier.await(); // wait for indexing threads to all be ready to start
            int commitLimit = randomIntBetween(10, 20);
            long sleepTime = 1;
            // create random commit points
            boolean doneIndexing;
            do {
                doneIndexing = doneLatch.await(sleepTime, TimeUnit.MILLISECONDS);
                commits.add(engine.acquireLastIndexCommit(true));
                if (commits.size() &gt; commitLimit) { // don't keep on piling up too many commits
                    IOUtils.close(commits.remove(randomIntBetween(0, commits.size()-1)));
                    // we increase the wait time to make sure we eventually if things are slow wait for threads to finish.
                    // this will reduce pressure on disks and will allow threads to make progress without piling up too many commits
                    sleepTime = sleepTime * 2;
                }
            } while (doneIndexing == false);

            // now, verify all the commits have the correct docs according to the user commit data
            long prevLocalCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
            long prevMaxSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
            for (Engine.IndexCommitRef commitRef : commits) {
                final IndexCommit commit = commitRef.getIndexCommit();
                Map&lt;String, String&gt; userData = commit.getUserData();
                long localCheckpoint = userData.containsKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY) ?
                    Long.parseLong(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) :
                    SequenceNumbers.NO_OPS_PERFORMED;
                long maxSeqNo = userData.containsKey(SequenceNumbers.MAX_SEQ_NO) ?
                    Long.parseLong(userData.get(SequenceNumbers.MAX_SEQ_NO)) :
                    UNASSIGNED_SEQ_NO;
                // local checkpoint and max seq no shouldn't go backwards
                assertThat(localCheckpoint, greaterThanOrEqualTo(prevLocalCheckpoint));
                assertThat(maxSeqNo, greaterThanOrEqualTo(prevMaxSeqNo));
                try (IndexReader reader = DirectoryReader.open(commit)) {
                    Long highest = getHighestSeqNo(reader);
                    final long highestSeqNo;
                    if (highest != null) {
                        highestSeqNo = highest.longValue();
                    } else {
                        highestSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
                    }
                    // make sure localCheckpoint &lt;= highest seq no found &lt;= maxSeqNo
                    assertThat(highestSeqNo, greaterThanOrEqualTo(localCheckpoint));
                    assertThat(highestSeqNo, lessThanOrEqualTo(maxSeqNo));
                    // make sure all sequence numbers up to and including the local checkpoint are in the index
                    FixedBitSet seqNosBitSet = getSeqNosSet(reader, highestSeqNo);
                    for (int i = 0; i &lt;= localCheckpoint; i++) {
                        assertTrue(&quot;local checkpoint [&quot; + localCheckpoint + &quot;], _seq_no [&quot; + i + &quot;] should be indexed&quot;,
                                   seqNosBitSet.get(i));
                    }
                }
                prevLocalCheckpoint = localCheckpoint;
                prevMaxSeqNo = maxSeqNo;
            }
        }
    }

    private static Long getHighestSeqNo(final IndexReader reader) throws IOException {
        final String fieldName = SeqNoFieldMapper.NAME;
        long size = PointValues.size(reader, fieldName);
        if (size == 0) {
            return null;
        }
        byte[] max = PointValues.getMaxPackedValue(reader, fieldName);
        return LongPoint.decodeDimension(max, 0);
    }

    private static FixedBitSet getSeqNosSet(final IndexReader reader, final long highestSeqNo) throws IOException {
        // _seq_no are stored as doc values for the time being, so this is how we get them
        // (as opposed to using an IndexSearcher or IndexReader)
        final FixedBitSet bitSet = new FixedBitSet((int) highestSeqNo + 1);
        final List&lt;LeafReaderContext&gt; leaves = reader.leaves();
        if (leaves.isEmpty()) {
            return bitSet;
        }

        for (int i = 0; i &lt; leaves.size(); i++) {
            final LeafReader leaf = leaves.get(i).reader();
            final NumericDocValues values = leaf.getNumericDocValues(SeqNoFieldMapper.NAME);
            if (values == null) {
                continue;
            }
            final Bits bits = leaf.getLiveDocs();
            for (int docID = 0; docID &lt; leaf.maxDoc(); docID++) {
                if (bits == null || bits.get(docID)) {
                    if (values.advanceExact(docID) == false) {
                        throw new AssertionError(&quot;Document does not have a seq number: &quot; + docID);
                    }
                    final long seqNo = values.longValue();
                    assertFalse(&quot;should not have more than one document with the same seq_no[&quot; +
                                seqNo + &quot;]&quot;, bitSet.get((int) seqNo));
                    bitSet.set((int) seqNo);
                }
            }
        }
        return bitSet;
    }

    // #8603: make sure we can separately log IFD's messages
    @Test
    public void testIndexWriterIFDInfoStream() throws IllegalAccessException, IOException {
        assumeFalse(&quot;who tests the tester?&quot;, VERBOSE);
        MockAppender mockAppender = new MockAppender(&quot;testIndexWriterIFDInfoStream&quot;);
        mockAppender.start();

        final Logger iwIFDLogger = LogManager.getLogger(&quot;org.elasticsearch.index.engine.Engine.IFD&quot;);

<A NAME="47"></A>        Loggers.addAppender(iwIFDLogger, mockAppender);
        Loggers.setLevel(iwIFDLogger, Level.DEBUG);

        try <FONT color="#d16587"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#47',2,'match306914-top.html#47',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>{
            // First, with DEBUG, which should NOT log IndexWriter output:
            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
            engine.index(indexForDoc(doc));
            engine.flush();
            assertFalse(mockAppender.sawIndexWriterMessage);
            assertFalse(mockAppender.sawIndexWriterIFDMessage);

            // Again, with TRACE, which should only log IndexWriter IFD output:
            Loggers.setLevel(iwIFDLogger, Level.TRACE);
            engine.index(indexForDoc(doc));
            engine.flush();
            assertFalse(mockAppender.sawIndexWriterMessage);
            assertTrue</B></FONT>(mockAppender.sawIndexWriterIFDMessage);

        } finally {
            Loggers.removeAppender(iwIFDLogger, mockAppender);
            mockAppender.stop();
            Loggers.setLevel(iwIFDLogger, (Level) null);
        }
    }

    @Test
    public void testEnableGcDeletes() throws Exception {
        try (Store store = createStore();
             Engine engine = createEngine(config(defaultSettings, store, createTempDir(), newMergePolicy(), null))) {
            engine.config().setEnableGcDeletes(false);

            final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;

            // Add document
            Document document = testDocument();
            document.add(new TextField(&quot;value&quot;, &quot;test1&quot;, Field.Store.YES));

            ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, document, B_2, null);
            engine.index(new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 1,
                                          VersionType.EXTERNAL,
                                          Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));

            // Delete document we just added:
            engine.delete(new Engine.Delete(
                &quot;1&quot;,
                newUid(doc),
                UNASSIGNED_SEQ_NO,
                0,
                10,
                VersionType.EXTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime(),
                UNASSIGNED_SEQ_NO,
                0
            ));

            // Get should not find the document
            Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory);
            assertThat(getResult.docIdAndVersion(), is(nullValue()));

            // Give the gc pruning logic a chance to kick in
            Thread.sleep(1000);

            if (randomBoolean()) {
                engine.refresh(&quot;test&quot;);
            }

            // Delete non-existent document
            engine.delete(new Engine.Delete(
                &quot;2&quot;,
                newUid(&quot;2&quot;),
                UNASSIGNED_SEQ_NO,
                0,
                10,
                VersionType.EXTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime(),
                UNASSIGNED_SEQ_NO,
                0
            ));

            // Get should not find the document (we never indexed uid=2):
            getResult = engine.get(new Engine.Get(&quot;2&quot;, newUid(&quot;2&quot;)), searcherFactory);
            assertThat(getResult.docIdAndVersion(), is(nullValue()));

            // Try to index uid=1 with a too-old version, should fail:
            Engine.Index index = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 2,
                                                  VersionType.EXTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
            Engine.IndexResult indexResult = engine.index(index);
            assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
            assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));

            // Get should still not find the document
            getResult = engine.get(newGet(doc), searcherFactory);
            assertThat(getResult.docIdAndVersion(), is(nullValue()));

            // Try to index uid=2 with a too-old version, should fail:
<A NAME="68"></A>            Engine.Index index1 = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 2,
                                                   VersionType.EXTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
            indexResult = engine.index(index1);
            assertThat(<FONT color="#b041ff"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#68',2,'match306914-top.html#68',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
            assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));

            // Get should not find the document
            getResult = engine.get(newGet(doc), searcherFactory);
            assertThat(getResult.docIdAndVersion(), is(nullValue()));
        }</B></FONT>
    }

    @Test
    public void testExtractShardId() {
        try (Engine.Searcher test = this.engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
            ShardId shardId = ShardUtils.extractShardId(test.getDirectoryReader());
            assertNotNull(shardId);
            assertEquals(shardId, engine.config().getShardId());
        }
    }

    /**
     * Random test that throws random exception and ensures all references are
     * counted down / released and resources are closed.
     */
    @Test
    public void testFailStart() throws IOException {
<A NAME="76"></A>        // this test fails if any reader, searcher or directory is not closed - MDW FTW
        final int iters = scaledRandomIntBetween(10, 100);
        for (int i = 0; i &lt; iters; i++) {
            <FONT color="#f62817"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#76',2,'match306914-top.html#76',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MockDirectoryWrapper wrapper = newMockDirectory();
            wrapper.setFailOnOpenInput(randomBoolean());
            wrapper.setAllowRandomFileNotFoundException(randomBoolean());
            wrapper.setRandomIOExceptionRate(randomDouble());
            wrapper.setRandomIOExceptionRateOnOpen(randomDouble());
            final Path translogPath = createTempDir</B></FONT>(&quot;testFailStart&quot;);
            try (Store store = createStore(wrapper)) {
                int refCount = store.refCount();
                assertTrue(&quot;refCount: &quot; + store.refCount(), store.refCount() &gt; 0);
                InternalEngine holder;
                try {
                    holder = createEngine(store, translogPath);
                } catch (EngineCreationFailureException | IOException ex) {
                    assertEquals(store.refCount(), refCount);
                    continue;
                }
                assertEquals(store.refCount(), refCount + 1);
                final int numStarts = scaledRandomIntBetween(1, 5);
                for (int j = 0; j &lt; numStarts; j++) {
                    try {
                        assertEquals(store.refCount(), refCount + 1);
                        holder.close();
                        holder = createEngine(store, translogPath);
                        assertEquals(store.refCount(), refCount + 1);
                    } catch (EngineCreationFailureException ex) {
                        // all is fine
                        assertEquals(store.refCount(), refCount);
                        break;
                    }
                }
                holder.close();
                assertEquals(store.refCount(), refCount);
            }
        }
    }

<A NAME="31"></A>    @Test
    public void testSettings() {
        CodecService codecService = new CodecService(null, logger);
        LiveIndexWriterConfig currentIndexWriterConfig = <FONT color="#3ea99f"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#31',2,'match306914-top.html#31',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.getCurrentIndexWriterConfig();

        assertEquals(engine.config().getCodec().getName(), codecService.codec(codecName).getName());
        assertEquals(currentIndexWriterConfig.getCodec().getName(), codecService.codec(codecName).getName());
    }

    @Test
    public void testCurrentTranslogIDisCommitted() throws IOException {
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)</B></FONT>;
        try (Store store = createStore()) {
            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null,
                                         globalCheckpoint::get);

            // create
            {
                store.createEmpty(Version.CURRENT.luceneVersion);
                final String translogUUID =
                    Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
                                                 SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
                store.associateIndexWithNewTranslog(translogUUID);
                ParsedDocument doc = testParsedDocument(Integer.toString(0), null, testDocument(),
                                                        new BytesArray(&quot;{}&quot;), null);
                Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
                                                                  Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);

<A NAME="97"></A>                try (InternalEngine engine = createEngine(config)) {
                    engine.index(firstIndexRequest);
                    engine.syncTranslog(); // to advance persisted local checkpoint
                    <FONT color="#347235"><div style="position:absolute;left:0"><A
                            HREF="javascript:ZweiFrames('match306914-0.html#97',2,'match306914-top.html#97',1)"><IMG
                            SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
                    globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
                    expectThrows(IllegalStateException.class, () -&gt; engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE));
                    Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos</B></FONT>().getUserData();
                    assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                }
            }
            // open and recover tlog
            {
                for (int i = 0; i &lt; 2; i++) {
                    try (InternalEngine engine = new InternalEngine(config)) {
                        expectThrows(IllegalStateException.class, engine::ensureCanFlush);
                        Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
                        assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                        engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                        userData = engine.getLastCommittedSegmentInfos().getUserData();
                        assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                    }
                }
            }
            // open index with new tlog
            {
                final String translogUUID =
                    Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
                                                 SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
                store.associateIndexWithNewTranslog(translogUUID);
                try (InternalEngine engine = new InternalEngine(config)) {
                    Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
                    assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                    engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                    assertEquals(2, engine.getTranslog().currentFileGeneration());
                }
            }

            // open and recover tlog with empty tlog
            {
                for (int i = 0; i &lt; 2; i++) {
                    try (InternalEngine engine = new InternalEngine(config)) {
                        Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
                        assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                        engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                        userData = engine.getLastCommittedSegmentInfos().getUserData();
                        assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
                    }
                }
            }
        }
    }

    @Test
    public void testMissingTranslog() throws IOException {
        // test that we can force start the engine , even if the translog is missing.
        engine.close();
<A NAME="50"></A>        // fake a new translog, causing the engine to point to a missing one.
        final long newPrimaryTerm = randomLongBetween(0L, primaryTerm.get());
        final Translog translog = createTranslog(() -&gt; newPrimaryTerm);
        long id = <FONT color="#ff0000"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#50',2,'match306914-top.html#50',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>translog.currentFileGeneration();
        translog.close();
        IOUtils.rm(translog.location().resolve(Translog.getFilename(id)));
        expectThrows(EngineCreationFailureException.class, &quot;engine shouldn't start without a valid translog id&quot;,
            () -&gt; createEngine(store, primaryTranslogDir));
        // when a new translog is created it should be ok
        final String translogUUID = Translog.createEmptyTranslog(primaryTranslogDir, UNASSIGNED_SEQ_NO, shardId, newPrimaryTerm);
        store.associateIndexWithNewTranslog(translogUUID);
        EngineConfig config = config(defaultSettings, store, primaryTranslogDir, newMergePolicy</B></FONT>(), null);
        engine = new InternalEngine(config);
    }

    @Test
    public void testTranslogReplayWithFailure() throws IOException {
        final MockDirectoryWrapper directory = newMockDirectory();
        final Path translogPath = createTempDir(&quot;testTranslogReplayWithFailure&quot;);
        try (Store store = createStore(directory)) {
            final int numDocs = randomIntBetween(1, 10);
            try (InternalEngine engine = createEngine(store, translogPath)) {
                for (int i = 0; i &lt; numDocs; i++) {
                    ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray(&quot;{}&quot;), null);
                    Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
                                                                      Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
                    Engine.IndexResult indexResult = engine.index(firstIndexRequest);
                    assertThat(indexResult.getVersion(), equalTo(1L));
                }
                assertVisibleCount(engine, numDocs);
            }
            // since we rollback the IW we are writing the same segment files again after starting IW but MDW prevents
            // this so we have to disable the check explicitly
            final int numIters = randomIntBetween(3, 5);
            for (int i = 0; i &lt; numIters; i++) {
                directory.setRandomIOExceptionRateOnOpen(randomDouble());
                directory.setRandomIOExceptionRate(randomDouble());
                directory.setFailOnOpenInput(randomBoolean());
                directory.setAllowRandomFileNotFoundException(randomBoolean());
                boolean started = false;
                InternalEngine engine = null;
                try {
                    engine = createEngine(store, translogPath);
                    started = true;
                } catch (EngineException | IOException e) {
                    logger.trace(&quot;exception on open&quot;, e);
                }
                directory.setRandomIOExceptionRateOnOpen(0.0);
                directory.setRandomIOExceptionRate(0.0);
                directory.setFailOnOpenInput(false);
                directory.setAllowRandomFileNotFoundException(false);
                if (started) {
                    engine.refresh(&quot;warm_up&quot;);
                    assertVisibleCount(engine, numDocs, false);
                    engine.close();
                }
            }
        }
    }

<A NAME="75"></A>    @Test
    public void testTranslogCleanUpPostCommitCrash() throws Exception {
        IndexSettings indexSettings = new IndexSettings(defaultSettings.getIndexMetadata(), defaultSettings.getNodeSettings(),
                                                        <FONT color="#800517"><div style="position:absolute;left:0"><A
                                                                HREF="javascript:ZweiFrames('match306914-0.html#75',2,'match306914-top.html#75',1)"><IMG
                                                                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>defaultSettings.getScopedSettings());
        IndexMetadata.Builder builder = IndexMetadata.builder(indexSettings.getIndexMetadata());
        builder.settings(Settings.builder().put(indexSettings.getSettings())
                             .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), &quot;-1&quot;)
                             .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey</B></FONT>(), &quot;-1&quot;)
        );
        indexSettings.updateIndexMetadata(builder.build());

        try (Store store = createStore()) {
            AtomicBoolean throwErrorOnCommit = new AtomicBoolean();
            final Path translogPath = createTempDir();
            final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
            final LongSupplier globalCheckpointSupplier = globalCheckpoint::get;
            store.createEmpty(Version.CURRENT.luceneVersion);
            final String translogUUID = Translog.createEmptyTranslog(translogPath, globalCheckpoint.get(), shardId, primaryTerm.get());
            store.associateIndexWithNewTranslog(translogUUID);
            try (InternalEngine engine =
                     new InternalEngine(config(indexSettings, store, translogPath, newMergePolicy(), null, null,
                                               globalCheckpointSupplier)) {

                         @Override
                         protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
                             super.commitIndexWriter(writer, translog, syncId);
                             if (throwErrorOnCommit.get()) {
                                 throw new RuntimeException(&quot;power's out&quot;);
                             }
<A NAME="32"></A>                         }
                     }) {
                engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                final ParsedDocument doc1 = <FONT color="#5b8daf"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#32',2,'match306914-top.html#32',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>testParsedDocument(&quot;1&quot;, null,
                                                               testDocumentWithTextField(), SOURCE, null);
                engine.index(indexForDoc(doc1));
                engine.syncTranslog(); // to advance local checkpoint
                assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
                globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
                throwErrorOnCommit.set(true);
                FlushFailedEngineException e = expectThrows(FlushFailedEngineException.class, engine::flush);
                assertThat(e.getCause().getMessage(), equalTo</B></FONT>(&quot;power's out&quot;));
            }
            try (InternalEngine engine =
                     new InternalEngine(config(indexSettings, store, translogPath, newMergePolicy(), null, null,
                                               globalCheckpointSupplier))) {
                engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                assertVisibleCount(engine, 1);
                final long localCheckpoint = Long.parseLong(
                    engine.getLastCommittedSegmentInfos().userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
                final long committedGen = engine.getTranslog().getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration;
                for (int gen = 1; gen &lt; committedGen; gen++) {
                    final Path genFile = translogPath.resolve(Translog.getFilename(gen));
                    assertFalse(genFile + &quot; wasn't cleaned up&quot;, Files.exists(genFile));
                }
            }
        }
    }

    @Test
    public void testSkipTranslogReplay() throws IOException {
        final int numDocs = randomIntBetween(1, 10);
        for (int i = 0; i &lt; numDocs; i++) {
            ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray(&quot;{}&quot;), null);
            Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
                                                              Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
            Engine.IndexResult indexResult = engine.index(firstIndexRequest);
            assertThat(indexResult.getVersion(), equalTo(1L));
        }
        EngineConfig config = engine.config();
        assertVisibleCount(engine, numDocs);
        engine.close();
        try (InternalEngine engine = new InternalEngine(config)) {
            engine.skipTranslogRecovery();
            try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
                TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), randomIntBetween(numDocs, numDocs + 10));
                assertThat(topDocs.totalHits.value, equalTo(0L));
            }
        }
    }

    @Test
    public void testTranslogReplay() throws IOException {
        final LongSupplier inSyncGlobalCheckpointSupplier = () -&gt; this.engine.getProcessedLocalCheckpoint();
        final int numDocs = randomIntBetween(1, 10);
        for (int i = 0; i &lt; numDocs; i++) {
            ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray(&quot;{}&quot;), null);
            Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
                                                              Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
            Engine.IndexResult indexResult = engine.index(firstIndexRequest);
            assertThat(indexResult.getVersion(), equalTo(1L));
        }
        assertVisibleCount(engine, numDocs);
        translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());

        engine.close();
        // we need to reuse the engine config unless the parser.mappingModified won't work
        engine = new InternalEngine(copy(engine.config(), inSyncGlobalCheckpointSupplier));
        engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
        engine.refresh(&quot;warm_up&quot;);

        assertVisibleCount(engine, numDocs, false);

        engine.close();
        translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());
        engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
<A NAME="99"></A>        engine.refresh(&quot;warm_up&quot;);
        assertVisibleCount(engine, numDocs, false);

        <FONT color="#c57717"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#99',2,'match306914-top.html#99',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>final boolean flush = randomBoolean();
        int randomId = randomIntBetween(numDocs + 1, numDocs + 10);
        ParsedDocument doc = testParsedDocument(Integer.toString(randomId), null, testDocument(), new</B></FONT> BytesArray(&quot;{}&quot;), null);
        Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, 1,
                                                          VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexResult = engine.index(firstIndexRequest);
        assertThat(indexResult.getVersion(), equalTo(1L));
        if (flush) {
            engine.flush();
            engine.refresh(&quot;test&quot;);
        }

        doc = testParsedDocument(Integer.toString(randomId), null, testDocument(), new BytesArray(&quot;{}&quot;), null);
        Engine.Index idxRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, 2,
                                                   VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult result = engine.index(idxRequest);
        engine.refresh(&quot;test&quot;);
        assertThat(result.getVersion(), equalTo(2L));
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs + 1);
            assertThat(topDocs.totalHits.value, equalTo(numDocs + 1L));
        }

        engine.close();
        translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());
        engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
        engine.refresh(&quot;warm_up&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs + 1);
            assertThat(topDocs.totalHits.value, equalTo(numDocs + 1L));
        }
        engine.delete(new Engine.Delete(
            Integer.toString(randomId),
            newUid(doc),
            UNASSIGNED_SEQ_NO,
            primaryTerm.get(),
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            Engine.Operation.Origin.PRIMARY,
            System.nanoTime(),
            UNASSIGNED_SEQ_NO,
            0
        ));
        if (randomBoolean()) {
            engine.close();
            engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
        }
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs);
            assertThat(topDocs.totalHits.value, equalTo((long) numDocs));
        }
    }

    @Test
    public void testRecoverFromForeignTranslog() throws IOException {
        final int numDocs = randomIntBetween(1, 10);
        for (int i = 0; i &lt; numDocs; i++) {
            ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray(&quot;{}&quot;), null);
            Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
                                                              Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
            Engine.IndexResult index = engine.index(firstIndexRequest);
            assertThat(index.getVersion(), equalTo(1L));
        }
        assertVisibleCount(engine, numDocs);
        Translog.TranslogGeneration generation = engine.getTranslog().getGeneration();
        engine.close();

        final Path badTranslogLog = createTempDir();
        final String badUUID = Translog.createEmptyTranslog(badTranslogLog, SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
<A NAME="91"></A>        Translog translog = new Translog(
            new TranslogConfig(shardId, badTranslogLog, INDEX_SETTINGS, BigArrays.NON_RECYCLING_INSTANCE),
            badUUID, createTranslogDeletionPolicy(INDEX_SETTINGS), () -&gt; SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -&gt; {});
        <FONT color="#827d6b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#91',2,'match306914-top.html#91',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>translog.add(new Translog.Index(
            &quot;SomeBogusId&quot;,
            0,
            primaryTerm.get(),
            &quot;{}&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;))));
        assertEquals(generation.translogFileGeneration, translog.currentFileGeneration());
        translog.close();

        EngineConfig config = engine.config</B></FONT>();
        /* create a TranslogConfig that has been created with a different UUID */
        TranslogConfig translogConfig = new TranslogConfig(shardId, translog.location(), config.getIndexSettings(),
                                                           BigArrays.NON_RECYCLING_INSTANCE);

        EngineConfig brokenConfig = new EngineConfig(
            shardId,
            allocationId.getId(),
            threadPool,
            config.getIndexSettings(),
            store,
            newMergePolicy(),
            config.getAnalyzer(),
            new CodecService(null, logger),
            config.getEventListener(),
            IndexSearcher.getDefaultQueryCache(),
            IndexSearcher.getDefaultQueryCachingPolicy(),
            translogConfig,
            TimeValue.timeValueMinutes(5),
            config.getExternalRefreshListener(),
            config.getInternalRefreshListener(),
            new NoneCircuitBreakerService(),
            () -&gt; UNASSIGNED_SEQ_NO,
            () -&gt; RetentionLeases.EMPTY,
            primaryTerm::get,
            tombstoneDocSupplier()
        );
        expectThrows(EngineCreationFailureException.class, () -&gt; new InternalEngine(brokenConfig));

        engine = createEngine(store, primaryTranslogDir); // and recover again!
        assertVisibleCount(engine, numDocs, true);
    }

    @Test
    public void testShardNotAvailableExceptionWhenEngineClosedConcurrently() throws IOException, InterruptedException {
        AtomicReference&lt;Exception&gt; exception = new AtomicReference&lt;&gt;();
        String operation = randomFrom(&quot;optimize&quot;, &quot;refresh&quot;, &quot;flush&quot;);
        Thread mergeThread = new Thread() {
            @Override
            public void run() {
                boolean stop = false;
                logger.info(&quot;try with {}&quot;, operation);
                while (stop == false) {
                    try {
                        switch (operation) {
                            case &quot;optimize&quot;: {
                                engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
                                break;
                            }
                            case &quot;refresh&quot;: {
                                engine.refresh(&quot;test refresh&quot;);
                                break;
                            }
                            case &quot;flush&quot;: {
                                engine.flush(true, false);
                                break;
                            }
                        }
                    } catch (Exception e) {
                        exception.set(e);
                        stop = true;
                    }
<A NAME="56"></A>                }
            }
        };
        <FONT color="#52d017"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#56',2,'match306914-top.html#56',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>mergeThread.start();
        engine.close();
        mergeThread.join();
        logger.info(&quot;exception caught: &quot;, exception.get());
        assertTrue(&quot;expected an Exception that signals shard is not available&quot;,
                   TransportActions.isShardNotAvailableException(exception.get()));
    }

    /**
     * Tests that when the close method returns the engine is actually guaranteed to have cleaned up and that resources are closed
     */
    @Test
    public void testConcurrentEngineClosed() throws BrokenBarrierException, InterruptedException {
        Thread[] closingThreads = new Thread[3]</B></FONT>;
        CyclicBarrier barrier = new CyclicBarrier(1 + closingThreads.length + 1);
        Thread failEngine = new Thread(new AbstractRunnable() {
            @Override
            public void onFailure(Exception e) {
                throw new AssertionError(e);
            }

            @Override
            protected void doRun() throws Exception {
                barrier.await();
                engine.failEngine(&quot;test&quot;, new RuntimeException(&quot;test&quot;));
            }
        });
        failEngine.start();
        for (int i = 0;i &lt; closingThreads.length ; i++) {
            boolean flushAndClose = randomBoolean();
            closingThreads[i] = new Thread(new AbstractRunnable() {
                @Override
                public void onFailure(Exception e) {
                    throw new AssertionError(e);
                }

                @Override
                protected void doRun() throws Exception {
                    barrier.await();
                    if (flushAndClose) {
                        engine.flushAndClose();
                    } else {
                        engine.close();
                    }
                    // try to acquire the writer lock - i.e., everything is closed, we need to synchronize
                    // to avoid races between closing threads
                    synchronized (closingThreads) {
                        try (Lock ignored = store.directory().obtainLock(IndexWriter.WRITE_LOCK_NAME)) {
                            // all good.
                        }
                    }
                }
            });
            closingThreads[i].setName(&quot;closingThread_&quot; + i);
            closingThreads[i].start();
        }
        barrier.await();
        failEngine.join();
        for (Thread t : closingThreads) {
            t.join();
        }
    }

    private static class ThrowingIndexWriter extends IndexWriter {
        private AtomicReference&lt;Supplier&lt;Exception&gt;&gt; failureToThrow = new AtomicReference&lt;&gt;();

        ThrowingIndexWriter(Directory d, IndexWriterConfig conf) throws IOException {
            super(d, conf);
        }

        @Override
        public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) throws IOException {
            maybeThrowFailure();
            return super.addDocument(doc);
        }

        private void maybeThrowFailure() throws IOException {
            if (failureToThrow.get() != null) {
                Exception failure = failureToThrow.get().get();
                clearFailure(); // one shot
                if (failure instanceof RuntimeException) {
                    throw (RuntimeException) failure;
                } else if (failure instanceof IOException) {
                    throw (IOException) failure;
                } else {
                    assert false: &quot;unsupported failure class: &quot; + failure.getClass().getCanonicalName();
                }
            }
        }

        @Override
        public long softUpdateDocument(Term term, Iterable&lt;? extends IndexableField&gt; doc, Field... softDeletes) throws IOException {
            maybeThrowFailure();
            return super.softUpdateDocument(term, doc, softDeletes);
        }

        @Override
        public long deleteDocuments(Term... terms) throws IOException {
            maybeThrowFailure();
            return super.deleteDocuments(terms);
        }

        public void setThrowFailure(Supplier&lt;Exception&gt; failureSupplier) {
            failureToThrow.set(failureSupplier);
        }

        public void clearFailure() {
            failureToThrow.set(null);
        }
    }

    @Test
    public void testHandleDocumentFailure() throws Exception {
        try (Store store = createStore()) {
            final ParsedDocument doc1 = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), B_1, null);
            final ParsedDocument doc2 = testParsedDocument(&quot;2&quot;, null, testDocumentWithTextField(), B_1, null);
            final ParsedDocument doc3 = testParsedDocument(&quot;3&quot;, null, testDocumentWithTextField(), B_1, null);

            AtomicReference&lt;ThrowingIndexWriter&gt; throwingIndexWriter = new AtomicReference&lt;&gt;();
            try (InternalEngine engine = createEngine(
                defaultSettings,
                store,
                createTempDir(),
                NoMergePolicy.INSTANCE,
                (directory, iwc) -&gt; {
                    throwingIndexWriter.set(new ThrowingIndexWriter(directory, iwc));
                    return throwingIndexWriter.get();
                })
            ) {
                // test document failure while indexing
                if (randomBoolean()) {
                    throwingIndexWriter.get().setThrowFailure(() -&gt; new IOException(&quot;simulated&quot;));
                } else {
                    throwingIndexWriter.get().setThrowFailure(() -&gt; new IllegalArgumentException(&quot;simulated max token length&quot;));
                }
<A NAME="40"></A>                // test index with document failure
                Engine.IndexResult indexResult = engine.index(indexForDoc(doc1));
                assertNotNull(indexResult.getFailure());
                <FONT color="#347235"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#40',2,'match306914-top.html#40',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(indexResult.getSeqNo(), equalTo(0L));
                assertThat(indexResult.getVersion(), equalTo(Versions.MATCH_ANY));
                assertNotNull(indexResult.getTranslogLocation());

                throwingIndexWriter.get().clearFailure();
                indexResult = engine.index(indexForDoc(doc1));
                assertThat(indexResult.getSeqNo(), equalTo(1L));
                assertThat</B></FONT>(indexResult.getVersion(), equalTo(1L));
                assertNull(indexResult.getFailure());
                assertNotNull(indexResult.getTranslogLocation());
                engine.index(indexForDoc(doc2));

                // test non document level failure is thrown
                if (randomBoolean()) {
                    // simulate close by corruption
                    throwingIndexWriter.get().setThrowFailure(null);
                    UncheckedIOException uncheckedIOException = expectThrows(UncheckedIOException.class, () -&gt; {
                        Engine.Index index = indexForDoc(doc3);
                        index.parsedDoc().rootDoc().add(new StoredField(&quot;foo&quot;, &quot;bar&quot;) {
                            // this is a hack to add a failure during store document which triggers a tragic event
                            // and in turn fails the engine
                            @Override
                            public BytesRef binaryValue() {
                                throw new UncheckedIOException(new MockDirectoryWrapper.FakeIOException());
                            }
                        });
                        engine.index(index);
                    });
                    assertTrue(uncheckedIOException.getCause() instanceof MockDirectoryWrapper.FakeIOException);
                } else {
                    // normal close
<A NAME="72"></A>                    engine.close();
                }
                // now the engine is closed check we respond correctly
                <FONT color="#f52887"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#72',2,'match306914-top.html#72',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expectThrows(AlreadyClosedException.class, () -&gt; engine.index(indexForDoc(doc1)));
                expectThrows(AlreadyClosedException.class,
                             () -&gt; engine.delete(new Engine.Delete(
                                 &quot;1&quot;,
                                 newUid(doc1),
                                 UNASSIGNED_SEQ_NO,
                                 primaryTerm.get(),
                                 Versions.MATCH_ANY,
                                 VersionType.INTERNAL,
                                 Engine.Operation.Origin.PRIMARY,
                                 System.nanoTime(),
                                 UNASSIGNED_SEQ_NO,
                                 0)));
                expectThrows(AlreadyClosedException.class,
                             () -&gt; engine.noOp(
                                 new Engine.NoOp(engine.getLocalCheckpointTracker().generateSeqNo</B></FONT>(),
                                                 engine.config().getPrimaryTermSupplier().getAsLong(),
                                                 randomFrom(Engine.Operation.Origin.values()),
                                                 randomNonNegativeLong(),
                                                 &quot;test&quot;)));
            }
        }
    }

    @Test
    public void testDeleteWithFatalError() throws Exception {
        final IllegalStateException tragicException = new IllegalStateException(&quot;fail to store tombstone&quot;);
        try (Store store = createStore()) {
            EngineConfig.TombstoneDocSupplier tombstoneDocSupplier = new EngineConfig.TombstoneDocSupplier() {
                @Override
                public ParsedDocument newDeleteTombstoneDoc(String id) {
                    ParsedDocument parsedDocument = tombstoneDocSupplier().newDeleteTombstoneDoc(id);
                    parsedDocument.rootDoc().add(new StoredField(&quot;foo&quot;, &quot;bar&quot;) {
                        // this is a hack to add a failure during store document which triggers a tragic event
                        // and in turn fails the engine
                        @Override
                        public BytesRef binaryValue() {
                            throw tragicException;
                        }
                    });
                    return parsedDocument;
                }

                @Override
                public ParsedDocument newNoopTombstoneDoc(String reason) {
                    return tombstoneDocSupplier().newNoopTombstoneDoc(reason);
                }
<A NAME="65"></A>            };
            EngineConfig config = config(this.engine.config(), store, createTempDir(), tombstoneDocSupplier);
            try (InternalEngine engine = createEngine(config)) {
                final ParsedDocument doc = <FONT color="#c58917"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#65',2,'match306914-top.html#65',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), SOURCE, null);
                engine.index(indexForDoc(doc));
                expectThrows(IllegalStateException.class, () -&gt; engine.delete(
                    new Engine.Delete(
                        &quot;1&quot;,
                        newUid(doc),
                        UNASSIGNED_SEQ_NO,
                        primaryTerm.get(),
                        Versions.MATCH_ANY,
                        VersionType.INTERNAL,
                        Engine.Operation.Origin.PRIMARY,
                        System.nanoTime(),
                        UNASSIGNED_SEQ_NO,
                        0
                    )));
                assertTrue(engine.isClosed.get());
                assertSame</B></FONT>(tragicException, engine.failedEngine.get());
            }
        }
    }

    @Test
    public void testDoubleDeliveryPrimary() throws IOException {
        final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
            new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        final boolean create = randomBoolean();
<A NAME="96"></A>        Engine.Index operation = appendOnlyPrimary(doc, false, 1, create);
        Engine.Index retry = appendOnlyPrimary(doc, true, 1, create);
        if (randomBoolean()) {
            Engine.IndexResult indexResult = <FONT color="#152dc6"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#96',2,'match306914-top.html#96',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.index(operation);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(indexResult.getTranslogLocation());
            Engine.IndexResult retryResult = engine.index(retry);
            assertLuceneOperations</B></FONT>(engine, 1, create ? 0 : 1, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
            if (create) {
                assertNull(retryResult.getTranslogLocation());
            } else {
<A NAME="95"></A>                assertNotNull(retryResult.getTranslogLocation());
            }
        } else {
            Engine.IndexResult retryResult = <FONT color="#348781"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#95',2,'match306914-top.html#95',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.index(retry);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
            assertNotNull(retryResult.getTranslogLocation());
            Engine.IndexResult indexResult = engine.index(operation);
            assertLuceneOperations</B></FONT>(engine, 1, create ? 0 : 1, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(2L));
            assertNotNull(retryResult.getTranslogLocation());
            if (create) {
                assertNull(indexResult.getTranslogLocation());
            } else {
                assertNotNull(indexResult.getTranslogLocation());
            }
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
        operation = appendOnlyPrimary(doc, false, 1, create);
        retry = appendOnlyPrimary(doc, true, 1, create);
        if (randomBoolean()) {
            Engine.IndexResult indexResult = engine.index(operation);
            if (create) {
                assertNull(indexResult.getTranslogLocation());
            } else {
                assertNotNull(indexResult.getTranslogLocation());
            }
            Engine.IndexResult retryResult = engine.index(retry);
            if (create) {
                assertNull(retryResult.getTranslogLocation());
            } else {
                assertNotNull(retryResult.getTranslogLocation());
            }
        } else {
            Engine.IndexResult retryResult = engine.index(retry);
            if (create) {
                assertNull(retryResult.getTranslogLocation());
            } else {
                assertNotNull(retryResult.getTranslogLocation());
            }
            Engine.IndexResult indexResult = engine.index(operation);
            if (create) {
                assertNull(indexResult.getTranslogLocation());
            } else {
                assertNotNull(indexResult.getTranslogLocation());
            }
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
    }

    @Test
    public void testDoubleDeliveryReplicaAppendingAndDeleteOnly() throws IOException {
        final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
                                                      new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        Engine.Index operation = appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
        Engine.Index retry = appendOnlyReplica(doc, true, 1, randomIntBetween(0, 5));
<A NAME="94"></A>        Engine.Delete delete = new Engine.Delete(
            operation.id(),
            operation.uid(),
            <FONT color="#810541"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#94',2,'match306914-top.html#94',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Math.max(retry.seqNo(), operation.seqNo()) + 1,
            operation.primaryTerm(),
            operation.version() + 1,
            operation.versionType(),
            REPLICA,
            operation.startTime() + 1,
            UNASSIGNED_SEQ_NO,
            0
        );
        // operations with a seq# equal or lower to the local checkpoint are not indexed to lucene
<A NAME="37"></A>        // and the version lookup is skipped
        final boolean sameSeqNo = operation.seqNo() == retry.seqNo</B></FONT>();
        if (randomBoolean()) {
            Engine.IndexResult indexResult = <FONT color="#810541"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#37',2,'match306914-top.html#37',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.index(operation);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(indexResult.getTranslogLocation());
            engine.delete(delete);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
            assertLuceneOperations(engine, 1, 0, 1);
            Engine.IndexResult retryResult = engine.index(retry);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is</B></FONT>(sameSeqNo ? 1L : 2L));
<A NAME="36"></A>            assertNotNull(retryResult.getTranslogLocation());
            assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &gt; 0);
        } else {
            Engine.IndexResult retryResult = <FONT color="#ff00ff"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#36',2,'match306914-top.html#36',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.index(retry);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(retryResult.getTranslogLocation());
            engine.delete(delete);
            assertLuceneOperations(engine, 1, 0, 1);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
            Engine.IndexResult indexResult = engine.index(operation);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is</B></FONT>(sameSeqNo ? 1L : 2L));
            assertNotNull(retryResult.getTranslogLocation());
            assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &lt; 0);
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(0, topDocs.totalHits.value);
        }
    }

    @Test
    public void testDoubleDeliveryReplicaAppendingOnly() throws IOException {
        final Supplier&lt;ParsedDocument&gt; doc = () -&gt; testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
            new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        boolean replicaOperationIsRetry = randomBoolean();
        Engine.Index operation = appendOnlyReplica(doc.get(), replicaOperationIsRetry, 1, randomIntBetween(0, 5));

        Engine.IndexResult result = engine.index(operation);
        assertLuceneOperations(engine, 1, 0, 0);
        assertEquals(0, engine.getNumVersionLookups());
        assertNotNull(result.getTranslogLocation());

        // promote to primary: first do refresh
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }

        final boolean create = randomBoolean();
        operation = appendOnlyPrimary(doc.get(), false, 1, create);
        Engine.Index retry = appendOnlyPrimary(doc.get(), true, 1, create);
        if (randomBoolean()) {
            // if the replica operation wasn't a retry, the operation arriving on the newly promoted primary must be a retry
            if (replicaOperationIsRetry) {
                Engine.IndexResult indexResult = engine.index(operation);
                if (create) {
                    assertNull(indexResult.getTranslogLocation());
                } else {
                    assertNotNull(indexResult.getTranslogLocation());
                }
            }
            Engine.IndexResult retryResult = engine.index(retry);
            if (create) {
                assertNull(retryResult.getTranslogLocation());
            } else {
                assertNotNull(retryResult.getTranslogLocation());
            }
        } else {
            Engine.IndexResult retryResult = engine.index(retry);
            if (create) {
                assertNull(retryResult.getTranslogLocation());
            } else {
                assertNotNull(retryResult.getTranslogLocation());
            }
            Engine.IndexResult indexResult = engine.index(operation);
            if (create) {
                assertNull(indexResult.getTranslogLocation());
            } else {
                assertNotNull(indexResult.getTranslogLocation());
            }
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
    }

    @Test
    public void testDoubleDeliveryReplica() throws IOException {
        final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
                                                      new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        Engine.Index operation = replicaIndexForDoc(doc, 1, 20, false);
        Engine.Index duplicate = replicaIndexForDoc(doc, 1, 20, true);
        if (randomBoolean()) {
            Engine.IndexResult indexResult = engine.index(operation);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(indexResult.getTranslogLocation());
            if (randomBoolean()) {
                engine.refresh(&quot;test&quot;);
            }
            Engine.IndexResult retryResult = engine.index(duplicate);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(retryResult.getTranslogLocation());
            assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &gt; 0);
        } else {
            Engine.IndexResult retryResult = engine.index(duplicate);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(retryResult.getTranslogLocation());
            if (randomBoolean()) {
                engine.refresh(&quot;test&quot;);
            }
            Engine.IndexResult indexResult = engine.index(operation);
            assertLuceneOperations(engine, 1, 0, 0);
            assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
            assertNotNull(retryResult.getTranslogLocation());
            assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &lt; 0);
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
<A NAME="105"></A>            assertEquals(1, topDocs.totalHits.value);
        }
        if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
            List&lt;Translog.Operation&gt; ops = <FONT color="#c57726"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#105',2,'match306914-top.html#105',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>readAllOperationsInLucene(engine, createMapperService(&quot;test&quot;));
            assertThat(ops.stream().map(o -&gt; o.seqNo()).collect(Collectors.toList</B></FONT>()), hasItem(20L));
        }
    }

    @Test
    public void testRetryWithAutogeneratedIdWorksAndNoDuplicateDocs() throws IOException {

        final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
                                                      new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        boolean isRetry = false;
        long autoGeneratedIdTimestamp = 0;

        Engine.Index index = new Engine.Index(
            newUid(doc),
            doc,
            UNASSIGNED_SEQ_NO,
            1,
            randomBoolean() ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
            VersionType.INTERNAL,
            PRIMARY,
            System.nanoTime(),
            autoGeneratedIdTimestamp,
            isRetry,
            UNASSIGNED_SEQ_NO,
            0
        );
        Engine.IndexResult indexResult = engine.index(index);
        assertThat(indexResult.getVersion(), equalTo(1L));

        index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
                                 null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
        indexResult = replicaEngine.index(index);
        assertThat(indexResult.getVersion(), equalTo(1L));

        isRetry = true;
        index = new Engine.Index(
            newUid(doc),
            doc,
            UNASSIGNED_SEQ_NO,
            1,
            Versions.MATCH_ANY,
            VersionType.INTERNAL,
            PRIMARY,
            System.nanoTime(),
            autoGeneratedIdTimestamp,
            isRetry,
            UNASSIGNED_SEQ_NO,
            0
        );
        indexResult = engine.index(index);
        assertThat(indexResult.getVersion(), equalTo(1L));
        assertNotEquals(indexResult.getSeqNo(), UNASSIGNED_SEQ_NO);
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }

        index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
                                 null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
        indexResult = replicaEngine.index(index);
        assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
        replicaEngine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = replicaEngine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
    }

    @Test
    public void testRetryWithAutogeneratedIdsAndWrongOrderWorksAndNoDuplicateDocs() throws IOException {

        final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(),
                                                      new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        boolean isRetry = true;
        long autoGeneratedIdTimestamp = 0;

        Engine.Index firstIndexRequest = new Engine.Index(
            newUid(doc),
            doc,
            UNASSIGNED_SEQ_NO,
            1,
            randomBoolean() ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
            VersionType.INTERNAL,
            PRIMARY,
            System.nanoTime(),
            autoGeneratedIdTimestamp,
            isRetry,
            UNASSIGNED_SEQ_NO,
            0
        );
        Engine.IndexResult result = engine.index(firstIndexRequest);
        assertThat(result.getVersion(), equalTo(1L));

        Engine.Index firstIndexRequestReplica = new Engine.Index(newUid(doc), doc, result.getSeqNo(), firstIndexRequest.primaryTerm(),
                                                                 result.getVersion(), null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
        Engine.IndexResult indexReplicaResult = replicaEngine.index(firstIndexRequestReplica);
        assertThat(indexReplicaResult.getVersion(), equalTo(1L));

        isRetry = false;
        Engine.Index secondIndexRequest = new Engine.Index(
            newUid(doc),
            doc,
            UNASSIGNED_SEQ_NO,
            1,
            Versions.MATCH_DELETED,
            VersionType.INTERNAL,
            PRIMARY,
            System.nanoTime(),
            autoGeneratedIdTimestamp,
            isRetry,
            UNASSIGNED_SEQ_NO,
            0);
        Engine.IndexResult indexResult = engine.index(secondIndexRequest);
        assertFalse(indexResult.isCreated());
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }

        Engine.Index secondIndexRequestReplica = new Engine.Index(newUid(doc), doc, result.getSeqNo(), secondIndexRequest.primaryTerm(),
                                                                  result.getVersion(), null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
        replicaEngine.index(secondIndexRequestReplica);
        replicaEngine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = replicaEngine.acquireSearcher(&quot;test&quot;)) {
            TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
            assertEquals(1, topDocs.totalHits.value);
        }
    }

    public Engine.Index randomAppendOnly(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp) {
        if (randomBoolean()) {
            return appendOnlyPrimary(doc, retry, autoGeneratedIdTimestamp);
        } else {
            return appendOnlyReplica(doc, retry, autoGeneratedIdTimestamp, 0);
        }
    }

    public Engine.Index appendOnlyPrimary(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp, boolean create) {
        return new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, create ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
            VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), autoGeneratedIdTimestamp, retry,
            UNASSIGNED_SEQ_NO, 0);
    }

    public Engine.Index appendOnlyPrimary(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp) {
        return appendOnlyPrimary(doc, retry, autoGeneratedIdTimestamp, randomBoolean());
    }

    public Engine.Index appendOnlyReplica(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp, final long seqNo) {
        return new Engine.Index(newUid(doc), doc, seqNo, 2, 1, null,
                                Engine.Operation.Origin.REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, retry, UNASSIGNED_SEQ_NO, 0);
    }


    @Test
    public void testAppendConcurrently() throws InterruptedException, IOException {
        Thread[] thread = new Thread[randomIntBetween(3, 5)];
        int numDocs = randomIntBetween(1000, 10000);
        assertEquals(0, engine.getNumVersionLookups());
        assertEquals(0, engine.getNumIndexVersionsLookups());
        boolean primary = randomBoolean();
        List&lt;Engine.Index&gt; docs = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; numDocs; i++) {
            final ParsedDocument doc = testParsedDocument(Integer.toString(i), null,
                testDocumentWithTextField(), new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
            Engine.Index index = primary ? appendOnlyPrimary(doc, false, i) : appendOnlyReplica(doc, false, i, i);
            docs.add(index);
        }
        Collections.shuffle(docs, random());
        CountDownLatch startGun = new CountDownLatch(thread.length);

        AtomicInteger offset = new AtomicInteger(-1);
        for (int i = 0; i &lt; thread.length; i++) {
            thread[i] = new Thread() {
                @Override
                public void run() {
                    startGun.countDown();
                    try {
                        startGun.await();
                    } catch (InterruptedException e) {
                        throw new AssertionError(e);
                    }
                    assertThat(engine.getVersionMap().values(), empty());
                    int docOffset;
                    while ((docOffset = offset.incrementAndGet()) &lt; docs.size()) {
                        try {
                            engine.index(docs.get(docOffset));
                        } catch (IOException e) {
                            throw new AssertionError(e);
                        }
                    }
                }
            };
            thread[i].start();
        }
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
            assertEquals(&quot;unexpected refresh&quot;, 0, searcher.getIndexReader().maxDoc());
        }
        for (int i = 0; i &lt; thread.length; i++) {
            thread[i].join();
        }

        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            int count = searcher.count(new MatchAllDocsQuery());
<A NAME="22"></A>            assertEquals(docs.size(), count);
        }
        assertEquals(0, engine.getNumVersionLookups());
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#22',2,'match306914-top.html#22',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>assertEquals(0, engine.getNumIndexVersionsLookups());
        assertThat(engine.getMaxSeenAutoIdTimestamp(),
            equalTo(docs.stream().mapToLong(Engine.Index::getAutoGeneratedIdTimestamp).max().getAsLong()));
        assertLuceneOperations(engine, numDocs, 0, 0);
    }

    public static long getNumVersionLookups(InternalEngine engine) { // for other tests to access this
        return engine.getNumVersionLookups();
    }

    public static long getNumI</B></FONT>ndexVersionsLookups(InternalEngine engine) { // for other tests to access this
        return engine.getNumIndexVersionsLookups();
    }

    @Test
    public void testFailEngineOnRandomIO() throws IOException, InterruptedException {
        MockDirectoryWrapper wrapper = newMockDirectory();
        final Path translogPath = createTempDir(&quot;testFailEngineOnRandomIO&quot;);
        try (Store store = createStore(wrapper)) {
            CyclicBarrier join = new CyclicBarrier(2);
            CountDownLatch start = new CountDownLatch(1);
            AtomicInteger controller = new AtomicInteger(0);
            EngineConfig config = config(defaultSettings, store, translogPath, newMergePolicy(), new ReferenceManager.RefreshListener() {
                    @Override
                    public void beforeRefresh() throws IOException {
                    }

                    @Override
                    public void afterRefresh(boolean didRefresh) throws IOException {
                        int i = controller.incrementAndGet();
                        if (i == 1) {
                            throw new MockDirectoryWrapper.FakeIOException();
                        } else if (i == 2) {
                            try {
                                start.await();
                            } catch (InterruptedException e) {
                                throw new AssertionError(e);
                            }
                            throw new ElasticsearchException(&quot;something completely different&quot;);
                        }
                    }
                });
            InternalEngine internalEngine = createEngine(config);
            int docId = 0;
            final ParsedDocument doc = testParsedDocument(Integer.toString(docId), null,
                                                          testDocumentWithTextField(), new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);

            Engine.Index index = randomBoolean() ? indexForDoc(doc) : randomAppendOnly(doc, false, docId);
            internalEngine.index(index);
            Runnable r = () -&gt;  {
                try {
                    join.await();
                } catch (Exception e) {
                    throw new AssertionError(e);
                }
                try {
                    internalEngine.refresh(&quot;test&quot;);
                    fail();
                } catch (AlreadyClosedException ex) {
                    if (ex.getCause() != null) {
                        assertTrue(ex.toString(), ex.getCause() instanceof MockDirectoryWrapper.FakeIOException);
                    }
                } catch (RefreshFailedEngineException ex) {
                    // fine
                } finally {
                    start.countDown();
                }

            };
            Thread t = new Thread(r);
            Thread t1 = new Thread(r);
            t.start();
            t1.start();
            t.join();
            t1.join();
            assertTrue(internalEngine.isClosed.get());
            assertTrue(internalEngine.failedEngine.get() instanceof MockDirectoryWrapper.FakeIOException);
        }
    }
<A NAME="58"></A>
    @Test
    public void testSequenceIDs() throws Exception {
        Tuple&lt;Long, Long&gt; seqID = <FONT color="#f63526"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#58',2,'match306914-top.html#58',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>getSequenceID(engine, new Engine.Get(&quot;type&quot;, newUid(&quot;1&quot;)));
        // Non-existent doc returns no seqnum and no primary term
        assertThat(seqID.v1(), equalTo(UNASSIGNED_SEQ_NO));
        assertThat(seqID.v2(), equalTo(0L));

        // create a document
        Document document = testDocumentWithTextField();
        document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes</B></FONT>(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
<A NAME="54"></A>        engine.index(indexForDoc(doc));
        engine.refresh(&quot;test&quot;);

        <FONT color="#4e8975"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#54',2,'match306914-top.html#54',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>seqID = getSequenceID(engine, newGet(doc));
        logger.info(&quot;--&gt; got seqID: {}&quot;, seqID);
        assertThat(seqID.v1(), equalTo(0L));
        assertThat(seqID.v2(), equalTo(primaryTerm.get()));

        // Index the same document again
        document = testDocumentWithTextField();
        document.add</B></FONT>(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
        doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        engine.index(indexForDoc(doc));
        engine.refresh(&quot;test&quot;);

        seqID = getSequenceID(engine, newGet(doc));
        logger.info(&quot;--&gt; got seqID: {}&quot;, seqID);
        assertThat(seqID.v1(), equalTo(1L));
        assertThat(seqID.v2(), equalTo(primaryTerm.get()));

        // Index the same document for the third time, this time changing the primary term
        document = testDocumentWithTextField();
        document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
        doc = testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        engine.index(new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 3,
                                      Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY,
                                      System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));
        engine.refresh(&quot;test&quot;);

        seqID = getSequenceID(engine, newGet(doc));
        logger.info(&quot;--&gt; got seqID: {}&quot;, seqID);
        assertThat(seqID.v1(), equalTo(2L));
<A NAME="55"></A>        assertThat(seqID.v2(), equalTo(3L));

        // we can query by the _seq_no
        Engine.Searcher searchResult = <FONT color="#4863a0"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#55',2,'match306914-top.html#55',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.acquireSearcher(&quot;test&quot;);
        MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
        MatcherAssert.assertThat(searchResult,
                                 EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(LongPoint.newExactQuery(&quot;_seq_no&quot;, 2), 1));
        searchResult.close();
    }

    @Test
    public void testLookupSeqNoByIdInLucene() throws Exception {
        int numOps = between</B></FONT>(10, 100);
        long seqNo = 0;
        List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;(numOps);
        for (int i = 0; i &lt; numOps; i++) {
            String id = Integer.toString(between(1, 50));
            boolean isIndexing = randomBoolean();
            int copies = frequently() ? 1 : between(2, 4);
            for (int c = 0; c &lt; copies; c++) {
                final ParsedDocument doc = EngineTestCase.createParsedDoc(id, null);
                if (isIndexing) {
                    operations.add(new Engine.Index(EngineTestCase.newUid(doc), doc, seqNo, primaryTerm.get(),
                                                    i, null, Engine.Operation.Origin.REPLICA, threadPool.relativeTimeInMillis(), -1, true,  UNASSIGNED_SEQ_NO, 0L));
                } else {
                    operations.add(new Engine.Delete(
                        doc.id(),
                        EngineTestCase.newUid(doc),
                        seqNo,
                        primaryTerm.get(),
                        i,
                        null,
                        Engine.Operation.Origin.REPLICA,
                        threadPool.relativeTimeInMillis(),
                        UNASSIGNED_SEQ_NO,
                        0L
                    ));
                }
            }
            seqNo++;
            if (rarely()) {
                seqNo++;
            }
        }
        Randomness.shuffle(operations);
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        Map&lt;String, Engine.Operation&gt; latestOps = new HashMap&lt;&gt;(); // id -&gt; latest seq_no
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null))) {
            CheckedRunnable&lt;IOException&gt; lookupAndCheck = () -&gt; {
                try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
                    Map&lt;String, Long&gt; liveOps = latestOps.entrySet().stream()
                        .filter(e -&gt; e.getValue().operationType() == Engine.Operation.TYPE.INDEX)
                        .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue().seqNo()));
                    assertThat(getDocIds(engine, true).stream().collect(Collectors.toMap(e -&gt; e.getId(), e -&gt; e.getSeqNo())),
                               equalTo(liveOps));
                    for (String id : latestOps.keySet()) {
                        String msg = &quot;latestOps=&quot; + latestOps + &quot; op=&quot; + id;
                        DocIdAndSeqNo docIdAndSeqNo = VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), newUid(id));
                        if (liveOps.containsKey(id) == false) {
                            assertNull(msg, docIdAndSeqNo);
                        } else {
                            assertNotNull(msg, docIdAndSeqNo);
                            assertThat(msg, docIdAndSeqNo.seqNo, equalTo(latestOps.get(id).seqNo()));
                        }
                    }
                    String notFoundId = randomValueOtherThanMany(liveOps::containsKey, () -&gt; Long.toString(randomNonNegativeLong()));
                    assertNull(VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), newUid(notFoundId)));
                }
            };
            for (Engine.Operation op : operations) {
                if (op instanceof Engine.Index) {
                    engine.index((Engine.Index) op);
                    if (latestOps.containsKey(op.id()) == false || latestOps.get(op.id()).seqNo() &lt; op.seqNo()) {
                        latestOps.put(op.id(), op);
                    }
                } else if (op instanceof Engine.Delete) {
                    engine.delete((Engine.Delete) op);
                    if (latestOps.containsKey(op.id()) == false || latestOps.get(op.id()).seqNo() &lt; op.seqNo()) {
                        latestOps.put(op.id(), op);
                    }
                }
                if (randomInt(100) &lt; 10) {
                    engine.refresh(&quot;test&quot;);
                    lookupAndCheck.run();
                }
                if (rarely()) {
                    engine.flush(false, true);
                    lookupAndCheck.run();
                }
            }
            engine.refresh(&quot;test&quot;);
            lookupAndCheck.run();
        }
    }

    /**
     * A sequence number generator that will generate a sequence number and if {@code stall} is set to true will wait on the barrier and the
     * referenced latch before returning. If the local checkpoint should advance (because {@code stall} is false, then the value of
     * {@code expectedLocalCheckpoint} is set accordingly.
     *
     * @param latchReference          to latch the thread for the purpose of stalling
     * @param barrier                 to signal the thread has generated a new sequence number
     * @param stall                   whether or not the thread should stall
     * @param expectedLocalCheckpoint the expected local checkpoint after generating a new sequence
     *                                number
     * @return a sequence number generator
     */
    private ToLongBiFunction&lt;Engine, Engine.Operation&gt; getStallingSeqNoGenerator(
        final AtomicReference&lt;CountDownLatch&gt; latchReference,
        final CyclicBarrier barrier,
        final AtomicBoolean stall,
        final AtomicLong expectedLocalCheckpoint) {
        return (engine, operation) -&gt; {
            final long seqNo = generateNewSeqNo(engine);
            final CountDownLatch latch = latchReference.get();
            if (stall.get()) {
                try {
                    barrier.await();
                    latch.await();
                } catch (BrokenBarrierException | InterruptedException e) {
                    throw new RuntimeException(e);
                }
            } else {
                if (expectedLocalCheckpoint.get() + 1 == seqNo) {
                    expectedLocalCheckpoint.set(seqNo);
                }
            }
            return seqNo;
        };
    }

    @Test
    public void testSequenceNumberAdvancesToMaxSeqOnEngineOpenOnPrimary() throws BrokenBarrierException, InterruptedException, IOException {
        engine.close();
        final int docs = randomIntBetween(1, 32);
        InternalEngine initialEngine = null;
        try {
            final AtomicReference&lt;CountDownLatch&gt; latchReference = new AtomicReference&lt;&gt;(new CountDownLatch(1));
            final CyclicBarrier barrier = new CyclicBarrier(2);
            final AtomicBoolean stall = new AtomicBoolean();
            final AtomicLong expectedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
            final List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
            initialEngine =
                createEngine(defaultSettings, store, primaryTranslogDir,
                             newMergePolicy(), null, LocalCheckpointTracker::new, null,
                             getStallingSeqNoGenerator(latchReference, barrier, stall, expectedLocalCheckpoint));
            final InternalEngine finalInitialEngine = initialEngine;
            for (int i = 0; i &lt; docs; i++) {
                final String id = Integer.toString(i);
                final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);

                stall.set(randomBoolean());
                final Thread thread = new Thread(() -&gt; {
                    try {
                        finalInitialEngine.index(indexForDoc(doc));
                    } catch (IOException e) {
                        throw new AssertionError(e);
                    }
                });
                thread.start();
                if (stall.get()) {
                    threads.add(thread);
                    barrier.await();
                } else {
                    thread.join();
                }
            }

            assertThat(initialEngine.getProcessedLocalCheckpoint(), equalTo(expectedLocalCheckpoint.get()));
            assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo((long) (docs - 1)));
            initialEngine.flush(true, true);
            assertEquals(initialEngine.getProcessedLocalCheckpoint(), initialEngine.getPersistedLocalCheckpoint());

            latchReference.get().countDown();
            for (final Thread thread : threads) {
                thread.join();
            }
        } finally {
            IOUtils.close(initialEngine);
        }
        try (var recoveringEngine = new InternalEngine(initialEngine.config())) {
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            recoveringEngine.fillSeqNoGaps(2);
            assertEquals(recoveringEngine.getProcessedLocalCheckpoint(), recoveringEngine.getPersistedLocalCheckpoint());
            assertThat(recoveringEngine.getProcessedLocalCheckpoint(), greaterThanOrEqualTo((long) (docs - 1)));
        }
    }

    @Test
    public void testOutOfOrderSequenceNumbersWithVersionConflict() throws IOException {
        final List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;();

        final int numberOfOperations = randomIntBetween(16, 32);
        final AtomicLong sequenceNumber = new AtomicLong();
        final Engine.Operation.Origin origin = randomFrom(LOCAL_TRANSLOG_RECOVERY, PEER_RECOVERY, PRIMARY, REPLICA);
        final LongSupplier sequenceNumberSupplier =
            origin == PRIMARY ? () -&gt; UNASSIGNED_SEQ_NO : sequenceNumber::getAndIncrement;
        final Supplier&lt;ParsedDocument&gt; doc = () -&gt; {
            final Document document = testDocumentWithTextField();
            document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
            return testParsedDocument(&quot;1&quot;, null, document, B_1, null);
        };
        final Term uid = newUid(&quot;1&quot;);
        final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
        for (int i = 0; i &lt; numberOfOperations; i++) {
            if (randomBoolean()) {
                final Engine.Index index = new Engine.Index(
                    uid,
                    doc.get(),
                    sequenceNumberSupplier.getAsLong(),
                    1,
                    i,
                    origin == PRIMARY ? VersionType.EXTERNAL : null,
                    origin,
                    System.nanoTime(),
                    Translog.UNSET_AUTO_GENERATED_TIMESTAMP,
                    false, UNASSIGNED_SEQ_NO, 0);
                operations.add(index);
            } else {
                final Engine.Delete delete = new Engine.Delete(
                    &quot;1&quot;,
                    uid,
                    sequenceNumberSupplier.getAsLong(),
                    1,
                    i,
                    origin == PRIMARY ? VersionType.EXTERNAL : null,
                    origin,
                    System.nanoTime(), UNASSIGNED_SEQ_NO, 0);
                operations.add(delete);
            }
        }

        final boolean exists = operations.get(operations.size() - 1) instanceof Engine.Index;
        Randomness.shuffle(operations);

        for (final Engine.Operation operation : operations) {
            if (operation instanceof Engine.Index) {
                engine.index((Engine.Index) operation);
            } else {
                engine.delete((Engine.Delete) operation);
            }
        }

        final long expectedLocalCheckpoint;
        if (origin == PRIMARY) {
            // we can only advance as far as the number of operations that did not conflict
            int count = 0;

            // each time the version increments as we walk the list, that counts as a successful operation
            long version = -1;
            for (int i = 0; i &lt; numberOfOperations; i++) {
                if (operations.get(i).version() &gt;= version) {
                    count++;
                    version = operations.get(i).version();
                }
            }

            // sequence numbers start at zero, so the expected local checkpoint is the number of successful operations minus one
            expectedLocalCheckpoint = count - 1;
        } else {
            expectedLocalCheckpoint = numberOfOperations - 1;
        }

        assertThat(engine.getProcessedLocalCheckpoint(), equalTo(expectedLocalCheckpoint));
        try (Engine.GetResult result = engine.get(new Engine.Get(&quot;2&quot;, uid), searcherFactory)) {
            assertThat(result.docIdAndVersion() != null, equalTo(exists));
        }
    }

    /**
     * Test that we do not leak out information on a deleted doc due to it existing in version map. There are at least 2 cases:
     * &lt;ul&gt;
     *     &lt;li&gt;Guessing the deleted seqNo makes the operation succeed&lt;/li&gt;
     *     &lt;li&gt;Providing any other seqNo leaks info that the doc was deleted (and its SeqNo)&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public void testVersionConflictIgnoreDeletedDoc() throws IOException {
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocument(),
            new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        engine.delete(new Engine.Delete(&quot;1&quot;, newUid(&quot;1&quot;), 1));
        for (long seqNo : new long[]{0, 1, randomNonNegativeLong()}) {
            assertDeletedVersionConflict(engine.index(new Engine.Index(newUid(&quot;1&quot;), doc, UNASSIGNED_SEQ_NO, 1,
                    Versions.MATCH_ANY, VersionType.INTERNAL,
                    PRIMARY, randomNonNegativeLong(), UNSET_AUTO_GENERATED_TIMESTAMP, false, seqNo, 1)),
                &quot;update: &quot; + seqNo);

            assertDeletedVersionConflict(engine.delete(new Engine.Delete(&quot;1&quot;, newUid(&quot;1&quot;), UNASSIGNED_SEQ_NO, 1,
                    Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, randomNonNegativeLong(), seqNo, 1)),
                &quot;delete: &quot; + seqNo);
        }
    }

    private void assertDeletedVersionConflict(Engine.Result result, String operation) {
        assertNotNull(&quot;Must have failure for &quot; + operation, result.getFailure());
        assertThat(operation, result.getFailure(), Matchers.instanceOf(VersionConflictEngineException.class));
        VersionConflictEngineException exception = (VersionConflictEngineException) result.getFailure();
        assertThat(operation, exception.getMessage(), containsString(&quot;but no document was found&quot;));
    }

    /*
     * This test tests that a no-op does not generate a new sequence number, that no-ops can advance the local checkpoint, and that no-ops
     * are correctly added to the translog.
     */
    @Test
    public void testNoOps() throws IOException {
        engine.close();
        InternalEngine noOpEngine = null;
        final int maxSeqNo = randomIntBetween(0, 128);
        final int localCheckpoint = randomIntBetween(0, maxSeqNo);
        try {
            final BiFunction&lt;Long, Long, LocalCheckpointTracker&gt; supplier = (ms, lcp) -&gt; new LocalCheckpointTracker(
                maxSeqNo,
                localCheckpoint);
            EngineConfig noopEngineConfig = copy(engine.config(), new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD,
                                                                                                      () -&gt; new MatchAllDocsQuery(), engine.config().getMergePolicy()));
            noOpEngine = new InternalEngine(noopEngineConfig, supplier) {
                @Override
                protected long doGenerateSeqNoForOperation(Operation operation) {
                    throw new UnsupportedOperationException();
                }
            };
<A NAME="41"></A>            noOpEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            final int gapsFilled = noOpEngine.fillSeqNoGaps(primaryTerm.get());
            final String reason = &quot;filling gaps&quot;;
            noOpEngine.noOp(new Engine.NoOp(maxSeqNo + 1, <FONT color="#f87a17"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#41',2,'match306914-top.html#41',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>primaryTerm.get(), LOCAL_TRANSLOG_RECOVERY, System.nanoTime(), reason));
            assertThat(noOpEngine.getProcessedLocalCheckpoint(), equalTo((long) (maxSeqNo + 1)));
            assertThat(noOpEngine.getTranslog().stats().getUncommittedOperations(), equalTo(gapsFilled));
            noOpEngine.noOp(
                new Engine.NoOp(maxSeqNo + 2, primaryTerm.get(),
                    randomFrom(PRIMARY, REPLICA, PEER_RECOVERY), System.nanoTime(), reason));
            assertThat(noOpEngine.getProcessedLocalCheckpoint</B></FONT>(), equalTo((long) (maxSeqNo + 2)));
            assertThat(noOpEngine.getTranslog().stats().getUncommittedOperations(), equalTo(gapsFilled + 1));
            // skip to the op that we added to the translog
            Translog.Operation op;
            Translog.Operation last = null;
            try (Translog.Snapshot snapshot = noOpEngine.getTranslog().newSnapshot()) {
                while ((op = snapshot.next()) != null) {
                    last = op;
                }
            }
            assertNotNull(last);
            assertThat(last, instanceOf(Translog.NoOp.class));
            final Translog.NoOp noOp = (Translog.NoOp) last;
            assertThat(noOp.seqNo(), equalTo((long) (maxSeqNo + 2)));
            assertThat(noOp.primaryTerm(), equalTo(primaryTerm.get()));
            assertThat(noOp.reason(), equalTo(reason));
            if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
                MapperService mapperService = createMapperService(&quot;test&quot;);
                List&lt;Translog.Operation&gt; operationsFromLucene = readAllOperationsInLucene(noOpEngine, mapperService);
                assertThat(operationsFromLucene, hasSize(maxSeqNo + 2 - localCheckpoint)); // fills n gap and 2 manual noop.
                for (int i = 0; i &lt; operationsFromLucene.size(); i++) {
                    assertThat(operationsFromLucene.get(i),
                               equalTo(new Translog.NoOp(localCheckpoint + 1 + i, primaryTerm.get(), &quot;filling gaps&quot;)));
                }
                assertConsistentHistoryBetweenTranslogAndLuceneIndex(noOpEngine, mapperService);
            }
        } finally {
            IOUtils.close(noOpEngine);
        }
    }

    /**
     * Verifies that a segment containing only no-ops can be used to look up _version and _seqno.
     */
    @Test
    public void testSegmentContainsOnlyNoOps() throws Exception {
        Engine.NoOpResult noOpResult = engine.noOp(new Engine.NoOp(1, primaryTerm.get(),
<A NAME="51"></A>                                                                   randomFrom(Engine.Operation.Origin.values()), randomNonNegativeLong(), &quot;test&quot;));
        assertThat(noOpResult.getFailure(), nullValue());
        engine.refresh(&quot;test&quot;);
        <FONT color="#b38481"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#51',2,'match306914-top.html#51',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>Engine.DeleteResult deleteResult = engine.delete(replicaDeleteForDoc(&quot;id&quot;, 1, 2, randomNonNegativeLong()));
        assertThat(deleteResult.getFailure(), nullValue());
        engine.refresh(&quot;test&quot;);
    }

    /**
     * A simple test to check that random combination of operations can coexist in segments and be lookup.
     * This is needed as some fields in Lucene may not exist if a segment misses operation types and this code is to check for that.
     * For example, a segment containing only no-ops does not have neither _uid or _version.
     */
    @Test
    public void testRandomOperations() throws Exception {
        int numOps = between(10, 100)</B></FONT>;
        for (int i = 0; i &lt; numOps; i++) {
            String id = Integer.toString(randomIntBetween(1, 10));
            ParsedDocument doc = createParsedDoc(id, null);
            Engine.Operation.TYPE type = randomFrom(Engine.Operation.TYPE.values());
            switch (type) {
                case INDEX:
                    Engine.IndexResult index = engine.index(replicaIndexForDoc(doc, between(1, 100), i, randomBoolean()));
                    assertThat(index.getFailure(), nullValue());
                    break;
                case DELETE:
                    Engine.DeleteResult delete = engine.delete(replicaDeleteForDoc(doc.id(), between(1, 100), i, randomNonNegativeLong()));
                    assertThat(delete.getFailure(), nullValue());
                    break;
                case NO_OP:
                    Engine.NoOpResult noOp = engine.noOp(new Engine.NoOp(i, primaryTerm.get(),
                                                                         randomFrom(Engine.Operation.Origin.values()), randomNonNegativeLong(), &quot;&quot;));
                    assertThat(noOp.getFailure(), nullValue());
                    break;
                default:
                    throw new IllegalStateException(&quot;Invalid op [&quot; + type + &quot;]&quot;);
            }
            if (randomBoolean()) {
                engine.refresh(&quot;test&quot;);
            }
            if (randomBoolean()) {
                engine.flush();
            }
            if (randomBoolean()) {
                engine.forceMerge(randomBoolean(), between(1, 10), randomBoolean(), false, false, UUIDs.randomBase64UUID());
            }
        }
        if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
            List&lt;Translog.Operation&gt; operations = readAllOperationsInLucene(engine, createMapperService(&quot;test&quot;));
            assertThat(operations, hasSize(numOps));
        }
    }

    @Test
    public void testMinGenerationForSeqNo() throws IOException, BrokenBarrierException, InterruptedException {
        engine.close();
        final int numberOfTriplets = randomIntBetween(1, 32);
        InternalEngine actualEngine = null;
        try {
            final AtomicReference&lt;CountDownLatch&gt; latchReference = new AtomicReference&lt;&gt;();
            final CyclicBarrier barrier = new CyclicBarrier(2);
            final AtomicBoolean stall = new AtomicBoolean();
            final AtomicLong expectedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
            final Map&lt;Thread, CountDownLatch&gt; threads = new LinkedHashMap&lt;&gt;();
            actualEngine =
                createEngine(defaultSettings, store, primaryTranslogDir,
                             newMergePolicy(), null, LocalCheckpointTracker::new, null,
                             getStallingSeqNoGenerator(latchReference, barrier, stall, expectedLocalCheckpoint));
            final InternalEngine finalActualEngine = actualEngine;
            final Translog translog = finalActualEngine.getTranslog();
            final long generation = finalActualEngine.getTranslog().currentFileGeneration();
            for (int i = 0; i &lt; numberOfTriplets; i++) {
                /*
                 * Index three documents with the first and last landing in the same generation and the middle document being stalled until
                 * a later generation.
                 */
                stall.set(false);
                index(finalActualEngine, 3 * i);

                final CountDownLatch latch = new CountDownLatch(1);
                latchReference.set(latch);
                final int skipId = 3 * i + 1;
                stall.set(true);
                final Thread thread = new Thread(() -&gt; {
                    try {
                        index(finalActualEngine, skipId);
                    } catch (IOException e) {
                        throw new AssertionError(e);
                    }
                });
                thread.start();
                threads.put(thread, latch);
                barrier.await();

                stall.set(false);
                index(finalActualEngine, 3 * i + 2);
                finalActualEngine.flush();

                /*
                 * This sequence number landed in the last generation, but the lower and upper bounds for an earlier generation straddle
                 * this sequence number.
                 */
                assertThat(translog.getMinGenerationForSeqNo(3 * i + 1).translogFileGeneration, equalTo(i + generation));
            }

            int i = 0;
            for (final Map.Entry&lt;Thread, CountDownLatch&gt; entry : threads.entrySet()) {
                final Map&lt;String, String&gt; userData = finalActualEngine.commitStats().getUserData();
                assertThat(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY), equalTo(Long.toString(3 * i)));
                entry.getValue().countDown();
                entry.getKey().join();
                finalActualEngine.flush();
                i++;
            }

        } finally {
            IOUtils.close(actualEngine);
        }
    }

    private void index(final InternalEngine engine, final int id) throws IOException {
        final String docId = Integer.toString(id);
        final ParsedDocument doc =
            testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
        engine.index(indexForDoc(doc));
    }

    /**
     * Return a tuple representing the sequence ID for the given {@code Get}
     * operation. The first value in the tuple is the sequence number, the
     * second is the primary term.
     */
    private Tuple&lt;Long, Long&gt; getSequenceID(Engine engine, Engine.Get get) throws EngineException {
        try (Searcher searcher = engine.acquireSearcher(&quot;get&quot;, Engine.SearcherScope.INTERNAL)) {
            final long primaryTerm;
            final long seqNo;
            DocIdAndSeqNo docIdAndSeqNo = VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), get.uid());
            if (docIdAndSeqNo == null) {
                primaryTerm = 0;
                seqNo = UNASSIGNED_SEQ_NO;
            } else {
                seqNo = docIdAndSeqNo.seqNo;
                NumericDocValues primaryTerms = docIdAndSeqNo.context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);
                if (primaryTerms == null || primaryTerms.advanceExact(docIdAndSeqNo.docId) == false) {
                    throw new AssertionError(&quot;document does not have primary term [&quot; + docIdAndSeqNo.docId + &quot;]&quot;);
                }
                primaryTerm = primaryTerms.longValue();
            }
            return new Tuple&lt;&gt;(seqNo, primaryTerm);
        } catch (Exception e) {
            throw new EngineException(shardId, &quot;unable to retrieve sequence id&quot;, e);
        }
    }

    @Test
    public void testRestoreLocalHistoryFromTranslog() throws IOException {
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (Store store = createStore()) {
            final ArrayList&lt;Long&gt; seqNos = new ArrayList&lt;&gt;();
            final int numOps = randomIntBetween(0, 1024);
            for (int i = 0; i &lt; numOps; i++) {
                if (rarely()) {
                    continue;
                }
                seqNos.add((long) i);
            }
            Randomness.shuffle(seqNos);
            final EngineConfig engineConfig;
            final SeqNoStats prevSeqNoStats;
            final List&lt;DocIdSeqNoAndSource&gt; prevDocs;
            try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
                engineConfig = engine.config();
                for (final long seqNo : seqNos) {
                    final String id = Long.toString(seqNo);
                    final ParsedDocument doc = testParsedDocument(id, null,
                                                                  testDocumentWithTextField(), SOURCE, null);
                    engine.index(replicaIndexForDoc(doc, 1, seqNo, false));
                    if (rarely()) {
                        engine.rollTranslogGeneration();
                    }
                    if (rarely()) {
                        engine.flush();
                    }
                }
                globalCheckpoint.set(randomLongBetween(SequenceNumbers.NO_OPS_PERFORMED, engine.getPersistedLocalCheckpoint()));
                engine.syncTranslog();
                prevSeqNoStats = engine.getSeqNoStats(globalCheckpoint.get());
                prevDocs = getDocIds(engine, true);
<A NAME="20"></A>            }
            try (InternalEngine engine = new InternalEngine(engineConfig)) {
                final long currentTranslogGeneration = engine.getTranslog().currentFileGeneration();
                engine.recoverFromTranslog(translogHandler, <FONT color="#4e9258"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#20',2,'match306914-top.html#20',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>globalCheckpoint.get());
                engine.restoreLocalHistoryFromTranslog(translogHandler);
                assertThat(getDocIds(engine, true), equalTo(prevDocs));
                SeqNoStats seqNoStats = engine.getSeqNoStats(globalCheckpoint.get());
                assertThat(seqNoStats.getLocalCheckpoint(), equalTo(prevSeqNoStats.getLocalCheckpoint()));
                assertThat(seqNoStats.getMaxSeqNo(), equalTo(prevSeqNoStats.getMaxSeqNo()));
                assertThat(&quot;restore from local translog must not add operations to translog&quot;,
                           engine.getTranslog().totalOperationsByMinGen(currentTranslogGeneration), equalTo</B></FONT>(0));
            }
            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, createMapperService(&quot;test&quot;));
        }
    }

    @Test
    public void testFillUpSequenceIdGapsOnRecovery() throws IOException {
        final int docs = randomIntBetween(1, 32);
        int numDocsOnReplica = 0;
        long maxSeqIDOnReplica = -1;
        long checkpointOnReplica;
        try {
            for (int i = 0; i &lt; docs; i++) {
                final String docId = Integer.toString(i);
                final ParsedDocument doc =
                    testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
                Engine.Index primaryResponse = indexForDoc(doc);
                Engine.IndexResult indexResult = engine.index(primaryResponse);
                if (randomBoolean()) {
                    numDocsOnReplica++;
                    maxSeqIDOnReplica = indexResult.getSeqNo();
                    replicaEngine.index(replicaIndexForDoc(doc, 1, indexResult.getSeqNo(), false));
                }
            }
            engine.syncTranslog(); // to advance local checkpoint
            replicaEngine.syncTranslog(); // to advance local checkpoint
            checkpointOnReplica = replicaEngine.getProcessedLocalCheckpoint();
        } finally {
            IOUtils.close(replicaEngine);
        }

        boolean flushed = false;
        AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        InternalEngine recoveringEngine = null;
        try {
            assertEquals(docs - 1, engine.getSeqNoStats(-1).getMaxSeqNo());
<A NAME="48"></A>            assertEquals(docs - 1, engine.getProcessedLocalCheckpoint());
            assertEquals(maxSeqIDOnReplica, replicaEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertEquals(checkpointOnReplica, replicaEngine.getProcessedLocalCheckpoint());
            recoveringEngine = <FONT color="#c57726"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#48',2,'match306914-top.html#48',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>new InternalEngine(copy(replicaEngine.config(), globalCheckpoint::get));
            assertEquals(numDocsOnReplica, getTranslog(recoveringEngine).stats().getUncommittedOperations());
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertEquals(checkpointOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
            assertEquals((maxSeqIDOnReplica + 1) - numDocsOnReplica, recoveringEngine.fillSeqNoGaps</B></FONT>(2));

            // now snapshot the tlog and ensure the primary term is updated
            try (Translog.Snapshot snapshot = getTranslog(recoveringEngine).newSnapshot()) {
                assertTrue((maxSeqIDOnReplica + 1) - numDocsOnReplica &lt;= snapshot.totalOperations());
                Translog.Operation operation;
                while ((operation = snapshot.next()) != null) {
                    if (operation.opType() == Translog.Operation.Type.NO_OP) {
                        assertEquals(2, operation.primaryTerm());
                    } else {
                        assertEquals(primaryTerm.get(), operation.primaryTerm());
                    }

                }
                assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
                assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
                if ((flushed = randomBoolean())) {
                    globalCheckpoint.set(recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
                    getTranslog(recoveringEngine).sync();
                    recoveringEngine.flush(true, true);
                }
            }
        } finally {
            IOUtils.close(recoveringEngine);
        }

        // now do it again to make sure we preserve values etc.
        try {
            recoveringEngine = new InternalEngine(copy(replicaEngine.config(), globalCheckpoint::get));
            if (flushed) {
                assertThat(recoveringEngine.getTranslogStats().getUncommittedOperations(), equalTo(0));
            }
            recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
            assertEquals(0, recoveringEngine.fillSeqNoGaps(3));
            assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
            assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
        } finally {
            IOUtils.close(recoveringEngine);
        }
    }

    public void assertSameReader(Searcher left, Searcher right) {
        List&lt;LeafReaderContext&gt; leftLeaves = ElasticsearchDirectoryReader.unwrap(left.getDirectoryReader()).leaves();
        List&lt;LeafReaderContext&gt; rightLeaves = ElasticsearchDirectoryReader.unwrap(right.getDirectoryReader()).leaves();
        assertEquals(rightLeaves.size(), leftLeaves.size());
        for (int i = 0; i &lt; leftLeaves.size(); i++) {
            assertSame(leftLeaves.get(i).reader(), rightLeaves.get(i).reader());
        }
    }

    public void assertNotSameReader(Searcher left, Searcher right) {
        List&lt;LeafReaderContext&gt; leftLeaves = ElasticsearchDirectoryReader.unwrap(left.getDirectoryReader()).leaves();
        List&lt;LeafReaderContext&gt; rightLeaves = ElasticsearchDirectoryReader.unwrap(right.getDirectoryReader()).leaves();
        if (rightLeaves.size() == leftLeaves.size()) {
            for (int i = 0; i &lt; leftLeaves.size(); i++) {
                if (leftLeaves.get(i).reader() != rightLeaves.get(i).reader()) {
                    return; // all is well
                }
            }
            fail(&quot;readers are same&quot;);
        }
    }

    @Test
    public void testRefreshScopedSearcher() throws IOException {
        try (Store store = createStore();
             InternalEngine engine =
                 // disable merges to make sure that the reader doesn't change unexpectedly during the test
                 createEngine(defaultSettings, store, createTempDir(), NoMergePolicy.INSTANCE)) {

            engine.refresh(&quot;warm_up&quot;);
            try (Searcher getSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL);
                 Searcher searchSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                assertSameReader(getSearcher, searchSearcher);
            }
            for (int i = 0; i &lt; 10; i++) {
                final String docId = Integer.toString(i);
                final ParsedDocument doc =
                    testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
                Engine.Index primaryResponse = indexForDoc(doc);
                engine.index(primaryResponse);
            }
            assertTrue(engine.refreshNeeded());
            engine.refresh(&quot;test&quot;, Engine.SearcherScope.INTERNAL, true);
            try (Searcher getSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL);
                 Searcher searchSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                assertEquals(10, getSearcher.getIndexReader().numDocs());
                assertEquals(0, searchSearcher.getIndexReader().numDocs());
                assertNotSameReader(getSearcher, searchSearcher);
            }
            engine.refresh(&quot;test&quot;, Engine.SearcherScope.EXTERNAL, true);

            try (Searcher getSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL);
                 Searcher searchSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                assertEquals(10, getSearcher.getIndexReader().numDocs());
                assertEquals(10, searchSearcher.getIndexReader().numDocs());
                assertSameReader(getSearcher, searchSearcher);
            }

            // now ensure external refreshes are reflected on the internal reader
            final String docId = Integer.toString(10);
            final ParsedDocument doc =
                testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
            Engine.Index primaryResponse = indexForDoc(doc);
            engine.index(primaryResponse);

            engine.refresh(&quot;test&quot;, Engine.SearcherScope.EXTERNAL, true);

            try (Searcher getSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL);
                 Searcher searchSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                assertEquals(11, getSearcher.getIndexReader().numDocs());
                assertEquals(11, searchSearcher.getIndexReader().numDocs());
                assertSameReader(getSearcher, searchSearcher);
            }

            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
                engine.refresh(&quot;test&quot;, Engine.SearcherScope.INTERNAL, true);
                try (Searcher nextSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
                    assertSame(searcher.getIndexReader(), nextSearcher.getIndexReader());
                }
            }

            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                engine.refresh(&quot;test&quot;, Engine.SearcherScope.EXTERNAL, true);
                try (Searcher nextSearcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.EXTERNAL)) {
                    assertSame(searcher.getIndexReader(), nextSearcher.getIndexReader());
                }
            }
        }
    }

    @Test
    public void testSeqNoGenerator() throws IOException {
        engine.close();
        final long seqNo = randomIntBetween(Math.toIntExact(SequenceNumbers.NO_OPS_PERFORMED), Integer.MAX_VALUE);
        final BiFunction&lt;Long, Long, LocalCheckpointTracker&gt; localCheckpointTrackerSupplier = (ms, lcp) -&gt; new LocalCheckpointTracker(
            SequenceNumbers.NO_OPS_PERFORMED,
            SequenceNumbers.NO_OPS_PERFORMED);
        final AtomicLong seqNoGenerator = new AtomicLong(seqNo);
        try (Engine e = createEngine(defaultSettings, store, primaryTranslogDir,
                                     newMergePolicy(), null, localCheckpointTrackerSupplier,
                                     null, (engine, operation) -&gt; seqNoGenerator.getAndIncrement())) {
            final String id = &quot;id&quot;;
            final Field uidField = new Field(&quot;_id&quot;, id, IdFieldMapper.Defaults.FIELD_TYPE);
            final Field versionField = new NumericDocValuesField(&quot;_version&quot;, 0);
            final SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID();
            final ParseContext.Document document = new ParseContext.Document();
            document.add(uidField);
            document.add(versionField);
            document.add(seqID.seqNo);
            document.add(seqID.seqNoDocValue);
            document.add(seqID.primaryTerm);
            final BytesReference source = new BytesArray(new byte[]{1});
            final ParsedDocument parsedDocument = new ParsedDocument(
                versionField,
                seqID,
                id,
                &quot;routing&quot;,
                Collections.singletonList(document),
                source,
                null);

            final Engine.Index index = new Engine.Index(
                new Term(&quot;_id&quot;, parsedDocument.id()),
                parsedDocument,
                UNASSIGNED_SEQ_NO,
                randomIntBetween(1, 8),
                Versions.NOT_FOUND,
                VersionType.INTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime(),
                -1,
                randomBoolean(),
                UNASSIGNED_SEQ_NO,
                0);
            final Engine.IndexResult indexResult = e.index(index);
            assertThat(indexResult.getSeqNo(), equalTo(seqNo));
            assertThat(seqNoGenerator.get(), equalTo(seqNo + 1));

            final Engine.Delete delete = new Engine.Delete(
                id,
                new Term(&quot;_id&quot;, parsedDocument.id()),
                UNASSIGNED_SEQ_NO,
                randomIntBetween(1, 8),
                Versions.MATCH_ANY,
                VersionType.INTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime(),
                UNASSIGNED_SEQ_NO,
                0);
            final Engine.DeleteResult deleteResult = e.delete(delete);
            assertThat(deleteResult.getSeqNo(), equalTo(seqNo + 1));
            assertThat(seqNoGenerator.get(), equalTo(seqNo + 2));
        }
    }

<A NAME="19"></A>    @Test
    public void testKeepTranslogAfterGlobalCheckpoint() throws Exception {
        IOUtils.close(engine, store);
        final IndexSettings indexSettings = new IndexSettings(<FONT color="#f62817"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#19',2,'match306914-top.html#19',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>defaultSettings.getIndexMetadata(), defaultSettings.getNodeSettings(),
                                                              defaultSettings.getScopedSettings());
        IndexMetadata.Builder builder = IndexMetadata.builder(indexSettings.getIndexMetadata())
            .settings(Settings.builder().put(indexSettings.getSettings())
                          .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), randomFrom(&quot;-1&quot;, &quot;100micros&quot;, &quot;30m&quot;))
                          .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), randomFrom(&quot;-1&quot;, &quot;512b&quot;, &quot;1gb&quot;)));
        indexSettings.updateIndexMetadata(builder.build());

        final Path translogPath = createTempDir</B></FONT>();
        store = createStore();
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        store.createEmpty(Version.CURRENT.luceneVersion);
        final String translogUUID = Translog.createEmptyTranslog(translogPath, globalCheckpoint.get(), shardId, primaryTerm.get());
        store.associateIndexWithNewTranslog(translogUUID);

        final EngineConfig engineConfig = config(indexSettings, store, translogPath,
                                                 NoMergePolicy.INSTANCE, null, null, () -&gt; globalCheckpoint.get());
        final AtomicLong lastSyncedGlobalCheckpointBeforeCommit = new AtomicLong(Translog.readGlobalCheckpoint(translogPath, translogUUID));
        try (InternalEngine engine = new InternalEngine(engineConfig) {
            @Override
            protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
                lastSyncedGlobalCheckpointBeforeCommit.set(Translog.readGlobalCheckpoint(translogPath, translogUUID));
                // Advance the global checkpoint during the flush to create a lag between a persisted global checkpoint in the translog
                // (this value is visible to the deletion policy) and an in memory global checkpoint in the SequenceNumbersService.
                if (rarely()) {
                    globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), getPersistedLocalCheckpoint()));
                }
                super.commitIndexWriter(writer, translog, syncId);
            }
        }) {
            engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
            int numDocs = scaledRandomIntBetween(10, 100);
            for (int docId = 0; docId &lt; numDocs; docId++) {
                ParseContext.Document document = testDocumentWithTextField();
                document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
                engine.index(indexForDoc(testParsedDocument(Integer.toString(docId), null, document, B_1, null)));
                if (frequently()) {
                    globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
                    engine.syncTranslog();
                }
                if (frequently()) {
                    engine.flush(randomBoolean(), true);
                    final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
                    // Keep only one safe commit as the oldest commit.
                    final IndexCommit safeCommit = commits.get(0);
                    if (lastSyncedGlobalCheckpointBeforeCommit.get() == UNASSIGNED_SEQ_NO) {
                        // If the global checkpoint is still unassigned, we keep an empty(eg. initial) commit as a safe commit.
                        assertThat(Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                                   equalTo(SequenceNumbers.NO_OPS_PERFORMED));
                    } else {
                        assertThat(Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                                   lessThanOrEqualTo(lastSyncedGlobalCheckpointBeforeCommit.get()));
                    }
                    for (int i = 1; i &lt; commits.size(); i++) {
                        assertThat(Long.parseLong(commits.get(i).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                                   greaterThan(lastSyncedGlobalCheckpointBeforeCommit.get()));
                    }
                    // Make sure we keep all translog operations after the local checkpoint of the safe commit.
                    long localCheckpointFromSafeCommit = Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
                    try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
                        assertThat(snapshot, SnapshotMatchers.containsSeqNoRange(localCheckpointFromSafeCommit + 1, docId));
                    }
                }
            }
        }
    }

    @Test
    public void testConcurrentAppendUpdateAndRefresh() throws InterruptedException, IOException {
        int numDocs = scaledRandomIntBetween(100, 1000);
        CountDownLatch latch = new CountDownLatch(2);
        AtomicBoolean done = new AtomicBoolean(false);
        AtomicInteger numDeletes = new AtomicInteger();
        Thread thread = new Thread(() -&gt; {
            try {
                latch.countDown();
                latch.await();
                for (int j = 0; j &lt; numDocs; j++) {
                    String docID = Integer.toString(j);
                    ParsedDocument doc = testParsedDocument(docID, null, testDocumentWithTextField(),
                                                            new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
                    Engine.Index operation = appendOnlyPrimary(doc, false, 1);
                    engine.index(operation);
                    if (rarely()) {
                        engine.delete(new Engine.Delete(
                            operation.id(),
                            operation.uid(),
                            UNASSIGNED_SEQ_NO,
                            primaryTerm.get(),
                            Versions.MATCH_ANY,
                            VersionType.INTERNAL,
                            Engine.Operation.Origin.PRIMARY,
                            System.nanoTime(),
                            UNASSIGNED_SEQ_NO,
                            0
                        ));
                        numDeletes.incrementAndGet();
                    } else {
                        doc = testParsedDocument(docID, null, testDocumentWithTextField(&quot;updated&quot;),
                                                 new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
                        Engine.Index update = indexForDoc(doc);
                        engine.index(update);
                    }
                }
            } catch (Exception e) {
                throw new AssertionError(e);
            } finally {
                done.set(true);
            }
        });
        thread.start();
        latch.countDown();
        latch.await();
        while (done.get() == false) {
            engine.refresh(&quot;test&quot;, Engine.SearcherScope.INTERNAL, true);
        }
        thread.join();
        engine.refresh(&quot;test&quot;, Engine.SearcherScope.INTERNAL, true);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL)) {
            TopDocs search = searcher.search(new MatchAllDocsQuery(), searcher.getIndexReader().numDocs());
            for (int i = 0; i &lt; search.scoreDocs.length; i++) {
                org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[i].doc);
                assertEquals(&quot;updated&quot;, luceneDoc.get(&quot;value&quot;));
            }
            int totalNumDocs = numDocs - numDeletes.get();
            assertEquals(totalNumDocs, searcher.getIndexReader().numDocs());
        }
    }

    @Test
    public void testAcquireIndexCommit() throws Exception {
        IOUtils.close(engine, store);
        store = createStore();
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
            int numDocs = between(1, 20);
            for (int i = 0; i &lt; numDocs; i++) {
                index(engine, i);
            }
            if (randomBoolean()) {
                globalCheckpoint.set(numDocs - 1);
            }
            final boolean flushFirst = randomBoolean();
            final boolean safeCommit = randomBoolean();
            final Engine.IndexCommitRef snapshot;
            if (safeCommit) {
                snapshot = engine.acquireSafeIndexCommit();
            } else {
                snapshot = engine.acquireLastIndexCommit(flushFirst);
            }
            int moreDocs = between(1, 20);
            for (int i = 0; i &lt; moreDocs; i++) {
                index(engine, numDocs + i);
            }
            globalCheckpoint.set(numDocs + moreDocs - 1);
            engine.flush();
            // check that we can still read the commit that we captured
            try (IndexReader reader = DirectoryReader.open(snapshot.getIndexCommit())) {
                assertThat(reader.numDocs(), equalTo(flushFirst &amp;&amp; safeCommit == false ? numDocs : 0));
            }
            assertThat(DirectoryReader.listCommits(engine.store.directory()), hasSize(2));
            snapshot.close();
            // check it's clean up
            engine.flush(true, true);
            assertThat(DirectoryReader.listCommits(engine.store.directory()), hasSize(1));
        }
    }

    @Test
    public void testCleanUpCommitsWhenGlobalCheckpointAdvanced() throws Exception {
        IOUtils.close(engine, store);
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(&quot;test&quot;,
                                                                                 Settings.builder().put(defaultSettings.getSettings())
                                                                                     .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), -1)
                                                                                     .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), -1).build());
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (Store store = createStore();
             InternalEngine engine =
                 createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(),
                                     null, null, globalCheckpoint::get))) {
            final int numDocs = scaledRandomIntBetween(10, 100);
            for (int docId = 0; docId &lt; numDocs; docId++) {
                index(engine, docId);
                if (rarely()) {
<A NAME="93"></A>                    engine.flush(randomBoolean(), true);
                }
            }
            <FONT color="#ff00ff"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#93',2,'match306914-top.html#93',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.flush(false, randomBoolean());
            globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
            engine.syncTranslog();
            List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory</B></FONT>());
            assertThat(Long.parseLong(commits.get(0).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                lessThanOrEqualTo(globalCheckpoint.get()));
            for (int i = 1; i &lt; commits.size(); i++) {
                assertThat(Long.parseLong(commits.get(i).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
                    greaterThan(globalCheckpoint.get()));
            }
            // Global checkpoint advanced enough - only the last commit is kept.
            globalCheckpoint.set(randomLongBetween(engine.getPersistedLocalCheckpoint(), Long.MAX_VALUE));
            engine.syncTranslog();
            assertThat(DirectoryReader.listCommits(store.directory()), contains(commits.get(commits.size() - 1)));
            assertThat(engine.getTranslog().totalOperations(), equalTo(0));
        }
    }

    @Test
    public void testCleanupCommitsWhenReleaseSnapshot() throws Exception {
        IOUtils.close(engine, store);
        store = createStore();
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
            final int numDocs = scaledRandomIntBetween(10, 100);
            for (int docId = 0; docId &lt; numDocs; docId++) {
                index(engine, docId);
                if (frequently()) {
                    engine.flush(randomBoolean(), true);
                }
            }
            engine.flush(false, randomBoolean());
            int numSnapshots = between(1, 10);
            final List&lt;Engine.IndexCommitRef&gt; snapshots = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; numSnapshots; i++) {
                snapshots.add(engine.acquireSafeIndexCommit()); // taking snapshots from the safe commit.
            }
            globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
            engine.syncTranslog();
            final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
            for (int i = 0; i &lt; numSnapshots - 1; i++) {
                snapshots.get(i).close();
                // pending snapshots - should not release any commit.
                assertThat(DirectoryReader.listCommits(store.directory()), equalTo(commits));
            }
            snapshots.get(numSnapshots - 1).close(); // release the last snapshot - delete all except the last commit
            assertThat(DirectoryReader.listCommits(store.directory()), hasSize(1));
        }
    }

    @Test
    public void testShouldPeriodicallyFlush() throws Exception {
        assertThat(&quot;Empty engine does not need flushing&quot;, engine.shouldPeriodicallyFlush(), equalTo(false));
        // A new engine may have more than one empty translog files - the test should account this extra.
        final Translog translog = engine.getTranslog();
        final IntSupplier uncommittedTranslogOperationsSinceLastCommit = () -&gt; {
            long localCheckpoint = Long.parseLong(engine.getLastCommittedSegmentInfos().userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
            return translog.totalOperationsByMinGen(translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration);
        };
        final long extraTranslogSizeInNewEngine =
            engine.getTranslog().stats().getUncommittedSizeInBytes() - Translog.DEFAULT_HEADER_SIZE_IN_BYTES;
        int numDocs = between(10, 100);
        for (int id = 0; id &lt; numDocs; id++) {
            final ParsedDocument doc =
                testParsedDocument(Integer.toString(id), null, testDocumentWithTextField(), SOURCE, null);
            engine.index(indexForDoc(doc));
        }
        assertThat(&quot;Not exceeded translog flush threshold yet&quot;, engine.shouldPeriodicallyFlush(), equalTo(false));
<A NAME="12"></A>        long flushThreshold = RandomNumbers.randomLongBetween(random(), 120,
            engine.getTranslog().stats().getUncommittedSizeInBytes()- extraTranslogSizeInNewEngine);
        final IndexSettings indexSettings = engine.config().getIndexSettings();
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#12',2,'match306914-top.html#12',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
            .settings(Settings.builder().put(indexSettings.getSettings())
                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + &quot;b&quot;)).build();
        indexSettings.updateIndexMetadata(indexMetadata);
        engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
            indexSettings.getSoftDeleteRetentionOperations());
        assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(numDocs));
        assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
        engine.flush();
        assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt</B></FONT>(), equalTo(0));
        // Stale operations skipped by Lucene but added to translog - still able to flush
        for (int id = 0; id &lt; numDocs; id++) {
            final ParsedDocument doc =
                testParsedDocument(Integer.toString(id), null, testDocumentWithTextField(), SOURCE, null);
<A NAME="39"></A>            final Engine.IndexResult result = engine.index(replicaIndexForDoc(doc, 1L, id, false));
            assertThat(result.isCreated(), equalTo(false));
        }
        <FONT color="#152dc6"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#39',2,'match306914-top.html#39',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>SegmentInfos lastCommitInfo = engine.getLastCommittedSegmentInfos();
        assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt(), equalTo(numDocs));
        assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
        engine.flush(false, false);
        assertThat(engine.getLastCommittedSegmentInfos(), not(sameInstance(lastCommitInfo)));
        assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt(), equalTo(0));
        // If the new index commit still points to the same translog generation as the current index commit,
        // we should not enable the periodically flush condition; otherwise we can get into an infinite loop of flushes.
        generateNewSeqNo</B></FONT>(engine); // create a gap here
        for (int id = 0; id &lt; numDocs; id++) {
            if (randomBoolean()) {
                translog.rollGeneration();
            }
            final ParsedDocument doc =
                testParsedDocument(&quot;new&quot; + id, null, testDocumentWithTextField(), SOURCE, null);
            engine.index(replicaIndexForDoc(doc, 2L, generateNewSeqNo(engine), false));
            if (engine.shouldPeriodicallyFlush()) {
                engine.flush();
                assertThat(engine.getLastCommittedSegmentInfos(), not(sameInstance(lastCommitInfo)));
                assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
            }
        }
    }
<A NAME="57"></A>
    @Test
    public void testShouldPeriodicallyFlushAfterMerge() throws Exception {
        assertThat(&quot;Empty engine does not need flushing&quot;, engine.shouldPeriodicallyFlush(), <FONT
                color="#0000ff"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#57',2,'match306914-top.html#57',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>equalTo(false));
        ParsedDocument doc =
            testParsedDocument(Integer.toString(0), null, testDocumentWithTextField(), SOURCE, null);
        engine.index(indexForDoc(doc));
<A NAME="9"></A>        engine.refresh(&quot;test&quot;);
        assertThat(&quot;Not exceeded translog flush threshold yet&quot;, engine.shouldPeriodicallyFlush(), equalTo(false));
        final IndexSettings indexSettings = engine.config</B></FONT>().getIndexSettings();
        final IndexMetadata indexMetadata = <FONT color="#83a33a"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#9',2,'match306914-top.html#9',1)"><IMG SRC="back.gif"
                                                                                                       ALT="other"
                                                                                                       BORDER="0"
                                                                                                       ALIGN="left"></A></div><B>IndexMetadata.builder(indexSettings.getIndexMetadata())
            .settings(Settings.builder().put(indexSettings.getSettings())
                          .put(IndexSettings.INDEX_FLUSH_AFTER_MERGE_THRESHOLD_SIZE_SETTING.getKey(),  &quot;0b&quot;)).build();
        indexSettings.updateIndexMetadata(indexMetadata);
        engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
                                 indexSettings.getSoftDeleteRetentionOperations());
        assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(1));
        assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
        doc = testParsedDocument(Integer.toString(1), null, testDocumentWithTextField(), SOURCE, null);
        engine.index(indexForDoc</B></FONT>(doc));
        assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(2));
        engine.refresh(&quot;test&quot;);
        engine.forceMerge(false, 1, false, false, false, UUIDs.randomBase64UUID());
        assertBusy(() -&gt; {
            // the merge listner runs concurrently after the force merge returned
<A NAME="103"></A>            assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
        });
        engine.flush();
        <FONT color="#668b8b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#103',2,'match306914-top.html#103',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
    }

    @Test
    public void testStressShouldPeriodicallyFlush() throws Exception {
<A NAME="27"></A>        final long flushThreshold = randomLongBetween(120, 5000)</B></FONT>;
        final long generationThreshold = randomLongBetween(1000, 5000);
        final IndexSettings indexSettings = engine.config().getIndexSettings();
        <FONT color="#e77471"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#27',2,'match306914-top.html#27',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
            .settings(Settings.builder().put(indexSettings.getSettings())
                          .put(IndexSettings.INDEX_TRANSLOG_GENERATION_THRESHOLD_SIZE_SETTING.getKey(), generationThreshold + &quot;b&quot;)
                          .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + &quot;b&quot;)).build();
        indexSettings.updateIndexMetadata(indexMetadata);
        engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
            indexSettings.getSoftDeleteRetentionOperations());
        final int numOps = scaledRandomIntBetween</B></FONT>(100, 10_000);
        for (int i = 0; i &lt; numOps; i++) {
            final long localCheckPoint = engine.getProcessedLocalCheckpoint();
            final long seqno = randomLongBetween(Math.max(0, localCheckPoint), localCheckPoint + 5);
            final ParsedDocument doc =
                testParsedDocument(Long.toString(seqno), null, testDocumentWithTextField(), SOURCE, null);
            engine.index(replicaIndexForDoc(doc, 1L, seqno, false));
            if (rarely() &amp;&amp; engine.getTranslog().shouldRollGeneration()) {
                engine.rollTranslogGeneration();
            }
            if (rarely() || engine.shouldPeriodicallyFlush()) {
                engine.flush();
                assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
            }
        }
    }

    @Test
    public void testStressUpdateSameDocWhileGettingIt() throws IOException, InterruptedException {
        final int iters = randomIntBetween(1, 15);
        for (int i = 0; i &lt; iters; i++) {
<A NAME="17"></A>            // this is a reproduction of https://github.com/elastic/elasticsearch/issues/28714
            try (Store store = createStore(); InternalEngine engine = createEngine(store, createTempDir())) {
                final IndexSettings indexSettings = engine.config().getIndexSettings();
                <FONT color="#3090c7"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#17',2,'match306914-top.html#17',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
                    .settings(Settings.builder().put(indexSettings.getSettings())
                                  .put(IndexSettings.INDEX_GC_DELETES_SETTING.getKey(), TimeValue.timeValueMillis(1))).build();
                engine.engineConfig.getIndexSettings().updateIndexMetadata(indexMetadata);
                engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
                    indexSettings.getSoftDeleteRetentionOperations());
                ParsedDocument document = testParsedDocument(Integer.toString(0), null, testDocumentWithTextField</B></FONT>(), SOURCE, null);
                final Engine.Index doc = new Engine.Index(newUid(document), document, UNASSIGNED_SEQ_NO, 0,
                    Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(),
                    -1, false, UNASSIGNED_SEQ_NO, 0);
                // first index an append only document and then delete it. such that we have it in the tombstones
                engine.index(doc);
                engine.delete(new Engine.Delete(
                    doc.id(),
                    doc.uid(),
                    UNASSIGNED_SEQ_NO,
                    primaryTerm.get(),
                    Versions.MATCH_ANY,
                    VersionType.INTERNAL,
                    Engine.Operation.Origin.PRIMARY,
                    System.nanoTime(),
                    UNASSIGNED_SEQ_NO,
                    0
                ));

                // now index more append only docs and refresh so we re-enabel the optimization for unsafe version map
                ParsedDocument document1 = testParsedDocument(Integer.toString(1), null, testDocumentWithTextField(), SOURCE, null);
                engine.index(new Engine.Index(newUid(document1), document1, UNASSIGNED_SEQ_NO, 0, Versions.MATCH_ANY, VersionType.INTERNAL,
                    Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false,
                    UNASSIGNED_SEQ_NO, 0));
                engine.refresh(&quot;test&quot;);
                ParsedDocument document2 = testParsedDocument(Integer.toString(2), null, testDocumentWithTextField(), SOURCE, null);
                engine.index(new Engine.Index(newUid(document2), document2, UNASSIGNED_SEQ_NO, 0, Versions.MATCH_ANY, VersionType.INTERNAL,
                    Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false,
                    UNASSIGNED_SEQ_NO, 0));
                engine.refresh(&quot;test&quot;);
                ParsedDocument document3 = testParsedDocument(Integer.toString(3), null, testDocumentWithTextField(), SOURCE, null);
                final Engine.Index doc3 = new Engine.Index(newUid(document3), document3, UNASSIGNED_SEQ_NO, 0,
                    Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(),
                    -1, false, UNASSIGNED_SEQ_NO, 0);
                engine.index(doc3);
                engine.engineConfig.setEnableGcDeletes(true);
                // once we are here the version map is unsafe again and we need to do a refresh inside the get calls to ensure we
                // de-optimize. We also enabled GCDeletes which now causes pruning tombstones inside that refresh that is done internally
                // to ensure we de-optimize. One get call will purne and the other will try to lock the version map concurrently while
                // holding the lock that pruneTombstones needs and we have a deadlock
                CountDownLatch awaitStarted = new CountDownLatch(1);
                Thread thread = new Thread(() -&gt; {
                    awaitStarted.countDown();
                    try (Engine.GetResult getResult = engine.get(new Engine.Get(
                        doc3.id(), doc3.uid()), engine::acquireSearcher)) {

                        assertThat(getResult.docIdAndVersion(), is(notNullValue()));
                    }
                });
                thread.start();
                awaitStarted.await();
                try (Engine.GetResult getResult = engine.get(
                    new Engine.Get(doc.id(), doc.uid()),
                    engine::acquireSearcher)) {

                    assertThat(getResult.docIdAndVersion(), is(nullValue()));
                }
                thread.join();
            }
        }
    }

    @Test
    public void testPruneOnlyDeletesAtMostLocalCheckpoint() throws Exception {
        final AtomicLong clock = new AtomicLong(0);
        threadPool = spy(threadPool);
        when(threadPool.relativeTimeInMillis()).thenAnswer(invocation -&gt; clock.get());
        final long gcInterval = randomIntBetween(0, 10);
        final IndexSettings indexSettings = engine.config().getIndexSettings();
        final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
            .settings(Settings.builder().put(indexSettings.getSettings())
                          .put(IndexSettings.INDEX_GC_DELETES_SETTING.getKey(), TimeValue.timeValueMillis(gcInterval).getStringRep())).build();
        indexSettings.updateIndexMetadata(indexMetadata);
        try (Store store = createStore();
             InternalEngine engine = createEngine(store, createTempDir())) {
            engine.config().setEnableGcDeletes(false);
            for (int i = 0, docs = scaledRandomIntBetween(0, 10); i &lt; docs; i++) {
                index(engine, i);
            }
            final long deleteBatch = between(10, 20);
            final long gapSeqNo = randomLongBetween(
                engine.getSeqNoStats(-1).getMaxSeqNo() + 1, engine.getSeqNoStats(-1).getMaxSeqNo() + deleteBatch);
            for (int i = 0; i &lt; deleteBatch; i++) {
                final long seqno = generateNewSeqNo(engine);
                if (seqno != gapSeqNo) {
                    if (randomBoolean()) {
                        clock.incrementAndGet();
                    }
                    engine.delete(replicaDeleteForDoc(UUIDs.randomBase64UUID(), 1, seqno, threadPool.relativeTimeInMillis()));
<A NAME="24"></A>                }
            }

            List&lt;DeleteVersionValue&gt; tombstones = new ArrayList&lt;&gt;(<FONT color="#79764d"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#24',2,'match306914-top.html#24',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>tombstonesInVersionMap(engine).values());
            engine.config().setEnableGcDeletes(true);
            // Prune tombstones whose seqno &lt; gap_seqno and timestamp &lt; clock-gcInterval.
            clock.set(randomLongBetween(gcInterval, deleteBatch + gcInterval));
            engine.refresh(&quot;test&quot;);
            tombstones.removeIf(v -&gt; v.seqNo &lt; gapSeqNo &amp;&amp; v.time &lt; clock.get() - gcInterval);
            assertThat(tombstonesInVersionMap(engine).values(), containsInAnyOrder(tombstones.toArray()));
            // Prune tombstones whose seqno at most the local checkpoint (eg. seqno &lt; gap_seqno).
            clock.set(randomLongBetween(deleteBatch + gcInterval * 4/3, 100)); // Need a margin for gcInterval/4.
            engine.refresh(&quot;test&quot;);
            tombstones.removeIf</B></FONT>(v -&gt; v.seqNo &lt; gapSeqNo);
            assertThat(tombstonesInVersionMap(engine).values(), containsInAnyOrder(tombstones.toArray()));
            // Fill the seqno gap - should prune all tombstones.
            clock.set(between(0, 100));
            if (randomBoolean()) {
                engine.index(replicaIndexForDoc(testParsedDocument(&quot;d&quot;, null, testDocumentWithTextField(),
                                                                   SOURCE, null), 1, gapSeqNo, false));
            } else {
                engine.delete(replicaDeleteForDoc(UUIDs.randomBase64UUID(), Versions.MATCH_ANY,
                                                  gapSeqNo, threadPool.relativeTimeInMillis()));
            }
            clock.set(randomLongBetween(100 + gcInterval * 4/3, Long.MAX_VALUE)); // Need a margin for gcInterval/4.
            engine.refresh(&quot;test&quot;);
            assertThat(tombstonesInVersionMap(engine).values(), empty());
        }
    }

    @Test
    public void testTrimUnsafeCommits() throws Exception {
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final int maxSeqNo = 40;
        final List&lt;Long&gt; seqNos = LongStream.rangeClosed(0, maxSeqNo).boxed().collect(Collectors.toList());
        Collections.shuffle(seqNos, random());
        try (Store store = createStore()) {
            EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(),
                                         null, null, globalCheckpoint::get);
            final List&lt;Long&gt; commitMaxSeqNo = new ArrayList&lt;&gt;();
            final long minTranslogGen;
            try (InternalEngine engine = createEngine(config)) {
                for (int i = 0; i &lt; seqNos.size(); i++) {
                    ParsedDocument doc = testParsedDocument(Long.toString(seqNos.get(i)), null, testDocument(),
                                                            new BytesArray(&quot;{}&quot;), null);
                    Engine.Index index = new Engine.Index(newUid(doc), doc, seqNos.get(i), 0,
                                                          1, null, REPLICA, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
                    engine.index(index);
                    if (randomBoolean()) {
                        engine.flush();
                        final Long maxSeqNoInCommit = seqNos.subList(0, i + 1).stream().max(Long::compareTo).orElse(-1L);
                        commitMaxSeqNo.add(maxSeqNoInCommit);
                    }
                }
                globalCheckpoint.set(randomInt(maxSeqNo));
                engine.syncTranslog();
                minTranslogGen = engine.getTranslog().getMinFileGeneration();
            }

            store.trimUnsafeCommits(globalCheckpoint.get(), minTranslogGen,config.getIndexSettings().getIndexVersionCreated());
            long safeMaxSeqNo =
                commitMaxSeqNo.stream().filter(s -&gt; s &lt;= globalCheckpoint.get())
                    .reduce((s1, s2) -&gt; s2) // get the last one.
                    .orElse(SequenceNumbers.NO_OPS_PERFORMED);
            final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
            assertThat(commits, hasSize(1));
            assertThat(commits.get(0).getUserData().get(SequenceNumbers.MAX_SEQ_NO), equalTo(Long.toString(safeMaxSeqNo)));
            try (IndexReader reader = DirectoryReader.open(commits.get(0))) {
                for (LeafReaderContext context: reader.leaves()) {
                    final NumericDocValues values = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);
                    if (values != null) {
                        for (int docID = 0; docID &lt; context.reader().maxDoc(); docID++) {
                            if (values.advanceExact(docID) == false) {
                                throw new AssertionError(&quot;Document does not have a seq number: &quot; + docID);
                            }
                            assertThat(values.longValue(), lessThanOrEqualTo(globalCheckpoint.get()));
                        }
                    }
                }
            }
        }
    }
<A NAME="69"></A>
    @Test
    public void testLuceneHistoryOnPrimary() throws Exception {
        final List&lt;Engine.Operation&gt; operations = <FONT color="#571b7e"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#69',2,'match306914-top.html#69',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>generateSingleDocHistory(
            false, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, &quot;1&quot;);
        assertOperationHistoryInLucene(operations);
    }

    @Test
    public void testLuceneHistoryOnReplica() throws Exception {
        final List&lt;Engine.Operation&gt; operations = generateSingleDocHistory(
            true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, &quot;2&quot;);
        Randomness.shuffle(operations);
        assertOperationHistoryInLucene</B></FONT>(operations);
    }

<A NAME="92"></A>    private void assertOperationHistoryInLucene(List&lt;Engine.Operation&gt; operations) throws IOException {
        final MergePolicy keepSoftDeleteDocsMP = new SoftDeletesRetentionMergePolicy(
            Lucene.SOFT_DELETES_FIELD, MatchAllDocsQuery::new, engine.config().getMergePolicy());
        Settings.Builder settings = <FONT color="#41a317"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#92',2,'match306914-top.html#92',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings</B></FONT>(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        Set&lt;Long&gt; expectedSeqNos = new HashSet&lt;&gt;();
        try (Store store = createStore();
             Engine engine = createEngine(config(indexSettings, store, createTempDir(), keepSoftDeleteDocsMP, null))) {
            for (Engine.Operation op : operations) {
                if (op instanceof Engine.Index) {
                    Engine.IndexResult indexResult = engine.index((Engine.Index) op);
                    assertThat(indexResult.getFailure(), nullValue());
                    expectedSeqNos.add(indexResult.getSeqNo());
                } else {
                    Engine.DeleteResult deleteResult = engine.delete((Engine.Delete) op);
                    assertThat(deleteResult.getFailure(), nullValue());
                    expectedSeqNos.add(deleteResult.getSeqNo());
                }
                if (rarely()) {
                    engine.refresh(&quot;test&quot;);
                }
                if (rarely()) {
                    engine.flush();
                }
                if (rarely()) {
<A NAME="79"></A>                    engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
                }
            }
            <FONT color="#4cc417"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#79',2,'match306914-top.html#79',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MapperService mapperService = createMapperService(&quot;test&quot;);
            List&lt;Translog.Operation&gt; actualOps = readAllOperationsInLucene(engine, mapperService);
            assertThat(actualOps.stream().map(o -&gt; o.seqNo()).collect(Collectors.toList</B></FONT>()), containsInAnyOrder(expectedSeqNos.toArray()));
            assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
        }
    }

    @Test
    public void testKeepMinRetainedSeqNoByMergePolicy() throws IOException {
        IOUtils.close(engine, store);
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        final long primaryTerm = randomLongBetween(1, Long.MAX_VALUE);
        final AtomicLong retentionLeasesVersion = new AtomicLong();
        final AtomicReference&lt;RetentionLeases&gt; retentionLeasesHolder = new AtomicReference&lt;&gt;(
            new RetentionLeases(primaryTerm, retentionLeasesVersion.get(), Collections.emptyList()));
        final List&lt;Engine.Operation&gt; operations = generateSingleDocHistory(
            true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, &quot;2&quot;);
        Randomness.shuffle(operations);
        Set&lt;Long&gt; existingSeqNos = new HashSet&lt;&gt;();
        store = createStore();
        engine = createEngine(config(
            indexSettings,
            store,
            createTempDir(),
            newMergePolicy(),
            null,
            null,
            globalCheckpoint::get,
            retentionLeasesHolder::get
        ));
        assertThat(engine.getMinRetainedSeqNo(), equalTo(0L));
        long lastMinRetainedSeqNo = engine.getMinRetainedSeqNo();
        for (Engine.Operation op : operations) {
            final Engine.Result result;
            if (op instanceof Engine.Index) {
                result = engine.index((Engine.Index) op);
            } else {
                result = engine.delete((Engine.Delete) op);
            }
            existingSeqNos.add(result.getSeqNo());
            if (randomBoolean()) {
                engine.syncTranslog(); // advance persisted local checkpoint
                assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
                globalCheckpoint.set(
                    randomLongBetween(globalCheckpoint.get(), engine.getLocalCheckpointTracker().getPersistedCheckpoint()));
            }
            if (randomBoolean()) {
                retentionLeasesVersion.incrementAndGet();
                final int length = randomIntBetween(0, 8);
                final List&lt;RetentionLease&gt; leases = new ArrayList&lt;&gt;(length);
                for (int i = 0; i &lt; length; i++) {
                    final String id = randomAlphaOfLength(8);
                    final long retainingSequenceNumber = randomLongBetween(0, Math.max(0, globalCheckpoint.get()));
                    final long timestamp = randomLongBetween(0L, Long.MAX_VALUE);
                    final String source = randomAlphaOfLength(8);
                    leases.add(new RetentionLease(id, retainingSequenceNumber, timestamp, source));
                }
                retentionLeasesHolder.set(new RetentionLeases(primaryTerm, retentionLeasesVersion.get(), leases));
            }
            if (rarely()) {
                settings.put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
                indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
                engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
                    indexSettings.getSoftDeleteRetentionOperations());
            }
            if (rarely()) {
                engine.refresh(&quot;test&quot;);
            }
            if (rarely()) {
                engine.flush(true, true);
                assertThat(Long.parseLong(engine.getLastCommittedSegmentInfos().userData.get(Engine.MIN_RETAINED_SEQNO)),
                           equalTo(engine.getMinRetainedSeqNo()));
            }
            if (rarely()) {
                engine.forceMerge(randomBoolean(), 1, false, false, false, UUIDs.randomBase64UUID());
            }
            try (Closeable ignored = engine.acquireHistoryRetentionLock(Engine.HistorySource.INDEX)) {
                long minRetainSeqNos = engine.getMinRetainedSeqNo();
                assertThat(minRetainSeqNos, lessThanOrEqualTo(globalCheckpoint.get() + 1));
                Long[] expectedOps = existingSeqNos.stream().filter(seqno -&gt; seqno &gt;= minRetainSeqNos).toArray(Long[]::new);
                Set&lt;Long&gt; actualOps = readAllOperationsInLucene(engine, createMapperService(&quot;test&quot;)).stream()
                    .map(Translog.Operation::seqNo).collect(Collectors.toSet());
                assertThat(actualOps, containsInAnyOrder(expectedOps));
            }
            try (Engine.IndexCommitRef commitRef = engine.acquireSafeIndexCommit()) {
                IndexCommit safeCommit = commitRef.getIndexCommit();
                if (safeCommit.getUserData().containsKey(Engine.MIN_RETAINED_SEQNO)) {
                    lastMinRetainedSeqNo = Long.parseLong(safeCommit.getUserData().get(Engine.MIN_RETAINED_SEQNO));
                }
            }
        }
        if (randomBoolean()) {
            engine.close();
        } else {
            engine.flushAndClose();
        }
        try (InternalEngine recoveringEngine = new InternalEngine(engine.config())) {
            assertThat(recoveringEngine.getMinRetainedSeqNo(), equalTo(lastMinRetainedSeqNo));
        }
    }

    @Test
    public void testLastRefreshCheckpoint() throws Exception {
        AtomicBoolean done = new AtomicBoolean();
        Thread[] refreshThreads = new Thread[between(1, 8)];
        CountDownLatch latch = new CountDownLatch(refreshThreads.length);
        for (int i = 0; i &lt; refreshThreads.length; i++) {
            latch.countDown();
            refreshThreads[i] = new Thread(() -&gt; {
                while (done.get() == false) {
                    long checkPointBeforeRefresh = engine.getProcessedLocalCheckpoint();
                    engine.refresh(&quot;test&quot;, randomFrom(Engine.SearcherScope.values()), true);
                    assertThat(engine.lastRefreshedCheckpoint(), greaterThanOrEqualTo(checkPointBeforeRefresh));
                }
            });
            refreshThreads[i].start();
        }
        latch.await();
        List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
            true, VersionType.EXTERNAL, 1, 10, 1000, &quot;1&quot;);
        concurrentlyApplyOps(ops, engine);
        done.set(true);
        for (Thread thread : refreshThreads) {
<A NAME="101"></A>            thread.join();
        }
        engine.refresh(&quot;test&quot;);
        assertThat(<FONT color="#a057a5"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#101',2,'match306914-top.html#101',1)"><IMG
                SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.lastRefreshedCheckpoint(), equalTo(engine.getProcessedLocalCheckpoint()));
    }

    @Test
    public void testLuceneSnapshotRefreshesOnlyOnce() throws Exception {
        final MapperService mapperService = createMapperService(&quot;test&quot;)</B></FONT>;
        final long maxSeqNo = randomLongBetween(10, 50);
        final AtomicLong refreshCounter = new AtomicLong();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(Settings.builder().
                put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)).build());
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(),
                                                         null,
                                                         new ReferenceManager.RefreshListener() {
                                                             @Override
                                                             public void beforeRefresh() {
                                                                 refreshCounter.incrementAndGet();
                                                             }

                                                             @Override
                                                             public void afterRefresh(boolean didRefresh) {
                                                             }
                                                         }, () -&gt; SequenceNumbers.NO_OPS_PERFORMED))) {
            for (long seqNo = 0; seqNo &lt;= maxSeqNo; seqNo++) {
                final ParsedDocument doc = testParsedDocument(&quot;id_&quot; + seqNo, null, testDocumentWithTextField(&quot;test&quot;),
                                                              new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
                engine.index(replicaIndexForDoc(doc, 1, seqNo, randomBoolean()));
            }

            final long initialRefreshCount = refreshCounter.get();
            final Thread[] snapshotThreads = new Thread[between(1, 3)];
            CountDownLatch latch = new CountDownLatch(1);
            for (int i = 0; i &lt; snapshotThreads.length; i++) {
                final long min = randomLongBetween(0, maxSeqNo - 5);
                final long max = randomLongBetween(min, maxSeqNo);
                snapshotThreads[i] = new Thread(new AbstractRunnable() {
                    @Override
                    public void onFailure(Exception e) {
                        throw new AssertionError(e);
                    }

                    @Override
                    protected void doRun() throws Exception {
                        latch.await();
                        Translog.Snapshot changes = engine.newChangesSnapshot(&quot;test&quot;, mapperService, min, max, true);
                        changes.close();
                    }
                });
                snapshotThreads[i].start();
            }
            latch.countDown();
            for (Thread thread : snapshotThreads) {
                thread.join();
            }
            assertThat(refreshCounter.get(), equalTo(initialRefreshCount + 1L));
            assertThat(engine.lastRefreshedCheckpoint(), equalTo(maxSeqNo));
        }
    }

    @Test
    public void testAcquireSearcherOnClosingEngine() throws Exception {
        engine.close();
        expectThrows(AlreadyClosedException.class, () -&gt; engine.acquireSearcher(&quot;test&quot;, Engine.SearcherScope.INTERNAL));
    }

    @Test
    public void testNoOpOnClosingEngine() throws Exception {
        engine.close();
        Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
        IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        assertTrue(indexSettings.isSoftDeleteEnabled());
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
            engine.close();
            expectThrows(AlreadyClosedException.class, () -&gt; engine.noOp(
                new Engine.NoOp(2, primaryTerm.get(), LOCAL_TRANSLOG_RECOVERY, System.nanoTime(), &quot;reason&quot;)));
        }
    }

    @Test
    public void testSoftDeleteOnClosingEngine() throws Exception {
        engine.close();
        Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
        IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        assertTrue(indexSettings.isSoftDeleteEnabled());
        try (Store store = createStore();
             InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
            engine.close();
            expectThrows(AlreadyClosedException.class, () -&gt; engine.delete(replicaDeleteForDoc(&quot;test&quot;, 42, 7, System.nanoTime())));
        }
    }

    @Test
    public void testTrackMaxSeqNoOfUpdatesOrDeletesOnPrimary() throws Exception {
        engine.close();
        Set&lt;String&gt; liveDocIds = new HashSet&lt;&gt;();
        engine = new InternalEngine(engine.config());
        assertThat(engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(-1L));
        int numOps = between(1, 500);
        for (int i = 0; i &lt; numOps; i++) {
            long currentMaxSeqNoOfUpdates = engine.getMaxSeqNoOfUpdatesOrDeletes();
            ParsedDocument doc = createParsedDoc(Integer.toString(between(1, 100)), null);
            if (randomBoolean()) {
<A NAME="70"></A>                Engine.IndexResult result = engine.index(indexForDoc(doc));
                if (liveDocIds.add(doc.id()) == false) {
                    assertThat(&quot;update operations on primary must advance max_seq_no_of_updates&quot;,
                               <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A
                                       HREF="javascript:ZweiFrames('match306914-0.html#70',2,'match306914-top.html#70',1)"><IMG
                                       SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(Math.max(currentMaxSeqNoOfUpdates, result.getSeqNo())));
                } else {
                    assertThat(&quot;append operations should not advance max_seq_no_of_updates&quot;,
<A NAME="71"></A>                               engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(currentMaxSeqNoOfUpdates));
                }
            }</B></FONT> else {
                Engine.DeleteResult result = <FONT color="#842dce"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#71',2,'match306914-top.html#71',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.delete(new Engine.Delete(
                    doc.id(),
                    newUid(doc.id()),
                    UNASSIGNED_SEQ_NO,
                    primaryTerm.get(),
                    Versions.MATCH_ANY,
                    VersionType.INTERNAL,
                    Engine.Operation.Origin.PRIMARY,
                    System.nanoTime(),
                    UNASSIGNED_SEQ_NO,
                    0
                ));
                liveDocIds.remove(doc.id());
                assertThat(&quot;delete operations on primary must advance max_seq_no_of_updates&quot;,
<A NAME="64"></A>                           engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(Math.max</B></FONT>(currentMaxSeqNoOfUpdates, result.getSeqNo())));
            }
        }
    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#64',2,'match306914-top.html#64',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    @Test
    public void testRebuildLocalCheckpointTrackerAndVersionMap() throws Exception {
        Settings.Builder settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 10000)
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey</B></FONT>(), true);
        final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        Path translogPath = createTempDir();
        List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 500), randomBoolean(), randomBoolean());
        List&lt;List&lt;Engine.Operation&gt;&gt; commits = new ArrayList&lt;&gt;();
        commits.add(new ArrayList&lt;&gt;());
        try (Store store = createStore()) {
            EngineConfig config = config(indexSettings, store, translogPath, NoMergePolicy.INSTANCE, null, null, globalCheckpoint::get);
            final List&lt;DocIdSeqNoAndSource&gt; docs;
            try (InternalEngine engine = createEngine(config)) {
                List&lt;Engine.Operation&gt; flushedOperations = new ArrayList&lt;&gt;();
                for (Engine.Operation op : operations) {
                    flushedOperations.add(op);
                    applyOperation(engine, op);
                    if (randomBoolean()) {
                        engine.syncTranslog();
                        globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
                    }
                    if (randomInt(100) &lt; 10) {
                        engine.refresh(&quot;test&quot;);
                    }
                    if (randomInt(100) &lt; 5) {
                        engine.flush(true, true);
                        flushedOperations.sort(Comparator.comparing(Engine.Operation::seqNo));
                        commits.add(new ArrayList&lt;&gt;(flushedOperations));
                    }
                }
                docs = getDocIds(engine, true);
            }
            List&lt;Engine.Operation&gt; operationsInSafeCommit = null;
            for (int i = commits.size() - 1; i &gt;= 0; i--) {
                if (commits.get(i).stream().allMatch(op -&gt; op.seqNo() &lt;= globalCheckpoint.get())) {
                    operationsInSafeCommit = commits.get(i);
                    break;
                }
            }
            assertThat(operationsInSafeCommit, notNullValue());
            try (InternalEngine engine = new InternalEngine(config)) { // do not recover from translog
                final Map&lt;BytesRef, Engine.Operation&gt; deletesAfterCheckpoint = new HashMap&lt;&gt;();
                for (Engine.Operation op : operationsInSafeCommit) {
                    if (op instanceof Engine.NoOp == false &amp;&amp; op.seqNo() &gt; engine.getPersistedLocalCheckpoint()) {
                        deletesAfterCheckpoint.put(new Term(IdFieldMapper.NAME, Uid.encodeId(op.id())).bytes(), op);
                    }
                }
                deletesAfterCheckpoint.values().removeIf(o -&gt; o instanceof Engine.Delete == false);
<A NAME="38"></A>                final Map&lt;BytesRef, VersionValue&gt; versionMap = engine.getVersionMap();
                for (BytesRef uid : deletesAfterCheckpoint.keySet()) {
                    final VersionValue versionValue = versionMap.get(uid);
                    <FONT color="#348781"><div style="position:absolute;left:0"><A
                            HREF="javascript:ZweiFrames('match306914-0.html#38',2,'match306914-top.html#38',1)"><IMG
                            SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Engine.Operation op = deletesAfterCheckpoint.get(uid);
                    final String msg = versionValue + &quot; vs &quot; +
                        &quot;op[&quot; + op.operationType() + &quot;id=&quot; + op.id() + &quot; seqno=&quot; + op.seqNo() + &quot; term=&quot; + op.primaryTerm() + &quot;]&quot;;
                    assertThat(versionValue, instanceOf(DeleteVersionValue.class));
                    assertThat(msg, versionValue.seqNo, equalTo(op.seqNo()));
                    assertThat(msg, versionValue.term, equalTo(op.primaryTerm()));
                    assertThat(msg, versionValue.version, equalTo</B></FONT>(op.version()));
                }
                assertThat(versionMap.keySet(), equalTo(deletesAfterCheckpoint.keySet()));
                final LocalCheckpointTracker tracker = engine.getLocalCheckpointTracker();
                final Set&lt;Long&gt; seqNosInSafeCommit = operationsInSafeCommit.stream().map(op -&gt; op.seqNo()).collect(Collectors.toSet());
                for (Engine.Operation op : operations) {
                    assertThat(
                        &quot;seq_no=&quot; + op.seqNo() + &quot; max_seq_no=&quot; + tracker.getMaxSeqNo() + &quot; checkpoint=&quot; + tracker.getProcessedCheckpoint(),
                        tracker.hasProcessed(op.seqNo()), equalTo(seqNosInSafeCommit.contains(op.seqNo())));
                }
                engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                assertThat(getDocIds(engine, true), equalTo(docs));
            }
        }
    }

    @Test
    public void testRequireSoftDeletesWhenAccessingChangesSnapshot() throws Exception {
        try (Store store = createStore()) {
            final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
                IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(Settings.builder().
                    put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false)).build());
            try (InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null))) {
                AssertionError error = expectThrows(AssertionError.class,
                                                    () -&gt; engine.newChangesSnapshot(&quot;test&quot;, createMapperService(&quot;test&quot;), 0, randomNonNegativeLong(), randomBoolean()));
                assertThat(error.getMessage(), containsString(&quot;does not have soft-deletes enabled&quot;));
            }
        }
    }

    private void assertLuceneOperations(InternalEngine engine,
                                        long expectedAppends,
<A NAME="34"></A>                                        long expectedUpdates,
                                        long expectedDeletes) {
        String message = &quot;Lucene operations mismatched;&quot; +
                         &quot; appends [actual:&quot; + <FONT color="#827d6b"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#34',2,'match306914-top.html#34',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.getNumDocAppends() + &quot;, expected:&quot; + expectedAppends + &quot;],&quot; +
                         &quot; updates [actual:&quot; + engine.getNumDocUpdates() + &quot;, expected:&quot; + expectedUpdates + &quot;],&quot; +
                         &quot; deletes [actual:&quot; + engine.getNumDocDeletes() + &quot;, expected:&quot; + expectedDeletes + &quot;]&quot;;
        assertThat(message, engine.getNumDocAppends(), equalTo(expectedAppends));
        assertThat(message, engine.getNumDocUpdates(), equalTo(expectedUpdates));
        assertThat(message, engine.getNumDocDeletes(), equalTo(expectedDeletes));
    }

    @Test
    public void testStoreHonorsLuceneVersion() throws IOException {</B></FONT>
        for (Version createdVersion : Arrays.asList(
                Version.CURRENT, VersionUtils.getPreviousMinorVersion(), VersionUtils.getFirstVersion())) {
            Settings settings = Settings.builder()
                    .put(indexSettings())
                    .put(IndexMetadata.SETTING_VERSION_CREATED, createdVersion).build();
            IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(&quot;test&quot;, settings);
            try (Store store = createStore();
                    InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
                ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, new Document(),
                        new BytesArray(&quot;{}&quot;.getBytes(&quot;UTF-8&quot;)), null);
                engine.index(appendOnlyPrimary(doc, false, 1));
                engine.refresh(&quot;test&quot;);
                try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                    LeafReader leafReader = getOnlyLeafReader(searcher.getIndexReader());
                    assertEquals(createdVersion.luceneVersion.major, leafReader.getMetaData().getCreatedVersionMajor());
                }
            }
        }
    }

    @Test
    public void testMaxSeqNoInCommitUserData() throws Exception {
        AtomicBoolean running = new AtomicBoolean(true);
        Thread rollTranslog = new Thread(() -&gt; {
            while (running.get() &amp;&amp; engine.getTranslog().currentFileGeneration() &lt; 500) {
                engine.rollTranslogGeneration(); // make adding operations to translog slower
            }
        });
        rollTranslog.start();

        Thread indexing = new Thread(() -&gt; {
            long seqNo = 0;
            while (running.get() &amp;&amp; seqNo &lt;= 1000) {
                try {
                    String id = Long.toString(between(1, 50));
                    if (randomBoolean()) {
                        ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
                        engine.index(replicaIndexForDoc(doc, 1L, seqNo, false));
                    } else {
                        engine.delete(replicaDeleteForDoc(id, 1L, seqNo, 0L));
                    }
                    seqNo++;
                } catch (IOException e) {
                    throw new AssertionError(e);
                }
            }
        });
        indexing.start();

        int numCommits = between(5, 20);
        for (int i = 0; i &lt; numCommits; i++) {
            engine.flush(false, true);
        }
        running.set(false);
        indexing.join();
        rollTranslog.join();
        assertMaxSeqNoInCommitUserData(engine);
    }

    @Test
    public void testPruneAwayDeletedButRetainedIds() throws Exception {
        IOUtils.close(engine, store);
        Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
        IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        store = createStore(indexSettings, newDirectory());
        LogDocMergePolicy policy = new LogDocMergePolicy();
        policy.setMinMergeDocs(10000);
        try (InternalEngine engine = createEngine(indexSettings, store, createTempDir(), policy)) {
            int numDocs = between(1, 20);
            logger.info(&quot;&quot; + numDocs);
            for (int i = 0; i &lt; numDocs; i++) {
                index(engine, i);
            }
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
            engine.delete(new Engine.Delete(&quot;0&quot;, newUid(&quot;0&quot;), primaryTerm.get()));
            engine.refresh(&quot;test&quot;);
            // now we have 2 segments since we now added a tombstone plus the old segment with the delete
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                IndexReader reader = searcher.getIndexReader();
                assertEquals(2, reader.leaves().size());
                LeafReaderContext leafReaderContext = reader.leaves().get(0);
                LeafReader leafReader = leafReaderContext.reader();
                assertEquals(&quot;the delete and the tombstone&quot;, 1, leafReader.numDeletedDocs());
                assertEquals(numDocs, leafReader.maxDoc());
                Terms id = leafReader.terms(&quot;_id&quot;);
                assertNotNull(id);
                assertEquals(&quot;deleted IDs are NOT YET pruned away&quot;, reader.numDocs() + 1, id.size());
                TermsEnum iterator = id.iterator();
                assertTrue(iterator.seekExact(Uid.encodeId(&quot;0&quot;)));
            }

            // lets force merge the tombstone and the original segment and make sure the doc is still there but the ID term is gone
            engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
            engine.refresh(&quot;test&quot;);
            try (Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
                IndexReader reader = searcher.getIndexReader();
                assertEquals(1, reader.leaves().size());
                LeafReaderContext leafReaderContext = reader.leaves().get(0);
                LeafReader leafReader = leafReaderContext.reader();
                assertEquals(&quot;the delete and the tombstone&quot;, 2, leafReader.numDeletedDocs());
                assertEquals(numDocs + 1, leafReader.maxDoc());
                Terms id = leafReader.terms(&quot;_id&quot;);
                if (numDocs == 1) {
                    assertNull(id); // everything is pruned away
                    assertEquals(0, leafReader.numDocs());
                } else {
                    assertNotNull(id);
                    assertEquals(&quot;deleted IDs are pruned away&quot;, reader.numDocs(), id.size());
                    TermsEnum iterator = id.iterator();
                    assertFalse(iterator.seekExact(Uid.encodeId(&quot;0&quot;)));
                }
             }
         }
    }

    @Test
    public void testRecoverFromLocalTranslog() throws Exception {
        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
        Path translogPath = createTempDir();
        List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 500), randomBoolean(), randomBoolean());
        try (Store store = createStore()) {
            EngineConfig config = config(defaultSettings, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get);
            final List&lt;DocIdSeqNoAndSource&gt; docs;
            try (InternalEngine engine = createEngine(config)) {
                for (Engine.Operation op : operations) {
                    applyOperation(engine, op);
                    if (randomBoolean()) {
                        engine.syncTranslog();
                        globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
                    }
                    if (randomInt(100) &lt; 10) {
                        engine.refresh(&quot;test&quot;);
                    }
                    if (randomInt(100) &lt; 5) {
                        engine.flush();
                    }
                    if (randomInt(100) &lt; 5) {
                        engine.forceMerge(randomBoolean(), 1, false, false, false, UUIDs.randomBase64UUID());
                    }
                }
                if (randomBoolean()) {
                    // engine is flushed properly before shutting down.
                    engine.syncTranslog();
                    globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
                    engine.flush();
                }
                docs = getDocIds(engine, true);
            }
            try (InternalEngine engine = new InternalEngine(config)) {
                engine.onSettingsChanged(TimeValue.MINUS_ONE, ByteSizeValue.ZERO, 0);
                engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
                assertThat(getDocIds(engine, randomBoolean()), equalTo(docs));
                if (engine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo() == globalCheckpoint.get()) {
                    assertThat(&quot;engine should trim all unreferenced translog after recovery&quot;,
                        engine.getTranslog().getMinFileGeneration(), equalTo(engine.getTranslog().currentFileGeneration()));
                }
            }
        }
    }
<A NAME="74"></A>

    private Map&lt;BytesRef, DeleteVersionValue&gt; tombstonesInVersionMap(InternalEngine engine) {
        return <FONT color="#3090c7"><div style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#74',2,'match306914-top.html#74',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>engine.getVersionMap().entrySet().stream()
            .filter(e -&gt; e.getValue() instanceof DeleteVersionValue)
            .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; (DeleteVersionValue) e.getValue</B></FONT>()));
    }

    @Test
    public void testTreatDocumentFailureAsFatalError() throws Exception {
        AtomicReference&lt;IOException&gt; addDocException = new AtomicReference&lt;&gt;();
        IndexWriterFactory indexWriterFactory = (dir, iwc) -&gt; new IndexWriter(dir, iwc) {
            @Override
            public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) throws IOException {
                final IOException ex = addDocException.getAndSet(null);
                if (ex != null) {
                    throw ex;
                }
                return super.addDocument(doc);
            }
        };
        try (Store store = createStore();
             InternalEngine engine = createEngine(defaultSettings,
                                                  store,
                                                  createTempDir(),
                                                  NoMergePolicy.INSTANCE,
                                                  indexWriterFactory)) {
<A NAME="63"></A>            final ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(), SOURCE, null);
            Engine.Operation.Origin origin = randomFrom(REPLICA, LOCAL_RESET, PEER_RECOVERY);
            Engine.Index index = new Engine.Index(
                <FONT color="#8c8774"><div style="position:absolute;left:0"><A
                        HREF="javascript:ZweiFrames('match306914-0.html#63',2,'match306914-top.html#63',1)"><IMG
                        SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>newUid(doc),
                doc,
                randomNonNegativeLong(),
                primaryTerm.get(),
                randomNonNegativeLong(),
                null,
                origin,
                System.nanoTime(),
                -1,
                false,
                UNASSIGNED_SEQ_NO,
                UNASSIGNED_PRIMARY_TERM);
            addDocException.set(new IOException(&quot;simulated&quot;));
            expectThrows(IOException.class, () -&gt; engine.index(index));
<A NAME="45"></A>            assertTrue(engine.isClosed.get());
            assertNotNull(engine.failedEngine.get</B></FONT>());
        }
    <FONT color="#549748"><div style="position:absolute;left:0"><A
            HREF="javascript:ZweiFrames('match306914-0.html#45',2,'match306914-top.html#45',1)"><IMG SRC="back.gif"
                                                                                                     ALT="other"
                                                                                                     BORDER="0"
                                                                                                     ALIGN="left"></A></div><B>}

    /**
     * We can trim translog on primary promotion and peer recovery based on the fact we add operations with either
     * REPLICA or PEER_RECOVERY origin to translog although they already exist in the engine (i.e. hasProcessed() == true).
     * If we decide not to add those already-processed operations to translog, we need to study carefully the consequence
     * of the translog trimming in these two places.
     */
    @Test
    public void testAlwaysRecordReplicaOrPeerRecoveryOperationsToTranslog() throws Exception {
        List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean());
        applyOperations(engine, operations);
        Set&lt;Long&gt; seqNos = operations.stream().map(Engine.Operation::seqNo).collect(Collectors.toSet</B></FONT>());
        try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
            assertThat(snapshot.totalOperations(), equalTo(operations.size()));
            assertThat(TestTranslog.drainSnapshot(snapshot, false).stream().map(Translog.Operation::seqNo).collect(Collectors.toSet()),
                equalTo(seqNos));
        }
        primaryTerm.set(randomLongBetween(primaryTerm.get(), Long.MAX_VALUE));
        engine.rollTranslogGeneration();
        engine.trimOperationsFromTranslog(primaryTerm.get(), NO_OPS_PERFORMED); // trim everything in translog
        try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
            assertThat(snapshot.totalOperations(), equalTo(0));
            assertNull(snapshot.next());
        }
        applyOperations(engine, operations);
        try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
            assertThat(snapshot.totalOperations(), equalTo(operations.size()));
            assertThat(TestTranslog.drainSnapshot(snapshot, false).stream().map(Translog.Operation::seqNo).collect(Collectors.toSet()),
                equalTo(seqNos));
        }
    }

    @Test
    public void testNoOpFailure() throws IOException {
        engine.close();
        final Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        try (Store store = createStore();
             Engine engine = createEngine((dir, iwc) -&gt; new IndexWriter(dir, iwc) {

                 @Override
                 public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) {
                     throw new IllegalArgumentException(&quot;fatal&quot;);
<A NAME="16"></A>                 }

             }, null, null, config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
            final Engine.NoOp op = new Engine.NoOp(0, 0, PRIMARY, <FONT color="#2981b2"><div
                style="position:absolute;left:0"><A
                HREF="javascript:ZweiFrames('match306914-0.html#16',2,'match306914-top.html#16',1)"><IMG SRC="back.gif"
                                                                                                         ALT="other"
                                                                                                         BORDER="0"
                                                                                                         ALIGN="left"></A></div><B>System.currentTimeMillis(), &quot;test&quot;);
            final IllegalArgumentException e = expectThrows(IllegalArgumentException. class, () -&gt; engine.noOp(op));
            assertThat(e.getMessage(), equalTo(&quot;fatal&quot;));
            assertTrue(engine.isClosed.get());
            assertThat(engine.failedEngine.get(), not(nullValue()));
            assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
            assertThat(engine.failedEngine.get().getMessage(), equalTo(&quot;fatal&quot;));
        }</B></FONT>
    }

    @Test
    public void testDeleteFailureSoftDeletesEnabledDocAlreadyDeleted() throws IOException {
        runTestDeleteFailure(true, InternalEngine::delete);
    }

    @Test
    public void testDeleteFailureSoftDeletesEnabled() throws IOException {
        runTestDeleteFailure(true, (engine, op) -&gt; {});
    }

    @Test
    public void testDeleteFailureSoftDeletesDisabled() throws IOException {
        runTestDeleteFailure(false, (engine, op) -&gt; {});
    }

    private void runTestDeleteFailure(
        final boolean softDeletesEnabled,
        final CheckedBiConsumer&lt;InternalEngine, Engine.Delete, IOException&gt; consumer) throws IOException {
        engine.close();
        final Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), softDeletesEnabled).build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        final AtomicReference&lt;ThrowingIndexWriter&gt; iw = new AtomicReference&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(
                 (dir, iwc) -&gt; {
                     iw.set(new ThrowingIndexWriter(dir, iwc));
                     return iw.get();
                 },
                 null,
                 null,
                 config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null)
            )) {

            engine.index(new Engine.Index(newUid(&quot;0&quot;), primaryTerm.get(), InternalEngineTests.createParsedDoc(&quot;0&quot;, null)));
<A NAME="29"></A>            final Engine.Delete op = new Engine.Delete(&quot;0&quot;, newUid(&quot;0&quot;), primaryTerm.get());
            consumer.accept(engine, op);
            iw.get().setThrowFailure(() -&gt; new IllegalArgumentException(&quot;fatal&quot;));
            <FONT color="#af7a82"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#29',2,'match306914-top.html#29',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final IllegalArgumentException e = expectThrows(IllegalArgumentException. class, () -&gt; engine.delete(op));
            assertThat(e.getMessage(), equalTo(&quot;fatal&quot;));
            assertTrue(engine.isClosed.get());
            assertThat(engine.failedEngine.get(), not(nullValue()));
            assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
            assertThat(engine.failedEngine.get().getMessage(), equalTo</B></FONT>(&quot;fatal&quot;));
        }
    }

    @Test
    public void testRealtimeGetOnlyRefreshIfNeeded() throws Exception {
        final AtomicInteger refreshCount = new AtomicInteger();
        final ReferenceManager.RefreshListener refreshListener = new ReferenceManager.RefreshListener() {
            @Override
            public void beforeRefresh() {

            }

            @Override
            public void afterRefresh(boolean didRefresh) {
                if (didRefresh) {
                    refreshCount.incrementAndGet();
                }
            }
        };
        try (Store store = createStore()) {
            final EngineConfig config = config(
                defaultSettings,
                store,
                createTempDir(),
                newMergePolicy(),
                null,
                refreshListener,
                null,
                null
            );
            try (InternalEngine engine = createEngine(config)) {
                int numDocs = randomIntBetween(10, 100);
                Set&lt;String&gt; ids = new HashSet&lt;&gt;();
                for (int i = 0; i &lt; numDocs; i++) {
                    String id = Integer.toString(i);
                    engine.index(indexForDoc(createParsedDoc(id, null)));
                    ids.add(id);
                }
                final int refreshCountBeforeGet = refreshCount.get();
                Thread[] getters = new Thread[randomIntBetween(1, 4)];
                Phaser phaser = new Phaser(getters.length + 1);
                for (int t = 0; t &lt; getters.length; t++) {
                    getters[t] = new Thread(() -&gt; {
                        phaser.arriveAndAwaitAdvance();
                        int iters = randomIntBetween(1, 10);
                        for (int i = 0; i &lt; iters; i++) {
                            ParsedDocument doc = createParsedDoc(randomFrom(ids), null);
                            try (Engine.GetResult getResult = engine.get(newGet(doc), engine::acquireSearcher)) {
                                assertThat(getResult.docIdAndVersion(), notNullValue());
                            }
                        }
                    });
                    getters[t].start();
                }
                phaser.arriveAndAwaitAdvance();
                for (int i = 0; i &lt; numDocs; i++) {
                    engine.index(indexForDoc(createParsedDoc(&quot;more-&quot; + i, null)));
                }
                for (Thread getter : getters) {
                    getter.join();
                }
                assertThat(refreshCount.get(), lessThanOrEqualTo(refreshCountBeforeGet + 1));
            }
        }
    }

    @Test
    public void testRefreshDoesNotBlockClosing() throws Exception {
        final CountDownLatch refreshStarted = new CountDownLatch(1);
        final CountDownLatch engineClosed = new CountDownLatch(1);
        final ReferenceManager.RefreshListener refreshListener = new ReferenceManager.RefreshListener() {

            @Override
            public void beforeRefresh() {
                refreshStarted.countDown();
                try {
                    engineClosed.await();
                } catch (InterruptedException e) {
                    throw new AssertionError(e);
                }
            }

            @Override
            public void afterRefresh(boolean didRefresh) {
                assertFalse(didRefresh);
            }
        };
        try (Store store = createStore()) {
            final EngineConfig config = config(
                defaultSettings,
                store,
                createTempDir(),
                newMergePolicy(),
                null,
                refreshListener,
                null,
                null
            );
            try (InternalEngine engine = createEngine(config)) {
                if (randomBoolean()) {
                    engine.index(indexForDoc(createParsedDoc(&quot;id&quot;, null)));
                }
                threadPool.executor(ThreadPool.Names.REFRESH).execute(() -&gt;
                    expectThrows(AlreadyClosedException.class,
                        () -&gt; engine.refresh(&quot;test&quot;, randomFrom(Engine.SearcherScope.values()), true)));
                refreshStarted.await();
                engine.close();
                engineClosed.countDown();
            }
        }
    }

    @Test
    public void testDeleteDocumentFailuresShouldFailEngine() throws IOException {
        engine.close();

        final Settings settings = Settings.builder()
            .put(defaultSettings.getSettings())
            .build();
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
            IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
        final AtomicReference&lt;ThrowingIndexWriter&gt; iw = new AtomicReference&lt;&gt;();
        try (Store store = createStore();
             InternalEngine engine = createEngine(
                 (dir, iwc) -&gt; {
                     iw.set(new ThrowingIndexWriter(dir, iwc));
                     return iw.get();
                 },
                 null,
                 null,
                 config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {

            engine.index(new Engine.Index(
                newUid(&quot;0&quot;), InternalEngineTests.createParsedDoc(&quot;0&quot;, null), UNASSIGNED_SEQ_NO, primaryTerm.get(),
                Versions.MATCH_DELETED, VersionType.INTERNAL,
                Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));

            Engine.Delete op = new Engine.Delete(
                &quot;0&quot;,
                newUid(&quot;0&quot;),
                UNASSIGNED_SEQ_NO,
                primaryTerm.get(),
                Versions.MATCH_ANY,
                VersionType.INTERNAL,
                Engine.Operation.Origin.PRIMARY,
                System.nanoTime(),
                UNASSIGNED_SEQ_NO,
                0
<A NAME="23"></A>            );

            iw.get().setThrowFailure(() -&gt; new IllegalArgumentException(&quot;fatal&quot;));
            <FONT color="#f660ab"><div style="position:absolute;left:0"><A
                    HREF="javascript:ZweiFrames('match306914-0.html#23',2,'match306914-top.html#23',1)"><IMG
                    SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -&gt; engine.delete(op));
            assertThat(e.getMessage(), equalTo(&quot;fatal&quot;));
            assertThat(engine.isClosed.get(), is(true));
            assertThat(engine.failedEngine.get(), not(nullValue()));
            assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
            assertThat(engine.failedEngine.get().getMessage(), equalTo</B></FONT>(&quot;fatal&quot;));
        }
    }

    public static &lt;T&gt; void assertThatIfAssertionEnabled(T actual, Matcher&lt;? super T&gt; matcher) {
        if (InternalEngineTests.class.desiredAssertionStatus()) {
            assertThat(actual, matcher);
        }
    }

    @Test
    public void testProducesStoredFieldsReader() throws Exception {
        // Make sure that the engine produces a SequentialStoredFieldsLeafReader.
        // This is required for optimizations on SourceLookup to work, which is in-turn useful for runtime fields.
        ParsedDocument doc = testParsedDocument(&quot;1&quot;, null, testDocumentWithTextField(&quot;test&quot;),
                                                new BytesArray(&quot;{}&quot;.getBytes(Charset.defaultCharset())), null);
        Engine.Index operation = randomBoolean() ?
            appendOnlyPrimary(doc, false, 1)
            : appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
        engine.index(operation);
        engine.refresh(&quot;test&quot;);
        try (Engine.Searcher searcher = engine.acquireSearcher(&quot;test&quot;)) {
            IndexReader reader = searcher.getIndexReader();
            assertThat(reader.leaves().size(), Matchers.greaterThanOrEqualTo(1));
            for (LeafReaderContext context: reader.leaves()) {
                assertThat(context.reader(), Matchers.instanceOf(SequentialStoredFieldsLeafReader.class));
                SequentialStoredFieldsLeafReader lf = (SequentialStoredFieldsLeafReader) context.reader();
                assertNotNull(lf.getSequentialStoredFieldsReader());
            }
        }
    }
}
</PRE>
    </div>
</div>
<div class="modal" id="myModal" style="display:none;">
    <div class="modal-content"><span class="close">x</span>
        <p></p>
        <div class="row">
            <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div>
            <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div>
        </div>
        <div class="row">
            <div class="column" id="column1">Column 1</div>
            <div class="column" id="column2">Column 2</div>
        </div>
    </div>
</div>
<script>var modal = document.getElementById("myModal"), span = document.getElementsByClassName("close")[0];
span.onclick = function () {
    modal.style.display = "none"
};
window.onclick = function (a) {
    a.target == modal && (modal.style.display = "none")
};

function openModal(a) {
    console.log("the color is " + a);
    let b = getCodes(a);
    console.log(b);
    var c = document.getElementById("column1");
    c.innerText = b[0];
    var d = document.getElementById("column2");
    d.innerText = b[1];
    c.style.color = a;
    c.style.fontWeight = "bold";
    d.style.fontWeight = "bold";
    d.style.color = a;
    var e = document.getElementById("myModal");
    e.style.display = "block"
}

function getCodes(a) {
    for (var b = document.getElementsByTagName("font"), c = [], d = 0; d < b.length; d++) b[d].attributes.color.nodeValue === a && "-" !== b[d].innerText && c.push(b[d].innerText);
    return c
}</script>
<script>const params = window.location.search;
const urlParams = new URLSearchParams(params);
const searchText = urlParams.get('lines');
let lines = searchText.split(',');
for (let line of lines) {
    const elements = document.getElementsByTagName('td');
    for (let i = 0; i < elements.length; i++) {
        if (elements[i].innerText.includes(line)) {
            elements[i].style.background = 'green';
            break;
        }
    }
}</script>
</body>
</html>
