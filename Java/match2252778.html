<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for PropertyPlaceholderTests.java &amp; PrimaryAllocationIT.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for PropertyPlaceholderTests.java &amp; PrimaryAllocationIT.java
      </h3>
<h1 align="center">
        9.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>PropertyPlaceholderTests.java (16.091953%)<th>PrimaryAllocationIT.java (7.179487%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-48)<td><a href="#" name="0">(145-154)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(56-62)<td><a href="#" name="1">(175-184)</a><td align="center"><font color="#d70000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(103-108)<td><a href="#" name="2">(268-271)</a><td align="center"><font color="#b00000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(66-71)<td><a href="#" name="3">(214-219)</a><td align="center"><font color="#b00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>PropertyPlaceholderTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.common.settings;
2 import java.util.LinkedHashMap;
3 import java.util.Map;
4 import org.elasticsearch.test.ESTestCase;
5 import org.junit.Test;
6 import static org.hamcrest.Matchers.is;
7 public class PropertyPlaceholderTests extends ESTestCase {
8     @Test
9     public void testSimple() {
10         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("{", "}", false);
11         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
12 <a name="0"></a>        map.put("foo1", "bar1");
13         map.put("foo2", "bar2");
14         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
15         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("bar1", propertyPlaceholder.replacePlaceholders("{foo1}", placeholderResolver));
16         assertEquals("a bar1b", propertyPlaceholder.replacePlaceholders("a {foo1}b", placeholderResolver));
17         assertEquals("bar1bar2", propertyPlaceholder.replacePlaceholders("{foo1}{foo2}", placeholderResolver));
18         assertEquals("a bar1 b bar2 c", propertyPlaceholder.replacePlaceholders("a {foo1} b {foo2} c", placeholderResolver));
19     }
20     @Test
21     public void testVariousPrefixSuffix() {</b></font>
22         PropertyPlaceholder ppEqualsPrefix = new PropertyPlaceholder("{", "}", false);
23         PropertyPlaceholder ppLongerPrefix = new PropertyPlaceholder("${", "}", false);
24         PropertyPlaceholder ppShorterPrefix = new PropertyPlaceholder("{", "}}", false);
25 <a name="1"></a>        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
26         map.put("foo", "bar");
27         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
28         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("bar", ppEqualsPrefix.replacePlaceholders("{foo}", placeholderResolver));
29         assertEquals("bar", ppLongerPrefix.replacePlaceholders("${foo}", placeholderResolver));
30         assertEquals("bar", ppShorterPrefix.replacePlaceholders("{foo}}", placeholderResolver));
31     }
32     @Test
33     public void testDefaultValue() {</b></font>
34 <a name="3"></a>        PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
35         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
36         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
37         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("bar", propertyPlaceholder.replacePlaceholders("${foo:bar}", placeholderResolver));
38         assertEquals("", propertyPlaceholder.replacePlaceholders("${foo:}", placeholderResolver));
39     }
40     @Test
41     public void testIgnoredUnresolvedPlaceholder() {</b></font>
42         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", true);
43         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
44         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
45         assertEquals("${foo}", propertyPlaceholder.replacePlaceholders("${foo}", placeholderResolver));
46     }
47     @Test
48     public void testNotIgnoredUnresolvedPlaceholder() {
49         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
50         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
51         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
52         try {
53             propertyPlaceholder.replacePlaceholders("${foo}", placeholderResolver);
54             fail("Expected IllegalArgumentException");
55         } catch (IllegalArgumentException e) {
56             assertThat(e.getMessage(), is("Could not resolve placeholder 'foo'"));
57         }
58     }
59     @Test
60     public void testShouldIgnoreMissing() {
61         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
62         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
63         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, true, true);
64         assertEquals("bar", propertyPlaceholder.replacePlaceholders("bar${foo}", placeholderResolver));
65     }
66     @Test
67 <a name="2"></a>    public void testRecursive() {
68         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
69         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
70         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>map.put("foo", "${foo1}");
71         map.put("foo1", "${foo2}");
72         map.put("foo2", "bar");
73         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
74         assertEquals("bar", propertyPlaceholder.replacePlaceholders("${foo}", placeholderResolver));
75         assertEquals("abarb", propertyPlaceholder.replacePlaceholders</b></font>("a${foo}b", placeholderResolver));
76     }
77     @Test
78     public void testNestedLongerPrefix() {
79         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
80         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
81         map.put("foo", "${foo1}");
82         map.put("foo1", "${foo2}");
83         map.put("foo2", "bar");
84         map.put("barbar", "baz");
85         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
86         assertEquals("baz", propertyPlaceholder.replacePlaceholders("${bar${foo}}", placeholderResolver));
87     }
88     @Test
89     public void testNestedSameLengthPrefixSuffix() {
90         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("{", "}", false);
91         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
92         map.put("foo", "{foo1}");
93         map.put("foo1", "{foo2}");
94         map.put("foo2", "bar");
95         map.put("barbar", "baz");
96         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
97         assertEquals("baz", propertyPlaceholder.replacePlaceholders("{bar{foo}}", placeholderResolver));
98     }
99     @Test
100     public void testNestedShorterPrefix() {
101         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("{", "}}", false);
102         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
103         map.put("foo", "{foo1}}");
104         map.put("foo1", "{foo2}}");
105         map.put("foo2", "bar");
106         map.put("barbar", "baz");
107         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
108         assertEquals("baz", propertyPlaceholder.replacePlaceholders("{bar{foo}}}}", placeholderResolver));
109     }
110     @Test
111     public void testCircularReference() {
112         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
113         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
114         map.put("foo", "${bar}");
115         map.put("bar", "${foo}");
116         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, false, true);
117         try {
118             propertyPlaceholder.replacePlaceholders("${foo}", placeholderResolver);
119             fail("Expected IllegalArgumentException");
120         } catch (IllegalArgumentException e) {
121             assertThat(e.getMessage(), is("Circular placeholder reference 'foo' in property definitions"));
122         }
123     }
124     @Test
125     public void testShouldRemoveMissing() {
126         PropertyPlaceholder propertyPlaceholder = new PropertyPlaceholder("${", "}", false);
127         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
128         PropertyPlaceholder.PlaceholderResolver placeholderResolver = new SimplePlaceholderResolver(map, true, false);
129         assertEquals("bar${foo}", propertyPlaceholder.replacePlaceholders("bar${foo}", placeholderResolver));
130     }
131     private class SimplePlaceholderResolver implements PropertyPlaceholder.PlaceholderResolver {
132         private Map&lt;String, String&gt; map;
133         private boolean shouldIgnoreMissing;
134         private boolean shouldRemoveMissing;
135         SimplePlaceholderResolver(Map&lt;String, String&gt; map, boolean shouldIgnoreMissing, boolean shouldRemoveMissing) {
136             this.map = map;
137             this.shouldIgnoreMissing = shouldIgnoreMissing;
138             this.shouldRemoveMissing = shouldRemoveMissing;
139         }
140         @Override
141         public String resolvePlaceholder(String placeholderName) {
142             return map.get(placeholderName);
143         }
144         @Override
145         public boolean shouldIgnoreMissing(String placeholderName) {
146             return shouldIgnoreMissing;
147         }
148         @Override
149         public boolean shouldRemoveMissingPlaceholder(String placeholderName) {
150             return shouldRemoveMissing;
151         }
152     }
153 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PrimaryAllocationIT.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.integrationtests.disruption.routing;
2 import io.crate.common.collections.Sets;
3 import io.crate.integrationtests.SQLIntegrationTestCase;
4 import io.crate.metadata.IndexParts;
5 import org.elasticsearch.cluster.ClusterState;
6 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
7 import org.elasticsearch.cluster.routing.ShardRouting;
8 import org.elasticsearch.cluster.routing.ShardRoutingState;
9 import org.elasticsearch.common.settings.Settings;
10 import org.elasticsearch.gateway.GatewayAllocator;
11 import org.elasticsearch.index.engine.EngineTestCase;
12 import org.elasticsearch.index.shard.IndexShard;
13 import org.elasticsearch.index.shard.IndexShardTestCase;
14 import org.elasticsearch.index.shard.ShardId;
15 import org.elasticsearch.indices.IndicesService;
16 import org.elasticsearch.plugins.Plugin;
17 import org.elasticsearch.test.ESIntegTestCase;
18 import org.elasticsearch.test.InternalTestCluster;
19 import org.elasticsearch.test.disruption.NetworkDisruption;
20 import org.elasticsearch.test.disruption.NetworkDisruption.NetworkDisconnect;
21 import org.elasticsearch.test.disruption.NetworkDisruption.TwoPartitions;
22 import org.elasticsearch.test.junit.annotations.TestLogging;
23 import org.elasticsearch.test.transport.MockTransportService;
24 import org.junit.Before;
25 import org.junit.Test;
26 import java.util.Collection;
27 import java.util.Collections;
28 import java.util.HashSet;
29 import java.util.List;
30 import java.util.Set;
31 import java.util.concurrent.TimeUnit;
32 import static org.hamcrest.CoreMatchers.is;
33 import static org.hamcrest.Matchers.equalTo;
34 import static org.hamcrest.Matchers.hasSize;
35 import static org.hamcrest.Matchers.in;
36 import static org.hamcrest.Matchers.not;
37 @ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)
38 @SQLIntegrationTestCase.Slow
39 public class PrimaryAllocationIT extends SQLIntegrationTestCase {
40     private String schema;
41     private String indexName;
42     @Override
43     protected Collection&lt;Class&lt;? extends Plugin&gt;&gt; nodePlugins() {
44         final HashSet&lt;Class&lt;? extends Plugin&gt;&gt; classes = new HashSet&lt;&gt;(super.nodePlugins());
45         classes.add(MockTransportService.TestPlugin.class);
46         return classes;
47     }
48     @Before
49     public void setupIndexNameAndSchemaForTableT() {
50         schema = sqlExecutor.getCurrentSchema();
51         indexName = IndexParts.toIndexName(schema, "t", null);
52     }
53     private Settings createStaleReplicaScenario(String master, String schema, String indexName) throws Exception {
54         execute("insert into t values ('value1')");
55         refresh();
56         ClusterState state = client().admin().cluster().prepareState().all().get().getState();
57         List&lt;ShardRouting&gt; shards = state.routingTable().allShards(indexName);
58         assertThat(shards.size(), equalTo(2));
59         final String primaryNode;
60         final String replicaNode;
61         if (shards.get(0).primary()) {
62             primaryNode = state.getRoutingNodes().node(shards.get(0).currentNodeId()).node().getName();
63             replicaNode = state.getRoutingNodes().node(shards.get(1).currentNodeId()).node().getName();
64         } else {
65             primaryNode = state.getRoutingNodes().node(shards.get(1).currentNodeId()).node().getName();
66             replicaNode = state.getRoutingNodes().node(shards.get(0).currentNodeId()).node().getName();
67         }
68         NetworkDisruption partition = new NetworkDisruption(
69             new TwoPartitions(Set.of(master, replicaNode), Collections.singleton(primaryNode)),
70             new NetworkDisconnect());
71         internalCluster().setDisruptionScheme(partition);
72         logger.info("--&gt; partitioning node with primary shard from rest of cluster");
73         partition.startDisrupting();
74         ensureStableCluster(2, master);
75         logger.info("--&gt; index a document into previous replica shard (that is now primary)");
76         systemExecute("insert into t values ('value2')", schema, replicaNode);
77         logger.info("--&gt; shut down node that has new acknowledged document");
78         final Settings inSyncDataPathSettings = internalCluster().dataPathSettings(replicaNode);
79         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(replicaNode));
80         ensureStableCluster(1, master);
81         partition.stopDisrupting();
82         logger.info("--&gt; waiting for node with old primary shard to rejoin the cluster");
83         ensureStableCluster(2, master);
84         logger.info("--&gt; check that old primary shard does not get promoted to primary again");
85         client(master).admin().cluster().prepareReroute().get();
86         assertBusy(() -&gt; assertThat(internalCluster().getInstance(GatewayAllocator.class, master).getNumberOfInFlightFetch(),
87             equalTo(0)));
88         assertThat(client(master).admin().cluster().prepareReroute().get().getState().getRoutingNodes().unassigned().size(),
89             equalTo(2));
90         return inSyncDataPathSettings;
91     }
92     @Test
93     public void testDoNotAllowStaleReplicasToBePromotedToPrimary() throws Exception {
94         logger.info("--&gt; starting 3 nodes, 1 master, 2 data");
95         String master = internalCluster().startMasterOnlyNode(Settings.EMPTY);
96         internalCluster().startDataOnlyNode(Settings.EMPTY);
97         internalCluster().startDataOnlyNode(Settings.EMPTY);
98         execute("create table t (x string) clustered into 1 shards with (number_of_replicas = 1, \"write.wait_for_active_shards\" = 1)");
99         ensureGreen();
100 <a name="0"></a>        final Settings inSyncDataPathSettings = createStaleReplicaScenario(master, schema, indexName);
101         logger.info("--&gt; starting node that reuses data folder with the up-to-date primary shard");
102         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>internalCluster().startDataOnlyNode(inSyncDataPathSettings);
103         logger.info("--&gt; check that the up-to-date primary shard gets promoted and that documents are available");
104         ensureYellow(indexName);
105         execute("select * from t");
106         assertThat(response.rowCount(), is(2L));
107     }
108     @Test
109     public void testDoNotRemoveAllocationIdOnNodeLeave() throws Exception {</b></font>
110         internalCluster().startMasterOnlyNode(Settings.EMPTY);
111         internalCluster().startDataOnlyNode(Settings.EMPTY);
112         execute("create table t (x string) clustered into 1 shards with (number_of_replicas = 1, " +
113                 "\"write.wait_for_active_shards\" = 1, \"unassigned.node_left.delayed_timeout\" = 0)");
114         String replicaNode = internalCluster().startDataOnlyNode(Settings.EMPTY);
115         ensureGreen();
116         final Settings inSyncDataPathSettings = internalCluster().dataPathSettings(replicaNode);
117         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(replicaNode));
118         ensureYellow();
119         assertEquals(2, client().admin().cluster().prepareState().get().getState().metadata().index(indexName)
120             .inSyncAllocationIds(0).size());
121         internalCluster().restartRandomDataNode(new InternalTestCluster.RestartCallback() {
122             @Override
123             public boolean clearData(String nodeName) {
124                 return true;
125             }
126         });
127 <a name="1"></a>        logger.info("--&gt; wait until shard is failed and becomes unassigned again");
128         assertBusy(() -&gt; assertTrue(client().admin().cluster().prepareState().get().getState()
129             .getRoutingTable().index(indexName).allPrimaryShardsUnassigned()));
130         assertEquals(2, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>client().admin().cluster().prepareState().get().getState()
131             .metadata().index(indexName).inSyncAllocationIds(0).size());
132         logger.info("--&gt; starting node that reuses data folder with the up-to-date shard");
133         internalCluster().startDataOnlyNode(inSyncDataPathSettings);
134         ensureGreen();
135     }
136     @Test
137     public void testRemoveAllocationIdOnWriteAfterNodeLeave() throws Exception {</b></font>
138         internalCluster().startMasterOnlyNode(Settings.EMPTY);
139         internalCluster().startDataOnlyNode(Settings.EMPTY);
140         execute("create table t (x string) clustered into 1 shards with (number_of_replicas = 1, " +
141                 "\"write.wait_for_active_shards\" = 1, \"unassigned.node_left.delayed_timeout\" = 0)");
142         String replicaNode = internalCluster().startDataOnlyNode(Settings.EMPTY);
143         final Settings inSyncDataPathSettings = internalCluster().dataPathSettings(replicaNode);
144         ensureGreen();
145         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(replicaNode));
146         ensureYellow();
147         assertEquals(2, client().admin().cluster().prepareState().get().getState()
148             .metadata().index(indexName).inSyncAllocationIds(0).size());
149         logger.info("--&gt; inserting row...");
150         execute("insert into t values ('value1')");
151         assertEquals(1, client().admin().cluster().prepareState().get().getState()
152             .metadata().index(indexName).inSyncAllocationIds(0).size());
153         internalCluster().restartRandomDataNode(new InternalTestCluster.RestartCallback() {
154             @Override
155             public boolean clearData(String nodeName) {
156                 return true;
157             }
158         });
159         logger.info("--&gt; wait until shard is failed and becomes unassigned again");
160         assertBusy(() -&gt; assertTrue(client().admin().cluster().prepareState().get().getState()
161             .getRoutingTable().index(indexName).allPrimaryShardsUnassigned()));
162         assertEquals(1, client().admin().cluster().prepareState().get().getState()
163             .metadata().index(indexName).inSyncAllocationIds(0).size());
164 <a name="3"></a>
165         logger.info("--&gt; starting node that reuses data folder with the up-to-date shard");
166         internalCluster().startDataOnlyNode(inSyncDataPathSettings);
167         assertBusy(() -&gt; assertTrue(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>client().admin().cluster().prepareState().get().getState()
168             .getRoutingTable().index(indexName).allPrimaryShardsUnassigned()));
169     }
170     @Test
171     public void testNotWaitForQuorumCopies() throws Exception {</b></font>
172         logger.info("--&gt; starting 3 nodes");
173         List&lt;String&gt; nodes = internalCluster().startNodes(3);
174         int numberOfShards = randomIntBetween(1, 3);
175         logger.info("--&gt; creating index with {} primary and 2 replicas", numberOfShards);
176         execute("create table t (x string) clustered into " + numberOfShards +
177                 " shards with (number_of_replicas = 2)");
178         ensureGreen();
179         execute("insert into t values ('value1')");
180         logger.info("--&gt; removing 2 nodes from cluster");
181         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(nodes.get(1), nodes.get(2)));
182         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(nodes.get(1), nodes.get(2)));
183         internalCluster().restartRandomDataNode();
184         logger.info("--&gt; checking that index still gets allocated with only 1 shard copy being available");
185         ensureYellow();
186         execute("select * from t");
187         assertThat(response.rowCount(), is(1L));
188     }
189     @Test
190     public void testForceAllocatePrimaryOnNoDecision() throws Exception {
191         logger.info("--&gt; starting 1 node");
192         final String node = internalCluster().startNode();
193         logger.info("--&gt; creating index with 1 primary and 0 replicas");
194         execute("create table t (x string) clustered into 1 shards with (number_of_replicas = 0)");
195         logger.info("--&gt; update the settings to prevent allocation to the data node");
196         execute("set global cluster.routing.allocation.exclude._name = '" + node + "'");
197         logger.info("--&gt; full cluster restart");
198         internalCluster().fullRestart();
199         logger.info("--&gt; checking that the primary shard is force allocated to the data node despite being blocked by the exclude filter");
200         ensureGreen();
201         assertEquals(1, client().admin().cluster().prepareState().get().getState()
202                             .routingTable().index(indexName).shardsWithState(ShardRoutingState.STARTED).size());
203     }
204     @TestLogging("_root:DEBUG, org.elasticsearch.cluster.routing.allocation:TRACE, org.elasticsearch.cluster.action.shard:TRACE," +
205                  "org.elasticsearch.indices.recovery:TRACE, org.elasticsearch.cluster.routing.allocation.allocator:TRACE")
206     @Test
207 <a name="2"></a>    public void testPrimaryReplicaResyncFailed() throws Exception {
208         String master = internalCluster().startMasterOnlyNode(Settings.EMPTY);
209         final int numberOfReplicas = between(2, 3);
210         final String oldPrimary = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>internalCluster().startDataOnlyNode();
211         execute("create table t (x string) clustered into 1 shards " +
212                 "with (number_of_replicas = " + numberOfReplicas + ", \"write.wait_for_active_shards\" = 1)");
213         final ShardId shardId = new ShardId(clusterService().state</b></font>().metadata().index(indexName).getIndex(), 0);
214         final Set&lt;String&gt; replicaNodes = new HashSet&lt;&gt;(internalCluster().startDataOnlyNodes(numberOfReplicas));
215         ensureGreen();
216         execute("SET GLOBAL cluster.routing.allocation.enable = 'none'");
217         logger.info("--&gt; Indexing with gap in seqno to ensure that some operations will be replayed in resync");
218         long numDocs = scaledRandomIntBetween(5, 50);
219         for (int i = 0; i &lt; numDocs; i++) {
220             execute("insert into t values ('" + (numDocs + i) + "')");
221         }
222         final IndexShard oldPrimaryShard = internalCluster().getInstance(IndicesService.class, oldPrimary).getShardOrNull(shardId);
223         EngineTestCase.generateNewSeqNo(IndexShardTestCase.getEngine(oldPrimaryShard));         long moreDocs = scaledRandomIntBetween(1, 10);
224         for (int i = 0; i &lt; moreDocs; i++) {
225             execute("insert into t values ('" + (numDocs + i) + "')");
226         }
227         final Set&lt;String&gt; replicasSide1 = Set.copyOf(randomSubsetOf(between(1, numberOfReplicas - 1), replicaNodes));
228         final Set&lt;String&gt; replicasSide2 = Sets.difference(replicaNodes, replicasSide1);
229         NetworkDisruption partition = new NetworkDisruption(new TwoPartitions(replicasSide1, replicasSide2), new NetworkDisconnect());
230         internalCluster().setDisruptionScheme(partition);
231         logger.info("--&gt; isolating some replicas during primary-replica resync");
232         partition.startDisrupting();
233         internalCluster().stopRandomNode(InternalTestCluster.nameFilter(oldPrimary));
234         assertBusy(() -&gt; {
235             ClusterState state = client(master).admin().cluster().prepareState().get().getState();
236             final IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shardId);
237             final String newPrimaryNode = state.getRoutingNodes().node(shardRoutingTable.primaryShard().currentNodeId()).node().getName();
238             assertThat(newPrimaryNode, not(equalTo(oldPrimary)));
239             Set&lt;String&gt; selectedPartition = replicasSide1.contains(newPrimaryNode) ? replicasSide1 : replicasSide2;
240             assertThat(shardRoutingTable.activeShards(), hasSize(selectedPartition.size()));
241             for (ShardRouting activeShard : shardRoutingTable.activeShards()) {
242                 assertThat(state.getRoutingNodes().node(activeShard.currentNodeId()).node().getName(), is(in(selectedPartition)));
243             }
244             assertThat(state.metadata().index(indexName).inSyncAllocationIds(shardId.id()), hasSize(numberOfReplicas + 1));
245         }, 1, TimeUnit.MINUTES);
246         execute("SET GLOBAL cluster.routing.allocation.enable = 'all'");
247         partition.stopDisrupting();
248         partition.ensureHealthy(internalCluster());
249         logger.info("--&gt; stop disrupting network and re-enable allocation");
250         assertBusy(() -&gt; {
251             ClusterState state = client(master).admin().cluster().prepareState().get().getState();
252             assertThat(state.routingTable().shardRoutingTable(shardId).activeShards(), hasSize(numberOfReplicas));
253             assertThat(state.metadata().index(indexName).inSyncAllocationIds(shardId.id()), hasSize(numberOfReplicas + 1));
254             for (String node : replicaNodes) {
255                 IndexShard shard = internalCluster().getInstance(IndicesService.class, node).getShardOrNull(shardId);
256                 assertThat(shard.getLocalCheckpoint(), equalTo(numDocs + moreDocs));
257             }
258         }, 30, TimeUnit.SECONDS);
259         internalCluster().assertConsistentHistoryBetweenTranslogAndLuceneIndex();
260     }
261 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
