<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for IndexModule.java &amp; Decision.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for IndexModule.java &amp; Decision.java
      </h3>
<h1 align="center">
        11.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>IndexModule.java (11.915888%)<th>Decision.java (11.724138%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(47-76)<td><a href="#" name="0">(22-46)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(290-295)<td><a href="#" name="1">(120-125)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(249-257)<td><a href="#" name="2">(87-95)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(113-128)<td><a href="#" name="3">(47-59)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IndexModule.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.index;
2 import org.apache.lucene.store.MMapDirectory;
3 import org.apache.lucene.util.Constants;
4 import org.apache.lucene.util.SetOnce;
5 import io.crate.common.Booleans;
6 import io.crate.types.DataTypes;
7 import org.elasticsearch.common.settings.Setting;
8 import org.elasticsearch.common.settings.Setting.Property;
9 import org.elasticsearch.common.settings.Settings;
10 import org.elasticsearch.common.util.BigArrays;
11 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
12 import org.elasticsearch.env.NodeEnvironment;
13 import org.elasticsearch.index.analysis.AnalysisRegistry;
14 import org.elasticsearch.index.cache.query.DisabledQueryCache;
15 import org.elasticsearch.index.cache.query.IndexQueryCache;
16 import org.elasticsearch.index.cache.query.QueryCache;
17 import org.elasticsearch.index.engine.EngineFactory;
18 import org.elasticsearch.index.mapper.MapperService;
19 import org.elasticsearch.index.shard.IndexEventListener;
20 import org.elasticsearch.index.shard.IndexingOperationListener;
21 import org.elasticsearch.index.store.FsDirectoryFactory;
22 import org.elasticsearch.indices.IndicesQueryCache;
23 <a name="0"></a>import org.elasticsearch.indices.breaker.CircuitBreakerService;
24 import org.elasticsearch.indices.mapper.MapperRegistry;
25 import org.elasticsearch.plugins.IndexStorePlugin;
26 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.elasticsearch.threadpool.ThreadPool;
27 import java.io.IOException;
28 import java.util.ArrayList;
29 import java.util.Collections;
30 import java.util.HashMap;
31 import java.util.HashSet;
32 import java.util.List;
33 import java.util.Map;
34 import java.util.Objects;
35 import java.util.Set;
36 import java.util.concurrent.atomic.AtomicBoolean;
37 import java.util.function.BiFunction;
38 import java.util.function.Consumer;
39 import java.util.function.Function;
40 public final class IndexModule {
41     @Deprecated</b></font>
42     public static final Setting&lt;Boolean&gt; NODE_STORE_ALLOW_MMAPFS = Setting.boolSetting(
43         "node.store.allow_mmapfs", true, Property.NodeScope, Property.Deprecated);
44     public static final Setting&lt;Boolean&gt; NODE_STORE_ALLOW_MMAP = new Setting&lt;&gt;(
45         new Setting.SimpleKey("node.store.allow_mmap"),
46         NODE_STORE_ALLOW_MMAPFS,
47         Booleans::parseBoolean,
48         DataTypes.BOOLEAN,
49         Property.NodeScope
50     );
51     private static final FsDirectoryFactory DEFAULT_DIRECTORY_FACTORY = new FsDirectoryFactory();
52     public static final Setting&lt;String&gt; INDEX_STORE_TYPE_SETTING =
53             new Setting&lt;&gt;("index.store.type", "fs", Function.identity(), DataTypes.STRING, Property.IndexScope, Property.NodeScope);
54     public static final Setting&lt;List&lt;String&gt;&gt; INDEX_STORE_PRE_LOAD_SETTING =
55             Setting.listSetting("index.store.preload", Collections.emptyList(), Function.identity(),
56                     DataTypes.STRING_ARRAY, Property.IndexScope, Property.NodeScope);
57     public static final Setting&lt;Boolean&gt; INDEX_QUERY_CACHE_ENABLED_SETTING =
58             Setting.boolSetting("index.queries.cache.enabled", true, Property.IndexScope);
59     public static final Setting&lt;Boolean&gt; INDEX_QUERY_CACHE_EVERYTHING_SETTING =
60         Setting.boolSetting("index.queries.cache.everything", false, Property.IndexScope);
61     private final IndexSettings indexSettings;
62     private final AnalysisRegistry analysisRegistry;
63 <a name="3"></a>    private final EngineFactory engineFactory;
64     private final Set&lt;IndexEventListener&gt; indexEventListeners = new HashSet&lt;&gt;();
65     private final Map&lt;String, IndexStorePlugin.DirectoryFactory&gt; directoryFactories;
66     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final SetOnce&lt;BiFunction&lt;IndexSettings, IndicesQueryCache, QueryCache&gt;&gt; forceQueryCacheProvider = new SetOnce&lt;&gt;();
67     private final List&lt;IndexingOperationListener&gt; indexOperationListeners = new ArrayList&lt;&gt;();
68     private final AtomicBoolean frozen = new AtomicBoolean(false);
69     public IndexModule(
70             final IndexSettings indexSettings,
71             final AnalysisRegistry analysisRegistry</b></font>,
72             final EngineFactory engineFactory,
73             final Map&lt;String, IndexStorePlugin.DirectoryFactory&gt; directoryFactories) {
74         this.indexSettings = indexSettings;
75         this.analysisRegistry = analysisRegistry;
76         this.engineFactory = Objects.requireNonNull(engineFactory);
77         this.directoryFactories = Collections.unmodifiableMap(directoryFactories);
78     }
79     public &lt;T&gt; void addSettingsUpdateConsumer(Setting&lt;T&gt; setting, Consumer&lt;T&gt; consumer) {
80         ensureNotFrozen();
81         if (setting == null) {
82             throw new IllegalArgumentException("setting must not be null");
83         }
84         indexSettings.getScopedSettings().addSettingsUpdateConsumer(setting, consumer);
85     }
86     public &lt;T&gt; void addSettingsUpdateConsumer(Setting&lt;T&gt; setting, Consumer&lt;T&gt; consumer, Consumer&lt;T&gt; validator) {
87         ensureNotFrozen();
88         if (setting == null) {
89             throw new IllegalArgumentException("setting must not be null");
90         }
91         indexSettings.getScopedSettings().addSettingsUpdateConsumer(setting, consumer, validator);
92     }
93     public Settings getSettings() {
94         return indexSettings.getSettings();
95     }
96     public Index getIndex() {
97         return indexSettings.getIndex();
98     }
99     EngineFactory getEngineFactory() {
100         return engineFactory;
101     }
102     public void addIndexEventListener(IndexEventListener listener) {
103         ensureNotFrozen();
104         if (listener == null) {
105             throw new IllegalArgumentException("listener must not be null");
106         }
107         if (indexEventListeners.contains(listener)) {
108             throw new IllegalArgumentException("listener already added");
109         }
110         this.indexEventListeners.add(listener);
111     }
112     public void addIndexOperationListener(IndexingOperationListener listener) {
113         ensureNotFrozen();
114         if (listener == null) {
115             throw new IllegalArgumentException("listener must not be null");
116         }
117         if (indexOperationListeners.contains(listener)) {
118             throw new IllegalArgumentException("listener already added");
119         }
120         this.indexOperationListeners.add(listener);
121     }
122     IndexEventListener freeze() {         if (this.frozen.compareAndSet(false, true)) {
123             return new CompositeIndexEventListener(indexSettings, indexEventListeners);
124         } else {
125             throw new IllegalStateException("already frozen");
126         }
127     }
128     public static boolean isBuiltinType(String storeType) {
129         for (Type type : Type.values()) {
130             if (type.match(storeType)) {
131                 return true;
132             }
133         }
134         return false;
135     }
136 <a name="2"></a>    public enum Type {
137         HYBRIDFS("hybridfs"),
138         NIOFS("niofs"),
139         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>MMAPFS("mmapfs"),
140         SIMPLEFS("simplefs"),
141         FS("fs");
142         private final String settingsKey;
143         Type(final String settingsKey) {
144             this.settingsKey = settingsKey;
145         }</b></font>
146         private static final Map&lt;String, Type&gt; TYPES;
147         static {
148             final Map&lt;String, Type&gt; types = new HashMap&lt;&gt;(4);
149             for (final Type type : values()) {
150                 types.put(type.settingsKey, type);
151             }
152             TYPES = Collections.unmodifiableMap(types);
153         }
154         public String getSettingsKey() {
155             return this.settingsKey;
156         }
157         public static Type fromSettingsKey(final String key) {
158             final Type type = TYPES.get(key);
159             if (type == null) {
160                 throw new IllegalArgumentException("no matching store type for [" + key + "]");
161             }
162             return type;
163         }
164         public boolean match(String setting) {
165             return getSettingsKey().equals(setting);
166         }
167 <a name="1"></a>
168     }
169     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public static Type defaultStoreType(final boolean allowMmap) {
170         if (allowMmap &amp;&amp; Constants.JRE_IS_64BIT &amp;&amp; MMapDirectory.UNMAP_SUPPORTED) {
171             return Type.HYBRIDFS;
172         } else if (Constants.WINDOWS) {
173             return Type.SIMPLEFS;
174         } else {</b></font>
175             return Type.NIOFS;
176         }
177     }
178     public IndexService newIndexService(
179             IndexService.IndexCreationContext indexCreationContext,
180             NodeEnvironment environment,
181             NamedXContentRegistry xContentRegistry,
182             IndexService.ShardStoreDeleter shardStoreDeleter,
183             CircuitBreakerService circuitBreakerService,
184             BigArrays bigArrays,
185             ThreadPool threadPool,
186             IndicesQueryCache indicesQueryCache,
187             MapperRegistry mapperRegistry) throws IOException {
188         final IndexEventListener eventListener = freeze();
189         eventListener.beforeIndexCreated(indexSettings.getIndex(), indexSettings.getSettings());
190         final IndexStorePlugin.DirectoryFactory directoryFactory = getDirectoryFactory(indexSettings, directoryFactories);
191         final QueryCache queryCache;
192         if (indexSettings.getValue(INDEX_QUERY_CACHE_ENABLED_SETTING)) {
193             BiFunction&lt;IndexSettings, IndicesQueryCache, QueryCache&gt; queryCacheProvider = forceQueryCacheProvider.get();
194             if (queryCacheProvider == null) {
195                 queryCache = new IndexQueryCache(indexSettings, indicesQueryCache);
196             } else {
197                 queryCache = queryCacheProvider.apply(indexSettings, indicesQueryCache);
198             }
199         } else {
200             queryCache = new DisabledQueryCache(indexSettings);
201         }
202         return new IndexService(
203             indexSettings,
204             indexCreationContext,
205             environment,
206             xContentRegistry,
207             shardStoreDeleter,
208             analysisRegistry,
209             engineFactory,
210             circuitBreakerService,
211             bigArrays,
212             threadPool,
213             queryCache,
214             directoryFactory,
215             eventListener,
216             mapperRegistry,
217             indexOperationListeners
218         );
219     }
220     private static IndexStorePlugin.DirectoryFactory getDirectoryFactory(
221             final IndexSettings indexSettings, final Map&lt;String, IndexStorePlugin.DirectoryFactory&gt; indexStoreFactories) {
222         final String storeType = indexSettings.getValue(INDEX_STORE_TYPE_SETTING);
223         final Type type;
224         final Boolean allowMmap = NODE_STORE_ALLOW_MMAP.getWithFallback(indexSettings.getNodeSettings());
225         if (storeType.isEmpty() || Type.FS.getSettingsKey().equals(storeType)) {
226             type = defaultStoreType(allowMmap);
227         } else {
228             if (isBuiltinType(storeType)) {
229                 type = Type.fromSettingsKey(storeType);
230             } else {
231                 type = null;
232             }
233         }
234         if (allowMmap == false &amp;&amp; (type == Type.MMAPFS || type == Type.HYBRIDFS)) {
235             throw new IllegalArgumentException("store type [" + storeType + "] is not allowed because mmap is disabled");
236         }
237         final IndexStorePlugin.DirectoryFactory factory;
238         if (storeType.isEmpty() || isBuiltinType(storeType)) {
239             factory = DEFAULT_DIRECTORY_FACTORY;
240         } else {
241             factory = indexStoreFactories.get(storeType);
242             if (factory == null) {
243                 throw new IllegalArgumentException("Unknown store type [" + storeType + "]");
244             }
245         }
246         return factory;
247     }
248     public MapperService newIndexMapperService(NamedXContentRegistry xContentRegistry, MapperRegistry mapperRegistry) throws IOException {
249         return new MapperService(
250             indexSettings,
251             analysisRegistry.build(indexSettings),
252             xContentRegistry,
253             mapperRegistry,
254             () -&gt; {
255                 throw new UnsupportedOperationException("no index query shard context available");
256             }
257         );
258     }
259     public void forceQueryCacheProvider(BiFunction&lt;IndexSettings, IndicesQueryCache, QueryCache&gt; queryCacheProvider) {
260         ensureNotFrozen();
261         this.forceQueryCacheProvider.set(queryCacheProvider);
262     }
263     private void ensureNotFrozen() {
264         if (this.frozen.get()) {
265             throw new IllegalStateException("Can't modify IndexModule once the index service has been created");
266         }
267     }
268 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Decision.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.cluster.routing.allocation.decider;
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import javax.annotation.Nullable;
4 import org.elasticsearch.common.io.stream.StreamInput;
5 import org.elasticsearch.common.io.stream.StreamOutput;
6 import org.elasticsearch.common.io.stream.Writeable;
7 import org.elasticsearch.common.xcontent.ToXContent;
8 import org.elasticsearch.common.xcontent.ToXContentFragment;
9 import org.elasticsearch.common.xcontent.ToXContentObject;
10 import org.elasticsearch.common.xcontent.XContentBuilder;
11 import java.io.IOException;
12 import java.util.ArrayList;
13 import java.util.Collections;
14 import java.util.List;
15 import java.util.Locale;
16 import java.util.Objects;
17 <a name="3"></a>public abstract class Decision implements ToXContent, Writeable {
18     public static final Decision ALWAYS = new Single(Type.YES)</b></font>;
19     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>public static final Decision YES = new Single(Type.YES);
20     public static final Decision NO = new Single(Type.NO);
21     public static final Decision THROTTLE = new Single(Type.THROTTLE);
22     public static Decision single(Type type, @Nullable String label</b></font>, @Nullable String explanation, @Nullable Object... explanationParams) {
23         return new Single(type, label, explanation, explanationParams);
24     }
25     public static Decision readFrom(StreamInput in) throws IOException {
26         if (in.readBoolean()) {
27             Multi result = new Multi();
28             int decisionCount = in.readVInt();
29             for (int i = 0; i &lt; decisionCount; i++) {
30                 Decision s = readFrom(in);
31                 result.decisions.add(s);
32             }
33             return result;
34         } else {
35             Single result = new Single();
36             result.type = Type.readFrom(in);
37             result.label = in.readOptionalString();
38             result.explanationString = in.readOptionalString();
39             return result;
40         }
41     }
42     public enum Type implements Writeable {
43         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>YES(1),
44         THROTTLE(2),
45         NO(0);
46         private final int id;
47         Type(int id) {
48             this.id = id;
49         }</b></font>
50         public static Type resolve(String s) {
51             return Type.valueOf(s.toUpperCase(Locale.ROOT));
52         }
53         public static Type readFrom(StreamInput in) throws IOException {
54             int i = in.readVInt();
55             switch (i) {
56                 case 0:
57                     return NO;
58                 case 1:
59                     return YES;
60                 case 2:
61                     return THROTTLE;
62                 default:
63                     throw new IllegalArgumentException("No Type for integer [" + i + "]");
64             }
65         }
66         @Override
67         public void writeTo(StreamOutput out) throws IOException {
68 <a name="1"></a>            out.writeVInt(id);
69         }
70         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>public boolean higherThan(Type other) {
71             if (this == NO) {
72                 return false;
73             } else if (other == NO) {
74                 return true;
75             } else if (</b></font>other == THROTTLE &amp;&amp; this == YES) {
76                 return true;
77             }
78             return false;
79         }
80     }
81     public abstract Type type();
82     @Nullable
83     public abstract String label();
84     @Nullable
85     public abstract String getExplanation();
86     public abstract List&lt;Decision&gt; getDecisions();
87     public static class Single extends Decision implements ToXContentObject {
88         private Type type;
89         private String label;
90         private String explanation;
91         private String explanationString;
92         private Object[] explanationParams;
93         public Single() {
94         }
95         public Single(Type type) {
96             this(type, null, null, (Object[]) null);
97         }
98         public Single(Type type, @Nullable String label, @Nullable String explanation, @Nullable Object... explanationParams) {
99             this.type = type;
100             this.label = label;
101             this.explanation = explanation;
102             this.explanationParams = explanationParams;
103         }
104         @Override
105         public Type type() {
106             return this.type;
107         }
108         @Override
109         @Nullable
110         public String label() {
111             return this.label;
112         }
113         @Override
114         public List&lt;Decision&gt; getDecisions() {
115             return Collections.singletonList(this);
116         }
117         @Override
118         @Nullable
119         public String getExplanation() {
120             if (explanationString == null &amp;&amp; explanation != null) {
121                 explanationString = String.format(Locale.ROOT, explanation, explanationParams);
122             }
123             return this.explanationString;
124         }
125         @Override
126         public boolean equals(Object object) {
127             if (this == object) {
128                 return true;
129             }
130             if (object == null || getClass() != object.getClass()) {
131                 return false;
132             }
133             Decision.Single s = (Decision.Single) object;
134             return this.type == s.type &amp;&amp;
135                        Objects.equals(label, s.label) &amp;&amp;
136                        Objects.equals(getExplanation(), s.getExplanation());
137         }
138         @Override
139         public int hashCode() {
140             int result = type.hashCode();
141             result = 31 * result + (label == null ? 0 : label.hashCode());
142             String explanationStr = getExplanation();
143             result = 31 * result + (explanationStr == null ? 0 : explanationStr.hashCode());
144             return result;
145         }
146         @Override
147         public String toString() {
148             if (explanationString != null || explanation != null) {
149                 return type + "(" + getExplanation() + ")";
150             }
151             return type + "()";
152         }
153         @Override
154         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
155             builder.startObject();
156             builder.field("decider", label);
157             builder.field("decision", type);
158             String explanation = getExplanation();
159             builder.field("explanation", explanation != null ? explanation : "none");
160             builder.endObject();
161             return builder;
162         }
163         @Override
164         public void writeTo(StreamOutput out) throws IOException {
165             out.writeBoolean(false);             type.writeTo(out);
166             out.writeOptionalString(label);
167             out.writeOptionalString(getExplanation());
168         }
169     }
170     public static class Multi extends Decision implements ToXContentFragment {
171         private final List&lt;Decision&gt; decisions = new ArrayList&lt;&gt;();
172         public Multi add(Decision decision) {
173             decisions.add(decision);
174             return this;
175         }
176         @Override
177         public Type type() {
178             Type ret = Type.YES;
179             for (int i = 0; i &lt; decisions.size(); i++) {
180                 Type type = decisions.get(i).type();
181                 if (type == Type.NO) {
182                     return type;
183                 } else if (type == Type.THROTTLE) {
184                     ret = type;
185                 }
186             }
187             return ret;
188         }
189         @Override
190         @Nullable
191         public String label() {
192             return null;
193         }
194         @Override
195         @Nullable
196         public String getExplanation() {
197             throw new UnsupportedOperationException("multi-level decisions do not have an explanation");
198         }
199         @Override
200         public List&lt;Decision&gt; getDecisions() {
201             return Collections.unmodifiableList(this.decisions);
202         }
203         @Override
204         public boolean equals(final Object object) {
205             if (this == object) {
206                 return true;
207             }
208             if (object == null || getClass() != object.getClass()) {
209                 return false;
210             }
211             final Decision.Multi m = (Decision.Multi) object;
212             return this.decisions.equals(m.decisions);
213         }
214         @Override
215         public int hashCode() {
216             return 31 * decisions.hashCode();
217         }
218         @Override
219         public String toString() {
220             StringBuilder sb = new StringBuilder();
221             for (Decision decision : decisions) {
222                 sb.append("[").append(decision.toString()).append("]");
223             }
224             return sb.toString();
225         }
226         @Override
227         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
228             for (Decision d : decisions) {
229                 d.toXContent(builder, params);
230             }
231             return builder;
232         }
233         @Override
234         public void writeTo(StreamOutput out) throws IOException {
235             out.writeBoolean(true);             out.writeVInt(getDecisions().size());
236             for (Decision d : getDecisions()) {
237                 d.writeTo(out);
238             }
239         }
240     }
241 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
