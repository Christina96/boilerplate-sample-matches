<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for WebSocketCloseStatusTest.java &amp; HttpResponseDecoderTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WebSocketCloseStatusTest.java &amp; HttpResponseDecoderTest.java
      </h3>
<h1 align="center">
        16.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WebSocketCloseStatusTest.java (69.9422%)<th>HttpResponseDecoderTest.java (9.438377%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(57-75)<td><a href="#" name="0">(683-703)</a><td align="center"><font color="#ff0000">35</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(76-87)<td><a href="#" name="1">(313-325)</a><td align="center"><font color="#a00000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(91-103)<td><a href="#" name="2">(467-477)</a><td align="center"><font color="#8a0000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(128-137)<td><a href="#" name="3">(68-80)</a><td align="center"><font color="#7b0000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(13-31)<td><a href="#" name="4">(16-32)</a><td align="center"><font color="#6d0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(104-118)<td><a href="#" name="5">(60-67)</a><td align="center"><font color="#5e0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketCloseStatusTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.http.websocketx;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import org.assertj.core.api.ThrowableAssert;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertSame;
import</b></font> static io.netty.handler.codec.http.websocketx.WebSocketCloseStatus.*;
public class WebSocketCloseStatusTest {
    private final List&lt;WebSocketCloseStatus&gt; validCodes = Arrays.asList(
        NORMAL_CLOSURE,
        ENDPOINT_UNAVAILABLE,
        PROTOCOL_ERROR,
        INVALID_MESSAGE_TYPE,
        INVALID_PAYLOAD_DATA,
        POLICY_VIOLATION,
        MESSAGE_TOO_BIG,
        MANDATORY_EXTENSION,
        INTERNAL_SERVER_ERROR,
        SERVICE_RESTART,
        TRY_AGAIN_LATER,
        BAD_GATEWAY
    );
    @Test
    public void testToString() {
        assertEquals("1000 Bye", NORMAL_CLOSURE.toString());
    }
<a name="0"></a>
    @Test
    public void testKnownStatuses() {
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertSame(NORMAL_CLOSURE, valueOf(1000));
        assertSame(ENDPOINT_UNAVAILABLE, valueOf(1001));
        assertSame(PROTOCOL_ERROR, valueOf(1002));
        assertSame(INVALID_MESSAGE_TYPE, valueOf(1003));
        assertSame(EMPTY, valueOf(1005));
        assertSame(ABNORMAL_CLOSURE, valueOf(1006));
        assertSame(INVALID_PAYLOAD_DATA, valueOf(1007));
        assertSame(POLICY_VIOLATION, valueOf(1008));
        assertSame(MESSAGE_TOO_BIG, valueOf(1009));
        assertSame(MANDATORY_EXTENSION, valueOf(1010));
        assertSame(INTERNAL_SERVER_ERROR, valueOf(1011));
        assertSame(SERVICE_RESTART, valueOf(1012));
        assertSame(TRY_AGAIN_LATER, valueOf(1013));
        assertSame(BAD_GATEWAY, valueOf(1014));
        assertSame(TLS_HANDSHAKE_FAILED, valueOf(1015));
    }
<a name="1"></a>
    @Test
    public void testNaturalOrder() {</b></font>
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(PROTOCOL_ERROR, Matchers.greaterThan(NORMAL_CLOSURE));
        assertThat(PROTOCOL_ERROR, Matchers.greaterThan(valueOf(1001)));
        assertThat(PROTOCOL_ERROR, Matchers.comparesEqualTo(PROTOCOL_ERROR));
        assertThat(PROTOCOL_ERROR, Matchers.comparesEqualTo(valueOf(1002)));
        assertThat(PROTOCOL_ERROR, Matchers.lessThan(INVALID_MESSAGE_TYPE));
        assertThat(PROTOCOL_ERROR, Matchers.lessThan(valueOf(1007)));
    }
    @Test
    public void testUserDefinedStatuses() {
        WebSocketCloseStatus feedTimeot = new</b></font> WebSocketCloseStatus(6033, "Feed timed out");
<a name="2"></a>        WebSocketCloseStatus untradablePrice = new WebSocketCloseStatus(6034, "Untradable price");
        <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertNotSame(feedTimeot, valueOf(6033));
        assertEquals(feedTimeot.code(), 6033);
        assertEquals(feedTimeot.reasonText(), "Feed timed out");
        assertNotSame(untradablePrice, valueOf(6034));
        assertEquals(untradablePrice.code(), 6034);
        assertEquals(untradablePrice.reasonText(), "Untradable price");
    }
    @Test
<a name="5"></a>    public void testRfc6455CodeValidation() {
        List&lt;Integer&gt; knownCodes = Arrays.asList</b></font>(
            <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>NORMAL_CLOSURE.code(),
            ENDPOINT_UNAVAILABLE.code(),
            PROTOCOL_ERROR.code(),
            INVALID_MESSAGE_TYPE.code(),
            INVALID_PAYLOAD_DATA.code(),
            POLICY_VIOLATION.code(),
            MESSAGE_TOO_BIG.code(),
            MANDATORY_EXTENSION.code(),
            INTERNAL_SERVER_ERROR.code(),
            SERVICE_RESTART.code(),
            TRY_AGAIN_LATER.code(),
            BAD_GATEWAY.code()
        );
        SortedSet&lt;Integer&gt; invalidCodes = new TreeSet&lt;Integer&gt;()</b></font>;
        for (int statusCode = Short.MIN_VALUE; statusCode &lt; Short.MAX_VALUE; statusCode++) {
            if (!isValidStatusCode(statusCode)) {
                invalidCodes.add(statusCode);
            }
<a name="3"></a>        }
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(0, invalidCodes.first().intValue());
        assertEquals(2999, invalidCodes.last().intValue());
        assertEquals(3000 - validCodes.size(), invalidCodes.size());
        invalidCodes.retainAll(knownCodes);
        assertEquals(invalidCodes, Collections.emptySet());
    }
    @Test
    public void testValidationEnabled() {</b></font>
        assertThatExceptionOfType(IllegalArgumentException.class)
                .isThrownBy(new ThrowableAssert.ThrowingCallable() {
                    @Override
                    public void call() throws RuntimeException {
                        new WebSocketCloseStatus(1006, "validation disabled");
                    }
                });
    }
    @Test
    public void testValidationDisabled() {
        WebSocketCloseStatus status = new WebSocketCloseStatus(1006, "validation disabled", false);
        assertEquals(1006, status.code());
        assertEquals("validation disabled", status.reasonText());
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HttpResponseDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec.http;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.PrematureChannelClosureException;
import io.netty.util.CharsetUtil;
import org.junit.jupiter.api.Test;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import static io.netty.handler.codec.http.HttpHeadersTestUtils.of;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import</b></font> static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
public class HttpResponseDecoderTest {
    @Test
    public void testMaxHeaderSize1() {
        final int maxHeaderSize = 8192;
        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));
        final char[] bytes = new char[maxHeaderSize / 2 - 4];
        Arrays.fill(bytes, 'a');
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n", CharsetUtil.US_ASCII));
<a name="5"></a>                ch.writeInbound(Unpooled.copiedBuffer("A:", CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
        <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
        assertNull(ch.readInbound());
        ch.writeInbound(Unpooled.copiedBuffer("B:", CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
<a name="3"></a>        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound()</b></font>;
        assertNull(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>res.decoderResult().cause());
        assertTrue(res.decoderResult().isSuccess());
        assertNull(ch.readInbound());
        assertTrue(ch.finish());
        assertThat(ch.readInbound(), instanceOf(LastHttpContent.class));
    }
    @Test
    public void testMaxHeaderSize2() {</b></font>
        final int maxHeaderSize = 8192;
        final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));
        final char[] bytes = new char[maxHeaderSize / 2 - 2];
        Arrays.fill(bytes, 'a');
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n", CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer("A:", CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
        assertNull(ch.readInbound());
        ch.writeInbound(Unpooled.copiedBuffer("B: ", CharsetUtil.US_ASCII));         ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertTrue(res.decoderResult().cause() instanceof TooLongHttpHeaderException);
        assertFalse(ch.finish());
        assertNull(ch.readInbound());
    }
    @Test
    public void testResponseChunked() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n",
                CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        byte[] data = new byte[64];
        for (int i = 0; i &lt; data.length; i++) {
            data[i] = (byte) i;
        }
        for (int i = 0; i &lt; 10; i++) {
            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + "\r\n",
                    CharsetUtil.US_ASCII)));
            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));
            HttpContent content = ch.readInbound();
            assertEquals(data.length, content.content().readableBytes());
            byte[] decodedData = new byte[data.length];
            content.content().readBytes(decodedData);
            assertArrayEquals(data, decodedData);
            content.release();
            assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
        }
        ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
        LastHttpContent content = ch.readInbound();
        assertFalse(content.content().isReadable());
        content.release();
        ch.finish();
        assertNull(ch.readInbound());
    }
    @Test
    public void testResponseDisallowPartialChunks() {
        HttpResponseDecoder decoder = new HttpResponseDecoder(
            HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH,
            HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE,
            HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE,
            HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS,
            HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE,
            HttpObjectDecoder.DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS,
            false);
        EmbeddedChannel ch = new EmbeddedChannel(decoder);
        String headers = "HTTP/1.1 200 OK\r\n"
            + "Transfer-Encoding: chunked\r\n"
            + "\r\n";
       assertTrue(ch.writeInbound(Unpooled.copiedBuffer(headers, CharsetUtil.US_ASCII)));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        byte[] chunkBytes = new byte[10];
        Random random = new Random();
        random.nextBytes(chunkBytes);
        final ByteBuf chunk = ch.alloc().buffer().writeBytes(chunkBytes);
        final int chunkSize = chunk.readableBytes();
        ByteBuf partialChunk1 = chunk.retainedSlice(0, 5);
        ByteBuf partialChunk2 = chunk.retainedSlice(5, 5);
        assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(chunkSize)
                                                          + "\r\n", CharsetUtil.US_ASCII)));
        assertFalse(ch.writeInbound(partialChunk1));
        assertTrue(ch.writeInbound(partialChunk2));
        HttpContent content = ch.readInbound();
        assertEquals(chunk, content.content());
        content.release();
        chunk.release();
        assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
        assertTrue(ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII)));
        HttpContent lastContent = ch.readInbound();
        assertFalse(lastContent.content().isReadable());
        lastContent.release();
        assertFalse(ch.finish());
    }
    @Test
    public void testResponseChunkedExceedMaxChunkSize() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, 8192, 32));
        ch.writeInbound(
                Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        byte[] data = new byte[64];
        for (int i = 0; i &lt; data.length; i++) {
            data[i] = (byte) i;
        }
        for (int i = 0; i &lt; 10; i++) {
            assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + "\r\n",
                    CharsetUtil.US_ASCII)));
            assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));
            byte[] decodedData = new byte[data.length];
            HttpContent content = ch.readInbound();
            assertEquals(32, content.content().readableBytes());
            content.content().readBytes(decodedData, 0, 32);
            content.release();
            content = ch.readInbound();
            assertEquals(32, content.content().readableBytes());
            content.content().readBytes(decodedData, 32, 32);
            assertArrayEquals(data, decodedData);
            content.release();
            assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
        }
        ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
        LastHttpContent content = ch.readInbound();
        assertFalse(content.content().isReadable());
        content.release();
        ch.finish();
        assertNull(ch.readInbound());
    }
    @Test
    public void testClosureWithoutContentLength1() throws Exception {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        assertThat(ch.readInbound(), is(nullValue()));
        assertTrue(ch.finish());
        LastHttpContent content = ch.readInbound();
        assertThat(content.content().isReadable(), is(false));
        content.release();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testClosureWithoutContentLength2() throws Exception {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n12345678", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        HttpContent content = ch.readInbound();
        assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
        assertThat(content, is(not(instanceOf(LastHttpContent.class))));
        content.release();
        assertThat(ch.readInbound(), is(nullValue()));
        assertTrue(ch.finish());
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        lastContent.release();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testPrematureClosureWithChunkedEncoding1() throws Exception {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(
                Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
<a name="1"></a>                HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>res.status(), is(HttpResponseStatus.OK));
        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
        assertThat(ch.readInbound(), is(nullValue()));
        ch.finish();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testPrematureClosureWithChunkedEncoding2() throws Exception {
        EmbeddedChannel ch = new</b></font> EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(
                "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n8\r\n12345678", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
        HttpContent content = ch.readInbound();
        assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
        assertThat(content, is(not(instanceOf(LastHttpContent.class))));
        content.release();
        assertThat(ch.readInbound(), is(nullValue()));
        ch.finish();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testLastResponseWithEmptyHeaderAndEmptyContent() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        assertThat(ch.readInbound(), is(nullValue()));
        assertThat(ch.finish(), is(true));
        LastHttpContent content = ch.readInbound();
        assertThat(content.content().isReadable(), is(false));
        content.release();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testLastResponseWithoutContentLengthHeader() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        assertThat(ch.readInbound(), is(nullValue()));
        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
        HttpContent content = ch.readInbound();
        assertThat(content.content().readableBytes(), is(1024));
        content.release();
        assertThat(ch.finish(), is(true));
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        lastContent.release();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testLastResponseWithHeaderRemoveTrailingSpaces() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(
                "HTTP/1.1 200 OK\r\nX-Header: h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT       \r\n\r\n",
                CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        assertThat(res.headers().get(of("X-Header")), is("h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
        assertThat(ch.readInbound(), is(nullValue()));
        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
        HttpContent content = ch.readInbound();
        assertThat(content.content().readableBytes(), is(1024));
        content.release();
        assertThat(ch.finish(), is(true));
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        lastContent.release();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testResetContentResponseWithTransferEncoding() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(
                "HTTP/1.1 205 Reset Content\r\n" +
                "Transfer-Encoding: chunked\r\n" +
                "\r\n" +
                "0\r\n" +
                "\r\n",
                CharsetUtil.US_ASCII)));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.RESET_CONTENT));
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        lastContent.release();
        assertThat(ch.finish(), is(false));
    }
    @Test
    public void testLastResponseWithTrailingHeader() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(
                "HTTP/1.1 200 OK\r\n" +
                        "Transfer-Encoding: chunked\r\n" +
                        "\r\n" +
                        "0\r\n" +
                        "Set-Cookie: t1=t1v1\r\n" +
                        "Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\r\n" +
                        "\r\n",
                CharsetUtil.US_ASCII));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        HttpHeaders headers = lastContent.trailingHeaders();
<a name="2"></a>        assertEquals(1, headers.names().size());
        List&lt;String&gt; values = headers.getAll(of("Set-Cookie"));
        assertEquals(2, values.size());
        <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(values.contains("t1=t1v1"));
        assertTrue(values.contains("t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
        lastContent.release();
        assertThat(ch.finish(), is(false));
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testLastResponseWithTrailingHeaderFragmented() {
        byte[] data = ("HTTP/1.1 200 OK\r\n" +</b></font>
                "Transfer-Encoding: chunked\r\n" +
                "\r\n" +
                "0\r\n" +
                "Set-Cookie: t1=t1v1\r\n" +
                "Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\r\n" +
                "\r\n").getBytes(CharsetUtil.US_ASCII);
        for (int i = 1; i &lt; data.length; i++) {
            testLastResponseWithTrailingHeaderFragmented(data, i);
        }
    }
    private static void testLastResponseWithTrailingHeaderFragmented(byte[] content, int fragmentSize) {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        int headerLength = 47;
        for (int a = 0; a &lt; headerLength;) {
            int amount = fragmentSize;
            if (a + amount &gt; headerLength) {
                amount = headerLength -  a;
            }
            boolean headerDone = a + amount == headerLength;
            assertEquals(headerDone, ch.writeInbound(Unpooled.copiedBuffer(content, a, amount)));
            a += amount;
        }
        ch.writeInbound(Unpooled.copiedBuffer(content, headerLength, content.length - headerLength));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        LastHttpContent lastContent = ch.readInbound();
        assertThat(lastContent.content().isReadable(), is(false));
        HttpHeaders headers = lastContent.trailingHeaders();
        assertEquals(1, headers.names().size());
        List&lt;String&gt; values = headers.getAll(of("Set-Cookie"));
        assertEquals(2, values.size());
        assertTrue(values.contains("t1=t1v1"));
        assertTrue(values.contains("t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
        lastContent.release();
        assertThat(ch.finish(), is(false));
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testResponseWithContentLength() {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(
                "HTTP/1.1 200 OK\r\n" +
                        "Content-Length: 10\r\n" +
                        "\r\n", CharsetUtil.US_ASCII));
        byte[] data = new byte[10];
        for (int i = 0; i &lt; data.length; i++) {
            data[i] = (byte) i;
        }
        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));
        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        HttpContent firstContent = ch.readInbound();
        assertThat(firstContent.content().readableBytes(), is(5));
        assertEquals(Unpooled.copiedBuffer(data, 0, 5), firstContent.content());
        firstContent.release();
        LastHttpContent lastContent = ch.readInbound();
        assertEquals(5, lastContent.content().readableBytes());
        assertEquals(Unpooled.copiedBuffer(data, 5, 5), lastContent.content());
        lastContent.release();
        assertThat(ch.finish(), is(false));
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testResponseWithContentLengthFragmented() {
        byte[] data = ("HTTP/1.1 200 OK\r\n" +
                "Content-Length: 10\r\n" +
                "\r\n").getBytes(CharsetUtil.US_ASCII);
        for (int i = 1; i &lt; data.length; i++) {
            testResponseWithContentLengthFragmented(data, i);
        }
    }
    private static void testResponseWithContentLengthFragmented(byte[] header, int fragmentSize) {
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        for (int a = 0; a &lt; header.length;) {
            int amount = fragmentSize;
            if (a + amount &gt; header.length) {
                amount = header.length -  a;
            }
            ch.writeInbound(Unpooled.copiedBuffer(header, a, amount));
            a += amount;
        }
        byte[] data = new byte[10];
        for (int i = 0; i &lt; data.length; i++) {
            data[i] = (byte) i;
        }
        ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));
        ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.OK));
        HttpContent firstContent = ch.readInbound();
        assertThat(firstContent.content().readableBytes(), is(5));
        assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());
        firstContent.release();
        LastHttpContent lastContent = ch.readInbound();
        assertEquals(5, lastContent.content().readableBytes());
        assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());
        lastContent.release();
        assertThat(ch.finish(), is(false));
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testWebSocketResponse() {
        byte[] data = ("HTTP/1.1 101 WebSocket Protocol Handshake\r\n" +
                "Upgrade: WebSocket\r\n" +
                "Connection: Upgrade\r\n" +
                "Sec-WebSocket-Origin: http://localhost:8080\r\n" +
                "Sec-WebSocket-Location: ws://localhost/some/path\r\n" +
                "\r\n" +
                "1234567812345678").getBytes();
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.wrappedBuffer(data));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
        HttpContent content = ch.readInbound();
        assertThat(content.content().readableBytes(), is(16));
        content.release();
        assertThat(ch.finish(), is(false));
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testWebSocketResponseWithDataFollowing() {
        byte[] data = ("HTTP/1.1 101 WebSocket Protocol Handshake\r\n" +
                "Upgrade: WebSocket\r\n" +
                "Connection: Upgrade\r\n" +
                "Sec-WebSocket-Origin: http://localhost:8080\r\n" +
                "Sec-WebSocket-Location: ws://localhost/some/path\r\n" +
                "\r\n" +
                "1234567812345678").getBytes();
        byte[] otherData = {1, 2, 3, 4};
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(data, otherData));
        HttpResponse res = ch.readInbound();
        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
        HttpContent content = ch.readInbound();
        assertThat(content.content().readableBytes(), is(16));
        content.release();
        assertThat(ch.finish(), is(true));
        ByteBuf expected = Unpooled.wrappedBuffer(otherData);
        ByteBuf buffer = ch.readInbound();
        try {
            assertEquals(expected, buffer);
        } finally {
            expected.release();
            if (buffer != null) {
                buffer.release();
            }
        }
    }
    @Test
    public void testGarbageHeaders() {
        byte[] data = ("&lt;html&gt;\r\n" +
                "&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;\r\n" +
                "&lt;body bgcolor=\"white\"&gt;\r\n" +
                "&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;\r\n" +
                "&lt;hr&gt;&lt;center&gt;nginx/1.1.19&lt;/center&gt;\r\n" +
                "&lt;/body&gt;\r\n" +
                "&lt;/html&gt;\r\n").getBytes();
        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
        ch.writeInbound(Unpooled.copiedBuffer(data));
<a name="0"></a>
        HttpResponse res = ch.readInbound();
        <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_0));
        assertThat(res.status().code(), is(999));
        assertThat(res.decoderResult().isFailure(), is(true));
        assertThat(res.decoderResult().isFinished(), is(true));
        assertThat(ch.readInbound(), is(nullValue()));
        ch.writeInbound(Unpooled.copiedBuffer(data));
        assertThat(ch.readInbound(), is(nullValue()));
        ch.finish();
        assertThat(ch.readInbound(), is(nullValue()));
    }
    @Test
    public void testGarbageChunk() {</b></font>
        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
        String responseWithIllegalChunk =
                "HTTP/1.1 200 OK\r\n" +
                "Transfer-Encoding: chunked\r\n\r\n" +
                "NOT_A_CHUNK_LENGTH\r\n";
        channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));
        assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));
        LastHttpContent invalidChunk = channel.readInbound();
        assertThat(invalidChunk.decoderResult().isFailure(), is(true));
        invalidChunk.release();
        assertThat(channel.readInbound(), is(nullValue()));
        assertThat(channel.finish(), is(false));
    }
    @Test
    public void testConnectionClosedBeforeHeadersReceived() {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
        String responseInitialLine =
                "HTTP/1.1 200 OK\r\n";
        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(responseInitialLine, CharsetUtil.US_ASCII)));
        assertTrue(channel.finish());
        HttpMessage message = channel.readInbound();
        assertTrue(message.decoderResult().isFailure());
        assertThat(message.decoderResult().cause(), instanceOf(PrematureChannelClosureException.class));
        assertNull(channel.readInbound());
    }
    @Test
    public void testTrailerWithEmptyLineInSeparateBuffer() {
        HttpResponseDecoder decoder = new HttpResponseDecoder();
        EmbeddedChannel channel = new EmbeddedChannel(decoder);
        String headers = "HTTP/1.1 200 OK\r\n"
                + "Transfer-Encoding: chunked\r\n"
                + "Trailer: My-Trailer\r\n";
        assertFalse(channel.writeInbound(Unpooled.copiedBuffer(headers.getBytes(CharsetUtil.US_ASCII))));
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer("\r\n".getBytes(CharsetUtil.US_ASCII))));
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer("0\r\n", CharsetUtil.US_ASCII)));
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer("My-Trailer: 42\r\n", CharsetUtil.US_ASCII)));
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
        HttpResponse response = channel.readInbound();
        assertEquals(2, response.headers().size());
        assertEquals("chunked", response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));
        assertEquals("My-Trailer", response.headers().get(HttpHeaderNames.TRAILER));
        LastHttpContent lastContent = channel.readInbound();
        assertEquals(1, lastContent.trailingHeaders().size());
        assertEquals("42", lastContent.trailingHeaders().get("My-Trailer"));
        assertEquals(0, lastContent.content().readableBytes());
        lastContent.release();
        assertFalse(channel.finish());
    }
    @Test
    public void testWhitespace() {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
        String requestStr = "HTTP/1.1 200 OK\r\n" +
                "Transfer-Encoding : chunked\r\n" +
                "Host: netty.io\n\r\n";
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpResponse response = channel.readInbound();
        assertFalse(response.decoderResult().isFailure());
        assertEquals(HttpHeaderValues.CHUNKED.toString(), response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));
        assertEquals("netty.io", response.headers().get(HttpHeaderNames.HOST));
        assertFalse(channel.finish());
    }
    @Test
    public void testHttpMessageDecoderResult() {
        String responseStr = "HTTP/1.1 200 OK\r\n" +
                "Content-Length: 11\r\n" +
                "Connection: close\r\n\r\n" +
                "Lorem ipsum";
        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(responseStr, CharsetUtil.US_ASCII)));
        HttpResponse response = channel.readInbound();
        assertTrue(response.decoderResult().isSuccess());
        assertThat(response.decoderResult(), instanceOf(HttpMessageDecoderResult.class));
        HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) response.decoderResult();
        assertThat(decoderResult.initialLineLength(), is(15));
        assertThat(decoderResult.headerSize(), is(35));
        assertThat(decoderResult.totalSize(), is(50));
        HttpContent c = channel.readInbound();
        c.release();
        assertFalse(channel.finish());
    }
    @Test
    public void testHeaderNameStartsWithControlChar1c() {
        testHeaderNameStartsWithControlChar(0x1c);
    }
    @Test
    public void testHeaderNameStartsWithControlChar1d() {
        testHeaderNameStartsWithControlChar(0x1d);
    }
    @Test
    public void testHeaderNameStartsWithControlChar1e() {
        testHeaderNameStartsWithControlChar(0x1e);
    }
    @Test
    public void testHeaderNameStartsWithControlChar1f() {
        testHeaderNameStartsWithControlChar(0x1f);
    }
    @Test
    public void testHeaderNameStartsWithControlChar0c() {
        testHeaderNameStartsWithControlChar(0x0c);
    }
    private void testHeaderNameStartsWithControlChar(int controlChar) {
        ByteBuf responseBuffer = Unpooled.buffer();
        responseBuffer.writeCharSequence("HTTP/1.1 200 OK\r\n" +
                "Host: netty.io\r\n", CharsetUtil.US_ASCII);
        responseBuffer.writeByte(controlChar);
        responseBuffer.writeCharSequence("Transfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII);
        testInvalidHeaders0(responseBuffer);
    }
    @Test
    public void testHeaderNameEndsWithControlChar1c() {
        testHeaderNameEndsWithControlChar(0x1c);
    }
    @Test
    public void testHeaderNameEndsWithControlChar1d() {
        testHeaderNameEndsWithControlChar(0x1d);
    }
    @Test
    public void testHeaderNameEndsWithControlChar1e() {
        testHeaderNameEndsWithControlChar(0x1e);
    }
    @Test
    public void testHeaderNameEndsWithControlChar1f() {
        testHeaderNameEndsWithControlChar(0x1f);
    }
    @Test
    public void testHeaderNameEndsWithControlChar0c() {
        testHeaderNameEndsWithControlChar(0x0c);
    }
    private void testHeaderNameEndsWithControlChar(int controlChar) {
        ByteBuf responseBuffer = Unpooled.buffer();
        responseBuffer.writeCharSequence("HTTP/1.1 200 OK\r\n" +
                "Host: netty.io\r\n", CharsetUtil.US_ASCII);
        responseBuffer.writeCharSequence("Transfer-Encoding", CharsetUtil.US_ASCII);
        responseBuffer.writeByte(controlChar);
        responseBuffer.writeCharSequence(": chunked\r\n\r\n", CharsetUtil.US_ASCII);
        testInvalidHeaders0(responseBuffer);
    }
    private static void testInvalidHeaders0(ByteBuf responseBuffer) {
        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
        assertTrue(channel.writeInbound(responseBuffer));
        HttpResponse response = channel.readInbound();
        assertThat(response.decoderResult().cause(), instanceOf(IllegalArgumentException.class));
        assertTrue(response.decoderResult().isFailure());
        assertFalse(channel.finish());
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
