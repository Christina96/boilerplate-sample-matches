<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for WebSocketCloseStatusTest.java &amp; HttpResponseDecoderTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WebSocketCloseStatusTest.java &amp; HttpResponseDecoderTest.java
      </h3>
<h1 align="center">
        16.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WebSocketCloseStatusTest.java (69.9422%)<th>HttpResponseDecoderTest.java (9.438377%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(57-75)<td><a href="#" name="0">(683-703)</a><td align="center"><font color="#ff0000">35</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(76-87)<td><a href="#" name="1">(313-325)</a><td align="center"><font color="#a00000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(91-103)<td><a href="#" name="2">(467-477)</a><td align="center"><font color="#8a0000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(128-137)<td><a href="#" name="3">(68-80)</a><td align="center"><font color="#7b0000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(13-31)<td><a href="#" name="4">(16-32)</a><td align="center"><font color="#6d0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(104-118)<td><a href="#" name="5">(60-67)</a><td align="center"><font color="#5e0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketCloseStatusTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.http.websocketx;
2 import java.util.Arrays;
3 import java.util.Collections;
4 import java.util.List;
5 import java.util.SortedSet;
6 import java.util.TreeSet;
7 import org.assertj.core.api.ThrowableAssert;
8 import org.hamcrest.Matchers;
9 import org.junit.jupiter.api.Test;
10 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
11 import static org.hamcrest.MatcherAssert.assertThat;
12 import static org.junit.jupiter.api.Assertions.assertEquals;
13 import static org.junit.jupiter.api.Assertions.assertNotSame;
14 import static org.junit.jupiter.api.Assertions.assertSame;
15 import</b></font> static io.netty.handler.codec.http.websocketx.WebSocketCloseStatus.*;
16 public class WebSocketCloseStatusTest {
17     private final List&lt;WebSocketCloseStatus&gt; validCodes = Arrays.asList(
18         NORMAL_CLOSURE,
19         ENDPOINT_UNAVAILABLE,
20         PROTOCOL_ERROR,
21         INVALID_MESSAGE_TYPE,
22         INVALID_PAYLOAD_DATA,
23         POLICY_VIOLATION,
24         MESSAGE_TOO_BIG,
25         MANDATORY_EXTENSION,
26         INTERNAL_SERVER_ERROR,
27         SERVICE_RESTART,
28         TRY_AGAIN_LATER,
29         BAD_GATEWAY
30     );
31     @Test
32     public void testToString() {
33         assertEquals("1000 Bye", NORMAL_CLOSURE.toString());
34     }
35 <a name="0"></a>
36     @Test
37     public void testKnownStatuses() {
38         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertSame(NORMAL_CLOSURE, valueOf(1000));
39         assertSame(ENDPOINT_UNAVAILABLE, valueOf(1001));
40         assertSame(PROTOCOL_ERROR, valueOf(1002));
41         assertSame(INVALID_MESSAGE_TYPE, valueOf(1003));
42         assertSame(EMPTY, valueOf(1005));
43         assertSame(ABNORMAL_CLOSURE, valueOf(1006));
44         assertSame(INVALID_PAYLOAD_DATA, valueOf(1007));
45         assertSame(POLICY_VIOLATION, valueOf(1008));
46         assertSame(MESSAGE_TOO_BIG, valueOf(1009));
47         assertSame(MANDATORY_EXTENSION, valueOf(1010));
48         assertSame(INTERNAL_SERVER_ERROR, valueOf(1011));
49         assertSame(SERVICE_RESTART, valueOf(1012));
50         assertSame(TRY_AGAIN_LATER, valueOf(1013));
51         assertSame(BAD_GATEWAY, valueOf(1014));
52         assertSame(TLS_HANDSHAKE_FAILED, valueOf(1015));
53     }
54 <a name="1"></a>
55     @Test
56     public void testNaturalOrder() {</b></font>
57         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(PROTOCOL_ERROR, Matchers.greaterThan(NORMAL_CLOSURE));
58         assertThat(PROTOCOL_ERROR, Matchers.greaterThan(valueOf(1001)));
59         assertThat(PROTOCOL_ERROR, Matchers.comparesEqualTo(PROTOCOL_ERROR));
60         assertThat(PROTOCOL_ERROR, Matchers.comparesEqualTo(valueOf(1002)));
61         assertThat(PROTOCOL_ERROR, Matchers.lessThan(INVALID_MESSAGE_TYPE));
62         assertThat(PROTOCOL_ERROR, Matchers.lessThan(valueOf(1007)));
63     }
64     @Test
65     public void testUserDefinedStatuses() {
66         WebSocketCloseStatus feedTimeot = new</b></font> WebSocketCloseStatus(6033, "Feed timed out");
67 <a name="2"></a>        WebSocketCloseStatus untradablePrice = new WebSocketCloseStatus(6034, "Untradable price");
68         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertNotSame(feedTimeot, valueOf(6033));
69         assertEquals(feedTimeot.code(), 6033);
70         assertEquals(feedTimeot.reasonText(), "Feed timed out");
71         assertNotSame(untradablePrice, valueOf(6034));
72         assertEquals(untradablePrice.code(), 6034);
73         assertEquals(untradablePrice.reasonText(), "Untradable price");
74     }
75     @Test
76 <a name="5"></a>    public void testRfc6455CodeValidation() {
77         List&lt;Integer&gt; knownCodes = Arrays.asList</b></font>(
78             <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>NORMAL_CLOSURE.code(),
79             ENDPOINT_UNAVAILABLE.code(),
80             PROTOCOL_ERROR.code(),
81             INVALID_MESSAGE_TYPE.code(),
82             INVALID_PAYLOAD_DATA.code(),
83             POLICY_VIOLATION.code(),
84             MESSAGE_TOO_BIG.code(),
85             MANDATORY_EXTENSION.code(),
86             INTERNAL_SERVER_ERROR.code(),
87             SERVICE_RESTART.code(),
88             TRY_AGAIN_LATER.code(),
89             BAD_GATEWAY.code()
90         );
91         SortedSet&lt;Integer&gt; invalidCodes = new TreeSet&lt;Integer&gt;()</b></font>;
92         for (int statusCode = Short.MIN_VALUE; statusCode &lt; Short.MAX_VALUE; statusCode++) {
93             if (!isValidStatusCode(statusCode)) {
94                 invalidCodes.add(statusCode);
95             }
96 <a name="3"></a>        }
97         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(0, invalidCodes.first().intValue());
98         assertEquals(2999, invalidCodes.last().intValue());
99         assertEquals(3000 - validCodes.size(), invalidCodes.size());
100         invalidCodes.retainAll(knownCodes);
101         assertEquals(invalidCodes, Collections.emptySet());
102     }
103     @Test
104     public void testValidationEnabled() {</b></font>
105         assertThatExceptionOfType(IllegalArgumentException.class)
106                 .isThrownBy(new ThrowableAssert.ThrowingCallable() {
107                     @Override
108                     public void call() throws RuntimeException {
109                         new WebSocketCloseStatus(1006, "validation disabled");
110                     }
111                 });
112     }
113     @Test
114     public void testValidationDisabled() {
115         WebSocketCloseStatus status = new WebSocketCloseStatus(1006, "validation disabled", false);
116         assertEquals(1006, status.code());
117         assertEquals("validation disabled", status.reasonText());
118     }
119 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HttpResponseDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec.http;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.Unpooled;
4 import io.netty.channel.embedded.EmbeddedChannel;
5 import io.netty.handler.codec.PrematureChannelClosureException;
6 import io.netty.util.CharsetUtil;
7 import org.junit.jupiter.api.Test;
8 import java.util.Arrays;
9 import java.util.List;
10 import java.util.Random;
11 import static io.netty.handler.codec.http.HttpHeadersTestUtils.of;
12 import static org.hamcrest.CoreMatchers.instanceOf;
13 import static org.hamcrest.CoreMatchers.is;
14 import static org.hamcrest.CoreMatchers.not;
15 import</b></font> static org.hamcrest.CoreMatchers.nullValue;
16 import static org.hamcrest.CoreMatchers.sameInstance;
17 import static org.hamcrest.MatcherAssert.assertThat;
18 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
19 import static org.junit.jupiter.api.Assertions.assertEquals;
20 import static org.junit.jupiter.api.Assertions.assertFalse;
21 import static org.junit.jupiter.api.Assertions.assertNull;
22 import static org.junit.jupiter.api.Assertions.assertTrue;
23 public class HttpResponseDecoderTest {
24     @Test
25     public void testMaxHeaderSize1() {
26         final int maxHeaderSize = 8192;
27         final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));
28         final char[] bytes = new char[maxHeaderSize / 2 - 4];
29         Arrays.fill(bytes, 'a');
30         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n", CharsetUtil.US_ASCII));
31 <a name="5"></a>                ch.writeInbound(Unpooled.copiedBuffer("A:", CharsetUtil.US_ASCII));
32         ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
33         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
34         assertNull(ch.readInbound());
35         ch.writeInbound(Unpooled.copiedBuffer("B:", CharsetUtil.US_ASCII));
36         ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
37         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
38 <a name="3"></a>        ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
39         HttpResponse res = ch.readInbound()</b></font>;
40         assertNull(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>res.decoderResult().cause());
41         assertTrue(res.decoderResult().isSuccess());
42         assertNull(ch.readInbound());
43         assertTrue(ch.finish());
44         assertThat(ch.readInbound(), instanceOf(LastHttpContent.class));
45     }
46     @Test
47     public void testMaxHeaderSize2() {</b></font>
48         final int maxHeaderSize = 8192;
49         final EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, maxHeaderSize, 8192));
50         final char[] bytes = new char[maxHeaderSize / 2 - 2];
51         Arrays.fill(bytes, 'a');
52         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n", CharsetUtil.US_ASCII));
53         ch.writeInbound(Unpooled.copiedBuffer("A:", CharsetUtil.US_ASCII));
54         ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
55         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
56         assertNull(ch.readInbound());
57         ch.writeInbound(Unpooled.copiedBuffer("B: ", CharsetUtil.US_ASCII));         ch.writeInbound(Unpooled.copiedBuffer(bytes, CharsetUtil.US_ASCII));
58         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
59         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII));
60         HttpResponse res = ch.readInbound();
61         assertTrue(res.decoderResult().cause() instanceof TooLongHttpHeaderException);
62         assertFalse(ch.finish());
63         assertNull(ch.readInbound());
64     }
65     @Test
66     public void testResponseChunked() {
67         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
68         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n",
69                 CharsetUtil.US_ASCII));
70         HttpResponse res = ch.readInbound();
71         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
72         assertThat(res.status(), is(HttpResponseStatus.OK));
73         byte[] data = new byte[64];
74         for (int i = 0; i &lt; data.length; i++) {
75             data[i] = (byte) i;
76         }
77         for (int i = 0; i &lt; 10; i++) {
78             assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + "\r\n",
79                     CharsetUtil.US_ASCII)));
80             assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));
81             HttpContent content = ch.readInbound();
82             assertEquals(data.length, content.content().readableBytes());
83             byte[] decodedData = new byte[data.length];
84             content.content().readBytes(decodedData);
85             assertArrayEquals(data, decodedData);
86             content.release();
87             assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
88         }
89         ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
90         LastHttpContent content = ch.readInbound();
91         assertFalse(content.content().isReadable());
92         content.release();
93         ch.finish();
94         assertNull(ch.readInbound());
95     }
96     @Test
97     public void testResponseDisallowPartialChunks() {
98         HttpResponseDecoder decoder = new HttpResponseDecoder(
99             HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH,
100             HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE,
101             HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE,
102             HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS,
103             HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE,
104             HttpObjectDecoder.DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS,
105             false);
106         EmbeddedChannel ch = new EmbeddedChannel(decoder);
107         String headers = "HTTP/1.1 200 OK\r\n"
108             + "Transfer-Encoding: chunked\r\n"
109             + "\r\n";
110        assertTrue(ch.writeInbound(Unpooled.copiedBuffer(headers, CharsetUtil.US_ASCII)));
111         HttpResponse res = ch.readInbound();
112         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
113         assertThat(res.status(), is(HttpResponseStatus.OK));
114         byte[] chunkBytes = new byte[10];
115         Random random = new Random();
116         random.nextBytes(chunkBytes);
117         final ByteBuf chunk = ch.alloc().buffer().writeBytes(chunkBytes);
118         final int chunkSize = chunk.readableBytes();
119         ByteBuf partialChunk1 = chunk.retainedSlice(0, 5);
120         ByteBuf partialChunk2 = chunk.retainedSlice(5, 5);
121         assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(chunkSize)
122                                                           + "\r\n", CharsetUtil.US_ASCII)));
123         assertFalse(ch.writeInbound(partialChunk1));
124         assertTrue(ch.writeInbound(partialChunk2));
125         HttpContent content = ch.readInbound();
126         assertEquals(chunk, content.content());
127         content.release();
128         chunk.release();
129         assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
130         assertTrue(ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII)));
131         HttpContent lastContent = ch.readInbound();
132         assertFalse(lastContent.content().isReadable());
133         lastContent.release();
134         assertFalse(ch.finish());
135     }
136     @Test
137     public void testResponseChunkedExceedMaxChunkSize() {
138         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(4096, 8192, 32));
139         ch.writeInbound(
140                 Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
141         HttpResponse res = ch.readInbound();
142         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
143         assertThat(res.status(), is(HttpResponseStatus.OK));
144         byte[] data = new byte[64];
145         for (int i = 0; i &lt; data.length; i++) {
146             data[i] = (byte) i;
147         }
148         for (int i = 0; i &lt; 10; i++) {
149             assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + "\r\n",
150                     CharsetUtil.US_ASCII)));
151             assertTrue(ch.writeInbound(Unpooled.copiedBuffer(data)));
152             byte[] decodedData = new byte[data.length];
153             HttpContent content = ch.readInbound();
154             assertEquals(32, content.content().readableBytes());
155             content.content().readBytes(decodedData, 0, 32);
156             content.release();
157             content = ch.readInbound();
158             assertEquals(32, content.content().readableBytes());
159             content.content().readBytes(decodedData, 32, 32);
160             assertArrayEquals(data, decodedData);
161             content.release();
162             assertFalse(ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
163         }
164         ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
165         LastHttpContent content = ch.readInbound();
166         assertFalse(content.content().isReadable());
167         content.release();
168         ch.finish();
169         assertNull(ch.readInbound());
170     }
171     @Test
172     public void testClosureWithoutContentLength1() throws Exception {
173         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
174         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
175         HttpResponse res = ch.readInbound();
176         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
177         assertThat(res.status(), is(HttpResponseStatus.OK));
178         assertThat(ch.readInbound(), is(nullValue()));
179         assertTrue(ch.finish());
180         LastHttpContent content = ch.readInbound();
181         assertThat(content.content().isReadable(), is(false));
182         content.release();
183         assertThat(ch.readInbound(), is(nullValue()));
184     }
185     @Test
186     public void testClosureWithoutContentLength2() throws Exception {
187         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
188         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n12345678", CharsetUtil.US_ASCII));
189         HttpResponse res = ch.readInbound();
190         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
191         assertThat(res.status(), is(HttpResponseStatus.OK));
192         HttpContent content = ch.readInbound();
193         assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
194         assertThat(content, is(not(instanceOf(LastHttpContent.class))));
195         content.release();
196         assertThat(ch.readInbound(), is(nullValue()));
197         assertTrue(ch.finish());
198         LastHttpContent lastContent = ch.readInbound();
199         assertThat(lastContent.content().isReadable(), is(false));
200         lastContent.release();
201         assertThat(ch.readInbound(), is(nullValue()));
202     }
203     @Test
204     public void testPrematureClosureWithChunkedEncoding1() throws Exception {
205         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
206         ch.writeInbound(
207                 Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
208 <a name="1"></a>                HttpResponse res = ch.readInbound();
209         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
210         assertThat(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>res.status(), is(HttpResponseStatus.OK));
211         assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
212         assertThat(ch.readInbound(), is(nullValue()));
213         ch.finish();
214         assertThat(ch.readInbound(), is(nullValue()));
215     }
216     @Test
217     public void testPrematureClosureWithChunkedEncoding2() throws Exception {
218         EmbeddedChannel ch = new</b></font> EmbeddedChannel(new HttpResponseDecoder());
219         ch.writeInbound(Unpooled.copiedBuffer(
220                 "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n8\r\n12345678", CharsetUtil.US_ASCII));
221         HttpResponse res = ch.readInbound();
222         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
223         assertThat(res.status(), is(HttpResponseStatus.OK));
224         assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
225         HttpContent content = ch.readInbound();
226         assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
227         assertThat(content, is(not(instanceOf(LastHttpContent.class))));
228         content.release();
229         assertThat(ch.readInbound(), is(nullValue()));
230         ch.finish();
231         assertThat(ch.readInbound(), is(nullValue()));
232     }
233     @Test
234     public void testLastResponseWithEmptyHeaderAndEmptyContent() {
235         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
236         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
237         HttpResponse res = ch.readInbound();
238         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
239         assertThat(res.status(), is(HttpResponseStatus.OK));
240         assertThat(ch.readInbound(), is(nullValue()));
241         assertThat(ch.finish(), is(true));
242         LastHttpContent content = ch.readInbound();
243         assertThat(content.content().isReadable(), is(false));
244         content.release();
245         assertThat(ch.readInbound(), is(nullValue()));
246     }
247     @Test
248     public void testLastResponseWithoutContentLengthHeader() {
249         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
250         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
251         HttpResponse res = ch.readInbound();
252         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
253         assertThat(res.status(), is(HttpResponseStatus.OK));
254         assertThat(ch.readInbound(), is(nullValue()));
255         ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
256         HttpContent content = ch.readInbound();
257         assertThat(content.content().readableBytes(), is(1024));
258         content.release();
259         assertThat(ch.finish(), is(true));
260         LastHttpContent lastContent = ch.readInbound();
261         assertThat(lastContent.content().isReadable(), is(false));
262         lastContent.release();
263         assertThat(ch.readInbound(), is(nullValue()));
264     }
265     @Test
266     public void testLastResponseWithHeaderRemoveTrailingSpaces() {
267         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
268         ch.writeInbound(Unpooled.copiedBuffer(
269                 "HTTP/1.1 200 OK\r\nX-Header: h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT       \r\n\r\n",
270                 CharsetUtil.US_ASCII));
271         HttpResponse res = ch.readInbound();
272         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
273         assertThat(res.status(), is(HttpResponseStatus.OK));
274         assertThat(res.headers().get(of("X-Header")), is("h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
275         assertThat(ch.readInbound(), is(nullValue()));
276         ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
277         HttpContent content = ch.readInbound();
278         assertThat(content.content().readableBytes(), is(1024));
279         content.release();
280         assertThat(ch.finish(), is(true));
281         LastHttpContent lastContent = ch.readInbound();
282         assertThat(lastContent.content().isReadable(), is(false));
283         lastContent.release();
284         assertThat(ch.readInbound(), is(nullValue()));
285     }
286     @Test
287     public void testResetContentResponseWithTransferEncoding() {
288         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
289         assertTrue(ch.writeInbound(Unpooled.copiedBuffer(
290                 "HTTP/1.1 205 Reset Content\r\n" +
291                 "Transfer-Encoding: chunked\r\n" +
292                 "\r\n" +
293                 "0\r\n" +
294                 "\r\n",
295                 CharsetUtil.US_ASCII)));
296         HttpResponse res = ch.readInbound();
297         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
298         assertThat(res.status(), is(HttpResponseStatus.RESET_CONTENT));
299         LastHttpContent lastContent = ch.readInbound();
300         assertThat(lastContent.content().isReadable(), is(false));
301         lastContent.release();
302         assertThat(ch.finish(), is(false));
303     }
304     @Test
305     public void testLastResponseWithTrailingHeader() {
306         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
307         ch.writeInbound(Unpooled.copiedBuffer(
308                 "HTTP/1.1 200 OK\r\n" +
309                         "Transfer-Encoding: chunked\r\n" +
310                         "\r\n" +
311                         "0\r\n" +
312                         "Set-Cookie: t1=t1v1\r\n" +
313                         "Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\r\n" +
314                         "\r\n",
315                 CharsetUtil.US_ASCII));
316         HttpResponse res = ch.readInbound();
317         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
318         assertThat(res.status(), is(HttpResponseStatus.OK));
319         LastHttpContent lastContent = ch.readInbound();
320         assertThat(lastContent.content().isReadable(), is(false));
321         HttpHeaders headers = lastContent.trailingHeaders();
322 <a name="2"></a>        assertEquals(1, headers.names().size());
323         List&lt;String&gt; values = headers.getAll(of("Set-Cookie"));
324         assertEquals(2, values.size());
325         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(values.contains("t1=t1v1"));
326         assertTrue(values.contains("t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
327         lastContent.release();
328         assertThat(ch.finish(), is(false));
329         assertThat(ch.readInbound(), is(nullValue()));
330     }
331     @Test
332     public void testLastResponseWithTrailingHeaderFragmented() {
333         byte[] data = ("HTTP/1.1 200 OK\r\n" +</b></font>
334                 "Transfer-Encoding: chunked\r\n" +
335                 "\r\n" +
336                 "0\r\n" +
337                 "Set-Cookie: t1=t1v1\r\n" +
338                 "Set-Cookie: t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT\r\n" +
339                 "\r\n").getBytes(CharsetUtil.US_ASCII);
340         for (int i = 1; i &lt; data.length; i++) {
341             testLastResponseWithTrailingHeaderFragmented(data, i);
342         }
343     }
344     private static void testLastResponseWithTrailingHeaderFragmented(byte[] content, int fragmentSize) {
345         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
346         int headerLength = 47;
347         for (int a = 0; a &lt; headerLength;) {
348             int amount = fragmentSize;
349             if (a + amount &gt; headerLength) {
350                 amount = headerLength -  a;
351             }
352             boolean headerDone = a + amount == headerLength;
353             assertEquals(headerDone, ch.writeInbound(Unpooled.copiedBuffer(content, a, amount)));
354             a += amount;
355         }
356         ch.writeInbound(Unpooled.copiedBuffer(content, headerLength, content.length - headerLength));
357         HttpResponse res = ch.readInbound();
358         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
359         assertThat(res.status(), is(HttpResponseStatus.OK));
360         LastHttpContent lastContent = ch.readInbound();
361         assertThat(lastContent.content().isReadable(), is(false));
362         HttpHeaders headers = lastContent.trailingHeaders();
363         assertEquals(1, headers.names().size());
364         List&lt;String&gt; values = headers.getAll(of("Set-Cookie"));
365         assertEquals(2, values.size());
366         assertTrue(values.contains("t1=t1v1"));
367         assertTrue(values.contains("t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
368         lastContent.release();
369         assertThat(ch.finish(), is(false));
370         assertThat(ch.readInbound(), is(nullValue()));
371     }
372     @Test
373     public void testResponseWithContentLength() {
374         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
375         ch.writeInbound(Unpooled.copiedBuffer(
376                 "HTTP/1.1 200 OK\r\n" +
377                         "Content-Length: 10\r\n" +
378                         "\r\n", CharsetUtil.US_ASCII));
379         byte[] data = new byte[10];
380         for (int i = 0; i &lt; data.length; i++) {
381             data[i] = (byte) i;
382         }
383         ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));
384         ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));
385         HttpResponse res = ch.readInbound();
386         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
387         assertThat(res.status(), is(HttpResponseStatus.OK));
388         HttpContent firstContent = ch.readInbound();
389         assertThat(firstContent.content().readableBytes(), is(5));
390         assertEquals(Unpooled.copiedBuffer(data, 0, 5), firstContent.content());
391         firstContent.release();
392         LastHttpContent lastContent = ch.readInbound();
393         assertEquals(5, lastContent.content().readableBytes());
394         assertEquals(Unpooled.copiedBuffer(data, 5, 5), lastContent.content());
395         lastContent.release();
396         assertThat(ch.finish(), is(false));
397         assertThat(ch.readInbound(), is(nullValue()));
398     }
399     @Test
400     public void testResponseWithContentLengthFragmented() {
401         byte[] data = ("HTTP/1.1 200 OK\r\n" +
402                 "Content-Length: 10\r\n" +
403                 "\r\n").getBytes(CharsetUtil.US_ASCII);
404         for (int i = 1; i &lt; data.length; i++) {
405             testResponseWithContentLengthFragmented(data, i);
406         }
407     }
408     private static void testResponseWithContentLengthFragmented(byte[] header, int fragmentSize) {
409         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
410         for (int a = 0; a &lt; header.length;) {
411             int amount = fragmentSize;
412             if (a + amount &gt; header.length) {
413                 amount = header.length -  a;
414             }
415             ch.writeInbound(Unpooled.copiedBuffer(header, a, amount));
416             a += amount;
417         }
418         byte[] data = new byte[10];
419         for (int i = 0; i &lt; data.length; i++) {
420             data[i] = (byte) i;
421         }
422         ch.writeInbound(Unpooled.copiedBuffer(data, 0, data.length / 2));
423         ch.writeInbound(Unpooled.copiedBuffer(data, 5, data.length / 2));
424         HttpResponse res = ch.readInbound();
425         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
426         assertThat(res.status(), is(HttpResponseStatus.OK));
427         HttpContent firstContent = ch.readInbound();
428         assertThat(firstContent.content().readableBytes(), is(5));
429         assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());
430         firstContent.release();
431         LastHttpContent lastContent = ch.readInbound();
432         assertEquals(5, lastContent.content().readableBytes());
433         assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());
434         lastContent.release();
435         assertThat(ch.finish(), is(false));
436         assertThat(ch.readInbound(), is(nullValue()));
437     }
438     @Test
439     public void testWebSocketResponse() {
440         byte[] data = ("HTTP/1.1 101 WebSocket Protocol Handshake\r\n" +
441                 "Upgrade: WebSocket\r\n" +
442                 "Connection: Upgrade\r\n" +
443                 "Sec-WebSocket-Origin: http://localhost:8080\r\n" +
444                 "Sec-WebSocket-Location: ws://localhost/some/path\r\n" +
445                 "\r\n" +
446                 "1234567812345678").getBytes();
447         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
448         ch.writeInbound(Unpooled.wrappedBuffer(data));
449         HttpResponse res = ch.readInbound();
450         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
451         assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
452         HttpContent content = ch.readInbound();
453         assertThat(content.content().readableBytes(), is(16));
454         content.release();
455         assertThat(ch.finish(), is(false));
456         assertThat(ch.readInbound(), is(nullValue()));
457     }
458     @Test
459     public void testWebSocketResponseWithDataFollowing() {
460         byte[] data = ("HTTP/1.1 101 WebSocket Protocol Handshake\r\n" +
461                 "Upgrade: WebSocket\r\n" +
462                 "Connection: Upgrade\r\n" +
463                 "Sec-WebSocket-Origin: http://localhost:8080\r\n" +
464                 "Sec-WebSocket-Location: ws://localhost/some/path\r\n" +
465                 "\r\n" +
466                 "1234567812345678").getBytes();
467         byte[] otherData = {1, 2, 3, 4};
468         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
469         ch.writeInbound(Unpooled.copiedBuffer(data, otherData));
470         HttpResponse res = ch.readInbound();
471         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
472         assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
473         HttpContent content = ch.readInbound();
474         assertThat(content.content().readableBytes(), is(16));
475         content.release();
476         assertThat(ch.finish(), is(true));
477         ByteBuf expected = Unpooled.wrappedBuffer(otherData);
478         ByteBuf buffer = ch.readInbound();
479         try {
480             assertEquals(expected, buffer);
481         } finally {
482             expected.release();
483             if (buffer != null) {
484                 buffer.release();
485             }
486         }
487     }
488     @Test
489     public void testGarbageHeaders() {
490         byte[] data = ("&lt;html&gt;\r\n" +
491                 "&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;\r\n" +
492                 "&lt;body bgcolor=\"white\"&gt;\r\n" +
493                 "&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;\r\n" +
494                 "&lt;hr&gt;&lt;center&gt;nginx/1.1.19&lt;/center&gt;\r\n" +
495                 "&lt;/body&gt;\r\n" +
496                 "&lt;/html&gt;\r\n").getBytes();
497         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
498         ch.writeInbound(Unpooled.copiedBuffer(data));
499 <a name="0"></a>
500         HttpResponse res = ch.readInbound();
501         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_0));
502         assertThat(res.status().code(), is(999));
503         assertThat(res.decoderResult().isFailure(), is(true));
504         assertThat(res.decoderResult().isFinished(), is(true));
505         assertThat(ch.readInbound(), is(nullValue()));
506         ch.writeInbound(Unpooled.copiedBuffer(data));
507         assertThat(ch.readInbound(), is(nullValue()));
508         ch.finish();
509         assertThat(ch.readInbound(), is(nullValue()));
510     }
511     @Test
512     public void testGarbageChunk() {</b></font>
513         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
514         String responseWithIllegalChunk =
515                 "HTTP/1.1 200 OK\r\n" +
516                 "Transfer-Encoding: chunked\r\n\r\n" +
517                 "NOT_A_CHUNK_LENGTH\r\n";
518         channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));
519         assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));
520         LastHttpContent invalidChunk = channel.readInbound();
521         assertThat(invalidChunk.decoderResult().isFailure(), is(true));
522         invalidChunk.release();
523         assertThat(channel.readInbound(), is(nullValue()));
524         assertThat(channel.finish(), is(false));
525     }
526     @Test
527     public void testConnectionClosedBeforeHeadersReceived() {
528         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
529         String responseInitialLine =
530                 "HTTP/1.1 200 OK\r\n";
531         assertFalse(channel.writeInbound(Unpooled.copiedBuffer(responseInitialLine, CharsetUtil.US_ASCII)));
532         assertTrue(channel.finish());
533         HttpMessage message = channel.readInbound();
534         assertTrue(message.decoderResult().isFailure());
535         assertThat(message.decoderResult().cause(), instanceOf(PrematureChannelClosureException.class));
536         assertNull(channel.readInbound());
537     }
538     @Test
539     public void testTrailerWithEmptyLineInSeparateBuffer() {
540         HttpResponseDecoder decoder = new HttpResponseDecoder();
541         EmbeddedChannel channel = new EmbeddedChannel(decoder);
542         String headers = "HTTP/1.1 200 OK\r\n"
543                 + "Transfer-Encoding: chunked\r\n"
544                 + "Trailer: My-Trailer\r\n";
545         assertFalse(channel.writeInbound(Unpooled.copiedBuffer(headers.getBytes(CharsetUtil.US_ASCII))));
546         assertTrue(channel.writeInbound(Unpooled.copiedBuffer("\r\n".getBytes(CharsetUtil.US_ASCII))));
547         assertTrue(channel.writeInbound(Unpooled.copiedBuffer("0\r\n", CharsetUtil.US_ASCII)));
548         assertTrue(channel.writeInbound(Unpooled.copiedBuffer("My-Trailer: 42\r\n", CharsetUtil.US_ASCII)));
549         assertTrue(channel.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.US_ASCII)));
550         HttpResponse response = channel.readInbound();
551         assertEquals(2, response.headers().size());
552         assertEquals("chunked", response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));
553         assertEquals("My-Trailer", response.headers().get(HttpHeaderNames.TRAILER));
554         LastHttpContent lastContent = channel.readInbound();
555         assertEquals(1, lastContent.trailingHeaders().size());
556         assertEquals("42", lastContent.trailingHeaders().get("My-Trailer"));
557         assertEquals(0, lastContent.content().readableBytes());
558         lastContent.release();
559         assertFalse(channel.finish());
560     }
561     @Test
562     public void testWhitespace() {
563         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
564         String requestStr = "HTTP/1.1 200 OK\r\n" +
565                 "Transfer-Encoding : chunked\r\n" +
566                 "Host: netty.io\n\r\n";
567         assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
568         HttpResponse response = channel.readInbound();
569         assertFalse(response.decoderResult().isFailure());
570         assertEquals(HttpHeaderValues.CHUNKED.toString(), response.headers().get(HttpHeaderNames.TRANSFER_ENCODING));
571         assertEquals("netty.io", response.headers().get(HttpHeaderNames.HOST));
572         assertFalse(channel.finish());
573     }
574     @Test
575     public void testHttpMessageDecoderResult() {
576         String responseStr = "HTTP/1.1 200 OK\r\n" +
577                 "Content-Length: 11\r\n" +
578                 "Connection: close\r\n\r\n" +
579                 "Lorem ipsum";
580         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
581         assertTrue(channel.writeInbound(Unpooled.copiedBuffer(responseStr, CharsetUtil.US_ASCII)));
582         HttpResponse response = channel.readInbound();
583         assertTrue(response.decoderResult().isSuccess());
584         assertThat(response.decoderResult(), instanceOf(HttpMessageDecoderResult.class));
585         HttpMessageDecoderResult decoderResult = (HttpMessageDecoderResult) response.decoderResult();
586         assertThat(decoderResult.initialLineLength(), is(15));
587         assertThat(decoderResult.headerSize(), is(35));
588         assertThat(decoderResult.totalSize(), is(50));
589         HttpContent c = channel.readInbound();
590         c.release();
591         assertFalse(channel.finish());
592     }
593     @Test
594     public void testHeaderNameStartsWithControlChar1c() {
595         testHeaderNameStartsWithControlChar(0x1c);
596     }
597     @Test
598     public void testHeaderNameStartsWithControlChar1d() {
599         testHeaderNameStartsWithControlChar(0x1d);
600     }
601     @Test
602     public void testHeaderNameStartsWithControlChar1e() {
603         testHeaderNameStartsWithControlChar(0x1e);
604     }
605     @Test
606     public void testHeaderNameStartsWithControlChar1f() {
607         testHeaderNameStartsWithControlChar(0x1f);
608     }
609     @Test
610     public void testHeaderNameStartsWithControlChar0c() {
611         testHeaderNameStartsWithControlChar(0x0c);
612     }
613     private void testHeaderNameStartsWithControlChar(int controlChar) {
614         ByteBuf responseBuffer = Unpooled.buffer();
615         responseBuffer.writeCharSequence("HTTP/1.1 200 OK\r\n" +
616                 "Host: netty.io\r\n", CharsetUtil.US_ASCII);
617         responseBuffer.writeByte(controlChar);
618         responseBuffer.writeCharSequence("Transfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII);
619         testInvalidHeaders0(responseBuffer);
620     }
621     @Test
622     public void testHeaderNameEndsWithControlChar1c() {
623         testHeaderNameEndsWithControlChar(0x1c);
624     }
625     @Test
626     public void testHeaderNameEndsWithControlChar1d() {
627         testHeaderNameEndsWithControlChar(0x1d);
628     }
629     @Test
630     public void testHeaderNameEndsWithControlChar1e() {
631         testHeaderNameEndsWithControlChar(0x1e);
632     }
633     @Test
634     public void testHeaderNameEndsWithControlChar1f() {
635         testHeaderNameEndsWithControlChar(0x1f);
636     }
637     @Test
638     public void testHeaderNameEndsWithControlChar0c() {
639         testHeaderNameEndsWithControlChar(0x0c);
640     }
641     private void testHeaderNameEndsWithControlChar(int controlChar) {
642         ByteBuf responseBuffer = Unpooled.buffer();
643         responseBuffer.writeCharSequence("HTTP/1.1 200 OK\r\n" +
644                 "Host: netty.io\r\n", CharsetUtil.US_ASCII);
645         responseBuffer.writeCharSequence("Transfer-Encoding", CharsetUtil.US_ASCII);
646         responseBuffer.writeByte(controlChar);
647         responseBuffer.writeCharSequence(": chunked\r\n\r\n", CharsetUtil.US_ASCII);
648         testInvalidHeaders0(responseBuffer);
649     }
650     private static void testInvalidHeaders0(ByteBuf responseBuffer) {
651         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
652         assertTrue(channel.writeInbound(responseBuffer));
653         HttpResponse response = channel.readInbound();
654         assertThat(response.decoderResult().cause(), instanceOf(IllegalArgumentException.class));
655         assertTrue(response.decoderResult().isFailure());
656         assertFalse(channel.finish());
657     }
658 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
