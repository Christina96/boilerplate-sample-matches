<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for GraphMutationTest.java &amp; StatsTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for GraphMutationTest.java &amp; StatsTest_1.java
      </h3>
<h1 align="center">
        10.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>GraphMutationTest.java (38.636364%)<th>StatsTest_1.java (6.296296%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-102)<td><a href="#" name="0">(120-124)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(77-83)<td><a href="#" name="1">(140-142)</a><td align="center"><font color="#e70000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(66-72)<td><a href="#" name="2">(466-472)</a><td align="center"><font color="#e70000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(17-28)<td><a href="#" name="3">(17-27)</a><td align="center"><font color="#e70000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(108-112)<td><a href="#" name="4">(231-235)</a><td align="center"><font color="#d00000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(73-76)<td><a href="#" name="5">(406-410)</a><td align="center"><font color="#d00000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(53-57)<td><a href="#" name="6">(92-94)</a><td align="center"><font color="#d00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>GraphMutationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<a name="3"></a> * limitations under the License.
 */

<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.graph;

import static com.google.common.truth.Truth.assertThat;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.RandomAccess;
import org.junit.Test;
import org.junit.runner.RunWith;
import</b></font> org.junit.runners.JUnit4;

/** Tests for repeated node and edge addition and removal in a {@link Graph}. */
@RunWith(JUnit4.class)

public final class GraphMutationTest {
  private static final int NUM_TRIALS = 50;
  private static final int NUM_NODES = 100;
  private static final int NUM_EDGES = 1000;
  private static final int NODE_POOL_SIZE = 1000; // must be &gt;&gt; NUM_NODES

  @Test
  public void directedGraph() {
    testGraphMutation(GraphBuilder.directed());
  }

  @Test
  public void undirectedGraph() {
    testGraphMutation(GraphBuilder.undirected());
  }

  private static void testGraphMutation(GraphBuilder&lt;? super Integer&gt; graphBuilder) {
<a name="6"></a>    Random gen = new Random(42); // Fixed seed so test results are deterministic.

    for (int trial = 0; trial &lt; NUM_TRIALS; ++trial) {
      MutableGraph&lt;Integer&gt; graph = <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>graphBuilder.allowsSelfLoops(true).build();

      assertThat(graph.nodes()).isEmpty();
      assertThat(graph.edges()).isEmpty();
      AbstractGraphTest.validateGraph</b></font>(graph);

      while (graph.nodes().size() &lt; NUM_NODES) {
        graph.addNode(gen.nextInt(NODE_POOL_SIZE));
      }
      ArrayList&lt;Integer&gt; nodeList = new ArrayList&lt;&gt;(graph.nodes());
<a name="2"></a>      while (graph.edges().size() &lt; NUM_EDGES) {
        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));
      }
      ArrayList&lt;EndpointPair&lt;Integer&gt;&gt; edgeList = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ArrayList&lt;&gt;(graph.edges());

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES);
<a name="5"></a>      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle</b></font>(edgeList, gen);
      int numEdgesToRemove = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>gen.nextInt(NUM_EDGES);
<a name="1"></a>      for (int i = 0; i &lt; numEdgesToRemove; ++i) {
        EndpointPair&lt;Integer&gt; edge = edgeList.get(i);
        assertThat(graph.removeEdge</b></font>(edge.nodeU(), edge.nodeV())).isTrue();
      <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);
      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle</b></font>(nodeList, gen);
      int numNodesToRemove = gen.nextInt(NUM_NODES);
      for (int i = 0; i &lt; numNodesToRemove; ++i) {
        assertThat(graph.removeNode(nodeList.get(i))).isTrue();
      }

      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);
      // Number of edges remaining is unknown (node's incident edges have been removed).
      AbstractGraphTest.validateGraph(graph);

      for (int i = numNodesToRemove; i &lt; NUM_NODES; ++i) {
<a name="0"></a>        assertThat(graph.removeNode(nodeList.get(i))).isTrue();
      }

      <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(graph.nodes()).isEmpty();
      assertThat(graph.edges()).isEmpty(); // no edges can remain if there's no nodes
      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle(nodeList, gen);
      for (Integer node : nodeList) {</b></font>
        assertThat(graph.addNode(node)).isTrue();
      }
<a name="4"></a>      Collections.shuffle(edgeList, gen);
      for (EndpointPair&lt;Integer&gt; edge : edgeList) {
        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();
      <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES);
      AbstractGraphTest.validateGraph</b></font>(graph);
    }
  }

  private static &lt;L extends List&lt;T&gt; &amp; RandomAccess, T&gt; T getRandomElement(L list, Random gen) {
    return list.get(gen.nextInt(list.size()));
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>StatsTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<a name="3"></a> * limitations under the License.
 */

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.math;

import static com.google.common.math.StatsTesting.ALLOWED_ERROR;
import static com.google.common.math.StatsTesting.ALL_MANY_VALUES;
import static com.google.common.math.StatsTesting.ALL_STATS;
import static com.google.common.math.StatsTesting.EMPTY_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.EMPTY_STATS_VARARGS;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MAX;
import</b></font> static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_STATS_VARARGS;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_POPULATION_VARIANCE;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_STATS;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_POPULATION_VARIANCE;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_STATS;
import static com.google.common.math.StatsTesting.LARGE_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_VALUES_STATS;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MAX;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_STATS_ITERATOR;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_STATS_SNAPSHOT;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.MANY_VALUES;
import static com.google.common.math.StatsTesting.MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.MANY_VALUES_MAX;
import static com.google.common.math.StatsTesting.MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_ITERATOR;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_SNAPSHOT;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_VARARGS;
import static com.google.common.math.StatsTesting.MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.ONE_VALUE;
import static com.google.common.math.StatsTesting.ONE_VALUE_STATS;
import static com.google.common.math.StatsTesting.TWO_VALUES;
import static com.google.common.math.StatsTesting.TWO_VALUES_MAX;
import static com.google.common.math.StatsTesting.TWO_VALUES_MEAN;
import static com.google.common.math.StatsTesting.TWO_VALUES_MIN;
import static com.google.common.math.StatsTesting.TWO_VALUES_STATS;
import static com.google.common.math.StatsTesting.TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;
import static java.lang.Double.NEGATIVE_INFINITY;
import static java.lang.Double.NaN;
import static java.lang.Double.POSITIVE_INFINITY;
import static java.lang.Math.sqrt;

import com.google.common.collect.ImmutableList;
import com.google.common.math.StatsTesting.ManyValues;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.testing.EqualsTester;
import com.google.common.testing.SerializableTester;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import junit.framework.TestCase;

/**
 * Tests for {@link Stats}. This tests instances created by both {@link Stats#of} and {@link
 * StatsAccumulator#snapshot}.
 *
 * @author Pete Gillin
 */
<a name="6"></a>public class StatsTest extends TestCase {

  public void testCount() {
    <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(EMPTY_STATS_VARARGS.count()).isEqualTo(0);
    assertThat(EMPTY_STATS_ITERABLE.count()).isEqualTo(0);
    assertThat(ONE_VALUE_STATS.count</b></font>()).isEqualTo(1);
    assertThat(TWO_VALUES_STATS.count()).isEqualTo(2);
    assertThat(MANY_VALUES_STATS_VARARGS.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERABLE.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERATOR.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.count()).isEqualTo(INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.count()).isEqualTo(INTEGER_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.count()).isEqualTo(LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.count()).isEqualTo(LONG_MANY_VALUES_COUNT);
  }

  public void testMean() {
    try {
      EMPTY_STATS_VARARGS.mean();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.mean();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
<a name="0"></a>    assertThat(ONE_VALUE_STATS.mean()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).mean()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).mean()).isNegativeInfinity();
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(Stats.of(NaN).mean()).isNaN();
    assertThat(TWO_VALUES_STATS.mean()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN);
    // For datasets of many double values created from an array, we test many combinations of finite
    // and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {</b></font>
      double mean = Stats.of(values.asArray()).mean();
      if (values.hasAnyNaN()) {
        assertWithMessage("mean of " + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity() &amp;&amp; values.hasAnyNegativeInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isPositiveInfinity();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isNegativeInfinity();
      } else {
        assertWithMessage("mean of " + values)
            .that(mean)
<a name="1"></a>            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_MEAN);
      }
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    assertThat(MANY_VALUES_STATS_ITERABLE.mean()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(MANY_VALUES_STATS_ITERATOR.mean</b></font>()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.mean()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(LARGE_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Double.MAX_VALUE)
        .of(LARGE_VALUES_MEAN);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.mean())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.mean())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(LARGE_INTEGER_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE)
        .of(LARGE_INTEGER_VALUES_MEAN);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.mean())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.mean())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(LARGE_LONG_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Long.MAX_VALUE)
        .of(LARGE_LONG_VALUES_MEAN);
  }

  public void testSum() {
    assertThat(EMPTY_STATS_VARARGS.sum()).isEqualTo(0.0);
    assertThat(EMPTY_STATS_ITERABLE.sum()).isEqualTo(0.0);
    assertThat(ONE_VALUE_STATS.sum()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(TWO_VALUES_STATS.sum()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN * 2);
    assertThat(MANY_VALUES_STATS_VARARGS.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERABLE.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERATOR.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sum())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sum())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sum())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sum())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
  }

  public void testPopulationVariance() {
    try {
      EMPTY_STATS_VARARGS.populationVariance();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.populationVariance();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.populationVariance()).isWithin(0.0).of(0.0);
    assertThat(Stats.of(POSITIVE_INFINITY).populationVariance()).isNaN();
    assertThat(Stats.of(NEGATIVE_INFINITY).populationVariance()).isNaN();
    assertThat(Stats.of(NaN).populationVariance()).isNaN();
    assertThat(TWO_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / 2);
    assertThat(MANY_VALUES_STATS_VARARGS.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    // For datasets of many double values created from an iterable, we test many combinations of
    // finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double populationVariance = Stats.of(values.asIterable()).populationVariance();
      if (values.hasAnyNonFinite()) {
        assertWithMessage("population variance of " + values).that(populationVariance).isNaN();
      } else {
        assertWithMessage("population variance of " + values)
            .that(populationVariance)
<a name="4"></a>            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
      }
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    assertThat(MANY_VALUES_STATS_ITERATOR.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    assertThat</b></font>(MANY_VALUES_STATS_SNAPSHOT.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
    assertThat(LARGE_INTEGER_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE * Integer.MAX_VALUE)
        .of(LARGE_INTEGER_VALUES_POPULATION_VARIANCE);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
    assertThat(LARGE_LONG_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR * Long.MAX_VALUE * Long.MAX_VALUE)
        .of(LARGE_LONG_VALUES_POPULATION_VARIANCE);
  }

  public void testPopulationStandardDeviation() {
    try {
      EMPTY_STATS_VARARGS.populationStandardDeviation();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.populationStandardDeviation();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.populationStandardDeviation()).isWithin(0.0).of(0.0);
    assertThat(TWO_VALUES_STATS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / 2));
    assertThat(MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
  }

  public void testSampleVariance() {
    try {
      EMPTY_STATS_VARARGS.sampleVariance();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.sampleVariance();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      ONE_VALUE_STATS.sampleVariance();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(TWO_VALUES_STATS.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS);
    assertThat(MANY_VALUES_STATS_VARARGS.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_ITERABLE.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_ITERATOR.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
  }

  public void testSampleStandardDeviation() {
    try {
      EMPTY_STATS_VARARGS.sampleStandardDeviation();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.sampleStandardDeviation();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      ONE_VALUE_STATS.sampleStandardDeviation();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(TWO_VALUES_STATS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS));
    assertThat(MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
  }

  public void testMax() {
    try {
      EMPTY_STATS_VARARGS.max();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.max();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).max()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).max()).isNegativeInfinity();
<a name="5"></a>    assertThat(Stats.of(NaN).max()).isNaN();
    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);
    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);
    assertThat(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);
    // For datasets of many double values created from an iterator, we test many combinations of
    // finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double max = Stats.of(values.asIterable</b></font>().iterator()).max();
      if (values.hasAnyNaN()) {
        assertWithMessage("max of " + values).that(max).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage("max of " + values).that(max).isPositiveInfinity();
      } else {
        assertWithMessage("max of " + values).that(max).isEqualTo(MANY_VALUES_MAX);
      }
    }
    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);
  }

  public void testMin() {
    try {
      EMPTY_STATS_VARARGS.min();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.min();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).min()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).min()).isNegativeInfinity();
    assertThat(Stats.of(NaN).min()).isNaN();
    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);
    // For datasets of many double values created from an accumulator snapshot, we test many
    // combinations of finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      StatsAccumulator accumulator = new StatsAccumulator();
      accumulator.addAll(values.asIterable());
      double min = accumulator.snapshot().min();
      if (values.hasAnyNaN()) {
        assertWithMessage("min of " + values).that(min).isNaN();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage("min of " + values).that(min).isNegativeInfinity();
      } else {
        assertWithMessage("min of " + values).that(min).isEqualTo(MANY_VALUES_MIN);
      }
    }
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);
<a name="2"></a>  }

  public void testEqualsAndHashCode() {
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new EqualsTester()
        .addEqualityGroup(
            Stats.of(1.0, 1.0, 5.0, 5.0),
            Stats.of(1.0, 1.0, 5.0, 5.0),
            Stats.of(ImmutableList.of(1.0, 1.0, 5.0, 5.0)),
            Stats.of(ImmutableList.of(1.0, 1.0, 5.0, 5.0).iterator()),
            SerializableTester.reserialize(Stats.of</b></font>(1.0, 1.0, 5.0, 5.0)))
        .addEqualityGroup(Stats.of(1.0, 5.0))
        .addEqualityGroup(Stats.of(1.0, 5.0, 1.0, 6.0))
        .addEqualityGroup(Stats.of(2.0, 6.0, 2.0, 6.0))
        .addEqualityGroup(
            new Stats(5, -5.5, 55.5, -5.55, 5.55), new Stats(5, -5.5, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(6, -5.5, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.6, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.6, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.5, -5.56, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.5, -5.55, 5.56))
        .testEquals();
  }

  public void testSerializable() {
    SerializableTester.reserializeAndAssert(MANY_VALUES_STATS_ITERABLE);
  }

  public void testToString() {
    assertThat(EMPTY_STATS_VARARGS.toString()).isEqualTo("Stats{count=0}");
    assertThat(MANY_VALUES_STATS_ITERABLE.toString())
        .isEqualTo(
            "Stats{count="
                + MANY_VALUES_STATS_ITERABLE.count()
                + ", mean="
                + MANY_VALUES_STATS_ITERABLE.mean()
                + ", populationStandardDeviation="
                + MANY_VALUES_STATS_ITERABLE.populationStandardDeviation()
                + ", min="
                + MANY_VALUES_STATS_ITERABLE.min()
                + ", max="
                + MANY_VALUES_STATS_ITERABLE.max()
                + "}");
  }

  public void testMeanOf() {
    try {
      Stats.meanOf();
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
    try {
      Stats.meanOf(ImmutableList.&lt;Number&gt;of());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
    assertThat(Stats.meanOf(ONE_VALUE)).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(Stats.meanOf(POSITIVE_INFINITY)).isPositiveInfinity();
    assertThat(Stats.meanOf(NEGATIVE_INFINITY)).isNegativeInfinity();
    assertThat(Stats.meanOf(NaN)).isNaN();
    assertThat(Stats.meanOf(TWO_VALUES)).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN);
    // For datasets of many double values created from an array, we test many combinations of finite
    // and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double mean = Stats.meanOf(values.asArray());
      if (values.hasAnyNaN()) {
        assertWithMessage("mean of " + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity() &amp;&amp; values.hasAnyNegativeInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isPositiveInfinity();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage("mean of " + values).that(mean).isNegativeInfinity();
      } else {
        assertWithMessage("mean of " + values)
            .that(mean)
            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_MEAN);
      }
    }
    assertThat(Stats.meanOf(MANY_VALUES)).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(MANY_VALUES.iterator())).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(INTEGER_MANY_VALUES))
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(Ints.toArray(INTEGER_MANY_VALUES)))
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(LONG_MANY_VALUES))
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(Longs.toArray(LONG_MANY_VALUES)))
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
  }

  public void testToByteArrayAndFromByteArrayRoundTrip() {
    for (Stats stats : ALL_STATS) {
      byte[] statsByteArray = stats.toByteArray();

      // Round trip to byte array and back
      assertThat(Stats.fromByteArray(statsByteArray)).isEqualTo(stats);
    }
  }

  public void testFromByteArray_withNullInputThrowsNullPointerException() {
    try {
      Stats.fromByteArray(null);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
  }

  public void testFromByteArray_withEmptyArrayInputThrowsIllegalArgumentException() {
    try {
      Stats.fromByteArray(new byte[0]);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFromByteArray_withTooLongArrayInputThrowsIllegalArgumentException() {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooLongByteArray =
        ByteBuffer.allocate(buffer.length + 2)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer)
            .putChar('.')
            .array();
    try {
      Stats.fromByteArray(tooLongByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException() {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooShortByteArray =
        ByteBuffer.allocate(buffer.length - 1)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer, 0, Stats.BYTES - 1)
            .array();
    try {
      Stats.fromByteArray(tooShortByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
