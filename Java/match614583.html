<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for GraphMutationTest.java & StatsTest_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for GraphMutationTest.java & StatsTest_1.java
      </h3>
      <h1 align="center">
        10.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>GraphMutationTest.java (38.636364%)<TH>StatsTest_1.java (6.296296%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#0',2,'match614583-1.html#0',3)" NAME="0">(97-102)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#0',2,'match614583-1.html#0',3)" NAME="0">(120-124)</A><TD ALIGN=center><FONT COLOR="#ff0000">11</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#1',2,'match614583-1.html#1',3)" NAME="1">(77-83)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#1',2,'match614583-1.html#1',3)" NAME="1">(140-142)</A><TD ALIGN=center><FONT COLOR="#e70000">10</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#2',2,'match614583-1.html#2',3)" NAME="2">(66-72)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#2',2,'match614583-1.html#2',3)" NAME="2">(466-472)</A><TD ALIGN=center><FONT COLOR="#e70000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#3',2,'match614583-1.html#3',3)" NAME="3">(17-28)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#3',2,'match614583-1.html#3',3)" NAME="3">(17-27)</A><TD ALIGN=center><FONT COLOR="#e70000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#4',2,'match614583-1.html#4',3)" NAME="4">(108-112)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#4',2,'match614583-1.html#4',3)" NAME="4">(231-235)</A><TD ALIGN=center><FONT COLOR="#d00000">9</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#5',2,'match614583-1.html#5',3)" NAME="5">(73-76)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#5',2,'match614583-1.html#5',3)" NAME="5">(406-410)</A><TD ALIGN=center><FONT COLOR="#d00000">9</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match614583-0.html#6',2,'match614583-1.html#6',3)" NAME="6">(53-57)<TD><A HREF="javascript:ZweiFrames('match614583-0.html#6',2,'match614583-1.html#6',3)" NAME="6">(92-94)</A><TD ALIGN=center><FONT COLOR="#d00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>GraphMutationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="3"></A> * limitations under the License.
 */

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match614583-1.html#3',3,'match614583-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.graph;

import static com.google.common.truth.Truth.assertThat;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.RandomAccess;
import org.junit.Test;
import org.junit.runner.RunWith;
import</B></FONT> org.junit.runners.JUnit4;

/** Tests for repeated node and edge addition and removal in a {@link Graph}. */
@RunWith(JUnit4.class)

public final class GraphMutationTest {
  private static final int NUM_TRIALS = 50;
  private static final int NUM_NODES = 100;
  private static final int NUM_EDGES = 1000;
  private static final int NODE_POOL_SIZE = 1000; // must be &gt;&gt; NUM_NODES

  @Test
  public void directedGraph() {
    testGraphMutation(GraphBuilder.directed());
  }

  @Test
  public void undirectedGraph() {
    testGraphMutation(GraphBuilder.undirected());
  }

  private static void testGraphMutation(GraphBuilder&lt;? super Integer&gt; graphBuilder) {
<A NAME="6"></A>    Random gen = new Random(42); // Fixed seed so test results are deterministic.

    for (int trial = 0; trial &lt; NUM_TRIALS; ++trial) {
      MutableGraph&lt;Integer&gt; graph = <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match614583-1.html#6',3,'match614583-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>graphBuilder.allowsSelfLoops(true).build();

      assertThat(graph.nodes()).isEmpty();
      assertThat(graph.edges()).isEmpty();
      AbstractGraphTest.validateGraph</B></FONT>(graph);

      while (graph.nodes().size() &lt; NUM_NODES) {
        graph.addNode(gen.nextInt(NODE_POOL_SIZE));
      }
      ArrayList&lt;Integer&gt; nodeList = new ArrayList&lt;&gt;(graph.nodes());
<A NAME="2"></A>      while (graph.edges().size() &lt; NUM_EDGES) {
        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));
      }
      ArrayList&lt;EndpointPair&lt;Integer&gt;&gt; edgeList = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match614583-1.html#2',3,'match614583-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ArrayList&lt;&gt;(graph.edges());

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES);
<A NAME="5"></A>      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle</B></FONT>(edgeList, gen);
      int numEdgesToRemove = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match614583-1.html#5',3,'match614583-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>gen.nextInt(NUM_EDGES);
<A NAME="1"></A>      for (int i = 0; i &lt; numEdgesToRemove; ++i) {
        EndpointPair&lt;Integer&gt; edge = edgeList.get(i);
        assertThat(graph.removeEdge</B></FONT>(edge.nodeU(), edge.nodeV())).isTrue();
      <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match614583-1.html#1',3,'match614583-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);
      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle</B></FONT>(nodeList, gen);
      int numNodesToRemove = gen.nextInt(NUM_NODES);
      for (int i = 0; i &lt; numNodesToRemove; ++i) {
        assertThat(graph.removeNode(nodeList.get(i))).isTrue();
      }

      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);
      // Number of edges remaining is unknown (node's incident edges have been removed).
      AbstractGraphTest.validateGraph(graph);

      for (int i = numNodesToRemove; i &lt; NUM_NODES; ++i) {
<A NAME="0"></A>        assertThat(graph.removeNode(nodeList.get(i))).isTrue();
      }

      <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match614583-1.html#0',3,'match614583-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(graph.nodes()).isEmpty();
      assertThat(graph.edges()).isEmpty(); // no edges can remain if there's no nodes
      AbstractGraphTest.validateGraph(graph);

      Collections.shuffle(nodeList, gen);
      for (Integer node : nodeList) {</B></FONT>
        assertThat(graph.addNode(node)).isTrue();
      }
<A NAME="4"></A>      Collections.shuffle(edgeList, gen);
      for (EndpointPair&lt;Integer&gt; edge : edgeList) {
        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();
      <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match614583-1.html#4',3,'match614583-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

      assertThat(graph.nodes()).hasSize(NUM_NODES);
      assertThat(graph.edges()).hasSize(NUM_EDGES);
      AbstractGraphTest.validateGraph</B></FONT>(graph);
    }
  }

  private static &lt;L extends List&lt;T&gt; &amp; RandomAccess, T&gt; T getRandomElement(L list, Random gen) {
    return list.get(gen.nextInt(list.size()));
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>StatsTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="3"></A> * limitations under the License.
 */

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#3',2,'match614583-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.math;

import static com.google.common.math.StatsTesting.ALLOWED_ERROR;
import static com.google.common.math.StatsTesting.ALL_MANY_VALUES;
import static com.google.common.math.StatsTesting.ALL_STATS;
import static com.google.common.math.StatsTesting.EMPTY_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.EMPTY_STATS_VARARGS;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MAX;
import</B></FONT> static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_STATS_VARARGS;
import static com.google.common.math.StatsTesting.INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_POPULATION_VARIANCE;
import static com.google.common.math.StatsTesting.LARGE_INTEGER_VALUES_STATS;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_POPULATION_VARIANCE;
import static com.google.common.math.StatsTesting.LARGE_LONG_VALUES_STATS;
import static com.google.common.math.StatsTesting.LARGE_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LARGE_VALUES_STATS;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MAX;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_STATS_ITERATOR;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_STATS_SNAPSHOT;
import static com.google.common.math.StatsTesting.LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.MANY_VALUES;
import static com.google.common.math.StatsTesting.MANY_VALUES_COUNT;
import static com.google.common.math.StatsTesting.MANY_VALUES_MAX;
import static com.google.common.math.StatsTesting.MANY_VALUES_MEAN;
import static com.google.common.math.StatsTesting.MANY_VALUES_MIN;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_ITERABLE;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_ITERATOR;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_SNAPSHOT;
import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_VARARGS;
import static com.google.common.math.StatsTesting.MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.math.StatsTesting.ONE_VALUE;
import static com.google.common.math.StatsTesting.ONE_VALUE_STATS;
import static com.google.common.math.StatsTesting.TWO_VALUES;
import static com.google.common.math.StatsTesting.TWO_VALUES_MAX;
import static com.google.common.math.StatsTesting.TWO_VALUES_MEAN;
import static com.google.common.math.StatsTesting.TWO_VALUES_MIN;
import static com.google.common.math.StatsTesting.TWO_VALUES_STATS;
import static com.google.common.math.StatsTesting.TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;
import static java.lang.Double.NEGATIVE_INFINITY;
import static java.lang.Double.NaN;
import static java.lang.Double.POSITIVE_INFINITY;
import static java.lang.Math.sqrt;

import com.google.common.collect.ImmutableList;
import com.google.common.math.StatsTesting.ManyValues;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.testing.EqualsTester;
import com.google.common.testing.SerializableTester;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import junit.framework.TestCase;

/**
 * Tests for {@link Stats}. This tests instances created by both {@link Stats#of} and {@link
 * StatsAccumulator#snapshot}.
 *
 * @author Pete Gillin
 */
<A NAME="6"></A>public class StatsTest extends TestCase {

  public void testCount() {
    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#6',2,'match614583-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(EMPTY_STATS_VARARGS.count()).isEqualTo(0);
    assertThat(EMPTY_STATS_ITERABLE.count()).isEqualTo(0);
    assertThat(ONE_VALUE_STATS.count</B></FONT>()).isEqualTo(1);
    assertThat(TWO_VALUES_STATS.count()).isEqualTo(2);
    assertThat(MANY_VALUES_STATS_VARARGS.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERABLE.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERATOR.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.count()).isEqualTo(MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.count()).isEqualTo(INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.count()).isEqualTo(INTEGER_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.count()).isEqualTo(LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.count()).isEqualTo(LONG_MANY_VALUES_COUNT);
  }

  public void testMean() {
    try {
      EMPTY_STATS_VARARGS.mean();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.mean();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
<A NAME="0"></A>    assertThat(ONE_VALUE_STATS.mean()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).mean()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).mean()).isNegativeInfinity();
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#0',2,'match614583-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(Stats.of(NaN).mean()).isNaN();
    assertThat(TWO_VALUES_STATS.mean()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN);
    // For datasets of many double values created from an array, we test many combinations of finite
    // and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {</B></FONT>
      double mean = Stats.of(values.asArray()).mean();
      if (values.hasAnyNaN()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity() &amp;&amp; values.hasAnyNegativeInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isPositiveInfinity();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNegativeInfinity();
      } else {
        assertWithMessage(&quot;mean of &quot; + values)
            .that(mean)
<A NAME="1"></A>            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_MEAN);
      }
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#1',2,'match614583-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    assertThat(MANY_VALUES_STATS_ITERABLE.mean()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(MANY_VALUES_STATS_ITERATOR.mean</B></FONT>()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.mean()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(LARGE_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Double.MAX_VALUE)
        .of(LARGE_VALUES_MEAN);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.mean())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.mean())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(LARGE_INTEGER_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE)
        .of(LARGE_INTEGER_VALUES_MEAN);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.mean())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.mean())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(LARGE_LONG_VALUES_STATS.mean())
        .isWithin(ALLOWED_ERROR * Long.MAX_VALUE)
        .of(LARGE_LONG_VALUES_MEAN);
  }

  public void testSum() {
    assertThat(EMPTY_STATS_VARARGS.sum()).isEqualTo(0.0);
    assertThat(EMPTY_STATS_ITERABLE.sum()).isEqualTo(0.0);
    assertThat(ONE_VALUE_STATS.sum()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(TWO_VALUES_STATS.sum()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN * 2);
    assertThat(MANY_VALUES_STATS_VARARGS.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERABLE.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_ITERATOR.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sum())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sum())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sum())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sum())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sum())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
  }

  public void testPopulationVariance() {
    try {
      EMPTY_STATS_VARARGS.populationVariance();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.populationVariance();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.populationVariance()).isWithin(0.0).of(0.0);
    assertThat(Stats.of(POSITIVE_INFINITY).populationVariance()).isNaN();
    assertThat(Stats.of(NEGATIVE_INFINITY).populationVariance()).isNaN();
    assertThat(Stats.of(NaN).populationVariance()).isNaN();
    assertThat(TWO_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / 2);
    assertThat(MANY_VALUES_STATS_VARARGS.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    // For datasets of many double values created from an iterable, we test many combinations of
    // finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double populationVariance = Stats.of(values.asIterable()).populationVariance();
      if (values.hasAnyNonFinite()) {
        assertWithMessage(&quot;population variance of &quot; + values).that(populationVariance).isNaN();
      } else {
        assertWithMessage(&quot;population variance of &quot; + values)
            .that(populationVariance)
<A NAME="4"></A>            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
      }
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#4',2,'match614583-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    assertThat(MANY_VALUES_STATS_ITERATOR.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    assertThat</B></FONT>(MANY_VALUES_STATS_SNAPSHOT.populationVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
    assertThat(LARGE_INTEGER_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE * Integer.MAX_VALUE)
        .of(LARGE_INTEGER_VALUES_POPULATION_VARIANCE);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
    assertThat(LARGE_LONG_VALUES_STATS.populationVariance())
        .isWithin(ALLOWED_ERROR * Long.MAX_VALUE * Long.MAX_VALUE)
        .of(LARGE_LONG_VALUES_POPULATION_VARIANCE);
  }

  public void testPopulationStandardDeviation() {
    try {
      EMPTY_STATS_VARARGS.populationStandardDeviation();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.populationStandardDeviation();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.populationStandardDeviation()).isWithin(0.0).of(0.0);
    assertThat(TWO_VALUES_STATS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / 2));
    assertThat(MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
  }

  public void testSampleVariance() {
    try {
      EMPTY_STATS_VARARGS.sampleVariance();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.sampleVariance();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      ONE_VALUE_STATS.sampleVariance();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(TWO_VALUES_STATS.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS);
    assertThat(MANY_VALUES_STATS_VARARGS.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_ITERABLE.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_ITERATOR.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
        .isWithin(ALLOWED_ERROR)
        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleVariance())
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
        .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
  }

  public void testSampleStandardDeviation() {
    try {
      EMPTY_STATS_VARARGS.sampleStandardDeviation();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.sampleStandardDeviation();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      ONE_VALUE_STATS.sampleStandardDeviation();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(TWO_VALUES_STATS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS));
    assertThat(MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR)
        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
        .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
  }

  public void testMax() {
    try {
      EMPTY_STATS_VARARGS.max();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.max();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).max()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).max()).isNegativeInfinity();
<A NAME="5"></A>    assertThat(Stats.of(NaN).max()).isNaN();
    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);
    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);
    assertThat(<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#5',2,'match614583-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);
    // For datasets of many double values created from an iterator, we test many combinations of
    // finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double max = Stats.of(values.asIterable</B></FONT>().iterator()).max();
      if (values.hasAnyNaN()) {
        assertWithMessage(&quot;max of &quot; + values).that(max).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage(&quot;max of &quot; + values).that(max).isPositiveInfinity();
      } else {
        assertWithMessage(&quot;max of &quot; + values).that(max).isEqualTo(MANY_VALUES_MAX);
      }
    }
    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);
  }

  public void testMin() {
    try {
      EMPTY_STATS_VARARGS.min();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.min();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).min()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).min()).isNegativeInfinity();
    assertThat(Stats.of(NaN).min()).isNaN();
    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);
    // For datasets of many double values created from an accumulator snapshot, we test many
    // combinations of finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      StatsAccumulator accumulator = new StatsAccumulator();
      accumulator.addAll(values.asIterable());
      double min = accumulator.snapshot().min();
      if (values.hasAnyNaN()) {
        assertWithMessage(&quot;min of &quot; + values).that(min).isNaN();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage(&quot;min of &quot; + values).that(min).isNegativeInfinity();
      } else {
        assertWithMessage(&quot;min of &quot; + values).that(min).isEqualTo(MANY_VALUES_MIN);
      }
    }
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);
<A NAME="2"></A>  }

  public void testEqualsAndHashCode() {
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match614583-0.html#2',2,'match614583-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new EqualsTester()
        .addEqualityGroup(
            Stats.of(1.0, 1.0, 5.0, 5.0),
            Stats.of(1.0, 1.0, 5.0, 5.0),
            Stats.of(ImmutableList.of(1.0, 1.0, 5.0, 5.0)),
            Stats.of(ImmutableList.of(1.0, 1.0, 5.0, 5.0).iterator()),
            SerializableTester.reserialize(Stats.of</B></FONT>(1.0, 1.0, 5.0, 5.0)))
        .addEqualityGroup(Stats.of(1.0, 5.0))
        .addEqualityGroup(Stats.of(1.0, 5.0, 1.0, 6.0))
        .addEqualityGroup(Stats.of(2.0, 6.0, 2.0, 6.0))
        .addEqualityGroup(
            new Stats(5, -5.5, 55.5, -5.55, 5.55), new Stats(5, -5.5, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(6, -5.5, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.6, 55.5, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.6, -5.55, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.5, -5.56, 5.55))
        .addEqualityGroup(new Stats(5, -5.5, 55.5, -5.55, 5.56))
        .testEquals();
  }

  public void testSerializable() {
    SerializableTester.reserializeAndAssert(MANY_VALUES_STATS_ITERABLE);
  }

  public void testToString() {
    assertThat(EMPTY_STATS_VARARGS.toString()).isEqualTo(&quot;Stats{count=0}&quot;);
    assertThat(MANY_VALUES_STATS_ITERABLE.toString())
        .isEqualTo(
            &quot;Stats{count=&quot;
                + MANY_VALUES_STATS_ITERABLE.count()
                + &quot;, mean=&quot;
                + MANY_VALUES_STATS_ITERABLE.mean()
                + &quot;, populationStandardDeviation=&quot;
                + MANY_VALUES_STATS_ITERABLE.populationStandardDeviation()
                + &quot;, min=&quot;
                + MANY_VALUES_STATS_ITERABLE.min()
                + &quot;, max=&quot;
                + MANY_VALUES_STATS_ITERABLE.max()
                + &quot;}&quot;);
  }

  public void testMeanOf() {
    try {
      Stats.meanOf();
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    try {
      Stats.meanOf(ImmutableList.&lt;Number&gt;of());
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    assertThat(Stats.meanOf(ONE_VALUE)).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(Stats.meanOf(POSITIVE_INFINITY)).isPositiveInfinity();
    assertThat(Stats.meanOf(NEGATIVE_INFINITY)).isNegativeInfinity();
    assertThat(Stats.meanOf(NaN)).isNaN();
    assertThat(Stats.meanOf(TWO_VALUES)).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MEAN);
    // For datasets of many double values created from an array, we test many combinations of finite
    // and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      double mean = Stats.meanOf(values.asArray());
      if (values.hasAnyNaN()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity() &amp;&amp; values.hasAnyNegativeInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNaN();
      } else if (values.hasAnyPositiveInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isPositiveInfinity();
      } else if (values.hasAnyNegativeInfinity()) {
        assertWithMessage(&quot;mean of &quot; + values).that(mean).isNegativeInfinity();
      } else {
        assertWithMessage(&quot;mean of &quot; + values)
            .that(mean)
            .isWithin(ALLOWED_ERROR)
            .of(MANY_VALUES_MEAN);
      }
    }
    assertThat(Stats.meanOf(MANY_VALUES)).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(MANY_VALUES.iterator())).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(INTEGER_MANY_VALUES))
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(Ints.toArray(INTEGER_MANY_VALUES)))
        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
        .of(INTEGER_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(LONG_MANY_VALUES))
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
    assertThat(Stats.meanOf(Longs.toArray(LONG_MANY_VALUES)))
        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
        .of(LONG_MANY_VALUES_MEAN);
  }

  public void testToByteArrayAndFromByteArrayRoundTrip() {
    for (Stats stats : ALL_STATS) {
      byte[] statsByteArray = stats.toByteArray();

      // Round trip to byte array and back
      assertThat(Stats.fromByteArray(statsByteArray)).isEqualTo(stats);
    }
  }

  public void testFromByteArray_withNullInputThrowsNullPointerException() {
    try {
      Stats.fromByteArray(null);
      fail(&quot;Expected NullPointerException&quot;);
    } catch (NullPointerException expected) {
    }
  }

  public void testFromByteArray_withEmptyArrayInputThrowsIllegalArgumentException() {
    try {
      Stats.fromByteArray(new byte[0]);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFromByteArray_withTooLongArrayInputThrowsIllegalArgumentException() {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooLongByteArray =
        ByteBuffer.allocate(buffer.length + 2)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer)
            .putChar('.')
            .array();
    try {
      Stats.fromByteArray(tooLongByteArray);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException() {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooShortByteArray =
        ByteBuffer.allocate(buffer.length - 1)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer, 0, Stats.BYTES - 1)
            .array();
    try {
      Stats.fromByteArray(tooShortByteArray);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
