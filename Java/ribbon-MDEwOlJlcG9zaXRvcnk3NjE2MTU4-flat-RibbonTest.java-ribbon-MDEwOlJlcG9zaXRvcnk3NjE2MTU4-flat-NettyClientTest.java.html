
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</h3>
            <pre><code>1  package com.netflix.ribbon;
2  import com.google.mockwebserver.MockResponse;
3  import com.google.mockwebserver.MockWebServer;
4  import com.netflix.hystrix.HystrixInvokableInfo;
5  import com.netflix.hystrix.exception.HystrixBadRequestException;
6  import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
7  import com.netflix.ribbon.http.HttpRequestTemplate;
8  import com.netflix.ribbon.http.HttpResourceGroup;
9  import com.netflix.ribbon.hystrix.FallbackHandler;
10  import io.netty.buffer.ByteBuf;
11  import io.netty.buffer.Unpooled;
12  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
13  import org.apache.log4j.Level;
14  import org.apache.log4j.LogManager;
15  import org.junit.BeforeClass;
16  import org.junit.Ignore;
17  import org.junit.Test;
18  import rx.Observable;
19  import rx.functions.Action0;
20  import rx.functions.Action1;
21  import rx.functions.Func1;
22  import java.io.IOException;
23  import java.io.UnsupportedEncodingException;
24  import java.nio.charset.Charset;
25  import java.util.Map;
26  import java.util.concurrent.CountDownLatch;
27  import java.util.concurrent.ExecutionException;
28  import java.util.concurrent.Future;
29  import java.util.concurrent.atomic.AtomicBoolean;
30  import java.util.concurrent.atomic.AtomicReference;
31  import static org.junit.Assert.*;
32  public class RibbonTest {
33      private static String toStringBlocking(RibbonRequest<ByteBuf> request) {
34          return request.toObservable().map(new Func1<ByteBuf, String>() {
35              @Override
36              public String call(ByteBuf t1) {
37                  return t1.toString(Charset.defaultCharset());
38              }
39          }).toBlocking().single();
40      }
41      @BeforeClass
42      public static void init() {
43          LogManager.getRootLogger().setLevel(Level.DEBUG);
44      }
45      @Test
46      public void testCommand() throws IOException, InterruptedException, ExecutionException {
47          MockWebServer server = new MockWebServer();
48          String content = "Hello world";
49          MockResponse response = new MockResponse()
50              .setResponseCode(200)
51              .setHeader("Content-type", "text/plain")
52              .setBody(content);
53          server.enqueue(response);        
54          server.enqueue(response);       
55          server.enqueue(response);       
56          server.play();
57          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient",
58                  ClientOptions.create()
59                  .withMaxAutoRetriesNextServer(3)
60                  .withReadTimeout(300000)
61                  .withConfigurationBasedServerList("localhost:12345, localhost:10092, localhost:" + server.getPort()));
62          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
63                  .withUriTemplate("/")
64                  .withMethod("GET")
65                  .build();
66          RibbonRequest<ByteBuf> request = template.requestBuilder().build();
67          String result = request.execute().toString(Charset.defaultCharset());
68          assertEquals(content, result);
69          ByteBuf raw = request.execute();
70          result = raw.toString(Charset.defaultCharset());
71          raw.release();
72          assertEquals(content, result);
73          result = request.queue().get().toString(Charset.defaultCharset());
74          assertEquals(content, result);
75      }
76      @Test
77      public void testHystrixCache() throws IOException {
78          MockWebServer server = new MockWebServer();
79          String content = "Hello world";
80          MockResponse response = new MockResponse()
81              .setResponseCode(200)
82              .setHeader("Content-type", "text/plain")
83              .setBody(content);
84          server.enqueue(response);
85          server.enqueue(response);       
86          server.play();
87          HttpResourceGroup group = Ribbon.createHttpResourceGroupBuilder("myclient").build();
88          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
89                  .withUriTemplate("http:&bsol;&bsol;localhost:" + server.getPort())
90                  .withMethod("GET")
91                  .withRequestCacheKey("xyz")
92                  .build();
93          RibbonRequest<ByteBuf> request = template
94                  .requestBuilder().build();
95          HystrixRequestContext context = HystrixRequestContext.initializeContext();
96          try {
97              RibbonResponse<ByteBuf> ribbonResponse = request.withMetadata().execute();
98              assertFalse(ribbonResponse.getHystrixInfo().isResponseFromCache());
99              ribbonResponse = request.withMetadata().execute();
100              assertTrue(ribbonResponse.getHystrixInfo().isResponseFromCache());
101          } finally {
102              context.shutdown();
103          }
104      }
105      @Test
106      @Ignore
107      public void testCommandWithMetaData() throws IOException, InterruptedException, ExecutionException {
108          MockWebServer server = new MockWebServer();
109          String content = "Hello world";
110          for (int i = 0; i < 6; i++) {
111              server.enqueue(new MockResponse()
112                  .setResponseCode(200)
113                  .setHeader("Content-type", "text/plain")
114                  .setBody(content));
115          }
116          server.play();
117          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
118                  .withConfigurationBasedServerList("localhost:" + server.getPort())
119                  .withMaxAutoRetriesNextServer(3));
120          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
121                  .withUriTemplate("/")
122                  .withMethod("GET")
123                  .withCacheProvider("somekey", new CacheProvider<ByteBuf>(){
124                      @Override
125                      public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
126                          return Observable.error(new Exception("Cache miss"));
127                      }
128                  }).build();
129          RibbonRequest<ByteBuf> request = template
130                  .requestBuilder().build();
131          final AtomicBoolean success = new AtomicBoolean(false);
132          RequestWithMetaData<ByteBuf> metaRequest = request.withMetadata();
133          Observable<String> result = metaRequest.toObservable().flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<String>>(){
134              @Override
135              public Observable<String> call(
136                      final RibbonResponse<Observable<ByteBuf>> response) {
137                  success.set(response.getHystrixInfo().isSuccessfulExecution());
138                  return response.content().map(new Func1<ByteBuf, String>(){
139                      @Override
140                      public String call(ByteBuf t1) {
141                          return t1.toString(Charset.defaultCharset());
142                      }
143                  });
144              }
145          });
146          String s = result.toBlocking().single();
147          assertEquals(content, s);
148          assertTrue(success.get());
149          Future<RibbonResponse<ByteBuf>> future = metaRequest.queue();
150          RibbonResponse<ByteBuf> response = future.get();
151          assertTrue(future.isDone());
152          assertEquals(content, response.content().toString(Charset.defaultCharset()));
153          assertTrue(response.getHystrixInfo().isSuccessfulExecution()); 
154          RibbonResponse<ByteBuf> result1 = metaRequest.execute();
155          assertEquals(content, result1.content().toString(Charset.defaultCharset()));
156          assertTrue(result1.getHystrixInfo().isSuccessfulExecution());
157      }
158      @Test
159      public void testValidator() throws IOException, InterruptedException {
160          MockWebServer server = new MockWebServer();
161          String content = "Hello world";
162          server.enqueue(new MockResponse()
163                  .setResponseCode(200)
164                  .setHeader("Content-type", "text/plain")
165                  .setBody(content));       
166          server.play();
167          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
168                  .withConfigurationBasedServerList("localhost:" + server.getPort()));
169          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
170                  .withUriTemplate("/")
171                  .withMethod("GET")
172                  .withResponseValidator(new ResponseValidator<HttpClientResponse<ByteBuf>>() {
173                      @Override
174                      public void validate(HttpClientResponse<ByteBuf> t1) throws UnsuccessfulResponseException {
175                          throw new UnsuccessfulResponseException("error", new IllegalArgumentException());
176                      }
177                  }).build();
178          RibbonRequest<ByteBuf> request = template.requestBuilder().build();
179          final CountDownLatch latch = new CountDownLatch(1);
180          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
181          request.toObservable().subscribe(new Action1<ByteBuf>() {
182              @Override
183              public void call(ByteBuf t1) {
184              }
185          }, 
186          new Action1<Throwable>(){
187              @Override
188              public void call(Throwable t1) {
189                  error.set(t1);
<span onclick='openModal()' class='match'>190                  latch.countDown();
191              }
192          }, 
193          new Action0() {
194              @Override
195              public void call() {
196              }
</span>197          });
198          latch.await();
199          assertTrue(error.get() instanceof HystrixBadRequestException);
200          assertTrue(error.get().getCause() instanceof UnsuccessfulResponseException);
201      }
202      @Test
203      public void testFallback() throws IOException {
204          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
205                  .withConfigurationBasedServerList("localhost:12345")
206                  .withMaxAutoRetriesNextServer(1));
207          final String fallback = "fallback";
208          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
209                  .withUriTemplate("/")
210                  .withMethod("GET")
211                  .withFallbackProvider(new FallbackHandler<ByteBuf>() {
212                      @Override
213                      public Observable<ByteBuf> getFallback(
214                              HystrixInvokableInfo<?> hystrixInfo,
215                              Map<String, Object> requestProperties) {
216                          try {
217                              return Observable.just(Unpooled.buffer().writeBytes(fallback.getBytes("UTF-8")));
218                          } catch (UnsupportedEncodingException e) {
219                              return Observable.error(e);
220                          }
221                      }
222                  }).build();
223          RibbonRequest<ByteBuf> request = template
224                  .requestBuilder().build();
225          final AtomicReference<HystrixInvokableInfo<?>> hystrixInfo = new AtomicReference<HystrixInvokableInfo<?>>();
226          final AtomicBoolean failed = new AtomicBoolean(false);
227          Observable<String> result = request.withMetadata().toObservable().flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<String>>(){
228              @Override
229              public Observable<String> call(
230                      final RibbonResponse<Observable<ByteBuf>> response) {
231                  hystrixInfo.set(response.getHystrixInfo());
232                  failed.set(response.getHystrixInfo().isFailedExecution());
233                  return response.content().map(new Func1<ByteBuf, String>(){
234                      @Override
235                      public String call(ByteBuf t1) {
236                          return t1.toString(Charset.defaultCharset());
237                      }
238                  });
239              }
240          });
241          String s = result.toBlocking().single();
242          assertTrue(hystrixInfo.get().isResponseFromFallback());
243          assertTrue(failed.get());
244          assertEquals(fallback, s);
245      }
246      @Test
247      public void testCacheHit() {
248          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
249                  .withConfigurationBasedServerList("localhost:12345")
250                  .withMaxAutoRetriesNextServer(1));
251          final String content = "from cache";
252          final String cacheKey = "somekey";
253          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
254          .withCacheProvider(cacheKey, new CacheProvider<ByteBuf>(){
255              @Override
256              public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
257                  if (key.equals(cacheKey)) {
258                      try {
259                          return Observable.just(Unpooled.buffer().writeBytes(content.getBytes("UTF-8")));
260                      } catch (UnsupportedEncodingException e) {
261                          return Observable.error(e);
262                      }
263                  } else {
264                      return Observable.error(new Exception("Cache miss"));
265                  }
266              }
267          }).withUriTemplate("/")
268                  .withMethod("GET").build();
269          RibbonRequest<ByteBuf> request = template
270                  .requestBuilder().build();
271          String result = request.execute().toString(Charset.defaultCharset());
272          assertEquals(content, result);
273      }
274      @Test
275      public void testObserve() throws IOException, InterruptedException {
276          MockWebServer server = new MockWebServer();
277          String content = "Hello world";
278          server.enqueue(new MockResponse()
279                  .setResponseCode(200)
280                  .setHeader("Content-type", "text/plain")
281                  .setBody(content));       
282          server.enqueue(new MockResponse()
283                  .setResponseCode(200)
284                  .setHeader("Content-type", "text/plain")
285                  .setBody(content));       
286          server.play();
287          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient",
288                  ClientOptions.create()
289                  .withMaxAutoRetriesNextServer(3)
290                  .withReadTimeout(300000)
291                  .withConfigurationBasedServerList("localhost:12345, localhost:10092, localhost:" + server.getPort()));
292          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
293                  .withUriTemplate("/")
294                  .withMethod("GET").build();
295          RibbonRequest<ByteBuf> request = template
296                  .requestBuilder().build();
297          Observable<ByteBuf> result = request.observe();
298          final CountDownLatch latch = new CountDownLatch(1);
299          final AtomicReference<String> fromCommand = new AtomicReference<String>();
300          result.toBlocking().last();
301          result.subscribe(new Action1<ByteBuf>() {
302              @Override
303              public void call(ByteBuf t1) {
304                  try {
305                      fromCommand.set(t1.toString(Charset.defaultCharset()));
306                  } catch (Exception e) {
307                      e.printStackTrace();
308                  }
309                  latch.countDown();
310              }
311          });
312          latch.await();
313          assertEquals(content, fromCommand.get());
314          Observable<RibbonResponse<Observable<ByteBuf>>> metaResult = request.withMetadata().observe();
315          String result2 = "";
316          metaResult.toBlocking().last();
317          result2 = metaResult.flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<ByteBuf>>(){
318              @Override
319              public Observable<ByteBuf> call(
320                      RibbonResponse<Observable<ByteBuf>> t1) {
321                  return t1.content();
322              }
323          }).map(new Func1<ByteBuf, String>(){
324              @Override
325              public String call(ByteBuf t1) {
326                  return t1.toString(Charset.defaultCharset());
327              }
328          }).toBlocking().single();
329          assertEquals(content, result2);
330      }
331      @Test
332      public void testCacheMiss() throws IOException, InterruptedException {
333          MockWebServer server = new MockWebServer();
334          String content = "Hello world";
335          server.enqueue(new MockResponse()
336                  .setResponseCode(200)
337                  .setHeader("Content-type", "text/plain")
338                  .setBody(content));       
339          server.play();
340          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
341                  .withConfigurationBasedServerList("localhost:" + server.getPort())
342                  .withMaxAutoRetriesNextServer(1));
343          final String cacheKey = "somekey";
344          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
345                  .withCacheProvider(cacheKey, new CacheProvider<ByteBuf>(){
346                      @Override
347                      public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
348                          return Observable.error(new Exception("Cache miss again"));
349                      }
350                  })
351                  .withMethod("GET")
352                  .withUriTemplate("/").build();
353          RibbonRequest<ByteBuf> request = template
354                  .requestBuilder().build();
355          String result = toStringBlocking(request);
356          assertEquals(content, result);
357      } 
358  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import static com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout;
3  import static org.junit.Assert.assertEquals;
4  import static org.junit.Assert.assertNotNull;
5  import static org.junit.Assert.assertNull;
6  import static org.junit.Assert.assertTrue;
7  import static org.junit.Assert.fail;
8  import io.netty.buffer.ByteBuf;
9  import io.netty.buffer.ByteBufInputStream;
10  import io.netty.buffer.Unpooled;
11  import io.reactivex.netty.contexts.ContextsContainer;
12  import io.reactivex.netty.contexts.ContextsContainerImpl;
13  import io.reactivex.netty.contexts.MapBackedKeySupplier;
14  import io.reactivex.netty.contexts.RxContexts;
15  import io.reactivex.netty.protocol.http.client.HttpClient.HttpClientConfig;
16  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
17  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
18  import io.reactivex.netty.protocol.text.sse.ServerSentEvent;
19  import io.reactivex.netty.servo.http.HttpClientListener;
20  import java.io.IOException;
21  import java.nio.charset.Charset;
22  import java.util.Iterator;
23  import java.util.List;
24  import java.util.Random;
25  import java.util.concurrent.CountDownLatch;
26  import java.util.concurrent.ExecutorService;
27  import java.util.concurrent.Executors;
28  import java.util.concurrent.atomic.AtomicReference;
29  import org.codehaus.jackson.map.ObjectMapper;
30  import org.junit.BeforeClass;
31  import org.junit.Ignore;
32  import org.junit.Test;
33  import rx.Observable;
34  import rx.functions.Action0;
35  import rx.functions.Action1;
36  import rx.functions.Func0;
37  import rx.functions.Func1;
38  import com.google.common.collect.Lists;
39  import com.google.mockwebserver.MockResponse;
40  import com.google.mockwebserver.MockWebServer;
41  import com.netflix.client.ClientException;
42  import com.netflix.client.RequestSpecificRetryHandler;
43  import com.netflix.client.RetryHandler;
44  import com.netflix.client.config.CommonClientConfigKey;
45  import com.netflix.client.config.DefaultClientConfigImpl;
46  import com.netflix.client.config.IClientConfig;
47  import com.netflix.client.config.IClientConfigKey;
48  import com.netflix.loadbalancer.AvailabilityFilteringRule;
49  import com.netflix.loadbalancer.BaseLoadBalancer;
50  import com.netflix.loadbalancer.DummyPing;
51  import com.netflix.loadbalancer.LoadBalancerBuilder;
52  import com.netflix.loadbalancer.Server;
53  import com.netflix.loadbalancer.ServerStats;
54  import com.netflix.ribbon.test.resources.EmbeddedResources;
55  import com.netflix.ribbon.test.resources.EmbeddedResources.Person;
56  import com.netflix.ribbon.transport.netty.RibbonTransport;
57  import com.netflix.serialization.JacksonCodec;
58  import com.netflix.serialization.SerializationUtils;
59  import com.netflix.serialization.TypeDef;
60  import com.sun.jersey.api.container.httpserver.HttpServerFactory;
61  import com.sun.jersey.api.core.PackagesResourceConfig;
62  import com.sun.net.httpserver.HttpServer;
63  public class NettyClientTest {
64      private static HttpServer server = null;
65      private static String SERVICE_URI;
66      private static int port;
67      private static final String host = "localhost";
68      static Observable<ServerSentEvent> transformSSE(Observable<HttpClientResponse<ServerSentEvent>> response) {
69          return response.flatMap(new Func1<HttpClientResponse<ServerSentEvent>, Observable<ServerSentEvent>>() {
70              @Override
71              public Observable<ServerSentEvent> call(HttpClientResponse<ServerSentEvent> t1) {
72                  return t1.getContent();
73              }
74          });
75      }
76      @BeforeClass 
77      public static void init() throws Exception {
78          PackagesResourceConfig resourceConfig = new PackagesResourceConfig("com.netflix.ribbon.test.resources");
79          port = (new Random()).nextInt(1000) + 4000;
80          SERVICE_URI = "http:&bsol;&bsol;localhost:" + port + "/";
81          ExecutorService service = Executors.newFixedThreadPool(20);
82          try{
83              server = HttpServerFactory.create(SERVICE_URI, resourceConfig);           
84              server.setExecutor(service);
85              server.start();
86          } catch(Exception e) {
87              e.printStackTrace();
88              fail("Unable to start server");
89          }
90      }
91      private static Observable<Person> getPersonObservable(Observable<HttpClientResponse<ByteBuf>> response) {
92          return response.flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>() {
93              @Override
94              public Observable<ByteBuf> call(HttpClientResponse<ByteBuf> t1) {
95                  return t1.getContent();
96              }
97          }).map(new Func1<ByteBuf, Person>() {
98              @Override
99              public Person call(ByteBuf t1) {
100                  try {
101                      return JacksonCodec.<Person>getInstance().deserialize(new ByteBufInputStream(t1), TypeDef.fromClass(Person.class));
102                  } catch (IOException e) {
103                      e.printStackTrace();
104                      return null;
105                  }
106              }
107          });
108      }
109      @Test
110      public void testObservable() throws Exception {
111          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
112          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
113          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
114          Person person = getPersonObservable(response).toBlocking().single();
115          assertEquals(EmbeddedResources.defaultPerson, person);
116          final HttpClientListener listener = observableClient.getListener();
117          assertEquals(1, listener.getPoolAcquires());
118          assertEquals(1, listener.getConnectionCount());
119          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
120              @Override
121              public Boolean call() {
122                  return listener.getPoolReleases() == 1;
123              }
124          });
125      }
126      @Test
127      public void testSubmitToAbsoluteURI() throws Exception {
128          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
129          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
130          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
131          Person person = getPersonObservable(response).toBlocking().single();
132          assertEquals(EmbeddedResources.defaultPerson, person);
133          final HttpClientListener listener = observableClient.getListener();
134          assertEquals(1, listener.getConnectionCount());
135          assertEquals(1, listener.getPoolAcquires());
136          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
137              @Override
138              public Boolean call() {
139                  return listener.getPoolReleases() == 1;
140              }
141          });
142      }
143      @Test
144      public void testPoolReuse() throws Exception {
145          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/person");
146          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
147                  IClientConfig.Builder.newBuilder().withDefaultValues()
148                  .withMaxAutoRetries(1)
149                  .withMaxAutoRetriesNextServer(1).build());
150          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
151          Person person = getPersonObservable(response).toBlocking().single();
152          assertEquals(EmbeddedResources.defaultPerson, person);
153          response = observableClient.submit(request);
154          person = getPersonObservable(response).toBlocking().single();
155          assertEquals(EmbeddedResources.defaultPerson, person);
156          final HttpClientListener listener = observableClient.getListener();
157          assertEquals(2, listener.getPoolAcquires());
158          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
159              @Override
160              public Boolean call() {
161                  return listener.getPoolReleases() == 2;
162              }
163          });
164          assertEquals(1, listener.getConnectionCount());
165          assertEquals(1, listener.getPoolReuse());
166      }
167      @Test
168      public void testPostWithObservable() throws Exception {
169          Person myPerson = new Person("netty", 5);
170          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost(SERVICE_URI + "testAsync/person")
171                  .withHeader("Content-type", "application/json")
172                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), myPerson, null));
173          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
174                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
175          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(new Server(host, port), request);
176          Person person = getPersonObservable(response).toBlocking().single();
177          assertEquals(myPerson, person);
178      }
179      @Test
180      public void testPostWithByteBuf() throws Exception {
181          Person myPerson = new Person("netty", 5);
182          ObjectMapper mapper = new ObjectMapper();
183          byte[] raw = mapper.writeValueAsBytes(myPerson);
184          ByteBuf buffer = Unpooled.copiedBuffer(raw);
185          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost(SERVICE_URI + "testAsync/person")
186                  .withHeader("Content-type", "application/json")
187                  .withHeader("Content-length", String.valueOf(raw.length))
188                  .withContent(buffer);
189          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
190                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
191          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(request);
192          Person person = getPersonObservable(response).toBlocking().single();
193          assertEquals(myPerson, person);
194      }
195      @Test
196      public void testConnectTimeout() throws Exception {
197          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
198                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1"));
199          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;www.google.com:81/");
200          Observable<HttpClientResponse<ByteBuf>> observable = observableClient.submit(new Server("www.google.com", 81), request);
201          ObserverWithLatch<HttpClientResponse<ByteBuf>> observer = new ObserverWithLatch<HttpClientResponse<ByteBuf>>();
202          observable.subscribe(observer);
203          observer.await();
204          assertNotNull(observer.error);
205          assertTrue(observer.error instanceof io.netty.channel.ConnectTimeoutException);
206      }
207      @Test
208      public void testReadTimeout() throws Exception {
209          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient(
210                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ReadTimeout, "100"));
211          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/readTimeout");
212          Observable<HttpClientResponse<ByteBuf>> observable = observableClient.submit(request);
213          ObserverWithLatch<HttpClientResponse<ByteBuf>> observer = new ObserverWithLatch<HttpClientResponse<ByteBuf>>();
214          observable.subscribe(observer);
215          observer.await();
216          assertTrue(observer.error instanceof io.netty.handler.timeout.ReadTimeoutException);      
217      }
218      @Test
219      public void testObservableWithMultipleServers() throws Exception {
220          IClientConfig config = DefaultClientConfigImpl
221                  .getClientConfigWithDefaultValues()
222                  .withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
223          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
224          Server badServer = new Server("localhost:12345");
225          Server goodServer = new Server("localhost:" + port);
226          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
227          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
228                  .withRule(new AvailabilityFilteringRule())
229                  .withPing(new DummyPing())
230                  .buildFixedServerListLoadBalancer(servers);
231          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
232                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
233          Person person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
234          assertEquals(EmbeddedResources.defaultPerson, person);
235          ServerStats stats = lbObservables.getServerStats(badServer);
236          assertEquals(4, stats.getTotalRequestsCount());
237          assertEquals(0, stats.getActiveRequestsCount());
238          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
239          stats = lbObservables.getServerStats(goodServer);
240          assertEquals(1, stats.getTotalRequestsCount());
241          assertEquals(0, stats.getActiveRequestsCount());
242          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
243          person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
244          assertEquals(EmbeddedResources.defaultPerson, person);
245          HttpClientListener listener = lbObservables.getListener();
246          assertEquals(1, listener.getPoolReuse());
247      }
248      @Test
249      public void testObservableWithMultipleServersWithOverrideRxConfig() throws Exception {
250          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
251          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
252          Server badServer = new Server("localhost:12345");
253          Server goodServer = new Server("localhost:" + port);
254          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
255          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
256                  .withRule(new AvailabilityFilteringRule())
257                  .withPing(new DummyPing())
258                  .buildFixedServerListLoadBalancer(servers);
259          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
260                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
261          HttpClientConfig rxconfig = HttpClientConfig.Builder.newDefaultConfig();
262          Person person = getPersonObservable(lbObservables.submit(request, rxconfig)).toBlocking().single();
263          assertEquals(EmbeddedResources.defaultPerson, person);
264          ServerStats stats = lbObservables.getServerStats(badServer);
265          assertEquals(4, stats.getTotalRequestsCount());
266          assertEquals(0, stats.getActiveRequestsCount());
267          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
268          stats = lbObservables.getServerStats(goodServer);
269          assertEquals(1, stats.getTotalRequestsCount());
270          assertEquals(0, stats.getActiveRequestsCount());
271          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
272          final HttpClientListener listener = lbObservables.getListener();
273          assertEquals(1, listener.getConnectionCount());
274          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
275              @Override
276              public Boolean call() {
277                  return listener.getPoolReleases() == 1;
278              }
279          });
280      }
281      @Test
282      public void testObservableWithRetrySameServer() throws Exception {
283          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "1000");
284          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
285          Server badServer = new Server("localhost:12345");
286          Server goodServer = new Server("localhost:" + port);
287          List<Server> servers = Lists.newArrayList(badServer, badServer, goodServer);
288          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
289                  .withRule(new AvailabilityFilteringRule())
290                  .withPing(new DummyPing())
291                  .buildFixedServerListLoadBalancer(servers);
292          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config,
293                  new NettyHttpLoadBalancerErrorHandler(1, 0, true));
294          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
295          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
296          observableWithRetries.subscribe(observer);
297          observer.await();
298          assertNull(observer.obj);
299          assertTrue(observer.error instanceof ClientException);
300          ServerStats stats = lbObservables.getServerStats(badServer);
301          assertEquals(2, stats.getTotalRequestsCount());
302          assertEquals(0, stats.getActiveRequestsCount());
303          stats = lbObservables.getServerStats(goodServer);
304          assertEquals(0, stats.getTotalRequestsCount());
305      }
306      @Test
307      public void testLoadBalancingObservablesWithReadTimeout() throws Exception {
308          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
309          MockWebServer server = new MockWebServer();
310          String content = "{\"name\": \"ribbon\", \"age\": 2}";
311          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
312                  .setBody(content));       
313          server.play();
314          IClientConfig config = DefaultClientConfigImpl
315                  .getClientConfigWithDefaultValues()
316                  .set(CommonClientConfigKey.ReadTimeout, 100);
317          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/readTimeout");
318          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
319          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
320          Server goodServer = new Server("localhost:" + server.getPort());
321          Server badServer  = new Server("localhost:" + port);
322          lb.setServersList(Lists.newArrayList(goodServer, badServer, badServer, goodServer));
323          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
324          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
325          observableWithRetries.subscribe(observer);
326          observer.await();
327          if (observer.error != null) {
328              observer.error.printStackTrace();
329          }
330          assertEquals("ribbon", observer.obj.name);
331          assertEquals(2, observer.obj.age);
332          ServerStats stats = lbObservables.getServerStats(badServer);
333          server.shutdown();
334          final HttpClientListener listener = lbObservables.getListener();
335          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
336              @Override
337              public Boolean call() {
338                  return listener.getPoolReleases() == 5;
339              }
340          });
341          assertEquals(0, listener.getPoolReuse());
342          assertEquals(4, stats.getTotalRequestsCount());
343          assertEquals(0, stats.getActiveRequestsCount());
344          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
345          stats = lbObservables.getServerStats(goodServer);
346          assertEquals(1, stats.getTotalRequestsCount());
347          assertEquals(0, stats.getActiveRequestsCount());
348          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
349      }
350      @Test
351      public void testLoadBalancingWithTwoServers() throws Exception {
352          MockWebServer server = new MockWebServer();
353          String content = "{\"name\": \"ribbon\", \"age\": 2}";
354          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
355                  .setBody(content));       
356          server.play();
357          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
358          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/person")
359                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
360                  .withHeader("Content-type", "application/json");
361          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
362          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
363          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
364          HttpClientListener externalListener = HttpClientListener.newHttpListener("external");
365          lbObservables.subscribe(externalListener);
366          Server server1 = new Server("localhost:" + server.getPort());
367          Server server2 = new Server("localhost:" + port);
368          lb.setServersList(Lists.newArrayList(server1, server2));
369          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
370              @Override
371              public boolean isRetriableException(Throwable e, boolean sameServer) {
372                  return true;
373              }
374          };
375          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
376          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
377          observableWithRetries.subscribe(observer);
378          observer.await();
379          if (observer.error != null) {
380              observer.error.printStackTrace();
381          }
382          assertEquals("ribbon", observer.obj.name);
383          assertEquals(EmbeddedResources.defaultPerson.age, observer.obj.age);
384          observer = new ObserverWithLatch<Person>();
385          observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
386          observableWithRetries.subscribe(observer);
387          observer.await();
388          if (observer.error != null) {
389              observer.error.printStackTrace();
390          }
391          assertEquals("ribbon", observer.obj.name);
392          assertEquals(2, observer.obj.age);
393          ServerStats stats = lbObservables.getServerStats(server1);
394          server.shutdown();
395          assertEquals(0, stats.getActiveRequestsCount());
396          stats = lbObservables.getServerStats(server2);
397          assertEquals(1, stats.getTotalRequestsCount());
398          assertEquals(0, stats.getActiveRequestsCount());
399          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
400          final HttpClientListener listener = lbObservables.getListener();
401          assertEquals(2, listener.getPoolAcquires());
402          waitUntilTrueOrTimeout(1000, new Func0<Boolean>() {
403              @Override
404              public Boolean call() {
405                  return listener.getPoolReleases() == 2;
406              }
407          });
408          assertEquals(2, listener.getConnectionCount());
409          assertEquals(0, listener.getPoolReuse());
410          assertEquals(2, externalListener.getPoolAcquires());
411      }
412      @Test
413      public void testLoadBalancingPostWithReadTimeout() throws Exception {
414          MockWebServer server = new MockWebServer();
415          String content = "{\"name\": \"ribbon\", \"age\": 2}";
416          server.enqueue(new MockResponse()
417                  .setResponseCode(200)
418                  .setHeader("Content-type", "application/json")
419                  .setBody(content));       
420          server.play();
421          IClientConfig config = DefaultClientConfigImpl
422                  .getClientConfigWithDefaultValues()
423                  .set(CommonClientConfigKey.ReadTimeout, 100);
424          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/postTimeout")
425                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
426                  .withHeader("Content-type", "application/json");
427          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
428          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
429          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
430          Server goodServer = new Server("localhost:" + server.getPort());
431          Server badServer = new Server("localhost:" + port);
432          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
433          lb.setServersList(servers);
434          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
435              @Override
436              public boolean isRetriableException(Throwable e, boolean sameServer) {
437                  return true;
438              }
439          };
440          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
441          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
442          observableWithRetries.subscribe(observer);
443          observer.await();
444          if (observer.error != null) {
445              observer.error.printStackTrace();
446          }
447          assertEquals("ribbon", observer.obj.name);
448          assertEquals(2, observer.obj.age);
449          ServerStats stats = lbObservables.getServerStats(badServer);
450          server.shutdown();
451          assertEquals(4, stats.getTotalRequestsCount());
452          assertEquals(0, stats.getActiveRequestsCount());
453          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
454          stats = lbObservables.getServerStats(goodServer);
455          assertEquals(1, stats.getTotalRequestsCount());
456          assertEquals(0, stats.getActiveRequestsCount());
457          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
458      }
459      @Test
460      public void testLoadBalancingPostWithNoRetrySameServer() throws Exception {
461          MockWebServer server = new MockWebServer();
462          String content = "{\"name\": \"ribbon\", \"age\": 2}";
463          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
464                  .setBody(content));       
465          server.play();
466          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
467                  .set(CommonClientConfigKey.ReadTimeout, 100);
468          HttpClientRequest<ByteBuf> request = HttpClientRequest.createPost("/testAsync/postTimeout")
469                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
470                  .withHeader("Content-type", "application/json");
471          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(0, 3, true);
472          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
473          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
474          Server goodServer = new Server("localhost:" + server.getPort());
475          Server badServer = new Server("localhost:" + port);
476          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
477          lb.setServersList(servers);
478          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
479              @Override
480              public boolean isRetriableException(Throwable e, boolean sameServer) {
481                  return true;
482              }
483          };
484          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
485          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
486          observableWithRetries.subscribe(observer);
487          observer.await();
488          if (observer.error != null) {
489              observer.error.printStackTrace();
490          }
491          server.shutdown();
492          assertEquals("ribbon", observer.obj.name);
493          assertEquals(2, observer.obj.age);
494          ServerStats stats = lbObservables.getServerStats(badServer);
495          assertEquals(2, stats.getTotalRequestsCount());
496          assertEquals(0, stats.getActiveRequestsCount());
497          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
498          stats = lbObservables.getServerStats(goodServer);
499          assertEquals(1, stats.getTotalRequestsCount());
500          assertEquals(0, stats.getActiveRequestsCount());
501          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
502      }
503      @Test
504      public void testObservableWithMultipleServersFailed() throws Exception {        
505          IClientConfig config = IClientConfig.Builder.newBuilder()
506                  .withDefaultValues()
507                  .withRetryOnAllOperations(true)
508                  .withMaxAutoRetries(1)
509                  .withMaxAutoRetriesNextServer(3)
510                  .withConnectTimeout(100)
511                  .build();
512          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
513          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
514          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config);
515          Server badServer = new Server("localhost:12345");
516          Server badServer1 = new Server("localhost:12346");
517          Server badServer2 = new Server("localhost:12347");
518          List<Server> servers = Lists.newArrayList(badServer, badServer1, badServer2);
519          lb.setServersList(servers);
520          Observable<Person> observableWithRetries = getPersonObservable(lbObservables.submit(request));
521          ObserverWithLatch<Person> observer = new ObserverWithLatch<Person>();
522          observableWithRetries.subscribe(observer);
523          observer.await();
524          assertNull(observer.obj);
525          observer.error.printStackTrace();
526          assertTrue(observer.error instanceof ClientException);
527          ServerStats stats = lbObservables.getServerStats(badServer);
528          assertEquals(2, stats.getTotalRequestsCount());
529          assertEquals(0, stats.getActiveRequestsCount());
530          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
531      }
532      private static List<Person> getPersonListFromResponse(Observable<HttpClientResponse<ServerSentEvent>> response) {
533          return getPersonList(transformSSE(response));
534      }
535      private static List<Person> getPersonList(Observable<ServerSentEvent> events) {
536          List<Person> result = Lists.newArrayList();
537          Iterator<Person> iterator = events.map(new Func1<ServerSentEvent, Person>() {
538              @Override
539              public Person call(ServerSentEvent t1) {
540                  String content = t1.getEventData();
541                  try {
542                      return SerializationUtils.deserializeFromString(JacksonCodec.<Person>getInstance(), content, TypeDef.fromClass(Person.class));
543                  } catch (IOException e) {
544                      e.printStackTrace();
545                      return null;
546                  }
547              }
548          }).toBlocking().getIterator();
549          while (iterator.hasNext()) {
550              result.add(iterator.next());
551          }
552          return result;
553      }
554      @Test
555      public void testStream() throws Exception {
556          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/personStream");
557          LoadBalancingHttpClient<ByteBuf, ServerSentEvent> observableClient = (LoadBalancingHttpClient<ByteBuf, ServerSentEvent>) RibbonTransport.newSSEClient();
558          List<Person> result = getPersonListFromResponse(observableClient.submit(new Server(host, port), request));
559          assertEquals(EmbeddedResources.entityStream, result);
560      }
561      @Test
562      public void testStreamWithLoadBalancer() throws Exception {
563          IClientConfig config = IClientConfig.Builder.newBuilder().withRetryOnAllOperations(true)
564                  .withMaxAutoRetries(1)
565                  .withMaxAutoRetriesNextServer(3)
566                  .build();
567          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
568          LoadBalancingHttpClient<ByteBuf, ServerSentEvent> lbObservables = (LoadBalancingHttpClient<ByteBuf, ServerSentEvent>) RibbonTransport.newSSEClient(lb, config);
569          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/personStream");
570          List<Person> result = Lists.newArrayList();
571          Server goodServer = new Server("localhost:" + port);
572          Server badServer = new Server("localhost:12245");
573          List<Server> servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
574          lb.setServersList(servers);
575          result = getPersonListFromResponse(lbObservables.submit(request, null, null));
576          assertEquals(EmbeddedResources.entityStream, result);
577      }
578      @Test
579      public void testQuery() throws Exception {
580          Person myPerson = new Person("hello_world", 4);
581          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/personQuery?name=" + myPerson.name + "&age=" + myPerson.age);
582          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
583          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
584          assertEquals(myPerson, person);
585      }
586      @Test
587      public void testUnexpectedResponse() throws Exception {
588          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/throttle");
589          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient();
590          Observable<HttpClientResponse<ByteBuf>> responseObservable = client.submit(new Server(host, port), request);
591          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
592          final CountDownLatch latch = new CountDownLatch(1);
593          responseObservable.subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
594              @Override
595              public void call(HttpClientResponse<ByteBuf> t1) {
596                  latch.countDown();
597              }
598          }, new Action1<Throwable>(){
599              @Override
600              public void call(Throwable t1) {
601                  error.set(t1);
602                  latch.countDown();
603              }
604          });
605          latch.await();
606          assertTrue(error.get() instanceof ClientException);
607          ClientException ce = (ClientException) error.get();
608          assertTrue(ce.getErrorType() == ClientException.ErrorType.SERVER_THROTTLED);
609      }
610      @Test
611      public void testLoadBalancerThrottle() throws Exception {
612          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/throttle");
613          IClientConfig config = DefaultClientConfigImpl
614                  .getClientConfigWithDefaultValues()
615                  .set(IClientConfigKey.Keys.MaxAutoRetriesNextServer, 1)
616                  .set(IClientConfigKey.Keys.OkToRetryOnAllOperations, true);
617          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
618          LoadBalancingHttpClient<ByteBuf, ByteBuf> lbObservables = RibbonTransport.newHttpClient(lb, config);
619          Server server = new Server(host, port);
620          lb.setServersList(Lists.newArrayList(server, server, server));
621          Observable<HttpClientResponse<ByteBuf>> response = lbObservables.submit(request);
622          final CountDownLatch latch = new CountDownLatch(1);
623          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
624          response.subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
625              @Override
626              public void call(HttpClientResponse<ByteBuf> t1) {
627                  System.err.println("Get response: " + t1.getStatus().code());
628                  latch.countDown();
629              }
630          }, new Action1<Throwable>(){
631              @Override
632              public void call(Throwable t1) {
633                  error.set(t1);
<span onclick='openModal()' class='match'>634                  latch.countDown();
635              }
636          }, new Action0() {
637              @Override
638              public void call() {
639                  Thread.dumpStack();
</span>640                  latch.countDown();
641              }
642          });
643          latch.await();
644          assertTrue(error.get() instanceof ClientException);
645          ClientException ce = (ClientException) error.get();
646          assertTrue(ce.toString(), ce.getErrorType() == ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED);
647          assertEquals(2, lbObservables.getServerStats(server).getSuccessiveConnectionFailureCount());
648      }
649      @Test
650      public void testContext() throws Exception {
651          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/context");
652          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient = RibbonTransport.newHttpClient();
653          String requestId = "xyz";
654          ContextsContainerImpl contextsContainer = new ContextsContainerImpl(new MapBackedKeySupplier());
655          contextsContainer.addContext("Context1", "value1");
656          RxContexts.DEFAULT_CORRELATOR.onNewServerRequest(requestId, contextsContainer);
657          Observable<HttpClientResponse<ByteBuf>> response = observableClient.submit(new Server(host, port), request);
658          final AtomicReference<ContextsContainer> responseContext = new AtomicReference<ContextsContainer>(); 
659          String requestIdSent = response.flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>() {
660              @Override
661              public Observable<ByteBuf> call(HttpClientResponse<ByteBuf> t1) {
662                  return t1.getContent();
663              }
664          }).map(new Func1<ByteBuf, String>() {
665              @Override
666              public String call(ByteBuf t1) {
667                  String requestId = RxContexts.DEFAULT_CORRELATOR.getRequestIdForClientRequest();
668                  responseContext.set(RxContexts.DEFAULT_CORRELATOR.getContextForClientRequest(requestId));
669                  return t1.toString(Charset.defaultCharset());
670              }
671          }).toBlocking().single();
672          assertEquals(requestId, requestIdSent);
673          assertEquals("value1", responseContext.get().getContext("Context1"));
674      }
675      @Test
676      @Ignore
677      public void testRedirect() throws Exception {
678          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet(SERVICE_URI + "testAsync/redirect?port=" + port);
679          LoadBalancingHttpClient<ByteBuf, ByteBuf> observableClient =
680                  RibbonTransport.newHttpClient(
681                          IClientConfig.Builder.newBuilder().withDefaultValues()
682                          .withFollowRedirects(true)
683                          .build());
684          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
685          assertEquals(EmbeddedResources.defaultPerson, person);
686      }     
687  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</div>
                </div>
                <div class="column column_space"><pre><code>190                  latch.countDown();
191              }
192          }, 
193          new Action0() {
194              @Override
195              public void call() {
196              }
</pre></code></div>
                <div class="column column_space"><pre><code>634                  latch.countDown();
635              }
636          }, new Action0() {
637              @Override
638              public void call() {
639                  Thread.dumpStack();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    