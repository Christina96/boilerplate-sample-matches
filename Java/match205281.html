<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for HAProxyMessage.java &amp; Http2TestUtil.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for HAProxyMessage.java &amp; Http2TestUtil.java
      </h3>
<h1 align="center">
        14.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>HAProxyMessage.java (14.829396%)<th>Http2TestUtil.java (13.532934%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(16-32)<td><a href="#" name="0">(15-30)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(354-363)<td><a href="#" name="1">(134-139)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(610-610)<td><a href="#" name="2">(455-457)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(44-56)<td><a href="#" name="3">(153-161)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(92-97)<td><a href="#" name="4">(200-203)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(73-91)<td><a href="#" name="5">(210-216)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(281-287)<td><a href="#" name="6">(411-417)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(588-593)<td><a href="#" name="7">(194-199)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(150-153)<td><a href="#" name="8">(112-115)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(139-142)<td><a href="#" name="9">(75-78)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>HAProxyMessage.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.haproxy;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;
4 import io.netty.util.AbstractReferenceCounted;
5 import io.netty.util.ByteProcessor;
6 import io.netty.util.CharsetUtil;
7 import io.netty.util.NetUtil;
8 import io.netty.util.ResourceLeakDetector;
9 import io.netty.util.ResourceLeakDetectorFactory;
10 import io.netty.util.ResourceLeakTracker;
11 import io.netty.util.internal.ObjectUtil;
12 import io.netty.util.internal.StringUtil;
13 import java.util.ArrayList;
14 import java.util.Collections;
15 import</b></font> java.util.List;
16 public final class HAProxyMessage extends AbstractReferenceCounted {
17     private static final ResourceLeakDetector&lt;HAProxyMessage&gt; leakDetector =
18             ResourceLeakDetectorFactory.instance().newResourceLeakDetector(HAProxyMessage.class);
19 <a name="3"></a>    private final ResourceLeakTracker&lt;HAProxyMessage&gt; leak;
20     private final HAProxyProtocolVersion protocolVersion;
21     private final HAProxyCommand command;
22     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final HAProxyProxiedProtocol proxiedProtocol;
23     private final String sourceAddress;
24     private final String destinationAddress;
25     private final int sourcePort;
26     private final int destinationPort;
27     private final List&lt;HAProxyTLV&gt; tlvs;
28     private HAProxyMessage(
29             HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,
30             String sourceAddress, String destinationAddress</b></font>, String sourcePort, String destinationPort) {
31         this(
32                 protocolVersion, command, proxiedProtocol,
33                 sourceAddress, destinationAddress, portStringToInt(sourcePort), portStringToInt(destinationPort));
34     }
35     public HAProxyMessage(
36             HAProxyProtocolVersion protocolVersion, HAProxyCommand command, <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HAProxyProxiedProtocol proxiedProtocol,
37             String sourceAddress, String destinationAddress, int sourcePort, int destinationPort) {
38         this(protocolVersion, command, proxiedProtocol,
39              sourceAddress, destinationAddress, sourcePort, destinationPort, Collections.&lt;HAProxyTLV&gt;emptyList());
40     }
41     public</b></font> HAProxyMessage(
42             <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,
43             String sourceAddress, String destinationAddress, int sourcePort, int destinationPort,
44             List&lt;? extends HAProxyTLV&gt; tlvs) {
45         ObjectUtil.checkNotNull(protocolVersion, "protocolVersion");
46         ObjectUtil.checkNotNull</b></font>(proxiedProtocol, "proxiedProtocol");
47         ObjectUtil.checkNotNull(tlvs, "tlvs");
48         AddressFamily addrFamily = proxiedProtocol.addressFamily();
49         checkAddress(sourceAddress, addrFamily);
50         checkAddress(destinationAddress, addrFamily);
51         checkPort(sourcePort, addrFamily);
52         checkPort(destinationPort, addrFamily);
53         this.protocolVersion = protocolVersion;
54         this.command = command;
55         this.proxiedProtocol = proxiedProtocol;
56         this.sourceAddress = sourceAddress;
57         this.destinationAddress = destinationAddress;
58         this.sourcePort = sourcePort;
59         this.destinationPort = destinationPort;
60         this.tlvs = Collections.unmodifiableList(tlvs);
61         leak = leakDetector.track(this);
62     }
63     static HAProxyMessage decodeHeader(ByteBuf header) {
64         ObjectUtil.checkNotNull(header, "header");
65         if (header.readableBytes() &lt; 16) {
66             throw new HAProxyProtocolException(
67                     "incomplete header: " + header.readableBytes() + " bytes (expected: 16+ bytes)");
68         }
69         header.skipBytes(12);
70         final byte verCmdByte = header.readByte();
71 <a name="9"></a>
72         HAProxyProtocolVersion ver;
73         try {
74             ver = <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HAProxyProtocolVersion.valueOf(verCmdByte);
75         } catch (IllegalArgumentException e) {
76             throw new HAProxyProtocolException(e);
77         }</b></font>
78         if (ver != HAProxyProtocolVersion.V2) {
79             throw new HAProxyProtocolException("version 1 unsupported: 0x" + Integer.toHexString(verCmdByte));
80         }
81 <a name="8"></a>
82         HAProxyCommand cmd;
83         try {
84             cmd = <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HAProxyCommand.valueOf(verCmdByte);
85         } catch (IllegalArgumentException e) {
86             throw new HAProxyProtocolException(e);
87         }</b></font>
88         if (cmd == HAProxyCommand.LOCAL) {
89             return unknownMsg(HAProxyProtocolVersion.V2, HAProxyCommand.LOCAL);
90         }
91         HAProxyProxiedProtocol protAndFam;
92         try {
93             protAndFam = HAProxyProxiedProtocol.valueOf(header.readByte());
94         } catch (IllegalArgumentException e) {
95             throw new HAProxyProtocolException(e);
96         }
97         if (protAndFam == HAProxyProxiedProtocol.UNKNOWN) {
98             return unknownMsg(HAProxyProtocolVersion.V2, HAProxyCommand.PROXY);
99         }
100         int addressInfoLen = header.readUnsignedShort();
101         String srcAddress;
102         String dstAddress;
103         int addressLen;
104         int srcPort = 0;
105         int dstPort = 0;
106         AddressFamily addressFamily = protAndFam.addressFamily();
107         if (addressFamily == AddressFamily.AF_UNIX) {
108             if (addressInfoLen &lt; 216 || header.readableBytes() &lt; 216) {
109                 throw new HAProxyProtocolException(
110                     "incomplete UNIX socket address information: " +
111                             Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 216+ bytes)");
112             }
113             int startIdx = header.readerIndex();
114             int addressEnd = header.forEachByte(startIdx, 108, ByteProcessor.FIND_NUL);
115             if (addressEnd == -1) {
116                 addressLen = 108;
117             } else {
118                 addressLen = addressEnd - startIdx;
119             }
120             srcAddress = header.toString(startIdx, addressLen, CharsetUtil.US_ASCII);
121             startIdx += 108;
122             addressEnd = header.forEachByte(startIdx, 108, ByteProcessor.FIND_NUL);
123             if (addressEnd == -1) {
124                 addressLen = 108;
125             } else {
126                 addressLen = addressEnd - startIdx;
127             }
128             dstAddress = header.toString(startIdx, addressLen, CharsetUtil.US_ASCII);
129             header.readerIndex(startIdx + 108);
130         } else {
131             if (addressFamily == AddressFamily.AF_IPv4) {
132                 if (addressInfoLen &lt; 12 || header.readableBytes() &lt; 12) {
133                     throw new HAProxyProtocolException(
134                         "incomplete IPv4 address information: " +
135                                 Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 12+ bytes)");
136                 }
137                 addressLen = 4;
138             } else if (addressFamily == AddressFamily.AF_IPv6) {
139                 if (addressInfoLen &lt; 36 || header.readableBytes() &lt; 36) {
140                     throw new HAProxyProtocolException(
141                         "incomplete IPv6 address information: " +
142                                 Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 36+ bytes)");
143                 }
144                 addressLen = 16;
145             } else {
146                 throw new HAProxyProtocolException(
147                     "unable to parse address information (unknown address family: " + addressFamily + ')');
148             }
149             srcAddress = ipBytesToString(header, addressLen);
150             dstAddress = ipBytesToString(header, addressLen);
151             srcPort = header.readUnsignedShort();
152             dstPort = header.readUnsignedShort();
153         }
154         final List&lt;HAProxyTLV&gt; tlvs = readTlvs(header);
155         return new HAProxyMessage(ver, cmd, protAndFam, srcAddress, dstAddress, srcPort, dstPort, tlvs);
156     }
157     private static List&lt;HAProxyTLV&gt; readTlvs(final ByteBuf header) {
158         HAProxyTLV haProxyTLV = readNextTLV(header);
159         if (haProxyTLV == null) {
160             return Collections.emptyList();
161         }
162         List&lt;HAProxyTLV&gt; haProxyTLVs = new ArrayList&lt;HAProxyTLV&gt;(4);
163         do {
164             haProxyTLVs.add(haProxyTLV);
165             if (haProxyTLV instanceof HAProxySSLTLV) {
166                 haProxyTLVs.addAll(((HAProxySSLTLV) haProxyTLV).encapsulatedTLVs());
167             }
168         } while ((haProxyTLV = readNextTLV(header)) != null);
169         return haProxyTLVs;
170     }
171     private static HAProxyTLV readNextTLV(final ByteBuf header) {
172         if (header.readableBytes() &lt; 4) {
173             return null;
174         }
175         final byte typeAsByte = header.readByte();
176         final HAProxyTLV.Type type = HAProxyTLV.Type.typeForByteValue(typeAsByte);
177         final int length = header.readUnsignedShort();
178         switch (type) {
179         case PP2_TYPE_SSL:
180             final ByteBuf rawContent = header.retainedSlice(header.readerIndex(), length);
181             final ByteBuf byteBuf = header.readSlice(length);
182             final byte client = byteBuf.readByte();
183             final int verify = byteBuf.readInt();
184 <a name="6"></a>            if (byteBuf.readableBytes() &gt;= 4) {
185                 final List&lt;HAProxyTLV&gt; encapsulatedTlvs = new ArrayList&lt;HAProxyTLV&gt;(4);
186                 do <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
187                     final HAProxyTLV haProxyTLV = readNextTLV(byteBuf);
188                     if (haProxyTLV == null) {
189                         break;
190                     }
191                     encapsulatedTlvs.add(haProxyTLV);
192                 }</b></font> while (byteBuf.readableBytes() &gt;= 4);
193                 return new HAProxySSLTLV(verify, client, encapsulatedTlvs, rawContent);
194             }
195             return new HAProxySSLTLV(verify, client, Collections.&lt;HAProxyTLV&gt;emptyList(), rawContent);
196         case PP2_TYPE_ALPN:
197         case PP2_TYPE_AUTHORITY:
198         case PP2_TYPE_SSL_VERSION:
199         case PP2_TYPE_SSL_CN:
200         case PP2_TYPE_NETNS:
201         case OTHER:
202             return new HAProxyTLV(type, typeAsByte, header.readRetainedSlice(length));
203         default:
204             return null;
205         }
206     }
207     static HAProxyMessage decodeHeader(String header) {
208         if (header == null) {
209             throw new HAProxyProtocolException("header");
210         }
211         String[] parts = header.split(" ");
212         int numParts = parts.length;
213         if (numParts &lt; 2) {
214             throw new HAProxyProtocolException(
215                     "invalid header: " + header + " (expected: 'PROXY' and proxied protocol values)");
216         }
217         if (!"PROXY".equals(parts[0])) {
218             throw new HAProxyProtocolException("unknown identifier: " + parts[0]);
219         }
220         HAProxyProxiedProtocol protAndFam;
221         try {
222             protAndFam = HAProxyProxiedProtocol.valueOf(parts[1]);
223         } catch (IllegalArgumentException e) {
224             throw new HAProxyProtocolException(e);
225         }
226         if (protAndFam != HAProxyProxiedProtocol.TCP4 &amp;&amp;
227                 protAndFam != HAProxyProxiedProtocol.TCP6 &amp;&amp;
228                 protAndFam != HAProxyProxiedProtocol.UNKNOWN) {
229             throw new HAProxyProtocolException("unsupported v1 proxied protocol: " + parts[1]);
230         }
231         if (protAndFam == HAProxyProxiedProtocol.UNKNOWN) {
232             return unknownMsg(HAProxyProtocolVersion.V1, HAProxyCommand.PROXY);
233         }
234         if (numParts != 6) {
235             throw new HAProxyProtocolException("invalid TCP4/6 header: " + header + " (expected: 6 parts)");
236         }
237         try {
238 <a name="1"></a>            return new HAProxyMessage(
239                     HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,
240                     protAndFam, parts[2], parts[3], parts[4], parts[5]);
241         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>} catch (RuntimeException e) {
242             throw new HAProxyProtocolException("invalid HAProxy message", e);
243         }
244     }
245     private static HAProxyMessage unknownMsg(HAProxyProtocolVersion version, HAProxyCommand command) {</b></font>
246         return new HAProxyMessage(version, command, HAProxyProxiedProtocol.UNKNOWN, null, null, 0, 0);
247     }
248     private static String ipBytesToString(ByteBuf header, int addressLen) {
249         StringBuilder sb = new StringBuilder();
250         final int ipv4Len = 4;
251         final int ipv6Len = 8;
252         if (addressLen == ipv4Len) {
253             for (int i = 0; i &lt; ipv4Len; i++) {
254                 sb.append(header.readByte() &amp; 0xff);
255                 sb.append('.');
256             }
257         } else {
258             for (int i = 0; i &lt; ipv6Len; i++) {
259                 sb.append(Integer.toHexString(header.readUnsignedShort()));
260                 sb.append(':');
261             }
262         }
263         sb.setLength(sb.length() - 1);
264         return sb.toString();
265     }
266     private static int portStringToInt(String value) {
267         int port;
268         try {
269             port = Integer.parseInt(value);
270         } catch (NumberFormatException e) {
271             throw new IllegalArgumentException("invalid port: " + value, e);
272         }
273         if (port &lt;= 0 || port &gt; 65535) {
274             throw new IllegalArgumentException("invalid port: " + value + " (expected: 1 ~ 65535)");
275         }
276         return port;
277     }
278     private static void checkAddress(String address, AddressFamily addrFamily) {
279         ObjectUtil.checkNotNull(addrFamily, "addrFamily");
280         switch (addrFamily) {
281             case AF_UNSPEC:
282                 if (address != null) {
283                     throw new IllegalArgumentException("unable to validate an AF_UNSPEC address: " + address);
284                 }
285                 return;
286             case AF_UNIX:
287                 ObjectUtil.checkNotNull(address, "address");
288                 if (address.getBytes(CharsetUtil.US_ASCII).length &gt; 108) {
289                     throw new IllegalArgumentException("invalid AF_UNIX address: " + address);
290                 }
291                 return;
292         }
293         ObjectUtil.checkNotNull(address, "address");
294         switch (addrFamily) {
295             case AF_IPv4:
296                 if (!NetUtil.isValidIpV4Address(address)) {
297                     throw new IllegalArgumentException("invalid IPv4 address: " + address);
298                 }
299                 break;
300             case AF_IPv6:
301                 if (!NetUtil.isValidIpV6Address(address)) {
302                     throw new IllegalArgumentException("invalid IPv6 address: " + address);
303                 }
304                 break;
305             default:
306                 throw new IllegalArgumentException("unexpected addrFamily: " + addrFamily);
307         }
308     }
309     private static void checkPort(int port, AddressFamily addrFamily) {
310         switch (addrFamily) {
311         case AF_IPv6:
312         case AF_IPv4:
313             if (port &lt; 0 || port &gt; 65535) {
314                 throw new IllegalArgumentException("invalid port: " + port + " (expected: 0 ~ 65535)");
315             }
316             break;
317         case AF_UNIX:
318         case AF_UNSPEC:
319             if (port != 0) {
320                 throw new IllegalArgumentException("port cannot be specified with addrFamily: " + addrFamily);
321             }
322             break;
323         default:
324             throw new IllegalArgumentException("unexpected addrFamily: " + addrFamily);
325         }
326     }
327     public HAProxyProtocolVersion protocolVersion() {
328         return protocolVersion;
329     }
330     public HAProxyCommand command() {
331         return command;
332     }
333     public HAProxyProxiedProtocol proxiedProtocol() {
334         return proxiedProtocol;
335     }
336     public String sourceAddress() {
337         return sourceAddress;
338     }
339     public String destinationAddress() {
340         return destinationAddress;
341     }
342     public int sourcePort() {
343         return sourcePort;
344     }
345     public int destinationPort() {
346         return destinationPort;
347     }
348     public List&lt;HAProxyTLV&gt; tlvs() {
349         return tlvs;
350     }
351     int tlvNumBytes() {
352         int tlvNumBytes = 0;
353         for (int i = 0; i &lt; tlvs.size(); i++) {
354             tlvNumBytes += tlvs.get(i).totalNumBytes();
355         }
356         return tlvNumBytes;
357     }
358     @Override
359     public HAProxyMessage touch() {
360         tryRecord();
361         return (HAProxyMessage) super.touch();
362     }
363     @Override
364     public HAProxyMessage touch(Object hint) {
365         if (leak != null) {
366             leak.record(hint);
367         }
368         return this;
369     }
370     @Override
371     public HAProxyMessage retain() {
372         tryRecord();
373         return (HAProxyMessage) super.retain();
374     }
375     @Override
376     public HAProxyMessage retain(int increment) {
377         tryRecord();
378         return (HAProxyMessage) super.retain(increment);
379     }
380     @Override
381     public boolean release() {
382         tryRecord();
383         return super.release();
384     }
385     @Override
386     public boolean release(int decrement) {
387         tryRecord();
388         return super.release(decrement);
389 <a name="7"></a>    }
390     private void tryRecord() {
391         <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (leak != null) {
392             leak.record();
393         }
394     }
395     @</b></font>Override
396     protected void deallocate() {
397         try {
398             for (HAProxyTLV tlv : tlvs) {
399                 tlv.release();
400             }
401         } finally {
402             final ResourceLeakTracker&lt;HAProxyMessage&gt; leak = this.leak;
403             if (leak != null) {
404                 boolean closed = leak.close(this);
405                 assert closed;
406             }
407         }
408     }
409 <a name="2"></a>
410     @Override
411     public String toString() {
412         StringBuilder sb = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new</b></font> StringBuilder(256)
413                 .append(StringUtil.simpleClassName(this))
414                 .append("(protocolVersion: ").append(protocolVersion)
415                 .append(", command: ").append(command)
416                 .append(", proxiedProtocol: ").append(proxiedProtocol)
417                 .append(", sourceAddress: ").append(sourceAddress)
418                 .append(", destinationAddress: ").append(destinationAddress)
419                 .append(", sourcePort: ").append(sourcePort)
420                 .append(", destinationPort: ").append(destinationPort)
421                 .append(", tlvs: [");
422         if (!tlvs.isEmpty()) {
423             for (HAProxyTLV tlv: tlvs) {
424                 sb.append(tlv).append(", ");
425             }
426             sb.setLength(sb.length() - 2);
427         }
428         sb.append("])");
429         return sb.toString();
430     }
431 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Http2TestUtil.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec.http2;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.ByteBufUtil;
4 import io.netty.buffer.Unpooled;
5 import io.netty.buffer.UnpooledByteBufAllocator;
6 import io.netty.channel.Channel;
7 import io.netty.channel.ChannelFuture;
8 import io.netty.channel.ChannelFutureListener;
9 import io.netty.channel.ChannelHandlerContext;
10 import io.netty.channel.ChannelPromise;
11 import io.netty.channel.DefaultChannelPromise;
12 import io.netty.util.AsciiString;
13 import io.netty.util.ReferenceCountUtil;
14 import io.netty.util.concurrent.Future;
15 import</b></font> io.netty.util.concurrent.GenericFutureListener;
16 import io.netty.util.concurrent.ImmediateEventExecutor;
17 import junit.framework.AssertionFailedError;
18 import org.mockito.Mockito;
19 import org.mockito.invocation.InvocationOnMock;
20 import org.mockito.stubbing.Answer;
21 import java.util.Random;
22 import java.util.concurrent.ConcurrentLinkedQueue;
23 import java.util.concurrent.CountDownLatch;
24 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_LIST_SIZE;
25 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;
26 import static io.netty.util.ReferenceCountUtil.release;
27 import static java.lang.Math.min;
28 import static org.junit.jupiter.api.Assertions.assertEquals;
29 import static org.junit.jupiter.api.Assertions.assertTrue;
30 import static org.mockito.ArgumentMatchers.any;
31 import static org.mockito.ArgumentMatchers.anyBoolean;
32 import static org.mockito.ArgumentMatchers.anyByte;
33 import static org.mockito.ArgumentMatchers.anyInt;
34 import static org.mockito.ArgumentMatchers.anyLong;
35 import static org.mockito.ArgumentMatchers.anyShort;
36 import static org.mockito.Mockito.doAnswer;
37 import static org.mockito.Mockito.when;
38 public final class Http2TestUtil {
39     interface Http2Runnable {
40         void run() throws Http2Exception;
41     }
42     static void runInChannel(Channel channel, final Http2Runnable runnable) {
43         channel.eventLoop().execute(new Runnable() {
44 <a name="9"></a>            @Override
45             public void run() {
46                 try {
47                     <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>runnable.run();
48                 } catch (Http2Exception e) {
49                     throw new RuntimeException(e);
50                 }</b></font>
51             }
52         });
53     }
54     public static byte[] randomBytes() {
55         return randomBytes(100);
56     }
57     public static byte[] randomBytes(int size) {
58         byte[] data = new byte[size];
59         new Random().nextBytes(data);
60         return data;
61     }
62     public static AsciiString randomString() {
63         return new AsciiString(randomBytes());
64     }
65     public static CharSequence of(String s) {
66         return s;
67     }
68 <a name="8"></a>
69     public static HpackEncoder newTestEncoder() {
70         try {
71             return <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>newTestEncoder(true, MAX_HEADER_LIST_SIZE, MAX_HEADER_TABLE_SIZE);
72         } catch (Http2Exception e) {
73             throw new Error("max size not allowed?", e);
74         }</b></font>
75     }
76     public static HpackEncoder newTestEncoder(boolean ignoreMaxHeaderListSize,
77                                               long maxHeaderListSize, long maxHeaderTableSize) throws Http2Exception {
78         HpackEncoder hpackEncoder = new HpackEncoder(false, 16, 0);
79         ByteBuf buf = Unpooled.buffer();
80         try {
81             hpackEncoder.setMaxHeaderTableSize(buf, maxHeaderTableSize);
82             hpackEncoder.setMaxHeaderListSize(maxHeaderListSize);
83         } finally  {
84             buf.release();
85         }
86         return hpackEncoder;
87     }
88 <a name="1"></a>    public static HpackDecoder newTestDecoder() {
89         try {
90             return newTestDecoder(MAX_HEADER_LIST_SIZE, MAX_HEADER_TABLE_SIZE);
91         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} catch (Http2Exception e) {
92             throw new Error("max size not allowed?", e);
93         }
94     }
95     public static HpackDecoder newTestDecoder(long maxHeaderListSize, long maxHeaderTableSize) throws Http2Exception {</b></font>
96         HpackDecoder hpackDecoder = new HpackDecoder(maxHeaderListSize);
97         hpackDecoder.setMaxHeaderTableSize(maxHeaderTableSize);
98         return hpackDecoder;
99     }
100     private Http2TestUtil() {
101     }
102     static class FrameCountDown implements Http2FrameListener {
103         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final Http2FrameListener listener;
104         private final CountDownLatch messageLatch;
105         private final CountDownLatch settingsAckLatch;
106         private final CountDownLatch dataLatch;
107         private final CountDownLatch trailersLatch;
108         private final CountDownLatch goAwayLatch;
109         FrameCountDown(Http2FrameListener listener, CountDownLatch settingsAckLatch, CountDownLatch messageLatch,
110                 CountDownLatch dataLatch, CountDownLatch trailersLatch</b></font>) {
111             this(listener, settingsAckLatch, messageLatch, dataLatch, trailersLatch, messageLatch);
112         }
113         FrameCountDown(Http2FrameListener listener, CountDownLatch settingsAckLatch, CountDownLatch messageLatch,
114                 CountDownLatch dataLatch, CountDownLatch trailersLatch, CountDownLatch goAwayLatch) {
115             this.listener = listener;
116             this.messageLatch = messageLatch;
117             this.settingsAckLatch = settingsAckLatch;
118             this.dataLatch = dataLatch;
119             this.trailersLatch = trailersLatch;
120             this.goAwayLatch = goAwayLatch;
121         }
122         @Override
123         public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)
124                 throws Http2Exception {
125             int numBytes = data.readableBytes();
126             int processed = listener.onDataRead(ctx, streamId, data, padding, endOfStream);
127             messageLatch.countDown();
128             if (dataLatch != null) {
129                 for (int i = 0; i &lt; numBytes; ++i) {
130                     dataLatch.countDown();
131                 }
132             }
133             return processed;
134         }
135         @Override
136         public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,
137 <a name="7"></a>                boolean endStream) throws Http2Exception {
138             listener.onHeadersRead(ctx, streamId, headers, padding, endStream);
139             messageLatch.countDown();
140             <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (trailersLatch != null &amp;&amp; endStream) {
141                 trailersLatch.countDown();
142             }
143 <a name="4"></a>        }
144         @</b></font>Override
145         public void onHeadersRead(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,
146                 short weight, boolean exclusive, int padding, boolean endStream) throws Http2Exception {
147             listener.onHeadersRead(ctx, streamId, headers, streamDependency, weight, exclusive, padding, endStream);
148             messageLatch.countDown</b></font>();
149             if (trailersLatch != null &amp;&amp; endStream) {
150                 trailersLatch.countDown();
151             }
152 <a name="5"></a>        }
153         @Override
154         public void onPriorityRead(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,
155                 boolean exclusive) throws Http2Exception {
156             listener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);
157             messageLatch.countDown();
158         }
159         @Override</b></font>
160         public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {
161             listener.onRstStreamRead(ctx, streamId, errorCode);
162             messageLatch.countDown();
163         }
164         @Override
165         public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {
166             listener.onSettingsAckRead(ctx);
167             settingsAckLatch.countDown();
168         }
169         @Override
170         public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {
171             listener.onSettingsRead(ctx, settings);
172             messageLatch.countDown();
173         }
174         @Override
175         public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
176             listener.onPingRead(ctx, data);
177             messageLatch.countDown();
178         }
179         @Override
180         public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
181             listener.onPingAckRead(ctx, data);
182             messageLatch.countDown();
183         }
184         @Override
185         public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,
186                 Http2Headers headers, int padding) throws Http2Exception {
187             listener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);
188             messageLatch.countDown();
189         }
190         @Override
191         public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)
192                 throws Http2Exception {
193             listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);
194             goAwayLatch.countDown();
195         }
196         @Override
197         public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)
198                 throws Http2Exception {
199             listener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);
200             messageLatch.countDown();
201         }
202         @Override
203         public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,
204                 ByteBuf payload) throws Http2Exception {
205             listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
206             messageLatch.countDown();
207         }
208     }
209     static ChannelPromise newVoidPromise(final Channel channel) {
210         return new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE) {
211             @Override
212             public ChannelPromise addListener(
213                     GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener) {
214                 throw new AssertionFailedError();
215             }
216             @Override
217             public ChannelPromise addListeners(
218                     GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners) {
219                 throw new AssertionFailedError();
220             }
221             @Override
222             public boolean isVoid() {
223                 return true;
224             }
225             @Override
226             public boolean tryFailure(Throwable cause) {
227                 channel().pipeline().fireExceptionCaught(cause);
228                 return true;
229             }
230             @Override
231             public ChannelPromise setFailure(Throwable cause) {
232                 tryFailure(cause);
233                 return this;
234             }
235             @Override
236             public ChannelPromise unvoid() {
237                 ChannelPromise promise =
238                         new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
239                 promise.addListener(new ChannelFutureListener() {
240                     @Override
241                     public void operationComplete(ChannelFuture future) throws Exception {
242                         if (!future.isSuccess()) {
243                             channel().pipeline().fireExceptionCaught(future.cause());
244                         }
245                     }
246                 });
247                 return promise;
248             }
249         };
250     }
251     static final class TestStreamByteDistributorStreamState implements StreamByteDistributor.StreamState {
252         private final Http2Stream stream;
253         boolean isWriteAllowed;
254         long pendingBytes;
255         boolean hasFrame;
256         TestStreamByteDistributorStreamState(Http2Stream stream, long pendingBytes, boolean hasFrame,
257                                              boolean isWriteAllowed) {
258             this.stream = stream;
259             this.isWriteAllowed = isWriteAllowed;
260             this.pendingBytes = pendingBytes;
261             this.hasFrame = hasFrame;
262         }
263         @Override
264         public Http2Stream stream() {
265             return stream;
266         }
267         @Override
268         public long pendingBytes() {
269             return pendingBytes;
270         }
271         @Override
272         public boolean hasFrame() {
273             return hasFrame;
274         }
275         @Override
276         public int windowSize() {
277             return isWriteAllowed ? (int) min(pendingBytes, Integer.MAX_VALUE) : -1;
278         }
279     }
280     static Http2FrameWriter mockedFrameWriter() {
281         Http2FrameWriter.Configuration configuration = new Http2FrameWriter.Configuration() {
282             private final Http2HeadersEncoder.Configuration headerConfiguration =
283                     new Http2HeadersEncoder.Configuration() {
284                 @Override
285                 public void maxHeaderTableSize(long max)  {
286                 }
287                 @Override
288                 public long maxHeaderTableSize() {
289                     return 0;
290                 }
291                 @Override
292                 public void maxHeaderListSize(long max) {
293                 }
294                 @Override
295                 public long maxHeaderListSize() {
296                     return 0;
297                 }
298             };
299             private final Http2FrameSizePolicy policy = new Http2FrameSizePolicy() {
300                 @Override
301                 public void maxFrameSize(int max) {
302                 }
303                 @Override
304                 public int maxFrameSize() {
305                     return 0;
306                 }
307             };
308             @Override
309             public Http2HeadersEncoder.Configuration headersConfiguration() {
310                 return headerConfiguration;
311             }
312             @Override
313             public Http2FrameSizePolicy frameSizePolicy() {
314                 return policy;
315             }
316         };
317         final ConcurrentLinkedQueue&lt;ByteBuf&gt; buffers = new ConcurrentLinkedQueue&lt;ByteBuf&gt;();
318         Http2FrameWriter frameWriter = Mockito.mock(Http2FrameWriter.class);
319 <a name="6"></a>        doAnswer(new Answer&lt;Object&gt;() {
320             @Override
321             public Object answer(InvocationOnMock invocationOnMock) {
322                 for (;;) <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
323                     ByteBuf buf = buffers.poll();
324                     if (buf == null) {
325                         break;
326                     }
327                     buf.release();
328                 }</b></font>
329                 return null;
330             }
331         }).when(frameWriter).close();
332         when(frameWriter.configuration()).thenReturn(configuration);
333         when(frameWriter.writeSettings(any(ChannelHandlerContext.class), any(Http2Settings.class),
334                 any(ChannelPromise.class))).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
335             @Override
336             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
337                 return ((ChannelPromise) invocationOnMock.getArgument(2)).setSuccess();
338             }
339         });
340         when(frameWriter.writeSettingsAck(any(ChannelHandlerContext.class), any(ChannelPromise.class)))
341                 .thenAnswer(new Answer&lt;ChannelFuture&gt;() {
342             @Override
343             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
344                 return ((ChannelPromise) invocationOnMock.getArgument(1)).setSuccess();
345             }
346         });
347         when(frameWriter.writeGoAway(any(ChannelHandlerContext.class), anyInt(),
348                 anyLong(), any(ByteBuf.class), any(ChannelPromise.class))).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
349             @Override
350             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
351                 buffers.offer((ByteBuf) invocationOnMock.getArgument(3));
352                 return ((ChannelPromise) invocationOnMock.getArgument(4)).setSuccess();
353             }
354         });
355         when(frameWriter.writeHeaders(any(ChannelHandlerContext.class), anyInt(), any(Http2Headers.class), anyInt(),
356                 anyBoolean(), any(ChannelPromise.class))).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
357             @Override
358             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
359                 return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();
360 <a name="2"></a>            }
361         });
362         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>when(frameWriter.writeHeaders(any(ChannelHandlerContext.class), anyInt(),
363                 any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean(),
364                 any(ChannelPromise.class))).thenAnswer(new</b></font> Answer&lt;ChannelFuture&gt;() {
365             @Override
366             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
367                 return ((ChannelPromise) invocationOnMock.getArgument(8)).setSuccess();
368             }
369         });
370         when(frameWriter.writeData(any(ChannelHandlerContext.class), anyInt(), any(ByteBuf.class), anyInt(),
371                 anyBoolean(), any(ChannelPromise.class))).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
372             @Override
373             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
374                 buffers.offer((ByteBuf) invocationOnMock.getArgument(2));
375                 return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();
376             }
377         });
378         when(frameWriter.writeRstStream(any(ChannelHandlerContext.class), anyInt(),
379                 anyLong(), any(ChannelPromise.class))).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
380             @Override
381             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
382                 return ((ChannelPromise) invocationOnMock.getArgument(3)).setSuccess();
383             }
384         });
385         when(frameWriter.writeWindowUpdate(any(ChannelHandlerContext.class), anyInt(), anyInt(),
386                 any(ChannelPromise.class))).then(new Answer&lt;ChannelFuture&gt;() {
387             @Override
388             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
389                 return ((ChannelPromise) invocationOnMock.getArgument(3)).setSuccess();
390             }
391         });
392         when(frameWriter.writePushPromise(any(ChannelHandlerContext.class), anyInt(), anyInt(), any(Http2Headers.class),
393                 anyInt(), anyChannelPromise())).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
394             @Override
395             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
396                 return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();
397             }
398         });
399         when(frameWriter.writeFrame(any(ChannelHandlerContext.class), anyByte(), anyInt(), any(Http2Flags.class),
400                 any(ByteBuf.class), anyChannelPromise())).thenAnswer(new Answer&lt;ChannelFuture&gt;() {
401             @Override
402             public ChannelFuture answer(InvocationOnMock invocationOnMock) {
403                 buffers.offer((ByteBuf) invocationOnMock.getArgument(4));
404                 return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();
405             }
406         });
407         return frameWriter;
408     }
409     static ChannelPromise anyChannelPromise() {
410         return any(ChannelPromise.class);
411     }
412     static Http2Settings anyHttp2Settings() {
413         return any(Http2Settings.class);
414     }
415     static ByteBuf bb(String s) {
416         return ByteBufUtil.writeUtf8(UnpooledByteBufAllocator.DEFAULT, s);
417     }
418     static ByteBuf bb(int size) {
419         return UnpooledByteBufAllocator.DEFAULT.buffer().writeZero(size);
420     }
421     static void assertEqualsAndRelease(Http2Frame expected, Http2Frame actual) {
422         try {
423             assertEquals(expected, actual);
424         } finally {
425             release(expected);
426             release(actual);
427             assertTrue(ReferenceCountUtil.refCnt(expected) &lt;= 0);
428             assertTrue(ReferenceCountUtil.refCnt(actual) &lt;= 0);
429         }
430     }
431 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
