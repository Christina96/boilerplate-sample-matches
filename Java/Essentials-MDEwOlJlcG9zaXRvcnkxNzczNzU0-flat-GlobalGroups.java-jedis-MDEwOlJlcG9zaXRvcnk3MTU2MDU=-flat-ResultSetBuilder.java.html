
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.761904761904762%, Tokens: 16</h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-GlobalGroups.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager;
2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.FileNotFoundException;
5  import java.io.FileOutputStream;
6  import java.io.IOException;
7  import java.io.OutputStreamWriter;
8  import java.io.UnsupportedEncodingException;
<span onclick='openModal()' class='match'>9  import java.util.Collections;
10  import java.util.HashMap;
11  import java.util.Iterator;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.logging.Level;
15  import org.anjocaido.groupmanager.data.Group;
16  import org.anjocaido.groupmanager.events.GMGroupEvent;
17  import org.anjocaido.groupmanager.utils.PermissionCheckResult;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.yaml.snakeyaml.DumperOptions;
20  import org.yaml.snakeyaml.Yaml;
21  import org.yaml.snakeyaml.constructor.SafeConstructor;
22  import org.yaml.snakeyaml.reader.UnicodeReader;
23  public class GlobalGroups {
24  	private GroupManager plugin;
</span>25  	private final Map<String, Group> groups = Collections.synchronizedMap(new HashMap<String, Group>());
26  	protected long timeStampGroups = 0;
27  	protected boolean haveGroupsChanged = false;
28  	protected File GlobalGroupsFile = null;
29  	public GlobalGroups(GroupManager plugin) {
30  		this.plugin = plugin;
31  		load();
32  	}
33  	public boolean haveGroupsChanged() {
34  		if (this.haveGroupsChanged) {
35  			return true;
36  		}
37  		synchronized(groups) {
38  		for (Group g : groups.values()) {
39  			if (g.isChanged()) {
40  				return true;
41  			}
42  		}
43  		}
44  		return false;
45  	}
46  	public long getTimeStampGroups() {
47  		return timeStampGroups;
48  	}
49  	protected void setTimeStampGroups(long timeStampGroups) {
50  		this.timeStampGroups = timeStampGroups;
51  	}
52  	public void setGroupsChanged(boolean haveGroupsChanged) {
53  		this.haveGroupsChanged = haveGroupsChanged;
54  	}
55  	@SuppressWarnings("unchecked")
56  	public void load() {
57  		Yaml GGroupYAML = new Yaml(new SafeConstructor());
58  		Map<String, Object> GGroups;
59  		GroupManager.setLoaded(false);
60  		if (GlobalGroupsFile == null)
61  			GlobalGroupsFile = new File(plugin.getDataFolder(), "globalgroups.yml");
62  		if (!GlobalGroupsFile.exists()) {
63  			try {
64  				Tasks.copy(plugin.getResourceAsStream("globalgroups.yml"), GlobalGroupsFile);
65  			} catch (IOException ex) {
66  				GroupManager.logger.log(Level.SEVERE, null, ex);
67  			}
68  		}
69  		try {
70  			FileInputStream groupsInputStream = new FileInputStream(GlobalGroupsFile);
71  			GGroups = (Map<String, Object>) GGroupYAML.load(new UnicodeReader(groupsInputStream));
72  			groupsInputStream.close();
73  		} catch (Exception ex) {
74  			throw new IllegalArgumentException("The following file couldn't pass on Parser.\n" + GlobalGroupsFile.getPath(), ex);
75  		}
76  		resetGlobalGroups();
77  		if (!GGroups.keySet().isEmpty()) {
78  			Map<String, Object> allGroups = new HashMap<String, Object>();
79  			try {
80  				allGroups = (Map<String, Object>) GGroups.get("groups");
81  			} catch (Exception ex) {
82  				throw new IllegalArgumentException("Your " + GlobalGroupsFile.getPath() + " file is invalid. See console for details.", ex);
83  			}
84  			if (allGroups != null) {
85  				Iterator<String> groupItr = allGroups.keySet().iterator();
86  				String groupName;
87  				Integer groupCount = 0;
88  				while (groupItr.hasNext()) {
89  					try {
90  						groupCount++;
91  						groupName = groupItr.next();
92  					} catch (Exception ex) {
93  						throw new IllegalArgumentException("Invalid group name for GlobalGroup entry (" + groupCount + ") in file: " + GlobalGroupsFile.getPath(), ex);
94  					}
95  					Group newGroup = new Group(groupName.toLowerCase());
96  					Object element;
97  					try {
98  						element = ((Map<String, Object>)allGroups.get(groupName)).get("permissions");
99  					} catch ( Exception ex) {
100  						throw new IllegalArgumentException("The GlobalGroup ' " + groupName + "' is formatted incorrectly: ", ex);
101  					}
102  					if (element != null)
103  						if (element instanceof List) {
104  							try {
105  								for (String node : (List<String>) element) {
106  									if ((node != null) && !node.isEmpty())
107  										newGroup.addPermission(node);
108  								}
109  							} catch (ClassCastException ex) {
110  								throw new IllegalArgumentException("Invalid permission node for global group:  " + groupName, ex);
111  							}
112  						} else if (element instanceof String) {
113  							if ((element != null) && !((String)element).isEmpty())
114  							newGroup.addPermission((String) element);
115  						} else
116  							throw new IllegalArgumentException("Unknown type of permission node for global group:  " + groupName);
117  					addGroup(newGroup);
118  				}
119  			}
120  			removeGroupsChangedFlag();
121  		}
122  		setTimeStampGroups(GlobalGroupsFile.lastModified());
123  		GroupManager.setLoaded(true);
124  	}
125  	public void writeGroups(boolean overwrite) {
126  		if (haveGroupsChanged()) {
127  			if (overwrite || (!overwrite && (getTimeStampGroups() >= GlobalGroupsFile.lastModified()))) {
128  				Map<String, Object> root = new HashMap<String, Object>();
129  				Map<String, Object> groupsMap = new HashMap<String, Object>();
130  				root.put("groups", groupsMap);
131  				synchronized(groups) {
132  				for (String groupKey : groups.keySet()) {
133  					Group group = groups.get(groupKey);
134  					Map<String, Object> aGroupMap = new HashMap<String, Object>();
135  					groupsMap.put(group.getName(), aGroupMap);
136  					aGroupMap.put("permissions", group.getPermissionList());
137  				}
138  				}
139  				if (!root.isEmpty()) {
140  					DumperOptions opt = new DumperOptions();
141  					opt.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
142  					final Yaml yaml = new Yaml(opt);
143  					try {
144  						yaml.dump(root, new OutputStreamWriter(new FileOutputStream(GlobalGroupsFile), "UTF-8"));
145  					} catch (UnsupportedEncodingException ex) {
146  					} catch (FileNotFoundException ex) {
147  					}
148  				}
149  				setTimeStampGroups(GlobalGroupsFile.lastModified());
150  			} else {
151  				GroupManager.logger.log(Level.WARNING, "Newer GlobalGroups file found, but we have local changes!");
152  				throw new IllegalStateException("Unable to save unless you issue a '/mansave force'");
153  			}
154  			removeGroupsChangedFlag();
155  		} else {
156  			if (getTimeStampGroups() < GlobalGroupsFile.lastModified()) {
157  				System.out.print("Newer GlobalGroups file found (Loading changes)!");
158  				backupFile();
159  				load();
160  			}
161  		}
162  	}
163  	private void backupFile() {
164  		File backupFile = new File(plugin.getBackupFolder(), "bkp_ggroups_" + Tasks.getDateString() + ".yml");
165  		try {
166  			Tasks.copy(GlobalGroupsFile, backupFile);
167  		} catch (IOException ex) {
168  			GroupManager.logger.log(Level.SEVERE, null, ex);
169  		}
170  	}
171  	public void addGroup(Group groupToAdd) {
172  		if (hasGroup(groupToAdd.getName())) {
173  			groupToAdd = groupToAdd.clone();
174  			removeGroup(groupToAdd.getName());
175  		}
176  		newGroup(groupToAdd);
177  		haveGroupsChanged = true;
178  		if (GroupManager.isLoaded())
179  			GroupManager.getGMEventHandler().callEvent(groupToAdd, GMGroupEvent.Action.GROUP_ADDED);
180  	}
181  	public Group newGroup(Group newGroup) {
182  		if (!groups.containsKey(newGroup.getName().toLowerCase())) {
183  			groups.put(newGroup.getName().toLowerCase(), newGroup);
184  			this.setGroupsChanged(true);
185  			return newGroup;
186  		}
187  		return null;
188  	}
189  	public boolean removeGroup(String groupName) {
190  		if (groups.containsKey(groupName.toLowerCase())) {
191  			groups.remove(groupName.toLowerCase());
192  			this.setGroupsChanged(true);
193  			if (GroupManager.isLoaded())
194  				GroupManager.getGMEventHandler().callEvent(groupName.toLowerCase(), GMGroupEvent.Action.GROUP_REMOVED);
195  			return true;
196  		}
197  		return false;
198  	}
199  	public boolean hasGroup(String groupName) {
200  		return groups.containsKey(groupName.toLowerCase());
201  	}
202  	public boolean hasPermission(String groupName, String permissionNode) {
203  		if (!hasGroup(groupName))
204  			return false;
205  		return groups.get(groupName.toLowerCase()).hasSamePermissionNode(permissionNode);
206  	}
207  	public PermissionCheckResult checkPermission(String groupName, String permissionNode) {
208  		PermissionCheckResult result = new PermissionCheckResult();
209  		result.askedPermission = permissionNode;
210  		result.resultType = PermissionCheckResult.Type.NOTFOUND;
211  		if (!hasGroup(groupName))
212  			return result;
213  		Group tempGroup = groups.get(groupName.toLowerCase());
214  		if (tempGroup.hasSamePermissionNode(permissionNode))
215  			result.resultType = PermissionCheckResult.Type.FOUND;
216  		if (tempGroup.hasSamePermissionNode("-" + permissionNode))
217  			result.resultType = PermissionCheckResult.Type.NEGATION;
218  		if (tempGroup.hasSamePermissionNode("+" + permissionNode))
219  			result.resultType = PermissionCheckResult.Type.EXCEPTION;
220  		return result;
221  	}
222  	public List<String> getGroupsPermissions(String groupName) {
223  		if (!hasGroup(groupName))
224  			return null;
225  		return groups.get(groupName.toLowerCase()).getPermissionList();
226  	}
227  	public void resetGlobalGroups() {
228  		this.groups.clear();
229  	}
230  	public Group[] getGroupList() {
231  		synchronized(groups) {
232  			return groups.values().toArray(new Group[0]);
233  		}
234  	}
235  	public Group getGroup(String groupName) {
236  		if (!hasGroup(groupName))
237  			return null;
238  		return groups.get(groupName.toLowerCase());
239  	}
240  	public File getGlobalGroupsFile() {
241  		return GlobalGroupsFile;
242  	}
243  	public void removeGroupsChangedFlag() {
244  		setGroupsChanged(false);
245  		synchronized(groups) {
246  		for (Group g : groups.values()) {
247  			g.flagAsSaved();
248  		}
249  		}
250  	}
251  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ResultSetBuilder.java</h3>
            <pre><code>1  package redis.clients.jedis.graph;
<span onclick='openModal()' class='match'>2  import static java.util.Collections.emptyList;
3  import java.util.ArrayList;
4  import java.util.HashMap;
5  import java.util.Iterator;
6  import java.util.List;
7  import java.util.Map;
8  import java.util.Objects;
9  import java.util.stream.Collectors;
10  import redis.clients.jedis.Builder;
11  import redis.clients.jedis.BuilderFactory;
12  import redis.clients.jedis.exceptions.JedisDataException;
13  import redis.clients.jedis.exceptions.JedisException;
14  import redis.clients.jedis.graph.entities.*;
15  import redis.clients.jedis.util.SafeEncoder;
16  class ResultSetBuilder extends Builder<ResultSet> {
17    private final GraphCache graphCache;
</span>18    ResultSetBuilder(GraphCache cache) {
19      this.graphCache = cache;
20    }
21    @Override
22    public ResultSet build(Object data) {
23      List<Object> rawResponse = (List<Object>) data;
24      if (rawResponse.get(rawResponse.size() - 1) instanceof JedisDataException) {
25        throw (JedisDataException) rawResponse.get(rawResponse.size() - 1);
26      }
27      final Object headerObject;
28      final Object recordsObject;
29      final Object statisticsObject;
30      if (rawResponse.size() == 1) {
31        headerObject = emptyList();
32        recordsObject = emptyList();
33        statisticsObject = rawResponse.get(0);
34      } else if (rawResponse.size() == 3) {
35        headerObject = rawResponse.get(0);
36        recordsObject = rawResponse.get(1);
37        statisticsObject = rawResponse.get(2);
38      } else {
39        throw new JedisException("Unrecognized graph response format.");
40      }
41      HeaderImpl header = parseHeader(headerObject);
42      List<Record> records = parseRecords(header, recordsObject);
43      StatisticsImpl statistics = parseStatistics(statisticsObject);
44      return new ResultSetImpl(header, records, statistics);
45    }
46    private class ResultSetImpl implements ResultSet {
47      private final Header header;
48      private final List<Record> results;
49      private final Statistics statistics;
50      private ResultSetImpl(Header header, List<Record> results, Statistics statistics) {
51        this.header = header;
52        this.results = results;
53        this.statistics = statistics;
54      }
55      @Override
56      public Header getHeader() {
57        return header;
58      }
59      @Override
60      public Statistics getStatistics() {
61        return statistics;
62      }
63      @Override
64      public int size() {
65        return results.size();
66      }
67      @Override
68      public boolean equals(Object o) {
69        if (this == o) {
70          return true;
71        }
72        if (!(o instanceof ResultSetImpl)) {
73          return false;
74        }
75        ResultSetImpl resultSet = (ResultSetImpl) o;
76        return Objects.equals(getHeader(), resultSet.getHeader())
77            && Objects.equals(getStatistics(), resultSet.getStatistics())
78            && Objects.equals(results, resultSet.results);
79      }
80      @Override
81      public int hashCode() {
82        return Objects.hash(getHeader(), getStatistics(), results);
83      }
84      @Override
85      public String toString() {
86        final StringBuilder sb = new StringBuilder("ResultSetImpl{");
87        sb.append("header=").append(header);
88        sb.append(", statistics=").append(statistics);
89        sb.append(", results=").append(results);
90        sb.append('}');
91        return sb.toString();
92      }
93      @Override
94      public Iterator<Record> iterator() {
95        return results.iterator();
96      }
97    }
98    @SuppressWarnings("unchecked")
99    private List<Record> parseRecords(Header header, Object data) {
100      List<List<Object>> rawResultSet = (List<List<Object>>) data;
101      if (rawResultSet == null || rawResultSet.isEmpty()) {
102        return new ArrayList<>(0);
103      }
104      List<Record> results = new ArrayList<>(rawResultSet.size());
105      for (List<Object> row : rawResultSet) {
106        List<Object> parsedRow = new ArrayList<>(row.size());
107        for (int i = 0; i < row.size(); i++) {
108          List<Object> obj = (List<Object>) row.get(i);
109          ResultSet.ColumnType objType = header.getSchemaTypes().get(i);
110          switch (objType) {
111            case NODE:
112              parsedRow.add(deserializeNode(obj));
113              break;
114            case RELATION:
115              parsedRow.add(deserializeEdge(obj));
116              break;
117            case SCALAR:
118              parsedRow.add(deserializeScalar(obj));
119              break;
120            default:
121              parsedRow.add(null);
122              break;
123          }
124        }
125        Record record = new RecordImpl(header.getSchemaNames(), parsedRow);
126        results.add(record);
127      }
128      return results;
129    }
130    @SuppressWarnings("unchecked")
131    private Node deserializeNode(List<Object> rawNodeData) {
132      List<Long> labelsIndices = (List<Long>) rawNodeData.get(1);
133      List<List<Object>> rawProperties = (List<List<Object>>) rawNodeData.get(2);
134      Node node = new Node(labelsIndices.size(), rawProperties.size());
135      deserializeGraphEntityId(node, (Long) rawNodeData.get(0));
136      for (Long labelIndex : labelsIndices) {
137        String label = graphCache.getLabel(labelIndex.intValue());
138        node.addLabel(label);
139      }
140      deserializeGraphEntityProperties(node, rawProperties);
141      return node;
142    }
143    private void deserializeGraphEntityId(GraphEntity graphEntity, long id) {
144      graphEntity.setId(id);
145    }
146    @SuppressWarnings("unchecked")
147    private Edge deserializeEdge(List<Object> rawEdgeData) {
148      List<List<Object>> rawProperties = (List<List<Object>>) rawEdgeData.get(4);
149      Edge edge = new Edge(rawProperties.size());
150      deserializeGraphEntityId(edge, (Long) rawEdgeData.get(0));
151      String relationshipType = graphCache.getRelationshipType(((Long) rawEdgeData.get(1)).intValue());
152      edge.setRelationshipType(relationshipType);
153      edge.setSource((long) rawEdgeData.get(2));
154      edge.setDestination((long) rawEdgeData.get(3));
155      deserializeGraphEntityProperties(edge, rawProperties);
156      return edge;
157    }
158    private void deserializeGraphEntityProperties(GraphEntity entity, List<List<Object>> rawProperties) {
159      for (List<Object> rawProperty : rawProperties) {
160        String name = graphCache.getPropertyName(((Long) rawProperty.get(0)).intValue());
161        List<Object> propertyScalar = rawProperty.subList(1, rawProperty.size());
162        entity.addProperty(name, deserializeScalar(propertyScalar));
163      }
164    }
165    @SuppressWarnings("unchecked")
166    private Object deserializeScalar(List<Object> rawScalarData) {
167      ScalarType type = getValueTypeFromObject(rawScalarData.get(0));
168      Object obj = rawScalarData.get(1);
169      switch (type) {
170        case NULL:
171          return null;
172        case BOOLEAN:
173          return Boolean.parseBoolean(SafeEncoder.encode((byte[]) obj));
174        case DOUBLE:
175          return BuilderFactory.DOUBLE.build(obj);
176        case INTEGER:
177          return (Long) obj;
178        case STRING:
179          return SafeEncoder.encode((byte[]) obj);
180        case ARRAY:
181          return deserializeArray(obj);
182        case NODE:
183          return deserializeNode((List<Object>) obj);
184        case EDGE:
185          return deserializeEdge((List<Object>) obj);
186        case PATH:
187          return deserializePath(obj);
188        case MAP:
189          return deserializeMap(obj);
190        case POINT:
191          return deserializePoint(obj);
192        case UNKNOWN:
193        default:
194          return obj;
195      }
196    }
197    private Object deserializePoint(Object rawScalarData) {
198      return new Point(BuilderFactory.DOUBLE_LIST.build(rawScalarData));
199    }
200    @SuppressWarnings("unchecked")
201    private Map<String, Object> deserializeMap(Object rawScalarData) {
202      List<Object> keyTypeValueEntries = (List<Object>) rawScalarData;
203      int size = keyTypeValueEntries.size();
204      Map<String, Object> map = new HashMap<>(size >> 1); 
205      for (int i = 0; i < size; i += 2) {
206        String key = SafeEncoder.encode((byte[]) keyTypeValueEntries.get(i));
207        Object value = deserializeScalar((List<Object>) keyTypeValueEntries.get(i + 1));
208        map.put(key, value);
209      }
210      return map;
211    }
212    @SuppressWarnings("unchecked")
213    private Path deserializePath(Object rawScalarData) {
214      List<List<Object>> array = (List<List<Object>>) rawScalarData;
215      List<Node> nodes = (List<Node>) deserializeScalar(array.get(0));
216      List<Edge> edges = (List<Edge>) deserializeScalar(array.get(1));
217      return new Path(nodes, edges);
218    }
219    @SuppressWarnings("unchecked")
220    private List<Object> deserializeArray(Object rawScalarData) {
221      List<List<Object>> array = (List<List<Object>>) rawScalarData;
222      List<Object> res = new ArrayList<>(array.size());
223      for (List<Object> arrayValue : array) {
224        res.add(deserializeScalar(arrayValue));
225      }
226      return res;
227    }
228    private ScalarType getValueTypeFromObject(Object rawScalarType) {
229      return getScalarType(((Long) rawScalarType).intValue());
230    }
231    private static enum ScalarType {
232      UNKNOWN,
233      NULL,
234      STRING,
235      INTEGER, 
236      BOOLEAN,
237      DOUBLE,
238      ARRAY,
239      EDGE,
240      NODE,
241      PATH,
242      MAP,
243      POINT;
244    }
245    private static final ScalarType[] SCALAR_TYPES = ScalarType.values();
246    private static ScalarType getScalarType(int index) {
247      try {
248        return SCALAR_TYPES[index];
249      } catch (IndexOutOfBoundsException e) {
250        throw new JedisException("Unrecognized response type");
251      }
252    }
253    private class RecordImpl implements Record {
254      private final List<String> header;
255      private final List<Object> values;
256      public RecordImpl(List<String> header, List<Object> values) {
257        this.header = header;
258        this.values = values;
259      }
260      @Override
261      public <T> T getValue(int index) {
262        return (T) this.values.get(index);
263      }
264      @Override
265      public <T> T getValue(String key) {
266        return getValue(this.header.indexOf(key));
267      }
268      @Override
269      public String getString(int index) {
270        return this.values.get(index).toString();
271      }
272      @Override
273      public String getString(String key) {
274        return getString(this.header.indexOf(key));
275      }
276      @Override
277      public List<String> keys() {
278        return header;
279      }
280      @Override
281      public List<Object> values() {
282        return this.values;
283      }
284      @Override
285      public boolean containsKey(String key) {
286        return this.header.contains(key);
287      }
288      @Override
289      public int size() {
290        return this.header.size();
291      }
292      @Override
293      public boolean equals(Object o) {
294        if (this == o) {
295          return true;
296        }
297        if (!(o instanceof RecordImpl)) {
298          return false;
299        }
300        RecordImpl record = (RecordImpl) o;
301        return Objects.equals(header, record.header)
302            && Objects.equals(values, record.values);
303      }
304      @Override
305      public int hashCode() {
306        return Objects.hash(header, values);
307      }
308      @Override
309      public String toString() {
310        final StringBuilder sb = new StringBuilder("Record{");
311        sb.append("values=").append(values);
312        sb.append('}');
313        return sb.toString();
314      }
315    }
316    private static final ResultSet.ColumnType[] COLUMN_TYPES = ResultSet.ColumnType.values();
317    private class HeaderImpl implements Header {
318      private final List<ResultSet.ColumnType> schemaTypes;
319      private final List<String> schemaNames;
320      private HeaderImpl() {
321        this.schemaTypes = emptyList();
322        this.schemaNames = emptyList();
323      }
324      private HeaderImpl(List<ResultSet.ColumnType> schemaTypes, List<String> schemaNames) {
325        this.schemaTypes = schemaTypes;
326        this.schemaNames = schemaNames;
327      }
328      @Override
329      public List<String> getSchemaNames() {
330        return schemaNames;
331      }
332      @Override
333      public List<ResultSet.ColumnType> getSchemaTypes() {
334        return schemaTypes;
335      }
336      @Override
337      public boolean equals(Object o) {
338        if (this == o) {
339          return true;
340        }
341        if (!(o instanceof HeaderImpl)) {
342          return false;
343        }
344        HeaderImpl header = (HeaderImpl) o;
345        return Objects.equals(getSchemaTypes(), header.getSchemaTypes())
346            && Objects.equals(getSchemaNames(), header.getSchemaNames());
347      }
348      @Override
349      public int hashCode() {
350        return Objects.hash(getSchemaTypes(), getSchemaNames());
351      }
352      @Override
353      public String toString() {
354        final StringBuilder sb = new StringBuilder("HeaderImpl{");
355        sb.append("schemaTypes=").append(schemaTypes);
356        sb.append(", schemaNames=").append(schemaNames);
357        sb.append('}');
358        return sb.toString();
359      }
360    }
361    private HeaderImpl parseHeader(Object data) {
362      if (data == null) {
363        return new HeaderImpl();
364      }
365      List<List<Object>> list = (List<List<Object>>) data;
366      List<ResultSet.ColumnType> types = new ArrayList<>(list.size());
367      List<String> texts = new ArrayList<>(list.size());
368      for (List<Object> tuple : list) {
369        types.add(COLUMN_TYPES[((Long) tuple.get(0)).intValue()]);
370        texts.add(SafeEncoder.encode((byte[]) tuple.get(1)));
371      }
372      return new HeaderImpl(types, texts);
373    }
374    private class StatisticsImpl implements Statistics {
375      private final Map<String, String> statistics;
376      private StatisticsImpl(Map<String, String> statistics) {
377        this.statistics = statistics;
378      }
379      public String getStringValue(String label) {
380        return statistics.get(label);
381      }
382      private int getIntValue(String label) {
383        String value = getStringValue(label);
384        return value == null ? 0 : Integer.parseInt(value);
385      }
386      @Override
387      public int nodesCreated() {
388        return getIntValue("Nodes created");
389      }
390      @Override
391      public int nodesDeleted() {
392        return getIntValue("Nodes deleted");
393      }
394      @Override
395      public int indicesCreated() {
396        return getIntValue("Indices created");
397      }
398      @Override
399      public int indicesDeleted() {
400        return getIntValue("Indices deleted");
401      }
402      @Override
403      public int labelsAdded() {
404        return getIntValue("Labels added");
405      }
406      @Override
407      public int relationshipsDeleted() {
408        return getIntValue("Relationships deleted");
409      }
410      @Override
411      public int relationshipsCreated() {
412        return getIntValue("Relationships created");
413      }
414      @Override
415      public int propertiesSet() {
416        return getIntValue("Properties set");
417      }
418      @Override
419      public boolean cachedExecution() {
420        return "1".equals(getStringValue("Cached execution"));
421      }
422      @Override
423      public String queryIntervalExecutionTime() {
424        return getStringValue("Query internal execution time");
425      }
426      @Override
427      public boolean equals(Object o) {
428        if (this == o) {
429          return true;
430        }
431        if (!(o instanceof StatisticsImpl)) {
432          return false;
433        }
434        StatisticsImpl that = (StatisticsImpl) o;
435        return Objects.equals(statistics, that.statistics);
436      }
437      @Override
438      public int hashCode() {
439        return Objects.hash(statistics);
440      }
441      @Override
442      public String toString() {
443        final StringBuilder sb = new StringBuilder("Statistics{");
444        sb.append(statistics);
445        sb.append('}');
446        return sb.toString();
447      }
448    }
449    private StatisticsImpl parseStatistics(Object data) {
450      Map<String, String> map = ((List<byte[]>) data).stream()
451          .map(SafeEncoder::encode).map(s -> s.split(": "))
452          .collect(Collectors.toMap(sa -> sa[0], sa -> sa[1]));
453      return new StatisticsImpl(map);
454    }
455  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-GlobalGroups.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ResultSetBuilder.java</div>
                <div class="column column_space"><pre><code>9  import java.util.Collections;
10  import java.util.HashMap;
11  import java.util.Iterator;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.logging.Level;
15  import org.anjocaido.groupmanager.data.Group;
16  import org.anjocaido.groupmanager.events.GMGroupEvent;
17  import org.anjocaido.groupmanager.utils.PermissionCheckResult;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.yaml.snakeyaml.DumperOptions;
20  import org.yaml.snakeyaml.Yaml;
21  import org.yaml.snakeyaml.constructor.SafeConstructor;
22  import org.yaml.snakeyaml.reader.UnicodeReader;
23  public class GlobalGroups {
24  	private GroupManager plugin;
</pre></code></div>
                <div class="column column_space"><pre><code>2  import static java.util.Collections.emptyList;
3  import java.util.ArrayList;
4  import java.util.HashMap;
5  import java.util.Iterator;
6  import java.util.List;
7  import java.util.Map;
8  import java.util.Objects;
9  import java.util.stream.Collectors;
10  import redis.clients.jedis.Builder;
11  import redis.clients.jedis.BuilderFactory;
12  import redis.clients.jedis.exceptions.JedisDataException;
13  import redis.clients.jedis.exceptions.JedisException;
14  import redis.clients.jedis.graph.entities.*;
15  import redis.clients.jedis.util.SafeEncoder;
16  class ResultSetBuilder extends Builder<ResultSet> {
17    private final GraphCache graphCache;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    