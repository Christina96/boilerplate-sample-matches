<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ByteSourceTester_1.java &amp; Murmur3_32HashFunction_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ByteSourceTester_1.java &amp; Murmur3_32HashFunction_1.java
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ByteSourceTester_1.java (4.848485%)<th>Murmur3_32HashFunction_1.java (2.9906542%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(23-46)<td><a href="#" name="0">(28-53)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ByteSourceTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.io;
import static com.google.common.io.SourceSinkFactory.ByteSourceFactory;
<a name="0"></a>import static com.google.common.io.SourceSinkFactory.CharSourceFactory;
import static org.junit.Assert.assertArrayEquals;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.base.Charsets;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hashing;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.util.Map.Entry;
import java.util.Random;
import junit.framework.TestSuite;
@</b></font>AndroidIncompatible public class ByteSourceTester extends SourceSinkTester&lt;ByteSource, byte[], ByteSourceFactory&gt; {
  private static final ImmutableList&lt;Method&gt; testMethods = getTestMethods(ByteSourceTester.class);
  static TestSuite tests(String name, ByteSourceFactory factory, boolean testAsCharSource) {
    TestSuite suite = new TestSuite(name);
    for (Entry&lt;String, String&gt; entry : TEST_STRINGS.entrySet()) {
      if (testAsCharSource) {
        suite.addTest(suiteForString(factory, entry.getValue(), name, entry.getKey()));
      } else {
        suite.addTest(
            suiteForBytes(
                factory, entry.getValue().getBytes(Charsets.UTF_8), name, entry.getKey(), true));
      }
    }
    return suite;
  }
  static TestSuite suiteForString(
      ByteSourceFactory factory, String string, String name, String desc) {
    TestSuite suite = suiteForBytes(factory, string.getBytes(Charsets.UTF_8), name, desc, true);
    CharSourceFactory charSourceFactory = SourceSinkFactories.asCharSourceFactory(factory);
    suite.addTest(
        CharSourceTester.suiteForString(
            charSourceFactory, string, name + ".asCharSource[Charset]", desc));
    return suite;
  }
  static TestSuite suiteForBytes(
      ByteSourceFactory factory, byte[] bytes, String name, String desc, boolean slice) {
    TestSuite suite = new TestSuite(name + " [" + desc + "]");
    for (Method method : testMethods) {
      suite.addTest(new ByteSourceTester(factory, bytes, name, desc, method));
    }
    if (slice &amp;&amp; bytes.length &gt; 0) {
      Random random = new Random();
      byte[] expected = factory.getExpected(bytes);
      int off = expected.length == 0 ? 0 : random.nextInt(expected.length);
      int len = expected.length == 0 ? 4 : random.nextInt(expected.length - off);
      ByteSourceFactory sliced = SourceSinkFactories.asSlicedByteSourceFactory(factory, off, len);
      suite.addTest(suiteForBytes(sliced, bytes, name + ".slice[long, long]", desc, false));
      ByteSourceFactory slicedLongMaxValue =
          SourceSinkFactories.asSlicedByteSourceFactory(factory, off, Long.MAX_VALUE);
      suite.addTest(
          suiteForBytes(
              slicedLongMaxValue, bytes, name + ".slice[long, Long.MAX_VALUE]", desc, false));
      ByteSourceFactory slicedOffsetPastEnd =
          SourceSinkFactories.asSlicedByteSourceFactory(
              factory, expected.length + 2, expected.length + 10);
      suite.addTest(
          suiteForBytes(slicedOffsetPastEnd, bytes, name + ".slice[size + 2, long]", desc, false));
    }
    return suite;
  }
  private ByteSource source;
  public ByteSourceTester(
      ByteSourceFactory factory, byte[] bytes, String suiteName, String caseDesc, Method method) {
    super(factory, bytes, suiteName, caseDesc, method);
  }
  @Override
  public void setUp() throws IOException {
    source = factory.createSource(data);
  }
  public void testOpenStream() throws IOException {
    InputStream in = source.openStream();
    try {
      byte[] readBytes = ByteStreams.toByteArray(in);
      assertExpectedBytes(readBytes);
    } finally {
      in.close();
    }
  }
  public void testOpenBufferedStream() throws IOException {
    InputStream in = source.openBufferedStream();
    try {
      byte[] readBytes = ByteStreams.toByteArray(in);
      assertExpectedBytes(readBytes);
    } finally {
      in.close();
    }
  }
  public void testRead() throws IOException {
    byte[] readBytes = source.read();
    assertExpectedBytes(readBytes);
  }
  public void testCopyTo_outputStream() throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    source.copyTo(out);
    assertExpectedBytes(out.toByteArray());
  }
  public void testCopyTo_byteSink() throws IOException {
    final ByteArrayOutputStream out = new ByteArrayOutputStream();
    source.copyTo(
        new ByteSink() {
          @Override
          public OutputStream openStream() throws IOException {
            return out;
          }
        });
    assertExpectedBytes(out.toByteArray());
  }
  public void testIsEmpty() throws IOException {
    assertEquals(expected.length == 0, source.isEmpty());
  }
  public void testSize() throws IOException {
    assertEquals(expected.length, source.size());
  }
  public void testSizeIfKnown() throws IOException {
    Optional&lt;Long&gt; sizeIfKnown = source.sizeIfKnown();
    if (sizeIfKnown.isPresent()) {
      assertEquals(expected.length, (long) sizeIfKnown.get());
    }
  }
  public void testContentEquals() throws IOException {
    assertTrue(
        source.contentEquals(
            new ByteSource() {
              @Override
              public InputStream openStream() throws IOException {
                return new RandomAmountInputStream(
                    new ByteArrayInputStream(expected), new Random());
              }
            }));
  }
  public void testRead_usingByteProcessor() throws IOException {
    byte[] readBytes =
        source.read(
            new ByteProcessor&lt;byte[]&gt;() {
              final ByteArrayOutputStream out = new ByteArrayOutputStream();
              @Override
              public boolean processBytes(byte[] buf, int off, int len) throws IOException {
                out.write(buf, off, len);
                return true;
              }
              @Override
              public byte[] getResult() {
                return out.toByteArray();
              }
            });
    assertExpectedBytes(readBytes);
  }
  public void testHash() throws IOException {
    HashCode expectedHash = Hashing.md5().hashBytes(expected);
    assertEquals(expectedHash, source.hash(Hashing.md5()));
  }
  public void testSlice_illegalArguments() {
    try {
      source.slice(-1, 0);
      fail("expected IllegalArgumentException for call to slice with offset -1: " + source);
    } catch (IllegalArgumentException expected) {
    }
    try {
      source.slice(0, -1);
      fail("expected IllegalArgumentException for call to slice with length -1: " + source);
    } catch (IllegalArgumentException expected) {
    }
  }
  public void testSlice_constrainedRange() throws IOException {
    long size = source.read().length;
    if (size &gt;= 2) {
      ByteSource sliced = source.slice(1, size - 2);
      assertEquals(size - 2, sliced.read().length);
      ByteSource resliced = sliced.slice(0, size - 1);
      assertTrue(sliced.contentEquals(resliced));
    }
  }
  private void assertExpectedBytes(byte[] readBytes) {
    assertArrayEquals(expected, readBytes);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Murmur3_32HashFunction_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.hash;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static com.google.common.base.Preconditions.checkPositionIndexes;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.primitives.UnsignedBytes.toInt;
import com.google.common.base.Charsets;
import com.google.common.primitives.Chars;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.Immutable;
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import javax.annotation.CheckForNull;
@</b></font>Immutable
@ElementTypesAreNonnullByDefault
final class Murmur3_32HashFunction extends AbstractHashFunction implements Serializable {
  static final HashFunction MURMUR3_32 =
      new Murmur3_32HashFunction(0,   static final HashFunction MURMUR3_32_FIXED =
      new Murmur3_32HashFunction(0, 
  static final HashFunction GOOD_FAST_HASH_32 =
      new Murmur3_32HashFunction(Hashing.GOOD_FAST_HASH_SEED, 
  private static final int CHUNK_SIZE = 4;
  private static final int C1 = 0xcc9e2d51;
  private static final int C2 = 0x1b873593;
  private final int seed;
  private final boolean supplementaryPlaneFix;
  Murmur3_32HashFunction(int seed, boolean supplementaryPlaneFix) {
    this.seed = seed;
    this.supplementaryPlaneFix = supplementaryPlaneFix;
  }
  @Override
  public int bits() {
    return 32;
  }
  @Override
  public Hasher newHasher() {
    return new Murmur3_32Hasher(seed);
  }
  @Override
  public String toString() {
    return "Hashing.murmur3_32(" + seed + ")";
  }
  @Override
  public boolean equals(@CheckForNull Object object) {
    if (object instanceof Murmur3_32HashFunction) {
      Murmur3_32HashFunction other = (Murmur3_32HashFunction) object;
      return seed == other.seed &amp;&amp; supplementaryPlaneFix == other.supplementaryPlaneFix;
    }
    return false;
  }
  @Override
  public int hashCode() {
    return getClass().hashCode() ^ seed;
  }
  @Override
  public HashCode hashInt(int input) {
    int k1 = mixK1(input);
    int h1 = mixH1(seed, k1);
    return fmix(h1, Ints.BYTES);
  }
  @Override
  public HashCode hashLong(long input) {
    int low = (int) input;
    int high = (int) (input &gt;&gt;&gt; 32);
    int k1 = mixK1(low);
    int h1 = mixH1(seed, k1);
    k1 = mixK1(high);
    h1 = mixH1(h1, k1);
    return fmix(h1, Longs.BYTES);
  }
  @Override
  public HashCode hashUnencodedChars(CharSequence input) {
    int h1 = seed;
    for (int i = 1; i &lt; input.length(); i += 2) {
      int k1 = input.charAt(i - 1) | (input.charAt(i) &lt;&lt; 16);
      k1 = mixK1(k1);
      h1 = mixH1(h1, k1);
    }
    if ((input.length() &amp; 1) == 1) {
      int k1 = input.charAt(input.length() - 1);
      k1 = mixK1(k1);
      h1 ^= k1;
    }
    return fmix(h1, Chars.BYTES * input.length());
  }
  @SuppressWarnings("deprecation")   @Override
  public HashCode hashString(CharSequence input, Charset charset) {
    if (Charsets.UTF_8.equals(charset)) {
      int utf16Length = input.length();
      int h1 = seed;
      int i = 0;
      int len = 0;
      while (i + 4 &lt;= utf16Length) {
        char c0 = input.charAt(i);
        char c1 = input.charAt(i + 1);
        char c2 = input.charAt(i + 2);
        char c3 = input.charAt(i + 3);
        if (c0 &lt; 0x80 &amp;&amp; c1 &lt; 0x80 &amp;&amp; c2 &lt; 0x80 &amp;&amp; c3 &lt; 0x80) {
          int k1 = c0 | (c1 &lt;&lt; 8) | (c2 &lt;&lt; 16) | (c3 &lt;&lt; 24);
          k1 = mixK1(k1);
          h1 = mixH1(h1, k1);
          i += 4;
          len += 4;
        } else {
          break;
        }
      }
      long buffer = 0;
      int shift = 0;
      for (; i &lt; utf16Length; i++) {
        char c = input.charAt(i);
        if (c &lt; 0x80) {
          buffer |= (long) c &lt;&lt; shift;
          shift += 8;
          len++;
        } else if (c &lt; 0x800) {
          buffer |= charToTwoUtf8Bytes(c) &lt;&lt; shift;
          shift += 16;
          len += 2;
        } else if (c &lt; Character.MIN_SURROGATE || c &gt; Character.MAX_SURROGATE) {
          buffer |= charToThreeUtf8Bytes(c) &lt;&lt; shift;
          shift += 24;
          len += 3;
        } else {
          int codePoint = Character.codePointAt(input, i);
          if (codePoint == c) {
            return hashBytes(input.toString().getBytes(charset));
          }
          i++;
          buffer |= codePointToFourUtf8Bytes(codePoint) &lt;&lt; shift;
          if (supplementaryPlaneFix) {             shift += 32;
          }
          len += 4;
        }
        if (shift &gt;= 32) {
          int k1 = mixK1((int) buffer);
          h1 = mixH1(h1, k1);
          buffer = buffer &gt;&gt;&gt; 32;
          shift -= 32;
        }
      }
      int k1 = mixK1((int) buffer);
      h1 ^= k1;
      return fmix(h1, len);
    } else {
      return hashBytes(input.toString().getBytes(charset));
    }
  }
  @Override
  public HashCode hashBytes(byte[] input, int off, int len) {
    checkPositionIndexes(off, off + len, input.length);
    int h1 = seed;
    int i;
    for (i = 0; i + CHUNK_SIZE &lt;= len; i += CHUNK_SIZE) {
      int k1 = mixK1(getIntLittleEndian(input, off + i));
      h1 = mixH1(h1, k1);
    }
    int k1 = 0;
    for (int shift = 0; i &lt; len; i++, shift += 8) {
      k1 ^= toInt(input[off + i]) &lt;&lt; shift;
    }
    h1 ^= mixK1(k1);
    return fmix(h1, len);
  }
  private static int getIntLittleEndian(byte[] input, int offset) {
    return Ints.fromBytes(input[offset + 3], input[offset + 2], input[offset + 1], input[offset]);
  }
  private static int mixK1(int k1) {
    k1 *= C1;
    k1 = Integer.rotateLeft(k1, 15);
    k1 *= C2;
    return k1;
  }
  private static int mixH1(int h1, int k1) {
    h1 ^= k1;
    h1 = Integer.rotateLeft(h1, 13);
    h1 = h1 * 5 + 0xe6546b64;
    return h1;
  }
  private static HashCode fmix(int h1, int length) {
    h1 ^= length;
    h1 ^= h1 &gt;&gt;&gt; 16;
    h1 *= 0x85ebca6b;
    h1 ^= h1 &gt;&gt;&gt; 13;
    h1 *= 0xc2b2ae35;
    h1 ^= h1 &gt;&gt;&gt; 16;
    return HashCode.fromInt(h1);
  }
  @CanIgnoreReturnValue
  private static final class Murmur3_32Hasher extends AbstractHasher {
    private int h1;
    private long buffer;
    private int shift;
    private int length;
    private boolean isDone;
    Murmur3_32Hasher(int seed) {
      this.h1 = seed;
      this.length = 0;
      isDone = false;
    }
    private void update(int nBytes, long update) {
      buffer |= (update &amp; 0xFFFFFFFFL) &lt;&lt; shift;
      shift += nBytes * 8;
      length += nBytes;
      if (shift &gt;= 32) {
        h1 = mixH1(h1, mixK1((int) buffer));
        buffer &gt;&gt;&gt;= 32;
        shift -= 32;
      }
    }
    @Override
    public Hasher putByte(byte b) {
      update(1, b &amp; 0xFF);
      return this;
    }
    @Override
    public Hasher putBytes(byte[] bytes, int off, int len) {
      checkPositionIndexes(off, off + len, bytes.length);
      int i;
      for (i = 0; i + 4 &lt;= len; i += 4) {
        update(4, getIntLittleEndian(bytes, off + i));
      }
      for (; i &lt; len; i++) {
        putByte(bytes[off + i]);
      }
      return this;
    }
    @Override
    public Hasher putBytes(ByteBuffer buffer) {
      ByteOrder bo = buffer.order();
      buffer.order(ByteOrder.LITTLE_ENDIAN);
      while (buffer.remaining() &gt;= 4) {
        putInt(buffer.getInt());
      }
      while (buffer.hasRemaining()) {
        putByte(buffer.get());
      }
      buffer.order(bo);
      return this;
    }
    @Override
    public Hasher putInt(int i) {
      update(4, i);
      return this;
    }
    @Override
    public Hasher putLong(long l) {
      update(4, (int) l);
      update(4, l &gt;&gt;&gt; 32);
      return this;
    }
    @Override
    public Hasher putChar(char c) {
      update(2, c);
      return this;
    }
    @SuppressWarnings("deprecation")     @Override
    public Hasher putString(CharSequence input, Charset charset) {
      if (Charsets.UTF_8.equals(charset)) {
        int utf16Length = input.length();
        int i = 0;
        while (i + 4 &lt;= utf16Length) {
          char c0 = input.charAt(i);
          char c1 = input.charAt(i + 1);
          char c2 = input.charAt(i + 2);
          char c3 = input.charAt(i + 3);
          if (c0 &lt; 0x80 &amp;&amp; c1 &lt; 0x80 &amp;&amp; c2 &lt; 0x80 &amp;&amp; c3 &lt; 0x80) {
            update(4, c0 | (c1 &lt;&lt; 8) | (c2 &lt;&lt; 16) | (c3 &lt;&lt; 24));
            i += 4;
          } else {
            break;
          }
        }
        for (; i &lt; utf16Length; i++) {
          char c = input.charAt(i);
          if (c &lt; 0x80) {
            update(1, c);
          } else if (c &lt; 0x800) {
            update(2, charToTwoUtf8Bytes(c));
          } else if (c &lt; Character.MIN_SURROGATE || c &gt; Character.MAX_SURROGATE) {
            update(3, charToThreeUtf8Bytes(c));
          } else {
            int codePoint = Character.codePointAt(input, i);
            if (codePoint == c) {
              putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));
              return this;
            }
            i++;
            update(4, codePointToFourUtf8Bytes(codePoint));
          }
        }
        return this;
      } else {
        return super.putString(input, charset);
      }
    }
    @Override
    public HashCode hash() {
      checkState(!isDone);
      isDone = true;
      h1 ^= mixK1((int) buffer);
      return fmix(h1, length);
    }
  }
  private static long codePointToFourUtf8Bytes(int codePoint) {
    return ((0xFL &lt;&lt; 4) | (codePoint &gt;&gt;&gt; 18))
        | ((0x80L | (0x3F &amp; (codePoint &gt;&gt;&gt; 12))) &lt;&lt; 8)
        | ((0x80L | (0x3F &amp; (codePoint &gt;&gt;&gt; 6))) &lt;&lt; 16)
        | ((0x80L | (0x3F &amp; codePoint)) &lt;&lt; 24);
  }
  private static long charToThreeUtf8Bytes(char c) {
    return ((0x7L &lt;&lt; 5) | (c &gt;&gt;&gt; 12))
        | ((0x80 | (0x3F &amp; (c &gt;&gt;&gt; 6))) &lt;&lt; 8)
        | ((0x80 | (0x3F &amp; c)) &lt;&lt; 16);
  }
  private static long charToTwoUtf8Bytes(char c) {
    return ((0x3L &lt;&lt; 6) | (c &gt;&gt;&gt; 6)) | ((0x80 | (0x3F &amp; c)) &lt;&lt; 8);
  }
  private static final long serialVersionUID = 0L;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
