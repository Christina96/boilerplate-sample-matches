<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ByteSourceTester_1.java &amp; Murmur3_32HashFunction_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ByteSourceTester_1.java &amp; Murmur3_32HashFunction_1.java
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ByteSourceTester_1.java (4.848485%)<th>Murmur3_32HashFunction_1.java (2.9906542%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(23-46)<td><a href="#" name="0">(28-53)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ByteSourceTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.io;
2 import static com.google.common.io.SourceSinkFactory.ByteSourceFactory;
3 <a name="0"></a>import static com.google.common.io.SourceSinkFactory.CharSourceFactory;
4 import static org.junit.Assert.assertArrayEquals;
5 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.base.Charsets;
6 import com.google.common.base.Optional;
7 import com.google.common.collect.ImmutableList;
8 import com.google.common.hash.HashCode;
9 import com.google.common.hash.Hashing;
10 import java.io.ByteArrayInputStream;
11 import java.io.ByteArrayOutputStream;
12 import java.io.IOException;
13 import java.io.InputStream;
14 import java.io.OutputStream;
15 import java.lang.reflect.Method;
16 import java.util.Map.Entry;
17 import java.util.Random;
18 import junit.framework.TestSuite;
19 @</b></font>AndroidIncompatible public class ByteSourceTester extends SourceSinkTester&lt;ByteSource, byte[], ByteSourceFactory&gt; {
20   private static final ImmutableList&lt;Method&gt; testMethods = getTestMethods(ByteSourceTester.class);
21   static TestSuite tests(String name, ByteSourceFactory factory, boolean testAsCharSource) {
22     TestSuite suite = new TestSuite(name);
23     for (Entry&lt;String, String&gt; entry : TEST_STRINGS.entrySet()) {
24       if (testAsCharSource) {
25         suite.addTest(suiteForString(factory, entry.getValue(), name, entry.getKey()));
26       } else {
27         suite.addTest(
28             suiteForBytes(
29                 factory, entry.getValue().getBytes(Charsets.UTF_8), name, entry.getKey(), true));
30       }
31     }
32     return suite;
33   }
34   static TestSuite suiteForString(
35       ByteSourceFactory factory, String string, String name, String desc) {
36     TestSuite suite = suiteForBytes(factory, string.getBytes(Charsets.UTF_8), name, desc, true);
37     CharSourceFactory charSourceFactory = SourceSinkFactories.asCharSourceFactory(factory);
38     suite.addTest(
39         CharSourceTester.suiteForString(
40             charSourceFactory, string, name + ".asCharSource[Charset]", desc));
41     return suite;
42   }
43   static TestSuite suiteForBytes(
44       ByteSourceFactory factory, byte[] bytes, String name, String desc, boolean slice) {
45     TestSuite suite = new TestSuite(name + " [" + desc + "]");
46     for (Method method : testMethods) {
47       suite.addTest(new ByteSourceTester(factory, bytes, name, desc, method));
48     }
49     if (slice &amp;&amp; bytes.length &gt; 0) {
50       Random random = new Random();
51       byte[] expected = factory.getExpected(bytes);
52       int off = expected.length == 0 ? 0 : random.nextInt(expected.length);
53       int len = expected.length == 0 ? 4 : random.nextInt(expected.length - off);
54       ByteSourceFactory sliced = SourceSinkFactories.asSlicedByteSourceFactory(factory, off, len);
55       suite.addTest(suiteForBytes(sliced, bytes, name + ".slice[long, long]", desc, false));
56       ByteSourceFactory slicedLongMaxValue =
57           SourceSinkFactories.asSlicedByteSourceFactory(factory, off, Long.MAX_VALUE);
58       suite.addTest(
59           suiteForBytes(
60               slicedLongMaxValue, bytes, name + ".slice[long, Long.MAX_VALUE]", desc, false));
61       ByteSourceFactory slicedOffsetPastEnd =
62           SourceSinkFactories.asSlicedByteSourceFactory(
63               factory, expected.length + 2, expected.length + 10);
64       suite.addTest(
65           suiteForBytes(slicedOffsetPastEnd, bytes, name + ".slice[size + 2, long]", desc, false));
66     }
67     return suite;
68   }
69   private ByteSource source;
70   public ByteSourceTester(
71       ByteSourceFactory factory, byte[] bytes, String suiteName, String caseDesc, Method method) {
72     super(factory, bytes, suiteName, caseDesc, method);
73   }
74   @Override
75   public void setUp() throws IOException {
76     source = factory.createSource(data);
77   }
78   public void testOpenStream() throws IOException {
79     InputStream in = source.openStream();
80     try {
81       byte[] readBytes = ByteStreams.toByteArray(in);
82       assertExpectedBytes(readBytes);
83     } finally {
84       in.close();
85     }
86   }
87   public void testOpenBufferedStream() throws IOException {
88     InputStream in = source.openBufferedStream();
89     try {
90       byte[] readBytes = ByteStreams.toByteArray(in);
91       assertExpectedBytes(readBytes);
92     } finally {
93       in.close();
94     }
95   }
96   public void testRead() throws IOException {
97     byte[] readBytes = source.read();
98     assertExpectedBytes(readBytes);
99   }
100   public void testCopyTo_outputStream() throws IOException {
101     ByteArrayOutputStream out = new ByteArrayOutputStream();
102     source.copyTo(out);
103     assertExpectedBytes(out.toByteArray());
104   }
105   public void testCopyTo_byteSink() throws IOException {
106     final ByteArrayOutputStream out = new ByteArrayOutputStream();
107     source.copyTo(
108         new ByteSink() {
109           @Override
110           public OutputStream openStream() throws IOException {
111             return out;
112           }
113         });
114     assertExpectedBytes(out.toByteArray());
115   }
116   public void testIsEmpty() throws IOException {
117     assertEquals(expected.length == 0, source.isEmpty());
118   }
119   public void testSize() throws IOException {
120     assertEquals(expected.length, source.size());
121   }
122   public void testSizeIfKnown() throws IOException {
123     Optional&lt;Long&gt; sizeIfKnown = source.sizeIfKnown();
124     if (sizeIfKnown.isPresent()) {
125       assertEquals(expected.length, (long) sizeIfKnown.get());
126     }
127   }
128   public void testContentEquals() throws IOException {
129     assertTrue(
130         source.contentEquals(
131             new ByteSource() {
132               @Override
133               public InputStream openStream() throws IOException {
134                 return new RandomAmountInputStream(
135                     new ByteArrayInputStream(expected), new Random());
136               }
137             }));
138   }
139   public void testRead_usingByteProcessor() throws IOException {
140     byte[] readBytes =
141         source.read(
142             new ByteProcessor&lt;byte[]&gt;() {
143               final ByteArrayOutputStream out = new ByteArrayOutputStream();
144               @Override
145               public boolean processBytes(byte[] buf, int off, int len) throws IOException {
146                 out.write(buf, off, len);
147                 return true;
148               }
149               @Override
150               public byte[] getResult() {
151                 return out.toByteArray();
152               }
153             });
154     assertExpectedBytes(readBytes);
155   }
156   public void testHash() throws IOException {
157     HashCode expectedHash = Hashing.md5().hashBytes(expected);
158     assertEquals(expectedHash, source.hash(Hashing.md5()));
159   }
160   public void testSlice_illegalArguments() {
161     try {
162       source.slice(-1, 0);
163       fail("expected IllegalArgumentException for call to slice with offset -1: " + source);
164     } catch (IllegalArgumentException expected) {
165     }
166     try {
167       source.slice(0, -1);
168       fail("expected IllegalArgumentException for call to slice with length -1: " + source);
169     } catch (IllegalArgumentException expected) {
170     }
171   }
172   public void testSlice_constrainedRange() throws IOException {
173     long size = source.read().length;
174     if (size &gt;= 2) {
175       ByteSource sliced = source.slice(1, size - 2);
176       assertEquals(size - 2, sliced.read().length);
177       ByteSource resliced = sliced.slice(0, size - 1);
178       assertTrue(sliced.contentEquals(resliced));
179     }
180   }
181   private void assertExpectedBytes(byte[] readBytes) {
182     assertArrayEquals(expected, readBytes);
183   }
184 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Murmur3_32HashFunction_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.hash;
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static com.google.common.base.Preconditions.checkPositionIndexes;
4 import static com.google.common.base.Preconditions.checkState;
5 import static com.google.common.primitives.UnsignedBytes.toInt;
6 import com.google.common.base.Charsets;
7 import com.google.common.primitives.Chars;
8 import com.google.common.primitives.Ints;
9 import com.google.common.primitives.Longs;
10 import com.google.errorprone.annotations.CanIgnoreReturnValue;
11 import com.google.errorprone.annotations.Immutable;
12 import java.io.Serializable;
13 import java.nio.ByteBuffer;
14 import java.nio.ByteOrder;
15 import java.nio.charset.Charset;
16 import javax.annotation.CheckForNull;
17 @</b></font>Immutable
18 @ElementTypesAreNonnullByDefault
19 final class Murmur3_32HashFunction extends AbstractHashFunction implements Serializable {
20   static final HashFunction MURMUR3_32 =
21       new Murmur3_32HashFunction(0,   static final HashFunction MURMUR3_32_FIXED =
22       new Murmur3_32HashFunction(0, 
23   static final HashFunction GOOD_FAST_HASH_32 =
24       new Murmur3_32HashFunction(Hashing.GOOD_FAST_HASH_SEED, 
25   private static final int CHUNK_SIZE = 4;
26   private static final int C1 = 0xcc9e2d51;
27   private static final int C2 = 0x1b873593;
28   private final int seed;
29   private final boolean supplementaryPlaneFix;
30   Murmur3_32HashFunction(int seed, boolean supplementaryPlaneFix) {
31     this.seed = seed;
32     this.supplementaryPlaneFix = supplementaryPlaneFix;
33   }
34   @Override
35   public int bits() {
36     return 32;
37   }
38   @Override
39   public Hasher newHasher() {
40     return new Murmur3_32Hasher(seed);
41   }
42   @Override
43   public String toString() {
44     return "Hashing.murmur3_32(" + seed + ")";
45   }
46   @Override
47   public boolean equals(@CheckForNull Object object) {
48     if (object instanceof Murmur3_32HashFunction) {
49       Murmur3_32HashFunction other = (Murmur3_32HashFunction) object;
50       return seed == other.seed &amp;&amp; supplementaryPlaneFix == other.supplementaryPlaneFix;
51     }
52     return false;
53   }
54   @Override
55   public int hashCode() {
56     return getClass().hashCode() ^ seed;
57   }
58   @Override
59   public HashCode hashInt(int input) {
60     int k1 = mixK1(input);
61     int h1 = mixH1(seed, k1);
62     return fmix(h1, Ints.BYTES);
63   }
64   @Override
65   public HashCode hashLong(long input) {
66     int low = (int) input;
67     int high = (int) (input &gt;&gt;&gt; 32);
68     int k1 = mixK1(low);
69     int h1 = mixH1(seed, k1);
70     k1 = mixK1(high);
71     h1 = mixH1(h1, k1);
72     return fmix(h1, Longs.BYTES);
73   }
74   @Override
75   public HashCode hashUnencodedChars(CharSequence input) {
76     int h1 = seed;
77     for (int i = 1; i &lt; input.length(); i += 2) {
78       int k1 = input.charAt(i - 1) | (input.charAt(i) &lt;&lt; 16);
79       k1 = mixK1(k1);
80       h1 = mixH1(h1, k1);
81     }
82     if ((input.length() &amp; 1) == 1) {
83       int k1 = input.charAt(input.length() - 1);
84       k1 = mixK1(k1);
85       h1 ^= k1;
86     }
87     return fmix(h1, Chars.BYTES * input.length());
88   }
89   @SuppressWarnings("deprecation")   @Override
90   public HashCode hashString(CharSequence input, Charset charset) {
91     if (Charsets.UTF_8.equals(charset)) {
92       int utf16Length = input.length();
93       int h1 = seed;
94       int i = 0;
95       int len = 0;
96       while (i + 4 &lt;= utf16Length) {
97         char c0 = input.charAt(i);
98         char c1 = input.charAt(i + 1);
99         char c2 = input.charAt(i + 2);
100         char c3 = input.charAt(i + 3);
101         if (c0 &lt; 0x80 &amp;&amp; c1 &lt; 0x80 &amp;&amp; c2 &lt; 0x80 &amp;&amp; c3 &lt; 0x80) {
102           int k1 = c0 | (c1 &lt;&lt; 8) | (c2 &lt;&lt; 16) | (c3 &lt;&lt; 24);
103           k1 = mixK1(k1);
104           h1 = mixH1(h1, k1);
105           i += 4;
106           len += 4;
107         } else {
108           break;
109         }
110       }
111       long buffer = 0;
112       int shift = 0;
113       for (; i &lt; utf16Length; i++) {
114         char c = input.charAt(i);
115         if (c &lt; 0x80) {
116           buffer |= (long) c &lt;&lt; shift;
117           shift += 8;
118           len++;
119         } else if (c &lt; 0x800) {
120           buffer |= charToTwoUtf8Bytes(c) &lt;&lt; shift;
121           shift += 16;
122           len += 2;
123         } else if (c &lt; Character.MIN_SURROGATE || c &gt; Character.MAX_SURROGATE) {
124           buffer |= charToThreeUtf8Bytes(c) &lt;&lt; shift;
125           shift += 24;
126           len += 3;
127         } else {
128           int codePoint = Character.codePointAt(input, i);
129           if (codePoint == c) {
130             return hashBytes(input.toString().getBytes(charset));
131           }
132           i++;
133           buffer |= codePointToFourUtf8Bytes(codePoint) &lt;&lt; shift;
134           if (supplementaryPlaneFix) {             shift += 32;
135           }
136           len += 4;
137         }
138         if (shift &gt;= 32) {
139           int k1 = mixK1((int) buffer);
140           h1 = mixH1(h1, k1);
141           buffer = buffer &gt;&gt;&gt; 32;
142           shift -= 32;
143         }
144       }
145       int k1 = mixK1((int) buffer);
146       h1 ^= k1;
147       return fmix(h1, len);
148     } else {
149       return hashBytes(input.toString().getBytes(charset));
150     }
151   }
152   @Override
153   public HashCode hashBytes(byte[] input, int off, int len) {
154     checkPositionIndexes(off, off + len, input.length);
155     int h1 = seed;
156     int i;
157     for (i = 0; i + CHUNK_SIZE &lt;= len; i += CHUNK_SIZE) {
158       int k1 = mixK1(getIntLittleEndian(input, off + i));
159       h1 = mixH1(h1, k1);
160     }
161     int k1 = 0;
162     for (int shift = 0; i &lt; len; i++, shift += 8) {
163       k1 ^= toInt(input[off + i]) &lt;&lt; shift;
164     }
165     h1 ^= mixK1(k1);
166     return fmix(h1, len);
167   }
168   private static int getIntLittleEndian(byte[] input, int offset) {
169     return Ints.fromBytes(input[offset + 3], input[offset + 2], input[offset + 1], input[offset]);
170   }
171   private static int mixK1(int k1) {
172     k1 *= C1;
173     k1 = Integer.rotateLeft(k1, 15);
174     k1 *= C2;
175     return k1;
176   }
177   private static int mixH1(int h1, int k1) {
178     h1 ^= k1;
179     h1 = Integer.rotateLeft(h1, 13);
180     h1 = h1 * 5 + 0xe6546b64;
181     return h1;
182   }
183   private static HashCode fmix(int h1, int length) {
184     h1 ^= length;
185     h1 ^= h1 &gt;&gt;&gt; 16;
186     h1 *= 0x85ebca6b;
187     h1 ^= h1 &gt;&gt;&gt; 13;
188     h1 *= 0xc2b2ae35;
189     h1 ^= h1 &gt;&gt;&gt; 16;
190     return HashCode.fromInt(h1);
191   }
192   @CanIgnoreReturnValue
193   private static final class Murmur3_32Hasher extends AbstractHasher {
194     private int h1;
195     private long buffer;
196     private int shift;
197     private int length;
198     private boolean isDone;
199     Murmur3_32Hasher(int seed) {
200       this.h1 = seed;
201       this.length = 0;
202       isDone = false;
203     }
204     private void update(int nBytes, long update) {
205       buffer |= (update &amp; 0xFFFFFFFFL) &lt;&lt; shift;
206       shift += nBytes * 8;
207       length += nBytes;
208       if (shift &gt;= 32) {
209         h1 = mixH1(h1, mixK1((int) buffer));
210         buffer &gt;&gt;&gt;= 32;
211         shift -= 32;
212       }
213     }
214     @Override
215     public Hasher putByte(byte b) {
216       update(1, b &amp; 0xFF);
217       return this;
218     }
219     @Override
220     public Hasher putBytes(byte[] bytes, int off, int len) {
221       checkPositionIndexes(off, off + len, bytes.length);
222       int i;
223       for (i = 0; i + 4 &lt;= len; i += 4) {
224         update(4, getIntLittleEndian(bytes, off + i));
225       }
226       for (; i &lt; len; i++) {
227         putByte(bytes[off + i]);
228       }
229       return this;
230     }
231     @Override
232     public Hasher putBytes(ByteBuffer buffer) {
233       ByteOrder bo = buffer.order();
234       buffer.order(ByteOrder.LITTLE_ENDIAN);
235       while (buffer.remaining() &gt;= 4) {
236         putInt(buffer.getInt());
237       }
238       while (buffer.hasRemaining()) {
239         putByte(buffer.get());
240       }
241       buffer.order(bo);
242       return this;
243     }
244     @Override
245     public Hasher putInt(int i) {
246       update(4, i);
247       return this;
248     }
249     @Override
250     public Hasher putLong(long l) {
251       update(4, (int) l);
252       update(4, l &gt;&gt;&gt; 32);
253       return this;
254     }
255     @Override
256     public Hasher putChar(char c) {
257       update(2, c);
258       return this;
259     }
260     @SuppressWarnings("deprecation")     @Override
261     public Hasher putString(CharSequence input, Charset charset) {
262       if (Charsets.UTF_8.equals(charset)) {
263         int utf16Length = input.length();
264         int i = 0;
265         while (i + 4 &lt;= utf16Length) {
266           char c0 = input.charAt(i);
267           char c1 = input.charAt(i + 1);
268           char c2 = input.charAt(i + 2);
269           char c3 = input.charAt(i + 3);
270           if (c0 &lt; 0x80 &amp;&amp; c1 &lt; 0x80 &amp;&amp; c2 &lt; 0x80 &amp;&amp; c3 &lt; 0x80) {
271             update(4, c0 | (c1 &lt;&lt; 8) | (c2 &lt;&lt; 16) | (c3 &lt;&lt; 24));
272             i += 4;
273           } else {
274             break;
275           }
276         }
277         for (; i &lt; utf16Length; i++) {
278           char c = input.charAt(i);
279           if (c &lt; 0x80) {
280             update(1, c);
281           } else if (c &lt; 0x800) {
282             update(2, charToTwoUtf8Bytes(c));
283           } else if (c &lt; Character.MIN_SURROGATE || c &gt; Character.MAX_SURROGATE) {
284             update(3, charToThreeUtf8Bytes(c));
285           } else {
286             int codePoint = Character.codePointAt(input, i);
287             if (codePoint == c) {
288               putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));
289               return this;
290             }
291             i++;
292             update(4, codePointToFourUtf8Bytes(codePoint));
293           }
294         }
295         return this;
296       } else {
297         return super.putString(input, charset);
298       }
299     }
300     @Override
301     public HashCode hash() {
302       checkState(!isDone);
303       isDone = true;
304       h1 ^= mixK1((int) buffer);
305       return fmix(h1, length);
306     }
307   }
308   private static long codePointToFourUtf8Bytes(int codePoint) {
309     return ((0xFL &lt;&lt; 4) | (codePoint &gt;&gt;&gt; 18))
310         | ((0x80L | (0x3F &amp; (codePoint &gt;&gt;&gt; 12))) &lt;&lt; 8)
311         | ((0x80L | (0x3F &amp; (codePoint &gt;&gt;&gt; 6))) &lt;&lt; 16)
312         | ((0x80L | (0x3F &amp; codePoint)) &lt;&lt; 24);
313   }
314   private static long charToThreeUtf8Bytes(char c) {
315     return ((0x7L &lt;&lt; 5) | (c &gt;&gt;&gt; 12))
316         | ((0x80 | (0x3F &amp; (c &gt;&gt;&gt; 6))) &lt;&lt; 8)
317         | ((0x80 | (0x3F &amp; c)) &lt;&lt; 16);
318   }
319   private static long charToTwoUtf8Bytes(char c) {
320     return ((0x3L &lt;&lt; 6) | (c &gt;&gt;&gt; 6)) | ((0x80 | (0x3F &amp; c)) &lt;&lt; 8);
321   }
322   private static final long serialVersionUID = 0L;
323 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
