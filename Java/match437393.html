<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractIndexedListIterator_1.java &amp; DenseImmutableTable.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractIndexedListIterator_1.java &amp; DenseImmutableTable.java
      </h3>
<h1 align="center">
        13.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractIndexedListIterator_1.java (36.78161%)<th>DenseImmutableTable.java (8.290155%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(68-77)<td><a href="#" name="0">(154-163)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(82-90)<td><a href="#" name="1">(113-121)</a><td align="center"><font color="#e90000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(101-107)<td><a href="#" name="2">(202-208)</a><td align="center"><font color="#bf0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractIndexedListIterator_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkPositionIndex;
3 import com.google.common.annotations.GwtCompatible;
4 import java.util.ListIterator;
5 import java.util.NoSuchElementException;
6 import org.checkerframework.checker.nullness.qual.Nullable;
7 @GwtCompatible
8 @ElementTypesAreNonnullByDefault
9 abstract class AbstractIndexedListIterator&lt;E extends @Nullable Object&gt;
10     extends UnmodifiableListIterator&lt;E&gt; {
11   private final int size;
12   private int position;
13   @ParametricNullness
14   protected abstract E get(int index);
15   protected AbstractIndexedListIterator(int size) {
16     this(size, 0);
17   }
18 <a name="0"></a>  protected AbstractIndexedListIterator(int size, int position) {
19     checkPositionIndex(position, size);
20     this.size = size;
21     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>this.position = position;
22   }
23   @Override
24   public final boolean hasNext() {
25     return position &lt; size;
26   }
27   @Override
28   @</b></font>ParametricNullness
29   public final E next() {
30 <a name="1"></a>    if (!hasNext()) {
31       throw new NoSuchElementException();
32     }
33     return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>get(position++);
34   }
35   @Override
36   public final int nextIndex() {
37     return position;
38   }
39   @</b></font>Override
40   public final boolean hasPrevious() {
41     return position &gt; 0;
42   }
43   @Override
44   @ParametricNullness
45   public final E previous() {
46 <a name="2"></a>    if (!hasPrevious()) {
47       throw new NoSuchElementException();
48     }
49     return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>get(--position);
50   }
51   @Override
52   public final int previousIndex() {
53     return position - 1;
54   }</b></font>
55 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DenseImmutableTable.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (C) 2009 The Guava Authors
3  *
4  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
5  * in compliance with the License. You may obtain a copy of the License at
6  *
7  * http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software distributed under the License
10  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
11  * or implied. See the License for the specific language governing permissions and limitations under
12  * the License.
13  */
14 package com.google.common.collect;
15 import static java.util.Objects.requireNonNull;
16 import com.google.common.annotations.GwtCompatible;
17 import com.google.common.collect.ImmutableMap.IteratorBasedImmutableMap;
18 import com.google.errorprone.annotations.Immutable;
19 import com.google.j2objc.annotations.WeakOuter;
20 import java.util.Map;
21 import javax.annotation.CheckForNull;
22 import org.checkerframework.checker.nullness.qual.Nullable;
23 @GwtCompatible
24 @Immutable(containerOf = {"R", "C", "V"})
25 @ElementTypesAreNonnullByDefault
26 final class DenseImmutableTable&lt;R, C, V&gt; extends RegularImmutableTable&lt;R, C, V&gt; {
27   private final ImmutableMap&lt;R, Integer&gt; rowKeyToIndex;
28   private final ImmutableMap&lt;C, Integer&gt; columnKeyToIndex;
29   private final ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt; rowMap;
30   private final ImmutableMap&lt;C, ImmutableMap&lt;R, V&gt;&gt; columnMap;
31   @SuppressWarnings("Immutable")   private final int[] rowCounts;
32   @SuppressWarnings("Immutable")   private final int[] columnCounts;
33   @SuppressWarnings("Immutable")   private final @Nullable V[][] values;
34   @SuppressWarnings("Immutable")   private final int[] cellRowIndices;
35   @SuppressWarnings("Immutable")   private final int[] cellColumnIndices;
36   DenseImmutableTable(
37       ImmutableList&lt;Cell&lt;R, C, V&gt;&gt; cellList,
38       ImmutableSet&lt;R&gt; rowSpace,
39       ImmutableSet&lt;C&gt; columnSpace) {
40     @SuppressWarnings("unchecked")
41     @Nullable
42     V[][] array = (@Nullable V[][]) new Object[rowSpace.size()][columnSpace.size()];
43     this.values = array;
44     this.rowKeyToIndex = Maps.indexMap(rowSpace);
45     this.columnKeyToIndex = Maps.indexMap(columnSpace);
46     rowCounts = new int[rowKeyToIndex.size()];
47     columnCounts = new int[columnKeyToIndex.size()];
48     int[] cellRowIndices = new int[cellList.size()];
49     int[] cellColumnIndices = new int[cellList.size()];
50     for (int i = 0; i &lt; cellList.size(); i++) {
51       Cell&lt;R, C, V&gt; cell = cellList.get(i);
52       R rowKey = cell.getRowKey();
53       C columnKey = cell.getColumnKey();
54       int rowIndex = requireNonNull(rowKeyToIndex.get(rowKey));
55       int columnIndex = requireNonNull(columnKeyToIndex.get(columnKey));
56       V existingValue = values[rowIndex][columnIndex];
57       checkNoDuplicate(rowKey, columnKey, existingValue, cell.getValue());
58       values[rowIndex][columnIndex] = cell.getValue();
59       rowCounts[rowIndex]++;
60       columnCounts[columnIndex]++;
61       cellRowIndices[i] = rowIndex;
62       cellColumnIndices[i] = columnIndex;
63     }
64     this.cellRowIndices = cellRowIndices;
65     this.cellColumnIndices = cellColumnIndices;
66     this.rowMap = new RowMap();
67     this.columnMap = new ColumnMap();
68   }
69   private abstract static class ImmutableArrayMap&lt;K, V&gt; extends IteratorBasedImmutableMap&lt;K, V&gt; {
70     private final int size;
71     ImmutableArrayMap(int size) {
72       this.size = size;
73     }
74     abstract ImmutableMap&lt;K, Integer&gt; keyToIndex();
75     private boolean isFull() {
76       return size == keyToIndex().size();
77     }
78     K getKey(int index) {
79       return keyToIndex().keySet().asList().get(index);
80     }
81     @CheckForNull
82     abstract V getValue(int keyIndex);
83 <a name="1"></a>
84     @Override
85     ImmutableSet&lt;K&gt; createKeySet() {
86       return isFull() ? keyToIndex().keySet() : <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.createKeySet();
87     }
88     @Override
89     public int size() {
90       return size;
91     }
92     @</b></font>Override
93     @CheckForNull
94     public V get(@CheckForNull Object key) {
95       Integer keyIndex = keyToIndex().get(key);
96       return (keyIndex == null) ? null : getValue(keyIndex);
97     }
98     @Override
99     UnmodifiableIterator&lt;Entry&lt;K, V&gt;&gt; entryIterator() {
100       return new AbstractIterator&lt;Entry&lt;K, V&gt;&gt;() {
101         private int index = -1;
102         private final int maxIndex = keyToIndex().size();
103         @Override
104         @CheckForNull
105         protected Entry&lt;K, V&gt; computeNext() {
106           for (index++; index &lt; maxIndex; index++) {
107             V value = getValue(index);
108             if (value != null) {
109               return Maps.immutableEntry(getKey(index), value);
110             }
111           }
112           return endOfData();
113         }
114       };
115     }
116   }
117   private final class Row extends ImmutableArrayMap&lt;C, V&gt; {
118     private final int rowIndex;
119 <a name="0"></a>
120     Row(int rowIndex) {
121       super(rowCounts[rowIndex]);
122       <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>this.rowIndex = rowIndex;
123     }
124     @Override
125     ImmutableMap&lt;C, Integer&gt; keyToIndex() {
126       return columnKeyToIndex;
127     }
128     @Override
129     @</b></font>CheckForNull
130     V getValue(int keyIndex) {
131       return values[rowIndex][keyIndex];
132     }
133     @Override
134     boolean isPartialView() {
135       return true;
136     }
137   }
138   private final class Column extends ImmutableArrayMap&lt;R, V&gt; {
139     private final int columnIndex;
140     Column(int columnIndex) {
141       super(columnCounts[columnIndex]);
142       this.columnIndex = columnIndex;
143     }
144     @Override
145     ImmutableMap&lt;R, Integer&gt; keyToIndex() {
146       return rowKeyToIndex;
147     }
148     @Override
149     @CheckForNull
150     V getValue(int keyIndex) {
151       return values[keyIndex][columnIndex];
152     }
153     @Override
154     boolean isPartialView() {
155       return true;
156     }
157   }
158 <a name="2"></a>  @WeakOuter
159   private final class RowMap extends ImmutableArrayMap&lt;R, ImmutableMap&lt;C, V&gt;&gt; {
160     private RowMap() {
161       <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super(rowCounts.length);
162     }
163     @Override
164     ImmutableMap&lt;R, Integer&gt; keyToIndex() {
165       return rowKeyToIndex;
166     }</b></font>
167     @Override
168     ImmutableMap&lt;C, V&gt; getValue(int keyIndex) {
169       return new Row(keyIndex);
170     }
171     @Override
172     boolean isPartialView() {
173       return false;
174     }
175   }
176   @WeakOuter
177   private final class ColumnMap extends ImmutableArrayMap&lt;C, ImmutableMap&lt;R, V&gt;&gt; {
178     private ColumnMap() {
179       super(columnCounts.length);
180     }
181     @Override
182     ImmutableMap&lt;C, Integer&gt; keyToIndex() {
183       return columnKeyToIndex;
184     }
185     @Override
186     ImmutableMap&lt;R, V&gt; getValue(int keyIndex) {
187       return new Column(keyIndex);
188     }
189     @Override
190     boolean isPartialView() {
191       return false;
192     }
193   }
194   @Override
195   public ImmutableMap&lt;C, Map&lt;R, V&gt;&gt; columnMap() {
196     ImmutableMap&lt;C, ImmutableMap&lt;R, V&gt;&gt; columnMap = this.columnMap;
197     return ImmutableMap.&lt;C, Map&lt;R, V&gt;&gt;copyOf(columnMap);
198   }
199   @Override
200   public ImmutableMap&lt;R, Map&lt;C, V&gt;&gt; rowMap() {
201     ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt; rowMap = this.rowMap;
202     return ImmutableMap.&lt;R, Map&lt;C, V&gt;&gt;copyOf(rowMap);
203   }
204   @Override
205   @CheckForNull
206   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
207     Integer rowIndex = rowKeyToIndex.get(rowKey);
208     Integer columnIndex = columnKeyToIndex.get(columnKey);
209     return ((rowIndex == null) || (columnIndex == null)) ? null : values[rowIndex][columnIndex];
210   }
211   @Override
212   public int size() {
213     return cellRowIndices.length;
214   }
215   @Override
216   Cell&lt;R, C, V&gt; getCell(int index) {
217     int rowIndex = cellRowIndices[index];
218     int columnIndex = cellColumnIndices[index];
219     R rowKey = rowKeySet().asList().get(rowIndex);
220     C columnKey = columnKeySet().asList().get(columnIndex);
221     V value = requireNonNull(values[rowIndex][columnIndex]);
222     return cellOf(rowKey, columnKey, value);
223   }
224   @Override
225   V getValue(int index) {
226     return requireNonNull(values[cellRowIndices[index]][cellColumnIndices[index]]);
227   }
228   @Override
229   SerializedForm createSerializedForm() {
230     return SerializedForm.create(this, cellRowIndices, cellColumnIndices);
231   }
232 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
