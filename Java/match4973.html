<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for AbstractTransportTestCases.java & ClientImplTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for AbstractTransportTestCases.java & ClientImplTest.java
      </h3>
      <h1 align="center">
        34.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>AbstractTransportTestCases.java (59.819122%)<TH>ClientImplTest.java (24.139729%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#0',2,'match4973-1.html#0',3)" NAME="0">(20-68)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#0',2,'match4973-1.html#0',3)" NAME="0">(21-69)</A><TD ALIGN=center><FONT COLOR="#ff0000">45</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#1',2,'match4973-1.html#1',3)" NAME="1">(298-321)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#1',2,'match4973-1.html#1',3)" NAME="1">(1122-1139)</A><TD ALIGN=center><FONT COLOR="#770000">21</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#2',2,'match4973-1.html#2',3)" NAME="2">(256-278)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#2',2,'match4973-1.html#2',3)" NAME="2">(938-955)</A><TD ALIGN=center><FONT COLOR="#770000">21</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#3',2,'match4973-1.html#3',3)" NAME="3">(335-358)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#3',2,'match4973-1.html#3',3)" NAME="3">(836-865)</A><TD ALIGN=center><FONT COLOR="#710000">20</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#4',2,'match4973-1.html#4',3)" NAME="4">(656-666)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#4',2,'match4973-1.html#4',3)" NAME="4">(870-882)</A><TD ALIGN=center><FONT COLOR="#660000">18</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#5',2,'match4973-1.html#5',3)" NAME="5">(609-619)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#5',2,'match4973-1.html#5',3)" NAME="5">(344-367)</A><TD ALIGN=center><FONT COLOR="#660000">18</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#6',2,'match4973-1.html#6',3)" NAME="6">(215-233)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#6',2,'match4973-1.html#6',3)" NAME="6">(1278-1303)</A><TD ALIGN=center><FONT COLOR="#660000">18</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#7',2,'match4973-1.html#7',3)" NAME="7">(669-678)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#7',2,'match4973-1.html#7',3)" NAME="7">(685-697)</A><TD ALIGN=center><FONT COLOR="#600000">17</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#8',2,'match4973-1.html#8',3)" NAME="8">(577-590)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#8',2,'match4973-1.html#8',3)" NAME="8">(1101-1118)</A><TD ALIGN=center><FONT COLOR="#600000">17</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#9',2,'match4973-1.html#9',3)" NAME="9">(470-482)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#9',2,'match4973-1.html#9',3)" NAME="9">(918-934)</A><TD ALIGN=center><FONT COLOR="#600000">17</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#10',2,'match4973-1.html#10',3)" NAME="10">(233-243)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#10',2,'match4973-1.html#10',3)" NAME="10">(174-193)</A><TD ALIGN=center><FONT COLOR="#600000">17</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#11',2,'match4973-1.html#11',3)" NAME="11">(440-450)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#11',2,'match4973-1.html#11',3)" NAME="11">(1619-1631)</A><TD ALIGN=center><FONT COLOR="#4f0000">14</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#12',2,'match4973-1.html#12',3)" NAME="12">(404-414)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#12',2,'match4973-1.html#12',3)" NAME="12">(265-278)</A><TD ALIGN=center><FONT COLOR="#4f0000">14</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#13',2,'match4973-1.html#13',3)" NAME="13">(368-378)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#13',2,'match4973-1.html#13',3)" NAME="13">(217-230)</A><TD ALIGN=center><FONT COLOR="#4f0000">14</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#14',2,'match4973-1.html#14',3)" NAME="14">(279-288)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#14',2,'match4973-1.html#14',3)" NAME="14">(1833-1849)</A><TD ALIGN=center><FONT COLOR="#4f0000">14</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#15',2,'match4973-1.html#15',3)" NAME="15">(642-654)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#15',2,'match4973-1.html#15',3)" NAME="15">(593-614)</A><TD ALIGN=center><FONT COLOR="#490000">13</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#16',2,'match4973-1.html#16',3)" NAME="16">(621-627)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#16',2,'match4973-1.html#16',3)" NAME="16">(785-799)</A><TD ALIGN=center><FONT COLOR="#490000">13</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#17',2,'match4973-1.html#17',3)" NAME="17">(548-558)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#17',2,'match4973-1.html#17',3)" NAME="17">(1432-1442)</A><TD ALIGN=center><FONT COLOR="#490000">13</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#18',2,'match4973-1.html#18',3)" NAME="18">(512-522)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#18',2,'match4973-1.html#18',3)" NAME="18">(1365-1375)</A><TD ALIGN=center><FONT COLOR="#490000">13</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#19',2,'match4973-1.html#19',3)" NAME="19">(629-637)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#19',2,'match4973-1.html#19',3)" NAME="19">(286-299)</A><TD ALIGN=center><FONT COLOR="#440000">12</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#20',2,'match4973-1.html#20',3)" NAME="20">(245-251)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#20',2,'match4973-1.html#20',3)" NAME="20">(706-721)</A><TD ALIGN=center><FONT COLOR="#440000">12</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#21',2,'match4973-1.html#21',3)" NAME="21">(689-692)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#21',2,'match4973-1.html#21',3)" NAME="21">(1140-1152)</A><TD ALIGN=center><FONT COLOR="#380000">10</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#22',2,'match4973-1.html#22',3)" NAME="22">(326-330)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#22',2,'match4973-1.html#22',3)" NAME="22">(367-372)</A><TD ALIGN=center><FONT COLOR="#380000">10</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#23',2,'match4973-1.html#23',3)" NAME="23">(289-293)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#23',2,'match4973-1.html#23',3)" NAME="23">(232-240)</A><TD ALIGN=center><FONT COLOR="#380000">10</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#24',2,'match4973-1.html#24',3)" NAME="24">(681-686)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#24',2,'match4973-1.html#24',3)" NAME="24">(392-399)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#25',2,'match4973-1.html#25',3)" NAME="25">(488-501)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#25',2,'match4973-1.html#25',3)" NAME="25">(1316-1331)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#26',2,'match4973-1.html#26',3)" NAME="26">(452-465)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#26',2,'match4973-1.html#26',3)" NAME="26">(1258-1274)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#27',2,'match4973-1.html#27',3)" NAME="27">(416-429)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#27',2,'match4973-1.html#27',3)" NAME="27">(806-823)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#28',2,'match4973-1.html#28',3)" NAME="28">(397-404)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#28',2,'match4973-1.html#28',3)" NAME="28">(389-391)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#29',2,'match4973-1.html#29',3)" NAME="29">(380-393)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#29',2,'match4973-1.html#29',3)" NAME="29">(648-660)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#ae694a"><FONT COLOR="#ae694a">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#30',2,'match4973-1.html#30',3)" NAME="30">(362-368)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#30',2,'match4973-1.html#30',3)" NAME="30">(373-388)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
<TR><TD BGCOLOR="#3ea99f"><FONT COLOR="#3ea99f">-</FONT><TD><A HREF="javascript:ZweiFrames('match4973-0.html#31',2,'match4973-1.html#31',3)" NAME="31">(198-206)<TD><A HREF="javascript:ZweiFrames('match4973-0.html#31',2,'match4973-1.html#31',3)" NAME="31">(546-557)</A><TD ALIGN=center><FONT COLOR="#330000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractTransportTestCases.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * #%L
 * AbstractTransportTestCases.java - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2015 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 * #L%
 */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4973-1.html#0',3,'match4973-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.allanbank.mongodb.client.transport;

import static com.allanbank.mongodb.bson.builder.BuilderFactory.d;
import static com.allanbank.mongodb.bson.builder.BuilderFactory.e;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.allanbank.mongodb.Durability;
import com.allanbank.mongodb.MongoClientConfiguration;
import com.allanbank.mongodb.ReadPreference;
import com.allanbank.mongodb.bson.Document;
import com.allanbank.mongodb.bson.io.BsonOutputStream;
import com.allanbank.mongodb.bson.io.EndianUtils;
import com.allanbank.mongodb.bson.io.StringDecoderCache;
import com.allanbank.mongodb.bson.io.StringEncoderCache;
import com.allanbank.mongodb.builder.Find;
import com.allanbank.mongodb.client.ClusterType;
import com.allanbank.mongodb.client.Message;
import com.allanbank.mongodb.client.MockSocketServer;
import com.allanbank.mongodb.client.Operation;
import com.allanbank.mongodb.client.message.Command;
import com.allanbank.mongodb.client.message.Delete;
import com.allanbank.mongodb.client.message.GetLastError;
import com.allanbank.mongodb.client.message.GetMore;
import com.allanbank.mongodb.client.message.Insert;
import com.allanbank.mongodb.client.message.KillCursors;
import com.allanbank.mongodb.client.message.Query;
import com.allanbank.mongodb.client.message.Reply;
import com.allanbank.mongodb.client.message.Update;
import com.allanbank.mongodb.client.state.Cluster;
import com.allanbank.mongodb.client.state.Server;
import</B></FONT> com.allanbank.mongodb.util.IOUtils;

/**
 * AbstractTransportTestCases provides tests cases for the {@link Transport}
 * implementations.
 *
 * @copyright 2015, Allanbank Consulting, Inc., All Rights Reserved
 */
public abstract class AbstractTransportTestCases {

    /** The decoder cache for the tests. */
    protected static StringDecoderCache ourDecoderCache;

    /** The encoder cache for the tests. */
    protected static StringEncoderCache ourEncoderCache;

    /** The mock server to connect to. */
    protected static MockSocketServer ourMockServer;

    /**
     * The &lt;code&gt;{ &quot;hello&quot; : &quot;world&quot; }&lt;/code&gt; document from the BSON
     * specification.
     */
    private static final byte[] ourHelloWorld = new byte[] { 0x16, 0x00, 0x00,
            0x00, 0x02, (byte) 'h', (byte) 'e', (byte) 'l', (byte) 'l',
            (byte) 'o', 0x00, 0x06, 0x00, 0x00, 0x00, (byte) 'w', (byte) 'o',
            (byte) 'r', (byte) 'l', (byte) 'd', 0x00, 0x00 };

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @BeforeClass
    public static void createCaches() {
        ourEncoderCache = new StringEncoderCache();
        ourDecoderCache = new StringDecoderCache();
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @AfterClass
    public static void destroyCaches() {
        ourEncoderCache = null;
        ourDecoderCache = null;
    }

    /**
     * Overloaded fail method to support passing the root cause of the failure.
     *
     * @param message
     *            The message for the failure.
     * @param cause
     *            The cause of the failure.
     */
    public static void fail(final String message, final Throwable cause) {
        final AssertionError error = new AssertionError(message);
        error.initCause(cause);

        throw error;
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @BeforeClass
    public static void startMockServer() {
        try {
            ourMockServer = new MockSocketServer();

            ourMockServer.start();
        }
        catch (final IOException error) {
            fail(&quot;Could not start the mock MongoDB server: &quot;
                    + error.getMessage(), error);
        }
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @AfterClass
    public static void stopMockServer() {
        IOUtils.close(ourMockServer);
        ourMockServer = null;
    }

    /** The configuration for the client. */
    protected MongoClientConfiguration myConfig = null;

    /** A test TransportResponseListener. */
    protected TestTransportResponseListener myListener = null;

    /** The server to connect to. */
    protected Server myServer = null;

    /** A test TransportResponseListener. */
    protected Transport&lt;TransportOutputBuffer&gt; myTestTransport = null;

    /**
     * Initialize the test common objects.
     */
    @Before
    public void setUp() {
        final InetSocketAddress address = ourMockServer.getInetSocketAddress();

        final Cluster cluster = new Cluster(myConfig, ClusterType.STAND_ALONE);

        myConfig = new MongoClientConfiguration(address);
        myServer = cluster.add(address);
        myListener = new TestTransportResponseListener();
    }

    /**
     * Cleans up after the test.
     */
    @After
    public void tearDown() {
        myConfig = null;
        myServer = null;

        IOUtils.close(myTestTransport);
        assertThat(myListener.getCloses().size(), is(1));

        myTestTransport = null;
        myListener = null;

        if (ourMockServer != null) {
<A NAME="31"></A>            ourMockServer.clear();
            ourMockServer.waitForDisconnect(60000);
        }
    <FONT color="#3ea99f"><A HREF="javascript:ZweiFrames('match4973-1.html#31',3,'match4973-top.html#31',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    /**
     * Test that the transport can connect to an open socket.
     */
    @Test
    public void testCanConnect() {
        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</B></FONT>(true));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     */
<A NAME="6"></A>    @Test
    public void testHandleServerDisconnect() {

        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match4973-1.html#6',3,'match4973-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is(true));

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
<A NAME="10"></A>     */
    @Test
    public void testHandleServerDisconnectAfterHeader() throws IOException {
        final ByteBuffer byteBuff = <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match4973-1.html#10',3,'match4973-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ByteBuffer.allocate(9 * 4)</B></FONT>;
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
<A NAME="20"></A>        buff.put(7, 0);
        buff.put(8, EndianUtils.swap</B></FONT>(1));

        final ByteArrayOutputStream out = <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match4973-1.html#20',3,'match4973-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ByteArrayOutputStream();
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length / 2);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</B></FONT>(true));

<A NAME="2"></A>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError(&quot;db&quot;, Durability.ACK), null);
        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match4973-1.html#2',3,'match4973-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
     */
<A NAME="14"></A>    @Test
    public void testHandleServerDisconnectInHeader() throws IOException {
        final ByteBuffer byteBuff = ByteBuffer.allocate</B></FONT>((9 * 4) - (2 * 4));
        final IntBuffer buff = <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match4973-1.html#14',3,'match4973-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
<A NAME="23"></A>        buff.put(6, 0);

        final ByteArrayOutputStream out = new</B></FONT> ByteArrayOutputStream();
        <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match4973-1.html#23',3,'match4973-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>out.write(byteBuff.array(), 0, byteBuff.array().length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</B></FONT>(true));

<A NAME="1"></A>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError(&quot;db&quot;, Durability.ACK), null);
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match4973-1.html#1',3,'match4973-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testHandleServerDisconnectInHeaderLength() throws IOException {

        final ByteBuffer byteBuff = ByteBuffer.allocate</B></FONT>(4);
        final IntBuffer buff = byteBuff.asIntBuffer();
<A NAME="22"></A>        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));

        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match4973-1.html#22',3,'match4973-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>out.write(byteBuff.array(), 0, byteBuff.array().length - 1);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</B></FONT>(true));

<A NAME="3"></A>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError(&quot;db&quot;, Durability.ACK), null);
        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match4973-1.html#3',3,'match4973-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link Command} (which is read as a {@link Query}).
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveCommand() throws IOException {
        final int messageId = 100</B></FONT>;
<A NAME="30"></A>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Command(&quot;db&quot;, &quot;collection&quot;, <FONT color="#ae694a"><A HREF="javascript:ZweiFrames('match4973-1.html#30',3,'match4973-top.html#30',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>d().build());
        outMessage.write(messageId, bsonOut);

<A NAME="13"></A>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient</B></FONT>(<FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match4973-1.html#13',3,'match4973-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<A NAME="29"></A>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <FONT color="#af7a82"><A HREF="javascript:ZweiFrames('match4973-1.html#29',3,'match4973-top.html#29',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inBuffer.read();
        assertThat(inMessage, instanceOf(Query.class));
    }

    /**
     * Test that the transport can handle sending and receiving a {@link Delete}
     * .
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveDelete() throws IOException {
        final int messageId = 100</B></FONT>;
<A NAME="28"></A>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Delete(&quot;db&quot;, &quot;collection&quot;, <FONT color="#717d7d"><A HREF="javascript:ZweiFrames('match4973-1.html#28',3,'match4973-top.html#28',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>d().build(),
                false);
        outMessage.write(messageId, bsonOut);

<A NAME="12"></A>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient</B></FONT>(<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match4973-1.html#12',3,'match4973-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<A NAME="27"></A>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <FONT color="#e77471"><A HREF="javascript:ZweiFrames('match4973-1.html#27',3,'match4973-top.html#27',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link GetMore}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveGetMore() throws IOException {
        final int messageId = 100</B></FONT>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new GetMore(&quot;db&quot;, &quot;collection&quot;, 101L, 50,
                ReadPreference.PRIMARY);
        outMessage.write(messageId, bsonOut);

<A NAME="11"></A>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match4973-1.html#11',3,'match4973-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<A NAME="26"></A>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match4973-1.html#26',3,'match4973-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving an
     * {@link Insert}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveInsert() throws IOException {
        final int messageId = 100</B></FONT>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
<A NAME="9"></A>        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Insert(&quot;db&quot;, &quot;collection&quot;,
                <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match4973-1.html#9',3,'match4973-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Arrays.asList(d().build()), false);
        outMessage.write(messageId, bsonOut);

        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush</B></FONT>();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<A NAME="25"></A>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match4973-1.html#25',3,'match4973-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link KillCursors}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveKillCursor() throws IOException {
        final int messageId = 100</B></FONT>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new KillCursors(new long[] { 1L },
                ReadPreference.PRIMARY);
        outMessage.write(messageId, bsonOut);

<A NAME="18"></A>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), <FONT color="#800517"><A HREF="javascript:ZweiFrames('match4973-1.html#18',3,'match4973-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a {@link Query}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveQuery() throws IOException {
        final int messageId = 100;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Query(&quot;db&quot;, &quot;collection&quot;, Find.ALL,
                Find.ALL, 0, 0, 1, false, ReadPreference.PRIMARY, false, false,
                false, false);
        outMessage.write(messageId, bsonOut);

<A NAME="17"></A>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match4973-1.html#17',3,'match4973-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving an
     * {@link Update}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveUpdate() throws IOException {
        final int messageId = 100;
<A NAME="8"></A>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Update(&quot;db&quot;, &quot;collection&quot;, <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match4973-1.html#8',3,'match4973-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>d().build(),
                d().build(), false, false);
        outMessage.write(messageId, bsonOut);

        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush</B></FONT>();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle a normal send/receive exchange.
     *
     * @throws IOException
     *             On a test failure.
     */
<A NAME="5"></A>    @Test
    public void testSimpleSendAndReceive() throws IOException {

        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match4973-1.html#5',3,'match4973-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final ByteBuffer byteBuff = ByteBuffer.allocate(9 * 4);
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
<A NAME="16"></A>        buff.put(7, 0);
        buff.put(8, EndianUtils.swap</B></FONT>(1));

        final ByteArrayOutputStream out = <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match4973-1.html#16',3,'match4973-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ByteArrayOutputStream();
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

<A NAME="19"></A>        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is</B></FONT>(true));

        final TransportOutputBuffer outBuffer = <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match4973-1.html#19',3,'match4973-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError(&quot;db&quot;, Durability.ACK), null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</B></FONT>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
<A NAME="15"></A>        final Message inMessage = inBuffer.read();
        assertThat(inMessage, instanceOf(Reply.class));
        assertThat(((Reply) inMessage).getResults(), hasSize(1));
        <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match4973-1.html#15',3,'match4973-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final Document reply = ((Reply) inMessage).getResults().get(0);
        assertThat(reply, is(d(e(&quot;hello&quot;, &quot;world&quot;)).build()));
    }

    /**
     * Test that the transport can handle the server responding with two
     * messages for a single send.
     *
     * @throws IOException
     *             On a test failure.
     */
<A NAME="4"></A>    @Test
    public void testSimpleSendAndReceiveTwo() throws IOException {</B></FONT>

        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match4973-1.html#4',3,'match4973-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final ByteBuffer byteBuff = ByteBuffer.allocate(9 * 4);
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
        buff.put(7, 0);
<A NAME="7"></A>        buff.put(8, EndianUtils.swap</B></FONT>(1));

        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match4973-1.html#7',3,'match4973-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

<A NAME="24"></A>        final TransportOutputBuffer outBuffer = myTestTransport</B></FONT>
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError(&quot;db&quot;, Durability.ACK), null);
        <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match4973-1.html#24',3,'match4973-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponses(2, 10, SECONDS);
<A NAME="21"></A>        assertThat(myListener.getResponses(), hasSize</B></FONT>(2));
        for (final TransportInputBuffer inBuffer : myListener.getResponses()) {
            final Message inMessage = inBuffer.read();
            <FONT color="#947010"><A HREF="javascript:ZweiFrames('match4973-1.html#21',3,'match4973-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(inMessage, instanceOf(Reply.class));
            assertThat(((Reply) inMessage).getResults(), hasSize(1));
            final Document reply = ((Reply) inMessage).getResults().get(0);
            assertThat(reply, is</B></FONT>(d(e(&quot;hello&quot;, &quot;world&quot;)).build()));
        }
    }

    /**
     * Connects to the server.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    protected void connect() {
        try {
            final TransportFactory testFactory = createFactory();
            myTestTransport = (Transport&lt;TransportOutputBuffer&gt;) testFactory
                    .createTransport(myServer, myConfig, ourEncoderCache,
                            ourDecoderCache, myListener);

            myTestTransport.start();
        }
        catch (final IOException e) {
            fail(e.getMessage(), e);
        }
    }

    /**
     * Creates the transport factory for the test.
     *
     * @return The {@link TransportFactory} for the test.
     */
    protected abstract TransportFactory createFactory();

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClientImplTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * #%L
 * ClientImplTest.java - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2014 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
<A NAME="0"></A> * #L%
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#0',2,'match4973-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.allanbank.mongodb.client;

import static com.allanbank.mongodb.client.connection.CallbackReply.reply;
import static org.easymock.EasyMock.anyObject;
import static org.easymock.EasyMock.capture;
import static org.easymock.EasyMock.createMock;
import static org.easymock.EasyMock.eq;
import static org.easymock.EasyMock.expect;
import static org.easymock.EasyMock.expectLastCall;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.allanbank.mongodb.Durability;
import com.allanbank.mongodb.MongoClientConfiguration;
import com.allanbank.mongodb.MongoCursorControl;
import com.allanbank.mongodb.MongoDbException;
import com.allanbank.mongodb.MongoIterator;
import com.allanbank.mongodb.ReadPreference;
import com.allanbank.mongodb.StreamCallback;
import com.allanbank.mongodb.bson.Document;
import com.allanbank.mongodb.bson.DocumentAssignable;
import com.allanbank.mongodb.bson.builder.BuilderFactory;
import com.allanbank.mongodb.bson.builder.DocumentBuilder;
import com.allanbank.mongodb.bson.impl.ImmutableDocument;
import com.allanbank.mongodb.client.callback.CursorStreamingCallback;
import com.allanbank.mongodb.client.callback.ReplyCallback;
import</B></FONT> com.allanbank.mongodb.client.connection.Connection;
import com.allanbank.mongodb.client.connection.MockMongoDBServer;
import com.allanbank.mongodb.client.connection.ReconnectStrategy;
import com.allanbank.mongodb.client.connection.proxy.ProxiedConnectionFactory;
import com.allanbank.mongodb.client.connection.socket.SocketConnectionFactory;
import com.allanbank.mongodb.client.message.Command;
import com.allanbank.mongodb.client.message.GetLastError;
import com.allanbank.mongodb.client.message.GetMore;
import com.allanbank.mongodb.client.message.IsMaster;
import com.allanbank.mongodb.client.message.Query;
import com.allanbank.mongodb.client.message.Update;
import com.allanbank.mongodb.client.state.Cluster;
import com.allanbank.mongodb.client.state.Server;
import com.allanbank.mongodb.client.state.ServerSelector;
import com.allanbank.mongodb.client.state.SimpleReconnectStrategy;
import com.allanbank.mongodb.error.CannotConnectException;
import com.allanbank.mongodb.error.ConnectionLostException;
import com.allanbank.mongodb.error.MongoClientClosedException;
import com.allanbank.mongodb.util.ServerNameUtils;

/**
 * ClientImplTest provides tests for the {@link ClientImpl} class.
 *
 * @copyright 2012-2014, Allanbank Consulting, Inc., All Rights Reserved
 */
@SuppressWarnings(&quot;unchecked&quot;)
public class ClientImplTest {
    /** A Mock MongoDB server to connect to. */
    private static MockMongoDBServer ourServer;

    /** Update document to mark servers as the primary. */
    private static final Document PRIMARY_UPDATE = new ImmutableDocument(
            BuilderFactory.start().add(&quot;ismaster&quot;, true));

    /**
     * Starts a Mock MongoDB server.
     *
     * @throws IOException
     *             On a failure to start the Mock MongoDB server.
     */
    @BeforeClass
    public static void setUpBeforeClass() throws IOException {
        ourServer = new MockMongoDBServer();
        ourServer.start();
    }

    /**
     * Stops a Mock MongoDB server.
     *
     * @throws IOException
     *             On a failure to stop the Mock MongoDB server.
     */
    @AfterClass
    public static void tearDownAfterClass() throws IOException {
        ourServer.setRunning(false);
        ourServer.close();
        ourServer = null;
    }

    /** The active configuration. */
    protected MongoClientConfiguration myConfig;

    /** The instance under test. */
    protected ClientImpl myTestInstance;

    /** A mock connection factory. */
    private ProxiedConnectionFactory myMockConnectionFactory;

    /**
     * Creates the base set of objects for the test.
     */
    @Before
    public void setUp() {
        myMockConnectionFactory = EasyMock
                .createMock(ProxiedConnectionFactory.class);

        myConfig = new MongoClientConfiguration();
        myTestInstance = new ClientImpl(myConfig, myMockConnectionFactory);

        reset(myMockConnectionFactory);
    }

    /**
     * Cleans up the base set of objects for the test.
     */
    @After
    public void tearDown() {
        myMockConnectionFactory = null;

        myConfig = null;
        myTestInstance = null;
        ourServer.clear();
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
<A NAME="10"></A>    public void testClose() throws IOException {

        final Command message = new Command(&quot;testDb&quot;,
                Command.COMMAND_COLLECTION, <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#10',2,'match4973-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();

        expect(mockConnection.isOpen()).andReturn</B></FONT>(false);

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on aa test failure.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
<A NAME="13"></A>    public void testCloseFails() throws IOException {

        final Command message = new Command(&quot;testDb&quot;,
                Command.COMMAND_COLLECTION, <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#13',2,'match4973-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

<A NAME="23"></A>        mockConnection.shutdown(false);
        expectLastCall</B></FONT>();

        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#23',2,'match4973-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();

        expect(mockConnection.isOpen()).andReturn(true);
        mockConnection.close();
        expectLastCall();
        mockConnection
                .removePropertyChangeListener(anyObject</B></FONT>(PropertyChangeListener.class));
        expectLastCall();

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
<A NAME="12"></A>    public void testCloseOnThrownIoException() throws IOException {

        final Command message = new Command(&quot;testDb&quot;,
                Command.COMMAND_COLLECTION, <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#12',2,'match4973-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall</B></FONT>();

        mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();
<A NAME="19"></A>
        expect(mockConnection.isOpen()).andReturn(true);
        mockConnection.close();
        <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#19',2,'match4973-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expectLastCall().andThrow(new IOException(&quot;This is a test.&quot;));
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify</B></FONT>(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()} then throws an exception in a
     * send.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testCloseThenThrows() throws IOException {

        final Command message = new Command(&quot;testDb&quot;,
                Command.COMMAND_COLLECTION, BuilderFactory.start().build());

        myTestInstance.close();
        try {
            myTestInstance.send(message, null);
            fail(&quot;Should have thrown a MongoClientClosedException.&quot;);
        }
        catch (final MongoClientClosedException mcce) {
            // Good.
        }
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testCreatesConnectionOnScannedPending() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(7);

        final Connection mockConnection1 = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
<A NAME="5"></A>        final Connection mockConnection3 = createMock(Connection.class);
        final Connection mockConnection4 = createMock(Connection.class);
        final Connection mockConnection5 = createMock(Connection.class);
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#5',2,'match4973-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Connection mockConnection6 = createMock(Connection.class);
        final Connection mockConnection7 = createMock(Connection.class);

        // First request - start at sequence zero.
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection1);
        mockConnection1
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection1.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
<A NAME="22"></A>                mockConnection7);

        // Second request - Still at sequence zero.
        expect</B></FONT>(<FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#22',2,'match4973-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
<A NAME="30"></A>        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall</B></FONT>();
        <FONT color="#ae694a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#30',2,'match4973-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
<A NAME="28"></A>
        // Third Request - Still at sequence zero.
        expect(mockConnection1.isAvailable</B></FONT>()).andReturn(true);
<A NAME="24"></A>        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#28',2,'match4973-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount</B></FONT>()).andReturn(1);
        <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#24',2,'match4973-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expect(myMockConnectionFactory.connect()).andReturn(mockConnection3);
        mockConnection3
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection3.send(message, null);
        expectLastCall();

        replay</B></FONT>(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection4);
        mockConnection4
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection4.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection5);
        mockConnection5
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection5.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection6);
        mockConnection6
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection6.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection7);
        mockConnection7
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection7.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Second for most idle.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(3);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fifth Request - Now at sequence one.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection3.isAvailable()).andReturn(true);
        expect(mockConnection3.getPendingCount()).andReturn(1);
        // Second for most idle.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection3.isAvailable()).andReturn(true);
        expect(mockConnection3.getPendingCount()).andReturn(3);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
<A NAME="31"></A>        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
    <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#31',2,'match4973-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Test method for {@link ClientImpl#getClusterType()}.
     */
    @Test
    public void testGetClusterType() {

        expect(myMockConnectionFactory.getClusterType()).andReturn(
                ClusterType.STAND_ALONE);

        replay</B></FONT>();

        assertEquals(ClusterType.STAND_ALONE, myTestInstance.getClusterType());

        verify();
    }

    /**
     * Test method for {@link ClientImpl#getConfig()}.
     */
    @Test
    public void testGetConfig() {
        assertSame(myConfig, myTestInstance.getConfig());
    }

    /**
     * Test method for {@link ClientImpl#getDefaultDurability()}.
     */
    @Test
    public void testGetDefaultDurability() {
        assertSame(myConfig.getDefaultDurability(),
                myTestInstance.getDefaultDurability());
        myConfig.setDefaultDurability(Durability.journalDurable(1000));
        assertSame(myConfig.getDefaultDurability(),
                myTestInstance.getDefaultDurability());
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
<A NAME="15"></A>    @Test
    public void testHandleConnectionClosedForUnknownConnection()
            throws IOException {
        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#15',2,'match4973-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Connection mockConnection = createMock(Connection.class);

        // Response to the handleConnextionClosed.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection);

        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection);
    }

    /**
     * Test method for reconnect logic.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testInvalidPrpertyChange() throws IOException {</B></FONT>
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        final Capture&lt;PropertyChangeListener&gt; propListenerCapture = new Capture&lt;PropertyChangeListener&gt;();
        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection.addPropertyChangeListener(capture(propListenerCapture));
        expectLastCall();

        // First send to create the connection.
        mockConnection.send(message, null);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);

        propListenerCapture.getValue().propertyChange(
                new PropertyChangeEvent(mockConnection,
                        Connection.OPEN_PROP_NAME + &quot;g&quot;, Boolean.TRUE,
                        Boolean.FALSE));
        propListenerCapture.getValue()
                .propertyChange(
                        new PropertyChangeEvent(mockConnection,
                                Connection.OPEN_PROP_NAME, Boolean.FALSE,
                                Boolean.TRUE));
        propListenerCapture.getValue().propertyChange(
                new PropertyChangeEvent(mockConnection,
                        Connection.OPEN_PROP_NAME, Boolean.TRUE, Integer
<A NAME="29"></A>                                .valueOf(1)));

        // Verify that the connection is not removed.
        <FONT color="#af7a82"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#29',2,'match4973-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(1, myTestInstance.getConnectionCount());

        verify(mockConnection);

    }

    /**
     * Test method for reconnect logic.
     */
    @Test
    public void testReconnect() {

        final String serverName = ourServer.getInetSocketAddress()</B></FONT>
                .getHostName()
                + &quot;:&quot;
                + ourServer.getInetSocketAddress().getPort();

        ourServer.setReplies(
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
<A NAME="7"></A>                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#7',2,'match4973-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString(&quot;_id&quot;,
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString(&quot;_id&quot;, &quot;localhost:1234&quot;)));

        final GetLastError message = new GetLastError(&quot;testDb&quot;, Durability.ACK)</B></FONT>;
        final MongoClientConfiguration config = new MongoClientConfiguration(
                &quot;mongodb://&quot;
                        + ServerNameUtils.normalize(ourServer
                                .getInetSocketAddress()));
        config.setAutoDiscoverServers(false);
<A NAME="20"></A>
        try {
            myTestInstance = new ClientImpl(config,
                    <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#20',2,'match4973-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new SocketConnectionFactory(config));

            myTestInstance.send(message, null);
            ourServer.waitForRequest(2, 10000);

            ourServer.disconnectClient();
            assertTrue(ourServer.waitForDisconnect(10000));

            assertTrue(ourServer.waitForClient(10000));
            ourServer.waitForRequest(2, 10000); // ping.

            // Give a pause for the reconnect to finish on our side.
            Thread.sleep(50);

            myTestInstance.send(message, null);
            ourServer.waitForRequest</B></FONT>(3, 10000);
        }
        catch (final InterruptedException e) {
            // Ignore.
        }
        finally {
            myTestInstance.close();
        }

    }

    /**
     * Test method for reconnect logic.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testReconnectFails() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
        final Cluster cluster = new Cluster(myConfig, ClusterType.STAND_ALONE);
        final Server server = cluster.add(new InetSocketAddress(&quot;localhost&quot;,
                27017));
        final Capture&lt;PropertyChangeListener&gt; propListenerCapture = new Capture&lt;PropertyChangeListener&gt;();
        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection.addPropertyChangeListener(capture(propListenerCapture));
        expectLastCall();

        // First send to create the connection.
        mockConnection.send(message, null);
        expectLastCall();

        // We trigger the connection failure.
        final SimpleReconnectStrategy strategy = new SimpleReconnectStrategy();
        strategy.setConfig(myConfig);
        strategy.setSelector(new ServerSelector() {
            @Override
            public List&lt;Server&gt; pickServers() {
                return Collections.singletonList(server);
            }
        });
        strategy.setConnectionFactory(myMockConnectionFactory);
        strategy.setState(cluster);

        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                strategy);

        // Try the straight connect back - but fail to connect.
        expect(mockConnection.getServer()).andReturn(server);
        expect(myMockConnectionFactory.connect(server, myConfig)).andThrow(
                new IOException(&quot;Injected&quot;));

        // Create a new connection for the reconnect.
        expect(myMockConnectionFactory.connect(server, myConfig)).andReturn(
                mockConnection2);

<A NAME="16"></A>        // The ping! -- Fail.
        mockConnection2
                .send(eq(new IsMaster()), anyObject(ReplyCallback.class));
        expectLastCall().andThrow(<FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#16',2,'match4973-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new MongoDbException(&quot;synthetic ping error&quot;));
        mockConnection2.close();
        expectLastCall();

        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        propListenerCapture.getValue</B></FONT>()
                .propertyChange(
                        new PropertyChangeEvent(mockConnection,
                                Connection.OPEN_PROP_NAME, Boolean.TRUE,
<A NAME="27"></A>                                Boolean.FALSE));

        // Verify that the connection is removed.
        <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#27',2,'match4973-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(0, myTestInstance.getConnectionCount());

        verify(mockConnection, mockConnection2);

    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @Test
    public void testReconnectOnShutdownConnection() throws IOException,
            InterruptedException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,</B></FONT>
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final ReconnectStrategy mockStrategy = createMock(ReconnectStrategy.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
<A NAME="3"></A>                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#3',2,'match4973-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(true);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();

        replay(mockConnection, mockStrategy);

        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockStrategy);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @Test
    public void testReconnectThatFails() throws IOException,
            InterruptedException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,</B></FONT>
                BuilderFactory.start().build());
<A NAME="4"></A>
        myConfig.setMaxConnectionCount(1);

        <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#4',2,'match4973-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Connection mockConnection = createMock(Connection.class);
        final ReconnectStrategy mockStrategy = createMock(ReconnectStrategy.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy</B></FONT>()).andReturn(
                mockStrategy);
        expect(mockStrategy.reconnect(mockConnection)).andReturn(null);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();

        replay(mockConnection, mockStrategy);

        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockStrategy);
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testRestartDocumentAssignable() throws IOException {

        final DocumentBuilder b = BuilderFactory.start();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);
<A NAME="9"></A>
        final GetMore message = new GetMore(&quot;a&quot;, &quot;b&quot;, 123456, 23,
                ReadPreference.server(&quot;server&quot;));
        final Connection mockConnection = <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#9',2,'match4973-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(eq(message), anyObject(ReplyCallback.class));
        expectLastCall();

        replay(mockConnection);

        final MongoIterator&lt;Document&gt; iter = myTestInstance.restart(b);

        verify(mockConnection);

        assertThat(iter, instanceOf</B></FONT>(MongoIteratorImpl.class));
<A NAME="2"></A>        final MongoIteratorImpl iterImpl = (MongoIteratorImpl) iter;
        assertThat(iterImpl.getBatchSize(), is(23));
        assertThat(iterImpl.getLimit(), is(4321));
        assertThat(iterImpl.getCursorId(), <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#2',2,'match4973-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>is(123456L));
        assertThat(iterImpl.getDatabaseName(), is(&quot;a&quot;));
        assertThat(iterImpl.getCollectionName(), is(&quot;b&quot;));
        assertThat(iterImpl.getClient(), is((Client) myTestInstance));
        assertThat(iterImpl.getReadPerference(),
                is(ReadPreference.server(&quot;server&quot;)));
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testRestartDocumentAssignableNonCursorDoc() throws IOException {

        final DocumentBuilder b = BuilderFactory.start</B></FONT>();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        replay();

        // Missing fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);

        // Too few fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        // Wrong Field type.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);

        verify();

    }

    /**
     * Test method for
     * {@link ClientImpl#restart(StreamCallback, DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testRestartStreamCallbackDocumentAssignable()
            throws IOException {

        final DocumentBuilder b = BuilderFactory.start();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

<A NAME="8"></A>        final GetMore message = new GetMore(&quot;a&quot;, &quot;b&quot;, 123456, 23,
                ReadPreference.server(&quot;server&quot;));
        final StreamCallback&lt;Document&gt; mockStreamCallback = createMock(StreamCallback.class);
        final Connection mockConnection = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#8',2,'match4973-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(eq(message), anyObject(ReplyCallback.class));
        expectLastCall();

        replay(mockConnection, mockStreamCallback);

        final MongoCursorControl iter = myTestInstance.restart(
                mockStreamCallback, b);

        verify(mockConnection, mockStreamCallback);

        assertThat(iter, instanceOf</B></FONT>(CursorStreamingCallback.class));
<A NAME="1"></A>        final CursorStreamingCallback iterImpl = (CursorStreamingCallback) iter;
        assertThat(iterImpl.getBatchSize(), is(23));
        assertThat(iterImpl.getLimit(), is(4321));
        assertThat(<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#1',2,'match4973-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>iterImpl.getCursorId(), is(123456L));
        assertThat(iterImpl.getDatabaseName(), is(&quot;a&quot;));
        assertThat(iterImpl.getCollectionName(), is(&quot;b&quot;));
        assertThat(iterImpl.getClient(), is((Client) myTestInstance));
        assertThat(iterImpl.getAddress(), is(&quot;server&quot;));
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testRestartStreamCallbackDocumentAssignableNonCursorDoc()
<A NAME="21"></A>            throws IOException {

        final DocumentBuilder b = BuilderFactory.start</B></FONT>();
        <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#21',2,'match4973-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        final StreamCallback&lt;Document&gt; mockStreamCallback = createMock(StreamCallback.class);

        replay(mockStreamCallback);

        // Missing fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add</B></FONT>(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(&quot;c&quot;, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(&quot;c&quot;);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);

        // Too few fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        // Wrong Field type.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, &quot;server&quot;);

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, &quot;s&quot;);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
<A NAME="26"></A>        }
        catch (final IllegalArgumentException good) { // Good.
        }
        <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#26',2,'match4973-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, &quot;a.b&quot;);

        verify(mockStreamCallback);

    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendGetMoreCallbackOfReply() throws IOException {

        final ReplyCallback callback = createMock(ReplyCallback.class)</B></FONT>;
<A NAME="6"></A>        final GetMore message = new GetMore(&quot;testDb&quot;, &quot;collection&quot;, 1234L,
                12345, ReadPreference.PRIMARY);

        final Connection mockConnection = <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#6',2,'match4973-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, callback);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessage() throws IOException {
        final Update message = new Update(&quot;testDb&quot;, &quot;collection&quot;, null, null,</B></FONT>
                false, false);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

<A NAME="25"></A>        mockConnection.send(message, null);
        expectLastCall();

        <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#25',2,'match4973-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>replay(mockConnection);

        myTestInstance.send(message, null);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessageAndCreateConnectionFailes() throws IOException {
        final Update message = new Update(&quot;testDb&quot;, &quot;collection&quot;, null, null,</B></FONT>
                false, false);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andThrow(new IOException());

        replay(mockConnection);

        try {
            myTestInstance.send(message, null);
            fail(&quot;Should have thrown a MongoDbException.&quot;);
        }
        catch (final MongoDbException good) {
            // good.
        }

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageClosesFirstWhenMaxShrinks() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
<A NAME="18"></A>
        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#18',2,'match4973-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect</B></FONT>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        mockConnection2.send(message, null);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        mockConnection2.send(message, null);
        expectLastCall();

        // Response to the handleConnextionClosed.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myConfig.setMaxConnectionCount(2);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myConfig.setMaxConnectionCount(1);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageClosesFirstWhenMaxShrinksAndCloseFails()
            throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
<A NAME="17"></A>
        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#17',2,'match4973-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect</B></FONT>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(0);
        mockConnection2.send(message, null);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        // expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myConfig.setMaxConnectionCount(2);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myConfig.setMaxConnectionCount(1);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageCreatesSecondConnectionOnPending()
            throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageFailsWhenAllAreClosed() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        // First pass for idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Now most idle.
        expect(mockConnection.isAvailable()).andReturn(false);
        expect(mockConnection2.isAvailable()).andReturn(false);

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        try {
            myTestInstance.send(message, null);
            fail(&quot;Should have failed.&quot;);
        }
        catch (final CannotConnectException failure) {
            assertThat(
                    failure.getMessage(),
                    containsString(&quot;Could not create a connection to the server.&quot;));
        }
        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessageGetLastErrorCallbackOfReply() throws IOException {
        final Message message = new Update(&quot;testDb&quot;, &quot;collection&quot;, null, null,
                false, false);
        final GetLastError lastError = new GetLastError(&quot;testDb&quot;, false, false,
                0, 0);
        final ReplyCallback callback = createMock(ReplyCallback.class);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, lastError, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, lastError, callback);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
<A NAME="11"></A>    @Test
    public void testSendMessagePicksIdleExisting() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#11',2,'match4973-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        expect</B></FONT>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(0);
        mockConnection.send(message, null);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessagePicksMostIdleWhenAllPending() throws IOException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        // First pass for idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Now most idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageWaitsForReconnect() throws IOException,
            InterruptedException {
        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
        makeThreadSafe(mockConnection, mockConnection2);

        final ReconnectStrategy pauseStrategy = new SimpleReconnectStrategy() {
            @Override
            public Connection reconnect(final Connection oldConnection) {
                try {
                    Thread.sleep(500);
                }
                catch (final InterruptedException e) {
                    // Ignore.
                }
                return mockConnection2;
            }
        };

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                pauseStrategy);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(ConnectionLostException.class));
        expectLastCall();

        // Second message.
        expect(mockConnection.isAvailable()).andReturn(false).times(2);

        // Wait for the reconnect.

        // After reconnect.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(0);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        new Thread(new Runnable() {
            @Override
            public void run() {
                myTestInstance.handleConnectionClosed(mockConnection);
            }
        }).start();
        Thread.sleep(100);

        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @SuppressWarnings(&quot;boxing&quot;)
    @Test
    public void testSendMessageWaitsForReconnectTimesOut() throws IOException,
            InterruptedException {

        myConfig.setReconnectTimeout(250);

        final Message message = new Command(&quot;db&quot;, Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
        makeThreadSafe(mockConnection, mockConnection2);

        final ReconnectStrategy pauseStrategy = new SimpleReconnectStrategy() {
            @Override
            public Connection reconnect(final Connection oldConnection) {
                try {
                    Thread.sleep(500);
                }
                catch (final InterruptedException e) {
                    // Ignore.
                }
                return mockConnection2;
            }
        };

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
<A NAME="14"></A>        expectLastCall();
        expect(mockConnection.isShuttingDown()).andReturn(false);

        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4973-0.html#14',2,'match4973-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                pauseStrategy);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        // Second message.
        // Wait for the reconnect.

        // After reconnect timeout.
        expect(mockConnection.isAvailable()).andReturn(false).times(2, 4);

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        final Thread t = new</B></FONT> Thread(new Runnable() {
            @Override
            public void run() {
                myTestInstance.handleConnectionClosed(mockConnection);
            }
        });
        t.start();

        Thread.sleep(100);

        try {
            myTestInstance.send(message, null);
        }
        catch (final CannotConnectException failure) {
            assertThat(
                    failure.getMessage(),
                    containsString(&quot;Could not create a connection to the server.&quot;));

        }

        t.join();

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendQueryCallbackOfReply() throws IOException {
        final Query message = new Query(&quot;db&quot;, &quot;coll&quot;, null, null, 0, 0, 0,
                false, ReadPreference.PRIMARY, false, false, false, false);
        final ReplyCallback callback = createMock(ReplyCallback.class);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, callback);

        verify(mockConnection);
    }

    /**
     * Performs a {@link EasyMock#makeThreadSafe(Object, boolean)} on the
     * provided mocks and the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void makeThreadSafe(final Object... mocks) {
        for (final Object mock : mocks) {
            EasyMock.makeThreadSafe(mock, true);
        }
        EasyMock.makeThreadSafe(myMockConnectionFactory, true);
    }

    /**
     * Performs a {@link EasyMock#replay(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void replay(final Object... mocks) {
        EasyMock.replay(mocks);
        EasyMock.replay(myMockConnectionFactory);
    }

    /**
     * Performs a {@link EasyMock#reset(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void reset(final Object... mocks) {
        EasyMock.reset(mocks);
        EasyMock.reset(myMockConnectionFactory);
    }

    /**
     * Performs a {@link EasyMock#verify(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void verify(final Object... mocks) {
        EasyMock.verify(mocks);
        EasyMock.verify(myMockConnectionFactory);
    }
}
</PRE>
</div>
  </div>
</body>
</html>
