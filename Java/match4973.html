<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for AbstractTransportTestCases.java &amp; ClientImplTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractTransportTestCases.java &amp; ClientImplTest.java
      </h3>
<h1 align="center">
        34.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractTransportTestCases.java (59.819122%)<th>ClientImplTest.java (24.139729%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-68)<td><a href="#" name="0">(21-69)</a><td align="center"><font color="#ff0000">45</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(298-321)<td><a href="#" name="1">(1122-1139)</a><td align="center"><font color="#770000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(256-278)<td><a href="#" name="2">(938-955)</a><td align="center"><font color="#770000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(335-358)<td><a href="#" name="3">(836-865)</a><td align="center"><font color="#710000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(656-666)<td><a href="#" name="4">(870-882)</a><td align="center"><font color="#660000">18</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(609-619)<td><a href="#" name="5">(344-367)</a><td align="center"><font color="#660000">18</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(215-233)<td><a href="#" name="6">(1278-1303)</a><td align="center"><font color="#660000">18</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(669-678)<td><a href="#" name="7">(685-697)</a><td align="center"><font color="#600000">17</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(577-590)<td><a href="#" name="8">(1101-1118)</a><td align="center"><font color="#600000">17</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(470-482)<td><a href="#" name="9">(918-934)</a><td align="center"><font color="#600000">17</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(233-243)<td><a href="#" name="10">(174-193)</a><td align="center"><font color="#600000">17</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(440-450)<td><a href="#" name="11">(1619-1631)</a><td align="center"><font color="#4f0000">14</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(404-414)<td><a href="#" name="12">(265-278)</a><td align="center"><font color="#4f0000">14</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(368-378)<td><a href="#" name="13">(217-230)</a><td align="center"><font color="#4f0000">14</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(279-288)<td><a href="#" name="14">(1833-1849)</a><td align="center"><font color="#4f0000">14</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(642-654)<td><a href="#" name="15">(593-614)</a><td align="center"><font color="#490000">13</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(621-627)<td><a href="#" name="16">(785-799)</a><td align="center"><font color="#490000">13</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(548-558)<td><a href="#" name="17">(1432-1442)</a><td align="center"><font color="#490000">13</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(512-522)<td><a href="#" name="18">(1365-1375)</a><td align="center"><font color="#490000">13</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(629-637)<td><a href="#" name="19">(286-299)</a><td align="center"><font color="#440000">12</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(245-251)<td><a href="#" name="20">(706-721)</a><td align="center"><font color="#440000">12</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(689-692)<td><a href="#" name="21">(1140-1152)</a><td align="center"><font color="#380000">10</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(326-330)<td><a href="#" name="22">(367-372)</a><td align="center"><font color="#380000">10</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(289-293)<td><a href="#" name="23">(232-240)</a><td align="center"><font color="#380000">10</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(681-686)<td><a href="#" name="24">(392-399)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(488-501)<td><a href="#" name="25">(1316-1331)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(452-465)<td><a href="#" name="26">(1258-1274)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(416-429)<td><a href="#" name="27">(806-823)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(397-404)<td><a href="#" name="28">(389-391)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(380-393)<td><a href="#" name="29">(648-660)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(362-368)<td><a href="#" name="30">(373-388)</a><td align="center"><font color="#330000">9</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(198-206)<td><a href="#" name="31">(546-557)</a><td align="center"><font color="#330000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractTransportTestCases.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * #%L
 * AbstractTransportTestCases.java - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2015 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<a name="0"></a> * limitations under the License.
 * #L%
 */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.allanbank.mongodb.client.transport;

import static com.allanbank.mongodb.bson.builder.BuilderFactory.d;
import static com.allanbank.mongodb.bson.builder.BuilderFactory.e;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.allanbank.mongodb.Durability;
import com.allanbank.mongodb.MongoClientConfiguration;
import com.allanbank.mongodb.ReadPreference;
import com.allanbank.mongodb.bson.Document;
import com.allanbank.mongodb.bson.io.BsonOutputStream;
import com.allanbank.mongodb.bson.io.EndianUtils;
import com.allanbank.mongodb.bson.io.StringDecoderCache;
import com.allanbank.mongodb.bson.io.StringEncoderCache;
import com.allanbank.mongodb.builder.Find;
import com.allanbank.mongodb.client.ClusterType;
import com.allanbank.mongodb.client.Message;
import com.allanbank.mongodb.client.MockSocketServer;
import com.allanbank.mongodb.client.Operation;
import com.allanbank.mongodb.client.message.Command;
import com.allanbank.mongodb.client.message.Delete;
import com.allanbank.mongodb.client.message.GetLastError;
import com.allanbank.mongodb.client.message.GetMore;
import com.allanbank.mongodb.client.message.Insert;
import com.allanbank.mongodb.client.message.KillCursors;
import com.allanbank.mongodb.client.message.Query;
import com.allanbank.mongodb.client.message.Reply;
import com.allanbank.mongodb.client.message.Update;
import com.allanbank.mongodb.client.state.Cluster;
import com.allanbank.mongodb.client.state.Server;
import</b></font> com.allanbank.mongodb.util.IOUtils;

/**
 * AbstractTransportTestCases provides tests cases for the {@link Transport}
 * implementations.
 *
 * @copyright 2015, Allanbank Consulting, Inc., All Rights Reserved
 */
public abstract class AbstractTransportTestCases {

    /** The decoder cache for the tests. */
    protected static StringDecoderCache ourDecoderCache;

    /** The encoder cache for the tests. */
    protected static StringEncoderCache ourEncoderCache;

    /** The mock server to connect to. */
    protected static MockSocketServer ourMockServer;

    /**
     * The &lt;code&gt;{ "hello" : "world" }&lt;/code&gt; document from the BSON
     * specification.
     */
    private static final byte[] ourHelloWorld = new byte[] { 0x16, 0x00, 0x00,
            0x00, 0x02, (byte) 'h', (byte) 'e', (byte) 'l', (byte) 'l',
            (byte) 'o', 0x00, 0x06, 0x00, 0x00, 0x00, (byte) 'w', (byte) 'o',
            (byte) 'r', (byte) 'l', (byte) 'd', 0x00, 0x00 };

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @BeforeClass
    public static void createCaches() {
        ourEncoderCache = new StringEncoderCache();
        ourDecoderCache = new StringDecoderCache();
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @AfterClass
    public static void destroyCaches() {
        ourEncoderCache = null;
        ourDecoderCache = null;
    }

    /**
     * Overloaded fail method to support passing the root cause of the failure.
     *
     * @param message
     *            The message for the failure.
     * @param cause
     *            The cause of the failure.
     */
    public static void fail(final String message, final Throwable cause) {
        final AssertionError error = new AssertionError(message);
        error.initCause(cause);

        throw error;
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @BeforeClass
    public static void startMockServer() {
        try {
            ourMockServer = new MockSocketServer();

            ourMockServer.start();
        }
        catch (final IOException error) {
            fail("Could not start the mock MongoDB server: "
                    + error.getMessage(), error);
        }
    }

    /**
     * Creates the encoder and decoder caches for the tests.
     */
    @AfterClass
    public static void stopMockServer() {
        IOUtils.close(ourMockServer);
        ourMockServer = null;
    }

    /** The configuration for the client. */
    protected MongoClientConfiguration myConfig = null;

    /** A test TransportResponseListener. */
    protected TestTransportResponseListener myListener = null;

    /** The server to connect to. */
    protected Server myServer = null;

    /** A test TransportResponseListener. */
    protected Transport&lt;TransportOutputBuffer&gt; myTestTransport = null;

    /**
     * Initialize the test common objects.
     */
    @Before
    public void setUp() {
        final InetSocketAddress address = ourMockServer.getInetSocketAddress();

        final Cluster cluster = new Cluster(myConfig, ClusterType.STAND_ALONE);

        myConfig = new MongoClientConfiguration(address);
        myServer = cluster.add(address);
        myListener = new TestTransportResponseListener();
    }

    /**
     * Cleans up after the test.
     */
    @After
    public void tearDown() {
        myConfig = null;
        myServer = null;

        IOUtils.close(myTestTransport);
        assertThat(myListener.getCloses().size(), is(1));

        myTestTransport = null;
        myListener = null;

        if (ourMockServer != null) {
<a name="31"></a>            ourMockServer.clear();
            ourMockServer.waitForDisconnect(60000);
        }
    <font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    /**
     * Test that the transport can connect to an open socket.
     */
    @Test
    public void testCanConnect() {
        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</b></font>(true));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     */
<a name="6"></a>    @Test
    public void testHandleServerDisconnect() {

        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is(true));

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
<a name="10"></a>     */
    @Test
    public void testHandleServerDisconnectAfterHeader() throws IOException {
        final ByteBuffer byteBuff = <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ByteBuffer.allocate(9 * 4)</b></font>;
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
<a name="20"></a>        buff.put(7, 0);
        buff.put(8, EndianUtils.swap</b></font>(1));

        final ByteArrayOutputStream out = <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ByteArrayOutputStream();
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length / 2);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</b></font>(true));

<a name="2"></a>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError("db", Durability.ACK), null);
        <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
     */
<a name="14"></a>    @Test
    public void testHandleServerDisconnectInHeader() throws IOException {
        final ByteBuffer byteBuff = ByteBuffer.allocate</b></font>((9 * 4) - (2 * 4));
        final IntBuffer buff = <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
<a name="23"></a>        buff.put(6, 0);

        final ByteArrayOutputStream out = new</b></font> ByteArrayOutputStream();
        <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>out.write(byteBuff.array(), 0, byteBuff.array().length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</b></font>(true));

<a name="1"></a>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError("db", Durability.ACK), null);
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle the server disconnecting.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testHandleServerDisconnectInHeaderLength() throws IOException {

        final ByteBuffer byteBuff = ByteBuffer.allocate</b></font>(4);
        final IntBuffer buff = byteBuff.asIntBuffer();
<a name="22"></a>        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));

        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>out.write(byteBuff.array(), 0, byteBuff.array().length - 1);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(10, SECONDS), is</b></font>(true));

<a name="3"></a>        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError("db", Durability.ACK), null);
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        // The message is incomplete so should not get here.
        myListener.waitForResponse(50, MILLISECONDS);

        ourMockServer.disconnectClient();
        assertThat(ourMockServer.waitForDisconnect(10, SECONDS), is(true));

        myListener.waitForClose(10, SECONDS);
        assertThat(myListener.getCloses(), hasSize(1));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link Command} (which is read as a {@link Query}).
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveCommand() throws IOException {
        final int messageId = 100</b></font>;
<a name="30"></a>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Command("db", "collection", <font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>d().build());
        outMessage.write(messageId, bsonOut);

<a name="13"></a>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient</b></font>(<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<a name="29"></a>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inBuffer.read();
        assertThat(inMessage, instanceOf(Query.class));
    }

    /**
     * Test that the transport can handle sending and receiving a {@link Delete}
     * .
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveDelete() throws IOException {
        final int messageId = 100</b></font>;
<a name="28"></a>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Delete("db", "collection", <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>d().build(),
                false);
        outMessage.write(messageId, bsonOut);

<a name="12"></a>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient</b></font>(<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<a name="27"></a>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link GetMore}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveGetMore() throws IOException {
        final int messageId = 100</b></font>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new GetMore("db", "collection", 101L, 50,
                ReadPreference.PRIMARY);
        outMessage.write(messageId, bsonOut);

<a name="11"></a>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<a name="26"></a>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving an
     * {@link Insert}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveInsert() throws IOException {
        final int messageId = 100</b></font>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
<a name="9"></a>        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Insert("db", "collection",
                <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Arrays.asList(d().build()), false);
        outMessage.write(messageId, bsonOut);

        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush</b></font>();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

<a name="25"></a>        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a
     * {@link KillCursors}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveKillCursor() throws IOException {
        final int messageId = 100</b></font>;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new KillCursors(new long[] { 1L },
                ReadPreference.PRIMARY);
        outMessage.write(messageId, bsonOut);

<a name="18"></a>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving a {@link Query}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveQuery() throws IOException {
        final int messageId = 100;
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Query("db", "collection", Find.ALL,
                Find.ALL, 0, 0, 1, false, ReadPreference.PRIMARY, false, false,
                false, false);
        outMessage.write(messageId, bsonOut);

<a name="17"></a>        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle sending and receiving an
     * {@link Update}.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testSendAndReceiveUpdate() throws IOException {
        final int messageId = 100;
<a name="8"></a>        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final BsonOutputStream bsonOut = new BsonOutputStream(out);

        final Message outMessage = new Update("db", "collection", <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>d().build(),
                d().build(), false, false);
        outMessage.write(messageId, bsonOut);

        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

        final TransportOutputBuffer outBuffer = myTestTransport
                .createSendBuffer(0);
        outBuffer.write(messageId, outMessage, null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush</b></font>();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
        final Message inMessage = inBuffer.read();
        assertThat(inMessage, is(outMessage));
    }

    /**
     * Test that the transport can handle a normal send/receive exchange.
     *
     * @throws IOException
     *             On a test failure.
     */
<a name="5"></a>    @Test
    public void testSimpleSendAndReceive() throws IOException {

        <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final ByteBuffer byteBuff = ByteBuffer.allocate(9 * 4);
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
<a name="16"></a>        buff.put(7, 0);
        buff.put(8, EndianUtils.swap</b></font>(1));

        final ByteArrayOutputStream out = <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ByteArrayOutputStream();
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

<a name="19"></a>        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is</b></font>(true));

        final TransportOutputBuffer outBuffer = <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>myTestTransport
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError("db", Durability.ACK), null);
        myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponse(10, SECONDS);
        assertThat(myListener.getResponses(), hasSize</b></font>(1));
        final TransportInputBuffer inBuffer = myListener.getResponses().get(0);
<a name="15"></a>        final Message inMessage = inBuffer.read();
        assertThat(inMessage, instanceOf(Reply.class));
        assertThat(((Reply) inMessage).getResults(), hasSize(1));
        <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final Document reply = ((Reply) inMessage).getResults().get(0);
        assertThat(reply, is(d(e("hello", "world")).build()));
    }

    /**
     * Test that the transport can handle the server responding with two
     * messages for a single send.
     *
     * @throws IOException
     *             On a test failure.
     */
<a name="4"></a>    @Test
    public void testSimpleSendAndReceiveTwo() throws IOException {</b></font>

        <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final ByteBuffer byteBuff = ByteBuffer.allocate(9 * 4);
        final IntBuffer buff = byteBuff.asIntBuffer();
        buff.put(0, EndianUtils.swap((7 * 4) + 8 + ourHelloWorld.length));
        buff.put(1, 0);
        buff.put(2, EndianUtils.swap(1));
        buff.put(3, EndianUtils.swap(Operation.REPLY.getCode()));
        buff.put(4, 0);
        buff.put(5, 0);
        buff.put(6, 0);
        buff.put(7, 0);
<a name="7"></a>        buff.put(8, EndianUtils.swap</b></font>(1));

        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        out.write(byteBuff.array(), 0, byteBuff.array().length);
        out.write(ourHelloWorld, 0, ourHelloWorld.length);
        ourMockServer.setReplies(Arrays.asList(out.toByteArray()));

        connect();
        assertThat(ourMockServer.waitForClient(SECONDS.toMillis(5)), is(true));

<a name="24"></a>        final TransportOutputBuffer outBuffer = myTestTransport</b></font>
                .createSendBuffer(0);
        outBuffer.write(1, new GetLastError("db", Durability.ACK), null);
        <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>myTestTransport.send(outBuffer);
        myTestTransport.flush();
        assertThat(ourMockServer.waitForRequest(1, 10, SECONDS), is(true));

        myListener.waitForResponses(2, 10, SECONDS);
<a name="21"></a>        assertThat(myListener.getResponses(), hasSize</b></font>(2));
        for (final TransportInputBuffer inBuffer : myListener.getResponses()) {
            final Message inMessage = inBuffer.read();
            <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(inMessage, instanceOf(Reply.class));
            assertThat(((Reply) inMessage).getResults(), hasSize(1));
            final Document reply = ((Reply) inMessage).getResults().get(0);
            assertThat(reply, is</b></font>(d(e("hello", "world")).build()));
        }
    }

    /**
     * Connects to the server.
     */
    @SuppressWarnings("unchecked")
    protected void connect() {
        try {
            final TransportFactory testFactory = createFactory();
            myTestTransport = (Transport&lt;TransportOutputBuffer&gt;) testFactory
                    .createTransport(myServer, myConfig, ourEncoderCache,
                            ourDecoderCache, myListener);

            myTestTransport.start();
        }
        catch (final IOException e) {
            fail(e.getMessage(), e);
        }
    }

    /**
     * Creates the transport factory for the test.
     *
     * @return The {@link TransportFactory} for the test.
     */
    protected abstract TransportFactory createFactory();

}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClientImplTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * #%L
 * ClientImplTest.java - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2014 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
<a name="0"></a> * #L%
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.allanbank.mongodb.client;

import static com.allanbank.mongodb.client.connection.CallbackReply.reply;
import static org.easymock.EasyMock.anyObject;
import static org.easymock.EasyMock.capture;
import static org.easymock.EasyMock.createMock;
import static org.easymock.EasyMock.eq;
import static org.easymock.EasyMock.expect;
import static org.easymock.EasyMock.expectLastCall;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.allanbank.mongodb.Durability;
import com.allanbank.mongodb.MongoClientConfiguration;
import com.allanbank.mongodb.MongoCursorControl;
import com.allanbank.mongodb.MongoDbException;
import com.allanbank.mongodb.MongoIterator;
import com.allanbank.mongodb.ReadPreference;
import com.allanbank.mongodb.StreamCallback;
import com.allanbank.mongodb.bson.Document;
import com.allanbank.mongodb.bson.DocumentAssignable;
import com.allanbank.mongodb.bson.builder.BuilderFactory;
import com.allanbank.mongodb.bson.builder.DocumentBuilder;
import com.allanbank.mongodb.bson.impl.ImmutableDocument;
import com.allanbank.mongodb.client.callback.CursorStreamingCallback;
import com.allanbank.mongodb.client.callback.ReplyCallback;
import</b></font> com.allanbank.mongodb.client.connection.Connection;
import com.allanbank.mongodb.client.connection.MockMongoDBServer;
import com.allanbank.mongodb.client.connection.ReconnectStrategy;
import com.allanbank.mongodb.client.connection.proxy.ProxiedConnectionFactory;
import com.allanbank.mongodb.client.connection.socket.SocketConnectionFactory;
import com.allanbank.mongodb.client.message.Command;
import com.allanbank.mongodb.client.message.GetLastError;
import com.allanbank.mongodb.client.message.GetMore;
import com.allanbank.mongodb.client.message.IsMaster;
import com.allanbank.mongodb.client.message.Query;
import com.allanbank.mongodb.client.message.Update;
import com.allanbank.mongodb.client.state.Cluster;
import com.allanbank.mongodb.client.state.Server;
import com.allanbank.mongodb.client.state.ServerSelector;
import com.allanbank.mongodb.client.state.SimpleReconnectStrategy;
import com.allanbank.mongodb.error.CannotConnectException;
import com.allanbank.mongodb.error.ConnectionLostException;
import com.allanbank.mongodb.error.MongoClientClosedException;
import com.allanbank.mongodb.util.ServerNameUtils;

/**
 * ClientImplTest provides tests for the {@link ClientImpl} class.
 *
 * @copyright 2012-2014, Allanbank Consulting, Inc., All Rights Reserved
 */
@SuppressWarnings("unchecked")
public class ClientImplTest {
    /** A Mock MongoDB server to connect to. */
    private static MockMongoDBServer ourServer;

    /** Update document to mark servers as the primary. */
    private static final Document PRIMARY_UPDATE = new ImmutableDocument(
            BuilderFactory.start().add("ismaster", true));

    /**
     * Starts a Mock MongoDB server.
     *
     * @throws IOException
     *             On a failure to start the Mock MongoDB server.
     */
    @BeforeClass
    public static void setUpBeforeClass() throws IOException {
        ourServer = new MockMongoDBServer();
        ourServer.start();
    }

    /**
     * Stops a Mock MongoDB server.
     *
     * @throws IOException
     *             On a failure to stop the Mock MongoDB server.
     */
    @AfterClass
    public static void tearDownAfterClass() throws IOException {
        ourServer.setRunning(false);
        ourServer.close();
        ourServer = null;
    }

    /** The active configuration. */
    protected MongoClientConfiguration myConfig;

    /** The instance under test. */
    protected ClientImpl myTestInstance;

    /** A mock connection factory. */
    private ProxiedConnectionFactory myMockConnectionFactory;

    /**
     * Creates the base set of objects for the test.
     */
    @Before
    public void setUp() {
        myMockConnectionFactory = EasyMock
                .createMock(ProxiedConnectionFactory.class);

        myConfig = new MongoClientConfiguration();
        myTestInstance = new ClientImpl(myConfig, myMockConnectionFactory);

        reset(myMockConnectionFactory);
    }

    /**
     * Cleans up the base set of objects for the test.
     */
    @After
    public void tearDown() {
        myMockConnectionFactory = null;

        myConfig = null;
        myTestInstance = null;
        ourServer.clear();
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings("boxing")
    @Test
<a name="10"></a>    public void testClose() throws IOException {

        final Command message = new Command("testDb",
                Command.COMMAND_COLLECTION, <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();

        expect(mockConnection.isOpen()).andReturn</b></font>(false);

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on aa test failure.
     */
    @SuppressWarnings("boxing")
    @Test
<a name="13"></a>    public void testCloseFails() throws IOException {

        final Command message = new Command("testDb",
                Command.COMMAND_COLLECTION, <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

<a name="23"></a>        mockConnection.shutdown(false);
        expectLastCall</b></font>();

        <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();

        expect(mockConnection.isOpen()).andReturn(true);
        mockConnection.close();
        expectLastCall();
        mockConnection
                .removePropertyChangeListener(anyObject</b></font>(PropertyChangeListener.class));
        expectLastCall();

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings("boxing")
    @Test
<a name="12"></a>    public void testCloseOnThrownIoException() throws IOException {

        final Command message = new Command("testDb",
                Command.COMMAND_COLLECTION, <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall</b></font>();

        mockConnection.waitForClosed(myConfig.getReadTimeout(),
                TimeUnit.MILLISECONDS);
        expectLastCall();
<a name="19"></a>
        expect(mockConnection.isOpen()).andReturn(true);
        mockConnection.close();
        <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>expectLastCall().andThrow(new IOException("This is a test."));
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        myMockConnectionFactory.close();
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.close();

        verify</b></font>(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#close()} then throws an exception in a
     * send.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testCloseThenThrows() throws IOException {

        final Command message = new Command("testDb",
                Command.COMMAND_COLLECTION, BuilderFactory.start().build());

        myTestInstance.close();
        try {
            myTestInstance.send(message, null);
            fail("Should have thrown a MongoClientClosedException.");
        }
        catch (final MongoClientClosedException mcce) {
            // Good.
        }
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testCreatesConnectionOnScannedPending() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(7);

        final Connection mockConnection1 = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
<a name="5"></a>        final Connection mockConnection3 = createMock(Connection.class);
        final Connection mockConnection4 = createMock(Connection.class);
        final Connection mockConnection5 = createMock(Connection.class);
        <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Connection mockConnection6 = createMock(Connection.class);
        final Connection mockConnection7 = createMock(Connection.class);

        // First request - start at sequence zero.
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection1);
        mockConnection1
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection1.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
<a name="22"></a>                mockConnection7);

        // Second request - Still at sequence zero.
        expect</b></font>(<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
<a name="30"></a>        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall</b></font>();
        <font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
<a name="28"></a>
        // Third Request - Still at sequence zero.
        expect(mockConnection1.isAvailable</b></font>()).andReturn(true);
<a name="24"></a>        <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount</b></font>()).andReturn(1);
        <font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>expect(myMockConnectionFactory.connect()).andReturn(mockConnection3);
        mockConnection3
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection3.send(message, null);
        expectLastCall();

        replay</b></font>(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection4);
        mockConnection4
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection4.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection5);
        mockConnection5
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection5.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection6);
        mockConnection6
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection6.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection7);
        mockConnection7
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection7.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fourth Request - Still at sequence zero.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Second for most idle.
        expect(mockConnection1.isAvailable()).andReturn(true);
        expect(mockConnection1.getPendingCount()).andReturn(3);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        reset(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);

        // Fifth Request - Now at sequence one.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection3.isAvailable()).andReturn(true);
        expect(mockConnection3.getPendingCount()).andReturn(1);
        // Second for most idle.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection3.isAvailable()).andReturn(true);
        expect(mockConnection3.getPendingCount()).andReturn(3);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
        myTestInstance.send(message, null);
<a name="31"></a>        verify(mockConnection1, mockConnection2, mockConnection3,
                mockConnection4, mockConnection5, mockConnection6,
                mockConnection7);
    <font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    /**
     * Test method for {@link ClientImpl#getClusterType()}.
     */
    @Test
    public void testGetClusterType() {

        expect(myMockConnectionFactory.getClusterType()).andReturn(
                ClusterType.STAND_ALONE);

        replay</b></font>();

        assertEquals(ClusterType.STAND_ALONE, myTestInstance.getClusterType());

        verify();
    }

    /**
     * Test method for {@link ClientImpl#getConfig()}.
     */
    @Test
    public void testGetConfig() {
        assertSame(myConfig, myTestInstance.getConfig());
    }

    /**
     * Test method for {@link ClientImpl#getDefaultDurability()}.
     */
    @Test
    public void testGetDefaultDurability() {
        assertSame(myConfig.getDefaultDurability(),
                myTestInstance.getDefaultDurability());
        myConfig.setDefaultDurability(Durability.journalDurable(1000));
        assertSame(myConfig.getDefaultDurability(),
                myTestInstance.getDefaultDurability());
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
<a name="15"></a>    @Test
    public void testHandleConnectionClosedForUnknownConnection()
            throws IOException {
        <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Connection mockConnection = createMock(Connection.class);

        // Response to the handleConnextionClosed.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection);

        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection);
    }

    /**
     * Test method for reconnect logic.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testInvalidPrpertyChange() throws IOException {</b></font>
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        final Capture&lt;PropertyChangeListener&gt; propListenerCapture = new Capture&lt;PropertyChangeListener&gt;();
        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection.addPropertyChangeListener(capture(propListenerCapture));
        expectLastCall();

        // First send to create the connection.
        mockConnection.send(message, null);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);

        propListenerCapture.getValue().propertyChange(
                new PropertyChangeEvent(mockConnection,
                        Connection.OPEN_PROP_NAME + "g", Boolean.TRUE,
                        Boolean.FALSE));
        propListenerCapture.getValue()
                .propertyChange(
                        new PropertyChangeEvent(mockConnection,
                                Connection.OPEN_PROP_NAME, Boolean.FALSE,
                                Boolean.TRUE));
        propListenerCapture.getValue().propertyChange(
                new PropertyChangeEvent(mockConnection,
                        Connection.OPEN_PROP_NAME, Boolean.TRUE, Integer
<a name="29"></a>                                .valueOf(1)));

        // Verify that the connection is not removed.
        <font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, myTestInstance.getConnectionCount());

        verify(mockConnection);

    }

    /**
     * Test method for reconnect logic.
     */
    @Test
    public void testReconnect() {

        final String serverName = ourServer.getInetSocketAddress()</b></font>
                .getHostName()
                + ":"
                + ourServer.getInetSocketAddress().getPort();

        ourServer.setReplies(
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
<a name="7"></a>                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")),
                reply(BuilderFactory.start(PRIMARY_UPDATE).addString("_id",
                        serverName), BuilderFactory.start(PRIMARY_UPDATE)
                        .addString("_id", "localhost:1234")));

        final GetLastError message = new GetLastError("testDb", Durability.ACK)</b></font>;
        final MongoClientConfiguration config = new MongoClientConfiguration(
                "mongodb://"
                        + ServerNameUtils.normalize(ourServer
                                .getInetSocketAddress()));
        config.setAutoDiscoverServers(false);
<a name="20"></a>
        try {
            myTestInstance = new ClientImpl(config,
                    <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new SocketConnectionFactory(config));

            myTestInstance.send(message, null);
            ourServer.waitForRequest(2, 10000);

            ourServer.disconnectClient();
            assertTrue(ourServer.waitForDisconnect(10000));

            assertTrue(ourServer.waitForClient(10000));
            ourServer.waitForRequest(2, 10000); // ping.

            // Give a pause for the reconnect to finish on our side.
            Thread.sleep(50);

            myTestInstance.send(message, null);
            ourServer.waitForRequest</b></font>(3, 10000);
        }
        catch (final InterruptedException e) {
            // Ignore.
        }
        finally {
            myTestInstance.close();
        }

    }

    /**
     * Test method for reconnect logic.
     *
     * @throws IOException
     *             On a test failure.
     */
    @Test
    public void testReconnectFails() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
        final Cluster cluster = new Cluster(myConfig, ClusterType.STAND_ALONE);
        final Server server = cluster.add(new InetSocketAddress("localhost",
                27017));
        final Capture&lt;PropertyChangeListener&gt; propListenerCapture = new Capture&lt;PropertyChangeListener&gt;();
        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection.addPropertyChangeListener(capture(propListenerCapture));
        expectLastCall();

        // First send to create the connection.
        mockConnection.send(message, null);
        expectLastCall();

        // We trigger the connection failure.
        final SimpleReconnectStrategy strategy = new SimpleReconnectStrategy();
        strategy.setConfig(myConfig);
        strategy.setSelector(new ServerSelector() {
            @Override
            public List&lt;Server&gt; pickServers() {
                return Collections.singletonList(server);
            }
        });
        strategy.setConnectionFactory(myMockConnectionFactory);
        strategy.setState(cluster);

        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                strategy);

        // Try the straight connect back - but fail to connect.
        expect(mockConnection.getServer()).andReturn(server);
        expect(myMockConnectionFactory.connect(server, myConfig)).andThrow(
                new IOException("Injected"));

        // Create a new connection for the reconnect.
        expect(myMockConnectionFactory.connect(server, myConfig)).andReturn(
                mockConnection2);

<a name="16"></a>        // The ping! -- Fail.
        mockConnection2
                .send(eq(new IsMaster()), anyObject(ReplyCallback.class));
        expectLastCall().andThrow(<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new MongoDbException("synthetic ping error"));
        mockConnection2.close();
        expectLastCall();

        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        propListenerCapture.getValue</b></font>()
                .propertyChange(
                        new PropertyChangeEvent(mockConnection,
                                Connection.OPEN_PROP_NAME, Boolean.TRUE,
<a name="27"></a>                                Boolean.FALSE));

        // Verify that the connection is removed.
        <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, myTestInstance.getConnectionCount());

        verify(mockConnection, mockConnection2);

    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @Test
    public void testReconnectOnShutdownConnection() throws IOException,
            InterruptedException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,</b></font>
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final ReconnectStrategy mockStrategy = createMock(ReconnectStrategy.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
<a name="3"></a>                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(true);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();

        replay(mockConnection, mockStrategy);

        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockStrategy);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @Test
    public void testReconnectThatFails() throws IOException,
            InterruptedException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,</b></font>
                BuilderFactory.start().build());
<a name="4"></a>
        myConfig.setMaxConnectionCount(1);

        <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Connection mockConnection = createMock(Connection.class);
        final ReconnectStrategy mockStrategy = createMock(ReconnectStrategy.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy</b></font>()).andReturn(
                mockStrategy);
        expect(mockStrategy.reconnect(mockConnection)).andReturn(null);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
        expectLastCall();

        replay(mockConnection, mockStrategy);

        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockStrategy);
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testRestartDocumentAssignable() throws IOException {

        final DocumentBuilder b = BuilderFactory.start();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, "server");
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);
<a name="9"></a>
        final GetMore message = new GetMore("a", "b", 123456, 23,
                ReadPreference.server("server"));
        final Connection mockConnection = <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(eq(message), anyObject(ReplyCallback.class));
        expectLastCall();

        replay(mockConnection);

        final MongoIterator&lt;Document&gt; iter = myTestInstance.restart(b);

        verify(mockConnection);

        assertThat(iter, instanceOf</b></font>(MongoIteratorImpl.class));
<a name="2"></a>        final MongoIteratorImpl iterImpl = (MongoIteratorImpl) iter;
        assertThat(iterImpl.getBatchSize(), is(23));
        assertThat(iterImpl.getLimit(), is(4321));
        assertThat(iterImpl.getCursorId(), <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>is(123456L));
        assertThat(iterImpl.getDatabaseName(), is("a"));
        assertThat(iterImpl.getCollectionName(), is("b"));
        assertThat(iterImpl.getClient(), is((Client) myTestInstance));
        assertThat(iterImpl.getReadPerference(),
                is(ReadPreference.server("server")));
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testRestartDocumentAssignableNonCursorDoc() throws IOException {

        final DocumentBuilder b = BuilderFactory.start</b></font>();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, "server");
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        replay();

        // Missing fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.SERVER_FIELD, "server");

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");

        // Too few fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        // Wrong Field type.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, "s");
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, "s");
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, "server");

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, "s");
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, 1);
        try {
            myTestInstance.restart(b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");

        verify();

    }

    /**
     * Test method for
     * {@link ClientImpl#restart(StreamCallback, DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testRestartStreamCallbackDocumentAssignable()
            throws IOException {

        final DocumentBuilder b = BuilderFactory.start();
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, "server");
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

<a name="8"></a>        final GetMore message = new GetMore("a", "b", 123456, 23,
                ReadPreference.server("server"));
        final StreamCallback&lt;Document&gt; mockStreamCallback = createMock(StreamCallback.class);
        final Connection mockConnection = <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(eq(message), anyObject(ReplyCallback.class));
        expectLastCall();

        replay(mockConnection, mockStreamCallback);

        final MongoCursorControl iter = myTestInstance.restart(
                mockStreamCallback, b);

        verify(mockConnection, mockStreamCallback);

        assertThat(iter, instanceOf</b></font>(CursorStreamingCallback.class));
<a name="1"></a>        final CursorStreamingCallback iterImpl = (CursorStreamingCallback) iter;
        assertThat(iterImpl.getBatchSize(), is(23));
        assertThat(iterImpl.getLimit(), is(4321));
        assertThat(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>iterImpl.getCursorId(), is(123456L));
        assertThat(iterImpl.getDatabaseName(), is("a"));
        assertThat(iterImpl.getCollectionName(), is("b"));
        assertThat(iterImpl.getClient(), is((Client) myTestInstance));
        assertThat(iterImpl.getAddress(), is("server"));
    }

    /**
     * Test method for {@link ClientImpl#restart(DocumentAssignable)}.
     *
     * @throws IOException
     *             on a test failure.
     */
    @Test
    public void testRestartStreamCallbackDocumentAssignableNonCursorDoc()
<a name="21"></a>            throws IOException {

        final DocumentBuilder b = BuilderFactory.start</b></font>();
        <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 123456);
        b.add(MongoCursorControl.SERVER_FIELD, "server");
        b.add(MongoCursorControl.LIMIT_FIELD, 4321);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        final StreamCallback&lt;Document&gt; mockStreamCallback = createMock(StreamCallback.class);

        replay(mockStreamCallback);

        // Missing fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add</b></font>("c", 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.SERVER_FIELD, "server");

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add("c", 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove("c");
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");

        // Too few fields.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        // Wrong Field type.
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, "s");
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.BATCH_SIZE_FIELD);
        b.add(MongoCursorControl.BATCH_SIZE_FIELD, 23);

        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, "s");
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.LIMIT_FIELD);
        b.add(MongoCursorControl.LIMIT_FIELD, 23);

        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.SERVER_FIELD);
        b.add(MongoCursorControl.SERVER_FIELD, "server");

        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, "s");
        try {
            myTestInstance.restart(mockStreamCallback, b);
        }
        catch (final IllegalArgumentException good) { // Good.
        }
        b.remove(MongoCursorControl.CURSOR_ID_FIELD);
        b.add(MongoCursorControl.CURSOR_ID_FIELD, 23);

        b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, 1);
        try {
            myTestInstance.restart(mockStreamCallback, b);
<a name="26"></a>        }
        catch (final IllegalArgumentException good) { // Good.
        }
        <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>b.remove(MongoCursorControl.NAME_SPACE_FIELD);
        b.add(MongoCursorControl.NAME_SPACE_FIELD, "a.b");

        verify(mockStreamCallback);

    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendGetMoreCallbackOfReply() throws IOException {

        final ReplyCallback callback = createMock(ReplyCallback.class)</b></font>;
<a name="6"></a>        final GetMore message = new GetMore("testDb", "collection", 1234L,
                12345, ReadPreference.PRIMARY);

        final Connection mockConnection = <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, callback);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessage() throws IOException {
        final Update message = new Update("testDb", "collection", null, null,</b></font>
                false, false);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

<a name="25"></a>        mockConnection.send(message, null);
        expectLastCall();

        <font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>replay(mockConnection);

        myTestInstance.send(message, null);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessageAndCreateConnectionFailes() throws IOException {
        final Update message = new Update("testDb", "collection", null, null,</b></font>
                false, false);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andThrow(new IOException());

        replay(mockConnection);

        try {
            myTestInstance.send(message, null);
            fail("Should have thrown a MongoDbException.");
        }
        catch (final MongoDbException good) {
            // good.
        }

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageClosesFirstWhenMaxShrinks() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
<a name="18"></a>
        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect</b></font>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        mockConnection2.send(message, null);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        mockConnection2.send(message, null);
        expectLastCall();

        // Response to the handleConnextionClosed.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myConfig.setMaxConnectionCount(2);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myConfig.setMaxConnectionCount(1);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myTestInstance.handleConnectionClosed(mockConnection);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageClosesFirstWhenMaxShrinksAndCloseFails()
            throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());
<a name="17"></a>
        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect</b></font>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        mockConnection.shutdown(false);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(0);
        mockConnection2.send(message, null);
        expectLastCall();

        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        expect(mockConnection2.isAvailable()).andReturn(true);
        // expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myConfig.setMaxConnectionCount(2);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myConfig.setMaxConnectionCount(1);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageCreatesSecondConnectionOnPending()
            throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageFailsWhenAllAreClosed() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        // First pass for idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Now most idle.
        expect(mockConnection.isAvailable()).andReturn(false);
        expect(mockConnection2.isAvailable()).andReturn(false);

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        try {
            myTestInstance.send(message, null);
            fail("Should have failed.");
        }
        catch (final CannotConnectException failure) {
            assertThat(
                    failure.getMessage(),
                    containsString("Could not create a connection to the server."));
        }
        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendMessageGetLastErrorCallbackOfReply() throws IOException {
        final Message message = new Update("testDb", "collection", null, null,
                false, false);
        final GetLastError lastError = new GetLastError("testDb", false, false,
                0, 0);
        final ReplyCallback callback = createMock(ReplyCallback.class);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, lastError, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, lastError, callback);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
<a name="11"></a>    @Test
    public void testSendMessagePicksIdleExisting() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BuilderFactory.start().build());

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, null);
        expectLastCall();

        expect</b></font>(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(0);
        mockConnection.send(message, null);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessagePicksMostIdleWhenAllPending() throws IOException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(2);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(1);
        expect(myMockConnectionFactory.connect()).andReturn(mockConnection2);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2.send(message, null);
        expectLastCall();

        // First pass for idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        // Now most idle.
        expect(mockConnection.isAvailable()).andReturn(true);
        expect(mockConnection.getPendingCount()).andReturn(2);
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(1);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);
        myTestInstance.send(message, null);
        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageWaitsForReconnect() throws IOException,
            InterruptedException {
        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
        makeThreadSafe(mockConnection, mockConnection2);

        final ReconnectStrategy pauseStrategy = new SimpleReconnectStrategy() {
            @Override
            public Connection reconnect(final Connection oldConnection) {
                try {
                    Thread.sleep(500);
                }
                catch (final InterruptedException e) {
                    // Ignore.
                }
                return mockConnection2;
            }
        };

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        expect(mockConnection.isShuttingDown()).andReturn(false);
        expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                pauseStrategy);
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(ConnectionLostException.class));
        expectLastCall();

        // Second message.
        expect(mockConnection.isAvailable()).andReturn(false).times(2);

        // Wait for the reconnect.

        // After reconnect.
        expect(mockConnection2.isAvailable()).andReturn(true);
        expect(mockConnection2.getPendingCount()).andReturn(0);
        mockConnection2.send(message, null);
        expectLastCall();

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        new Thread(new Runnable() {
            @Override
            public void run() {
                myTestInstance.handleConnectionClosed(mockConnection);
            }
        }).start();
        Thread.sleep(100);

        myTestInstance.send(message, null);

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     * @throws InterruptedException
     *             On a failure to pause in the test.
     */
    @SuppressWarnings("boxing")
    @Test
    public void testSendMessageWaitsForReconnectTimesOut() throws IOException,
            InterruptedException {

        myConfig.setReconnectTimeout(250);

        final Message message = new Command("db", Command.COMMAND_COLLECTION,
                BuilderFactory.start().build());

        myConfig.setMaxConnectionCount(1);

        final Connection mockConnection = createMock(Connection.class);
        final Connection mockConnection2 = createMock(Connection.class);
        makeThreadSafe(mockConnection, mockConnection2);

        final ReconnectStrategy pauseStrategy = new SimpleReconnectStrategy() {
            @Override
            public Connection reconnect(final Connection oldConnection) {
                try {
                    Thread.sleep(500);
                }
                catch (final InterruptedException e) {
                    // Ignore.
                }
                return mockConnection2;
            }
        };

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.send(message, null);
        expectLastCall();

        // Reconnect.
        mockConnection
                .removePropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();
        mockConnection.raiseErrors(anyObject(MongoDbException.class));
<a name="14"></a>        expectLastCall();
        expect(mockConnection.isShuttingDown()).andReturn(false);

        <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>expect(myMockConnectionFactory.getReconnectStrategy()).andReturn(
                pauseStrategy);
        mockConnection2
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        // Second message.
        // Wait for the reconnect.

        // After reconnect timeout.
        expect(mockConnection.isAvailable()).andReturn(false).times(2, 4);

        replay(mockConnection, mockConnection2);

        myTestInstance.send(message, null);

        final Thread t = new</b></font> Thread(new Runnable() {
            @Override
            public void run() {
                myTestInstance.handleConnectionClosed(mockConnection);
            }
        });
        t.start();

        Thread.sleep(100);

        try {
            myTestInstance.send(message, null);
        }
        catch (final CannotConnectException failure) {
            assertThat(
                    failure.getMessage(),
                    containsString("Could not create a connection to the server."));

        }

        t.join();

        verify(mockConnection, mockConnection2);
    }

    /**
     * Test method for {@link ClientImpl#send} .
     *
     * @throws IOException
     *             On a failure setting up the test.
     */
    @Test
    public void testSendQueryCallbackOfReply() throws IOException {
        final Query message = new Query("db", "coll", null, null, 0, 0, 0,
                false, ReadPreference.PRIMARY, false, false, false, false);
        final ReplyCallback callback = createMock(ReplyCallback.class);

        final Connection mockConnection = createMock(Connection.class);

        expect(myMockConnectionFactory.connect()).andReturn(mockConnection);
        mockConnection
                .addPropertyChangeListener(anyObject(PropertyChangeListener.class));
        expectLastCall();

        mockConnection.send(message, callback);
        expectLastCall();

        replay(mockConnection);

        myTestInstance.send(message, callback);

        verify(mockConnection);
    }

    /**
     * Performs a {@link EasyMock#makeThreadSafe(Object, boolean)} on the
     * provided mocks and the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void makeThreadSafe(final Object... mocks) {
        for (final Object mock : mocks) {
            EasyMock.makeThreadSafe(mock, true);
        }
        EasyMock.makeThreadSafe(myMockConnectionFactory, true);
    }

    /**
     * Performs a {@link EasyMock#replay(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void replay(final Object... mocks) {
        EasyMock.replay(mocks);
        EasyMock.replay(myMockConnectionFactory);
    }

    /**
     * Performs a {@link EasyMock#reset(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void reset(final Object... mocks) {
        EasyMock.reset(mocks);
        EasyMock.reset(myMockConnectionFactory);
    }

    /**
     * Performs a {@link EasyMock#verify(Object...)} on the provided mocks and
     * the {@link #myMockConnectionFactory} object.
     *
     * @param mocks
     *            The mock to replay.
     */
    private void verify(final Object... mocks) {
        EasyMock.verify(mocks);
        EasyMock.verify(myMockConnectionFactory);
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
