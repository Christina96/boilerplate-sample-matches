<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FinalizableReferenceQueueClassLoaderUnloadingTest.java &amp; ImmutableSortedMap.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FinalizableReferenceQueueClassLoaderUnloadingTest.java &amp; ImmutableSortedMap.java
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FinalizableReferenceQueueClassLoaderUnloadingTest.java (4.6153846%)<th>ImmutableSortedMap.java (1.9582245%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-33)<td><a href="#" name="0">(17-33)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FinalizableReferenceQueueClassLoaderUnloadingTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.base;
2 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
3 import static com.google.common.base.StandardSystemProperty.JAVA_SPECIFICATION_VERSION;
4 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
5 import com.google.common.collect.ImmutableList;
6 import com.google.common.testing.GcFinalization;
7 import java.io.Closeable;
8 import java.io.File;
9 import java.lang.ref.WeakReference;
10 import java.lang.reflect.Constructor;
11 import java.lang.reflect.Field;
12 import java.net.MalformedURLException;
13 import java.net.URL;
14 import java.net.URLClassLoader;
15 import</b></font> java.security.Permission;
16 import java.security.Policy;
17 import java.security.ProtectionDomain;
18 import java.util.concurrent.Callable;
19 import java.util.concurrent.Semaphore;
20 import java.util.concurrent.TimeUnit;
21 import java.util.concurrent.atomic.AtomicReference;
22 import junit.framework.TestCase;
23 public class FinalizableReferenceQueueClassLoaderUnloadingTest extends TestCase {
24   public static class MyFinalizableWeakReference extends FinalizableWeakReference&lt;Object&gt; {
25     public MyFinalizableWeakReference(Object x, FinalizableReferenceQueue queue) {
26       super(x, queue);
27     }
28     @Override
29     public void finalizeReferent() {}
30   }
31   private static class PermissivePolicy extends Policy {
32     @Override
33     public boolean implies(ProtectionDomain pd, Permission perm) {
34       return true;
35     }
36   }
37   private WeakReference&lt;ClassLoader&gt; useFrqInSeparateLoader() throws Exception {
38     final ClassLoader myLoader = getClass().getClassLoader();
39     URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent());
40     Class&lt;?&gt; frqC = FinalizableReferenceQueue.class;
41     Class&lt;?&gt; sepFrqC = sepLoader.loadClass(frqC.getName());
42     assertNotSame(frqC, sepFrqC);
43     Class&lt;?&gt; sepFrqSystemLoaderC =
44         sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());
45     Field disabled = sepFrqSystemLoaderC.getDeclaredField("disabled");
46     disabled.setAccessible(true);
47     disabled.set(null, true);
48     AtomicReference&lt;Object&gt; sepFrqA =
49         new AtomicReference&lt;Object&gt;(sepFrqC.getDeclaredConstructor().newInstance());
50     Class&lt;?&gt; sepFwrC = sepLoader.loadClass(MyFinalizableWeakReference.class.getName());
51     Constructor&lt;?&gt; sepFwrCons = sepFwrC.getConstructor(Object.class, sepFrqC);
52     Class&lt;?&gt; sepStopwatchC = sepLoader.loadClass(Stopwatch.class.getName());
53     assertSame(sepLoader, sepStopwatchC.getClassLoader());
54     AtomicReference&lt;Object&gt; sepStopwatchA =
55         new AtomicReference&lt;Object&gt;(sepStopwatchC.getMethod("createUnstarted").invoke(null));
56     AtomicReference&lt;WeakReference&lt;?&gt;&gt; sepStopwatchRef =
57         new AtomicReference&lt;WeakReference&lt;?&gt;&gt;(
58             (WeakReference&lt;?&gt;) sepFwrCons.newInstance(sepStopwatchA.get(), sepFrqA.get()));
59     assertNotNull(sepStopwatchA.get());
60     sepStopwatchA.set(null);
61     GcFinalization.awaitClear(sepStopwatchRef.get());
62     return new WeakReference&lt;ClassLoader&gt;(sepLoader);
63   }
64   private void doTestUnloadable() throws Exception {
65     WeakReference&lt;ClassLoader&gt; loaderRef = useFrqInSeparateLoader();
66     GcFinalization.awaitClear(loaderRef);
67   }
68   public void testUnloadableWithoutSecurityManager() throws Exception {
69     if (isJdk9OrHigher()) {
70       return;
71     }
72     SecurityManager oldSecurityManager = System.getSecurityManager();
73     try {
74       System.setSecurityManager(null);
75       doTestUnloadable();
76     } finally {
77       System.setSecurityManager(oldSecurityManager);
78     }
79   }
80   public void testUnloadableWithSecurityManager() throws Exception {
81     if (isJdk9OrHigher()) {
82       return;
83     }
84     Policy oldPolicy = Policy.getPolicy();
85     SecurityManager oldSecurityManager = System.getSecurityManager();
86     try {
87       Policy.setPolicy(new PermissivePolicy());
88       System.setSecurityManager(new SecurityManager());
89       doTestUnloadable();
90     } finally {
91       System.setSecurityManager(oldSecurityManager);
92       Policy.setPolicy(oldPolicy);
93     }
94   }
95   public static class FrqUser implements Callable&lt;WeakReference&lt;Object&gt;&gt; {
96     public static FinalizableReferenceQueue frq = new FinalizableReferenceQueue();
97     public static final Semaphore finalized = new Semaphore(0);
98     @Override
99     public WeakReference&lt;Object&gt; call() {
100       WeakReference&lt;Object&gt; wr =
101           new FinalizableWeakReference&lt;Object&gt;(new Integer(23), frq) {
102             @Override
103             public void finalizeReferent() {
104               finalized.release();
105             }
106           };
107       return wr;
108     }
109   }
110   public void testUnloadableInStaticFieldIfClosed() throws Exception {
111     if (isJdk9OrHigher()) {
112       return;
113     }
114     Policy oldPolicy = Policy.getPolicy();
115     SecurityManager oldSecurityManager = System.getSecurityManager();
116     try {
117       Policy.setPolicy(new PermissivePolicy());
118       System.setSecurityManager(new SecurityManager());
119       WeakReference&lt;ClassLoader&gt; loaderRef = doTestUnloadableInStaticFieldIfClosed();
120       GcFinalization.awaitClear(loaderRef);
121     } finally {
122       System.setSecurityManager(oldSecurityManager);
123       Policy.setPolicy(oldPolicy);
124     }
125   }
126   private WeakReference&lt;ClassLoader&gt; doTestUnloadableInStaticFieldIfClosed() throws Exception {
127     final ClassLoader myLoader = getClass().getClassLoader();
128     URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent());
129     Class&lt;?&gt; frqC = FinalizableReferenceQueue.class;
130     Class&lt;?&gt; sepFrqC = sepLoader.loadClass(frqC.getName());
131     assertNotSame(frqC, sepFrqC);
132     Class&lt;?&gt; sepFrqSystemLoaderC =
133         sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());
134     Field disabled = sepFrqSystemLoaderC.getDeclaredField("disabled");
135     disabled.setAccessible(true);
136     disabled.set(null, true);
137     Class&lt;?&gt; frqUserC = FrqUser.class;
138     Class&lt;?&gt; sepFrqUserC = sepLoader.loadClass(frqUserC.getName());
139     assertNotSame(frqUserC, sepFrqUserC);
140     assertSame(sepLoader, sepFrqUserC.getClassLoader());
141     Callable&lt;?&gt; sepFrqUser = (Callable&lt;?&gt;) sepFrqUserC.getDeclaredConstructor().newInstance();
142     WeakReference&lt;?&gt; finalizableWeakReference = (WeakReference&lt;?&gt;) sepFrqUser.call();
143     GcFinalization.awaitClear(finalizableWeakReference);
144     Field sepFrqUserFinalizedF = sepFrqUserC.getField("finalized");
145     Semaphore finalizeCount = (Semaphore) sepFrqUserFinalizedF.get(null);
146     boolean finalized = finalizeCount.tryAcquire(5, TimeUnit.SECONDS);
147     assertTrue(finalized);
148     Field sepFrqUserFrqF = sepFrqUserC.getField("frq");
149     Closeable frq = (Closeable) sepFrqUserFrqF.get(null);
150     frq.close();
151     return new WeakReference&lt;ClassLoader&gt;(sepLoader);
152   }
153   private URL[] getClassPathUrls() {
154     ClassLoader classLoader = getClass().getClassLoader();
155     return classLoader instanceof URLClassLoader
156         ? ((URLClassLoader) classLoader).getURLs()
157         : parseJavaClassPath().toArray(new URL[0]);
158   }
159   private static ImmutableList&lt;URL&gt; parseJavaClassPath() {
160     ImmutableList.Builder&lt;URL&gt; urls = ImmutableList.builder();
161     for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {
162       try {
163         try {
164           urls.add(new File(entry).toURI().toURL());
165         } catch (SecurityException e) {           urls.add(new URL("file", null, new File(entry).getAbsolutePath()));
166         }
167       } catch (MalformedURLException e) {
168         AssertionError error = new AssertionError("malformed class path entry: " + entry);
169         error.initCause(e);
170         throw error;
171       }
172     }
173     return urls.build();
174   }
175   private static boolean isJdk9OrHigher() {
176     return JAVA_SPECIFICATION_VERSION.value().startsWith("9")
177         || JAVA_SPECIFICATION_VERSION.value().startsWith("10");
178   }
179 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.Maps.newTreeMap;
5 import static java.util.Collections.singletonMap;
6 import static java.util.Collections.unmodifiableSortedMap;
7 import java.util.Comparator;
8 import java.util.Iterator;
9 import java.util.Map;
10 import java.util.SortedMap;
11 import java.util.TreeMap;
12 import java.util.function.BinaryOperator;
13 import java.util.function.Function;
14 import java.util.stream.Collector;
15 import</b></font> java.util.stream.Collectors;
16 public final class ImmutableSortedMap&lt;K, V&gt; extends ForwardingImmutableMap&lt;K, V&gt;
17     implements SortedMap&lt;K, V&gt; {
18   @SuppressWarnings("unchecked")
19   static final Comparator NATURAL_ORDER = Ordering.natural();
20   private Comparator&lt;? super K&gt; unusedComparatorForSerialization;
21   private K unusedKeyForSerialization;
22   private V unusedValueForSerialization;
23   private final transient SortedMap&lt;K, V&gt; sortedDelegate;
24   private final transient Comparator&lt;? super K&gt; comparator;
25   ImmutableSortedMap(SortedMap&lt;K, V&gt; delegate, Comparator&lt;? super K&gt; comparator) {
26     super(delegate);
27     this.comparator = comparator;
28     this.sortedDelegate = delegate;
29   }
30   public static &lt;T, K, V&gt; Collector&lt;T, ?, ImmutableSortedMap&lt;K, V&gt;&gt; toImmutableSortedMap(
31       Comparator&lt;? super K&gt; comparator,
32       Function&lt;? super T, ? extends K&gt; keyFunction,
33       Function&lt;? super T, ? extends V&gt; valueFunction) {
34     return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction);
35   }
36   public static &lt;T, K, V&gt; Collector&lt;T, ?, ImmutableSortedMap&lt;K, V&gt;&gt; toImmutableSortedMap(
37       Comparator&lt;? super K&gt; comparator,
38       Function&lt;? super T, ? extends K&gt; keyFunction,
39       Function&lt;? super T, ? extends V&gt; valueFunction,
40       BinaryOperator&lt;V&gt; mergeFunction) {
41     checkNotNull(comparator);
42     checkNotNull(keyFunction);
43     checkNotNull(valueFunction);
44     checkNotNull(mergeFunction);
45     return Collectors.collectingAndThen(
46         Collectors.toMap(
47             keyFunction, valueFunction, mergeFunction, () -&gt; new TreeMap&lt;K, V&gt;(comparator)),
48         ImmutableSortedMap::copyOfSorted);
49   }
50   @SuppressWarnings("unchecked")
51   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; of() {
52     return new Builder&lt;K, V&gt;(NATURAL_ORDER).build();
53   }
54   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(K k1, V v1) {
55     return copyOf(singletonMap(k1, v1));
56   }
57   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
58       K k1, V v1, K k2, V v2) {
59     return new Builder&lt;K, V&gt;(Ordering.natural()).put(k1, v1).put(k2, v2).build();
60   }
61   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
62       K k1, V v1, K k2, V v2, K k3, V v3) {
63     return new Builder&lt;K, V&gt;(Ordering.natural()).put(k1, v1).put(k2, v2).put(k3, v3).build();
64   }
65   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
66       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
67     return new Builder&lt;K, V&gt;(Ordering.natural())
68         .put(k1, v1)
69         .put(k2, v2)
70         .put(k3, v3)
71         .put(k4, v4)
72         .build();
73   }
74   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
75       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
76     return new Builder&lt;K, V&gt;(Ordering.natural())
77         .put(k1, v1)
78         .put(k2, v2)
79         .put(k3, v3)
80         .put(k4, v4)
81         .put(k5, v5)
82         .build();
83   }
84   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
85       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
86     return new Builder&lt;K, V&gt;(Ordering.natural())
87         .put(k1, v1)
88         .put(k2, v2)
89         .put(k3, v3)
90         .put(k4, v4)
91         .put(k5, v5)
92         .put(k6, v6)
93         .build();
94   }
95   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
96       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
97     return new Builder&lt;K, V&gt;(Ordering.natural())
98         .put(k1, v1)
99         .put(k2, v2)
100         .put(k3, v3)
101         .put(k4, v4)
102         .put(k5, v5)
103         .put(k6, v6)
104         .put(k7, v7)
105         .build();
106   }
107   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
108       K k1,
109       V v1,
110       K k2,
111       V v2,
112       K k3,
113       V v3,
114       K k4,
115       V v4,
116       K k5,
117       V v5,
118       K k6,
119       V v6,
120       K k7,
121       V v7,
122       K k8,
123       V v8) {
124     return new Builder&lt;K, V&gt;(Ordering.natural())
125         .put(k1, v1)
126         .put(k2, v2)
127         .put(k3, v3)
128         .put(k4, v4)
129         .put(k5, v5)
130         .put(k6, v6)
131         .put(k7, v7)
132         .put(k8, v8)
133         .build();
134   }
135   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
136       K k1,
137       V v1,
138       K k2,
139       V v2,
140       K k3,
141       V v3,
142       K k4,
143       V v4,
144       K k5,
145       V v5,
146       K k6,
147       V v6,
148       K k7,
149       V v7,
150       K k8,
151       V v8,
152       K k9,
153       V v9) {
154     return new Builder&lt;K, V&gt;(Ordering.natural())
155         .put(k1, v1)
156         .put(k2, v2)
157         .put(k3, v3)
158         .put(k4, v4)
159         .put(k5, v5)
160         .put(k6, v6)
161         .put(k7, v7)
162         .put(k8, v8)
163         .put(k9, v9)
164         .build();
165   }
166   public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
167       K k1,
168       V v1,
169       K k2,
170       V v2,
171       K k3,
172       V v3,
173       K k4,
174       V v4,
175       K k5,
176       V v5,
177       K k6,
178       V v6,
179       K k7,
180       V v7,
181       K k8,
182       V v8,
183       K k9,
184       V v9,
185       K k10,
186       V v10) {
187     return new Builder&lt;K, V&gt;(Ordering.natural())
188         .put(k1, v1)
189         .put(k2, v2)
190         .put(k3, v3)
191         .put(k4, v4)
192         .put(k5, v5)
193         .put(k6, v6)
194         .put(k7, v7)
195         .put(k8, v8)
196         .put(k9, v9)
197         .put(k10, v10)
198         .build();
199   }
200   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) {
201     return copyOfInternal((Map) map, (Ordering&lt;K&gt;) Ordering.natural());
202   }
203   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
204       Map&lt;? extends K, ? extends V&gt; map, Comparator&lt;? super K&gt; comparator) {
205     return copyOfInternal(map, checkNotNull(comparator));
206   }
207   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
208       Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries) {
209     return new Builder&lt;K, V&gt;(NATURAL_ORDER).putAll(entries).build();
210   }
211   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
212       Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries,
213       Comparator&lt;? super K&gt; comparator) {
214     return new Builder&lt;K, V&gt;(comparator).putAll(entries).build();
215   }
216   public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOfSorted(SortedMap&lt;K, ? extends V&gt; map) {
217     @SuppressWarnings("unchecked")
218     Comparator&lt;? super K&gt; comparator =
219         (map.comparator() == null) ? NATURAL_ORDER : map.comparator();
220     return copyOfInternal(map, comparator);
221   }
222   private static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOfInternal(
223       Map&lt;? extends K, ? extends V&gt; map, Comparator&lt;? super K&gt; comparator) {
224     if (map instanceof ImmutableSortedMap) {
225       @SuppressWarnings("unchecked")
226       ImmutableSortedMap&lt;K, V&gt; kvMap = (ImmutableSortedMap&lt;K, V&gt;) map;
227       Comparator&lt;?&gt; comparator2 = kvMap.comparator();
228       boolean sameComparator =
229           (comparator2 == null) ? comparator == NATURAL_ORDER : comparator.equals(comparator2);
230       if (sameComparator) {
231         return kvMap;
232       }
233     }
234     SortedMap&lt;K, V&gt; delegate = newModifiableDelegate(comparator);
235     for (Entry&lt;? extends K, ? extends V&gt; entry : map.entrySet()) {
236       putEntryWithChecks(delegate, entry);
237     }
238     return newView(unmodifiableSortedMap(delegate), comparator);
239   }
240   private static &lt;K, V&gt; void putEntryWithChecks(
241       SortedMap&lt;K, V&gt; map, Entry&lt;? extends K, ? extends V&gt; entry) {
242     K key = checkNotNull(entry.getKey());
243     V value = checkNotNull(entry.getValue());
244     if (map.containsKey(key)) {
245       Entry&lt;K, V&gt; previousEntry = map.tailMap(key).entrySet().iterator().next();
246       throw new IllegalArgumentException(
247           "Duplicate keys in mappings "
248               + previousEntry.getKey()
249               + "="
250               + previousEntry.getValue()
251               + " and "
252               + key
253               + "="
254               + value);
255     }
256     map.put(key, value);
257   }
258   public static &lt;K extends Comparable&lt;?&gt;, V&gt; Builder&lt;K, V&gt; naturalOrder() {
259     return new Builder&lt;K, V&gt;(Ordering.natural());
260   }
261   public static &lt;K, V&gt; Builder&lt;K, V&gt; orderedBy(Comparator&lt;K&gt; comparator) {
262     return new Builder&lt;K, V&gt;(comparator);
263   }
264   public static &lt;K extends Comparable&lt;?&gt;, V&gt; Builder&lt;K, V&gt; reverseOrder() {
265     return new Builder&lt;K, V&gt;(Ordering.natural().reverse());
266   }
267   public static final class Builder&lt;K, V&gt; extends ImmutableMap.Builder&lt;K, V&gt; {
268     private final Comparator&lt;? super K&gt; comparator;
269     public Builder(Comparator&lt;? super K&gt; comparator) {
270       this.comparator = checkNotNull(comparator);
271     }
272     @Override
273     public Builder&lt;K, V&gt; put(K key, V value) {
274       entries.add(entryOf(key, value));
275       return this;
276     }
277     @Override
278     public Builder&lt;K, V&gt; put(Entry&lt;? extends K, ? extends V&gt; entry) {
279       super.put(entry);
280       return this;
281     }
282     @Override
283     public Builder&lt;K, V&gt; putAll(Map&lt;? extends K, ? extends V&gt; map) {
284       return putAll(map.entrySet());
285     }
286     @Override
287     public Builder&lt;K, V&gt; putAll(Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries) {
288       for (Entry&lt;? extends K, ? extends V&gt; entry : entries) {
289         put(entry);
290       }
291       return this;
292     }
293     Builder&lt;K, V&gt; combine(Builder&lt;K, V&gt; other) {
294       super.combine(other);
295       return this;
296     }
297     @Override
298     public Builder&lt;K, V&gt; orderEntriesByValue(Comparator&lt;? super V&gt; valueComparator) {
299       throw new UnsupportedOperationException("Not available on ImmutableSortedMap.Builder");
300     }
301     @Override
302     public ImmutableSortedMap&lt;K, V&gt; build() {
303       return buildOrThrow();
304     }
305     @Override
306     public ImmutableSortedMap&lt;K, V&gt; buildOrThrow() {
307       SortedMap&lt;K, V&gt; delegate = newModifiableDelegate(comparator);
308       for (Entry&lt;? extends K, ? extends V&gt; entry : entries) {
309         putEntryWithChecks(delegate, entry);
310       }
311       return newView(unmodifiableSortedMap(delegate), comparator);
312     }
313   }
314   private transient ImmutableSortedSet&lt;K&gt; keySet;
315   @Override
316   public ImmutableSortedSet&lt;K&gt; keySet() {
317     ImmutableSortedSet&lt;K&gt; ks = keySet;
318     return (ks == null) ? (keySet = createKeySet()) : ks;
319   }
320   @Override
321   ImmutableSortedSet&lt;K&gt; createKeySet() {
322     //
323     return ImmutableSortedSet.copyOf(comparator, sortedDelegate.keySet());
324   }
325   public Comparator&lt;? super K&gt; comparator() {
326     return comparator;
327   }
328   public K firstKey() {
329     return sortedDelegate.firstKey();
330   }
331   public K lastKey() {
332     return sortedDelegate.lastKey();
333   }
334   K higher(K k) {
335     Iterator&lt;K&gt; iterator = keySet().tailSet(k).iterator();
336     while (iterator.hasNext()) {
337       K tmp = iterator.next();
338       if (comparator().compare(k, tmp) &lt; 0) {
339         return tmp;
340       }
341     }
342     return null;
343   }
344   public ImmutableSortedMap&lt;K, V&gt; headMap(K toKey) {
345     checkNotNull(toKey);
346     return newView(sortedDelegate.headMap(toKey));
347   }
348   ImmutableSortedMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) {
349     checkNotNull(toKey);
350     if (inclusive) {
351       K tmp = higher(toKey);
352       if (tmp == null) {
353         return this;
354       }
355       toKey = tmp;
356     }
357     return headMap(toKey);
358   }
359   public ImmutableSortedMap&lt;K, V&gt; subMap(K fromKey, K toKey) {
360     checkNotNull(fromKey);
361     checkNotNull(toKey);
362     checkArgument(comparator.compare(fromKey, toKey) &lt;= 0);
363     return newView(sortedDelegate.subMap(fromKey, toKey));
364   }
365   ImmutableSortedMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
366     checkNotNull(fromKey);
367     checkNotNull(toKey);
368     checkArgument(comparator.compare(fromKey, toKey) &lt;= 0);
369     return tailMap(fromKey, fromInclusive).headMap(toKey, toInclusive);
370   }
371   public ImmutableSortedMap&lt;K, V&gt; tailMap(K fromKey) {
372     checkNotNull(fromKey);
373     return newView(sortedDelegate.tailMap(fromKey));
374   }
375   public ImmutableSortedMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) {
376     checkNotNull(fromKey);
377     if (!inclusive) {
378       fromKey = higher(fromKey);
379       if (fromKey == null) {
380         return new Builder&lt;K, V&gt;(this.comparator).build();
381       }
382     }
383     return tailMap(fromKey);
384   }
385   private ImmutableSortedMap&lt;K, V&gt; newView(SortedMap&lt;K, V&gt; delegate) {
386     return newView(delegate, comparator);
387   }
388   private static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; newView(
389       SortedMap&lt;K, V&gt; delegate, Comparator&lt;? super K&gt; comparator) {
390     return new ImmutableSortedMap&lt;K, V&gt;(delegate, comparator);
391   }
392   /*
393    * We don't permit nulls, but we wrap every comparator with nullsFirst().
394    * Why? We want for queries like containsKey(null) to return false, but the
395    * GWT SortedMap implementation that we delegate to throws
396    * NullPointerException if the comparator does. Since our construction
397    * methods ensure that null is never present in the map, it's OK for the
398    * comparator to look for it wherever it wants.
399    *
400    * Note that we do NOT touch the comparator returned by comparator(), which
401    * should be identical to the one the user passed in. We touch only the
402    * "secret" comparator used by the delegate implementation.
403    */
404   private static &lt;K, V&gt; SortedMap&lt;K, V&gt; newModifiableDelegate(Comparator&lt;? super K&gt; comparator) {
405     return newTreeMap(nullAccepting(comparator));
406   }
407   private static &lt;E&gt; Comparator&lt;E&gt; nullAccepting(Comparator&lt;E&gt; comparator) {
408     return Ordering.from(comparator).nullsFirst();
409   }
410 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
