<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for FinalizableReferenceQueueClassLoaderUnloadingTest.java & ImmutableSortedMap.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for FinalizableReferenceQueueClassLoaderUnloadingTest.java & ImmutableSortedMap.java
      </h3>
      <h1 align="center">
        2.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>FinalizableReferenceQueueClassLoaderUnloadingTest.java (4.6153846%)<TH>ImmutableSortedMap.java (1.9582245%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1817211-0.html#0',2,'match1817211-1.html#0',3)" NAME="0">(17-33)<TD><A HREF="javascript:ZweiFrames('match1817211-0.html#0',2,'match1817211-1.html#0',3)" NAME="0">(17-33)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FinalizableReferenceQueueClassLoaderUnloadingTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2005 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1817211-1.html#0',3,'match1817211-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.base;

import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
import static com.google.common.base.StandardSystemProperty.JAVA_SPECIFICATION_VERSION;
import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;

import com.google.common.collect.ImmutableList;
import com.google.common.testing.GcFinalization;
import java.io.Closeable;
import java.io.File;
import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import</B></FONT> java.security.Permission;
import java.security.Policy;
import java.security.ProtectionDomain;
import java.util.concurrent.Callable;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import junit.framework.TestCase;

/**
 * Tests that the {@code ClassLoader} of {@link FinalizableReferenceQueue} can be unloaded. These
 * tests are separate from {@link FinalizableReferenceQueueTest} so that they can be excluded from
 * coverage runs, as the coverage system interferes with them.
 *
 * @author Eamonn McManus
 */


public class FinalizableReferenceQueueClassLoaderUnloadingTest extends TestCase {

  /*
   * The following tests check that the use of FinalizableReferenceQueue does not prevent the
   * ClassLoader that loaded that class from later being garbage-collected. If anything continues
   * to reference the FinalizableReferenceQueue class then its ClassLoader cannot be
   * garbage-collected, even if there are no more instances of FinalizableReferenceQueue itself.
   * The code in FinalizableReferenceQueue goes to considerable trouble to ensure that there are
   * no such references and the tests here check that that trouble has not been in vain.
   *
   * When we reference FinalizableReferenceQueue in this test, we are referencing a class that is
   * loaded by this test and that will obviously remain loaded for as long as the test is running.
   * So in order to check ClassLoader garbage collection we need to create a new ClassLoader and
   * make it load its own version of FinalizableReferenceQueue. Then we need to interact with that
   * parallel version through reflection in order to exercise the parallel
   * FinalizableReferenceQueue, and then check that the parallel ClassLoader can be
   * garbage-collected after that.
   */

  public static class MyFinalizableWeakReference extends FinalizableWeakReference&lt;Object&gt; {
    public MyFinalizableWeakReference(Object x, FinalizableReferenceQueue queue) {
      super(x, queue);
    }

    @Override
    public void finalizeReferent() {}
  }

  private static class PermissivePolicy extends Policy {
    @Override
    public boolean implies(ProtectionDomain pd, Permission perm) {
      return true;
    }
  }

  private WeakReference&lt;ClassLoader&gt; useFrqInSeparateLoader() throws Exception {
    final ClassLoader myLoader = getClass().getClassLoader();
    URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent());
    // sepLoader is the loader that we will use to load the parallel FinalizableReferenceQueue (FRQ)
    // and friends, and that we will eventually expect to see garbage-collected. The assumption
    // is that the ClassLoader of this test is a URLClassLoader, and that it loads FRQ itself
    // rather than delegating to a parent ClassLoader. If this assumption is violated the test will
    // fail and will need to be rewritten.

    Class&lt;?&gt; frqC = FinalizableReferenceQueue.class;
    Class&lt;?&gt; sepFrqC = sepLoader.loadClass(frqC.getName());
    assertNotSame(frqC, sepFrqC);
    // Check the assumptions above.

    // FRQ tries to load the Finalizer class (for the reference-collecting thread) in a few ways.
    // If the class is accessible to the system ClassLoader (ClassLoader.getSystemClassLoader())
    // then FRQ does not bother to load Finalizer.class through a separate ClassLoader. That happens
    // in our test environment, which foils the purpose of this test, so we disable the logic for
    // our test by setting a static field. We are changing the field in the parallel version of FRQ
    // and each test creates its own one of those, so there is no test interference here.
    Class&lt;?&gt; sepFrqSystemLoaderC =
        sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());
    Field disabled = sepFrqSystemLoaderC.getDeclaredField(&quot;disabled&quot;);
    disabled.setAccessible(true);
    disabled.set(null, true);

    // Now make a parallel FRQ and an associated FinalizableWeakReference to an object, in order to
    // exercise some classes from the parallel ClassLoader.
    AtomicReference&lt;Object&gt; sepFrqA =
        new AtomicReference&lt;Object&gt;(sepFrqC.getDeclaredConstructor().newInstance());
    Class&lt;?&gt; sepFwrC = sepLoader.loadClass(MyFinalizableWeakReference.class.getName());
    Constructor&lt;?&gt; sepFwrCons = sepFwrC.getConstructor(Object.class, sepFrqC);
    // The object that we will wrap in FinalizableWeakReference is a Stopwatch.
    Class&lt;?&gt; sepStopwatchC = sepLoader.loadClass(Stopwatch.class.getName());
    assertSame(sepLoader, sepStopwatchC.getClassLoader());
    AtomicReference&lt;Object&gt; sepStopwatchA =
        new AtomicReference&lt;Object&gt;(sepStopwatchC.getMethod(&quot;createUnstarted&quot;).invoke(null));
    AtomicReference&lt;WeakReference&lt;?&gt;&gt; sepStopwatchRef =
        new AtomicReference&lt;WeakReference&lt;?&gt;&gt;(
            (WeakReference&lt;?&gt;) sepFwrCons.newInstance(sepStopwatchA.get(), sepFrqA.get()));
    assertNotNull(sepStopwatchA.get());
    // Clear all references to the Stopwatch and wait for it to be gc'd.
    sepStopwatchA.set(null);
    GcFinalization.awaitClear(sepStopwatchRef.get());
    // Return a weak reference to the parallel ClassLoader. This is the reference that should
    // eventually become clear if there are no other references to the ClassLoader.
    return new WeakReference&lt;ClassLoader&gt;(sepLoader);
  }

  private void doTestUnloadable() throws Exception {
    WeakReference&lt;ClassLoader&gt; loaderRef = useFrqInSeparateLoader();
    GcFinalization.awaitClear(loaderRef);
  }

  /**
   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
   * loader of that class from being garbage-collected.
   */
  public void testUnloadableWithoutSecurityManager() throws Exception {
    if (isJdk9OrHigher()) {
      return;
    }
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      System.setSecurityManager(null);
      doTestUnloadable();
    } finally {
      System.setSecurityManager(oldSecurityManager);
    }
  }

  /**
   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
   * loader of that class from being garbage-collected even if there is a {@link SecurityManager}.
   * The {@link SecurityManager} environment makes such leaks more likely because when you create a
   * {@link URLClassLoader} with a {@link SecurityManager}, the creating code's {@link
   * java.security.AccessControlContext} is captured, and that references the creating code's {@link
   * ClassLoader}.
   */
  public void testUnloadableWithSecurityManager() throws Exception {
    if (isJdk9OrHigher()) {
      return;
    }
    Policy oldPolicy = Policy.getPolicy();
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      Policy.setPolicy(new PermissivePolicy());
      System.setSecurityManager(new SecurityManager());
      doTestUnloadable();
    } finally {
      System.setSecurityManager(oldSecurityManager);
      Policy.setPolicy(oldPolicy);
    }
  }

  public static class FrqUser implements Callable&lt;WeakReference&lt;Object&gt;&gt; {
    public static FinalizableReferenceQueue frq = new FinalizableReferenceQueue();
    public static final Semaphore finalized = new Semaphore(0);

    @Override
    public WeakReference&lt;Object&gt; call() {
      WeakReference&lt;Object&gt; wr =
          new FinalizableWeakReference&lt;Object&gt;(new Integer(23), frq) {
            @Override
            public void finalizeReferent() {
              finalized.release();
            }
          };
      return wr;
    }
  }

  public void testUnloadableInStaticFieldIfClosed() throws Exception {
    if (isJdk9OrHigher()) {
      return;
    }
    Policy oldPolicy = Policy.getPolicy();
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      Policy.setPolicy(new PermissivePolicy());
      System.setSecurityManager(new SecurityManager());
      WeakReference&lt;ClassLoader&gt; loaderRef = doTestUnloadableInStaticFieldIfClosed();
      GcFinalization.awaitClear(loaderRef);
    } finally {
      System.setSecurityManager(oldSecurityManager);
      Policy.setPolicy(oldPolicy);
    }
  }

  // If you have a FinalizableReferenceQueue that is a static field of one of the classes of your
  // app (like the FrqUser class above), then the app's ClassLoader will never be gc'd. The reason
  // is that we attempt to run a thread in a separate ClassLoader that will detect when the FRQ
  // is no longer referenced, meaning that the app's ClassLoader has been gc'd, and when that
  // happens. But the thread's supposedly separate ClassLoader actually has a reference to the app's
  // ClasLoader via its AccessControlContext. It does not seem to be possible to make a
  // URLClassLoader without capturing this reference, and it probably would not be desirable for
  // security reasons anyway. Therefore, the FRQ.close() method provides a way to stop the thread
  // explicitly. This test checks that calling that method does allow an app's ClassLoader to be
  // gc'd even if there is a still a FinalizableReferenceQueue in a static field. (Setting the field
  // to null would also work, but only if there are no references to the FRQ anywhere else.)
  private WeakReference&lt;ClassLoader&gt; doTestUnloadableInStaticFieldIfClosed() throws Exception {
    final ClassLoader myLoader = getClass().getClassLoader();
    URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent());

    Class&lt;?&gt; frqC = FinalizableReferenceQueue.class;
    Class&lt;?&gt; sepFrqC = sepLoader.loadClass(frqC.getName());
    assertNotSame(frqC, sepFrqC);

    Class&lt;?&gt; sepFrqSystemLoaderC =
        sepLoader.loadClass(FinalizableReferenceQueue.SystemLoader.class.getName());
    Field disabled = sepFrqSystemLoaderC.getDeclaredField(&quot;disabled&quot;);
    disabled.setAccessible(true);
    disabled.set(null, true);

    Class&lt;?&gt; frqUserC = FrqUser.class;
    Class&lt;?&gt; sepFrqUserC = sepLoader.loadClass(frqUserC.getName());
    assertNotSame(frqUserC, sepFrqUserC);
    assertSame(sepLoader, sepFrqUserC.getClassLoader());

    Callable&lt;?&gt; sepFrqUser = (Callable&lt;?&gt;) sepFrqUserC.getDeclaredConstructor().newInstance();
    WeakReference&lt;?&gt; finalizableWeakReference = (WeakReference&lt;?&gt;) sepFrqUser.call();

    GcFinalization.awaitClear(finalizableWeakReference);

    Field sepFrqUserFinalizedF = sepFrqUserC.getField(&quot;finalized&quot;);
    Semaphore finalizeCount = (Semaphore) sepFrqUserFinalizedF.get(null);
    boolean finalized = finalizeCount.tryAcquire(5, TimeUnit.SECONDS);
    assertTrue(finalized);

    Field sepFrqUserFrqF = sepFrqUserC.getField(&quot;frq&quot;);
    Closeable frq = (Closeable) sepFrqUserFrqF.get(null);
    frq.close();

    return new WeakReference&lt;ClassLoader&gt;(sepLoader);
  }

  private URL[] getClassPathUrls() {
    ClassLoader classLoader = getClass().getClassLoader();
    return classLoader instanceof URLClassLoader
        ? ((URLClassLoader) classLoader).getURLs()
        : parseJavaClassPath().toArray(new URL[0]);
  }

  /**
   * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain
   * System#getProperty system property}.
   */
  // TODO(b/65488446): Make this a public API.
  private static ImmutableList&lt;URL&gt; parseJavaClassPath() {
    ImmutableList.Builder&lt;URL&gt; urls = ImmutableList.builder();
    for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {
      try {
        try {
          urls.add(new File(entry).toURI().toURL());
        } catch (SecurityException e) { // File.toURI checks to see if the file is a directory
          urls.add(new URL(&quot;file&quot;, null, new File(entry).getAbsolutePath()));
        }
      } catch (MalformedURLException e) {
        AssertionError error = new AssertionError(&quot;malformed class path entry: &quot; + entry);
        error.initCause(e);
        throw error;
      }
    }
    return urls.build();
  }

  /**
   * These tests fail in JDK 9 and JDK 10 for an unknown reason. It might be the test; it might be
   * the underlying functionality. Fixing this is not a high priority; if you need it to be fixed,
   * please comment on &lt;a href=&quot;https://github.com/google/guava/issues/3086&quot;&gt;issue 3086&lt;/a&gt;.
   */
  private static boolean isJdk9OrHigher() {
    return JAVA_SPECIFICATION_VERSION.value().startsWith(&quot;9&quot;)
        || JAVA_SPECIFICATION_VERSION.value().startsWith(&quot;10&quot;);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1817211-0.html#0',2,'match1817211-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Maps.newTreeMap;
import static java.util.Collections.singletonMap;
import static java.util.Collections.unmodifiableSortedMap;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collector;
import</B></FONT> java.util.stream.Collectors;

/**
 * GWT emulated version of {@link com.google.common.collect.ImmutableSortedMap}. It's a thin wrapper
 * around a {@link java.util.TreeMap}.
 *
 * @author Hayward Chan
 */
public final class ImmutableSortedMap&lt;K, V&gt; extends ForwardingImmutableMap&lt;K, V&gt;
    implements SortedMap&lt;K, V&gt; {

  @SuppressWarnings(&quot;unchecked&quot;)
  static final Comparator NATURAL_ORDER = Ordering.natural();

  // This reference is only used by GWT compiler to infer the keys and values
  // of the map that needs to be serialized.
  private Comparator&lt;? super K&gt; unusedComparatorForSerialization;
  private K unusedKeyForSerialization;
  private V unusedValueForSerialization;

  private final transient SortedMap&lt;K, V&gt; sortedDelegate;

  // The comparator used by this map.  It's the same as that of sortedDelegate,
  // except that when sortedDelegate's comparator is null, it points to a
  // non-null instance of Ordering.natural().
  // (cpovirk: Is sortedDelegate's comparator really ever null?)
  // The comparator will likely also differ because of our nullAccepting hack.
  // See the bottom of the file for more information about it.
  private final transient Comparator&lt;? super K&gt; comparator;

  ImmutableSortedMap(SortedMap&lt;K, V&gt; delegate, Comparator&lt;? super K&gt; comparator) {
    super(delegate);
    this.comparator = comparator;
    this.sortedDelegate = delegate;
  }

  public static &lt;T, K, V&gt; Collector&lt;T, ?, ImmutableSortedMap&lt;K, V&gt;&gt; toImmutableSortedMap(
      Comparator&lt;? super K&gt; comparator,
      Function&lt;? super T, ? extends K&gt; keyFunction,
      Function&lt;? super T, ? extends V&gt; valueFunction) {
    return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction);
  }

  public static &lt;T, K, V&gt; Collector&lt;T, ?, ImmutableSortedMap&lt;K, V&gt;&gt; toImmutableSortedMap(
      Comparator&lt;? super K&gt; comparator,
      Function&lt;? super T, ? extends K&gt; keyFunction,
      Function&lt;? super T, ? extends V&gt; valueFunction,
      BinaryOperator&lt;V&gt; mergeFunction) {
    checkNotNull(comparator);
    checkNotNull(keyFunction);
    checkNotNull(valueFunction);
    checkNotNull(mergeFunction);
    return Collectors.collectingAndThen(
        Collectors.toMap(
            keyFunction, valueFunction, mergeFunction, () -&gt; new TreeMap&lt;K, V&gt;(comparator)),
        ImmutableSortedMap::copyOfSorted);
  }

  // Casting to any type is safe because the set will never hold any elements.
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; of() {
    return new Builder&lt;K, V&gt;(NATURAL_ORDER).build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(K k1, V v1) {
    return copyOf(singletonMap(k1, v1));
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2) {
    return new Builder&lt;K, V&gt;(Ordering.natural()).put(k1, v1).put(k2, v2).build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2, K k3, V v3) {
    return new Builder&lt;K, V&gt;(Ordering.natural()).put(k1, v1).put(k2, v2).put(k3, v3).build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .put(k6, v6)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .put(k6, v6)
        .put(k7, v7)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1,
      V v1,
      K k2,
      V v2,
      K k3,
      V v3,
      K k4,
      V v4,
      K k5,
      V v5,
      K k6,
      V v6,
      K k7,
      V v7,
      K k8,
      V v8) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .put(k6, v6)
        .put(k7, v7)
        .put(k8, v8)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1,
      V v1,
      K k2,
      V v2,
      K k3,
      V v3,
      K k4,
      V v4,
      K k5,
      V v5,
      K k6,
      V v6,
      K k7,
      V v7,
      K k8,
      V v8,
      K k9,
      V v9) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .put(k6, v6)
        .put(k7, v7)
        .put(k8, v8)
        .put(k9, v9)
        .build();
  }

  public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; of(
      K k1,
      V v1,
      K k2,
      V v2,
      K k3,
      V v3,
      K k4,
      V v4,
      K k5,
      V v5,
      K k6,
      V v6,
      K k7,
      V v7,
      K k8,
      V v8,
      K k9,
      V v9,
      K k10,
      V v10) {
    return new Builder&lt;K, V&gt;(Ordering.natural())
        .put(k1, v1)
        .put(k2, v2)
        .put(k3, v3)
        .put(k4, v4)
        .put(k5, v5)
        .put(k6, v6)
        .put(k7, v7)
        .put(k8, v8)
        .put(k9, v9)
        .put(k10, v10)
        .build();
  }

  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) {
    return copyOfInternal((Map) map, (Ordering&lt;K&gt;) Ordering.natural());
  }

  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
      Map&lt;? extends K, ? extends V&gt; map, Comparator&lt;? super K&gt; comparator) {
    return copyOfInternal(map, checkNotNull(comparator));
  }

  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
      Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries) {
    return new Builder&lt;K, V&gt;(NATURAL_ORDER).putAll(entries).build();
  }

  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOf(
      Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries,
      Comparator&lt;? super K&gt; comparator) {
    return new Builder&lt;K, V&gt;(comparator).putAll(entries).build();
  }

  public static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOfSorted(SortedMap&lt;K, ? extends V&gt; map) {
    // If map has a null comparator, the keys should have a natural ordering,
    // even though K doesn't explicitly implement Comparable.
    @SuppressWarnings(&quot;unchecked&quot;)
    Comparator&lt;? super K&gt; comparator =
        (map.comparator() == null) ? NATURAL_ORDER : map.comparator();
    return copyOfInternal(map, comparator);
  }

  private static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; copyOfInternal(
      Map&lt;? extends K, ? extends V&gt; map, Comparator&lt;? super K&gt; comparator) {

    if (map instanceof ImmutableSortedMap) {
      // TODO: Prove that this cast is safe, even though
      // Collections.unmodifiableSortedMap requires the same key type.
      @SuppressWarnings(&quot;unchecked&quot;)
      ImmutableSortedMap&lt;K, V&gt; kvMap = (ImmutableSortedMap&lt;K, V&gt;) map;
      Comparator&lt;?&gt; comparator2 = kvMap.comparator();
      boolean sameComparator =
          (comparator2 == null) ? comparator == NATURAL_ORDER : comparator.equals(comparator2);
      if (sameComparator) {
        return kvMap;
      }
    }

    SortedMap&lt;K, V&gt; delegate = newModifiableDelegate(comparator);
    for (Entry&lt;? extends K, ? extends V&gt; entry : map.entrySet()) {
      putEntryWithChecks(delegate, entry);
    }
    return newView(unmodifiableSortedMap(delegate), comparator);
  }

  private static &lt;K, V&gt; void putEntryWithChecks(
      SortedMap&lt;K, V&gt; map, Entry&lt;? extends K, ? extends V&gt; entry) {
    K key = checkNotNull(entry.getKey());
    V value = checkNotNull(entry.getValue());
    if (map.containsKey(key)) {
      // When a collision happens, the colliding entry is the first entry
      // of the tail map.
      Entry&lt;K, V&gt; previousEntry = map.tailMap(key).entrySet().iterator().next();
      throw new IllegalArgumentException(
          &quot;Duplicate keys in mappings &quot;
              + previousEntry.getKey()
              + &quot;=&quot;
              + previousEntry.getValue()
              + &quot; and &quot;
              + key
              + &quot;=&quot;
              + value);
    }
    map.put(key, value);
  }

  public static &lt;K extends Comparable&lt;?&gt;, V&gt; Builder&lt;K, V&gt; naturalOrder() {
    return new Builder&lt;K, V&gt;(Ordering.natural());
  }

  public static &lt;K, V&gt; Builder&lt;K, V&gt; orderedBy(Comparator&lt;K&gt; comparator) {
    return new Builder&lt;K, V&gt;(comparator);
  }

  public static &lt;K extends Comparable&lt;?&gt;, V&gt; Builder&lt;K, V&gt; reverseOrder() {
    return new Builder&lt;K, V&gt;(Ordering.natural().reverse());
  }

  public static final class Builder&lt;K, V&gt; extends ImmutableMap.Builder&lt;K, V&gt; {
    private final Comparator&lt;? super K&gt; comparator;

    public Builder(Comparator&lt;? super K&gt; comparator) {
      this.comparator = checkNotNull(comparator);
    }

    @Override
    public Builder&lt;K, V&gt; put(K key, V value) {
      entries.add(entryOf(key, value));
      return this;
    }

    @Override
    public Builder&lt;K, V&gt; put(Entry&lt;? extends K, ? extends V&gt; entry) {
      super.put(entry);
      return this;
    }

    @Override
    public Builder&lt;K, V&gt; putAll(Map&lt;? extends K, ? extends V&gt; map) {
      return putAll(map.entrySet());
    }

    @Override
    public Builder&lt;K, V&gt; putAll(Iterable&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries) {
      for (Entry&lt;? extends K, ? extends V&gt; entry : entries) {
        put(entry);
      }
      return this;
    }

    Builder&lt;K, V&gt; combine(Builder&lt;K, V&gt; other) {
      super.combine(other);
      return this;
    }

    @Override
    public Builder&lt;K, V&gt; orderEntriesByValue(Comparator&lt;? super V&gt; valueComparator) {
      throw new UnsupportedOperationException(&quot;Not available on ImmutableSortedMap.Builder&quot;);
    }

    @Override
    public ImmutableSortedMap&lt;K, V&gt; build() {
      return buildOrThrow();
    }

    @Override
    public ImmutableSortedMap&lt;K, V&gt; buildOrThrow() {
      SortedMap&lt;K, V&gt; delegate = newModifiableDelegate(comparator);
      for (Entry&lt;? extends K, ? extends V&gt; entry : entries) {
        putEntryWithChecks(delegate, entry);
      }
      return newView(unmodifiableSortedMap(delegate), comparator);
    }
  }

  private transient ImmutableSortedSet&lt;K&gt; keySet;

  @Override
  public ImmutableSortedSet&lt;K&gt; keySet() {
    ImmutableSortedSet&lt;K&gt; ks = keySet;
    return (ks == null) ? (keySet = createKeySet()) : ks;
  }

  @Override
  ImmutableSortedSet&lt;K&gt; createKeySet() {
    // the keySet() of the delegate is only a Set and TreeMap.navigatableKeySet
    // is not available in GWT yet.  To keep the code simple and code size more,
    // we make a copy here, instead of creating a view of it.
    //
    // TODO: revisit if it's unbearably slow or when GWT supports
    // TreeMap.navigatbleKeySet().
    return ImmutableSortedSet.copyOf(comparator, sortedDelegate.keySet());
  }

  public Comparator&lt;? super K&gt; comparator() {
    return comparator;
  }

  public K firstKey() {
    return sortedDelegate.firstKey();
  }

  public K lastKey() {
    return sortedDelegate.lastKey();
  }

  K higher(K k) {
    Iterator&lt;K&gt; iterator = keySet().tailSet(k).iterator();
    while (iterator.hasNext()) {
      K tmp = iterator.next();
      if (comparator().compare(k, tmp) &lt; 0) {
        return tmp;
      }
    }
    return null;
  }

  public ImmutableSortedMap&lt;K, V&gt; headMap(K toKey) {
    checkNotNull(toKey);
    return newView(sortedDelegate.headMap(toKey));
  }

  ImmutableSortedMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) {
    checkNotNull(toKey);
    if (inclusive) {
      K tmp = higher(toKey);
      if (tmp == null) {
        return this;
      }
      toKey = tmp;
    }
    return headMap(toKey);
  }

  public ImmutableSortedMap&lt;K, V&gt; subMap(K fromKey, K toKey) {
    checkNotNull(fromKey);
    checkNotNull(toKey);
    checkArgument(comparator.compare(fromKey, toKey) &lt;= 0);
    return newView(sortedDelegate.subMap(fromKey, toKey));
  }

  ImmutableSortedMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
    checkNotNull(fromKey);
    checkNotNull(toKey);
    checkArgument(comparator.compare(fromKey, toKey) &lt;= 0);
    return tailMap(fromKey, fromInclusive).headMap(toKey, toInclusive);
  }

  public ImmutableSortedMap&lt;K, V&gt; tailMap(K fromKey) {
    checkNotNull(fromKey);
    return newView(sortedDelegate.tailMap(fromKey));
  }

  public ImmutableSortedMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) {
    checkNotNull(fromKey);
    if (!inclusive) {
      fromKey = higher(fromKey);
      if (fromKey == null) {
        return new Builder&lt;K, V&gt;(this.comparator).build();
      }
    }
    return tailMap(fromKey);
  }

  private ImmutableSortedMap&lt;K, V&gt; newView(SortedMap&lt;K, V&gt; delegate) {
    return newView(delegate, comparator);
  }

  private static &lt;K, V&gt; ImmutableSortedMap&lt;K, V&gt; newView(
      SortedMap&lt;K, V&gt; delegate, Comparator&lt;? super K&gt; comparator) {
    return new ImmutableSortedMap&lt;K, V&gt;(delegate, comparator);
  }

  /*
   * We don't permit nulls, but we wrap every comparator with nullsFirst().
   * Why? We want for queries like containsKey(null) to return false, but the
   * GWT SortedMap implementation that we delegate to throws
   * NullPointerException if the comparator does. Since our construction
   * methods ensure that null is never present in the map, it's OK for the
   * comparator to look for it wherever it wants.
   *
   * Note that we do NOT touch the comparator returned by comparator(), which
   * should be identical to the one the user passed in. We touch only the
   * &quot;secret&quot; comparator used by the delegate implementation.
   */

  private static &lt;K, V&gt; SortedMap&lt;K, V&gt; newModifiableDelegate(Comparator&lt;? super K&gt; comparator) {
    return newTreeMap(nullAccepting(comparator));
  }

  private static &lt;E&gt; Comparator&lt;E&gt; nullAccepting(Comparator&lt;E&gt; comparator) {
    return Ordering.from(comparator).nullsFirst();
  }
}
</PRE>
</div>
  </div>
</body>
</html>
