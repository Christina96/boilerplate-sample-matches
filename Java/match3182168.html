<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for AbstractXContentTestCaseTests.java & WhereClauseAnalyzerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for AbstractXContentTestCaseTests.java & WhereClauseAnalyzerTest.java
      </h3>
      <h1 align="center">
        6.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>AbstractXContentTestCaseTests.java (47.826088%)<TH>WhereClauseAnalyzerTest.java (3.7225041%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3182168-0.html#0',2,'match3182168-1.html#0',3)" NAME="0">(52-55)<TD><A HREF="javascript:ZweiFrames('match3182168-0.html#0',2,'match3182168-1.html#0',3)" NAME="0">(314-317)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match3182168-0.html#1',2,'match3182168-1.html#1',3)" NAME="1">(20-33)<TD><A HREF="javascript:ZweiFrames('match3182168-0.html#1',2,'match3182168-1.html#1',3)" NAME="1">(22-32)</A><TD ALIGN=center><FONT COLOR="#d40000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractXContentTestCaseTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="1"></A> * under the License.
 */

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match3182168-1.html#1',3,'match3182168-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.test;

import com.carrotsearch.randomizedtesting.RandomizedContext;

import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.common.xcontent.XContentType;

import java.util.Map;

import static org.hamcrest.Matchers.equalTo;
import</B></FONT> static org.hamcrest.Matchers.not;

public class AbstractXContentTestCaseTests extends ESTestCase {

    public void testInsertRandomFieldsAndShuffle() throws Exception {
        XContentBuilder builder = XContentFactory.jsonBuilder();
        builder.startObject();
        {
            builder.field(&quot;field&quot;, 1);
        }
        builder.endObject();
        BytesReference insertRandomFieldsAndShuffle = RandomizedContext.current().runWithPrivateRandomness(1,
                () -&gt; AbstractXContentTestCase.insertRandomFieldsAndShuffle(
                        BytesReference.bytes(builder),
                        XContentType.JSON,
                        true,
<A NAME="0"></A>                        new String[] {},
                        null,
                        this::createParser));
        try (XContentParser parser = createParser(XContentType.JSON.xContent(), insertRandomFieldsAndShuffle)) <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3182168-1.html#0',3,'match3182168-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            Map&lt;String, Object&gt; mapOrdered = parser.mapOrdered();
            assertThat(mapOrdered.size(), equalTo(2));
            assertThat(mapOrdered.keySet().iterator().next(), not(equalTo</B></FONT>(&quot;field&quot;)));
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>WhereClauseAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="1"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3182168-0.html#1',2,'match3182168-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.analyze.where;

import io.crate.action.sql.SessionContext;
import io.crate.analyze.AnalyzedUpdateStatement;
import io.crate.analyze.QueriedSelectRelation;
import io.crate.analyze.WhereClause;
import io.crate.analyze.relations.AnalyzedRelation;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.data.Row;
import io.crate.exceptions.VersioningValidationException;
import</B></FONT> io.crate.expression.eval.EvaluatingNormalizer;
import io.crate.expression.operator.EqOperator;
import io.crate.expression.operator.LikeOperators;
import io.crate.expression.operator.any.AnyEqOperator;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.PartitionName;
import io.crate.metadata.RelationName;
import io.crate.metadata.RowGranularity;
import io.crate.metadata.doc.DocSchemaInfo;
import io.crate.planner.WhereClauseOptimizer;
import io.crate.planner.operators.SubQueryResults;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.ArrayType;
import io.crate.types.DataTypes;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static io.crate.testing.SymbolMatchers.isFunction;
import static io.crate.testing.SymbolMatchers.isLiteral;
import static io.crate.testing.SymbolMatchers.isReference;
import static io.crate.testing.TestingHelpers.isSQL;
import static java.util.Collections.singletonList;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.is;

public class WhereClauseAnalyzerTest extends CrateDummyClusterServiceUnitTest {

    private final CoordinatorTxnCtx coordinatorTxnCtx = new CoordinatorTxnCtx(SessionContext.systemSessionContext());
    private SQLExecutor e;

    @Before
    public void prepare() throws IOException {
        SQLExecutor.Builder builder = SQLExecutor.builder(clusterService);
        registerTables(builder);

        RelationName docGeneratedCol = new RelationName(&quot;doc&quot;, &quot;generated_col&quot;);
        builder.addPartitionedTable(
            &quot;create table doc.generated_col (&quot; +
            &quot;   ts timestamp with time zone ,&quot; +
            &quot;   x integer,&quot; +
            &quot;   y long,&quot; +
            &quot;   day as date_trunc('day', ts),&quot; +
            &quot;   minus_y as y * -1,&quot; +
            &quot;   x_incr as x + 1&quot; +
            &quot;) partitioned by (day, minus_y)&quot;,
            new PartitionName(docGeneratedCol, Arrays.asList(&quot;1420070400000&quot;, &quot;-1&quot;)).asIndexName(),
            new PartitionName(docGeneratedCol, Arrays.asList(&quot;1420156800000&quot;, &quot;-2&quot;)).asIndexName()
        );
        RelationName docDoubleGenParted = new RelationName(DocSchemaInfo.NAME, &quot;double_gen_parted&quot;);
        builder.addPartitionedTable(
            &quot;create table doc.double_gen_parted (&quot; +
            &quot;   x integer,&quot; +
            &quot;   x1 as x + 1,&quot; +
            &quot;   x2 as x + 2&quot; +
            &quot;) partitioned by (x1, x2)&quot;,
                new PartitionName(docDoubleGenParted, Arrays.asList(&quot;4&quot;, &quot;5&quot;)).toString(),
                new PartitionName(docDoubleGenParted, Arrays.asList(&quot;5&quot;, &quot;6&quot;)).toString()
        );
        e = builder.build();
    }

    private void registerTables(SQLExecutor.Builder builder) throws IOException {
        builder.addTable(
            &quot;create table users (&quot; +
             &quot;  id string primary key,&quot; +
             &quot;  name string,&quot; +
             &quot;  tags array(string)&quot; +
             &quot;) clustered by (id)&quot;);
        RelationName docParted = new RelationName(&quot;doc&quot;, &quot;parted&quot;);
        builder.addPartitionedTable(
            &quot;create table doc.parted (&quot; +
            &quot;   id integer,&quot; +
            &quot;   name string,&quot; +
            &quot;   date timestamp with time zone,&quot; +
            &quot;   obj object (ignored)&quot; +
            &quot;) partitioned by (date)&quot;,
            new PartitionName(docParted, singletonList(&quot;1395874800000&quot;)).asIndexName(),
            new PartitionName(docParted, singletonList(&quot;1395961200000&quot;)).asIndexName(),
            new PartitionName(docParted, singletonList(null)).asIndexName()
        );
        builder.addTable(
            &quot;create table doc.users_multi_pk (&quot; +
            &quot;   id long primary key,&quot; +
            &quot;   name string primary key,&quot; +
            &quot;   details object,&quot; +
            &quot;   awesome boolean,&quot; +
            &quot;   friends array(object)&quot; +
            &quot;) clustered by (id)&quot;
        );
        builder.addTable(
            &quot;create table doc.pk4 (&quot; +
            &quot;   i1 integer primary key,&quot; +
            &quot;   i2 integer primary key,&quot; +
            &quot;   i3 integer primary key,&quot; +
            &quot;   i4 integer primary key&quot; +
            &quot;)&quot;
        );
    }

    private AnalyzedUpdateStatement analyzeUpdate(String stmt) {
        return e.analyze(stmt);
    }

    private WhereClause analyzeSelectWhere(String stmt) {
        AnalyzedRelation rel = e.analyze(stmt);

        if (rel instanceof QueriedSelectRelation) {
            QueriedSelectRelation queriedRelation = ((QueriedSelectRelation) rel);
            if (queriedRelation.from().get(0) instanceof DocTableRelation) {
                DocTableRelation docTableRelation = (DocTableRelation) queriedRelation.from().get(0);
                WhereClauseOptimizer.DetailedQuery detailedQuery = WhereClauseOptimizer.optimize(
                    new EvaluatingNormalizer(e.nodeCtx, RowGranularity.CLUSTER, null, docTableRelation),
                    queriedRelation.where(),
                    docTableRelation.tableInfo(),
                    coordinatorTxnCtx,
                    e.nodeCtx);
                return detailedQuery.toBoundWhereClause(
                    docTableRelation.tableInfo(),
                    Row.EMPTY,
                    SubQueryResults.EMPTY,
                    coordinatorTxnCtx,
                    e.nodeCtx);
            }
            return new WhereClause(queriedRelation.where());
        } else {
            return WhereClause.MATCH_ALL;
        }
    }

    @Test
    public void testSelectWherePartitionedByColumn() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select id from parted where date = 1395874800000&quot;);
        assertThat(whereClause.queryOrFallback(), isLiteral(true));
        assertThat(whereClause.partitions(),
            Matchers.contains(new PartitionName(new RelationName(&quot;doc&quot;, &quot;parted&quot;), Arrays.asList(&quot;1395874800000&quot;)).asIndexName()));
    }

    @Test
    public void testUpdateWherePartitionedByColumn() throws Exception {
        AnalyzedUpdateStatement update = analyzeUpdate(&quot;update parted set id = 2 where date = 1395874800000::timestamp&quot;);
        assertThat(update.query(), isFunction(EqOperator.NAME, isReference(&quot;date&quot;), isLiteral(1395874800000L)));
    }

    @Test
    public void testSelectFromPartitionedTable() throws Exception {
        String partition1 = new PartitionName(new RelationName(&quot;doc&quot;, &quot;parted&quot;), Arrays.asList(&quot;1395874800000&quot;)).asIndexName();
        String partition2 = new PartitionName(new RelationName(&quot;doc&quot;, &quot;parted&quot;), Arrays.asList(&quot;1395961200000&quot;)).asIndexName();
        String partition3 = new PartitionName(new RelationName(&quot;doc&quot;, &quot;parted&quot;), singletonList(null)).asIndexName();

        WhereClause whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395874800000&quot;);
        assertEquals(List.of(partition1), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395874800000 &quot; +
                                         &quot;and substr(name, 0, 4) = 'this'&quot;);
        assertEquals(List.of(partition1), whereClause.partitions());
        assertThat(whereClause.hasQuery(), is(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date &gt;= 1395874800000&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date &lt; 1395874800000&quot;);
        assertEquals(List.of(), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isLiteral(false));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395874800000 and date = 1395961200000&quot;);
        assertEquals(List.of(), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isLiteral(false));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395874800000 or date = 1395961200000&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date &lt; 1395874800000 or date &gt; 1395874800000&quot;);
        assertEquals(List.of(partition2), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date in (1395874800000, 1395961200000)&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date in (1395874800000, 1395961200000) and id = 1&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_=&quot;));

        /**
         *
         * obj['col'] = 'undefined' =&gt; null as col doesn't exist
         *
         *  partition1: not (true  and null) -&gt; not (null)  -&gt; null -&gt; no match
         *  partition2: not (false and null) -&gt; not (false) -&gt; true -&gt; match
         *  partition3: not (null  and null) -&gt; not (null)  -&gt; null -&gt; no match
         */
        whereClause = analyzeSelectWhere(&quot;select id, name from parted where not (date = 1395874800000 and obj['col'] = 'undefined')&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date in (1395874800000) or date in (1395961200000)&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395961200000 and id = 1&quot;);
        assertEquals(List.of(partition2), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_=&quot;));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where (date =1395874800000 or date = 1395961200000) and id = 1&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_=&quot;));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date = 1395874800000 and id is null&quot;);
        assertEquals(List.of(partition1), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_isnull&quot;));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where date is null and id = 1&quot;);
        assertEquals(List.of(partition3), whereClause.partitions());
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_=&quot;));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where 1395874700000 &lt; date and date &lt; 1395961200001&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));

        whereClause = analyzeSelectWhere(&quot;select id, name from parted where '2014-03-16T22:58:20' &lt; date and date &lt; '2014-03-27T23:00:01'&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
        assertThat(whereClause.queryOrFallback(), isLiteral(true));
    }

    @Test
    public void test_where_on_date_with_null_partition_or_id_can_match_all_partitions() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(
            &quot;select id, name from parted where date = 1395961200000::timestamp or id = 1&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(
            &quot;.partitioned.parted.0400&quot;,
            &quot;.partitioned.parted.04732cpp6ksjcc9i60o30c1g&quot;,
            &quot;.partitioned.parted.04732cpp6ks3ed1o60o30c1g&quot;
        ));
        assertThat(whereClause.queryOrFallback(), isSQL(&quot;((doc.parted.date = 1395961200000::bigint) OR (doc.parted.id = 1))&quot;));
    }

    @Test
    public void testAnyInvalidArrayType() throws Exception {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot cast `'foo'` of type `text` to type `boolean`&quot;);
        analyzeSelectWhere(&quot;select * from users_multi_pk where awesome = any(['foo', 'bar', 'baz'])&quot;);
    }

    @Test
    public void testInConvertedToAnyIfOnlyLiterals() throws Exception {
        StringBuilder sb = new StringBuilder(&quot;select id from sys.shards where id in (&quot;);
        int i = 0;
        for (; i &lt; 1500; i++) {
            sb.append(i);
            sb.append(',');
        }
        sb.append(i++);
        sb.append(')');
        String s = sb.toString();

        WhereClause whereClause = analyzeSelectWhere(s);
        assertThat(whereClause.query(), isFunction(AnyEqOperator.NAME,
                                                   List.of(DataTypes.INTEGER, new ArrayType&lt;&gt;(DataTypes.INTEGER))));
    }

    @Test
    public void testAnyLikeArrayLiteral() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from users where name like any(['a', 'b', 'c'])&quot;);
        assertThat(whereClause.query(), isFunction(LikeOperators.ANY_LIKE, List.of(DataTypes.STRING, new ArrayType&lt;&gt;(DataTypes.STRING))));
    }

    @Test
    public void testAnyILikeArrayLiteral() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from users where name ilike any(['a', 'b', 'c'])&quot;);
        assertThat(whereClause.query(), isFunction(LikeOperators.ANY_ILIKE, List.of(DataTypes.STRING, new ArrayType&lt;&gt;(DataTypes.STRING))));
<A NAME="0"></A>    }

    @Test
    public void testEqualGenColOptimization() throws Exception <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3182168-0.html#0',2,'match3182168-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where y = 1&quot;);
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(new PartitionName(new RelationName(&quot;doc&quot;, &quot;generated_col&quot;),</B></FONT>
            Arrays.asList(&quot;1420070400000&quot;, &quot;-1&quot;)).asIndexName()));
    }

    @Test
    public void testNonPartitionedNotOptimized() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where x = 1&quot;);
        assertThat(whereClause.query(), isSQL(&quot;(doc.generated_col.x = 1)&quot;));
    }

    @Test
    public void testGtGenColOptimization() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where ts &gt; '2015-01-02T12:00:00'&quot;);
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(new PartitionName(new RelationName(&quot;doc&quot;, &quot;generated_col&quot;),
            Arrays.asList(&quot;1420156800000&quot;, &quot;-2&quot;)).asIndexName()));
    }

    @Test
    public void testGenColRoundingFunctionNoSwappingOperatorOptimization() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where ts &gt;= '2015-01-02T12:00:00'&quot;);
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(new PartitionName(
            new RelationName(&quot;doc&quot;, &quot;generated_col&quot;), Arrays.asList(&quot;1420156800000&quot;, &quot;-2&quot;)).asIndexName()));
    }

    @Test
    public void testMultiplicationGenColNoOptimization() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where y &gt; 1&quot;);
        // no optimization is done
        assertThat(whereClause.partitions().size(), is(0));
        assertThat(whereClause.queryOrFallback(), isFunction(&quot;op_&gt;&quot;));
    }

    @Test
    public void testMultipleColumnsOptimization() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where ts &gt; '2015-01-01T12:00:00' and y = 1&quot;);
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(new PartitionName(
            new RelationName(&quot;doc&quot;, &quot;generated_col&quot;), Arrays.asList(&quot;1420070400000&quot;, &quot;-1&quot;)).asIndexName()));
    }

    @Test
    public void testColumnReferencedTwiceInGeneratedColumnPartitioned() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from double_gen_parted where x = 4&quot;);
        assertThat(whereClause.query(), isSQL(&quot;(doc.double_gen_parted.x = 4)&quot;));
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(&quot;.partitioned.double_gen_parted.0813a0hm&quot;));
    }

    @Test
    public void testOptimizationNonRoundingFunctionGreater() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from double_gen_parted where x &gt; 3&quot;);
        assertThat(whereClause.query(), isSQL(&quot;(doc.double_gen_parted.x &gt; 3)&quot;));
        assertThat(whereClause.partitions().size(), is(1));
        assertThat(whereClause.partitions().get(0), is(&quot;.partitioned.double_gen_parted.0813a0hm&quot;));
    }

    @Test
    public void testGenColRangeOptimization() throws Exception {
        WhereClause whereClause = analyzeSelectWhere(&quot;select * from generated_col where ts &gt;= '2015-01-01T12:00:00' and ts &lt;= '2015-01-02T00:00:00'&quot;);
        RelationName relationName = new RelationName(&quot;doc&quot;, &quot;generated_col&quot;);
        assertThat(whereClause.partitions(), containsInAnyOrder(
            new PartitionName(relationName, Arrays.asList(&quot;1420070400000&quot;, &quot;-1&quot;)).asIndexName(),
            new PartitionName(relationName, Arrays.asList(&quot;1420156800000&quot;, &quot;-2&quot;)).asIndexName())
        );
    }

    @Test
    public void testRawNotAllowedInQuery() throws Exception {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;The _raw column is not searchable and cannot be used inside a query&quot;);
        analyzeSelectWhere(&quot;select * from users where _raw = 'foo'&quot;);
    }

    @Test
    public void testVersionOnlySupportedWithEqualOperator() throws Exception {
        expectedException.expect(VersioningValidationException.class);
        expectedException.expectMessage(VersioningValidationException.VERSION_COLUMN_USAGE_MSG);
        analyzeSelectWhere(&quot;select * from users where _version &gt; 1&quot;);
    }

    @Test
    public void testSeqNoOnlySupportedWithEqualOperator() throws Exception {
        expectedException.expect(VersioningValidationException.class);
        expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
        analyzeSelectWhere(&quot;select * from users where _seq_no &gt; 1&quot;);
    }

    @Test
    public void testPrimaryTermOnlySupportedWithEqualOperator() throws Exception {
        expectedException.expect(VersioningValidationException.class);
        expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
        analyzeSelectWhere(&quot;select * from users where _primary_term &gt; 1&quot;);
    }

    @Test
    public void testSeqNoAndPrimaryTermAreRequired() {
        expectedException.expect(VersioningValidationException.class);
        expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
        analyzeSelectWhere(&quot;select * from users where name = 'Douglas' and _primary_term = 1&quot;);
    }

    @Test
    public void testVersioningMechanismsCannotBeMixed() {
        expectedException.expect(VersioningValidationException.class);
        expectedException.expectMessage(VersioningValidationException.MIXED_VERSIONING_COLUMNS_USAGE_MSG);
        analyzeSelectWhere(&quot;select * from users where name = 'Douglas' and _primary_term = 1 and _seq_no = 22 and _version = 1&quot;);
    }
}
</PRE>
</div>
  </div>
</body>
</html>
