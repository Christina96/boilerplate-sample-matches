<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractXContentTestCaseTests.java &amp; WhereClauseAnalyzerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractXContentTestCaseTests.java &amp; WhereClauseAnalyzerTest.java
      </h3>
<h1 align="center">
        6.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractXContentTestCaseTests.java (47.826088%)<th>WhereClauseAnalyzerTest.java (3.7225041%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(52-55)<td><a href="#" name="0">(314-317)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(20-33)<td><a href="#" name="1">(22-32)</a><td align="center"><font color="#d40000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractXContentTestCaseTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.test;
2 import com.carrotsearch.randomizedtesting.RandomizedContext;
3 import org.elasticsearch.common.bytes.BytesReference;
4 import org.elasticsearch.common.xcontent.XContentBuilder;
5 import org.elasticsearch.common.xcontent.XContentFactory;
6 import org.elasticsearch.common.xcontent.XContentParser;
7 import org.elasticsearch.common.xcontent.XContentType;
8 import java.util.Map;
9 import static org.hamcrest.Matchers.equalTo;
10 import</b></font> static org.hamcrest.Matchers.not;
11 public class AbstractXContentTestCaseTests extends ESTestCase {
12     public void testInsertRandomFieldsAndShuffle() throws Exception {
13         XContentBuilder builder = XContentFactory.jsonBuilder();
14         builder.startObject();
15         {
16             builder.field("field", 1);
17         }
18         builder.endObject();
19         BytesReference insertRandomFieldsAndShuffle = RandomizedContext.current().runWithPrivateRandomness(1,
20                 () -&gt; AbstractXContentTestCase.insertRandomFieldsAndShuffle(
21                         BytesReference.bytes(builder),
22                         XContentType.JSON,
23                         true,
24 <a name="0"></a>                        new String[] {},
25                         null,
26                         this::createParser));
27         try (XContentParser parser = createParser(XContentType.JSON.xContent(), insertRandomFieldsAndShuffle)) <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
28             Map&lt;String, Object&gt; mapOrdered = parser.mapOrdered();
29             assertThat(mapOrdered.size(), equalTo(2));
30             assertThat(mapOrdered.keySet().iterator().next(), not(equalTo</b></font>("field")));
31         }
32     }
33 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>WhereClauseAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.analyze.where;
2 import io.crate.action.sql.SessionContext;
3 import io.crate.analyze.AnalyzedUpdateStatement;
4 import io.crate.analyze.QueriedSelectRelation;
5 import io.crate.analyze.WhereClause;
6 import io.crate.analyze.relations.AnalyzedRelation;
7 import io.crate.analyze.relations.DocTableRelation;
8 import io.crate.data.Row;
9 import io.crate.exceptions.VersioningValidationException;
10 import</b></font> io.crate.expression.eval.EvaluatingNormalizer;
11 import io.crate.expression.operator.EqOperator;
12 import io.crate.expression.operator.LikeOperators;
13 import io.crate.expression.operator.any.AnyEqOperator;
14 import io.crate.metadata.CoordinatorTxnCtx;
15 import io.crate.metadata.PartitionName;
16 import io.crate.metadata.RelationName;
17 import io.crate.metadata.RowGranularity;
18 import io.crate.metadata.doc.DocSchemaInfo;
19 import io.crate.planner.WhereClauseOptimizer;
20 import io.crate.planner.operators.SubQueryResults;
21 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
22 import io.crate.testing.SQLExecutor;
23 import io.crate.types.ArrayType;
24 import io.crate.types.DataTypes;
25 import org.hamcrest.Matchers;
26 import org.junit.Before;
27 import org.junit.Test;
28 import java.io.IOException;
29 import java.util.Arrays;
30 import java.util.List;
31 import static io.crate.testing.SymbolMatchers.isFunction;
32 import static io.crate.testing.SymbolMatchers.isLiteral;
33 import static io.crate.testing.SymbolMatchers.isReference;
34 import static io.crate.testing.TestingHelpers.isSQL;
35 import static java.util.Collections.singletonList;
36 import static org.hamcrest.Matchers.containsInAnyOrder;
37 import static org.hamcrest.Matchers.is;
38 public class WhereClauseAnalyzerTest extends CrateDummyClusterServiceUnitTest {
39     private final CoordinatorTxnCtx coordinatorTxnCtx = new CoordinatorTxnCtx(SessionContext.systemSessionContext());
40     private SQLExecutor e;
41     @Before
42     public void prepare() throws IOException {
43         SQLExecutor.Builder builder = SQLExecutor.builder(clusterService);
44         registerTables(builder);
45         RelationName docGeneratedCol = new RelationName("doc", "generated_col");
46         builder.addPartitionedTable(
47             "create table doc.generated_col (" +
48             "   ts timestamp with time zone ," +
49             "   x integer," +
50             "   y long," +
51             "   day as date_trunc('day', ts)," +
52             "   minus_y as y * -1," +
53             "   x_incr as x + 1" +
54             ") partitioned by (day, minus_y)",
55             new PartitionName(docGeneratedCol, Arrays.asList("1420070400000", "-1")).asIndexName(),
56             new PartitionName(docGeneratedCol, Arrays.asList("1420156800000", "-2")).asIndexName()
57         );
58         RelationName docDoubleGenParted = new RelationName(DocSchemaInfo.NAME, "double_gen_parted");
59         builder.addPartitionedTable(
60             "create table doc.double_gen_parted (" +
61             "   x integer," +
62             "   x1 as x + 1," +
63             "   x2 as x + 2" +
64             ") partitioned by (x1, x2)",
65                 new PartitionName(docDoubleGenParted, Arrays.asList("4", "5")).toString(),
66                 new PartitionName(docDoubleGenParted, Arrays.asList("5", "6")).toString()
67         );
68         e = builder.build();
69     }
70     private void registerTables(SQLExecutor.Builder builder) throws IOException {
71         builder.addTable(
72             "create table users (" +
73              "  id string primary key," +
74              "  name string," +
75              "  tags array(string)" +
76              ") clustered by (id)");
77         RelationName docParted = new RelationName("doc", "parted");
78         builder.addPartitionedTable(
79             "create table doc.parted (" +
80             "   id integer," +
81             "   name string," +
82             "   date timestamp with time zone," +
83             "   obj object (ignored)" +
84             ") partitioned by (date)",
85             new PartitionName(docParted, singletonList("1395874800000")).asIndexName(),
86             new PartitionName(docParted, singletonList("1395961200000")).asIndexName(),
87             new PartitionName(docParted, singletonList(null)).asIndexName()
88         );
89         builder.addTable(
90             "create table doc.users_multi_pk (" +
91             "   id long primary key," +
92             "   name string primary key," +
93             "   details object," +
94             "   awesome boolean," +
95             "   friends array(object)" +
96             ") clustered by (id)"
97         );
98         builder.addTable(
99             "create table doc.pk4 (" +
100             "   i1 integer primary key," +
101             "   i2 integer primary key," +
102             "   i3 integer primary key," +
103             "   i4 integer primary key" +
104             ")"
105         );
106     }
107     private AnalyzedUpdateStatement analyzeUpdate(String stmt) {
108         return e.analyze(stmt);
109     }
110     private WhereClause analyzeSelectWhere(String stmt) {
111         AnalyzedRelation rel = e.analyze(stmt);
112         if (rel instanceof QueriedSelectRelation) {
113             QueriedSelectRelation queriedRelation = ((QueriedSelectRelation) rel);
114             if (queriedRelation.from().get(0) instanceof DocTableRelation) {
115                 DocTableRelation docTableRelation = (DocTableRelation) queriedRelation.from().get(0);
116                 WhereClauseOptimizer.DetailedQuery detailedQuery = WhereClauseOptimizer.optimize(
117                     new EvaluatingNormalizer(e.nodeCtx, RowGranularity.CLUSTER, null, docTableRelation),
118                     queriedRelation.where(),
119                     docTableRelation.tableInfo(),
120                     coordinatorTxnCtx,
121                     e.nodeCtx);
122                 return detailedQuery.toBoundWhereClause(
123                     docTableRelation.tableInfo(),
124                     Row.EMPTY,
125                     SubQueryResults.EMPTY,
126                     coordinatorTxnCtx,
127                     e.nodeCtx);
128             }
129             return new WhereClause(queriedRelation.where());
130         } else {
131             return WhereClause.MATCH_ALL;
132         }
133     }
134     @Test
135     public void testSelectWherePartitionedByColumn() throws Exception {
136         WhereClause whereClause = analyzeSelectWhere("select id from parted where date = 1395874800000");
137         assertThat(whereClause.queryOrFallback(), isLiteral(true));
138         assertThat(whereClause.partitions(),
139             Matchers.contains(new PartitionName(new RelationName("doc", "parted"), Arrays.asList("1395874800000")).asIndexName()));
140     }
141     @Test
142     public void testUpdateWherePartitionedByColumn() throws Exception {
143         AnalyzedUpdateStatement update = analyzeUpdate("update parted set id = 2 where date = 1395874800000::timestamp");
144         assertThat(update.query(), isFunction(EqOperator.NAME, isReference("date"), isLiteral(1395874800000L)));
145     }
146     @Test
147     public void testSelectFromPartitionedTable() throws Exception {
148         String partition1 = new PartitionName(new RelationName("doc", "parted"), Arrays.asList("1395874800000")).asIndexName();
149         String partition2 = new PartitionName(new RelationName("doc", "parted"), Arrays.asList("1395961200000")).asIndexName();
150         String partition3 = new PartitionName(new RelationName("doc", "parted"), singletonList(null)).asIndexName();
151         WhereClause whereClause = analyzeSelectWhere("select id, name from parted where date = 1395874800000");
152         assertEquals(List.of(partition1), whereClause.partitions());
153         assertThat(whereClause.queryOrFallback(), isLiteral(true));
154         whereClause = analyzeSelectWhere("select id, name from parted where date = 1395874800000 " +
155                                          "and substr(name, 0, 4) = 'this'");
156         assertEquals(List.of(partition1), whereClause.partitions());
157         assertThat(whereClause.hasQuery(), is(true));
158         whereClause = analyzeSelectWhere("select id, name from parted where date &gt;= 1395874800000");
159         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
160         assertThat(whereClause.queryOrFallback(), isLiteral(true));
161         whereClause = analyzeSelectWhere("select id, name from parted where date &lt; 1395874800000");
162         assertEquals(List.of(), whereClause.partitions());
163         assertThat(whereClause.queryOrFallback(), isLiteral(false));
164         whereClause = analyzeSelectWhere("select id, name from parted where date = 1395874800000 and date = 1395961200000");
165         assertEquals(List.of(), whereClause.partitions());
166         assertThat(whereClause.queryOrFallback(), isLiteral(false));
167         whereClause = analyzeSelectWhere("select id, name from parted where date = 1395874800000 or date = 1395961200000");
168         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
169         assertThat(whereClause.queryOrFallback(), isLiteral(true));
170         whereClause = analyzeSelectWhere("select id, name from parted where date &lt; 1395874800000 or date &gt; 1395874800000");
171         assertEquals(List.of(partition2), whereClause.partitions());
172         assertThat(whereClause.queryOrFallback(), isLiteral(true));
173         whereClause = analyzeSelectWhere("select id, name from parted where date in (1395874800000, 1395961200000)");
174         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
175         assertThat(whereClause.queryOrFallback(), isLiteral(true));
176         whereClause = analyzeSelectWhere("select id, name from parted where date in (1395874800000, 1395961200000) and id = 1");
177         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
178         assertThat(whereClause.queryOrFallback(), isFunction("op_="));
179         whereClause = analyzeSelectWhere("select id, name from parted where not (date = 1395874800000 and obj['col'] = 'undefined')");
180         assertThat(whereClause.partitions(), containsInAnyOrder(partition2));
181         assertThat(whereClause.queryOrFallback(), isLiteral(true));
182         whereClause = analyzeSelectWhere("select id, name from parted where date in (1395874800000) or date in (1395961200000)");
183         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
184         assertThat(whereClause.queryOrFallback(), isLiteral(true));
185         whereClause = analyzeSelectWhere("select id, name from parted where date = 1395961200000 and id = 1");
186         assertEquals(List.of(partition2), whereClause.partitions());
187         assertThat(whereClause.queryOrFallback(), isFunction("op_="));
188         whereClause = analyzeSelectWhere("select id, name from parted where (date =1395874800000 or date = 1395961200000) and id = 1");
189         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
190         assertThat(whereClause.queryOrFallback(), isFunction("op_="));
191         whereClause = analyzeSelectWhere("select id, name from parted where date = 1395874800000 and id is null");
192         assertEquals(List.of(partition1), whereClause.partitions());
193         assertThat(whereClause.queryOrFallback(), isFunction("op_isnull"));
194         whereClause = analyzeSelectWhere("select id, name from parted where date is null and id = 1");
195         assertEquals(List.of(partition3), whereClause.partitions());
196         assertThat(whereClause.queryOrFallback(), isFunction("op_="));
197         whereClause = analyzeSelectWhere("select id, name from parted where 1395874700000 &lt; date and date &lt; 1395961200001");
198         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
199         assertThat(whereClause.queryOrFallback(), isLiteral(true));
200         whereClause = analyzeSelectWhere("select id, name from parted where '2014-03-16T22:58:20' &lt; date and date &lt; '2014-03-27T23:00:01'");
201         assertThat(whereClause.partitions(), containsInAnyOrder(partition1, partition2));
202         assertThat(whereClause.queryOrFallback(), isLiteral(true));
203     }
204     @Test
205     public void test_where_on_date_with_null_partition_or_id_can_match_all_partitions() throws Exception {
206         WhereClause whereClause = analyzeSelectWhere(
207             "select id, name from parted where date = 1395961200000::timestamp or id = 1");
208         assertThat(whereClause.partitions(), containsInAnyOrder(
209             ".partitioned.parted.0400",
210             ".partitioned.parted.04732cpp6ksjcc9i60o30c1g",
211             ".partitioned.parted.04732cpp6ks3ed1o60o30c1g"
212         ));
213         assertThat(whereClause.queryOrFallback(), isSQL("((doc.parted.date = 1395961200000::bigint) OR (doc.parted.id = 1))"));
214     }
215     @Test
216     public void testAnyInvalidArrayType() throws Exception {
217         expectedException.expect(IllegalArgumentException.class);
218         expectedException.expectMessage("Cannot cast `'foo'` of type `text` to type `boolean`");
219         analyzeSelectWhere("select * from users_multi_pk where awesome = any(['foo', 'bar', 'baz'])");
220     }
221     @Test
222     public void testInConvertedToAnyIfOnlyLiterals() throws Exception {
223         StringBuilder sb = new StringBuilder("select id from sys.shards where id in (");
224         int i = 0;
225         for (; i &lt; 1500; i++) {
226             sb.append(i);
227             sb.append(',');
228         }
229         sb.append(i++);
230         sb.append(')');
231         String s = sb.toString();
232         WhereClause whereClause = analyzeSelectWhere(s);
233         assertThat(whereClause.query(), isFunction(AnyEqOperator.NAME,
234                                                    List.of(DataTypes.INTEGER, new ArrayType&lt;&gt;(DataTypes.INTEGER))));
235     }
236     @Test
237     public void testAnyLikeArrayLiteral() throws Exception {
238         WhereClause whereClause = analyzeSelectWhere("select * from users where name like any(['a', 'b', 'c'])");
239         assertThat(whereClause.query(), isFunction(LikeOperators.ANY_LIKE, List.of(DataTypes.STRING, new ArrayType&lt;&gt;(DataTypes.STRING))));
240     }
241     @Test
242     public void testAnyILikeArrayLiteral() throws Exception {
243         WhereClause whereClause = analyzeSelectWhere("select * from users where name ilike any(['a', 'b', 'c'])");
244         assertThat(whereClause.query(), isFunction(LikeOperators.ANY_ILIKE, List.of(DataTypes.STRING, new ArrayType&lt;&gt;(DataTypes.STRING))));
245 <a name="0"></a>    }
246     @Test
247     public void testEqualGenColOptimization() throws Exception <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
248         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where y = 1");
249         assertThat(whereClause.partitions().size(), is(1));
250         assertThat(whereClause.partitions().get(0), is(new PartitionName(new RelationName("doc", "generated_col"),</b></font>
251             Arrays.asList("1420070400000", "-1")).asIndexName()));
252     }
253     @Test
254     public void testNonPartitionedNotOptimized() throws Exception {
255         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where x = 1");
256         assertThat(whereClause.query(), isSQL("(doc.generated_col.x = 1)"));
257     }
258     @Test
259     public void testGtGenColOptimization() throws Exception {
260         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where ts &gt; '2015-01-02T12:00:00'");
261         assertThat(whereClause.partitions().size(), is(1));
262         assertThat(whereClause.partitions().get(0), is(new PartitionName(new RelationName("doc", "generated_col"),
263             Arrays.asList("1420156800000", "-2")).asIndexName()));
264     }
265     @Test
266     public void testGenColRoundingFunctionNoSwappingOperatorOptimization() throws Exception {
267         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where ts &gt;= '2015-01-02T12:00:00'");
268         assertThat(whereClause.partitions().size(), is(1));
269         assertThat(whereClause.partitions().get(0), is(new PartitionName(
270             new RelationName("doc", "generated_col"), Arrays.asList("1420156800000", "-2")).asIndexName()));
271     }
272     @Test
273     public void testMultiplicationGenColNoOptimization() throws Exception {
274         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where y &gt; 1");
275         assertThat(whereClause.partitions().size(), is(0));
276         assertThat(whereClause.queryOrFallback(), isFunction("op_&gt;"));
277     }
278     @Test
279     public void testMultipleColumnsOptimization() throws Exception {
280         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where ts &gt; '2015-01-01T12:00:00' and y = 1");
281         assertThat(whereClause.partitions().size(), is(1));
282         assertThat(whereClause.partitions().get(0), is(new PartitionName(
283             new RelationName("doc", "generated_col"), Arrays.asList("1420070400000", "-1")).asIndexName()));
284     }
285     @Test
286     public void testColumnReferencedTwiceInGeneratedColumnPartitioned() throws Exception {
287         WhereClause whereClause = analyzeSelectWhere("select * from double_gen_parted where x = 4");
288         assertThat(whereClause.query(), isSQL("(doc.double_gen_parted.x = 4)"));
289         assertThat(whereClause.partitions().size(), is(1));
290         assertThat(whereClause.partitions().get(0), is(".partitioned.double_gen_parted.0813a0hm"));
291     }
292     @Test
293     public void testOptimizationNonRoundingFunctionGreater() throws Exception {
294         WhereClause whereClause = analyzeSelectWhere("select * from double_gen_parted where x &gt; 3");
295         assertThat(whereClause.query(), isSQL("(doc.double_gen_parted.x &gt; 3)"));
296         assertThat(whereClause.partitions().size(), is(1));
297         assertThat(whereClause.partitions().get(0), is(".partitioned.double_gen_parted.0813a0hm"));
298     }
299     @Test
300     public void testGenColRangeOptimization() throws Exception {
301         WhereClause whereClause = analyzeSelectWhere("select * from generated_col where ts &gt;= '2015-01-01T12:00:00' and ts &lt;= '2015-01-02T00:00:00'");
302         RelationName relationName = new RelationName("doc", "generated_col");
303         assertThat(whereClause.partitions(), containsInAnyOrder(
304             new PartitionName(relationName, Arrays.asList("1420070400000", "-1")).asIndexName(),
305             new PartitionName(relationName, Arrays.asList("1420156800000", "-2")).asIndexName())
306         );
307     }
308     @Test
309     public void testRawNotAllowedInQuery() throws Exception {
310         expectedException.expect(UnsupportedOperationException.class);
311         expectedException.expectMessage("The _raw column is not searchable and cannot be used inside a query");
312         analyzeSelectWhere("select * from users where _raw = 'foo'");
313     }
314     @Test
315     public void testVersionOnlySupportedWithEqualOperator() throws Exception {
316         expectedException.expect(VersioningValidationException.class);
317         expectedException.expectMessage(VersioningValidationException.VERSION_COLUMN_USAGE_MSG);
318         analyzeSelectWhere("select * from users where _version &gt; 1");
319     }
320     @Test
321     public void testSeqNoOnlySupportedWithEqualOperator() throws Exception {
322         expectedException.expect(VersioningValidationException.class);
323         expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
324         analyzeSelectWhere("select * from users where _seq_no &gt; 1");
325     }
326     @Test
327     public void testPrimaryTermOnlySupportedWithEqualOperator() throws Exception {
328         expectedException.expect(VersioningValidationException.class);
329         expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
330         analyzeSelectWhere("select * from users where _primary_term &gt; 1");
331     }
332     @Test
333     public void testSeqNoAndPrimaryTermAreRequired() {
334         expectedException.expect(VersioningValidationException.class);
335         expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
336         analyzeSelectWhere("select * from users where name = 'Douglas' and _primary_term = 1");
337     }
338     @Test
339     public void testVersioningMechanismsCannotBeMixed() {
340         expectedException.expect(VersioningValidationException.class);
341         expectedException.expectMessage(VersioningValidationException.MIXED_VERSIONING_COLUMNS_USAGE_MSG);
342         analyzeSelectWhere("select * from users where name = 'Douglas' and _primary_term = 1 and _seq_no = 22 and _version = 1");
343     }
344 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
