<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for WebSocketServerExtensionHandlerTest.java & WebSocketServerProtocolHandlerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for WebSocketServerExtensionHandlerTest.java & WebSocketServerProtocolHandlerTest.java
      </h3>
      <h1 align="center">
        35.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>WebSocketServerExtensionHandlerTest.java (55.454544%)<TH>WebSocketServerProtocolHandlerTest.java (26.637554%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#0',2,'match21697-1.html#0',3)" NAME="0">(159-170)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#0',2,'match21697-1.html#0',3)" NAME="0">(343-354)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#1',2,'match21697-1.html#1',3)" NAME="1">(95-105)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#1',2,'match21697-1.html#1',3)" NAME="1">(318-329)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#2',2,'match21697-1.html#2',3)" NAME="2">(81-89)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#2',2,'match21697-1.html#2',3)" NAME="2">(381-393)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#3',2,'match21697-1.html#3',3)" NAME="3">(18-40)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#3',2,'match21697-1.html#3',3)" NAME="3">(37-58)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#4',2,'match21697-1.html#4',3)" NAME="4">(140-148)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#4',2,'match21697-1.html#4',3)" NAME="4">(330-341)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#5',2,'match21697-1.html#5',3)" NAME="5">(199-207)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#5',2,'match21697-1.html#5',3)" NAME="5">(371-380)</A><TD ALIGN=center><FONT COLOR="#d40000">15</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#6',2,'match21697-1.html#6',3)" NAME="6">(114-120)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#6',2,'match21697-1.html#6',3)" NAME="6">(357-367)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#7',2,'match21697-1.html#7',3)" NAME="7">(59-65)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#7',2,'match21697-1.html#7',3)" NAME="7">(305-315)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#8',2,'match21697-1.html#8',3)" NAME="8">(190-199)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#8',2,'match21697-1.html#8',3)" NAME="8">(77-84)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#9',2,'match21697-1.html#9',3)" NAME="9">(123-126)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#9',2,'match21697-1.html#9',3)" NAME="9">(476-481)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#10',2,'match21697-1.html#10',3)" NAME="10">(223-229)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#10',2,'match21697-1.html#10',3)" NAME="10">(395-400)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#11',2,'match21697-1.html#11',3)" NAME="11">(209-215)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#11',2,'match21697-1.html#11',3)" NAME="11">(112-122)</A><TD ALIGN=center><FONT COLOR="#8d0000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match21697-0.html#12',2,'match21697-1.html#12',3)" NAME="12">(52-57)<TD><A HREF="javascript:ZweiFrames('match21697-0.html#12',2,'match21697-1.html#12',3)" NAME="12">(102-106)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketServerExtensionHandlerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="3"></A> */
package io.netty.handler.codec.http.websocketx.extensions;

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match21697-1.html#3',3,'match21697-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.channel.ChannelPromise;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponse;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.Test;

import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.*;

public class WebSocketServerExtensionHandlerTest {

    WebSocketServerExtensionHandshaker mainHandshakerMock =</B></FONT>
            mock(WebSocketServerExtensionHandshaker.class, &quot;mainHandshaker&quot;);
    WebSocketServerExtensionHandshaker fallbackHandshakerMock =
            mock(WebSocketServerExtensionHandshaker.class, &quot;fallbackHandshaker&quot;);
    WebSocketServerExtension mainExtensionMock =
            mock(WebSocketServerExtension.class, &quot;mainExtension&quot;);
    WebSocketServerExtension fallbackExtensionMock =
            mock(WebSocketServerExtension.class, &quot;fallbackExtension&quot;);

<A NAME="12"></A>    @Test
    public void testMainSuccess() {
        // initialize
        <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match21697-1.html#12',3,'match21697-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;))).
                thenReturn(mainExtensionMock);
        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;))).
                thenReturn(null);
<A NAME="7"></A>
        when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;))).</B></FONT>
                thenReturn(fallbackExtensionMock);
        <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match21697-1.html#7',3,'match21697-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;))).
                thenReturn(null);

        when(mainExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);
        when(mainExtensionMock.newReponseData()).thenReturn(
                new WebSocketExtensionData(&quot;main&quot;, Collections.&lt;String, String&gt;emptyMap()));
        when(mainExtensionMock.newExtensionEncoder</B></FONT>()).thenReturn(new DummyEncoder());
        when(mainExtensionMock.newExtensionDecoder()).thenReturn(new DummyDecoder());

        when(fallbackExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);

        // execute
        WebSocketServerExtensionHandler extensionHandler =
                new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);

        HttpRequest req = newUpgradeRequest(&quot;main, fallback&quot;);
        ch.writeInbound(req);

<A NAME="2"></A>        HttpResponse res = newUpgradeResponse(null);
        ch.writeOutbound(res);

        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match21697-1.html#2',3,'match21697-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>HttpResponse res2 = ch.readOutbound();
        List&lt;WebSocketExtensionData&gt; resExts = WebSocketExtensionUtil.extractExtensions(
                res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));

        // test
        assertNull(ch.pipeline().context(extensionHandler));
        assertEquals(1, resExts.size());
        assertEquals(&quot;main&quot;, resExts.get(0).name());
        assertTrue(resExts.get</B></FONT>(0).parameters().isEmpty());
        assertNotNull(ch.pipeline().get(DummyDecoder.class));
        assertNotNull(ch.pipeline().get(DummyEncoder.class));
<A NAME="1"></A>
        verify(mainHandshakerMock, atLeastOnce()).handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;));
        verify(mainHandshakerMock, atLeastOnce()).handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;));
        verify(fallbackHandshakerMock, atLeastOnce()).handshakeExtension(<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match21697-1.html#1',3,'match21697-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>webSocketExtensionDataMatcher(&quot;fallback&quot;));

        verify(mainExtensionMock, atLeastOnce()).rsv();
        verify(mainExtensionMock).newReponseData();
        verify(mainExtensionMock).newExtensionEncoder();
        verify(mainExtensionMock).newExtensionDecoder();
        verify(fallbackExtensionMock, atLeastOnce()).rsv();
    }

    @Test
    public void testCompatibleExtensionTogetherSuccess() {</B></FONT>
        // initialize
        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;))).
                thenReturn(mainExtensionMock);
        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;))).
                thenReturn(null);
<A NAME="6"></A>
        when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;))).
                thenReturn(fallbackExtensionMock);
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match21697-1.html#6',3,'match21697-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;))).
                thenReturn(null);

        when(mainExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);
        when(mainExtensionMock.newReponseData()).thenReturn(
                new WebSocketExtensionData(&quot;main&quot;, Collections.&lt;String, String&gt;emptyMap()));
<A NAME="9"></A>        when(mainExtensionMock.newExtensionEncoder</B></FONT>()).thenReturn(new DummyEncoder());
        when(mainExtensionMock.newExtensionDecoder()).thenReturn(new DummyDecoder());

        <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match21697-1.html#9',3,'match21697-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(fallbackExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV2);
        when(fallbackExtensionMock.newReponseData()).thenReturn(
                new WebSocketExtensionData(&quot;fallback&quot;, Collections.&lt;String, String&gt;emptyMap()));
        when(fallbackExtensionMock.newExtensionEncoder</B></FONT>()).thenReturn(new Dummy2Encoder());
        when(fallbackExtensionMock.newExtensionDecoder()).thenReturn(new Dummy2Decoder());

        // execute
        WebSocketServerExtensionHandler extensionHandler =
                new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);

        HttpRequest req = newUpgradeRequest(&quot;main, fallback&quot;);
        ch.writeInbound(req);

<A NAME="4"></A>        HttpResponse res = newUpgradeResponse(null);
        ch.writeOutbound(res);

        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match21697-1.html#4',3,'match21697-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>HttpResponse res2 = ch.readOutbound();
        List&lt;WebSocketExtensionData&gt; resExts = WebSocketExtensionUtil.extractExtensions(
                res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));

        // test
        assertNull(ch.pipeline().context(extensionHandler));
        assertEquals(2, resExts.size());
        assertEquals(&quot;main&quot;, resExts.get(0).name());
        assertEquals(&quot;fallback&quot;, resExts.get(1).name</B></FONT>());
        assertNotNull(ch.pipeline().get(DummyDecoder.class));
        assertNotNull(ch.pipeline().get(DummyEncoder.class));
        assertNotNull(ch.pipeline().get(Dummy2Decoder.class));
        assertNotNull(ch.pipeline().get(Dummy2Encoder.class));

        verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;));
        verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;));
<A NAME="0"></A>        verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;fallback&quot;));
        verify(mainExtensionMock, times(2)).rsv();
        verify(mainExtensionMock).newReponseData();
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match21697-1.html#0',3,'match21697-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>verify(mainExtensionMock).newExtensionEncoder();
        verify(mainExtensionMock).newExtensionDecoder();

        verify(fallbackExtensionMock, times(2)).rsv();

        verify(fallbackExtensionMock).newReponseData();
        verify(fallbackExtensionMock).newExtensionEncoder();
        verify(fallbackExtensionMock).newExtensionDecoder();
    }

    @Test
    public void testNoneExtensionMatchingSuccess() {</B></FONT>
        // initialize
        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown&quot;))).
                thenReturn(null);
        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown2&quot;))).
                thenReturn(null);

        when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown&quot;))).
                thenReturn(null);
        when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown2&quot;))).
                thenReturn(null);

        // execute
        WebSocketServerExtensionHandler extensionHandler =
                new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);

<A NAME="8"></A>        HttpRequest req = newUpgradeRequest(&quot;unknown, unknown2&quot;);
        ch.writeInbound(req);

        HttpResponse res = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match21697-1.html#8',3,'match21697-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newUpgradeResponse(null);
        ch.writeOutbound(res);

        HttpResponse res2 = ch.readOutbound();

        // test
<A NAME="5"></A>        assertNull(ch.pipeline().context(extensionHandler));
        assertFalse(res2.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));

        verify</B></FONT>(mainHandshakerMock).handshakeExtension(<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match21697-1.html#5',3,'match21697-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>webSocketExtensionDataMatcher(&quot;unknown&quot;));
        verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown2&quot;));

        verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown&quot;));
        verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(&quot;unknown2&quot;));
    }

<A NAME="11"></A>    @Test
    public void testExtensionHandlerNotRemovedByFailureWritePromise() {</B></FONT>
        // initialize
        <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match21697-1.html#11',3,'match21697-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(&quot;main&quot;)))
                .thenReturn(mainExtensionMock);
        when(mainExtensionMock.newReponseData()).thenReturn(
                new WebSocketExtensionData(&quot;main&quot;, Collections.&lt;String, String&gt;emptyMap()));

        // execute
        WebSocketServerExtensionHandler extensionHandler =</B></FONT>
                new WebSocketServerExtensionHandler(mainHandshakerMock);
        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);

        HttpRequest req = newUpgradeRequest(&quot;main&quot;);
<A NAME="10"></A>        ch.writeInbound(req);

        HttpResponse res = newUpgradeResponse(null);
        <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match21697-1.html#10',3,'match21697-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ChannelPromise failurePromise = ch.newPromise();
        ch.writeOneOutbound(res, failurePromise);
        failurePromise.setFailure(new IOException(&quot;Cannot write response&quot;));

        // test
        assertNull(ch.readOutbound());
        assertNotNull(ch.pipeline</B></FONT>().context(extensionHandler));
        assertTrue(ch.finish());
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketServerProtocolHandlerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License, version
 * 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.netty.handler.codec.http.websocketx;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.channel.embedded.EmbeddedChannel;

import io.netty.handler.codec.http.DefaultHttpContent;
import io.netty.handler.codec.http.DefaultHttpRequest;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpRequestDecoder;
import io.netty.handler.codec.http.HttpResponseEncoder;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
<A NAME="3"></A>import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpObjectAggregator;
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#3',2,'match21697-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.netty.handler.codec.http.HttpServerCodec;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.ArrayDeque;
import java.util.Queue;

import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static io.netty.handler.codec.http.HttpVersion.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class WebSocketServerProtocolHandlerTest {

    private final Queue&lt;FullHttpResponse&gt; responses = new ArrayDeque&lt;FullHttpResponse&gt;()</B></FONT>;

    @BeforeEach
    public void setUp() {
        responses.clear();
    }

    @Test
    public void testHttpUpgradeRequestFull() {
        testHttpUpgradeRequest0(true);
    }

    @Test
    public void testHttpUpgradeRequestNonFull() {
        testHttpUpgradeRequest0(false);
    }
<A NAME="8"></A>
    private void testHttpUpgradeRequest0(boolean full) {
        EmbeddedChannel ch = createChannel(new MockOutboundHandler());
        ChannelHandlerContext handshakerCtx = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#8',2,'match21697-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
        writeUpgradeRequest(ch, full);

        FullHttpResponse response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();
        assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx.channel()));
        assertFalse(ch.finish</B></FONT>());
    }

    @Test
    public void testWebSocketServerProtocolHandshakeHandlerReplacedBeforeHandshake() {
        EmbeddedChannel ch = createChannel(new MockOutboundHandler());
        ChannelHandlerContext handshakerCtx = ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
        ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
            @Override
            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {
                    // We should have removed the handler already.
                    assertNull(ctx.pipeline().context(WebSocketServerProtocolHandshakeHandler.class));
                }
            }
<A NAME="12"></A>        });
        writeUpgradeRequest(ch);

        FullHttpResponse response = <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#12',2,'match21697-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();
        assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx.channel()));
        assertFalse(ch.finish</B></FONT>());
    }

<A NAME="11"></A>    @Test
    public void testHttpUpgradeRequestInvalidUpgradeHeader() {
        EmbeddedChannel ch = createChannel();
        FullHttpRequest httpRequestWithEntity = <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#11',2,'match21697-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                .method(HttpMethod.GET)
                .uri(&quot;/test&quot;)
                .connection(&quot;Upgrade&quot;)
                .version00()
                .upgrade(&quot;BogusSocket&quot;)
                .build();

        ch.writeInbound(httpRequestWithEntity);

        FullHttpResponse response = responses.remove()</B></FONT>;
        assertEquals(BAD_REQUEST, response.status());
        assertEquals(&quot;not a WebSocket handshake request: missing upgrade&quot;, getResponseMessage(response));
        response.release();
        assertFalse(ch.finish());
    }

    @Test
    public void testHttpUpgradeRequestMissingWSKeyHeader() {
        EmbeddedChannel ch = createChannel();
        HttpRequest httpRequest = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                .method(HttpMethod.GET)
                .uri(&quot;/test&quot;)
                .key(null)
                .connection(&quot;Upgrade&quot;)
                .upgrade(HttpHeaderValues.WEBSOCKET)
                .version13()
                .build();

        ch.writeInbound(httpRequest);

        FullHttpResponse response = responses.remove();
        assertEquals(BAD_REQUEST, response.status());
        assertEquals(&quot;not a WebSocket request: missing key&quot;, getResponseMessage(response));
        response.release();
        assertFalse(ch.finish());
    }

    @Test
    public void testCreateUTF8Validator() {
        WebSocketServerProtocolConfig config = WebSocketServerProtocolConfig.newBuilder()
                .websocketPath(&quot;/test&quot;)
                .withUTF8Validator(true)
                .build();

        EmbeddedChannel ch = new EmbeddedChannel(
                new WebSocketServerProtocolHandler(config),
                new HttpRequestDecoder(),
                new HttpResponseEncoder(),
                new MockOutboundHandler());
        writeUpgradeRequest(ch);

        FullHttpResponse response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();

        assertNotNull(ch.pipeline().get(Utf8FrameValidator.class));
    }

    @Test
    public void testDoNotCreateUTF8Validator() {
        WebSocketServerProtocolConfig config = WebSocketServerProtocolConfig.newBuilder()
                .websocketPath(&quot;/test&quot;)
                .withUTF8Validator(false)
                .build();

        EmbeddedChannel ch = new EmbeddedChannel(
                new WebSocketServerProtocolHandler(config),
                new HttpRequestDecoder(),
                new HttpResponseEncoder(),
                new MockOutboundHandler());
        writeUpgradeRequest(ch);

        FullHttpResponse response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();

        assertNull(ch.pipeline().get(Utf8FrameValidator.class));
    }

    @Test
    public void testHandleTextFrame() {
        CustomTextFrameHandler customTextFrameHandler = new CustomTextFrameHandler();
        EmbeddedChannel ch = createChannel(customTextFrameHandler);
        writeUpgradeRequest(ch);

        FullHttpResponse response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();

        if (ch.pipeline().context(HttpRequestDecoder.class) != null) {
            // Removing the HttpRequestDecoder because we are writing a TextWebSocketFrame and thus
            // decoding is not necessary.
            ch.pipeline().remove(HttpRequestDecoder.class);
        }

        ch.writeInbound(new TextWebSocketFrame(&quot;payload&quot;));

        assertEquals(&quot;processed: payload&quot;, customTextFrameHandler.getContent());
        assertFalse(ch.finish());
    }

    @Test
    public void testCheckWebSocketPathStartWithSlash() {
        WebSocketRequestBuilder builder = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                .method(HttpMethod.GET)
                .key(HttpHeaderNames.SEC_WEBSOCKET_KEY)
                .connection(&quot;Upgrade&quot;)
                .upgrade(HttpHeaderValues.WEBSOCKET)
                .version13();

        WebSocketServerProtocolConfig config = WebSocketServerProtocolConfig.newBuilder()
                .websocketPath(&quot;/&quot;)
                .checkStartsWith(true)
                .build();

        FullHttpResponse response;

        createChannel(config, null).writeInbound(builder.uri(&quot;/test&quot;).build());
        response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();

        createChannel(config, null).writeInbound(builder.uri(&quot;/?q=v&quot;).build());
        response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();

        createChannel(config, null).writeInbound(builder.uri(&quot;/&quot;).build());
        response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();
    }

    @Test
    public void testCheckValidWebSocketPath() {
        HttpRequest httpRequest = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                .method(HttpMethod.GET)
                .uri(&quot;/test&quot;)
                .key(HttpHeaderNames.SEC_WEBSOCKET_KEY)
                .connection(&quot;Upgrade&quot;)
                .upgrade(HttpHeaderValues.WEBSOCKET)
                .version13()
                .build();

        WebSocketServerProtocolConfig config = WebSocketServerProtocolConfig.newBuilder()
                .websocketPath(&quot;/test&quot;)
                .checkStartsWith(true)
                .build();

        EmbeddedChannel ch = new EmbeddedChannel(
                new WebSocketServerProtocolHandler(config),
                new HttpRequestDecoder(),
                new HttpResponseEncoder(),
                new MockOutboundHandler());
        ch.writeInbound(httpRequest);

        FullHttpResponse response = responses.remove();
        assertEquals(SWITCHING_PROTOCOLS, response.status());
        response.release();
    }

    @Test
    public void testCheckInvalidWebSocketPath() {
        HttpRequest httpRequest = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                .method(HttpMethod.GET)
                .uri(&quot;/testabc&quot;)
                .key(HttpHeaderNames.SEC_WEBSOCKET_KEY)
                .connection(&quot;Upgrade&quot;)
                .upgrade(HttpHeaderValues.WEBSOCKET)
                .version13()
                .build();

        WebSocketServerProtocolConfig config = WebSocketServerProtocolConfig.newBuilder()
                .websocketPath(&quot;/test&quot;)
                .checkStartsWith(true)
                .build();

        EmbeddedChannel ch = new EmbeddedChannel(
                new WebSocketServerProtocolHandler(config),
                new HttpRequestDecoder(),
                new HttpResponseEncoder(),
                new MockOutboundHandler());
        ch.writeInbound(httpRequest);

        ChannelHandlerContext handshakerCtx = ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
        assertNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx.channel()));
    }

    @Test
<A NAME="7"></A>    public void testExplicitCloseFrameSentWhenServerChannelClosed() throws Exception {
        WebSocketCloseStatus closeStatus = WebSocketCloseStatus.ENDPOINT_UNAVAILABLE;
        EmbeddedChannel client = createClient();
        EmbeddedChannel server = <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#7',2,'match21697-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createServer();

        assertFalse(server.writeInbound(client.readOutbound()));
        assertFalse(client.writeInbound(server.readOutbound()));

        // When server channel closed with explicit close-frame
        assertTrue(server.writeOutbound(new CloseWebSocketFrame(closeStatus)));
        server.close();

        // Then client receives provided close-frame
<A NAME="1"></A>        assertTrue(client.writeInbound(server.readOutbound</B></FONT>()));
        assertFalse(server.isOpen());

        CloseWebSocketFrame closeMessage = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#1',2,'match21697-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>client.readInbound();
        assertEquals(closeMessage.statusCode(), closeStatus.code());
        closeMessage.release();

        client.close();
        assertTrue(ReferenceCountUtil.release(client.readOutbound()));
        assertFalse(client.finishAndReleaseAll());
        assertFalse(server.finishAndReleaseAll());
    }
<A NAME="4"></A>
    @Test
    public void testCloseFrameSentWhenServerChannelClosedSilently() throws Exception {</B></FONT>
        <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#4',2,'match21697-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>EmbeddedChannel client = createClient();
        EmbeddedChannel server = createServer();

        assertFalse(server.writeInbound(client.readOutbound()));
        assertFalse(client.writeInbound(server.readOutbound()));

        // When server channel closed without explicit close-frame
        server.close();

        // Then client receives NORMAL_CLOSURE close-frame
<A NAME="0"></A>        assertTrue(client.writeInbound(server.readOutbound()));
        assertFalse(server.isOpen</B></FONT>());

        CloseWebSocketFrame closeMessage = <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#0',2,'match21697-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>client.readInbound();
        assertEquals(closeMessage.statusCode(), WebSocketCloseStatus.NORMAL_CLOSURE.code());
        closeMessage.release();

        client.close();
        assertTrue(ReferenceCountUtil.release(client.readOutbound()));
        assertFalse(client.finishAndReleaseAll());
        assertFalse(server.finishAndReleaseAll());
    }

    @Test
<A NAME="6"></A>    public void testExplicitCloseFrameSentWhenClientChannelClosed() throws Exception {</B></FONT>
        WebSocketCloseStatus closeStatus = WebSocketCloseStatus.INVALID_PAYLOAD_DATA;
        EmbeddedChannel client = createClient();
        EmbeddedChannel server = <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#6',2,'match21697-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createServer();

        assertFalse(server.writeInbound(client.readOutbound()));
        assertFalse(client.writeInbound(server.readOutbound()));

        // When client channel closed with explicit close-frame
        assertTrue(client.writeOutbound(new CloseWebSocketFrame(closeStatus)));
        client.close();

        // Then client receives provided close-frame
        assertFalse(server.writeInbound(client.readOutbound</B></FONT>()));
<A NAME="5"></A>        assertFalse(client.isOpen());
        assertFalse(server.isOpen());

        CloseWebSocketFrame closeMessage = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#5',2,'match21697-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>decode(server.&lt;ByteBuf&gt;readOutbound(), CloseWebSocketFrame.class);
        assertEquals(closeMessage.statusCode(), closeStatus.code());
        closeMessage.release();

        assertFalse(client.finishAndReleaseAll());
        assertFalse(server.finishAndReleaseAll());
    }
<A NAME="2"></A>
    @Test
    public void testCloseFrameSentWhenClientChannelClosedSilently() throws Exception {</B></FONT>
        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#2',2,'match21697-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>EmbeddedChannel client = createClient();
        EmbeddedChannel server = createServer();

        assertFalse(server.writeInbound(client.readOutbound()));
        assertFalse(client.writeInbound(server.readOutbound()));

        // When client channel closed without explicit close-frame
        client.close();

        // Then server receives NORMAL_CLOSURE close-frame
        assertFalse(server.writeInbound(client.readOutbound()));
<A NAME="10"></A>        assertFalse(client.isOpen());
        assertFalse(server.isOpen</B></FONT>());

        <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#10',2,'match21697-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CloseWebSocketFrame closeMessage = decode(server.&lt;ByteBuf&gt;readOutbound(), CloseWebSocketFrame.class);
        assertEquals(closeMessage, new CloseWebSocketFrame(WebSocketCloseStatus.NORMAL_CLOSURE));
        closeMessage.release();

        assertFalse(client.finishAndReleaseAll());
        assertFalse(server.finishAndReleaseAll</B></FONT>());
    }

    private EmbeddedChannel createClient(ChannelHandler... handlers) throws Exception {
        WebSocketClientProtocolConfig clientConfig = WebSocketClientProtocolConfig.newBuilder()
            .webSocketUri(&quot;http://test/test&quot;)
            .dropPongFrames(false)
            .handleCloseFrames(false)
            .build();
        EmbeddedChannel ch = new EmbeddedChannel(false, false,
            new HttpClientCodec(),
            new HttpObjectAggregator(8192),
            new WebSocketClientProtocolHandler(clientConfig)
        );
        ch.pipeline().addLast(handlers);
        ch.register();
        return ch;
    }

    private EmbeddedChannel createServer(ChannelHandler... handlers) throws Exception {
        WebSocketServerProtocolConfig serverConfig = WebSocketServerProtocolConfig.newBuilder()
            .websocketPath(&quot;/test&quot;)
            .dropPongFrames(false)
            .build();
        EmbeddedChannel ch = new EmbeddedChannel(false, false,
            new HttpServerCodec(),
            new HttpObjectAggregator(8192),
            new WebSocketServerProtocolHandler(serverConfig)
        );
        ch.pipeline().addLast(handlers);
        ch.register();
        return ch;
    }

    @SuppressWarnings(&quot;SameParameterValue&quot;)
    private &lt;T&gt; T decode(ByteBuf input, Class&lt;T&gt; clazz) {
        EmbeddedChannel ch = new EmbeddedChannel(new WebSocket13FrameDecoder(true, false, 65536, true));
        assertTrue(ch.writeInbound(input));
        Object decoded = ch.readInbound();
        assertNotNull(decoded);
        assertFalse(ch.finish());
        return clazz.cast(decoded);
    }

    private EmbeddedChannel createChannel() {
        return createChannel(null);
    }

    private EmbeddedChannel createChannel(ChannelHandler handler) {
        WebSocketServerProtocolConfig serverConfig = WebSocketServerProtocolConfig.newBuilder()
            .websocketPath(&quot;/test&quot;)
            .sendCloseFrame(null)
            .build();
        return createChannel(serverConfig, handler);
    }

    private EmbeddedChannel createChannel(WebSocketServerProtocolConfig serverConfig, ChannelHandler handler) {
        return new EmbeddedChannel(
                new WebSocketServerProtocolHandler(serverConfig),
                new HttpRequestDecoder(),
                new HttpResponseEncoder(),
                new MockOutboundHandler(),
                handler);
    }

    private static void writeUpgradeRequest(EmbeddedChannel ch) {
        writeUpgradeRequest(ch, true);
    }

    private static void writeUpgradeRequest(EmbeddedChannel ch, boolean full) {
        HttpRequest request = WebSocketRequestBuilder.successful();
        if (full) {
            ch.writeInbound(request);
<A NAME="9"></A>        } else {
            if (request instanceof FullHttpRequest) {
                FullHttpRequest fullHttpRequest = (FullHttpRequest) request;
                HttpRequest req = new DefaultHttpRequest(fullHttpRequest.protocolVersion(), <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match21697-0.html#9',2,'match21697-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>fullHttpRequest.method(),
                        fullHttpRequest.uri(), fullHttpRequest.headers().copy());
                ch.writeInbound(req);
                ch.writeInbound(new DefaultHttpContent(fullHttpRequest.content().copy()));
                ch.writeInbound(LastHttpContent.EMPTY_LAST_CONTENT);
                fullHttpRequest.release</B></FONT>();
            } else {
                ch.writeInbound(request);
            }
        }
    }

    private static String getResponseMessage(FullHttpResponse response) {
        return response.content().toString(CharsetUtil.UTF_8);
    }

    private class MockOutboundHandler extends ChannelOutboundHandlerAdapter {

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
            responses.add((FullHttpResponse) msg);
            promise.setSuccess();
        }

        @Override
        public void flush(ChannelHandlerContext ctx) {
        }
    }

    private static class CustomTextFrameHandler extends ChannelInboundHandlerAdapter {
        private String content;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) {
            assertNull(content);
            content = &quot;processed: &quot; + ((TextWebSocketFrame) msg).text();
            ReferenceCountUtil.release(msg);
        }

        String getContent() {
            return content;
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
