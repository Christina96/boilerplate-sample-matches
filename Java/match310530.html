<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Graphs.java & ImmutableRangeSet.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Graphs.java & ImmutableRangeSet.java
      </h3>
      <h1 align="center">
        16.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Graphs.java (18.21192%)<TH>ImmutableRangeSet.java (15.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#0',2,'match310530-1.html#0',3)" NAME="0">(19-46)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#0',2,'match310530-1.html#0',3)" NAME="0">(22-49)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#1',2,'match310530-1.html#1',3)" NAME="1">(271-280)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#1',2,'match310530-1.html#1',3)" NAME="1">(738-759)</A><TD ALIGN=center><FONT COLOR="#cc0000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#2',2,'match310530-1.html#2',3)" NAME="2">(587-598)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#2',2,'match310530-1.html#2',3)" NAME="2">(761-777)</A><TD ALIGN=center><FONT COLOR="#bf0000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#3',2,'match310530-1.html#3',3)" NAME="3">(307-313)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#3',2,'match310530-1.html#3',3)" NAME="3">(606-612)</A><TD ALIGN=center><FONT COLOR="#bf0000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#4',2,'match310530-1.html#4',3)" NAME="4">(424-429)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#4',2,'match310530-1.html#4',3)" NAME="4">(622-629)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#5',2,'match310530-1.html#5',3)" NAME="5">(328-337)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#5',2,'match310530-1.html#5',3)" NAME="5">(324-333)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#6',2,'match310530-1.html#6',3)" NAME="6">(90-94)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#6',2,'match310530-1.html#6',3)" NAME="6">(154-160)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#7',2,'match310530-1.html#7',3)" NAME="7">(418-423)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#7',2,'match310530-1.html#7',3)" NAME="7">(161-169)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#8',2,'match310530-1.html#8',3)" NAME="8">(440-445)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#8',2,'match310530-1.html#8',3)" NAME="8">(174-179)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#9',2,'match310530-1.html#9',3)" NAME="9">(386-392)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#9',2,'match310530-1.html#9',3)" NAME="9">(457-463)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#10',2,'match310530-1.html#10',3)" NAME="10">(262-269)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#10',2,'match310530-1.html#10',3)" NAME="10">(811-818)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#11',2,'match310530-1.html#11',3)" NAME="11">(253-256)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#11',2,'match310530-1.html#11',3)" NAME="11">(652-655)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match310530-0.html#12',2,'match310530-1.html#12',3)" NAME="12">(293-295)<TD><A HREF="javascript:ZweiFrames('match310530-0.html#12',2,'match310530-1.html#12',3)" NAME="12">(383-385)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Graphs.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.graph;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match310530-1.html#0',3,'match310530-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Maps;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;

/**
 * Static utility methods for {@link Graph}, {@link ValueGraph}, and {@link Network} instances.
 *
 * @author James Sexton
 * @author Joshua O'Madadhain
 * @since 20.0
 */
@Beta
@</B></FONT>ElementTypesAreNonnullByDefault
public final class Graphs {

  private Graphs() {}

  // Graph query methods

  /**
   * Returns true if {@code graph} has at least one cycle. A cycle is defined as a non-empty subset
   * of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) starting
   * and ending with the same node.
   *
   * &lt;p&gt;This method will detect any non-empty cycle, including self-loops (a cycle of length 1).
   */
  public static &lt;N&gt; boolean hasCycle(Graph&lt;N&gt; graph) {
    int numEdges = graph.edges().size();
    if (numEdges == 0) {
      return false; // An edge-free graph is acyclic by definition.
    }
    if (!graph.isDirected() &amp;&amp; numEdges &gt;= graph.nodes().size()) {
      return true; // Optimization for the undirected case: at least one cycle must exist.
    }

    Map&lt;Object, NodeVisitState&gt; visitedNodes =
        Maps.newHashMapWithExpectedSize(graph.nodes().size());
    for (N node : graph.nodes()) {
      if (subgraphHasCycle(graph, visitedNodes, node, null)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns true if {@code network} has at least one cycle. A cycle is defined as a non-empty
   * subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)
   * starting and ending with the same node.
   *
   * &lt;p&gt;This method will detect any non-empty cycle, including self-loops (a cycle of length 1).
   */
  public static boolean hasCycle(Network&lt;?, ?&gt; network) {
<A NAME="6"></A>    // In a directed graph, parallel edges cannot introduce a cycle in an acyclic graph.
    // However, in an undirected graph, any parallel edge induces a cycle in the graph.
    if (!network.isDirected()
        &amp;&amp; <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match310530-1.html#6',3,'match310530-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>network.allowsParallelEdges()
        &amp;&amp; network.edges().size() &gt; network.asGraph().edges().size()) {
      return true;
    }
    return hasCycle(network.asGraph</B></FONT>());
  }

  /**
   * Performs a traversal of the nodes reachable from {@code node}. If we ever reach a node we've
   * already visited (following only outgoing edges and without reusing edges), we know there's a
   * cycle in the graph.
   */
  private static &lt;N&gt; boolean subgraphHasCycle(
      Graph&lt;N&gt; graph,
      Map&lt;Object, NodeVisitState&gt; visitedNodes,
      N node,
      @CheckForNull N previousNode) {
    NodeVisitState state = visitedNodes.get(node);
    if (state == NodeVisitState.COMPLETE) {
      return false;
    }
    if (state == NodeVisitState.PENDING) {
      return true;
    }

    visitedNodes.put(node, NodeVisitState.PENDING);
    for (N nextNode : graph.successors(node)) {
      if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode)
          &amp;&amp; subgraphHasCycle(graph, visitedNodes, nextNode, node)) {
        return true;
      }
    }
    visitedNodes.put(node, NodeVisitState.COMPLETE);
    return false;
  }

  /**
   * Determines whether an edge has already been used during traversal. In the directed case a cycle
   * is always detected before reusing an edge, so no special logic is required. In the undirected
   * case, we must take care not to &quot;backtrack&quot; over an edge (i.e. going from A to B and then going
   * from B to A).
   */
  private static boolean canTraverseWithoutReusingEdge(
      Graph&lt;?&gt; graph, Object nextNode, @CheckForNull Object previousNode) {
    if (graph.isDirected() || !Objects.equal(previousNode, nextNode)) {
      return true;
    }
    // This falls into the undirected A-&gt;B-&gt;A case. The Graph interface does not support parallel
    // edges, so this traversal would require reusing the undirected AB edge.
    return false;
  }

  /**
   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another
   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,
   * Object) reachable} from node A.
   *
   * &lt;p&gt;This is a &quot;snapshot&quot; based on the current topology of {@code graph}, rather than a live view
   * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not
   * be updated after modifications to {@code graph}.
   */
  // TODO(b/31438252): Consider potential optimizations for this algorithm.
  public static &lt;N&gt; Graph&lt;N&gt; transitiveClosure(Graph&lt;N&gt; graph) {
    MutableGraph&lt;N&gt; transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();
    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure
    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.

    if (graph.isDirected()) {
      // Note: works for both directed and undirected graphs, but we only use in the directed case.
      for (N node : graph.nodes()) {
        for (N reachableNode : reachableNodes(graph, node)) {
          transitiveClosure.putEdge(node, reachableNode);
        }
      }
    } else {
      // An optimization for the undirected case: for every node B reachable from node A,
      // node A and node B have the same reachability set.
      Set&lt;N&gt; visitedNodes = new HashSet&lt;N&gt;();
      for (N node : graph.nodes()) {
        if (!visitedNodes.contains(node)) {
          Set&lt;N&gt; reachableNodes = reachableNodes(graph, node);
          visitedNodes.addAll(reachableNodes);
          int pairwiseMatch = 1; // start at 1 to include self-loops
          for (N nodeU : reachableNodes) {
            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {
              transitiveClosure.putEdge(nodeU, nodeV);
            }
          }
        }
      }
    }

    return transitiveClosure;
  }

  /**
   * Returns the set of nodes that are reachable from {@code node}. Node B is defined as reachable
   * from node A if there exists a path (a sequence of adjacent outgoing edges) starting at node A
   * and ending at node B. Note that a node is always reachable from itself via a zero-length path.
   *
   * &lt;p&gt;This is a &quot;snapshot&quot; based on the current topology of {@code graph}, rather than a live view
   * of the set of nodes reachable from {@code node}. In other words, the returned {@link Set} will
   * not be updated after modifications to {@code graph}.
   *
   * @throws IllegalArgumentException if {@code node} is not present in {@code graph}
   */
  public static &lt;N&gt; Set&lt;N&gt; reachableNodes(Graph&lt;N&gt; graph, N node) {
    checkArgument(graph.nodes().contains(node), NODE_NOT_IN_GRAPH, node);
    return ImmutableSet.copyOf(Traverser.forGraph(graph).breadthFirst(node));
  }

  // Graph mutation methods

  // Graph view methods

  /**
   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other
   * properties remain intact, and further updates to {@code graph} will be reflected in the view.
   */
  public static &lt;N&gt; Graph&lt;N&gt; transpose(Graph&lt;N&gt; graph) {
    if (!graph.isDirected()) {
      return graph; // the transpose of an undirected graph is an identical graph
    }

    if (graph instanceof TransposedGraph) {
      return ((TransposedGraph&lt;N&gt;) graph).graph;
    }

    return new TransposedGraph&lt;N&gt;(graph);
  }

  /**
   * Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other
   * properties remain intact, and further updates to {@code graph} will be reflected in the view.
   */
  public static &lt;N, V&gt; ValueGraph&lt;N, V&gt; transpose(ValueGraph&lt;N, V&gt; graph) {
    if (!graph.isDirected()) {
      return graph; // the transpose of an undirected graph is an identical graph
    }

    if (graph instanceof TransposedValueGraph) {
      return ((TransposedValueGraph&lt;N, V&gt;) graph).graph;
    }

    return new TransposedValueGraph&lt;&gt;(graph);
  }

  /**
   * Returns a view of {@code network} with the direction (if any) of every edge reversed. All other
   * properties remain intact, and further updates to {@code network} will be reflected in the view.
   */
  public static &lt;N, E&gt; Network&lt;N, E&gt; transpose(Network&lt;N, E&gt; network) {
    if (!network.isDirected()) {
      return network; // the transpose of an undirected network is an identical network
    }

    if (network instanceof TransposedNetwork) {
      return ((TransposedNetwork&lt;N, E&gt;) network).network;
    }

<A NAME="11"></A>    return new TransposedNetwork&lt;&gt;(network);
  }

  static &lt;N&gt; EndpointPair&lt;N&gt; transpose(<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match310530-1.html#11',3,'match310530-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>EndpointPair&lt;N&gt; endpoints) {
    if (endpoints.isOrdered()) {
      return EndpointPair.ordered(endpoints.target(), endpoints.source());
    }</B></FONT>
    return endpoints;
  }
<A NAME="10"></A>
  // NOTE: this should work as long as the delegate graph's implementation of edges() (like that of
  // AbstractGraph) derives its behavior from calling successors().
  <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match310530-1.html#10',3,'match310530-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private static class TransposedGraph&lt;N&gt; extends ForwardingGraph&lt;N&gt; {
    private final Graph&lt;N&gt; graph;

    TransposedGraph(Graph&lt;N&gt; graph) {
      this.graph = graph;
    }
<A NAME="1"></A>
    @Overrid</B></FONT>e
    Graph&lt;N&gt; delegate() {
      <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match310530-1.html#1',3,'match310530-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return graph;
    }

    @Override
    public Set&lt;N&gt; predecessors(N node) {
      return delegate().successors(node); // transpose
    }

    @Override
    public Set&lt;N&gt; successors(N node) {</B></FONT>
      return delegate().predecessors(node); // transpose
    }

    @Override
    public Set&lt;EndpointPair&lt;N&gt;&gt; incidentEdges(N node) {
      return new IncidentEdgeSet&lt;N&gt;(this, node) {
        @Override
        public Iterator&lt;EndpointPair&lt;N&gt;&gt; iterator() {
          return Iterators.transform(
<A NAME="12"></A>              delegate().incidentEdges(node).iterator(),
              new Function&lt;EndpointPair&lt;N&gt;, EndpointPair&lt;N&gt;&gt;() {
                @Override
                public EndpointPair&lt;N&gt; apply(<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match310530-1.html#12',3,'match310530-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>EndpointPair&lt;N&gt; edge) {
                  return EndpointPair.of(delegate(), edge.nodeV(), edge.nodeU());
                }</B></FONT>
              });
        }
      };
    }

    @Override
    public int inDegree(N node) {
      return delegate().outDegree(node); // transpose
<A NAME="3"></A>    }

    @Override
    public int outDegree(<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match310530-1.html#3',3,'match310530-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>N node) {
      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate</B></FONT>().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }
  }

  // NOTE: this should work as long as the delegate graph's implementation of edges() (like that of
  // AbstractValueGraph) derives its behavior from calling successors().
  private static class TransposedValueGraph&lt;N, V&gt; extends ForwardingValueGraph&lt;N, V&gt; {
<A NAME="5"></A>    private final ValueGraph&lt;N, V&gt; graph;

    TransposedValueGraph(ValueGraph&lt;N, V&gt; graph) {
      <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match310530-1.html#5',3,'match310530-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>this.graph = graph;
    }

    @Override
    ValueGraph&lt;N, V&gt; delegate() {
      return graph;
    }

    @Override
    public Set&lt;N&gt; predecessors(N node) {</B></FONT>
      return delegate().successors(node); // transpose
    }

    @Override
    public Set&lt;N&gt; successors(N node) {
      return delegate().predecessors(node); // transpose
    }

    @Override
    public int inDegree(N node) {
      return delegate().outDegree(node); // transpose
    }

    @Override
    public int outDegree(N node) {
      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }

    @Override
    @CheckForNull
    public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
      return delegate().edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose
    }

    @Override
    @CheckForNull
    public V edgeValueOrDefault(EndpointPair&lt;N&gt; endpoints, @CheckForNull V defaultValue) {
      return delegate().edgeValueOrDefault(transpose(endpoints), defaultValue);
    }
  }

  private static class TransposedNetwork&lt;N, E&gt; extends ForwardingNetwork&lt;N, E&gt; {
    private final Network&lt;N, E&gt; network;

    TransposedNetwork(Network&lt;N, E&gt; network) {
<A NAME="9"></A>      this.network = network;
    }

    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match310530-1.html#9',3,'match310530-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    Network&lt;N, E&gt; delegate() {
      return network;
    }

    @Override
    public Set&lt;N&gt; predecessors(N node) {</B></FONT>
      return delegate().successors(node); // transpose
    }

    @Override
    public Set&lt;N&gt; successors(N node) {
      return delegate().predecessors(node); // transpose
    }

    @Override
    public int inDegree(N node) {
      return delegate().outDegree(node); // transpose
    }

    @Override
    public int outDegree(N node) {
      return delegate().inDegree(node); // transpose
    }

    @Override
    public Set&lt;E&gt; inEdges(N node) {
      return delegate().outEdges(node); // transpose
    }
<A NAME="7"></A>
    @Override
    public Set&lt;E&gt; outEdges(N node) {
      return <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match310530-1.html#7',3,'match310530-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate().inEdges(node); // transpose
    }

<A NAME="4"></A>    @Override
    public EndpointPair&lt;N&gt; incidentNodes(E edge) {
      EndpointPair&lt;N&gt; endpointPair = delegate</B></FONT>().incidentNodes(edge);
      return <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match310530-1.html#4',3,'match310530-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>EndpointPair.of(network, endpointPair.nodeV(), endpointPair.nodeU()); // transpose
    }

    @Override
    public Set&lt;E&gt; edgesConnecting(N nodeU, N nodeV) {
      return delegate</B></FONT>().edgesConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public Set&lt;E&gt; edgesConnecting(EndpointPair&lt;N&gt; endpoints) {
      return delegate().edgesConnecting(transpose(endpoints));
    }

<A NAME="8"></A>    @Override
    @CheckForNull
    public E edgeConnectingOrNull(N nodeU, N nodeV) {
      <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match310530-1.html#8',3,'match310530-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return delegate().edgeConnectingOrNull(nodeV, nodeU); // transpose
    }

    @Override
    @CheckForNull
    public E edgeConnectingOrNull(EndpointPair&lt;N&gt; endpoints) {</B></FONT>
      return delegate().edgeConnectingOrNull(transpose(endpoints));
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }
  }

  // Graph copy methods

  /**
   * Returns the subgraph of {@code graph} induced by {@code nodes}. This subgraph is a new graph
   * that contains all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges}
   * from {@code graph} for which both nodes are contained by {@code nodes}.
   *
   * @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph
   */
  public static &lt;N&gt; MutableGraph&lt;N&gt; inducedSubgraph(Graph&lt;N&gt; graph, Iterable&lt;? extends N&gt; nodes) {
    MutableGraph&lt;N&gt; subgraph =
        (nodes instanceof Collection)
            ? GraphBuilder.from(graph).expectedNodeCount(((Collection) nodes).size()).build()
            : GraphBuilder.from(graph).build();
    for (N node : nodes) {
      subgraph.addNode(node);
    }
    for (N node : subgraph.nodes()) {
      for (N successorNode : graph.successors(node)) {
        if (subgraph.nodes().contains(successorNode)) {
          subgraph.putEdge(node, successorNode);
        }
      }
    }
    return subgraph;
  }

  /**
   * Returns the subgraph of {@code graph} induced by {@code nodes}. This subgraph is a new graph
   * that contains all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges}
   * (and associated edge values) from {@code graph} for which both nodes are contained by {@code
   * nodes}.
   *
   * @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph
   */
  public static &lt;N, V&gt; MutableValueGraph&lt;N, V&gt; inducedSubgraph(
      ValueGraph&lt;N, V&gt; graph, Iterable&lt;? extends N&gt; nodes) {
    MutableValueGraph&lt;N, V&gt; subgraph =
        (nodes instanceof Collection)
            ? ValueGraphBuilder.from(graph).expectedNodeCount(((Collection) nodes).size()).build()
            : ValueGraphBuilder.from(graph).build();
    for (N node : nodes) {
      subgraph.addNode(node);
    }
    for (N node : subgraph.nodes()) {
      for (N successorNode : graph.successors(node)) {
        if (subgraph.nodes().contains(successorNode)) {
          // requireNonNull is safe because the endpoint pair comes from the graph.
          subgraph.putEdgeValue(
              node,
              successorNode,
              requireNonNull(graph.edgeValueOrDefault(node, successorNode, null)));
        }
      }
    }
    return subgraph;
  }

  /**
   * Returns the subgraph of {@code network} induced by {@code nodes}. This subgraph is a new graph
   * that contains all of the nodes in {@code nodes}, and all of the {@link Network#edges() edges}
   * from {@code network} for which the {@link Network#incidentNodes(Object) incident nodes} are
   * both contained by {@code nodes}.
   *
   * @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph
   */
  public static &lt;N, E&gt; MutableNetwork&lt;N, E&gt; inducedSubgraph(
      Network&lt;N, E&gt; network, Iterable&lt;? extends N&gt; nodes) {
    MutableNetwork&lt;N, E&gt; subgraph =
        (nodes instanceof Collection)
            ? NetworkBuilder.from(network).expectedNodeCount(((Collection) nodes).size()).build()
            : NetworkBuilder.from(network).build();
    for (N node : nodes) {
      subgraph.addNode(node);
    }
    for (N node : subgraph.nodes()) {
      for (E edge : network.outEdges(node)) {
        N successorNode = network.incidentNodes(edge).adjacentNode(node);
        if (subgraph.nodes().contains(successorNode)) {
          subgraph.addEdge(node, successorNode, edge);
        }
      }
    }
    return subgraph;
  }

  /** Creates a mutable copy of {@code graph} with the same nodes and edges. */
  public static &lt;N&gt; MutableGraph&lt;N&gt; copyOf(Graph&lt;N&gt; graph) {
    MutableGraph&lt;N&gt; copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
    for (N node : graph.nodes()) {
      copy.addNode(node);
    }
    for (EndpointPair&lt;N&gt; edge : graph.edges()) {
      copy.putEdge(edge.nodeU(), edge.nodeV());
    }
    return copy;
  }

  /** Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values. */
  public static &lt;N, V&gt; MutableValueGraph&lt;N, V&gt; copyOf(ValueGraph&lt;N, V&gt; graph) {
    MutableValueGraph&lt;N, V&gt; copy =
        ValueGraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
    for (N node : graph.nodes()) {
      copy.addNode(node);
    }
    for (EndpointPair&lt;N&gt; edge : graph.edges()) {
      // requireNonNull is safe because the endpoint pair comes from the graph.
      copy.putEdgeValue(
          edge.nodeU(),
          edge.nodeV(),
          requireNonNull(graph.edgeValueOrDefault(edge.nodeU(), edge.nodeV(), null)));
    }
    return copy;
  }

  /** Creates a mutable copy of {@code network} with the same nodes and edges. */
  public static &lt;N, E&gt; MutableNetwork&lt;N, E&gt; copyOf(Network&lt;N, E&gt; network) {
    MutableNetwork&lt;N, E&gt; copy =
        NetworkBuilder.from(network)
            .expectedNodeCount(network.nodes().size())
            .expectedEdgeCount(network.edges().size())
            .build();
    for (N node : network.nodes()) {
      copy.addNode(node);
<A NAME="2"></A>    }
    for (E edge : network.edges()) {
      EndpointPair&lt;N&gt; endpointPair = network.incidentNodes(edge);
      copy.addEdge(endpointPair.nodeU(), <FONT color="#980517"><A HREF="javascript:ZweiFrames('match310530-1.html#2',3,'match310530-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>endpointPair.nodeV(), edge);
    }
    return copy;
  }

  @CanIgnoreReturnValue
  static int checkNonNegative(int value) {
    checkArgument(value &gt;= 0, &quot;Not true that %s is non-negative.&quot;, value);
    return value;
  }

  @CanIgnoreReturn</B></FONT>Value
  static long checkNonNegative(long value) {
    checkArgument(value &gt;= 0, &quot;Not true that %s is non-negative.&quot;, value);
    return value;
  }

  @CanIgnoreReturnValue
  static int checkPositive(int value) {
    checkArgument(value &gt; 0, &quot;Not true that %s is positive.&quot;, value);
    return value;
  }

  @CanIgnoreReturnValue
  static long checkPositive(long value) {
    checkArgument(value &gt; 0, &quot;Not true that %s is positive.&quot;, value);
    return value;
  }

  /**
   * An enum representing the state of a node during DFS. {@code PENDING} means that the node is on
   * the stack of the DFS, while {@code COMPLETE} means that the node and all its successors have
   * been already explored. Any node that has not been explored will not have a state at all.
   */
  private enum NodeVisitState {
    PENDING,
    COMPLETE
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableRangeSet.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkElementIndex;
<A NAME="0"></A>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_HIGHER;
import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_LOWER;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#0',2,'match310530-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.collect.SortedLists.KeyPresentBehavior.ANY_PRESENT;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.SortedLists.KeyAbsentBehavior;
import com.google.common.collect.SortedLists.KeyPresentBehavior;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import javax.annotation.CheckForNull;

/**
 * A {@link RangeSet} whose contents will never change, with many other important properties
 * detailed at {@link ImmutableCollection}.
 *
 * @author Louis Wasserman
 * @since 14.0
 */
@Beta
@</B></FONT>GwtIncompatible
@ElementTypesAreNonnullByDefault
public final class ImmutableRangeSet&lt;C extends Comparable&gt; extends AbstractRangeSet&lt;C&gt;
    implements Serializable {

  private static final ImmutableRangeSet&lt;Comparable&lt;?&gt;&gt; EMPTY =
      new ImmutableRangeSet&lt;&gt;(ImmutableList.&lt;Range&lt;Comparable&lt;?&gt;&gt;&gt;of());

  private static final ImmutableRangeSet&lt;Comparable&lt;?&gt;&gt; ALL =
      new ImmutableRangeSet&lt;&gt;(ImmutableList.of(Range.&lt;Comparable&lt;?&gt;&gt;all()));

  /**
   * Returns an empty immutable range set.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; the instance returned is a singleton.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; of() {
    return (ImmutableRangeSet&lt;C&gt;) EMPTY;
  }

  /**
   * Returns an immutable range set containing the specified single range. If {@link Range#isEmpty()
   * range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.
   */
  public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; of(Range&lt;C&gt; range) {
    checkNotNull(range);
    if (range.isEmpty()) {
      return of();
    } else if (range.equals(Range.all())) {
      return all();
    } else {
      return new ImmutableRangeSet&lt;C&gt;(ImmutableList.of(range));
    }
  }

  /** Returns an immutable range set containing the single range {@link Range#all()}. */
  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; all() {
    return (ImmutableRangeSet&lt;C&gt;) ALL;
  }

  /** Returns an immutable copy of the specified {@code RangeSet}. */
  public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; copyOf(RangeSet&lt;C&gt; rangeSet) {
    checkNotNull(rangeSet);
    if (rangeSet.isEmpty()) {
      return of();
    } else if (rangeSet.encloses(Range.&lt;C&gt;all())) {
      return all();
    }

    if (rangeSet instanceof ImmutableRangeSet) {
      ImmutableRangeSet&lt;C&gt; immutableRangeSet = (ImmutableRangeSet&lt;C&gt;) rangeSet;
      if (!immutableRangeSet.isPartialView()) {
        return immutableRangeSet;
      }
    }
    return new ImmutableRangeSet&lt;C&gt;(ImmutableList.copyOf(rangeSet.asRanges()));
  }

  /**
   * Returns an {@code ImmutableRangeSet} containing each of the specified disjoint ranges.
   * Overlapping ranges and empty ranges are forbidden, though adjacent ranges are permitted and
   * will be merged.
   *
   * @throws IllegalArgumentException if any ranges overlap or are empty
   * @since 21.0
   */
  public static &lt;C extends Comparable&lt;?&gt;&gt; ImmutableRangeSet&lt;C&gt; copyOf(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
    return new ImmutableRangeSet.Builder&lt;C&gt;().addAll(ranges).build();
  }

  /**
   * Returns an {@code ImmutableRangeSet} representing the union of the specified ranges.
   *
   * &lt;p&gt;This is the smallest {@code RangeSet} which encloses each of the specified ranges. Duplicate
   * or connected ranges are permitted, and will be coalesced in the result.
   *
   * @since 21.0
   */
  public static &lt;C extends Comparable&lt;?&gt;&gt; ImmutableRangeSet&lt;C&gt; unionOf(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
    return copyOf(TreeRangeSet.create(ranges));
  }

  ImmutableRangeSet(ImmutableList&lt;Range&lt;C&gt;&gt; ranges) {
    this.ranges = ranges;
  }

  private ImmutableRangeSet(ImmutableList&lt;Range&lt;C&gt;&gt; ranges, ImmutableRangeSet&lt;C&gt; complement) {
    this.ranges = ranges;
    this.complement = complement;
  }

  private final transient ImmutableList&lt;Range&lt;C&gt;&gt; ranges;

  @Override
  public boolean intersects(Range&lt;C&gt; otherRange) {
    int ceilingIndex =
        SortedLists.binarySearch(
            ranges,
            Range.&lt;C&gt;lowerBoundFn(),
            otherRange.lowerBound,
<A NAME="6"></A>            Ordering.natural(),
            ANY_PRESENT,
            NEXT_HIGHER);
    if (ceilingIndex &lt; <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#6',2,'match310530-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ranges.size()
        &amp;&amp; ranges.get(ceilingIndex).isConnected(otherRange)
        &amp;&amp; !ranges.get(ceilingIndex).intersection(otherRange).isEmpty()) {
      return true;
<A NAME="7"></A>    }
    return ceilingIndex &gt; 0
        &amp;&amp; ranges.get</B></FONT>(ceilingIndex - 1).isConnected(otherRange)
        &amp;&amp; !<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#7',2,'match310530-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ranges.get(ceilingIndex - 1).intersection(otherRange).isEmpty();
  }

  @Override
  public boolean encloses(Range&lt;C&gt; otherRange) {
    int index =
        SortedLists.binarySearch(
            ranges,
            Range.&lt;C&gt;lowerBoundFn</B></FONT>(),
            otherRange.lowerBound,
<A NAME="8"></A>            Ordering.natural(),
            ANY_PRESENT,
            NEXT_LOWER);
    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#8',2,'match310530-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return index != -1 &amp;&amp; ranges.get(index).encloses(otherRange);
  }

  @Override
  @CheckForNull
  public Range&lt;C&gt; rangeContaining(C value) {</B></FONT>
    int index =
        SortedLists.binarySearch(
            ranges,
            Range.&lt;C&gt;lowerBoundFn(),
            Cut.belowValue(value),
            Ordering.natural(),
            ANY_PRESENT,
            NEXT_LOWER);
    if (index != -1) {
      Range&lt;C&gt; range = ranges.get(index);
      return range.contains(value) ? range : null;
    }
    return null;
  }

  @Override
  public Range&lt;C&gt; span() {
    if (ranges.isEmpty()) {
      throw new NoSuchElementException();
    }
    return Range.create(ranges.get(0).lowerBound, ranges.get(ranges.size() - 1).upperBound);
  }

  @Override
  public boolean isEmpty() {
    return ranges.isEmpty();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void add(Range&lt;C&gt; range) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void addAll(RangeSet&lt;C&gt; other) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void addAll(Iterable&lt;Range&lt;C&gt;&gt; other) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void remove(Range&lt;C&gt; range) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void removeAll(RangeSet&lt;C&gt; other) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  public void removeAll(Iterable&lt;Range&lt;C&gt;&gt; other) {
    throw new UnsupportedOperationException();
  }

  @Override
  public ImmutableSet&lt;Range&lt;C&gt;&gt; asRanges() {
    if (ranges.isEmpty()) {
      return ImmutableSet.of();
    }
    return new RegularImmutableSortedSet&lt;&gt;(ranges, Range.&lt;C&gt;rangeLexOrdering());
  }

  @Override
  public ImmutableSet&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges() {
    if (ranges.isEmpty()) {
      return ImmutableSet.of();
    }
    return new RegularImmutableSortedSet&lt;&gt;(ranges.reverse(), Range.&lt;C&gt;rangeLexOrdering().reverse());
  }

  @LazyInit @CheckForNull private transient ImmutableRangeSet&lt;C&gt; complement;

  private final class ComplementRanges extends ImmutableList&lt;Range&lt;C&gt;&gt; {
    // True if the &quot;positive&quot; range set is empty or bounded below.
    private final boolean positiveBoundedBelow;

    // True if the &quot;positive&quot; range set is empty or bounded above.
    private final boolean positiveBoundedAbove;

    private final int size;

    ComplementRanges() {
      this.positiveBoundedBelow = ranges.get(0).hasLowerBound();
      this.positiveBoundedAbove = Iterables.getLast(ranges).hasUpperBound();

      int size = ranges.size() - 1;
      if (positiveBoundedBelow) {
        size++;
      }
<A NAME="5"></A>      if (positiveBoundedAbove) {
        size++;
      }
      <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#5',2,'match310530-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.size = size;
    }

    @Override
    public int size() {
      return size;
    }

    @Override
    public Range&lt;C&gt; get(int index) {</B></FONT>
      checkElementIndex(index, size);

      Cut&lt;C&gt; lowerBound;
      if (positiveBoundedBelow) {
        lowerBound = (index == 0) ? Cut.&lt;C&gt;belowAll() : ranges.get(index - 1).upperBound;
      } else {
        lowerBound = ranges.get(index).upperBound;
      }

      Cut&lt;C&gt; upperBound;
      if (positiveBoundedAbove &amp;&amp; index == size - 1) {
        upperBound = Cut.&lt;C&gt;aboveAll();
      } else {
        upperBound = ranges.get(index + (positiveBoundedBelow ? 0 : 1)).lowerBound;
      }

      return Range.create(lowerBound, upperBound);
    }

    @Override
    boolean isPartialView() {
      return true;
    }
  }

  @Override
  public ImmutableRangeSet&lt;C&gt; complement() {
    ImmutableRangeSet&lt;C&gt; result = complement;
    if (result != null) {
      return result;
    } else if (ranges.isEmpty()) {
      return complement = all();
    } else if (ranges.size() == 1 &amp;&amp; ranges.get(0).equals(Range.all())) {
      return complement = of();
    } else {
      ImmutableList&lt;Range&lt;C&gt;&gt; complementRanges = new ComplementRanges();
      result = complement = new ImmutableRangeSet&lt;C&gt;(complementRanges, this);
    }
    return result;
  }

  /**
   * Returns a new range set consisting of the union of this range set and {@code other}.
   *
   * &lt;p&gt;This is essentially the same as {@code TreeRangeSet.create(this).addAll(other)} except it
   * returns an {@code ImmutableRangeSet}.
<A NAME="12"></A>   *
   * @since 21.0
   */
  public ImmutableRangeSet&lt;C&gt; union(<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#12',2,'match310530-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>RangeSet&lt;C&gt; other) {
    return unionOf(Iterables.concat(asRanges(), other.asRanges()));
  }</B></FONT>

  /**
   * Returns a new range set consisting of the intersection of this range set and {@code other}.
   *
   * &lt;p&gt;This is essentially the same as {@code
   * TreeRangeSet.create(this).removeAll(other.complement())} except it returns an {@code
   * ImmutableRangeSet}.
   *
   * @since 21.0
   */
  public ImmutableRangeSet&lt;C&gt; intersection(RangeSet&lt;C&gt; other) {
    RangeSet&lt;C&gt; copy = TreeRangeSet.create(this);
    copy.removeAll(other.complement());
    return copyOf(copy);
  }

  /**
   * Returns a new range set consisting of the difference of this range set and {@code other}.
   *
   * &lt;p&gt;This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other)} except it
   * returns an {@code ImmutableRangeSet}.
   *
   * @since 21.0
   */
  public ImmutableRangeSet&lt;C&gt; difference(RangeSet&lt;C&gt; other) {
    RangeSet&lt;C&gt; copy = TreeRangeSet.create(this);
    copy.removeAll(other);
    return copyOf(copy);
  }

  /**
   * Returns a list containing the nonempty intersections of {@code range} with the ranges in this
   * range set.
   */
  private ImmutableList&lt;Range&lt;C&gt;&gt; intersectRanges(final Range&lt;C&gt; range) {
    if (ranges.isEmpty() || range.isEmpty()) {
      return ImmutableList.of();
    } else if (range.encloses(span())) {
      return ranges;
    }

    final int fromIndex;
    if (range.hasLowerBound()) {
      fromIndex =
          SortedLists.binarySearch(
              ranges,
              Range.&lt;C&gt;upperBoundFn(),
              range.lowerBound,
              KeyPresentBehavior.FIRST_AFTER,
              KeyAbsentBehavior.NEXT_HIGHER);
    } else {
      fromIndex = 0;
    }

    int toIndex;
    if (range.hasUpperBound()) {
      toIndex =
          SortedLists.binarySearch(
              ranges,
              Range.&lt;C&gt;lowerBoundFn(),
              range.upperBound,
              KeyPresentBehavior.FIRST_PRESENT,
              KeyAbsentBehavior.NEXT_HIGHER);
    } else {
      toIndex = ranges.size();
    }
    final int length = toIndex - fromIndex;
    if (length == 0) {
<A NAME="9"></A>      return ImmutableList.of();
    } else {
      return new ImmutableList&lt;Range&lt;C&gt;&gt;() {
        <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#9',2,'match310530-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
        public int size() {
          return length;
        }

        @Override
        public Range&lt;C&gt; get(int index) {</B></FONT>
          checkElementIndex(index, length);
          if (index == 0 || index == length - 1) {
            return ranges.get(index + fromIndex).intersection(range);
          } else {
            return ranges.get(index + fromIndex);
          }
        }

        @Override
        boolean isPartialView() {
          return true;
        }
      };
    }
  }

  /** Returns a view of the intersection of this range set with the given range. */
  @Override
  public ImmutableRangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; range) {
    if (!isEmpty()) {
      Range&lt;C&gt; span = span();
      if (range.encloses(span)) {
        return this;
      } else if (range.isConnected(span)) {
        return new ImmutableRangeSet&lt;C&gt;(intersectRanges(range));
      }
    }
    return of();
  }

  /**
   * Returns an {@link ImmutableSortedSet} containing the same values in the given domain
   * {@linkplain RangeSet#contains contained} by this range set.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; {@code a.asSet(d).equals(b.asSet(d))} does not imply {@code a.equals(b)}! For
   * example, {@code a} and {@code b} could be {@code [2..4]} and {@code (1..5)}, or the empty
   * ranges {@code [3..3)} and {@code [4..4)}.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Be extremely careful what you do with the {@code asSet} view of a large
   * range set (such as {@code ImmutableRangeSet.of(Range.greaterThan(0))}). Certain operations on
   * such a set can be performed efficiently, but others (such as {@link Set#hashCode} or {@link
   * Collections#frequency}) can cause major performance problems.
   *
   * &lt;p&gt;The returned set's {@link Object#toString} method returns a short-hand form of the set's
   * contents, such as {@code &quot;[1..100]}&quot;}.
   *
   * @throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if
   *     neither has an upper bound
   */
  public ImmutableSortedSet&lt;C&gt; asSet(DiscreteDomain&lt;C&gt; domain) {
    checkNotNull(domain);
    if (isEmpty()) {
      return ImmutableSortedSet.of();
    }
    Range&lt;C&gt; span = span().canonical(domain);
    if (!span.hasLowerBound()) {
      // according to the spec of canonical, neither this ImmutableRangeSet nor
      // the range have a lower bound
      throw new IllegalArgumentException(
          &quot;Neither the DiscreteDomain nor this range set are bounded below&quot;);
    } else if (!span.hasUpperBound()) {
      try {
        domain.maxValue();
      } catch (NoSuchElementException e) {
        throw new IllegalArgumentException(
            &quot;Neither the DiscreteDomain nor this range set are bounded above&quot;);
      }
    }

    return new AsSet(domain);
  }

  private final class AsSet extends ImmutableSortedSet&lt;C&gt; {
    private final DiscreteDomain&lt;C&gt; domain;

    AsSet(DiscreteDomain&lt;C&gt; domain) {
      super(Ordering.natural());
      this.domain = domain;
    }

    @CheckForNull private transient Integer size;

    @Override
    public int size() {
      // racy single-check idiom
      Integer result = size;
      if (result == null) {
        long total = 0;
        for (Range&lt;C&gt; range : ranges) {
          total += ContiguousSet.create(range, domain).size();
          if (total &gt;= Integer.MAX_VALUE) {
            break;
          }
        }
        result = size = Ints.saturatedCast(total);
      }
      return result.intValue();
    }

    @Override
    public UnmodifiableIterator&lt;C&gt; iterator() {
      return new AbstractIterator&lt;C&gt;() {
        final Iterator&lt;Range&lt;C&gt;&gt; rangeItr = ranges.iterator();
        Iterator&lt;C&gt; elemItr = Iterators.emptyIterator();

        @Override
        @CheckForNull
        protected C computeNext() {
          while (!elemItr.hasNext()) {
            if (rangeItr.hasNext()) {
              elemItr = ContiguousSet.create(rangeItr.next(), domain).iterator();
            } else {
              return endOfData();
            }
          }
          return elemItr.next();
        }
      };
    }

    @Override
    @GwtIncompatible(&quot;NavigableSet&quot;)
    public UnmodifiableIterator&lt;C&gt; descendingIterator() {
      return new AbstractIterator&lt;C&gt;() {
        final Iterator&lt;Range&lt;C&gt;&gt; rangeItr = ranges.reverse().iterator();
        Iterator&lt;C&gt; elemItr = Iterators.emptyIterator();

        @Override
        @CheckForNull
        protected C computeNext() {
          while (!elemItr.hasNext()) {
            if (rangeItr.hasNext()) {
              elemItr = ContiguousSet.create(rangeItr.next(), domain).descendingIterator();
            } else {
              return endOfData();
            }
          }
          return elemItr.next();
        }
<A NAME="3"></A>      };
    }

    ImmutableSortedSet&lt;C&gt; subSet(<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#3',2,'match310530-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Range&lt;C&gt; range) {
      return subRangeSet(range).asSet(domain);
    }

    @Override
    ImmutableSortedSet&lt;C&gt; headSetImpl(C toElement, boolean inclusive) {
      return subSet(Range.upTo</B></FONT>(toElement, BoundType.forBoolean(inclusive)));
    }

    @Override
    ImmutableSortedSet&lt;C&gt; subSetImpl(
        C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {
      if (!fromInclusive &amp;&amp; !toInclusive &amp;&amp; Range.compareOrThrow(fromElement, toElement) == 0) {
<A NAME="4"></A>        return ImmutableSortedSet.of();
      }
      return subSet(
          <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#4',2,'match310530-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Range.range(
              fromElement, BoundType.forBoolean(fromInclusive),
              toElement, BoundType.forBoolean(toInclusive)));
    }

    @Override
    ImmutableSortedSet&lt;C&gt; tailSetImpl(C fromElement, boolean inclusive) {
      return subSet(Range.downTo</B></FONT>(fromElement, BoundType.forBoolean(inclusive)));
    }

    @Override
    public boolean contains(@CheckForNull Object o) {
      if (o == null) {
        return false;
      }
      try {
        @SuppressWarnings(&quot;unchecked&quot;) // we catch CCE's
        C c = (C) o;
        return ImmutableRangeSet.this.contains(c);
      } catch (ClassCastException e) {
        return false;
      }
    }

    @Override
    int indexOf(@CheckForNull Object target) {
      if (contains(target)) {
<A NAME="11"></A>        @SuppressWarnings(&quot;unchecked&quot;) // if it's contained, it's definitely a C
        C c = (C) requireNonNull(target);
        long total = 0;
        for (<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#11',2,'match310530-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Range&lt;C&gt; range : ranges) {
          if (range.contains(c)) {
            return Ints.saturatedCast(total + ContiguousSet.create(range, domain).indexOf(c));
          }</B></FONT> else {
            total += ContiguousSet.create(range, domain).size();
          }
        }
        throw new AssertionError(&quot;impossible&quot;);
      }
      return -1;
    }

    @Override
    ImmutableSortedSet&lt;C&gt; createDescendingSet() {
      return new DescendingImmutableSortedSet&lt;C&gt;(this);
    }

    @Override
    boolean isPartialView() {
      return ranges.isPartialView();
    }

    @Override
    public String toString() {
      return ranges.toString();
    }

    @Override
    Object writeReplace() {
      return new AsSetSerializedForm&lt;C&gt;(ranges, domain);
    }
  }

  private static class AsSetSerializedForm&lt;C extends Comparable&gt; implements Serializable {
    private final ImmutableList&lt;Range&lt;C&gt;&gt; ranges;
    private final DiscreteDomain&lt;C&gt; domain;

    AsSetSerializedForm(ImmutableList&lt;Range&lt;C&gt;&gt; ranges, DiscreteDomain&lt;C&gt; domain) {
      this.ranges = ranges;
      this.domain = domain;
    }

    Object readResolve() {
      return new ImmutableRangeSet&lt;C&gt;(ranges).asSet(domain);
    }
  }

  /**
   * Returns {@code true} if this immutable range set's implementation contains references to
   * user-created objects that aren't accessible via this range set's methods. This is generally
   * used to determine whether {@code copyOf} implementations should make an explicit copy to avoid
   * memory leaks.
   */
  boolean isPartialView() {
    return ranges.isPartialView();
  }

  /** Returns a new builder for an immutable range set. */
  public static &lt;C extends Comparable&lt;?&gt;&gt; Builder&lt;C&gt; builder() {
    return new Builder&lt;C&gt;();
  }

  /**
   * A builder for immutable range sets.
   *
   * @since 14.0
   */
  public static class Builder&lt;C extends Comparable&lt;?&gt;&gt; {
    private final List&lt;Range&lt;C&gt;&gt; ranges;

    public Builder() {
      this.ranges = Lists.newArrayList();
    }

    // TODO(lowasser): consider adding union, in addition to add, that does allow overlap

    /**
     * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,
     * but overlapping ranges will cause an exception when {@link #build()} is called.
     *
     * @throws IllegalArgumentException if {@code range} is empty
     */
    @CanIgnoreReturnValue
<A NAME="1"></A>    public Builder&lt;C&gt; add(Range&lt;C&gt; range) {
      checkArgument(!range.isEmpty(), &quot;range must not be empty, but was %s&quot;, range);
      ranges.add(range);
      <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#1',2,'match310530-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return this;
    }

    /**
     * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted
     * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is
     * called.
     */
    @CanIgnoreReturnValue
    public Builder&lt;C&gt; addAll(RangeSet&lt;C&gt; ranges) {
      return addAll(ranges.asRanges());
    }

    /**
     * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be
     * merged, but overlapping ranges will cause an exception when {@link #build()} is called.
     *
     * @throws IllegalArgumentException if any inserted ranges are empty
     * @since 21.0
     */
<A NAME="2"></A>    @CanIgnoreReturnValue
    public Builder&lt;C&gt; addAll(Iterable&lt;Range&lt;C&gt;&gt; ranges) {</B></FONT>
      for (Range&lt;C&gt; range : ranges) {
        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#2',2,'match310530-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>add(range);
      }
      return this;
    }

    @CanIgnoreReturnValue
    Builder&lt;C&gt; combine(Builder&lt;C&gt; builder) {
      addAll(builder.ranges);
      return this;
    }

    /**
     * Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.
     *
     * @throws IllegalArgumentException if any input ranges have nonempty overlap
     */
    publi</B></FONT>c ImmutableRangeSet&lt;C&gt; build() {
      ImmutableList.Builder&lt;Range&lt;C&gt;&gt; mergedRangesBuilder =
          new ImmutableList.Builder&lt;&gt;(ranges.size());
      Collections.sort(ranges, Range.&lt;C&gt;rangeLexOrdering());
      PeekingIterator&lt;Range&lt;C&gt;&gt; peekingItr = Iterators.peekingIterator(ranges.iterator());
      while (peekingItr.hasNext()) {
        Range&lt;C&gt; range = peekingItr.next();
        while (peekingItr.hasNext()) {
          Range&lt;C&gt; nextRange = peekingItr.peek();
          if (range.isConnected(nextRange)) {
            checkArgument(
                range.intersection(nextRange).isEmpty(),
                &quot;Overlapping ranges not permitted but found %s overlapping %s&quot;,
                range,
                nextRange);
            range = range.span(peekingItr.next());
          } else {
            break;
          }
        }
        mergedRangesBuilder.add(range);
      }
      ImmutableList&lt;Range&lt;C&gt;&gt; mergedRanges = mergedRangesBuilder.build();
      if (mergedRanges.isEmpty()) {
        return of();
      } else if (mergedRanges.size() == 1
          &amp;&amp; Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {
        return all();
      } else {
        return new ImmutableRangeSet&lt;C&gt;(mergedRanges);
      }
<A NAME="10"></A>    }
  }

  <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match310530-0.html#10',2,'match310530-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final class SerializedForm&lt;C extends Comparable&gt; implements Serializable {
    private final ImmutableList&lt;Range&lt;C&gt;&gt; ranges;

    SerializedForm(ImmutableList&lt;Range&lt;C&gt;&gt; ranges) {
      this.ranges = ranges;
    }

    Object read</B></FONT>Resolve() {
      if (ranges.isEmpty()) {
        return of();
      } else if (ranges.equals(ImmutableList.of(Range.all()))) {
        return all();
      } else {
        return new ImmutableRangeSet&lt;C&gt;(ranges);
      }
    }
  }

  Object writeReplace() {
    return new SerializedForm&lt;C&gt;(ranges);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
