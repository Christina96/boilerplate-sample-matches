<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Graphs.java &amp; ImmutableRangeSet.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Graphs.java &amp; ImmutableRangeSet.java
      </h3>
<h1 align="center">
        16.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Graphs.java (18.21192%)<th>ImmutableRangeSet.java (15.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-46)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(271-280)<td><a href="#" name="1">(738-759)</a><td align="center"><font color="#cc0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(587-598)<td><a href="#" name="2">(761-777)</a><td align="center"><font color="#bf0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(307-313)<td><a href="#" name="3">(606-612)</a><td align="center"><font color="#bf0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(424-429)<td><a href="#" name="4">(622-629)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(328-337)<td><a href="#" name="5">(324-333)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(90-94)<td><a href="#" name="6">(154-160)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(418-423)<td><a href="#" name="7">(161-169)</a><td align="center"><font color="#8c0000">11</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(440-445)<td><a href="#" name="8">(174-179)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(386-392)<td><a href="#" name="9">(457-463)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(262-269)<td><a href="#" name="10">(811-818)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(253-256)<td><a href="#" name="11">(652-655)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(293-295)<td><a href="#" name="12">(383-385)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Graphs.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.graph;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
4 import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;
5 import static java.util.Objects.requireNonNull;
6 import com.google.common.annotations.Beta;
7 import com.google.common.base.Function;
8 import com.google.common.base.Objects;
9 import com.google.common.collect.ImmutableSet;
10 import com.google.common.collect.Iterables;
11 import com.google.common.collect.Iterators;
12 import com.google.common.collect.Maps;
13 import com.google.errorprone.annotations.CanIgnoreReturnValue;
14 import java.util.Collection;
15 import java.util.HashSet;
16 import java.util.Iterator;
17 import java.util.Map;
18 import java.util.Set;
19 import javax.annotation.CheckForNull;
20 @Beta
21 @</b></font>ElementTypesAreNonnullByDefault
22 public final class Graphs {
23   private Graphs() {}
24   public static &lt;N&gt; boolean hasCycle(Graph&lt;N&gt; graph) {
25     int numEdges = graph.edges().size();
26     if (numEdges == 0) {
27       return false;     }
28     if (!graph.isDirected() &amp;&amp; numEdges &gt;= graph.nodes().size()) {
29       return true;     }
30     Map&lt;Object, NodeVisitState&gt; visitedNodes =
31         Maps.newHashMapWithExpectedSize(graph.nodes().size());
32     for (N node : graph.nodes()) {
33       if (subgraphHasCycle(graph, visitedNodes, node, null)) {
34         return true;
35       }
36     }
37     return false;
38   }
39   public static boolean hasCycle(Network&lt;?, ?&gt; network) {
40 <a name="6"></a>        if (!network.isDirected()
41         &amp;&amp; <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>network.allowsParallelEdges()
42         &amp;&amp; network.edges().size() &gt; network.asGraph().edges().size()) {
43       return true;
44     }
45     return hasCycle(network.asGraph</b></font>());
46   }
47   private static &lt;N&gt; boolean subgraphHasCycle(
48       Graph&lt;N&gt; graph,
49       Map&lt;Object, NodeVisitState&gt; visitedNodes,
50       N node,
51       @CheckForNull N previousNode) {
52     NodeVisitState state = visitedNodes.get(node);
53     if (state == NodeVisitState.COMPLETE) {
54       return false;
55     }
56     if (state == NodeVisitState.PENDING) {
57       return true;
58     }
59     visitedNodes.put(node, NodeVisitState.PENDING);
60     for (N nextNode : graph.successors(node)) {
61       if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode)
62           &amp;&amp; subgraphHasCycle(graph, visitedNodes, nextNode, node)) {
63         return true;
64       }
65     }
66     visitedNodes.put(node, NodeVisitState.COMPLETE);
67     return false;
68   }
69   private static boolean canTraverseWithoutReusingEdge(
70       Graph&lt;?&gt; graph, Object nextNode, @CheckForNull Object previousNode) {
71     if (graph.isDirected() || !Objects.equal(previousNode, nextNode)) {
72       return true;
73     }
74     return false;
75   }
76   public static &lt;N&gt; Graph&lt;N&gt; transitiveClosure(Graph&lt;N&gt; graph) {
77     MutableGraph&lt;N&gt; transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();
78     if (graph.isDirected()) {
79       for (N node : graph.nodes()) {
80         for (N reachableNode : reachableNodes(graph, node)) {
81           transitiveClosure.putEdge(node, reachableNode);
82         }
83       }
84     } else {
85       Set&lt;N&gt; visitedNodes = new HashSet&lt;N&gt;();
86       for (N node : graph.nodes()) {
87         if (!visitedNodes.contains(node)) {
88           Set&lt;N&gt; reachableNodes = reachableNodes(graph, node);
89           visitedNodes.addAll(reachableNodes);
90           int pairwiseMatch = 1;           for (N nodeU : reachableNodes) {
91             for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {
92               transitiveClosure.putEdge(nodeU, nodeV);
93             }
94           }
95         }
96       }
97     }
98     return transitiveClosure;
99   }
100   public static &lt;N&gt; Set&lt;N&gt; reachableNodes(Graph&lt;N&gt; graph, N node) {
101     checkArgument(graph.nodes().contains(node), NODE_NOT_IN_GRAPH, node);
102     return ImmutableSet.copyOf(Traverser.forGraph(graph).breadthFirst(node));
103   }
104   public static &lt;N&gt; Graph&lt;N&gt; transpose(Graph&lt;N&gt; graph) {
105     if (!graph.isDirected()) {
106       return graph;     }
107     if (graph instanceof TransposedGraph) {
108       return ((TransposedGraph&lt;N&gt;) graph).graph;
109     }
110     return new TransposedGraph&lt;N&gt;(graph);
111   }
112   public static &lt;N, V&gt; ValueGraph&lt;N, V&gt; transpose(ValueGraph&lt;N, V&gt; graph) {
113     if (!graph.isDirected()) {
114       return graph;     }
115     if (graph instanceof TransposedValueGraph) {
116       return ((TransposedValueGraph&lt;N, V&gt;) graph).graph;
117     }
118     return new TransposedValueGraph&lt;&gt;(graph);
119   }
120   public static &lt;N, E&gt; Network&lt;N, E&gt; transpose(Network&lt;N, E&gt; network) {
121     if (!network.isDirected()) {
122       return network;     }
123     if (network instanceof TransposedNetwork) {
124       return ((TransposedNetwork&lt;N, E&gt;) network).network;
125     }
126 <a name="11"></a>    return new TransposedNetwork&lt;&gt;(network);
127   }
128   static &lt;N&gt; EndpointPair&lt;N&gt; transpose(<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>EndpointPair&lt;N&gt; endpoints) {
129     if (endpoints.isOrdered()) {
130       return EndpointPair.ordered(endpoints.target(), endpoints.source());
131     }</b></font>
132     return endpoints;
133   }
134 <a name="10"></a>
135   <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private static class TransposedGraph&lt;N&gt; extends ForwardingGraph&lt;N&gt; {
136     private final Graph&lt;N&gt; graph;
137     TransposedGraph(Graph&lt;N&gt; graph) {
138       this.graph = graph;
139     }
140 <a name="1"></a>
141     @Overrid</b></font>e
142     Graph&lt;N&gt; delegate() {
143       <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return graph;
144     }
145     @Override
146     public Set&lt;N&gt; predecessors(N node) {
147       return delegate().successors(node);     }
148     @Override
149     public Set&lt;N&gt; successors(N node) {</b></font>
150       return delegate().predecessors(node);     }
151     @Override
152     public Set&lt;EndpointPair&lt;N&gt;&gt; incidentEdges(N node) {
153       return new IncidentEdgeSet&lt;N&gt;(this, node) {
154         @Override
155         public Iterator&lt;EndpointPair&lt;N&gt;&gt; iterator() {
156           return Iterators.transform(
157 <a name="12"></a>              delegate().incidentEdges(node).iterator(),
158               new Function&lt;EndpointPair&lt;N&gt;, EndpointPair&lt;N&gt;&gt;() {
159                 @Override
160                 public EndpointPair&lt;N&gt; apply(<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>EndpointPair&lt;N&gt; edge) {
161                   return EndpointPair.of(delegate(), edge.nodeV(), edge.nodeU());
162                 }</b></font>
163               });
164         }
165       };
166     }
167     @Override
168     public int inDegree(N node) {
169       return delegate().outDegree(node); <a name="3"></a>    }
170     @Override
171     public int outDegree(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>N node) {
172       return delegate().inDegree(node);     }
173     @Override
174     public boolean hasEdgeConnecting(N nodeU, N nodeV) {
175       return delegate</b></font>().hasEdgeConnecting(nodeV, nodeU);     }
176     @Override
177     public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
178       return delegate().hasEdgeConnecting(transpose(endpoints));
179     }
180   }
181   private static class TransposedValueGraph&lt;N, V&gt; extends ForwardingValueGraph&lt;N, V&gt; {
182 <a name="5"></a>    private final ValueGraph&lt;N, V&gt; graph;
183     TransposedValueGraph(ValueGraph&lt;N, V&gt; graph) {
184       <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>this.graph = graph;
185     }
186     @Override
187     ValueGraph&lt;N, V&gt; delegate() {
188       return graph;
189     }
190     @Override
191     public Set&lt;N&gt; predecessors(N node) {</b></font>
192       return delegate().successors(node);     }
193     @Override
194     public Set&lt;N&gt; successors(N node) {
195       return delegate().predecessors(node);     }
196     @Override
197     public int inDegree(N node) {
198       return delegate().outDegree(node);     }
199     @Override
200     public int outDegree(N node) {
201       return delegate().inDegree(node);     }
202     @Override
203     public boolean hasEdgeConnecting(N nodeU, N nodeV) {
204       return delegate().hasEdgeConnecting(nodeV, nodeU);     }
205     @Override
206     public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
207       return delegate().hasEdgeConnecting(transpose(endpoints));
208     }
209     @Override
210     @CheckForNull
211     public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
212       return delegate().edgeValueOrDefault(nodeV, nodeU, defaultValue);     }
213     @Override
214     @CheckForNull
215     public V edgeValueOrDefault(EndpointPair&lt;N&gt; endpoints, @CheckForNull V defaultValue) {
216       return delegate().edgeValueOrDefault(transpose(endpoints), defaultValue);
217     }
218   }
219   private static class TransposedNetwork&lt;N, E&gt; extends ForwardingNetwork&lt;N, E&gt; {
220     private final Network&lt;N, E&gt; network;
221     TransposedNetwork(Network&lt;N, E&gt; network) {
222 <a name="9"></a>      this.network = network;
223     }
224     <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
225     Network&lt;N, E&gt; delegate() {
226       return network;
227     }
228     @Override
229     public Set&lt;N&gt; predecessors(N node) {</b></font>
230       return delegate().successors(node);     }
231     @Override
232     public Set&lt;N&gt; successors(N node) {
233       return delegate().predecessors(node);     }
234     @Override
235     public int inDegree(N node) {
236       return delegate().outDegree(node);     }
237     @Override
238     public int outDegree(N node) {
239       return delegate().inDegree(node);     }
240     @Override
241     public Set&lt;E&gt; inEdges(N node) {
242       return delegate().outEdges(node);     }
243 <a name="7"></a>
244     @Override
245     public Set&lt;E&gt; outEdges(N node) {
246       return <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate().inEdges(node);     }
247 <a name="4"></a>    @Override
248     public EndpointPair&lt;N&gt; incidentNodes(E edge) {
249       EndpointPair&lt;N&gt; endpointPair = delegate</b></font>().incidentNodes(edge);
250       return <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>EndpointPair.of(network, endpointPair.nodeV(), endpointPair.nodeU());     }
251     @Override
252     public Set&lt;E&gt; edgesConnecting(N nodeU, N nodeV) {
253       return delegate</b></font>().edgesConnecting(nodeV, nodeU);     }
254     @Override
255     public Set&lt;E&gt; edgesConnecting(EndpointPair&lt;N&gt; endpoints) {
256       return delegate().edgesConnecting(transpose(endpoints));
257     }
258 <a name="8"></a>    @Override
259     @CheckForNull
260     public E edgeConnectingOrNull(N nodeU, N nodeV) {
261       <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return delegate().edgeConnectingOrNull(nodeV, nodeU);     }
262     @Override
263     @CheckForNull
264     public E edgeConnectingOrNull(EndpointPair&lt;N&gt; endpoints) {</b></font>
265       return delegate().edgeConnectingOrNull(transpose(endpoints));
266     }
267     @Override
268     public boolean hasEdgeConnecting(N nodeU, N nodeV) {
269       return delegate().hasEdgeConnecting(nodeV, nodeU);     }
270     @Override
271     public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
272       return delegate().hasEdgeConnecting(transpose(endpoints));
273     }
274   }
275   public static &lt;N&gt; MutableGraph&lt;N&gt; inducedSubgraph(Graph&lt;N&gt; graph, Iterable&lt;? extends N&gt; nodes) {
276     MutableGraph&lt;N&gt; subgraph =
277         (nodes instanceof Collection)
278             ? GraphBuilder.from(graph).expectedNodeCount(((Collection) nodes).size()).build()
279             : GraphBuilder.from(graph).build();
280     for (N node : nodes) {
281       subgraph.addNode(node);
282     }
283     for (N node : subgraph.nodes()) {
284       for (N successorNode : graph.successors(node)) {
285         if (subgraph.nodes().contains(successorNode)) {
286           subgraph.putEdge(node, successorNode);
287         }
288       }
289     }
290     return subgraph;
291   }
292   public static &lt;N, V&gt; MutableValueGraph&lt;N, V&gt; inducedSubgraph(
293       ValueGraph&lt;N, V&gt; graph, Iterable&lt;? extends N&gt; nodes) {
294     MutableValueGraph&lt;N, V&gt; subgraph =
295         (nodes instanceof Collection)
296             ? ValueGraphBuilder.from(graph).expectedNodeCount(((Collection) nodes).size()).build()
297             : ValueGraphBuilder.from(graph).build();
298     for (N node : nodes) {
299       subgraph.addNode(node);
300     }
301     for (N node : subgraph.nodes()) {
302       for (N successorNode : graph.successors(node)) {
303         if (subgraph.nodes().contains(successorNode)) {
304           subgraph.putEdgeValue(
305               node,
306               successorNode,
307               requireNonNull(graph.edgeValueOrDefault(node, successorNode, null)));
308         }
309       }
310     }
311     return subgraph;
312   }
313   public static &lt;N, E&gt; MutableNetwork&lt;N, E&gt; inducedSubgraph(
314       Network&lt;N, E&gt; network, Iterable&lt;? extends N&gt; nodes) {
315     MutableNetwork&lt;N, E&gt; subgraph =
316         (nodes instanceof Collection)
317             ? NetworkBuilder.from(network).expectedNodeCount(((Collection) nodes).size()).build()
318             : NetworkBuilder.from(network).build();
319     for (N node : nodes) {
320       subgraph.addNode(node);
321     }
322     for (N node : subgraph.nodes()) {
323       for (E edge : network.outEdges(node)) {
324         N successorNode = network.incidentNodes(edge).adjacentNode(node);
325         if (subgraph.nodes().contains(successorNode)) {
326           subgraph.addEdge(node, successorNode, edge);
327         }
328       }
329     }
330     return subgraph;
331   }
332   public static &lt;N&gt; MutableGraph&lt;N&gt; copyOf(Graph&lt;N&gt; graph) {
333     MutableGraph&lt;N&gt; copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
334     for (N node : graph.nodes()) {
335       copy.addNode(node);
336     }
337     for (EndpointPair&lt;N&gt; edge : graph.edges()) {
338       copy.putEdge(edge.nodeU(), edge.nodeV());
339     }
340     return copy;
341   }
342   public static &lt;N, V&gt; MutableValueGraph&lt;N, V&gt; copyOf(ValueGraph&lt;N, V&gt; graph) {
343     MutableValueGraph&lt;N, V&gt; copy =
344         ValueGraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
345     for (N node : graph.nodes()) {
346       copy.addNode(node);
347     }
348     for (EndpointPair&lt;N&gt; edge : graph.edges()) {
349       copy.putEdgeValue(
350           edge.nodeU(),
351           edge.nodeV(),
352           requireNonNull(graph.edgeValueOrDefault(edge.nodeU(), edge.nodeV(), null)));
353     }
354     return copy;
355   }
356   public static &lt;N, E&gt; MutableNetwork&lt;N, E&gt; copyOf(Network&lt;N, E&gt; network) {
357     MutableNetwork&lt;N, E&gt; copy =
358         NetworkBuilder.from(network)
359             .expectedNodeCount(network.nodes().size())
360             .expectedEdgeCount(network.edges().size())
361             .build();
362     for (N node : network.nodes()) {
363       copy.addNode(node);
364 <a name="2"></a>    }
365     for (E edge : network.edges()) {
366       EndpointPair&lt;N&gt; endpointPair = network.incidentNodes(edge);
367       copy.addEdge(endpointPair.nodeU(), <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>endpointPair.nodeV(), edge);
368     }
369     return copy;
370   }
371   @CanIgnoreReturnValue
372   static int checkNonNegative(int value) {
373     checkArgument(value &gt;= 0, "Not true that %s is non-negative.", value);
374     return value;
375   }
376   @CanIgnoreReturn</b></font>Value
377   static long checkNonNegative(long value) {
378     checkArgument(value &gt;= 0, "Not true that %s is non-negative.", value);
379     return value;
380   }
381   @CanIgnoreReturnValue
382   static int checkPositive(int value) {
383     checkArgument(value &gt; 0, "Not true that %s is positive.", value);
384     return value;
385   }
386   @CanIgnoreReturnValue
387   static long checkPositive(long value) {
388     checkArgument(value &gt; 0, "Not true that %s is positive.", value);
389     return value;
390   }
391   private enum NodeVisitState {
392     PENDING,
393     COMPLETE
394   }
395 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableRangeSet.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkElementIndex;
4 <a name="0"></a>import static com.google.common.base.Preconditions.checkNotNull;
5 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_HIGHER;
6 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_LOWER;
7 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static com.google.common.collect.SortedLists.KeyPresentBehavior.ANY_PRESENT;
8 import static java.util.Objects.requireNonNull;
9 import com.google.common.annotations.Beta;
10 import com.google.common.annotations.GwtIncompatible;
11 import com.google.common.collect.SortedLists.KeyAbsentBehavior;
12 import com.google.common.collect.SortedLists.KeyPresentBehavior;
13 import com.google.common.primitives.Ints;
14 import com.google.errorprone.annotations.CanIgnoreReturnValue;
15 import com.google.errorprone.annotations.DoNotCall;
16 import com.google.errorprone.annotations.concurrent.LazyInit;
17 import java.io.Serializable;
18 import java.util.Collections;
19 import java.util.Iterator;
20 import java.util.List;
21 import java.util.NoSuchElementException;
22 import java.util.Set;
23 import javax.annotation.CheckForNull;
24 @Beta
25 @</b></font>GwtIncompatible
26 @ElementTypesAreNonnullByDefault
27 public final class ImmutableRangeSet&lt;C extends Comparable&gt; extends AbstractRangeSet&lt;C&gt;
28     implements Serializable {
29   private static final ImmutableRangeSet&lt;Comparable&lt;?&gt;&gt; EMPTY =
30       new ImmutableRangeSet&lt;&gt;(ImmutableList.&lt;Range&lt;Comparable&lt;?&gt;&gt;&gt;of());
31   private static final ImmutableRangeSet&lt;Comparable&lt;?&gt;&gt; ALL =
32       new ImmutableRangeSet&lt;&gt;(ImmutableList.of(Range.&lt;Comparable&lt;?&gt;&gt;all()));
33   @SuppressWarnings("unchecked")
34   public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; of() {
35     return (ImmutableRangeSet&lt;C&gt;) EMPTY;
36   }
37   public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; of(Range&lt;C&gt; range) {
38     checkNotNull(range);
39     if (range.isEmpty()) {
40       return of();
41     } else if (range.equals(Range.all())) {
42       return all();
43     } else {
44       return new ImmutableRangeSet&lt;C&gt;(ImmutableList.of(range));
45     }
46   }
47   @SuppressWarnings("unchecked")
48   static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; all() {
49     return (ImmutableRangeSet&lt;C&gt;) ALL;
50   }
51   public static &lt;C extends Comparable&gt; ImmutableRangeSet&lt;C&gt; copyOf(RangeSet&lt;C&gt; rangeSet) {
52     checkNotNull(rangeSet);
53     if (rangeSet.isEmpty()) {
54       return of();
55     } else if (rangeSet.encloses(Range.&lt;C&gt;all())) {
56       return all();
57     }
58     if (rangeSet instanceof ImmutableRangeSet) {
59       ImmutableRangeSet&lt;C&gt; immutableRangeSet = (ImmutableRangeSet&lt;C&gt;) rangeSet;
60       if (!immutableRangeSet.isPartialView()) {
61         return immutableRangeSet;
62       }
63     }
64     return new ImmutableRangeSet&lt;C&gt;(ImmutableList.copyOf(rangeSet.asRanges()));
65   }
66   public static &lt;C extends Comparable&lt;?&gt;&gt; ImmutableRangeSet&lt;C&gt; copyOf(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
67     return new ImmutableRangeSet.Builder&lt;C&gt;().addAll(ranges).build();
68   }
69   public static &lt;C extends Comparable&lt;?&gt;&gt; ImmutableRangeSet&lt;C&gt; unionOf(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
70     return copyOf(TreeRangeSet.create(ranges));
71   }
72   ImmutableRangeSet(ImmutableList&lt;Range&lt;C&gt;&gt; ranges) {
73     this.ranges = ranges;
74   }
75   private ImmutableRangeSet(ImmutableList&lt;Range&lt;C&gt;&gt; ranges, ImmutableRangeSet&lt;C&gt; complement) {
76     this.ranges = ranges;
77     this.complement = complement;
78   }
79   private final transient ImmutableList&lt;Range&lt;C&gt;&gt; ranges;
80   @Override
81   public boolean intersects(Range&lt;C&gt; otherRange) {
82     int ceilingIndex =
83         SortedLists.binarySearch(
84             ranges,
85             Range.&lt;C&gt;lowerBoundFn(),
86             otherRange.lowerBound,
87 <a name="6"></a>            Ordering.natural(),
88             ANY_PRESENT,
89             NEXT_HIGHER);
90     if (ceilingIndex &lt; <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ranges.size()
91         &amp;&amp; ranges.get(ceilingIndex).isConnected(otherRange)
92         &amp;&amp; !ranges.get(ceilingIndex).intersection(otherRange).isEmpty()) {
93       return true;
94 <a name="7"></a>    }
95     return ceilingIndex &gt; 0
96         &amp;&amp; ranges.get</b></font>(ceilingIndex - 1).isConnected(otherRange)
97         &amp;&amp; !<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ranges.get(ceilingIndex - 1).intersection(otherRange).isEmpty();
98   }
99   @Override
100   public boolean encloses(Range&lt;C&gt; otherRange) {
101     int index =
102         SortedLists.binarySearch(
103             ranges,
104             Range.&lt;C&gt;lowerBoundFn</b></font>(),
105             otherRange.lowerBound,
106 <a name="8"></a>            Ordering.natural(),
107             ANY_PRESENT,
108             NEXT_LOWER);
109     <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return index != -1 &amp;&amp; ranges.get(index).encloses(otherRange);
110   }
111   @Override
112   @CheckForNull
113   public Range&lt;C&gt; rangeContaining(C value) {</b></font>
114     int index =
115         SortedLists.binarySearch(
116             ranges,
117             Range.&lt;C&gt;lowerBoundFn(),
118             Cut.belowValue(value),
119             Ordering.natural(),
120             ANY_PRESENT,
121             NEXT_LOWER);
122     if (index != -1) {
123       Range&lt;C&gt; range = ranges.get(index);
124       return range.contains(value) ? range : null;
125     }
126     return null;
127   }
128   @Override
129   public Range&lt;C&gt; span() {
130     if (ranges.isEmpty()) {
131       throw new NoSuchElementException();
132     }
133     return Range.create(ranges.get(0).lowerBound, ranges.get(ranges.size() - 1).upperBound);
134   }
135   @Override
136   public boolean isEmpty() {
137     return ranges.isEmpty();
138   }
139   @Deprecated
140   @Override
141   @DoNotCall("Always throws UnsupportedOperationException")
142   public void add(Range&lt;C&gt; range) {
143     throw new UnsupportedOperationException();
144   }
145   @Deprecated
146   @Override
147   @DoNotCall("Always throws UnsupportedOperationException")
148   public void addAll(RangeSet&lt;C&gt; other) {
149     throw new UnsupportedOperationException();
150   }
151   @Deprecated
152   @Override
153   @DoNotCall("Always throws UnsupportedOperationException")
154   public void addAll(Iterable&lt;Range&lt;C&gt;&gt; other) {
155     throw new UnsupportedOperationException();
156   }
157   @Deprecated
158   @Override
159   @DoNotCall("Always throws UnsupportedOperationException")
160   public void remove(Range&lt;C&gt; range) {
161     throw new UnsupportedOperationException();
162   }
163   @Deprecated
164   @Override
165   @DoNotCall("Always throws UnsupportedOperationException")
166   public void removeAll(RangeSet&lt;C&gt; other) {
167     throw new UnsupportedOperationException();
168   }
169   @Deprecated
170   @Override
171   @DoNotCall("Always throws UnsupportedOperationException")
172   public void removeAll(Iterable&lt;Range&lt;C&gt;&gt; other) {
173     throw new UnsupportedOperationException();
174   }
175   @Override
176   public ImmutableSet&lt;Range&lt;C&gt;&gt; asRanges() {
177     if (ranges.isEmpty()) {
178       return ImmutableSet.of();
179     }
180     return new RegularImmutableSortedSet&lt;&gt;(ranges, Range.&lt;C&gt;rangeLexOrdering());
181   }
182   @Override
183   public ImmutableSet&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges() {
184     if (ranges.isEmpty()) {
185       return ImmutableSet.of();
186     }
187     return new RegularImmutableSortedSet&lt;&gt;(ranges.reverse(), Range.&lt;C&gt;rangeLexOrdering().reverse());
188   }
189   @LazyInit @CheckForNull private transient ImmutableRangeSet&lt;C&gt; complement;
190   private final class ComplementRanges extends ImmutableList&lt;Range&lt;C&gt;&gt; {
191     private final boolean positiveBoundedBelow;
192     private final boolean positiveBoundedAbove;
193     private final int size;
194     ComplementRanges() {
195       this.positiveBoundedBelow = ranges.get(0).hasLowerBound();
196       this.positiveBoundedAbove = Iterables.getLast(ranges).hasUpperBound();
197       int size = ranges.size() - 1;
198       if (positiveBoundedBelow) {
199         size++;
200       }
201 <a name="5"></a>      if (positiveBoundedAbove) {
202         size++;
203       }
204       <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>this.size = size;
205     }
206     @Override
207     public int size() {
208       return size;
209     }
210     @Override
211     public Range&lt;C&gt; get(int index) {</b></font>
212       checkElementIndex(index, size);
213       Cut&lt;C&gt; lowerBound;
214       if (positiveBoundedBelow) {
215         lowerBound = (index == 0) ? Cut.&lt;C&gt;belowAll() : ranges.get(index - 1).upperBound;
216       } else {
217         lowerBound = ranges.get(index).upperBound;
218       }
219       Cut&lt;C&gt; upperBound;
220       if (positiveBoundedAbove &amp;&amp; index == size - 1) {
221         upperBound = Cut.&lt;C&gt;aboveAll();
222       } else {
223         upperBound = ranges.get(index + (positiveBoundedBelow ? 0 : 1)).lowerBound;
224       }
225       return Range.create(lowerBound, upperBound);
226     }
227     @Override
228     boolean isPartialView() {
229       return true;
230     }
231   }
232   @Override
233   public ImmutableRangeSet&lt;C&gt; complement() {
234     ImmutableRangeSet&lt;C&gt; result = complement;
235     if (result != null) {
236       return result;
237     } else if (ranges.isEmpty()) {
238       return complement = all();
239     } else if (ranges.size() == 1 &amp;&amp; ranges.get(0).equals(Range.all())) {
240       return complement = of();
241     } else {
242       ImmutableList&lt;Range&lt;C&gt;&gt; complementRanges = new ComplementRanges();
243       result = complement = new ImmutableRangeSet&lt;C&gt;(complementRanges, this);
244     }
245     return result;
246   }
247   public ImmutableRangeSet&lt;C&gt; union(<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>RangeSet&lt;C&gt; other) {
248     return unionOf(Iterables.concat(asRanges(), other.asRanges()));
249   }</b></font>
250   public ImmutableRangeSet&lt;C&gt; intersection(RangeSet&lt;C&gt; other) {
251     RangeSet&lt;C&gt; copy = TreeRangeSet.create(this);
252     copy.removeAll(other.complement());
253     return copyOf(copy);
254   }
255   public ImmutableRangeSet&lt;C&gt; difference(RangeSet&lt;C&gt; other) {
256     RangeSet&lt;C&gt; copy = TreeRangeSet.create(this);
257     copy.removeAll(other);
258     return copyOf(copy);
259   }
260   private ImmutableList&lt;Range&lt;C&gt;&gt; intersectRanges(final Range&lt;C&gt; range) {
261     if (ranges.isEmpty() || range.isEmpty()) {
262       return ImmutableList.of();
263     } else if (range.encloses(span())) {
264       return ranges;
265     }
266     final int fromIndex;
267     if (range.hasLowerBound()) {
268       fromIndex =
269           SortedLists.binarySearch(
270               ranges,
271               Range.&lt;C&gt;upperBoundFn(),
272               range.lowerBound,
273               KeyPresentBehavior.FIRST_AFTER,
274               KeyAbsentBehavior.NEXT_HIGHER);
275     } else {
276       fromIndex = 0;
277     }
278     int toIndex;
279     if (range.hasUpperBound()) {
280       toIndex =
281           SortedLists.binarySearch(
282               ranges,
283               Range.&lt;C&gt;lowerBoundFn(),
284               range.upperBound,
285               KeyPresentBehavior.FIRST_PRESENT,
286               KeyAbsentBehavior.NEXT_HIGHER);
287     } else {
288       toIndex = ranges.size();
289     }
290     final int length = toIndex - fromIndex;
291     if (length == 0) {
292 <a name="9"></a>      return ImmutableList.of();
293     } else {
294       return new ImmutableList&lt;Range&lt;C&gt;&gt;() {
295         <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
296         public int size() {
297           return length;
298         }
299         @Override
300         public Range&lt;C&gt; get(int index) {</b></font>
301           checkElementIndex(index, length);
302           if (index == 0 || index == length - 1) {
303             return ranges.get(index + fromIndex).intersection(range);
304           } else {
305             return ranges.get(index + fromIndex);
306           }
307         }
308         @Override
309         boolean isPartialView() {
310           return true;
311         }
312       };
313     }
314   }
315   @Override
316   public ImmutableRangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; range) {
317     if (!isEmpty()) {
318       Range&lt;C&gt; span = span();
319       if (range.encloses(span)) {
320         return this;
321       } else if (range.isConnected(span)) {
322         return new ImmutableRangeSet&lt;C&gt;(intersectRanges(range));
323       }
324     }
325     return of();
326   }
327   public ImmutableSortedSet&lt;C&gt; asSet(DiscreteDomain&lt;C&gt; domain) {
328     checkNotNull(domain);
329     if (isEmpty()) {
330       return ImmutableSortedSet.of();
331     }
332     Range&lt;C&gt; span = span().canonical(domain);
333     if (!span.hasLowerBound()) {
334       throw new IllegalArgumentException(
335           "Neither the DiscreteDomain nor this range set are bounded below");
336     } else if (!span.hasUpperBound()) {
337       try {
338         domain.maxValue();
339       } catch (NoSuchElementException e) {
340         throw new IllegalArgumentException(
341             "Neither the DiscreteDomain nor this range set are bounded above");
342       }
343     }
344     return new AsSet(domain);
345   }
346   private final class AsSet extends ImmutableSortedSet&lt;C&gt; {
347     private final DiscreteDomain&lt;C&gt; domain;
348     AsSet(DiscreteDomain&lt;C&gt; domain) {
349       super(Ordering.natural());
350       this.domain = domain;
351     }
352     @CheckForNull private transient Integer size;
353     @Override
354     public int size() {
355       Integer result = size;
356       if (result == null) {
357         long total = 0;
358         for (Range&lt;C&gt; range : ranges) {
359           total += ContiguousSet.create(range, domain).size();
360           if (total &gt;= Integer.MAX_VALUE) {
361             break;
362           }
363         }
364         result = size = Ints.saturatedCast(total);
365       }
366       return result.intValue();
367     }
368     @Override
369     public UnmodifiableIterator&lt;C&gt; iterator() {
370       return new AbstractIterator&lt;C&gt;() {
371         final Iterator&lt;Range&lt;C&gt;&gt; rangeItr = ranges.iterator();
372         Iterator&lt;C&gt; elemItr = Iterators.emptyIterator();
373         @Override
374         @CheckForNull
375         protected C computeNext() {
376           while (!elemItr.hasNext()) {
377             if (rangeItr.hasNext()) {
378               elemItr = ContiguousSet.create(rangeItr.next(), domain).iterator();
379             } else {
380               return endOfData();
381             }
382           }
383           return elemItr.next();
384         }
385       };
386     }
387     @Override
388     @GwtIncompatible("NavigableSet")
389     public UnmodifiableIterator&lt;C&gt; descendingIterator() {
390       return new AbstractIterator&lt;C&gt;() {
391         final Iterator&lt;Range&lt;C&gt;&gt; rangeItr = ranges.reverse().iterator();
392         Iterator&lt;C&gt; elemItr = Iterators.emptyIterator();
393         @Override
394         @CheckForNull
395         protected C computeNext() {
396           while (!elemItr.hasNext()) {
397             if (rangeItr.hasNext()) {
398               elemItr = ContiguousSet.create(rangeItr.next(), domain).descendingIterator();
399             } else {
400               return endOfData();
401             }
402           }
403           return elemItr.next();
404         }
405 <a name="3"></a>      };
406     }
407     ImmutableSortedSet&lt;C&gt; subSet(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Range&lt;C&gt; range) {
408       return subRangeSet(range).asSet(domain);
409     }
410     @Override
411     ImmutableSortedSet&lt;C&gt; headSetImpl(C toElement, boolean inclusive) {
412       return subSet(Range.upTo</b></font>(toElement, BoundType.forBoolean(inclusive)));
413     }
414     @Override
415     ImmutableSortedSet&lt;C&gt; subSetImpl(
416         C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {
417       if (!fromInclusive &amp;&amp; !toInclusive &amp;&amp; Range.compareOrThrow(fromElement, toElement) == 0) {
418 <a name="4"></a>        return ImmutableSortedSet.of();
419       }
420       return subSet(
421           <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Range.range(
422               fromElement, BoundType.forBoolean(fromInclusive),
423               toElement, BoundType.forBoolean(toInclusive)));
424     }
425     @Override
426     ImmutableSortedSet&lt;C&gt; tailSetImpl(C fromElement, boolean inclusive) {
427       return subSet(Range.downTo</b></font>(fromElement, BoundType.forBoolean(inclusive)));
428     }
429     @Override
430     public boolean contains(@CheckForNull Object o) {
431       if (o == null) {
432         return false;
433       }
434       try {
435         @SuppressWarnings("unchecked")         C c = (C) o;
436         return ImmutableRangeSet.this.contains(c);
437       } catch (ClassCastException e) {
438         return false;
439       }
440     }
441     @Override
442     int indexOf(@CheckForNull Object target) {
443       if (contains(target)) {
444 <a name="11"></a>        @SuppressWarnings("unchecked")         C c = (C) requireNonNull(target);
445         long total = 0;
446         for (<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Range&lt;C&gt; range : ranges) {
447           if (range.contains(c)) {
448             return Ints.saturatedCast(total + ContiguousSet.create(range, domain).indexOf(c));
449           }</b></font> else {
450             total += ContiguousSet.create(range, domain).size();
451           }
452         }
453         throw new AssertionError("impossible");
454       }
455       return -1;
456     }
457     @Override
458     ImmutableSortedSet&lt;C&gt; createDescendingSet() {
459       return new DescendingImmutableSortedSet&lt;C&gt;(this);
460     }
461     @Override
462     boolean isPartialView() {
463       return ranges.isPartialView();
464     }
465     @Override
466     public String toString() {
467       return ranges.toString();
468     }
469     @Override
470     Object writeReplace() {
471       return new AsSetSerializedForm&lt;C&gt;(ranges, domain);
472     }
473   }
474   private static class AsSetSerializedForm&lt;C extends Comparable&gt; implements Serializable {
475     private final ImmutableList&lt;Range&lt;C&gt;&gt; ranges;
476     private final DiscreteDomain&lt;C&gt; domain;
477     AsSetSerializedForm(ImmutableList&lt;Range&lt;C&gt;&gt; ranges, DiscreteDomain&lt;C&gt; domain) {
478       this.ranges = ranges;
479       this.domain = domain;
480     }
481     Object readResolve() {
482       return new ImmutableRangeSet&lt;C&gt;(ranges).asSet(domain);
483     }
484   }
485   boolean isPartialView() {
486     return ranges.isPartialView();
487   }
488   public static &lt;C extends Comparable&lt;?&gt;&gt; Builder&lt;C&gt; builder() {
489     return new Builder&lt;C&gt;();
490   }
491   public static class Builder&lt;C extends Comparable&lt;?&gt;&gt; {
492     private final List&lt;Range&lt;C&gt;&gt; ranges;
493     public Builder() {
494       this.ranges = Lists.newArrayList();
495     }
496     @CanIgnoreReturnValue
497 <a name="1"></a>    public Builder&lt;C&gt; add(Range&lt;C&gt; range) {
498       checkArgument(!range.isEmpty(), "range must not be empty, but was %s", range);
499       ranges.add(range);
500       <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return this;
501     }
502     @CanIgnoreReturnValue
503     public Builder&lt;C&gt; addAll(RangeSet&lt;C&gt; ranges) {
504       return addAll(ranges.asRanges());
505     }
506 <a name="2"></a>    @CanIgnoreReturnValue
507     public Builder&lt;C&gt; addAll(Iterable&lt;Range&lt;C&gt;&gt; ranges) {</b></font>
508       for (Range&lt;C&gt; range : ranges) {
509         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>add(range);
510       }
511       return this;
512     }
513     @CanIgnoreReturnValue
514     Builder&lt;C&gt; combine(Builder&lt;C&gt; builder) {
515       addAll(builder.ranges);
516       return this;
517     }
518     publi</b></font>c ImmutableRangeSet&lt;C&gt; build() {
519       ImmutableList.Builder&lt;Range&lt;C&gt;&gt; mergedRangesBuilder =
520           new ImmutableList.Builder&lt;&gt;(ranges.size());
521       Collections.sort(ranges, Range.&lt;C&gt;rangeLexOrdering());
522       PeekingIterator&lt;Range&lt;C&gt;&gt; peekingItr = Iterators.peekingIterator(ranges.iterator());
523       while (peekingItr.hasNext()) {
524         Range&lt;C&gt; range = peekingItr.next();
525         while (peekingItr.hasNext()) {
526           Range&lt;C&gt; nextRange = peekingItr.peek();
527           if (range.isConnected(nextRange)) {
528             checkArgument(
529                 range.intersection(nextRange).isEmpty(),
530                 "Overlapping ranges not permitted but found %s overlapping %s",
531                 range,
532                 nextRange);
533             range = range.span(peekingItr.next());
534           } else {
535             break;
536           }
537         }
538         mergedRangesBuilder.add(range);
539       }
540       ImmutableList&lt;Range&lt;C&gt;&gt; mergedRanges = mergedRangesBuilder.build();
541       if (mergedRanges.isEmpty()) {
542         return of();
543       } else if (mergedRanges.size() == 1
544           &amp;&amp; Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {
545         return all();
546       } else {
547         return new ImmutableRangeSet&lt;C&gt;(mergedRanges);
548       }
549 <a name="10"></a>    }
550   }
551   <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private static final class SerializedForm&lt;C extends Comparable&gt; implements Serializable {
552     private final ImmutableList&lt;Range&lt;C&gt;&gt; ranges;
553     SerializedForm(ImmutableList&lt;Range&lt;C&gt;&gt; ranges) {
554       this.ranges = ranges;
555     }
556     Object read</b></font>Resolve() {
557       if (ranges.isEmpty()) {
558         return of();
559       } else if (ranges.equals(ImmutableList.of(Range.all()))) {
560         return all();
561       } else {
562         return new ImmutableRangeSet&lt;C&gt;(ranges);
563       }
564     }
565   }
566   Object writeReplace() {
567     return new SerializedForm&lt;C&gt;(ranges);
568   }
569 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
