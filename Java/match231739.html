<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for CharsetUtil.java &amp; Base64.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CharsetUtil.java &amp; Base64.java
      </h3>
<h1 align="center">
        13.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CharsetUtil.java (31.654676%)<th>Base64.java (8.429119%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(76-92)<td><a href="#" name="0">(73-80)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(132-145)<td><a href="#" name="1">(85-89)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(147-159)<td><a href="#" name="2">(281-287)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(103-113)<td><a href="#" name="3">(94-99)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CharsetUtil.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.util;
2 import io.netty.util.internal.InternalThreadLocalMap;
3 import static io.netty.util.internal.ObjectUtil.checkNotNull;
4 import java.nio.charset.Charset;
5 import java.nio.charset.CharsetDecoder;
6 import java.nio.charset.CharsetEncoder;
7 import java.nio.charset.CodingErrorAction;
8 import java.util.Map;
9 public final class CharsetUtil {
10     public static final Charset UTF_16 = Charset.forName("UTF-16");
11     public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
12     public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
13     public static final Charset UTF_8 = Charset.forName("UTF-8");
14     public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
15     public static final Charset US_ASCII = Charset.forName("US-ASCII");
16     private static final Charset[] CHARSETS = new Charset[]
17             { UTF_16, UTF_16BE, UTF_16LE, UTF_8, ISO_8859_1, US_ASCII };
18     public static Charset[] values() {
19         return CHARSETS;
20     }
21     @Deprecated
22     public static CharsetEncoder getEncoder(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset) {
23         return encoder(charset);
24     }
25     public static CharsetEncoder encoder(Charset charset, CodingErrorAction malformedInputAction,
26                                          CodingErrorAction unmappableCharacterAction) {
27         checkNotNull(charset, "charset");
28         CharsetEncoder e = charset.newEncoder();
29         e.onMalformedInput</b></font>(malformedInputAction).onUnmappableCharacter(unmappableCharacterAction);
30         return e;
31     }
32     public static CharsetEncoder encoder(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset, CodingErrorAction codingErrorAction) {
33         return encoder(charset, codingErrorAction, codingErrorAction);
34     }
35     public static CharsetEncoder encoder(Charset charset</b></font>) {
36         checkNotNull(charset, "charset");
37         Map&lt;Charset, CharsetEncoder&gt; map = InternalThreadLocalMap.get().charsetEncoderCache();
38         CharsetEncoder e = map.get(charset);
39         if (e != null) {
40             e.reset().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
41             return e;
42         }
43         e = encoder(charset, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);
44         map.put(charset, e);
45         return e;
46     }
47     @Deprecated
48     public static CharsetDecoder getDecoder(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset) {
49         return decoder(charset);
50     }
51 <a name="2"></a>    public static CharsetDecoder decoder(Charset charset, CodingErrorAction malformedInputAction,
52                                          CodingErrorAction unmappableCharacterAction</b></font>) {
53         checkNotNull(charset, "charset");
54         CharsetDecoder d = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>charset.newDecoder();
55         d.onMalformedInput(malformedInputAction).onUnmappableCharacter(unmappableCharacterAction);
56         return d;
57     }
58     public static CharsetDecoder decoder(Charset charset, CodingErrorAction codingErrorAction</b></font>) {
59         return decoder(charset, codingErrorAction, codingErrorAction);
60     }
61     public static CharsetDecoder decoder(Charset charset) {
62         checkNotNull(charset, "charset");
63         Map&lt;Charset, CharsetDecoder&gt; map = InternalThreadLocalMap.get().charsetDecoderCache();
64         CharsetDecoder d = map.get(charset);
65         if (d != null) {
66             d.reset().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
67             return d;
68         }
69         d = decoder(charset, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);
70         map.put(charset, d);
71         return d;
72     }
73     private CharsetUtil() { }
74 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Base64.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec.base64;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.ByteBufAllocator;
4 import io.netty.util.ByteProcessor;
5 import io.netty.util.internal.ObjectUtil;
6 import io.netty.util.internal.PlatformDependent;
7 import java.nio.ByteOrder;
8 public final class Base64 {
9     private static final int MAX_LINE_LENGTH = 76;
10     private static final byte EQUALS_SIGN = (byte) '=';
11     private static final byte NEW_LINE = (byte) '\n';
12     private static final byte WHITE_SPACE_ENC = -5; 
13     private static final byte EQUALS_SIGN_ENC = -1; 
14     private static byte[] alphabet(Base64Dialect dialect) {
15         return ObjectUtil.checkNotNull(dialect, "dialect").alphabet;
16     }
17     private static byte[] decodabet(Base64Dialect dialect) {
18         return ObjectUtil.checkNotNull(dialect, "dialect").decodabet;
19     }
20     private static boolean breakLines(Base64Dialect dialect) {
21         return ObjectUtil.checkNotNull(dialect, "dialect").breakLinesByDefault;
22     }
23     public static ByteBuf encode(ByteBuf src) {
24         return encode(src, Base64Dialect.STANDARD);
25     }
26     public static ByteBuf encode(ByteBuf src, Base64Dialect dialect) {
27 <a name="0"></a>        return encode(src, breakLines(dialect), dialect);
28     }
29     public static ByteBuf encode(ByteBuf src, <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>boolean breakLines) {
30         return encode(src, breakLines, Base64Dialect.STANDARD);
31     }
32     public static ByteBuf encode(ByteBuf src, boolean breakLines, Base64Dialect dialect) {
33         ObjectUtil.checkNotNull(src, "src");
34         ByteBuf dest = encode(src, src.readerIndex(), src.readableBytes</b></font>(), breakLines, dialect);
35         src.readerIndex(src.writerIndex());
36 <a name="1"></a>        return dest;
37     }
38     public static ByteBuf encode(ByteBuf src, int off, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int len) {
39         return encode(src, off, len, Base64Dialect.STANDARD);
40     }
41     public static ByteBuf encode(ByteBuf src, int off, int len</b></font>, Base64Dialect dialect) {
42         return encode(src, off, len, breakLines(dialect), dialect);
43 <a name="3"></a>    }
44     public static ByteBuf encode(
45             ByteBuf src, int off, <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int len, boolean breakLines) {
46         return encode(src, off, len, breakLines, Base64Dialect.STANDARD);
47     }
48     public static ByteBuf encode(
49             ByteBuf src</b></font>, int off, int len, boolean breakLines, Base64Dialect dialect) {
50         return encode(src, off, len, breakLines, dialect, src.alloc());
51     }
52     public static ByteBuf encode(
53             ByteBuf src, int off, int len, boolean breakLines, Base64Dialect dialect, ByteBufAllocator allocator) {
54         ObjectUtil.checkNotNull(src, "src");
55         ObjectUtil.checkNotNull(dialect, "dialect");
56         ByteBuf dest = allocator.buffer(encodedBufferSize(len, breakLines)).order(src.order());
57         byte[] alphabet = alphabet(dialect);
58         int d = 0;
59         int e = 0;
60         int len2 = len - 2;
61         int lineLength = 0;
62         for (; d &lt; len2; d += 3, e += 4) {
63             encode3to4(src, d + off, 3, dest, e, alphabet);
64             lineLength += 4;
65             if (breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH) {
66                 dest.setByte(e + 4, NEW_LINE);
67                 e ++;
68                 lineLength = 0;
69             }         } 
70         if (d &lt; len) {
71             encode3to4(src, d + off, len - d, dest, e, alphabet);
72             e += 4;
73         } 
74         if (e &gt; 1 &amp;&amp; dest.getByte(e - 1) == NEW_LINE) {
75             e--;
76         }
77         return dest.slice(0, e);
78     }
79     private static void encode3to4(
80             ByteBuf src, int srcOffset, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
81         if (src.order() == ByteOrder.BIG_ENDIAN) {
82             final int inBuff;
83             switch (numSigBytes) {
84                 case 1:
85                     inBuff = toInt(src.getByte(srcOffset));
86                     break;
87                 case 2:
88                     inBuff = toIntBE(src.getShort(srcOffset));
89                     break;
90                 default:
91                     inBuff = numSigBytes &lt;= 0 ? 0 : toIntBE(src.getMedium(srcOffset));
92                     break;
93             }
94             encode3to4BigEndian(inBuff, numSigBytes, dest, destOffset, alphabet);
95         } else {
96             final int inBuff;
97             switch (numSigBytes) {
98                 case 1:
99                     inBuff = toInt(src.getByte(srcOffset));
100                     break;
101                 case 2:
102                     inBuff = toIntLE(src.getShort(srcOffset));
103                     break;
104                 default:
105                     inBuff = numSigBytes &lt;= 0 ? 0 : toIntLE(src.getMedium(srcOffset));
106                     break;
107             }
108             encode3to4LittleEndian(inBuff, numSigBytes, dest, destOffset, alphabet);
109         }
110     }
111     static int encodedBufferSize(int len, boolean breakLines) {
112         long len43 = ((long) len &lt;&lt; 2) / 3;
113         long ret = (len43 + 3) &amp; ~3;
114         if (breakLines) {
115             ret += len43 / MAX_LINE_LENGTH;
116         }
117         return ret &lt; Integer.MAX_VALUE ? (int) ret : Integer.MAX_VALUE;
118     }
119     private static int toInt(byte value) {
120         return (value &amp; 0xff) &lt;&lt; 16;
121     }
122     private static int toIntBE(short value) {
123         return (value &amp; 0xff00) &lt;&lt; 8 | (value &amp; 0xff) &lt;&lt; 8;
124     }
125     private static int toIntLE(short value) {
126         return (value &amp; 0xff) &lt;&lt; 16 | (value &amp; 0xff00);
127     }
128     private static int toIntBE(int mediumValue) {
129         return (mediumValue &amp; 0xff0000) | (mediumValue &amp; 0xff00) | (mediumValue &amp; 0xff);
130     }
131     private static int toIntLE(int mediumValue) {
132         return (mediumValue &amp; 0xff) &lt;&lt; 16 | (mediumValue &amp; 0xff00) | (mediumValue &amp; 0xff0000) &gt;&gt;&gt; 16;
133     }
134     private static void encode3to4BigEndian(
135             int inBuff, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
136         switch (numSigBytes) {
137             case 3:
138                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
139                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
140                                         alphabet[inBuff &gt;&gt;&gt;  6 &amp; 0x3f] &lt;&lt; 8  |
141                                         alphabet[inBuff        &amp; 0x3f]);
142                 break;
143             case 2:
144                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
145                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
146                                         alphabet[inBuff &gt;&gt;&gt; 6  &amp; 0x3f] &lt;&lt; 8  |
147                                         EQUALS_SIGN);
148                 break;
149             case 1:
150                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
151                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
152                                         EQUALS_SIGN &lt;&lt; 8                     |
153                                         EQUALS_SIGN);
154                 break;
155             default:
156                 break;
157         }
158     }
159     private static void encode3to4LittleEndian(
160             int inBuff, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
161         switch (numSigBytes) {
162             case 3:
163                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]       |
164                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8  |
165                                         alphabet[inBuff &gt;&gt;&gt;  6 &amp; 0x3f] &lt;&lt; 16 |
166                                         alphabet[inBuff        &amp; 0x3f] &lt;&lt; 24);
167                 break;
168             case 2:
169                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]       |
170                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8  |
171                                         alphabet[inBuff &gt;&gt;&gt; 6  &amp; 0x3f] &lt;&lt; 16 |
172                                         EQUALS_SIGN &lt;&lt; 24);
173                 break;
174             case 1:
175                 dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]      |
176                                         alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8 |
177                                         EQUALS_SIGN &lt;&lt; 16                   |
178                                         EQUALS_SIGN &lt;&lt; 24);
179                 break;
180             default:
181                 break;
182         }
183     }
184     public static ByteBuf decode(ByteBuf src) {
185         return decode(src, Base64Dialect.STANDARD);
186     }
187 <a name="2"></a>    public static ByteBuf decode(ByteBuf src, Base64Dialect dialect) {
188         ObjectUtil.checkNotNull(src, "src");
189         ByteBuf dest = decode(src, src.readerIndex(), <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>src.readableBytes(), dialect);
190         src.readerIndex(src.writerIndex());
191         return dest;
192     }
193     public static ByteBuf decode(
194             ByteBuf src, int off</b></font>, int len) {
195         return decode(src, off, len, Base64Dialect.STANDARD);
196     }
197     public static ByteBuf decode(
198             ByteBuf src, int off, int len, Base64Dialect dialect) {
199         return decode(src, off, len, dialect, src.alloc());
200     }
201     public static ByteBuf decode(
202             ByteBuf src, int off, int len, Base64Dialect dialect, ByteBufAllocator allocator) {
203         ObjectUtil.checkNotNull(src, "src");
204         ObjectUtil.checkNotNull(dialect, "dialect");
205         return new Decoder().decode(src, off, len, allocator, dialect);
206     }
207     static int decodedBufferSize(int len) {
208         return len - (len &gt;&gt;&gt; 2);
209     }
210     private static final class Decoder implements ByteProcessor {
211         private final byte[] b4 = new byte[4];
212         private int b4Posn;
213         private byte[] decodabet;
214         private int outBuffPosn;
215         private ByteBuf dest;
216         ByteBuf decode(ByteBuf src, int off, int len, ByteBufAllocator allocator, Base64Dialect dialect) {
217             dest = allocator.buffer(decodedBufferSize(len)).order(src.order()); 
218             decodabet = decodabet(dialect);
219             try {
220                 src.forEachByte(off, len, this);
221                 return dest.slice(0, outBuffPosn);
222             } catch (Throwable cause) {
223                 dest.release();
224                 PlatformDependent.throwException(cause);
225                 return null;
226             }
227         }
228         @Override
229         public boolean process(byte value) throws Exception {
230             if (value &gt; 0) {
231                 byte sbiDecode = decodabet[value];
232                 if (sbiDecode &gt;= WHITE_SPACE_ENC) {                     if (sbiDecode &gt;= EQUALS_SIGN_ENC) {                         b4[b4Posn ++] = value;
233                         if (b4Posn &gt; 3) {                             outBuffPosn += decode4to3(b4, dest, outBuffPosn, decodabet);
234                             b4Posn = 0;
235                             return value != EQUALS_SIGN;
236                         }
237                     }
238                     return true;
239                 }
240             }
241             throw new IllegalArgumentException(
242                     "invalid Base64 input character: " + (short) (value &amp; 0xFF) + " (decimal)");
243         }
244         private static int decode4to3(byte[] src, ByteBuf dest, int destOffset, byte[] decodabet) {
245             final byte src0 = src[0];
246             final byte src1 = src[1];
247             final byte src2 = src[2];
248             final int decodedValue;
249             if (src2 == EQUALS_SIGN) {
250                 try {
251                     decodedValue = (decodabet[src0] &amp; 0xff) &lt;&lt; 2 | (decodabet[src1] &amp; 0xff) &gt;&gt;&gt; 4;
252                 } catch (IndexOutOfBoundsException ignored) {
253                     throw new IllegalArgumentException("not encoded in Base64");
254                 }
255                 dest.setByte(destOffset, decodedValue);
256                 return 1;
257             }
258             final byte src3 = src[3];
259             if (src3 == EQUALS_SIGN) {
260                 final byte b1 = decodabet[src1];
261                 try {
262                     if (dest.order() == ByteOrder.BIG_ENDIAN) {
263                         decodedValue = ((decodabet[src0] &amp; 0x3f) &lt;&lt; 2 | (b1 &amp; 0xf0) &gt;&gt; 4) &lt;&lt; 8 |
264                                         (b1 &amp; 0xf) &lt;&lt; 4 | (decodabet[src2] &amp; 0xfc) &gt;&gt;&gt; 2;
265                     } else {
266                         decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 2 | (b1 &amp; 0xf0) &gt;&gt; 4 |
267                                       ((b1 &amp; 0xf) &lt;&lt; 4 | (decodabet[src2] &amp; 0xfc) &gt;&gt;&gt; 2) &lt;&lt; 8;
268                     }
269                 } catch (IndexOutOfBoundsException ignored) {
270                     throw new IllegalArgumentException("not encoded in Base64");
271                 }
272                 dest.setShort(destOffset, decodedValue);
273                 return 2;
274             }
275             try {
276                 if (dest.order() == ByteOrder.BIG_ENDIAN) {
277                     decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 18 |
278                                    (decodabet[src1] &amp; 0xff) &lt;&lt; 12 |
279                                    (decodabet[src2] &amp; 0xff) &lt;&lt; 6 |
280                                     decodabet[src3] &amp; 0xff;
281                 } else {
282                     final byte b1 = decodabet[src1];
283                     final byte b2 = decodabet[src2];
284                     decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 2 |
285                                    (b1 &amp; 0xf) &lt;&lt; 12 |
286                                    (b1 &amp; 0xf0) &gt;&gt;&gt; 4 |
287                                    (b2 &amp; 0x3) &lt;&lt; 22 |
288                                    (b2 &amp; 0xfc) &lt;&lt; 6 |
289                                    (decodabet[src3] &amp; 0xff) &lt;&lt; 16;
290                 }
291             } catch (IndexOutOfBoundsException ignored) {
292                 throw new IllegalArgumentException("not encoded in Base64");
293             }
294             dest.setMedium(destOffset, decodedValue);
295             return 3;
296         }
297     }
298     private Base64() {
299     }
300 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
