<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for CharsetUtil.java &amp; Base64.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CharsetUtil.java &amp; Base64.java
      </h3>
<h1 align="center">
        13.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CharsetUtil.java (31.654676%)<th>Base64.java (8.429119%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(76-92)<td><a href="#" name="0">(73-80)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(132-145)<td><a href="#" name="1">(85-89)</a><td align="center"><font color="#9f0000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(147-159)<td><a href="#" name="2">(281-287)</a><td align="center"><font color="#8f0000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(103-113)<td><a href="#" name="3">(94-99)</a><td align="center"><font color="#8f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CharsetUtil.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.util;

import io.netty.util.internal.InternalThreadLocalMap;
import static io.netty.util.internal.ObjectUtil.checkNotNull;

import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CodingErrorAction;
import java.util.Map;

/**
 * A utility class that provides various common operations and constants
 * related with {@link Charset} and its relevant classes.
 */
public final class CharsetUtil {

    /**
     * 16-bit UTF (UCS Transformation Format) whose byte order is identified by
     * an optional byte-order mark
     */
    public static final Charset UTF_16 = Charset.forName("UTF-16");

    /**
     * 16-bit UTF (UCS Transformation Format) whose byte order is big-endian
     */
    public static final Charset UTF_16BE = Charset.forName("UTF-16BE");

    /**
     * 16-bit UTF (UCS Transformation Format) whose byte order is little-endian
     */
    public static final Charset UTF_16LE = Charset.forName("UTF-16LE");

    /**
     * 8-bit UTF (UCS Transformation Format)
     */
    public static final Charset UTF_8 = Charset.forName("UTF-8");

    /**
     * ISO Latin Alphabet No. 1, as known as &lt;tt&gt;ISO-LATIN-1&lt;/tt&gt;
     */
    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");

    /**
     * 7-bit ASCII, as known as ISO646-US or the Basic Latin block of the
     * Unicode character set
     */
    public static final Charset US_ASCII = Charset.forName("US-ASCII");

    private static final Charset[] CHARSETS = new Charset[]
            { UTF_16, UTF_16BE, UTF_16LE, UTF_8, ISO_8859_1, US_ASCII };

    public static Charset[] values() {
        return CHARSETS;
    }

    /**
<a name="0"></a>     * @deprecated Use {@link #encoder(Charset)}.
     */
    @Deprecated
    public static CharsetEncoder getEncoder(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset) {
        return encoder(charset);
    }

    /**
     * Returns a new {@link CharsetEncoder} for the {@link Charset} with specified error actions.
     *
     * @param charset The specified charset
     * @param malformedInputAction The encoder's action for malformed-input errors
     * @param unmappableCharacterAction The encoder's action for unmappable-character errors
     * @return The encoder for the specified {@code charset}
     */
    public static CharsetEncoder encoder(Charset charset, CodingErrorAction malformedInputAction,
                                         CodingErrorAction unmappableCharacterAction) {
        checkNotNull(charset, "charset");
        CharsetEncoder e = charset.newEncoder();
        e.onMalformedInput</b></font>(malformedInputAction).onUnmappableCharacter(unmappableCharacterAction);
        return e;
    }

    /**
     * Returns a new {@link CharsetEncoder} for the {@link Charset} with the specified error action.
     *
     * @param charset The specified charset
<a name="3"></a>     * @param codingErrorAction The encoder's action for malformed-input and unmappable-character errors
     * @return The encoder for the specified {@code charset}
     */
    public static CharsetEncoder encoder(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset, CodingErrorAction codingErrorAction) {
        return encoder(charset, codingErrorAction, codingErrorAction);
    }

    /**
     * Returns a cached thread-local {@link CharsetEncoder} for the specified {@link Charset}.
     *
     * @param charset The specified charset
     * @return The encoder for the specified {@code charset}
     */
    public static CharsetEncoder encoder(Charset charset</b></font>) {
        checkNotNull(charset, "charset");

        Map&lt;Charset, CharsetEncoder&gt; map = InternalThreadLocalMap.get().charsetEncoderCache();
        CharsetEncoder e = map.get(charset);
        if (e != null) {
            e.reset().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
            return e;
        }

        e = encoder(charset, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);
        map.put(charset, e);
        return e;
    }

    /**
<a name="1"></a>     * @deprecated Use {@link #decoder(Charset)}.
     */
    @Deprecated
    public static CharsetDecoder getDecoder(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Charset charset) {
        return decoder(charset);
    }

    /**
     * Returns a new {@link CharsetDecoder} for the {@link Charset} with specified error actions.
     *
     * @param charset The specified charset
     * @param malformedInputAction The decoder's action for malformed-input errors
     * @param unmappableCharacterAction The decoder's action for unmappable-character errors
     * @return The decoder for the specified {@code charset}
     */
<a name="2"></a>    public static CharsetDecoder decoder(Charset charset, CodingErrorAction malformedInputAction,
                                         CodingErrorAction unmappableCharacterAction</b></font>) {
        checkNotNull(charset, "charset");
        CharsetDecoder d = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>charset.newDecoder();
        d.onMalformedInput(malformedInputAction).onUnmappableCharacter(unmappableCharacterAction);
        return d;
    }

    /**
     * Returns a new {@link CharsetDecoder} for the {@link Charset} with the specified error action.
     *
     * @param charset The specified charset
     * @param codingErrorAction The decoder's action for malformed-input and unmappable-character errors
     * @return The decoder for the specified {@code charset}
     */
    public static CharsetDecoder decoder(Charset charset, CodingErrorAction codingErrorAction</b></font>) {
        return decoder(charset, codingErrorAction, codingErrorAction);
    }

    /**
     * Returns a cached thread-local {@link CharsetDecoder} for the specified {@link Charset}.
     *
     * @param charset The specified charset
     * @return The decoder for the specified {@code charset}
     */
    public static CharsetDecoder decoder(Charset charset) {
        checkNotNull(charset, "charset");

        Map&lt;Charset, CharsetDecoder&gt; map = InternalThreadLocalMap.get().charsetDecoderCache();
        CharsetDecoder d = map.get(charset);
        if (d != null) {
            d.reset().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
            return d;
        }

        d = decoder(charset, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);
        map.put(charset, d);
        return d;
    }

    private CharsetUtil() { }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Base64.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
/*
 * Written by Robert Harder and released to the public domain, as explained at
 * https://creativecommons.org/licenses/publicdomain
 */
package io.netty.handler.codec.base64;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.util.ByteProcessor;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;

import java.nio.ByteOrder;

/**
 * Utility class for {@link ByteBuf} that encodes and decodes to and from
 * &lt;a href="https://en.wikipedia.org/wiki/Base64"&gt;Base64&lt;/a&gt; notation.
 * &lt;p&gt;
 * The encoding and decoding algorithm in this class has been derived from
 * &lt;a href="http://iharder.sourceforge.net/current/java/base64/"&gt;Robert Harder's Public Domain
 * Base64 Encoder/Decoder&lt;/a&gt;.
 */
public final class Base64 {

    /** Maximum line length (76) of Base64 output. */
    private static final int MAX_LINE_LENGTH = 76;

    /** The equals sign (=) as a byte. */
    private static final byte EQUALS_SIGN = (byte) '=';

    /** The new line character (\n) as a byte. */
    private static final byte NEW_LINE = (byte) '\n';

    private static final byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding

    private static final byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding

    private static byte[] alphabet(Base64Dialect dialect) {
        return ObjectUtil.checkNotNull(dialect, "dialect").alphabet;
    }

    private static byte[] decodabet(Base64Dialect dialect) {
        return ObjectUtil.checkNotNull(dialect, "dialect").decodabet;
    }

    private static boolean breakLines(Base64Dialect dialect) {
        return ObjectUtil.checkNotNull(dialect, "dialect").breakLinesByDefault;
    }

    public static ByteBuf encode(ByteBuf src) {
        return encode(src, Base64Dialect.STANDARD);
    }

    public static ByteBuf encode(ByteBuf src, Base64Dialect dialect) {
<a name="0"></a>        return encode(src, breakLines(dialect), dialect);
    }

    public static ByteBuf encode(ByteBuf src, <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>boolean breakLines) {
        return encode(src, breakLines, Base64Dialect.STANDARD);
    }

    public static ByteBuf encode(ByteBuf src, boolean breakLines, Base64Dialect dialect) {
        ObjectUtil.checkNotNull(src, "src");

        ByteBuf dest = encode(src, src.readerIndex(), src.readableBytes</b></font>(), breakLines, dialect);
        src.readerIndex(src.writerIndex());
<a name="1"></a>        return dest;
    }

    public static ByteBuf encode(ByteBuf src, int off, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int len) {
        return encode(src, off, len, Base64Dialect.STANDARD);
    }

    public static ByteBuf encode(ByteBuf src, int off, int len</b></font>, Base64Dialect dialect) {
        return encode(src, off, len, breakLines(dialect), dialect);
<a name="3"></a>    }

    public static ByteBuf encode(
            ByteBuf src, int off, <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int len, boolean breakLines) {
        return encode(src, off, len, breakLines, Base64Dialect.STANDARD);
    }

    public static ByteBuf encode(
            ByteBuf src</b></font>, int off, int len, boolean breakLines, Base64Dialect dialect) {
        return encode(src, off, len, breakLines, dialect, src.alloc());
    }

    public static ByteBuf encode(
            ByteBuf src, int off, int len, boolean breakLines, Base64Dialect dialect, ByteBufAllocator allocator) {
        ObjectUtil.checkNotNull(src, "src");
        ObjectUtil.checkNotNull(dialect, "dialect");

        ByteBuf dest = allocator.buffer(encodedBufferSize(len, breakLines)).order(src.order());
        byte[] alphabet = alphabet(dialect);
        int d = 0;
        int e = 0;
        int len2 = len - 2;
        int lineLength = 0;
        for (; d &lt; len2; d += 3, e += 4) {
            encode3to4(src, d + off, 3, dest, e, alphabet);

            lineLength += 4;

            if (breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH) {
                dest.setByte(e + 4, NEW_LINE);
                e ++;
                lineLength = 0;
            } // end if: end of line
        } // end for: each piece of array

        if (d &lt; len) {
            encode3to4(src, d + off, len - d, dest, e, alphabet);
            e += 4;
        } // end if: some padding needed

        // Remove last byte if it's a newline
        if (e &gt; 1 &amp;&amp; dest.getByte(e - 1) == NEW_LINE) {
            e--;
        }

        return dest.slice(0, e);
    }

    private static void encode3to4(
            ByteBuf src, int srcOffset, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
        //           1         2         3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET
        //          &gt;&gt;18  &gt;&gt;12  &gt;&gt; 6  &gt;&gt; 0  Right shift necessary
        //                0x3f  0x3f  0x3f  Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an int.
        if (src.order() == ByteOrder.BIG_ENDIAN) {
            final int inBuff;
            switch (numSigBytes) {
                case 1:
                    inBuff = toInt(src.getByte(srcOffset));
                    break;
                case 2:
                    inBuff = toIntBE(src.getShort(srcOffset));
                    break;
                default:
                    inBuff = numSigBytes &lt;= 0 ? 0 : toIntBE(src.getMedium(srcOffset));
                    break;
            }
            encode3to4BigEndian(inBuff, numSigBytes, dest, destOffset, alphabet);
        } else {
            final int inBuff;
            switch (numSigBytes) {
                case 1:
                    inBuff = toInt(src.getByte(srcOffset));
                    break;
                case 2:
                    inBuff = toIntLE(src.getShort(srcOffset));
                    break;
                default:
                    inBuff = numSigBytes &lt;= 0 ? 0 : toIntLE(src.getMedium(srcOffset));
                    break;
            }
            encode3to4LittleEndian(inBuff, numSigBytes, dest, destOffset, alphabet);
        }
    }

    // package-private for testing
    static int encodedBufferSize(int len, boolean breakLines) {
        // Cast len to long to prevent overflow
        long len43 = ((long) len &lt;&lt; 2) / 3;

        // Account for padding
        long ret = (len43 + 3) &amp; ~3;

        if (breakLines) {
            ret += len43 / MAX_LINE_LENGTH;
        }

        return ret &lt; Integer.MAX_VALUE ? (int) ret : Integer.MAX_VALUE;
    }

    private static int toInt(byte value) {
        return (value &amp; 0xff) &lt;&lt; 16;
    }

    private static int toIntBE(short value) {
        return (value &amp; 0xff00) &lt;&lt; 8 | (value &amp; 0xff) &lt;&lt; 8;
    }

    private static int toIntLE(short value) {
        return (value &amp; 0xff) &lt;&lt; 16 | (value &amp; 0xff00);
    }

    private static int toIntBE(int mediumValue) {
        return (mediumValue &amp; 0xff0000) | (mediumValue &amp; 0xff00) | (mediumValue &amp; 0xff);
    }

    private static int toIntLE(int mediumValue) {
        return (mediumValue &amp; 0xff) &lt;&lt; 16 | (mediumValue &amp; 0xff00) | (mediumValue &amp; 0xff0000) &gt;&gt;&gt; 16;
    }

    private static void encode3to4BigEndian(
            int inBuff, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
        // Packing bytes into an int to reduce bound and reference count checking.
        switch (numSigBytes) {
            case 3:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
                                        alphabet[inBuff &gt;&gt;&gt;  6 &amp; 0x3f] &lt;&lt; 8  |
                                        alphabet[inBuff        &amp; 0x3f]);
                break;
            case 2:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
                                        alphabet[inBuff &gt;&gt;&gt; 6  &amp; 0x3f] &lt;&lt; 8  |
                                        EQUALS_SIGN);
                break;
            case 1:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ] &lt;&lt; 24 |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 16 |
                                        EQUALS_SIGN &lt;&lt; 8                     |
                                        EQUALS_SIGN);
                break;
            default:
                // NOOP
                break;
        }
    }

    private static void encode3to4LittleEndian(
            int inBuff, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {
        // Packing bytes into an int to reduce bound and reference count checking.
        switch (numSigBytes) {
            case 3:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]       |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8  |
                                        alphabet[inBuff &gt;&gt;&gt;  6 &amp; 0x3f] &lt;&lt; 16 |
                                        alphabet[inBuff        &amp; 0x3f] &lt;&lt; 24);
                break;
            case 2:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]       |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8  |
                                        alphabet[inBuff &gt;&gt;&gt; 6  &amp; 0x3f] &lt;&lt; 16 |
                                        EQUALS_SIGN &lt;&lt; 24);
                break;
            case 1:
                dest.setInt(destOffset, alphabet[inBuff &gt;&gt;&gt; 18       ]      |
                                        alphabet[inBuff &gt;&gt;&gt; 12 &amp; 0x3f] &lt;&lt; 8 |
                                        EQUALS_SIGN &lt;&lt; 16                   |
                                        EQUALS_SIGN &lt;&lt; 24);
                break;
            default:
                // NOOP
                break;
        }
    }

    public static ByteBuf decode(ByteBuf src) {
        return decode(src, Base64Dialect.STANDARD);
    }

<a name="2"></a>    public static ByteBuf decode(ByteBuf src, Base64Dialect dialect) {
        ObjectUtil.checkNotNull(src, "src");

        ByteBuf dest = decode(src, src.readerIndex(), <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>src.readableBytes(), dialect);
        src.readerIndex(src.writerIndex());
        return dest;
    }

    public static ByteBuf decode(
            ByteBuf src, int off</b></font>, int len) {
        return decode(src, off, len, Base64Dialect.STANDARD);
    }

    public static ByteBuf decode(
            ByteBuf src, int off, int len, Base64Dialect dialect) {
        return decode(src, off, len, dialect, src.alloc());
    }

    public static ByteBuf decode(
            ByteBuf src, int off, int len, Base64Dialect dialect, ByteBufAllocator allocator) {
        ObjectUtil.checkNotNull(src, "src");
        ObjectUtil.checkNotNull(dialect, "dialect");

        // Using a ByteProcessor to reduce bound and reference count checking.
        return new Decoder().decode(src, off, len, allocator, dialect);
    }

    // package-private for testing
    static int decodedBufferSize(int len) {
        return len - (len &gt;&gt;&gt; 2);
    }

    private static final class Decoder implements ByteProcessor {
        private final byte[] b4 = new byte[4];
        private int b4Posn;
        private byte[] decodabet;
        private int outBuffPosn;
        private ByteBuf dest;

        ByteBuf decode(ByteBuf src, int off, int len, ByteBufAllocator allocator, Base64Dialect dialect) {
            dest = allocator.buffer(decodedBufferSize(len)).order(src.order()); // Upper limit on size of output

            decodabet = decodabet(dialect);
            try {
                src.forEachByte(off, len, this);
                return dest.slice(0, outBuffPosn);
            } catch (Throwable cause) {
                dest.release();
                PlatformDependent.throwException(cause);
                return null;
            }
        }

        @Override
        public boolean process(byte value) throws Exception {
            if (value &gt; 0) {
                byte sbiDecode = decodabet[value];
                if (sbiDecode &gt;= WHITE_SPACE_ENC) { // White space, Equals sign or better
                    if (sbiDecode &gt;= EQUALS_SIGN_ENC) { // Equals sign or better
                        b4[b4Posn ++] = value;
                        if (b4Posn &gt; 3) { // Quartet built
                            outBuffPosn += decode4to3(b4, dest, outBuffPosn, decodabet);
                            b4Posn = 0;

                            // If that was the equals sign, break out of 'for' loop
                            return value != EQUALS_SIGN;
                        }
                    }
                    return true;
                }
            }
            throw new IllegalArgumentException(
                    "invalid Base64 input character: " + (short) (value &amp; 0xFF) + " (decimal)");
        }

        private static int decode4to3(byte[] src, ByteBuf dest, int destOffset, byte[] decodabet) {
            final byte src0 = src[0];
            final byte src1 = src[1];
            final byte src2 = src[2];
            final int decodedValue;
            if (src2 == EQUALS_SIGN) {
                // Example: Dk==
                try {
                    decodedValue = (decodabet[src0] &amp; 0xff) &lt;&lt; 2 | (decodabet[src1] &amp; 0xff) &gt;&gt;&gt; 4;
                } catch (IndexOutOfBoundsException ignored) {
                    throw new IllegalArgumentException("not encoded in Base64");
                }
                dest.setByte(destOffset, decodedValue);
                return 1;
            }

            final byte src3 = src[3];
            if (src3 == EQUALS_SIGN) {
                // Example: DkL=
                final byte b1 = decodabet[src1];
                // Packing bytes into a short to reduce bound and reference count checking.
                try {
                    if (dest.order() == ByteOrder.BIG_ENDIAN) {
                        // The decodabet bytes are meant to straddle byte boundaries and so we must carefully mask out
                        // the bits we care about.
                        decodedValue = ((decodabet[src0] &amp; 0x3f) &lt;&lt; 2 | (b1 &amp; 0xf0) &gt;&gt; 4) &lt;&lt; 8 |
                                        (b1 &amp; 0xf) &lt;&lt; 4 | (decodabet[src2] &amp; 0xfc) &gt;&gt;&gt; 2;
                    } else {
                        // This is just a simple byte swap of the operation above.
                        decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 2 | (b1 &amp; 0xf0) &gt;&gt; 4 |
                                      ((b1 &amp; 0xf) &lt;&lt; 4 | (decodabet[src2] &amp; 0xfc) &gt;&gt;&gt; 2) &lt;&lt; 8;
                    }
                } catch (IndexOutOfBoundsException ignored) {
                    throw new IllegalArgumentException("not encoded in Base64");
                }
                dest.setShort(destOffset, decodedValue);
                return 2;
            }

            // Example: DkLE
            try {
                if (dest.order() == ByteOrder.BIG_ENDIAN) {
                    decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 18 |
                                   (decodabet[src1] &amp; 0xff) &lt;&lt; 12 |
                                   (decodabet[src2] &amp; 0xff) &lt;&lt; 6 |
                                    decodabet[src3] &amp; 0xff;
                } else {
                    final byte b1 = decodabet[src1];
                    final byte b2 = decodabet[src2];
                    // The goal is to byte swap the BIG_ENDIAN case above. There are 2 interesting things to consider:
                    // 1. We are byte swapping a 3 byte data type. The left and the right byte switch, but the middle
                    //    remains the same.
                    // 2. The contents straddles byte boundaries. This means bytes will be pulled apart during the byte
                    //    swapping process.
                    decodedValue = (decodabet[src0] &amp; 0x3f) &lt;&lt; 2 |
                                   // The bottom half of b1 remains in the middle.
                                   (b1 &amp; 0xf) &lt;&lt; 12 |
                                   // The top half of b1 are the least significant bits after the swap.
                                   (b1 &amp; 0xf0) &gt;&gt;&gt; 4 |
                                   // The bottom 2 bits of b2 will be the most significant bits after the swap.
                                   (b2 &amp; 0x3) &lt;&lt; 22 |
                                   // The remaining 6 bits of b2 remain in the middle.
                                   (b2 &amp; 0xfc) &lt;&lt; 6 |
                                   (decodabet[src3] &amp; 0xff) &lt;&lt; 16;
                }
            } catch (IndexOutOfBoundsException ignored) {
                throw new IllegalArgumentException("not encoded in Base64");
            }
            dest.setMedium(destOffset, decodedValue);
            return 3;
        }
    }

    private Base64() {
        // Unused
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
