<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TablesTest.java &amp; AbstractScheduledServiceTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TablesTest.java &amp; AbstractScheduledServiceTest.java
      </h3>
<h1 align="center">
        10.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TablesTest.java (54.081635%)<th>AbstractScheduledServiceTest.java (5.573081%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-56)<td><a href="#" name="0">(189-199)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(56-64)<td><a href="#" name="1">(217-224)</a><td align="center"><font color="#c80000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(82-91)<td><a href="#" name="2">(143-150)</a><td align="center"><font color="#b60000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(74-79)<td><a href="#" name="3">(388-394)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(17-26)<td><a href="#" name="4">(17-27)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TablesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
2 import com.google.common.annotations.GwtCompatible;
3 import com.google.common.annotations.GwtIncompatible;
4 import com.google.common.collect.Table.Cell;
5 import com.google.common.testing.CollectorTester;
6 import com.google.common.testing.EqualsTester;
7 import com.google.common.testing.SerializableTester;
8 import java.util.stream.Collector;
9 import</b></font> junit.framework.TestCase;
10 @GwtCompatible(emulated = true)
11 public class TablesTest extends TestCase {
12 <a name="0"></a>  public void testToTableSanityTest() {
13     Collector&lt;Cell&lt;String, String, Integer&gt;, ?, Table&lt;String, String, Integer&gt;&gt; collector =
14         Tables.toTable(Cell::getRowKey, Cell::getColumnKey, Cell::getValue, HashBasedTable::create);
15     HashBasedTable&lt;String, String, Integer&gt; expected = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HashBasedTable.create();
16     expected.put("one", "uno", 1);
17     CollectorTester.of(collector)
18         .expectCollects(HashBasedTable.create())
19         .expectCollects(expected, Tables.immutableCell("one", "uno", 1));
20   }
21   public void testToTableMergingSanityTest() {
22     Collector&lt;Cell&lt;String, String, Integer&gt;, ?, Table&lt;String, String, Integer&gt;&gt; collector =
23         Tables.toTable(
24             Cell::getRowKey,
25             Cell::getColumnKey,
26 <a name="1"></a>            Cell::getValue,
27             Integer::sum,
28             HashBasedTable::create);
29     HashBasedTable&lt;String, String, Integer&gt; expected = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HashBasedTable.create()</b></font>;
30     expected.put("one", "uno", 3);
31     CollectorTester.of(collector)
32         .expectCollects(HashBasedTable.create())
33         .expectCollects(
34             expected, Tables.immutableCell("one", "uno", 1), Tables.immutableCell("one", "uno", 2));
35   }
36   @GwtIncompatible   public void testImmutableEntrySerialization() {
37     Cell&lt;String, Integer, Character&gt; entry = Tables.immutableCell("foo", 1, 'a');
38     SerializableTester.reserializeAndAssert(entry);
39   }
40   public void testImmutableEntryToString() {
41 <a name="3"></a>    Cell&lt;String, Integer, Character&gt; entry = Tables.immutableCell("foo", 1, 'a');
42     assertEquals("(foo,1)=a", entry.toString());
43     Cell&lt;String, Integer, Character&gt; nullEntry = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Tables.immutableCell(null, null, null);
44     assertEquals("(null,null)=null", nullEntry.toString());
45   }
46   public void testEntryEquals() {
47 <a name="2"></a>    Cell&lt;String, Integer, Character&gt; entry = Tables.immutableCell</b></font>("foo", 1, 'a');
48     new EqualsTester()
49         .addEqualityGroup(entry, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Tables.immutableCell("foo", 1, 'a'))
50         .addEqualityGroup(Tables.immutableCell("bar", 1, 'a'))
51         .addEqualityGroup(Tables.immutableCell("foo", 2, 'a'))
52         .addEqualityGroup(Tables.immutableCell("foo", 1, 'b'))
53         .addEqualityGroup(Tables.immutableCell(null, null, null))
54         .testEquals();
55   }
56   public void testEntryEqualsNull() {
57     Cell&lt;String, Integer, Character&gt; entry = Tables.immutableCell(null, null, null)</b></font>;
58     new EqualsTester()
59         .addEqualityGroup(entry, Tables.immutableCell(null, null, null))
60         .addEqualityGroup(Tables.immutableCell("bar", null, null))
61         .addEqualityGroup(Tables.immutableCell(null, 2, null))
62         .addEqualityGroup(Tables.immutableCell(null, null, 'b'))
63         .addEqualityGroup(Tables.immutableCell("foo", 1, 'a'))
64         .testEquals();
65   }
66 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractScheduledServiceTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
2 import static com.google.common.truth.Truth.assertThat;
3 import static com.google.common.util.concurrent.AbstractScheduledService.Scheduler.newFixedDelaySchedule;
4 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
5 import static java.util.concurrent.TimeUnit.MILLISECONDS;
6 import static java.util.concurrent.TimeUnit.NANOSECONDS;
7 import static java.util.concurrent.TimeUnit.SECONDS;
8 import com.google.common.util.concurrent.AbstractScheduledService.Cancellable;
9 import</b></font> com.google.common.util.concurrent.AbstractScheduledService.Scheduler;
10 import com.google.common.util.concurrent.Service.State;
11 import com.google.common.util.concurrent.testing.TestingExecutors;
12 import java.util.concurrent.BrokenBarrierException;
13 import java.util.concurrent.CancellationException;
14 import java.util.concurrent.CountDownLatch;
15 import java.util.concurrent.CyclicBarrier;
16 import java.util.concurrent.Delayed;
17 import java.util.concurrent.Executors;
18 import java.util.concurrent.Future;
19 import java.util.concurrent.ScheduledExecutorService;
20 import java.util.concurrent.ScheduledFuture;
21 import java.util.concurrent.ScheduledThreadPoolExecutor;
22 import java.util.concurrent.TimeUnit;
23 import java.util.concurrent.TimeoutException;
24 import java.util.concurrent.atomic.AtomicBoolean;
25 import java.util.concurrent.atomic.AtomicInteger;
26 import java.util.concurrent.atomic.AtomicReference;
27 import junit.framework.TestCase;
28 public class AbstractScheduledServiceTest extends TestCase {
29   volatile Scheduler configuration = newFixedDelaySchedule(0, 10, MILLISECONDS);
30   volatile ScheduledFuture&lt;?&gt; future = null;
31   volatile boolean atFixedRateCalled = false;
32   volatile boolean withFixedDelayCalled = false;
33   volatile boolean scheduleCalled = false;
34   final ScheduledExecutorService executor =
35       new ScheduledThreadPoolExecutor(10) {
36         @Override
37         public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(
38             Runnable command, long initialDelay, long delay, TimeUnit unit) {
39           return future = super.scheduleWithFixedDelay(command, initialDelay, delay, unit);
40         }
41       };
42   public void testServiceStartStop() throws Exception {
43     NullService service = new NullService();
44     service.startAsync().awaitRunning();
45     assertFalse(future.isDone());
46     service.stopAsync().awaitTerminated();
47     assertTrue(future.isCancelled());
48   }
49   private class NullService extends AbstractScheduledService {
50     @Override
51     protected void runOneIteration() throws Exception {}
52     @Override
53     protected Scheduler scheduler() {
54       return configuration;
55     }
56     @Override
57     protected ScheduledExecutorService executor() {
58       return executor;
59     }
60   }
61   public void testFailOnExceptionFromRun() throws Exception {
62     TestService service = new TestService();
63     service.runException = new Exception();
64     service.startAsync().awaitRunning();
65     service.runFirstBarrier.await();
66     service.runSecondBarrier.await();
67     try {
68       future.get();
69       fail();
70     } catch (CancellationException expected) {
71     }
72     assertEquals(service.runException, service.failureCause());
73     assertEquals(Service.State.FAILED, service.state());
74   }
75   public void testFailOnExceptionFromStartUp() {
76     TestService service = new TestService();
77     service.startUpException = new Exception();
78     try {
79       service.startAsync().awaitRunning();
80       fail();
81     } catch (IllegalStateException e) {
82       assertThat(e).hasCauseThat().isEqualTo(service.startUpException);
83     }
84     assertEquals(0, service.numberOfTimesRunCalled.get());
85     assertEquals(Service.State.FAILED, service.state());
86   }
87   public void testFailOnErrorFromStartUpListener() throws InterruptedException {
88     final Error error = new Error();
89     final CountDownLatch latch = new CountDownLatch(1);
90     TestService service = new TestService();
91     service.addListener(
92         new Service.Listener() {
93           @Override
94           public void running() {
95             throw error;
96           }
97           @Override
98           public void failed(State from, Throwable failure) {
99             assertEquals(State.RUNNING, from);
100             assertEquals(error, failure);
101             latch.countDown();
102           }
103 <a name="2"></a>        },
104         directExecutor());
105     service.startAsync();
106     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>latch.await();
107     assertEquals(0, service.numberOfTimesRunCalled.get());
108     assertEquals(Service.State.FAILED, service.state());
109   }
110   public void testFailOnExceptionFromShutDown() throws Exception {
111     TestService service = new TestService()</b></font>;
112     service.shutDownException = new Exception();
113     service.startAsync().awaitRunning();
114     service.runFirstBarrier.await();
115     service.stopAsync();
116     service.runSecondBarrier.await();
117     try {
118       service.awaitTerminated();
119       fail();
120     } catch (IllegalStateException e) {
121       assertThat(e).hasCauseThat().isEqualTo(service.shutDownException);
122     }
123     assertEquals(Service.State.FAILED, service.state());
124   }
125   public void testRunOneIterationCalledMultipleTimes() throws Exception {
126     TestService service = new TestService();
127     service.startAsync().awaitRunning();
128     for (int i = 1; i &lt; 10; i++) {
129       service.runFirstBarrier.await();
130       assertEquals(i, service.numberOfTimesRunCalled.get());
131       service.runSecondBarrier.await();
132     }
133     service.runFirstBarrier.await();
134     service.stopAsync();
135     service.runSecondBarrier.await();
136     service.stopAsync().awaitTerminated();
137   }
138   public void testExecutorOnlyCalledOnce() throws Exception {
139     TestService service = new TestService();
140     service.startAsync().awaitRunning();
141     assertEquals(1, service.numberOfTimesExecutorCalled.get());
142     for (int i = 1; i &lt; 10; i++) {
143       service.runFirstBarrier.await();
144 <a name="0"></a>      assertEquals(i, service.numberOfTimesRunCalled.get());
145       service.runSecondBarrier.await();
146     }
147     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.runFirstBarrier.await();
148     service.stopAsync();
149     service.runSecondBarrier.await();
150     service.stopAsync().awaitTerminated();
151     assertEquals(1, service.numberOfTimesExecutorCalled.get());
152   }
153   public void testDefaultExecutorIsShutdownWhenServiceIsStopped() throws Exception {
154     final AtomicReference&lt;ScheduledExecutorService&gt; executor = Atomics.newReference();
155     AbstractScheduledService service =</b></font>
156         new AbstractScheduledService() {
157           @Override
158           protected void runOneIteration() throws Exception {}
159           @Override
160           protected ScheduledExecutorService executor() {
161             executor.set(super.executor());
162             return executor.get();
163           }
164           @Override
165           protected Scheduler scheduler() {
166             return newFixedDelaySchedule(0, 1, MILLISECONDS);
167           }
168 <a name="1"></a>        };
169     service.startAsync();
170     assertFalse(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.executor().isShutdown());
171     service.awaitRunning();
172     service.stopAsync();
173     service.awaitTerminated();
174     assertTrue(executor.get().awaitTermination(100, MILLISECONDS));
175   }
176   public void testDefaultExecutorIsShutdownWhen</b></font>ServiceFails() throws Exception {
177     final AtomicReference&lt;ScheduledExecutorService&gt; executor = Atomics.newReference();
178     AbstractScheduledService service =
179         new AbstractScheduledService() {
180           @Override
181           protected void startUp() throws Exception {
182             throw new Exception("Failed");
183           }
184           @Override
185           protected void runOneIteration() throws Exception {}
186           @Override
187           protected ScheduledExecutorService executor() {
188             executor.set(super.executor());
189             return executor.get();
190           }
191           @Override
192           protected Scheduler scheduler() {
193             return newFixedDelaySchedule(0, 1, MILLISECONDS);
194           }
195         };
196     try {
197       service.startAsync().awaitRunning();
198       fail("Expected service to fail during startup");
199     } catch (IllegalStateException expected) {
200     }
201     assertTrue(executor.get().awaitTermination(100, MILLISECONDS));
202   }
203   public void testSchedulerOnlyCalledOnce() throws Exception {
204     TestService service = new TestService();
205     service.startAsync().awaitRunning();
206     assertEquals(1, service.numberOfTimesSchedulerCalled.get());
207     for (int i = 1; i &lt; 10; i++) {
208       service.runFirstBarrier.await();
209       assertEquals(i, service.numberOfTimesRunCalled.get());
210       service.runSecondBarrier.await();
211     }
212     service.runFirstBarrier.await();
213     service.stopAsync();
214     service.runSecondBarrier.await();
215     service.awaitTerminated();
216     assertEquals(1, service.numberOfTimesSchedulerCalled.get());
217   }
218   public void testTimeout() {
219     Service service =
220         new AbstractScheduledService() {
221           @Override
222           protected Scheduler scheduler() {
223             return Scheduler.newFixedDelaySchedule(0, 1, NANOSECONDS);
224           }
225           @Override
226           protected ScheduledExecutorService executor() {
227             return TestingExecutors.noOpScheduledExecutor();
228           }
229           @Override
230           protected void runOneIteration() throws Exception {}
231           @Override
232           protected String serviceName() {
233             return "Foo";
234           }
235         };
236     try {
237       service.startAsync().awaitRunning(1, MILLISECONDS);
238       fail("Expected timeout");
239     } catch (TimeoutException e) {
240       assertThat(e)
241           .hasMessageThat()
242           .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");
243     }
244   }
245   private class TestService extends AbstractScheduledService {
246     CyclicBarrier runFirstBarrier = new CyclicBarrier(2);
247     CyclicBarrier runSecondBarrier = new CyclicBarrier(2);
248     volatile boolean startUpCalled = false;
249     volatile boolean shutDownCalled = false;
250     AtomicInteger numberOfTimesRunCalled = new AtomicInteger(0);
251     AtomicInteger numberOfTimesExecutorCalled = new AtomicInteger(0);
252     AtomicInteger numberOfTimesSchedulerCalled = new AtomicInteger(0);
253     volatile Exception runException = null;
254     volatile Exception startUpException = null;
255     volatile Exception shutDownException = null;
256     @Override
257     protected void runOneIteration() throws Exception {
258       assertTrue(startUpCalled);
259       assertFalse(shutDownCalled);
260       numberOfTimesRunCalled.incrementAndGet();
261       assertEquals(State.RUNNING, state());
262       runFirstBarrier.await();
263       runSecondBarrier.await();
264       if (runException != null) {
265         throw runException;
266       }
267     }
268     @Override
269     protected void startUp() throws Exception {
270       assertFalse(startUpCalled);
271       assertFalse(shutDownCalled);
272       startUpCalled = true;
273       assertEquals(State.STARTING, state());
274       if (startUpException != null) {
275         throw startUpException;
276       }
277     }
278     @Override
279     protected void shutDown() throws Exception {
280       assertTrue(startUpCalled);
281       assertFalse(shutDownCalled);
282       shutDownCalled = true;
283       if (shutDownException != null) {
284         throw shutDownException;
285       }
286     }
287     @Override
288     protected ScheduledExecutorService executor() {
289       numberOfTimesExecutorCalled.incrementAndGet();
290       return executor;
291     }
292     @Override
293     protected Scheduler scheduler() {
294       numberOfTimesSchedulerCalled.incrementAndGet();
295       return configuration;
296     }
297   }
298   private static final int INITIAL_DELAY = 10;
299   private static final int DELAY = 20;
300   private static final TimeUnit UNIT = MILLISECONDS;
301   final Runnable testRunnable =
302       new Runnable() {
303         @Override
304         public void run() {}
305       };
306   boolean called = false;
307   private void assertSingleCallWithCorrectParameters(
308       Runnable command, long initialDelay, long delay, TimeUnit unit) {
309 <a name="3"></a>    assertFalse(called);     called = true;
310     assertEquals(INITIAL_DELAY, initialDelay);
311     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(DELAY, delay);
312     assertEquals(UNIT, unit);
313     assertEquals(testRunnable, command);
314   }
315   public void testFixedRateSchedule() {
316     Scheduler schedule = Scheduler.newFixedRateSchedule</b></font>(INITIAL_DELAY, DELAY, UNIT);
317     Cancellable unused =
318         schedule.schedule(
319             null,
320             new ScheduledThreadPoolExecutor(1) {
321               @Override
322               public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(
323                   Runnable command, long initialDelay, long period, TimeUnit unit) {
324                 assertSingleCallWithCorrectParameters(command, initialDelay, period, unit);
325                 return new ThrowingScheduledFuture&lt;&gt;();
326               }
327             },
328             testRunnable);
329     assertTrue(called);
330   }
331   public void testFixedDelaySchedule() {
332     Scheduler schedule = newFixedDelaySchedule(INITIAL_DELAY, DELAY, UNIT);
333     Cancellable unused =
334         schedule.schedule(
335             null,
336             new ScheduledThreadPoolExecutor(10) {
337               @Override
338               public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(
339                   Runnable command, long initialDelay, long delay, TimeUnit unit) {
340                 assertSingleCallWithCorrectParameters(command, initialDelay, delay, unit);
341                 return new ThrowingScheduledFuture&lt;&gt;();
342               }
343             },
344             testRunnable);
345     assertTrue(called);
346   }
347   private static final class ThrowingScheduledFuture&lt;V&gt; extends ForwardingFuture&lt;V&gt;
348       implements ScheduledFuture&lt;V&gt; {
349     @Override
350     protected Future&lt;V&gt; delegate() {
351       throw new UnsupportedOperationException("test should not care about this");
352     }
353     @Override
354     public long getDelay(TimeUnit unit) {
355       throw new UnsupportedOperationException("test should not care about this");
356     }
357     @Override
358     public int compareTo(Delayed other) {
359       throw new UnsupportedOperationException("test should not care about this");
360     }
361   }
362   public void testFixedDelayScheduleFarFuturePotentiallyOverflowingScheduleIsNeverReached()
363       throws Exception {
364     TestAbstractScheduledCustomService service =
365         new TestAbstractScheduledCustomService() {
366           @Override
367           protected Scheduler scheduler() {
368             return newFixedDelaySchedule(Long.MAX_VALUE, Long.MAX_VALUE, SECONDS);
369           }
370         };
371     service.startAsync().awaitRunning();
372     try {
373       service.firstBarrier.await(5, SECONDS);
374       fail();
375     } catch (TimeoutException expected) {
376     }
377     assertEquals(0, service.numIterations.get());
378     service.stopAsync();
379     service.awaitTerminated();
380   }
381   public void testCustomSchedulerFarFuturePotentiallyOverflowingScheduleIsNeverReached()
382       throws Exception {
383     TestAbstractScheduledCustomService service =
384         new TestAbstractScheduledCustomService() {
385           @Override
386           protected Scheduler scheduler() {
387             return new AbstractScheduledService.CustomScheduler() {
388               @Override
389               protected Schedule getNextSchedule() throws Exception {
390                 return new Schedule(Long.MAX_VALUE, SECONDS);
391               }
392             };
393           }
394         };
395     service.startAsync().awaitRunning();
396     try {
397       service.firstBarrier.await(5, SECONDS);
398       fail();
399     } catch (TimeoutException expected) {
400     }
401     assertEquals(0, service.numIterations.get());
402     service.stopAsync();
403     service.awaitTerminated();
404   }
405   private static class TestCustomScheduler extends AbstractScheduledService.CustomScheduler {
406     public AtomicInteger scheduleCounter = new AtomicInteger(0);
407     @Override
408     protected Schedule getNextSchedule() throws Exception {
409       scheduleCounter.incrementAndGet();
410       return new Schedule(0, SECONDS);
411     }
412   }
413   public void testCustomSchedule_startStop() throws Exception {
414     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
415     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
416     final AtomicBoolean shouldWait = new AtomicBoolean(true);
417     Runnable task =
418         new Runnable() {
419           @Override
420           public void run() {
421             try {
422               if (shouldWait.get()) {
423                 firstBarrier.await();
424                 secondBarrier.await();
425               }
426             } catch (Exception e) {
427               throw new RuntimeException(e);
428             }
429           }
430         };
431     TestCustomScheduler scheduler = new TestCustomScheduler();
432     Cancellable future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);
433     firstBarrier.await();
434     assertEquals(1, scheduler.scheduleCounter.get());
435     secondBarrier.await();
436     firstBarrier.await();
437     assertEquals(2, scheduler.scheduleCounter.get());
438     shouldWait.set(false);
439     secondBarrier.await();
440     future.cancel(false);
441   }
442   public void testCustomSchedulerServiceStop() throws Exception {
443     TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService();
444     service.startAsync().awaitRunning();
445     service.firstBarrier.await();
446     assertEquals(1, service.numIterations.get());
447     service.stopAsync();
448     service.secondBarrier.await();
449     service.awaitTerminated();
450     Thread.sleep(UNIT.toMillis(3 * DELAY));
451     assertEquals(1, service.numIterations.get());
452   }
453   public void testCustomScheduler_deadlock() throws InterruptedException, BrokenBarrierException {
454     final CyclicBarrier inGetNextSchedule = new CyclicBarrier(2);
455     for (int i = 0; i &lt; 1000; i++) {
456       Service service =
457           new AbstractScheduledService() {
458             @Override
459             protected void runOneIteration() {}
460             @Override
461             protected Scheduler scheduler() {
462               return new CustomScheduler() {
463                 @Override
464                 protected Schedule getNextSchedule() throws Exception {
465                   if (state() != State.STARTING) {
466                     inGetNextSchedule.await();
467                     Thread.yield();
468                     throw new RuntimeException("boom");
469                   }
470                   return new Schedule(0, NANOSECONDS);
471                 }
472               };
473             }
474           };
475       service.startAsync().awaitRunning();
476       inGetNextSchedule.await();
477       service.stopAsync();
478     }
479   }
480   public void testBig() throws Exception {
481     TestAbstractScheduledCustomService service =
482         new TestAbstractScheduledCustomService() {
483           @Override
484           protected Scheduler scheduler() {
485             return new AbstractScheduledService.CustomScheduler() {
486               @Override
487               protected Schedule getNextSchedule() throws Exception {
488                 Thread.yield();
489                 return new Schedule(0, SECONDS);
490               }
491             };
492           }
493         };
494     service.useBarriers = false;
495     service.startAsync().awaitRunning();
496     Thread.sleep(50);
497     service.useBarriers = true;
498     service.firstBarrier.await();
499     int numIterations = service.numIterations.get();
500     service.stopAsync();
501     service.secondBarrier.await();
502     service.awaitTerminated();
503     assertEquals(numIterations, service.numIterations.get());
504   }
505   private static class TestAbstractScheduledCustomService extends AbstractScheduledService {
506     final AtomicInteger numIterations = new AtomicInteger(0);
507     volatile boolean useBarriers = true;
508     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
509     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
510     @Override
511     protected void runOneIteration() throws Exception {
512       numIterations.incrementAndGet();
513       if (useBarriers) {
514         firstBarrier.await();
515         secondBarrier.await();
516       }
517     }
518     @Override
519     protected ScheduledExecutorService executor() {
520       return Executors.newScheduledThreadPool(10);
521     }
522     @Override
523     protected Scheduler scheduler() {
524       return new CustomScheduler() {
525         @Override
526         protected Schedule getNextSchedule() throws Exception {
527           return new Schedule(DELAY, UNIT);
528         }
529       };
530     }
531   }
532   public void testCustomSchedulerFailure() throws Exception {
533     TestFailingCustomScheduledService service = new TestFailingCustomScheduledService();
534     service.startAsync().awaitRunning();
535     for (int i = 1; i &lt; 4; i++) {
536       service.firstBarrier.await();
537       assertEquals(i, service.numIterations.get());
538       service.secondBarrier.await();
539     }
540     Thread.sleep(1000);
541     try {
542       service.stopAsync().awaitTerminated(100, SECONDS);
543       fail();
544     } catch (IllegalStateException e) {
545       assertEquals(State.FAILED, service.state());
546     }
547   }
548   private static class TestFailingCustomScheduledService extends AbstractScheduledService {
549     final AtomicInteger numIterations = new AtomicInteger(0);
550     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
551     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
552     @Override
553     protected void runOneIteration() throws Exception {
554       numIterations.incrementAndGet();
555       firstBarrier.await();
556       secondBarrier.await();
557     }
558     @Override
559     protected ScheduledExecutorService executor() {
560       return Executors.newScheduledThreadPool(10);
561     }
562     @Override
563     protected Scheduler scheduler() {
564       return new CustomScheduler() {
565         @Override
566         protected Schedule getNextSchedule() throws Exception {
567           if (numIterations.get() &gt; 2) {
568             throw new IllegalStateException("Failed");
569           }
570           return new Schedule(DELAY, UNIT);
571         }
572       };
573     }
574   }
575 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
