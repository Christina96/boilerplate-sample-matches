<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TransportClusterUpdateSettingsAction.java &amp; NumberFieldMapper.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TransportClusterUpdateSettingsAction.java &amp; NumberFieldMapper.java
      </h3>
<h1 align="center">
        14.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TransportClusterUpdateSettingsAction.java (32.188843%)<th>NumberFieldMapper.java (9.225092%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-47)<td><a href="#" name="0">(24-51)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(88-95)<td><a href="#" name="1">(115-121)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(96-103)<td><a href="#" name="2">(95-101)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(177-183)<td><a href="#" name="3">(150-155)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(56-71)<td><a href="#" name="4">(62-68)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(168-173)<td><a href="#" name="5">(200-204)</a><td align="center"><font color="#630000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportClusterUpdateSettingsAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.action.admin.cluster.settings;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.apache.logging.log4j.message.ParameterizedMessage;
4 import org.elasticsearch.ElasticsearchException;
5 import org.elasticsearch.action.ActionListener;
6 import org.elasticsearch.action.support.master.TransportMasterNodeAction;
7 import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
8 import org.elasticsearch.cluster.ClusterState;
9 import org.elasticsearch.cluster.block.ClusterBlockException;
10 import org.elasticsearch.cluster.block.ClusterBlockLevel;
11 import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
12 import org.elasticsearch.cluster.metadata.Metadata;
13 import org.elasticsearch.cluster.node.DiscoveryNode;
14 import org.elasticsearch.cluster.routing.allocation.AllocationService;
15 import org.elasticsearch.cluster.service.ClusterService;
16 import javax.annotation.Nullable;
17 import org.elasticsearch.common.Priority;
18 import org.elasticsearch.common.inject.Inject;
19 import org.elasticsearch.common.io.stream.StreamInput;
20 import org.elasticsearch.common.settings.ClusterSettings;
21 import org.elasticsearch.threadpool.ThreadPool;
22 import org.elasticsearch.transport.TransportService;
23 import java.io.IOException;
24 public class TransportClusterUpdateSettingsAction extends TransportMasterNodeAction&lt;ClusterUpdateSettingsRequest, ClusterUpdateSettingsResponse&gt; {
25     private final AllocationService allocationService</b></font>;
26     private final ClusterSettings clusterSettings;
27     @Inject
28     public TransportClusterUpdateSettingsAction(TransportService transportService,
29 <a name="4"></a>                                                ClusterService clusterService,
30                                                 ThreadPool threadPool,
31                                                 AllocationService allocationService,
32                                                 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IndexNameExpressionResolver indexNameExpressionResolver,
33                                                 ClusterSettings clusterSettings) {
34         super(
35             ClusterUpdateSettingsAction.NAME,
36             false,
37             transportService,
38             clusterService,
39             threadPool,
40             ClusterUpdateSettingsRequest::new,
41             indexNameExpressionResolver
42         );
43         this.allocationService = allocationService;
44         this.clusterSettings = clusterSettings;
45     }
46     @</b></font>Override
47     protected String executor() {
48         return ThreadPool.Names.SAME;
49     }
50     @Override
51     protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {
52         if (request.transientSettings().size() + request.persistentSettings().size() == 1) {
53             if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())
54                 || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())
55                 || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())
56                 || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {
57 <a name="1"></a>                                return null;
58             }
59         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
60         return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);
61     }
62 <a name="2"></a>    @Override
63     protected ClusterUpdateSettingsResponse read(StreamInput in) throws IOException {
64         return</b></font> new ClusterUpdateSettingsResponse(in);
65     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
66     @Override
67     protected void masterOperation(final ClusterUpdateSettingsRequest request,
68                                    final ClusterState state,
69                                    final ActionListener&lt;ClusterUpdateSettingsResponse&gt; listener) {
70         final SettingsUpdater updater = new SettingsUpdater(clusterSettings);
71         clusterService.submitStateUpdateTask</b></font>(
72             "cluster_update_settings",
73             new AckedClusterStateUpdateTask&lt;&gt;(Priority.IMMEDIATE, request, listener) {
74                 private volatile boolean changed = false;
75                 @Override
76                 protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {
77                     return new ClusterUpdateSettingsResponse(acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate());
78                 }
79                 @Override
80                 public void onAllNodesAcked(@Nullable Exception e) {
81                     if (changed) {
82                         reroute(true);
83                     } else {
84                         super.onAllNodesAcked(e);
85                     }
86                 }
87                 @Override
88                 public void onAckTimeout() {
89                     if (changed) {
90                         reroute(false);
91                     } else {
92                         super.onAckTimeout();
93                     }
94                 }
95                 private void reroute(final boolean updateSettingsAcked) {
96                     if (!clusterService.state().nodes().isLocalNodeElectedMaster()) {
97                         logger.debug("Skipping reroute after cluster update settings, because node is no longer master");
98                         listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(),
99                             updater.getPersistentUpdate()));
100                         return;
101                     }
102                     clusterService.submitStateUpdateTask(
103                         "reroute_after_cluster_update_settings",
104                         new AckedClusterStateUpdateTask&lt;ClusterUpdateSettingsResponse&gt;(Priority.URGENT, request, listener) {
105                             @Override
106                             public boolean mustAck(DiscoveryNode discoveryNode) {
107                                 //we wait for the reroute ack only if the update settings was acknowledged
108                                 return updateSettingsAcked;
109                             }
110                             @Override
111                             protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {
112                                 return new ClusterUpdateSettingsResponse(updateSettingsAcked &amp;&amp; acknowledged, updater.getTransientUpdates(),
113                                     updater.getPersistentUpdate());
114                             }
115 <a name="5"></a>                            @Override
116                             public void onNoLongerMaster(String source) {
117                                 logger.debug("failed to preform reroute after cluster settings were updated - current node is no longer a master");
118                                 listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>updater.getTransientUpdates(),
119                                     updater.getPersistentUpdate()));
120                             }
121                             @Override
122                             public void onFailure(String source, Exception e) {</b></font>
123 <a name="3"></a>                                //if the reroute fails we only log
124                                 logger.debug(() -&gt; new ParameterizedMessage("failed to perform [{}]", source), e);
125                                 listener.onFailure(new ElasticsearchException("reroute after update settings failed", e));
126                             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
127                             @Override
128                             public ClusterState execute(final ClusterState currentState) {
129                                 return allocationService.reroute(currentState, "reroute after cluster update settings");
130                             }</b></font>
131                         }
132                     );
133                 }
134                 @Override
135                 public void onFailure(String source, Exception e) {
136                     logger.debug(() -&gt; new ParameterizedMessage("failed to perform [{}]", source), e);
137                     super.onFailure(source, e);
138                 }
139                 @Override
140                 public ClusterState execute(final ClusterState currentState) {
141                     final ClusterState clusterState =
142                             updater.updateSettings(
143                                     currentState,
144                                     clusterSettings.upgradeSettings(request.transientSettings()),
145                                     clusterSettings.upgradeSettings(request.persistentSettings()),
146                                     logger);
147                     changed = clusterState != currentState;
148                     return clusterState;
149                 }
150             }
151         );
152     }
153 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>NumberFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.index.mapper;
2 <a name="0"></a>
3 import java.io.IOException;
4 import java.util.ArrayList;
5 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.List;
6 import java.util.Map;
7 import java.util.Objects;
8 import javax.annotation.Nullable;
9 import org.apache.lucene.document.DoublePoint;
10 import org.apache.lucene.document.Field;
11 import org.apache.lucene.document.FieldType;
12 import org.apache.lucene.document.FloatPoint;
13 import org.apache.lucene.document.IntPoint;
14 import org.apache.lucene.document.LongPoint;
15 import org.apache.lucene.document.SortedNumericDocValuesField;
16 import org.apache.lucene.document.StoredField;
17 import org.apache.lucene.index.IndexOptions;
18 import org.apache.lucene.index.IndexableField;
19 import org.apache.lucene.util.BytesRef;
20 import org.apache.lucene.util.NumericUtils;
21 import org.elasticsearch.common.Numbers;
22 import org.elasticsearch.common.lucene.Lucene;
23 import org.elasticsearch.common.settings.Settings;
24 import org.elasticsearch.common.xcontent.XContentParser;
25 import org.elasticsearch.common.xcontent.XContentParser.Token;
26 public class NumberFieldMapper extends FieldMapper {
27     public static final FieldType FIELD_TYPE = new FieldType()</b></font>;
28     static {
29         FIELD_TYPE.setStored(false);
30         FIELD_TYPE.freeze();
31     }
32     public static class Builder extends FieldMapper.Builder&lt;Builder&gt; {
33 <a name="4"></a>
34         private final NumberType type;
35         public Builder(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String name, NumberType type) {
36             super(name, FIELD_TYPE);
37             this.type = type;
38             builder = this;
39         }
40         @</b></font>Override
41         public Builder indexOptions(IndexOptions indexOptions) {
42             throw new MapperParsingException(
43                     "index_options not allowed in field [" + name + "] of type [" + type.typeName() + "]");
44         }
45         @Override
46         public NumberFieldMapper build(BuilderContext context) {
47             return new NumberFieldMapper(
48                 name,
49                 position,
50                 defaultExpression,
51                 fieldType,
52                 new NumberFieldType(buildFullName(context), type, indexed, hasDocValues),
53                 context.indexSettings(),
54                 multiFieldsBuilder.build(this, context),
55                 copyTo
56             );
57         }
58     }
59     public static class TypeParser implements Mapper.TypeParser {
60         final NumberType type;
61 <a name="2"></a>
62         public TypeParser(NumberType type) {
63             this.type = type;
64         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
65         @Override
66         public Mapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node,
67                                          ParserContext parserContext) throws MapperParsingException {
68             Builder builder = new Builder(name, type);
69             TypeParsers.parseField</b></font>(builder, name, node, parserContext);
70             return builder;
71         }
72     }
73     public enum NumberType {
74         FLOAT("float") {
75             @Override
76             public Float parse(Object value, boolean coerce) {
77                 if (value instanceof Number) {
78                     return ((Number) value).floatValue();
79 <a name="1"></a>                }
80                 if (value instanceof BytesRef) {
81                     value = ((BytesRef) value).utf8ToString();
82                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
83                 return Float.parseFloat(value.toString());
84             }
85             @Override
86             public Number parsePoint(byte[] value) {
87                 return</b></font> FloatPoint.decodeDimension(value, 0);
88             }
89             @Override
90             public Float parse(XContentParser parser, boolean coerce) throws IOException {
91                 return parser.floatValue(coerce);
92             }
93             @Override
94             public List&lt;Field&gt; createFields(String name, Number value,
95                                             boolean indexed, boolean docValued, boolean stored) {
96                 List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
97                 if (indexed) {
98                     fields.add(new FloatPoint(name, value.floatValue()));
99                 }
100                 if (docValued) {
101                     fields.add(new SortedNumericDocValuesField(name,
102                         NumericUtils.floatToSortableInt(value.floatValue())));
103                 }
104                 if (stored) {
105                     fields.add(new StoredField(name, value.floatValue()));
106                 }
107                 return fields;
108             }
109         },
110         DOUBLE("double") {
111 <a name="3"></a>            @Override
112             public Double parse(Object value, boolean coerce) {
113                 return objectToDouble(value);
114             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
115             @Override
116             public Number parsePoint(byte[] value) {
117                 return DoublePoint.decodeDimension(value, 0);
118             }</b></font>
119             @Override
120             public Double parse(XContentParser parser, boolean coerce) throws IOException {
121                 return parser.doubleValue(coerce);
122             }
123             @Override
124             public List&lt;Field&gt; createFields(String name, Number value,
125                                             boolean indexed, boolean docValued, boolean stored) {
126                 List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
127                 if (indexed) {
128                     fields.add(new DoublePoint(name, value.doubleValue()));
129                 }
130                 if (docValued) {
131                     fields.add(new SortedNumericDocValuesField(name,
132                         NumericUtils.doubleToSortableLong(value.doubleValue())));
133                 }
134                 if (stored) {
135                     fields.add(new StoredField(name, value.doubleValue()));
136                 }
137                 return fields;
138             }
139         },
140         BYTE("byte") {
141             @Override
142             public Byte parse(Object value, boolean coerce) {
143                 double doubleValue = objectToDouble(value);
144                 if (doubleValue &lt; Byte.MIN_VALUE || doubleValue &gt; Byte.MAX_VALUE) {
145                     throw new IllegalArgumentException("Value [" + value + "] is out of range for a byte");
146                 }
147                 if (!coerce &amp;&amp; doubleValue % 1 != 0) {
148                     throw new IllegalArgumentException("Value [" + value + "] has a decimal part");
149                 }
150                 if (value instanceof Number) {
151                     return ((Number) value).byteValue();
152                 }
153                 return (byte) doubleValue;
154             }
155 <a name="5"></a>
156             @Override
157             public Number parsePoint(byte[] value) {
158                 return <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>INTEGER.parsePoint(value).byteValue();
159             }
160             @Override
161             public Short parse(XContentParser parser, boolean coerce) throws IOException {</b></font>
162                 int value = parser.intValue(coerce);
163                 if (value &lt; Byte.MIN_VALUE || value &gt; Byte.MAX_VALUE) {
164                     throw new IllegalArgumentException("Value [" + value + "] is out of range for a byte");
165                 }
166                 return (short) value;
167             }
168             @Override
169             public List&lt;Field&gt; createFields(String name, Number value,
170                                             boolean indexed, boolean docValued, boolean stored) {
171                 return INTEGER.createFields(name, value, indexed, docValued, stored);
172             }
173             @Override
174             Number valueForSearch(Number value) {
175                 return value.byteValue();
176             }
177         },
178         SHORT("short") {
179             @Override
180             public Short parse(Object value, boolean coerce) {
181                 double doubleValue = objectToDouble(value);
182                 if (doubleValue &lt; Short.MIN_VALUE || doubleValue &gt; Short.MAX_VALUE) {
183                     throw new IllegalArgumentException("Value [" + value + "] is out of range for a short");
184                 }
185                 if (!coerce &amp;&amp; doubleValue % 1 != 0) {
186                     throw new IllegalArgumentException("Value [" + value + "] has a decimal part");
187                 }
188                 if (value instanceof Number) {
189                     return ((Number) value).shortValue();
190                 }
191                 return (short) doubleValue;
192             }
193             @Override
194             public Number parsePoint(byte[] value) {
195                 return INTEGER.parsePoint(value).shortValue();
196             }
197             @Override
198             public Short parse(XContentParser parser, boolean coerce) throws IOException {
199                 return parser.shortValue(coerce);
200             }
201             @Override
202             public List&lt;Field&gt; createFields(String name, Number value,
203                                             boolean indexed, boolean docValued, boolean stored) {
204                 return INTEGER.createFields(name, value, indexed, docValued, stored);
205             }
206             @Override
207             Number valueForSearch(Number value) {
208                 return value.shortValue();
209             }
210         },
211         INTEGER("integer") {
212             @Override
213             public Integer parse(Object value, boolean coerce) {
214                 double doubleValue = objectToDouble(value);
215                 if (doubleValue &lt; Integer.MIN_VALUE || doubleValue &gt; Integer.MAX_VALUE) {
216                     throw new IllegalArgumentException("Value [" + value + "] is out of range for an integer");
217                 }
218                 if (!coerce &amp;&amp; doubleValue % 1 != 0) {
219                     throw new IllegalArgumentException("Value [" + value + "] has a decimal part");
220                 }
221                 if (value instanceof Number) {
222                     return ((Number) value).intValue();
223                 }
224                 return (int) doubleValue;
225             }
226             @Override
227             public Number parsePoint(byte[] value) {
228                 return IntPoint.decodeDimension(value, 0);
229             }
230             @Override
231             public Integer parse(XContentParser parser, boolean coerce) throws IOException {
232                 return parser.intValue(coerce);
233             }
234             @Override
235             public List&lt;Field&gt; createFields(String name, Number value,
236                                             boolean indexed, boolean docValued, boolean stored) {
237                 List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
238                 if (indexed) {
239                     fields.add(new IntPoint(name, value.intValue()));
240                 }
241                 if (docValued) {
242                     fields.add(new SortedNumericDocValuesField(name, value.intValue()));
243                 }
244                 if (stored) {
245                     fields.add(new StoredField(name, value.intValue()));
246                 }
247                 return fields;
248             }
249         },
250         LONG("long") {
251             @Override
252             public Long parse(Object value, boolean coerce) {
253                 if (value instanceof Long) {
254                     return (Long)value;
255                 }
256                 double doubleValue = objectToDouble(value);
257                 if (doubleValue &lt; Long.MIN_VALUE || doubleValue &gt; Long.MAX_VALUE) {
258                     throw new IllegalArgumentException("Value [" + value + "] is out of range for a long");
259                 }
260                 if (!coerce &amp;&amp; doubleValue % 1 != 0) {
261                     throw new IllegalArgumentException("Value [" + value + "] has a decimal part");
262                 }
263                 String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();
264                 return Numbers.toLong(stringValue, coerce);
265             }
266             @Override
267             public Number parsePoint(byte[] value) {
268                 return LongPoint.decodeDimension(value, 0);
269             }
270             @Override
271             public Long parse(XContentParser parser, boolean coerce) throws IOException {
272                 return parser.longValue(coerce);
273             }
274             @Override
275             public List&lt;Field&gt; createFields(String name, Number value,
276                                             boolean indexed, boolean docValued, boolean stored) {
277                 List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
278                 if (indexed) {
279                     fields.add(new LongPoint(name, value.longValue()));
280                 }
281                 if (docValued) {
282                     fields.add(new SortedNumericDocValuesField(name, value.longValue()));
283                 }
284                 if (stored) {
285                     fields.add(new StoredField(name, value.longValue()));
286                 }
287                 return fields;
288             }
289         };
290         private final String name;
291         NumberType(String name) {
292             this.name = name;
293         }
294         public final String typeName() {
295             return name;
296         }
297         public abstract Number parse(XContentParser parser, boolean coerce) throws IOException;
298         public abstract Number parse(Object value, boolean coerce);
299         public abstract Number parsePoint(byte[] value);
300         public abstract List&lt;Field&gt; createFields(String name,
301                                                  Number value,
302                                                  boolean indexed,
303                                                  boolean docValued,
304                                                  boolean stored);
305         Number valueForSearch(Number value) {
306             return value;
307         }
308         boolean hasDecimalPart(Object number) {
309             if (number instanceof Number) {
310                 double doubleValue = ((Number) number).doubleValue();
311                 return doubleValue % 1 != 0;
312             }
313             if (number instanceof BytesRef) {
314                 number = ((BytesRef) number).utf8ToString();
315             }
316             if (number instanceof String) {
317                 return Double.parseDouble((String) number) % 1 != 0;
318             }
319             return false;
320         }
321         double signum(Object value) {
322             if (value instanceof Number) {
323                 double doubleValue = ((Number) value).doubleValue();
324                 return Math.signum(doubleValue);
325             }
326             if (value instanceof BytesRef) {
327                 value = ((BytesRef) value).utf8ToString();
328             }
329             return Math.signum(Double.parseDouble(value.toString()));
330         }
331         private static double objectToDouble(Object value) {
332             double doubleValue;
333             if (value instanceof Number) {
334                 doubleValue = ((Number) value).doubleValue();
335             } else if (value instanceof BytesRef) {
336                 doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString());
337             } else {
338                 doubleValue = Double.parseDouble(value.toString());
339             }
340             return doubleValue;
341         }
342     }
343     public static final class NumberFieldType extends MappedFieldType {
344         private final NumberType type;
345         public NumberFieldType(String name, NumberType type, boolean isSearchable, boolean hasDocValues) {
346             super(name, isSearchable, hasDocValues);
347             this.type = Objects.requireNonNull(type);
348             this.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);                 this.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);            }
349         public NumberFieldType(String name, NumberType type) {
350             this(name, type, true, true);
351         }
352         @Override
353         public String typeName() {
354             return type.name;
355         }
356     }
357     private NumberFieldMapper(
358             String simpleName,
359             Integer position,
360             @Nullable String defaultExpression,
361             FieldType fieldType,
362             MappedFieldType mappedFieldType,
363             Settings indexSettings,
364             MultiFields multiFields,
365             CopyTo copyTo) {
366         super(simpleName, position, defaultExpression, fieldType, mappedFieldType, indexSettings, multiFields, copyTo);
367     }
368     @Override
369     public NumberFieldType fieldType() {
370         return (NumberFieldType) super.fieldType();
371     }
372     @Override
373     protected String contentType() {
374         return fieldType().type.typeName();
375     }
376     @Override
377     protected NumberFieldMapper clone() {
378         return (NumberFieldMapper) super.clone();
379     }
380     @Override
381     protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
382         XContentParser parser = context.parser();
383         Object value;
384         Number numericValue = null;
385         if (context.externalValueSet()) {
386             value = context.externalValue();
387         } else if (parser.currentToken() == Token.VALUE_NULL) {
388             value = null;
389         } else if (parser.currentToken() == Token.VALUE_STRING
390                 &amp;&amp; parser.textLength() == 0) {
391             value = null;
392         } else {
393             numericValue = fieldType().type.parse(parser, true);
394             value = numericValue;
395         }
396         if (value == null) {
397             return;
398         }
399         if (numericValue == null) {
400             numericValue = fieldType().type.parse(value, true);
401         }
402         boolean docValued = fieldType().hasDocValues();
403         boolean stored = fieldType.stored();
404         fields.addAll(fieldType().type.createFields(
405             fieldType().name(),
406             numericValue,
407             fieldType().isSearchable(),
408             docValued,
409             stored
410         ));
411         if (docValued == false &amp;&amp; (stored || fieldType().isSearchable())) {
412             createFieldNamesField(context, fields);
413         }
414     }
415     @Override
416     protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts) {
417         NumberFieldMapper m = (NumberFieldMapper) other;
418         if (fieldType().type != m.fieldType().type) {
419             conflicts.add(
420                 "mapper [" + name() + "] cannot be changed from type ["
421                 + fieldType().type.name
422                 + "] to ["
423                 + m.fieldType().type.name + "]"
424             );
425         }
426     }
427 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
