<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for MutableClassToInstanceMap.java &amp; Cut_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MutableClassToInstanceMap.java &amp; Cut_1.java
      </h3>
<h1 align="center">
        8.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MutableClassToInstanceMap.java (16.591928%)<th>Cut_1.java (5.799373%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(73-81)<td><a href="#" name="0">(204-212)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(176-183)<td><a href="#" name="1">(36-43)</a><td align="center"><font color="#e50000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(83-89)<td><a href="#" name="2">(329-335)</a><td align="center"><font color="#e50000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(26-48)<td><a href="#" name="3">(17-35)</a><td align="center"><font color="#e50000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MutableClassToInstanceMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.primitives.Primitives;
<a name="3"></a>import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.Serializable;
import java.util.HashMap;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A mutable class-to-instance map backed by an arbitrary user-provided map. See also {@link
 * ImmutableClassToInstanceMap}.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#classtoinstancemap"&gt;{@code
 * ClassToInstanceMap}&lt;/a&gt;.
 *
 * &lt;p&gt;This implementation &lt;i&gt;does&lt;/i&gt; support null values, despite how it is annotated; see
 * discussion at {@link ClassToInstanceMap}.
 *
 * @author Kevin Bourrillion
 * @since 2.0
 */
@GwtIncompatible
@</b></font>SuppressWarnings("serial") // using writeReplace instead of standard serialization
@ElementTypesAreNonnullByDefault
public final class MutableClassToInstanceMap&lt;B&gt; extends ForwardingMap&lt;Class&lt;? extends B&gt;, B&gt;
    implements ClassToInstanceMap&lt;B&gt;, Serializable {

  /**
   * Returns a new {@code MutableClassToInstanceMap} instance backed by a {@link HashMap} using the
   * default initial capacity and load factor.
   */
  public static &lt;B&gt; MutableClassToInstanceMap&lt;B&gt; create() {
    return new MutableClassToInstanceMap&lt;B&gt;(new HashMap&lt;Class&lt;? extends B&gt;, B&gt;());
  }

  /**
   * Returns a new {@code MutableClassToInstanceMap} instance backed by a given empty {@code
   * backingMap}. The caller surrenders control of the backing map, and thus should not allow any
   * direct references to it to remain accessible.
   */
  public static &lt;B&gt; MutableClassToInstanceMap&lt;B&gt; create(Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap) {
    return new MutableClassToInstanceMap&lt;B&gt;(backingMap);
  }

<a name="0"></a>  private final Map&lt;Class&lt;? extends B&gt;, B&gt; delegate;

  private MutableClassToInstanceMap(Map&lt;Class&lt;? extends B&gt;, B&gt; delegate) {
    this.delegate = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>checkNotNull(delegate);
  }

  @Override
  protected Map&lt;Class&lt;? extends B&gt;, B&gt; delegate() {
    return delegate;
  }
<a name="2"></a>
  static &lt;B&gt; E</b></font>ntry&lt;Class&lt;? extends B&gt;, B&gt; checkedEntry(final Entry&lt;Class&lt;? extends B&gt;, B&gt; entry) {
    return new ForwardingMapEntry&lt;Class&lt;? extends B&gt;, B&gt;() {
      <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
      protected Entry&lt;Class&lt;? extends B&gt;, B&gt; delegate() {
        return entry;
      }

      @Override
      public B setValue(B value</b></font>) {
        return super.setValue(cast(getKey(), value));
      }
    };
  }

  @Override
  public Set&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; entrySet() {
    return new ForwardingSet&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt;() {

      @Override
      protected Set&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; delegate() {
        return MutableClassToInstanceMap.this.delegate().entrySet();
      }

      @Override
      public Iterator&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; iterator() {
        return new TransformedIterator&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;, Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt;(
            delegate().iterator()) {
          @Override
          Entry&lt;Class&lt;? extends B&gt;, B&gt; transform(Entry&lt;Class&lt;? extends B&gt;, B&gt; from) {
            return checkedEntry(from);
          }
        };
      }

      @Override
      public Object[] toArray() {
        /*
         * standardToArray returns `@Nullable Object[]` rather than `Object[]` but only because it
         * can be used with collections that may contain null. This collection is a collection of
         * non-null Entry objects (Entry objects that might contain null values but are not
         * themselves null), so we can treat it as a plain `Object[]`.
         */
        @SuppressWarnings("nullness")
        Object[] result = standardToArray();
        return result;
      }

      @Override
      @SuppressWarnings("nullness") // b/192354773 in our checker affects toArray declarations
      public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
        return standardToArray(array);
      }
    };
  }

  @Override
  @CanIgnoreReturnValue
  @CheckForNull
  public B put(Class&lt;? extends B&gt; key, B value) {
    return super.put(key, cast(key, value));
  }

  @Override
  public void putAll(Map&lt;? extends Class&lt;? extends B&gt;, ? extends B&gt; map) {
    Map&lt;Class&lt;? extends B&gt;, B&gt; copy = new LinkedHashMap&lt;&gt;(map);
    for (Entry&lt;? extends Class&lt;? extends B&gt;, B&gt; entry : copy.entrySet()) {
      cast(entry.getKey(), entry.getValue());
    }
    super.putAll(copy);
  }

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public &lt;T extends B&gt; T putInstance(Class&lt;T&gt; type, T value) {
    return cast(type, put(type, value));
  }

  @Override
  @CheckForNull
  public &lt;T extends B&gt; T getInstance(Class&lt;T&gt; type) {
    return cast(type, get(type));
  }

  @CanIgnoreReturnValue
  @CheckForNull
  private static &lt;B, T extends B&gt; T cast(Class&lt;T&gt; type, @CheckForNull B value) {
    return Primitives.wrap(type).cast(value);
  }

  private Object writeReplace() {
    return new SerializedForm(delegate());
<a name="1"></a>  }

  /** Serialized form of the map, to avoid serializing the constraint. */
  private static final class SerializedForm&lt;<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>B&gt; implements Serializable {
    private final Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap;

    SerializedForm(Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap) {
      this.backingMap = backingMap;
    }

    Object read</b></font>Resolve() {
      return create(backingMap);
    }

    private static final long serialVersionUID = 0;
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Cut_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<a name="3"></a>
package com.google.common.collect;

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.primitives.Booleans;
import java.io.Serializable;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;

/**
 * Implementation detail for the internal structure of {@link Range} instances. Represents a unique
 * way of "cutting" a "number line" (actually of instances of type {@code C}, not necessarily
 * "numbers") into two sections; this can be done below a certain value, above a certain value,
 * below all values or above all values. With this object defined in this way, an interval can
 * always be represented by a pair of {@code Cut} instances.
 *
 * @author Kevin Bourrillion
<a name="1"></a> */
@GwtCompatible
@</b></font>ElementTypesAreNonnullByDefault
abstract class Cut&lt;<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>C extends Comparable&gt; implements Comparable&lt;Cut&lt;C&gt;&gt;, Serializable {
  final C endpoint;

  Cut(C endpoint) {
    this.endpoint = endpoint;
  }

  abstract b</b></font>oolean isLessThan(C value);

  abstract BoundType typeAsLowerBound();

  abstract BoundType typeAsUpperBound();

  abstract Cut&lt;C&gt; withLowerBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain);

  abstract Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain);

  abstract void describeAsLowerBound(StringBuilder sb);

  abstract void describeAsUpperBound(StringBuilder sb);

  @CheckForNull
  abstract C leastValueAbove(DiscreteDomain&lt;C&gt; domain);

  @CheckForNull
  abstract C greatestValueBelow(DiscreteDomain&lt;C&gt; domain);

  /*
   * The canonical form is a BelowValue cut whenever possible, otherwise ABOVE_ALL, or
   * (only in the case of types that are unbounded below) BELOW_ALL.
   */
  Cut&lt;C&gt; canonical(DiscreteDomain&lt;C&gt; domain) {
    return this;
  }

  // note: overridden by {BELOW,ABOVE}_ALL
  @Override
  public int compareTo(Cut&lt;C&gt; that) {
    if (that == belowAll()) {
      return 1;
    }
    if (that == aboveAll()) {
      return -1;
    }
    int result = Range.compareOrThrow(endpoint, that.endpoint);
    if (result != 0) {
      return result;
    }
    // same value. below comes before above
    return Booleans.compare(this instanceof AboveValue, that instanceof AboveValue);
  }

  C endpoint() {
    return endpoint;
  }

  @SuppressWarnings("unchecked") // catching CCE
  @Override
  public boolean equals(@CheckForNull Object obj) {
    if (obj instanceof Cut) {
      // It might not really be a Cut&lt;C&gt;, but we'll catch a CCE if it's not
      Cut&lt;C&gt; that = (Cut&lt;C&gt;) obj;
      try {
        int compareResult = compareTo(that);
        return compareResult == 0;
      } catch (ClassCastException wastNotComparableToOurType) {
        return false;
      }
    }
    return false;
  }

  // Prevent "missing hashCode" warning by explicitly forcing subclasses implement it
  @Override
  public abstract int hashCode();

  /*
   * The implementation neither produces nor consumes any non-null instance of type C, so
   * casting the type parameter is safe.
   */
  @SuppressWarnings("unchecked")
  static &lt;C extends Comparable&gt; Cut&lt;C&gt; belowAll() {
    return (Cut&lt;C&gt;) BelowAll.INSTANCE;
  }

  private static final long serialVersionUID = 0;

  private static final class BelowAll extends Cut&lt;Comparable&lt;?&gt;&gt; {
    private static final BelowAll INSTANCE = new BelowAll();

    private BelowAll() {
      /*
       * No code ever sees this bogus value for `endpoint`: This class overrides both methods that
       * use the `endpoint` field, compareTo() and endpoint(). Additionally, the main implementation
       * of Cut.compareTo checks for belowAll before reading accessing `endpoint` on another Cut
       * instance.
       */
      super("");
    }

    @Override
    Comparable&lt;?&gt; endpoint() {
      throw new IllegalStateException("range unbounded on this side");
    }

    @Override
    boolean isLessThan(Comparable&lt;?&gt; value) {
      return true;
    }

    @Override
    BoundType typeAsLowerBound() {
      throw new IllegalStateException();
    }

    @Override
    BoundType typeAsUpperBound() {
      throw new AssertionError("this statement should be unreachable");
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withLowerBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new IllegalStateException();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withUpperBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError("this statement should be unreachable");
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append("(-\u221e");
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      throw new AssertionError();
    }

    @Override
    Comparable&lt;?&gt; leastValueAbove(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      return domain.minValue();
    }

    @Override
    Comparable&lt;?&gt; greatestValueBelow(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; canonical(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      try {
        return Cut.&lt;Comparable&lt;?&gt;&gt;belowValue(domain.minValue());
      } catch (NoSuchElementException e) {
        return this;
      }
    }

    @Override
    public int compareTo(Cut&lt;Comparable&lt;?&gt;&gt; o) {
      return (o == this) ? 0 : -1;
    }
<a name="0"></a>
    @Override
    public int hashCode() {
      return <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>System.identityHashCode(this);
    }

    @Override
    public String toString() {
      return "-\u221e";
    }

    private Obj</b></font>ect readResolve() {
      return INSTANCE;
    }

    private static final long serialVersionUID = 0;
  }

  /*
   * The implementation neither produces nor consumes any non-null instance of
   * type C, so casting the type parameter is safe.
   */
  @SuppressWarnings("unchecked")
  static &lt;C extends Comparable&gt; Cut&lt;C&gt; aboveAll() {
    return (Cut&lt;C&gt;) AboveAll.INSTANCE;
  }

  private static final class AboveAll extends Cut&lt;Comparable&lt;?&gt;&gt; {
    private static final AboveAll INSTANCE = new AboveAll();

    private AboveAll() {
      // For discussion of "", see BelowAll.
      super("");
    }

    @Override
    Comparable&lt;?&gt; endpoint() {
      throw new IllegalStateException("range unbounded on this side");
    }

    @Override
    boolean isLessThan(Comparable&lt;?&gt; value) {
      return false;
    }

    @Override
    BoundType typeAsLowerBound() {
      throw new AssertionError("this statement should be unreachable");
    }

    @Override
    BoundType typeAsUpperBound() {
      throw new IllegalStateException();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withLowerBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError("this statement should be unreachable");
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withUpperBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new IllegalStateException();
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      throw new AssertionError();
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append("+\u221e)");
    }

    @Override
    Comparable&lt;?&gt; leastValueAbove(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError();
    }

    @Override
    Comparable&lt;?&gt; greatestValueBelow(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      return domain.maxValue();
    }

    @Override
    public int compareTo(Cut&lt;Comparable&lt;?&gt;&gt; o) {
      return (o == this) ? 0 : 1;
    }

    @Override
    public int hashCode() {
      return System.identityHashCode(this);
    }

    @Override
    public String toString() {
      return "+\u221e";
    }

    private Object readResolve() {
      return INSTANCE;
    }

    private static final long serialVersionUID = 0;
  }

  static &lt;C extends Comparable&gt; Cut&lt;C&gt; belowValue(C endpoint) {
    return new BelowValue&lt;&gt;(endpoint);
  }

  private static final class BelowValue&lt;C extends Comparable&gt; extends Cut&lt;C&gt; {
    BelowValue(C endpoint) {
      super(checkNotNull(endpoint));
    }

    @Override
    boolean isLessThan(C value) {
      return Range.compareOrThrow(endpoint, value) &lt;= 0;
    }

    @Override
    BoundType typeAsLowerBound() {
<a name="2"></a>      return BoundType.CLOSED;
    }

    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
    BoundType typeAsUpperBound() {
      return BoundType.OPEN;
    }

    @Override
    Cut&lt;C&gt; withLowerBoundType(BoundType boundType</b></font>, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case CLOSED:
          return this;
        case OPEN:
          C previous = domain.previous(endpoint);
          return (previous == null) ? Cut.&lt;C&gt;belowAll() : new AboveValue&lt;C&gt;(previous);
        default:
          throw new AssertionError();
      }
    }

    @Override
    Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case CLOSED:
          C previous = domain.previous(endpoint);
          return (previous == null) ? Cut.&lt;C&gt;aboveAll() : new AboveValue&lt;C&gt;(previous);
        case OPEN:
          return this;
        default:
          throw new AssertionError();
      }
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append('[').append(endpoint);
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append(endpoint).append(')');
    }

    @Override
    C leastValueAbove(DiscreteDomain&lt;C&gt; domain) {
      return endpoint;
    }

    @Override
    @CheckForNull
    C greatestValueBelow(DiscreteDomain&lt;C&gt; domain) {
      return domain.previous(endpoint);
    }

    @Override
    public int hashCode() {
      return endpoint.hashCode();
    }

    @Override
    public String toString() {
      return "\\" + endpoint + "/";
    }

    private static final long serialVersionUID = 0;
  }

  static &lt;C extends Comparable&gt; Cut&lt;C&gt; aboveValue(C endpoint) {
    return new AboveValue&lt;&gt;(endpoint);
  }

  private static final class AboveValue&lt;C extends Comparable&gt; extends Cut&lt;C&gt; {
    AboveValue(C endpoint) {
      super(checkNotNull(endpoint));
    }

    @Override
    boolean isLessThan(C value) {
      return Range.compareOrThrow(endpoint, value) &lt; 0;
    }

    @Override
    BoundType typeAsLowerBound() {
      return BoundType.OPEN;
    }

    @Override
    BoundType typeAsUpperBound() {
      return BoundType.CLOSED;
    }

    @Override
    Cut&lt;C&gt; withLowerBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case OPEN:
          return this;
        case CLOSED:
          C next = domain.next(endpoint);
          return (next == null) ? Cut.&lt;C&gt;belowAll() : belowValue(next);
        default:
          throw new AssertionError();
      }
    }

    @Override
    Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case OPEN:
          C next = domain.next(endpoint);
          return (next == null) ? Cut.&lt;C&gt;aboveAll() : belowValue(next);
        case CLOSED:
          return this;
        default:
          throw new AssertionError();
      }
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append('(').append(endpoint);
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append(endpoint).append(']');
    }

    @Override
    @CheckForNull
    C leastValueAbove(DiscreteDomain&lt;C&gt; domain) {
      return domain.next(endpoint);
    }

    @Override
    C greatestValueBelow(DiscreteDomain&lt;C&gt; domain) {
      return endpoint;
    }

    @Override
    Cut&lt;C&gt; canonical(DiscreteDomain&lt;C&gt; domain) {
      C next = leastValueAbove(domain);
      return (next != null) ? belowValue(next) : Cut.&lt;C&gt;aboveAll();
    }

    @Override
    public int hashCode() {
      return ~endpoint.hashCode();
    }

    @Override
    public String toString() {
      return "/" + endpoint + "\\";
    }

    private static final long serialVersionUID = 0;
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
