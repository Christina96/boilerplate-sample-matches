<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for MutableClassToInstanceMap.java & Cut_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for MutableClassToInstanceMap.java & Cut_1.java
      </h3>
      <h1 align="center">
        8.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>MutableClassToInstanceMap.java (16.591928%)<TH>Cut_1.java (5.799373%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match833601-0.html#0',2,'match833601-1.html#0',3)" NAME="0">(73-81)<TD><A HREF="javascript:ZweiFrames('match833601-0.html#0',2,'match833601-1.html#0',3)" NAME="0">(204-212)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match833601-0.html#1',2,'match833601-1.html#1',3)" NAME="1">(176-183)<TD><A HREF="javascript:ZweiFrames('match833601-0.html#1',2,'match833601-1.html#1',3)" NAME="1">(36-43)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match833601-0.html#2',2,'match833601-1.html#2',3)" NAME="2">(83-89)<TD><A HREF="javascript:ZweiFrames('match833601-0.html#2',2,'match833601-1.html#2',3)" NAME="2">(329-335)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match833601-0.html#3',2,'match833601-1.html#3',3)" NAME="3">(26-48)<TD><A HREF="javascript:ZweiFrames('match833601-0.html#3',2,'match833601-1.html#3',3)" NAME="3">(17-35)</A><TD ALIGN=center><FONT COLOR="#e50000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MutableClassToInstanceMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.primitives.Primitives;
<A NAME="3"></A>import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.Serializable;
import java.util.HashMap;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match833601-1.html#3',3,'match833601-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A mutable class-to-instance map backed by an arbitrary user-provided map. See also {@link
 * ImmutableClassToInstanceMap}.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/NewCollectionTypesExplained#classtoinstancemap&quot;&gt;{@code
 * ClassToInstanceMap}&lt;/a&gt;.
 *
 * &lt;p&gt;This implementation &lt;i&gt;does&lt;/i&gt; support null values, despite how it is annotated; see
 * discussion at {@link ClassToInstanceMap}.
 *
 * @author Kevin Bourrillion
 * @since 2.0
 */
@GwtIncompatible
@</B></FONT>SuppressWarnings(&quot;serial&quot;) // using writeReplace instead of standard serialization
@ElementTypesAreNonnullByDefault
public final class MutableClassToInstanceMap&lt;B&gt; extends ForwardingMap&lt;Class&lt;? extends B&gt;, B&gt;
    implements ClassToInstanceMap&lt;B&gt;, Serializable {

  /**
   * Returns a new {@code MutableClassToInstanceMap} instance backed by a {@link HashMap} using the
   * default initial capacity and load factor.
   */
  public static &lt;B&gt; MutableClassToInstanceMap&lt;B&gt; create() {
    return new MutableClassToInstanceMap&lt;B&gt;(new HashMap&lt;Class&lt;? extends B&gt;, B&gt;());
  }

  /**
   * Returns a new {@code MutableClassToInstanceMap} instance backed by a given empty {@code
   * backingMap}. The caller surrenders control of the backing map, and thus should not allow any
   * direct references to it to remain accessible.
   */
  public static &lt;B&gt; MutableClassToInstanceMap&lt;B&gt; create(Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap) {
    return new MutableClassToInstanceMap&lt;B&gt;(backingMap);
  }

<A NAME="0"></A>  private final Map&lt;Class&lt;? extends B&gt;, B&gt; delegate;

  private MutableClassToInstanceMap(Map&lt;Class&lt;? extends B&gt;, B&gt; delegate) {
    this.delegate = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match833601-1.html#0',3,'match833601-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkNotNull(delegate);
  }

  @Override
  protected Map&lt;Class&lt;? extends B&gt;, B&gt; delegate() {
    return delegate;
  }
<A NAME="2"></A>
  static &lt;B&gt; E</B></FONT>ntry&lt;Class&lt;? extends B&gt;, B&gt; checkedEntry(final Entry&lt;Class&lt;? extends B&gt;, B&gt; entry) {
    return new ForwardingMapEntry&lt;Class&lt;? extends B&gt;, B&gt;() {
      <FONT color="#980517"><A HREF="javascript:ZweiFrames('match833601-1.html#2',3,'match833601-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
      protected Entry&lt;Class&lt;? extends B&gt;, B&gt; delegate() {
        return entry;
      }

      @Override
      public B setValue(B value</B></FONT>) {
        return super.setValue(cast(getKey(), value));
      }
    };
  }

  @Override
  public Set&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; entrySet() {
    return new ForwardingSet&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt;() {

      @Override
      protected Set&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; delegate() {
        return MutableClassToInstanceMap.this.delegate().entrySet();
      }

      @Override
      public Iterator&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt; iterator() {
        return new TransformedIterator&lt;Entry&lt;Class&lt;? extends B&gt;, B&gt;, Entry&lt;Class&lt;? extends B&gt;, B&gt;&gt;(
            delegate().iterator()) {
          @Override
          Entry&lt;Class&lt;? extends B&gt;, B&gt; transform(Entry&lt;Class&lt;? extends B&gt;, B&gt; from) {
            return checkedEntry(from);
          }
        };
      }

      @Override
      public Object[] toArray() {
        /*
         * standardToArray returns `@Nullable Object[]` rather than `Object[]` but only because it
         * can be used with collections that may contain null. This collection is a collection of
         * non-null Entry objects (Entry objects that might contain null values but are not
         * themselves null), so we can treat it as a plain `Object[]`.
         */
        @SuppressWarnings(&quot;nullness&quot;)
        Object[] result = standardToArray();
        return result;
      }

      @Override
      @SuppressWarnings(&quot;nullness&quot;) // b/192354773 in our checker affects toArray declarations
      public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
        return standardToArray(array);
      }
    };
  }

  @Override
  @CanIgnoreReturnValue
  @CheckForNull
  public B put(Class&lt;? extends B&gt; key, B value) {
    return super.put(key, cast(key, value));
  }

  @Override
  public void putAll(Map&lt;? extends Class&lt;? extends B&gt;, ? extends B&gt; map) {
    Map&lt;Class&lt;? extends B&gt;, B&gt; copy = new LinkedHashMap&lt;&gt;(map);
    for (Entry&lt;? extends Class&lt;? extends B&gt;, B&gt; entry : copy.entrySet()) {
      cast(entry.getKey(), entry.getValue());
    }
    super.putAll(copy);
  }

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public &lt;T extends B&gt; T putInstance(Class&lt;T&gt; type, T value) {
    return cast(type, put(type, value));
  }

  @Override
  @CheckForNull
  public &lt;T extends B&gt; T getInstance(Class&lt;T&gt; type) {
    return cast(type, get(type));
  }

  @CanIgnoreReturnValue
  @CheckForNull
  private static &lt;B, T extends B&gt; T cast(Class&lt;T&gt; type, @CheckForNull B value) {
    return Primitives.wrap(type).cast(value);
  }

  private Object writeReplace() {
    return new SerializedForm(delegate());
<A NAME="1"></A>  }

  /** Serialized form of the map, to avoid serializing the constraint. */
  private static final class SerializedForm&lt;<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match833601-1.html#1',3,'match833601-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>B&gt; implements Serializable {
    private final Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap;

    SerializedForm(Map&lt;Class&lt;? extends B&gt;, B&gt; backingMap) {
      this.backingMap = backingMap;
    }

    Object read</B></FONT>Resolve() {
      return create(backingMap);
    }

    private static final long serialVersionUID = 0;
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Cut_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<A NAME="3"></A>
package com.google.common.collect;

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match833601-0.html#3',2,'match833601-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.primitives.Booleans;
import java.io.Serializable;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;

/**
 * Implementation detail for the internal structure of {@link Range} instances. Represents a unique
 * way of &quot;cutting&quot; a &quot;number line&quot; (actually of instances of type {@code C}, not necessarily
 * &quot;numbers&quot;) into two sections; this can be done below a certain value, above a certain value,
 * below all values or above all values. With this object defined in this way, an interval can
 * always be represented by a pair of {@code Cut} instances.
 *
 * @author Kevin Bourrillion
<A NAME="1"></A> */
@GwtCompatible
@</B></FONT>ElementTypesAreNonnullByDefault
abstract class Cut&lt;<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match833601-0.html#1',2,'match833601-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>C extends Comparable&gt; implements Comparable&lt;Cut&lt;C&gt;&gt;, Serializable {
  final C endpoint;

  Cut(C endpoint) {
    this.endpoint = endpoint;
  }

  abstract b</B></FONT>oolean isLessThan(C value);

  abstract BoundType typeAsLowerBound();

  abstract BoundType typeAsUpperBound();

  abstract Cut&lt;C&gt; withLowerBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain);

  abstract Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain);

  abstract void describeAsLowerBound(StringBuilder sb);

  abstract void describeAsUpperBound(StringBuilder sb);

  @CheckForNull
  abstract C leastValueAbove(DiscreteDomain&lt;C&gt; domain);

  @CheckForNull
  abstract C greatestValueBelow(DiscreteDomain&lt;C&gt; domain);

  /*
   * The canonical form is a BelowValue cut whenever possible, otherwise ABOVE_ALL, or
   * (only in the case of types that are unbounded below) BELOW_ALL.
   */
  Cut&lt;C&gt; canonical(DiscreteDomain&lt;C&gt; domain) {
    return this;
  }

  // note: overridden by {BELOW,ABOVE}_ALL
  @Override
  public int compareTo(Cut&lt;C&gt; that) {
    if (that == belowAll()) {
      return 1;
    }
    if (that == aboveAll()) {
      return -1;
    }
    int result = Range.compareOrThrow(endpoint, that.endpoint);
    if (result != 0) {
      return result;
    }
    // same value. below comes before above
    return Booleans.compare(this instanceof AboveValue, that instanceof AboveValue);
  }

  C endpoint() {
    return endpoint;
  }

  @SuppressWarnings(&quot;unchecked&quot;) // catching CCE
  @Override
  public boolean equals(@CheckForNull Object obj) {
    if (obj instanceof Cut) {
      // It might not really be a Cut&lt;C&gt;, but we'll catch a CCE if it's not
      Cut&lt;C&gt; that = (Cut&lt;C&gt;) obj;
      try {
        int compareResult = compareTo(that);
        return compareResult == 0;
      } catch (ClassCastException wastNotComparableToOurType) {
        return false;
      }
    }
    return false;
  }

  // Prevent &quot;missing hashCode&quot; warning by explicitly forcing subclasses implement it
  @Override
  public abstract int hashCode();

  /*
   * The implementation neither produces nor consumes any non-null instance of type C, so
   * casting the type parameter is safe.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;C extends Comparable&gt; Cut&lt;C&gt; belowAll() {
    return (Cut&lt;C&gt;) BelowAll.INSTANCE;
  }

  private static final long serialVersionUID = 0;

  private static final class BelowAll extends Cut&lt;Comparable&lt;?&gt;&gt; {
    private static final BelowAll INSTANCE = new BelowAll();

    private BelowAll() {
      /*
       * No code ever sees this bogus value for `endpoint`: This class overrides both methods that
       * use the `endpoint` field, compareTo() and endpoint(). Additionally, the main implementation
       * of Cut.compareTo checks for belowAll before reading accessing `endpoint` on another Cut
       * instance.
       */
      super(&quot;&quot;);
    }

    @Override
    Comparable&lt;?&gt; endpoint() {
      throw new IllegalStateException(&quot;range unbounded on this side&quot;);
    }

    @Override
    boolean isLessThan(Comparable&lt;?&gt; value) {
      return true;
    }

    @Override
    BoundType typeAsLowerBound() {
      throw new IllegalStateException();
    }

    @Override
    BoundType typeAsUpperBound() {
      throw new AssertionError(&quot;this statement should be unreachable&quot;);
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withLowerBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new IllegalStateException();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withUpperBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError(&quot;this statement should be unreachable&quot;);
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append(&quot;(-\u221e&quot;);
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      throw new AssertionError();
    }

    @Override
    Comparable&lt;?&gt; leastValueAbove(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      return domain.minValue();
    }

    @Override
    Comparable&lt;?&gt; greatestValueBelow(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; canonical(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      try {
        return Cut.&lt;Comparable&lt;?&gt;&gt;belowValue(domain.minValue());
      } catch (NoSuchElementException e) {
        return this;
      }
    }

    @Override
    public int compareTo(Cut&lt;Comparable&lt;?&gt;&gt; o) {
      return (o == this) ? 0 : -1;
    }
<A NAME="0"></A>
    @Override
    public int hashCode() {
      return <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match833601-0.html#0',2,'match833601-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>System.identityHashCode(this);
    }

    @Override
    public String toString() {
      return &quot;-\u221e&quot;;
    }

    private Obj</B></FONT>ect readResolve() {
      return INSTANCE;
    }

    private static final long serialVersionUID = 0;
  }

  /*
   * The implementation neither produces nor consumes any non-null instance of
   * type C, so casting the type parameter is safe.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;C extends Comparable&gt; Cut&lt;C&gt; aboveAll() {
    return (Cut&lt;C&gt;) AboveAll.INSTANCE;
  }

  private static final class AboveAll extends Cut&lt;Comparable&lt;?&gt;&gt; {
    private static final AboveAll INSTANCE = new AboveAll();

    private AboveAll() {
      // For discussion of &quot;&quot;, see BelowAll.
      super(&quot;&quot;);
    }

    @Override
    Comparable&lt;?&gt; endpoint() {
      throw new IllegalStateException(&quot;range unbounded on this side&quot;);
    }

    @Override
    boolean isLessThan(Comparable&lt;?&gt; value) {
      return false;
    }

    @Override
    BoundType typeAsLowerBound() {
      throw new AssertionError(&quot;this statement should be unreachable&quot;);
    }

    @Override
    BoundType typeAsUpperBound() {
      throw new IllegalStateException();
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withLowerBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError(&quot;this statement should be unreachable&quot;);
    }

    @Override
    Cut&lt;Comparable&lt;?&gt;&gt; withUpperBoundType(
        BoundType boundType, DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new IllegalStateException();
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      throw new AssertionError();
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append(&quot;+\u221e)&quot;);
    }

    @Override
    Comparable&lt;?&gt; leastValueAbove(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      throw new AssertionError();
    }

    @Override
    Comparable&lt;?&gt; greatestValueBelow(DiscreteDomain&lt;Comparable&lt;?&gt;&gt; domain) {
      return domain.maxValue();
    }

    @Override
    public int compareTo(Cut&lt;Comparable&lt;?&gt;&gt; o) {
      return (o == this) ? 0 : 1;
    }

    @Override
    public int hashCode() {
      return System.identityHashCode(this);
    }

    @Override
    public String toString() {
      return &quot;+\u221e&quot;;
    }

    private Object readResolve() {
      return INSTANCE;
    }

    private static final long serialVersionUID = 0;
  }

  static &lt;C extends Comparable&gt; Cut&lt;C&gt; belowValue(C endpoint) {
    return new BelowValue&lt;&gt;(endpoint);
  }

  private static final class BelowValue&lt;C extends Comparable&gt; extends Cut&lt;C&gt; {
    BelowValue(C endpoint) {
      super(checkNotNull(endpoint));
    }

    @Override
    boolean isLessThan(C value) {
      return Range.compareOrThrow(endpoint, value) &lt;= 0;
    }

    @Override
    BoundType typeAsLowerBound() {
<A NAME="2"></A>      return BoundType.CLOSED;
    }

    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match833601-0.html#2',2,'match833601-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    BoundType typeAsUpperBound() {
      return BoundType.OPEN;
    }

    @Override
    Cut&lt;C&gt; withLowerBoundType(BoundType boundType</B></FONT>, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case CLOSED:
          return this;
        case OPEN:
          C previous = domain.previous(endpoint);
          return (previous == null) ? Cut.&lt;C&gt;belowAll() : new AboveValue&lt;C&gt;(previous);
        default:
          throw new AssertionError();
      }
    }

    @Override
    Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case CLOSED:
          C previous = domain.previous(endpoint);
          return (previous == null) ? Cut.&lt;C&gt;aboveAll() : new AboveValue&lt;C&gt;(previous);
        case OPEN:
          return this;
        default:
          throw new AssertionError();
      }
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append('[').append(endpoint);
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append(endpoint).append(')');
    }

    @Override
    C leastValueAbove(DiscreteDomain&lt;C&gt; domain) {
      return endpoint;
    }

    @Override
    @CheckForNull
    C greatestValueBelow(DiscreteDomain&lt;C&gt; domain) {
      return domain.previous(endpoint);
    }

    @Override
    public int hashCode() {
      return endpoint.hashCode();
    }

    @Override
    public String toString() {
      return &quot;\\&quot; + endpoint + &quot;/&quot;;
    }

    private static final long serialVersionUID = 0;
  }

  static &lt;C extends Comparable&gt; Cut&lt;C&gt; aboveValue(C endpoint) {
    return new AboveValue&lt;&gt;(endpoint);
  }

  private static final class AboveValue&lt;C extends Comparable&gt; extends Cut&lt;C&gt; {
    AboveValue(C endpoint) {
      super(checkNotNull(endpoint));
    }

    @Override
    boolean isLessThan(C value) {
      return Range.compareOrThrow(endpoint, value) &lt; 0;
    }

    @Override
    BoundType typeAsLowerBound() {
      return BoundType.OPEN;
    }

    @Override
    BoundType typeAsUpperBound() {
      return BoundType.CLOSED;
    }

    @Override
    Cut&lt;C&gt; withLowerBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case OPEN:
          return this;
        case CLOSED:
          C next = domain.next(endpoint);
          return (next == null) ? Cut.&lt;C&gt;belowAll() : belowValue(next);
        default:
          throw new AssertionError();
      }
    }

    @Override
    Cut&lt;C&gt; withUpperBoundType(BoundType boundType, DiscreteDomain&lt;C&gt; domain) {
      switch (boundType) {
        case OPEN:
          C next = domain.next(endpoint);
          return (next == null) ? Cut.&lt;C&gt;aboveAll() : belowValue(next);
        case CLOSED:
          return this;
        default:
          throw new AssertionError();
      }
    }

    @Override
    void describeAsLowerBound(StringBuilder sb) {
      sb.append('(').append(endpoint);
    }

    @Override
    void describeAsUpperBound(StringBuilder sb) {
      sb.append(endpoint).append(']');
    }

    @Override
    @CheckForNull
    C leastValueAbove(DiscreteDomain&lt;C&gt; domain) {
      return domain.next(endpoint);
    }

    @Override
    C greatestValueBelow(DiscreteDomain&lt;C&gt; domain) {
      return endpoint;
    }

    @Override
    Cut&lt;C&gt; canonical(DiscreteDomain&lt;C&gt; domain) {
      C next = leastValueAbove(domain);
      return (next != null) ? belowValue(next) : Cut.&lt;C&gt;aboveAll();
    }

    @Override
    public int hashCode() {
      return ~endpoint.hashCode();
    }

    @Override
    public String toString() {
      return &quot;/&quot; + endpoint + &quot;\\&quot;;
    }

    private static final long serialVersionUID = 0;
  }
}
</PRE>
</div>
  </div>
</body>
</html>
