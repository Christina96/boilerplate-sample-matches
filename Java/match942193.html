<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableDoubleArray.java (14.61039%)<th>ClosingFuture.java (5.260082%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-81)<td><a href="#" name="0">(50-194)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(485-494)<td><a href="#" name="1">(601-610)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(518-526)<td><a href="#" name="2">(463-483)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(455-458)<td><a href="#" name="3">(831-834)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(426-435)<td><a href="#" name="4">(333-360)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(435-440)<td><a href="#" name="5">(694-699)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(252-261)<td><a href="#" name="6">(1136-1141)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(115-119)<td><a href="#" name="7">(565-580)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableDoubleArray.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.primitives;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.CheckReturnValue;
import com.google.errorprone.annotations.Immutable;
import java.io.Serializable;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.RandomAccess;
import javax.annotation.CheckForNull;
@Beta
@</b></font>GwtCompatible
@Immutable
@ElementTypesAreNonnullByDefault
public final class ImmutableDoubleArray implements Serializable {
  private static final ImmutableDoubleArray EMPTY = new ImmutableDoubleArray(new double[0]);
  public static ImmutableDoubleArray of() {
    return EMPTY;
  }
  public static ImmutableDoubleArray of(double e0) {
    return new ImmutableDoubleArray(new double[] {e0});
  }
  public static ImmutableDoubleArray of(double e0, double e1) {
    return new ImmutableDoubleArray(new double[] {e0, e1});
  }
  public static ImmutableDoubleArray of(double e0, double e1, double e2) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2});
  }
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3});
  }
<a name="7"></a>    public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3, double e4) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4});
  <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  public static ImmutableDoubleArray of(
      double e0, double e1, double e2, double e3, double e4, double e5</b></font>) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4, e5});
  }
  public static ImmutableDoubleArray of(double first, double... rest) {
    checkArgument(
        rest.length &lt;= Integer.MAX_VALUE - 1, "the total number of elements must fit in an int");
    double[] array = new double[rest.length + 1];
    array[0] = first;
    System.arraycopy(rest, 0, array, 1, rest.length);
    return new ImmutableDoubleArray(array);
  }
  public static ImmutableDoubleArray copyOf(double[] values) {
    return values.length == 0
        ? EMPTY
        : new ImmutableDoubleArray(Arrays.copyOf(values, values.length));
  }
  public static ImmutableDoubleArray copyOf(Collection&lt;Double&gt; values) {
    return values.isEmpty() ? EMPTY : new ImmutableDoubleArray(Doubles.toArray(values));
  }
  public static ImmutableDoubleArray copyOf(Iterable&lt;Double&gt; values) {
    if (values instanceof Collection) {
      return copyOf((Collection&lt;Double&gt;) values);
    }
    return builder().addAll(values).build();
  }
  public static Builder builder(int initialCapacity) {
    checkArgument(initialCapacity &gt;= 0, "Invalid initialCapacity: %s", initialCapacity);
    return new Builder(initialCapacity);
  }
  public static Builder builder() {
    return new Builder(10);
  }
  @CanIgnoreReturnValue
  public static final class Builder {
    private double[] array;
    private int count = 0; 
    Builder(int initialCapacity) {
      array = new double[initialCapacity];
    }
    public Builder add(double value) {
      ensureRoomFor(1);
      array[count] = value;
      count += 1;
      return this;
    }
    public Builder addAll(double[] values) {
      ensureRoomFor(values.length);
      System.arraycopy(values, 0, array, count, values.length);
      count += values.length;
      return this;
    }
    public Builder addAll(Iterable&lt;Double&gt; values) {
      if (values instanceof Collection) {
        return addAll((Collection&lt;Double&gt;) values);
      }
      for (Double value : values) {
        add(value);
      }
      return this;
    }
    public Builder addAll(Collection&lt;Double&gt; values) {
      ensureRoomFor(values.size());
<a name="6"></a>      for (Double value : values) {
        array[count++] = value;
      }
      <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
    }
    public Builder addAll(ImmutableDoubleArray values) {
      ensureRoomFor(values.length());
      System.arraycopy</b></font>(values.array, values.start, array, count, values.length());
      count += values.length();
      return this;
    }
    private void ensureRoomFor(int numberToAdd) {
      int newCount = count + numberToAdd;       if (newCount &gt; array.length) {
        array = Arrays.copyOf(array, expandedCapacity(array.length, newCount));
      }
    }
    private static int expandedCapacity(int oldCapacity, int minCapacity) {
      if (minCapacity &lt; 0) {
        throw new AssertionError("cannot store more than MAX_VALUE elements");
      }
      int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) + 1;
      if (newCapacity &lt; minCapacity) {
        newCapacity = Integer.highestOneBit(minCapacity - 1) &lt;&lt; 1;
      }
      if (newCapacity &lt; 0) {
        newCapacity = Integer.MAX_VALUE;       }
      return newCapacity;
    }
    @CheckReturnValue
    public ImmutableDoubleArray build() {
      return count == 0 ? EMPTY : new ImmutableDoubleArray(array, 0, count);
    }
  }
  @SuppressWarnings("Immutable")
  private final double[] array;
  private final transient int start;   private final int end; 
  private ImmutableDoubleArray(double[] array) {
    this(array, 0, array.length);
  }
  private ImmutableDoubleArray(double[] array, int start, int end) {
    this.array = array;
    this.start = start;
    this.end = end;
  }
  public int length() {
    return end - start;
  }
  public boolean isEmpty() {
    return end == start;
  }
  public double get(int index) {
    Preconditions.checkElementIndex(index, length());
    return array[start + index];
  }
  public int indexOf(double target) {
    for (int i = start; i &lt; end; i++) {
      if (areEqual(array[i], target)) {
        return i - start;
      }
    }
    return -1;
  }
  public int lastIndexOf(double target) {
    for (int i = end - 1; i &gt;= start; i--) {
      if (areEqual(array[i], target)) {
        return i - start;
      }
    }
    return -1;
  }
  public boolean contains(double target) {
    return indexOf(target) &gt;= 0;
  }
  public double[] toArray() {
    return Arrays.copyOfRange(array, start, end);
  }
  public ImmutableDoubleArray subArray(int startIndex, int endIndex) {
    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
    return startIndex == endIndex
        ? EMPTY
        : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);
  }
  public List&lt;Double&gt; asList() {
    return new AsList(this);
  }
  static class AsList extends AbstractList&lt;Double&gt; implements RandomAccess, Serializable {
    private final ImmutableDoubleArray parent;
<a name="4"></a>
    private AsList(ImmutableDoubleArray parent) {
      this.parent = parent;
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    public int size() {
<a name="5"></a>      return parent.length();
    }
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Ov</b></font>erride
    public Double get(int index) {
      return parent.get(index);
    }
    @</b></font>Override
    public boolean contains(@CheckForNull Object target) {
      return indexOf(target) &gt;= 0;
    }
    @Override
    public int indexOf(@CheckForNull Object target) {
      return target instanceof Double ? parent.indexOf((Double) target) : -1;
    }
    @Override
    public int lastIndexOf(@CheckForNull Object target) {
<a name="3"></a>      return target instanceof Double ? parent.lastIndexOf((Double) target) : -1;
    }
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    public List&lt;Double&gt; subList(int fromIndex, int toIndex) {
      return parent.subArray(fromIndex, toIndex).asList();
    }</b></font>
    @Override
    public boolean equals(@CheckForNull Object object) {
      if (object instanceof AsList) {
        AsList that = (AsList) object;
        return this.parent.equals(that.parent);
      }
      if (!(object instanceof List)) {
        return false;
      }
      List&lt;?&gt; that = (List&lt;?&gt;) object;
      if (this.size() != that.size()) {
        return false;
      }
      int i = parent.start;
      for (Object element : that) {
        if (!(element instanceof Double) || !areEqual(parent.array[i++], (Double) element)) {
          return false;
        }
      }
      return true;
<a name="1"></a>    }
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    public int hashCode() {
      return parent.hashCode();
    }
    @Override
    public String toString() {
      return parent.toString();
    }
  }</b></font>
  @Override
  public boolean equals(@CheckForNull Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof ImmutableDoubleArray)) {
      return false;
    }
    ImmutableDoubleArray that = (ImmutableDoubleArray) object;
    if (this.length() != that.length()) {
      return false;
    }
    for (int i = 0; i &lt; length(); i++) {
      if (!areEqual(this.get(i), that.get(i))) {
        return false;
<a name="2"></a>      }
    }
    return true;
  <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  private static boolean areEqual(double a, double b) {
    return Double.doubleToLongBits(a) == Double.doubleToLongBits(b);
  }
  @Overrid</b></font>e
  public int hashCode() {
    int hash = 1;
    for (int i = start; i &lt; end; i++) {
      hash *= 31;
      hash += Doubles.hashCode(array[i]);
    }
    return hash;
  }
  @Override
  public String toString() {
    if (isEmpty()) {
      return "[]";
    }
    StringBuilder builder = new StringBuilder(length() * 5);     builder.append('[').append(array[start]);
    for (int i = start + 1; i &lt; end; i++) {
      builder.append(", ").append(array[i]);
    }
    builder.append(']');
    return builder.toString();
  }
  public ImmutableDoubleArray trimmed() {
    return isPartialView() ? new ImmutableDoubleArray(toArray()) : this;
  }
  private boolean isPartialView() {
    return start &gt; 0 || end &lt; array.length;
  }
  Object writeReplace() {
    return trimmed();
  }
  Object readResolve() {
    return isEmpty() ? EMPTY : this;
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClosingFuture.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.util.concurrent;
import static com.google.common.base.Functions.constant;
import static com.google.common.base.MoreObjects.toStringHelper;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.Lists.asList;
import static com.google.common.util.concurrent.ClosingFuture.State.CLOSED;
import static com.google.common.util.concurrent.ClosingFuture.State.CLOSING;
import static com.google.common.util.concurrent.ClosingFuture.State.OPEN;
import static com.google.common.util.concurrent.ClosingFuture.State.SUBSUMED;
import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CLOSE;
import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CREATE_VALUE_AND_CLOSER;
import static com.google.common.util.concurrent.Futures.getDone;
import static com.google.common.util.concurrent.Futures.immediateFuture;
import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.logging.Level.FINER;
import static java.util.logging.Level.SEVERE;
import static java.util.logging.Level.WARNING;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable;
import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
import com.google.common.util.concurrent.Futures.FutureCombiner;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<a name="0"></a>import com.google.errorprone.annotations.DoNotMock;
import com.google.j2objc.annotations.RetainedWith;
import java.io.Closeable;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.IOException;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@DoNotMock("Use ClosingFuture.from(Futures.immediate*Future)")
@</b></font>ElementTypesAreNonnullByDefault
public final class ClosingFuture&lt;V extends @Nullable Object&gt; {
  private static final Logger logger = Logger.getLogger(ClosingFuture.class.getName());
  public static final class DeferredCloser {
    @RetainedWith private final CloseableList list;
    DeferredCloser(CloseableList list) {
      this.list = list;
    }
    @CanIgnoreReturnValue
    @ParametricNullness
    public &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt; C eventuallyClose(
        @ParametricNullness C closeable, Executor closingExecutor) {
      checkNotNull(closingExecutor);
      if (closeable != null) {
        list.add(closeable, closingExecutor);
      }
      return closeable;
    }
  }
  public interface ClosingCallable&lt;V extends @Nullable Object&gt; {
    @ParametricNullness
    V call(DeferredCloser closer) throws Exception;
  }
  public interface AsyncClosingCallable&lt;V extends @Nullable Object&gt; {
    ClosingFuture&lt;V&gt; call(DeferredCloser closer) throws Exception;
  }
  public interface ClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {
    @ParametricNullness
    U apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
  }
  public interface AsyncClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {
    ClosingFuture&lt;U&gt; apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
  }
  public static final class ValueAndCloser&lt;V extends @Nullable Object&gt; {
    private final ClosingFuture&lt;? extends V&gt; closingFuture;
<a name="4"></a>
    ValueAndCloser(ClosingFuture&lt;? extends V&gt; closingFuture) {
      this.closingFuture = checkNotNull(closingFuture);
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @ParametricNullness
    public V get() throws ExecutionException {
      return getDone(closingFuture.future);
    }
    public voi</b></font>d closeAsync() {
      closingFuture.close();
    }
  }
  public interface ValueAndCloserConsumer&lt;V extends @Nullable Object&gt; {
    void accept(ValueAndCloser&lt;V&gt; valueAndCloser);
  }
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submit(
      ClosingCallable&lt;V&gt; callable, Executor executor) {
    return new ClosingFuture&lt;&gt;(callable, executor);
  }
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submitAsync(
      AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
    return new ClosingFuture&lt;&gt;(callable, executor);
  }
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; from(ListenableFuture&lt;V&gt; future) {
    return new ClosingFuture&lt;V&gt;(future);
  }
  @Deprecated
  public static &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt;
      ClosingFuture&lt;C&gt; eventuallyClosing(
          ListenableFuture&lt;C&gt; future, final Executor closingExecutor) {
    checkNotNull(closingExecutor);
    final ClosingFuture&lt;C&gt; closingFuture = new ClosingFuture&lt;&gt;(nonCancellationPropagating(future));
    Futures.addCallback(
        future,
        new FutureCallback&lt;@Nullable Closeable&gt;() {
          @Override
          public void onSuccess(@CheckForNull Closeable result) {
            closingFuture.closeables.closer.eventuallyClose(result, closingExecutor);
          }
          @Override
          public void onFailure(Throwable t) {}
        },
        directExecutor());
    return closingFuture;
  }
  public static Combiner whenAllComplete(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
    return new Combiner(false, futures);
  <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
  public static Combiner whenAllComplete(
      ClosingFuture&lt;?&gt; future1, ClosingFuture&lt;?&gt;... moreFutures) {
    return whenAllComplete(asList(future1, moreFutures));
  }
  public static </b></font>Combiner whenAllSucceed(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
    return new Combiner(true, futures);
  }
  public static &lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
      Combiner2&lt;V1, V2&gt; whenAllSucceed(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
    return new Combiner2&lt;&gt;(future1, future2);
  }
  public static &lt;
          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
      Combiner3&lt;V1, V2, V3&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
    return new Combiner3&lt;&gt;(future1, future2, future3);
  }
  public static &lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object&gt;
      Combiner4&lt;V1, V2, V3, V4&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1,
          ClosingFuture&lt;V2&gt; future2,
          ClosingFuture&lt;V3&gt; future3,
          ClosingFuture&lt;V4&gt; future4) {
    return new Combiner4&lt;&gt;(future1, future2, future3, future4);
  }
  public static &lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object,
          V5 extends @Nullable Object&gt;
      Combiner5&lt;V1, V2, V3, V4, V5&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1,
          ClosingFuture&lt;V2&gt; future2,
          ClosingFuture&lt;V3&gt; future3,
<a name="7"></a>          ClosingFuture&lt;V4&gt; future4,
          ClosingFuture&lt;V5&gt; future5) {
    return new Combiner5&lt;&gt;(future1, future2, future3, future4, future5);
  <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
  public static Combiner whenAllSucceed(
      ClosingFuture&lt;?&gt; future1,
      ClosingFuture&lt;?&gt; future2,
      ClosingFuture&lt;?&gt; future3,
      ClosingFuture&lt;?&gt; future4,
      ClosingFuture&lt;?&gt; future5,
      ClosingFuture&lt;?&gt; future6</b></font>,
      ClosingFuture&lt;?&gt;... moreFutures) {
    return whenAllSucceed(
        FluentIterable.of(future1, future2, future3, future4, future5, future6)
            .append(moreFutures));
  }
  private final AtomicReference&lt;State&gt; state = new AtomicReference&lt;&gt;(OPEN);
  private final CloseableList closeables = new CloseableList();
  private final FluentFuture&lt;V&gt; future;
  private ClosingFuture(ListenableFuture&lt;V&gt; future) {
    this.future = FluentFuture.from(future);
  }
  private ClosingFuture(final ClosingCallable&lt;V&gt; callable, Executor executor) {
    checkNotNull(callable);
    TrustedListenableFutureTask&lt;V&gt; task =
<a name="1"></a>        TrustedListenableFutureTask.create(
            new Callable&lt;V&gt;() {
              @Override
              <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@ParametricNullness
              public V call() throws Exception {
                return callable.call(closeables.closer);
              }
              @Override
              public String toString() {
                return callable.toString();
              }
            }</b></font>);
    executor.execute(task);
    this.future = task;
  }
  private ClosingFuture(final AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
    checkNotNull(callable);
    TrustedListenableFutureTask&lt;V&gt; task =
        TrustedListenableFutureTask.create(
            new AsyncCallable&lt;V&gt;() {
              @Override
              public ListenableFuture&lt;V&gt; call() throws Exception {
                CloseableList newCloseables = new CloseableList();
                try {
                  ClosingFuture&lt;V&gt; closingFuture = callable.call(newCloseables.closer);
                  closingFuture.becomeSubsumedInto(closeables);
                  return closingFuture.future;
                } finally {
                  closeables.add(newCloseables, directExecutor());
                }
              }
              @Override
              public String toString() {
                return callable.toString();
              }
            });
    executor.execute(task);
    this.future = task;
  }
  public ListenableFuture&lt;?&gt; statusFuture() {
    return nonCancellationPropagating(future.transform(constant(null), directExecutor()));
  }
  public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transform(
      final ClosingFunction&lt;? super V, U&gt; function, Executor executor) {
<a name="5"></a>    checkNotNull(function);
    AsyncFunction&lt;V, U&gt; applyFunction =
        new AsyncFunction&lt;V, U&gt;() {
          <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
          public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
            return closeables.applyClosingFunction(function, input);
          }
          @</b></font>Override
          public String toString() {
            return function.toString();
          }
        };
    return derive(future.transformAsync(applyFunction, executor));
  }
  public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transformAsync(
      final AsyncClosingFunction&lt;? super V, U&gt; function, Executor executor) {
    checkNotNull(function);
    AsyncFunction&lt;V, U&gt; applyFunction =
        new AsyncFunction&lt;V, U&gt;() {
          @Override
          public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
            return closeables.applyAsyncClosingFunction(function, input);
          }
          @Override
          public String toString() {
            return function.toString();
          }
        };
    return derive(future.transformAsync(applyFunction, executor));
  }
  public static &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
<a name="3"></a>      AsyncClosingFunction&lt;V, U&gt; withoutCloser(final AsyncFunction&lt;V, U&gt; function) {
    checkNotNull(function);
    return new AsyncClosingFunction&lt;V, U&gt;() {
      <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public ClosingFuture&lt;U&gt; apply(DeferredCloser closer, V input) throws Exception {
        return ClosingFuture.from(function.apply(input));
      }</b></font>
    };
  }
  public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catching(
      Class&lt;X&gt; exceptionType, ClosingFunction&lt;? super X, ? extends V&gt; fallback, Executor executor) {
    return catchingMoreGeneric(exceptionType, fallback, executor);
  }
  private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingMoreGeneric(
      Class&lt;X&gt; exceptionType, final ClosingFunction&lt;? super X, W&gt; fallback, Executor executor) {
    checkNotNull(fallback);
    AsyncFunction&lt;X, W&gt; applyFallback =
        new AsyncFunction&lt;X, W&gt;() {
          @Override
          public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
            return closeables.applyClosingFunction(fallback, exception);
          }
          @Override
          public String toString() {
            return fallback.toString();
          }
        };
    return derive(future.catchingAsync(exceptionType, applyFallback, executor));
  }
  public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catchingAsync(
      Class&lt;X&gt; exceptionType,
      AsyncClosingFunction&lt;? super X, ? extends V&gt; fallback,
      Executor executor) {
    return catchingAsyncMoreGeneric(exceptionType, fallback, executor);
  }
  private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingAsyncMoreGeneric(
      Class&lt;X&gt; exceptionType,
      final AsyncClosingFunction&lt;? super X, W&gt; fallback,
      Executor executor) {
    checkNotNull(fallback);
    AsyncFunction&lt;X, W&gt; asyncFunction =
        new AsyncFunction&lt;X, W&gt;() {
          @Override
          public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
            return closeables.applyAsyncClosingFunction(fallback, exception);
          }
          @Override
          public String toString() {
            return fallback.toString();
          }
        };
    return derive(future.catchingAsync(exceptionType, asyncFunction, executor));
  }
  public FluentFuture&lt;V&gt; finishToFuture() {
    if (compareAndUpdateState(OPEN, WILL_CLOSE)) {
      logger.log(FINER, "will close {0}", this);
      future.addListener(
          new Runnable() {
            @Override
            public void run() {
              checkAndUpdateState(WILL_CLOSE, CLOSING);
              close();
              checkAndUpdateState(CLOSING, CLOSED);
            }
          },
          directExecutor());
    } else {
      switch (state.get()) {
        case SUBSUMED:
          throw new IllegalStateException(
              "Cannot call finishToFuture() after deriving another step");
        case WILL_CREATE_VALUE_AND_CLOSER:
          throw new IllegalStateException(
              "Cannot call finishToFuture() after calling finishToValueAndCloser()");
        case WILL_CLOSE:
        case CLOSING:
        case CLOSED:
          throw new IllegalStateException("Cannot call finishToFuture() twice");
        case OPEN:
          throw new AssertionError();
      }
    }
    return future;
  }
  public void finishToValueAndCloser(
      final ValueAndCloserConsumer&lt;? super V&gt; consumer, Executor executor) {
    checkNotNull(consumer);
    if (!compareAndUpdateState(OPEN, WILL_CREATE_VALUE_AND_CLOSER)) {
      switch (state.get()) {
        case SUBSUMED:
          throw new IllegalStateException(
              "Cannot call finishToValueAndCloser() after deriving another step");
        case WILL_CLOSE:
        case CLOSING:
        case CLOSED:
          throw new IllegalStateException(
              "Cannot call finishToValueAndCloser() after calling finishToFuture()");
        case WILL_CREATE_VALUE_AND_CLOSER:
          throw new IllegalStateException("Cannot call finishToValueAndCloser() twice");
        case OPEN:
          break;
      }
      throw new AssertionError(state);
    }
    future.addListener(
        new Runnable() {
          @Override
          public void run() {
            provideValueAndCloser(consumer, ClosingFuture.this);
          }
        },
        executor);
  }
  private static &lt;C extends @Nullable Object, V extends C&gt; void provideValueAndCloser(
      ValueAndCloserConsumer&lt;C&gt; consumer, ClosingFuture&lt;V&gt; closingFuture) {
    consumer.accept(new ValueAndCloser&lt;C&gt;(closingFuture));
  }
  @CanIgnoreReturnValue
  public boolean cancel(boolean mayInterruptIfRunning) {
    logger.log(FINER, "cancelling {0}", this);
    boolean cancelled = future.cancel(mayInterruptIfRunning);
    if (cancelled) {
      close();
    }
    return cancelled;
  }
  private void close() {
    logger.log(FINER, "closing {0}", this);
    closeables.close();
  }
<a name="6"></a>  private &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; derive(FluentFuture&lt;U&gt; future) {
    ClosingFuture&lt;U&gt; derived = new ClosingFuture&lt;&gt;(future);
    becomeSubsumedInto(derived.closeables);
    <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return derived;
  }
  private void becomeSubsumedInto(CloseableList otherCloseables) {
    checkAndUpdateState(OPEN, SUBSUMED);
    otherCloseables.add(closeables, directExecutor</b></font>());
  }
  public static final class Peeker {
    private final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures;
    private volatile boolean beingCalled;
    private Peeker(ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures) {
      this.futures = checkNotNull(futures);
    }
    @ParametricNullness
    public final &lt;D extends @Nullable Object&gt; D getDone(ClosingFuture&lt;D&gt; closingFuture)
        throws ExecutionException {
      checkState(beingCalled);
      checkArgument(futures.contains(closingFuture));
      return Futures.getDone(closingFuture.future);
    }
    @ParametricNullness
    private &lt;V extends @Nullable Object&gt; V call(
        CombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        return combiner.call(newCloseables.closer, this);
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }
    private &lt;V extends @Nullable Object&gt; FluentFuture&lt;V&gt; callAsync(
        AsyncCombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture&lt;V&gt; closingFuture = combiner.call(newCloseables.closer, this);
        closingFuture.becomeSubsumedInto(closeables);
        return closingFuture.future;
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }
  }
  @com.google.errorprone.annotations.DoNotMock(
      "Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead.")
  public static class Combiner {
    private final CloseableList closeables = new CloseableList();
    public interface CombiningCallable&lt;V extends @Nullable Object&gt; {
      @ParametricNullness
      V call(DeferredCloser closer, Peeker peeker) throws Exception;
    }
    public interface AsyncCombiningCallable&lt;V extends @Nullable Object&gt; {
      ClosingFuture&lt;V&gt; call(DeferredCloser closer, Peeker peeker) throws Exception;
    }
    private final boolean allMustSucceed;
    protected final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; inputs;
    private Combiner(boolean allMustSucceed, Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; inputs) {
      this.allMustSucceed = allMustSucceed;
      this.inputs = ImmutableList.copyOf(inputs);
      for (ClosingFuture&lt;?&gt; input : inputs) {
        input.becomeSubsumedInto(closeables);
      }
    }
    public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; call(
        final CombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
      Callable&lt;V&gt; callable =
          new Callable&lt;V&gt;() {
            @Override
            @ParametricNullness
            public V call() throws Exception {
              return new Peeker(inputs).call(combiningCallable, closeables);
            }
            @Override
            public String toString() {
              return combiningCallable.toString();
            }
          };
      ClosingFuture&lt;V&gt; derived = new ClosingFuture&lt;&gt;(futureCombiner().call(callable, executor));
      derived.closeables.add(closeables, directExecutor());
      return derived;
    }
    public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; callAsync(
        final AsyncCombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
      AsyncCallable&lt;V&gt; asyncCallable =
          new AsyncCallable&lt;V&gt;() {
            @Override
            public ListenableFuture&lt;V&gt; call() throws Exception {
              return new Peeker(inputs).callAsync(combiningCallable, closeables);
            }
            @Override
            public String toString() {
              return combiningCallable.toString();
            }
          };
      ClosingFuture&lt;V&gt; derived =
          new ClosingFuture&lt;&gt;(futureCombiner().callAsync(asyncCallable, executor));
      derived.closeables.add(closeables, directExecutor());
      return derived;
    }
    private FutureCombiner&lt;@Nullable Object&gt; futureCombiner() {
      return allMustSucceed
          ? Futures.whenAllSucceed(inputFutures())
          : Futures.whenAllComplete(inputFutures());
    }
    private static final Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt; INNER_FUTURE =
        new Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt;() {
          @Override
          public FluentFuture&lt;?&gt; apply(ClosingFuture&lt;?&gt; future) {
            return future.future;
          }
        };
    private ImmutableList&lt;FluentFuture&lt;?&gt;&gt; inputFutures() {
      return FluentIterable.from(inputs).transform(INNER_FUTURE).toList();
    }
  }
  public static final class Combiner2&lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
      extends Combiner {
    public interface ClosingFunction2&lt;
        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {
      @ParametricNullness
      U apply(DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
          throws Exception;
    }
    public interface AsyncClosingFunction2&lt;
        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
          throws Exception;
    }
    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private Combiner2(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
      super(true, ImmutableList.of(future1, future2));
      this.future1 = future1;
      this.future2 = future2;
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }
  public static final class Combiner3&lt;
          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
      extends Combiner {
    public interface ClosingFunction3&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3)
          throws Exception;
    }
    public interface AsyncClosingFunction3&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3)
          throws Exception;
    }
    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;
    private Combiner3(
        ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
      super(true, ImmutableList.of(future1, future2, future3));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }
  public static final class Combiner4&lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object&gt;
      extends Combiner {
    public interface ClosingFunction4&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4)
          throws Exception;
    }
    public interface AsyncClosingFunction4&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4)
          throws Exception;
    }
    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;
    private final ClosingFuture&lt;V4&gt; future4;
    private Combiner4(
        ClosingFuture&lt;V1&gt; future1,
        ClosingFuture&lt;V2&gt; future2,
        ClosingFuture&lt;V3&gt; future3,
        ClosingFuture&lt;V4&gt; future4) {
      super(true, ImmutableList.of(future1, future2, future3, future4));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
      this.future4 = future4;
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }
  public static final class Combiner5&lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object,
          V5 extends @Nullable Object&gt;
      extends Combiner {
    public interface ClosingFunction5&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        V5 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4,
          @ParametricNullness V5 value5)
          throws Exception;
    }
    public interface AsyncClosingFunction5&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        V5 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4,
          @ParametricNullness V5 value5)
          throws Exception;
    }
    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;
    private final ClosingFuture&lt;V4&gt; future4;
    private final ClosingFuture&lt;V5&gt; future5;
    private Combiner5(
        ClosingFuture&lt;V1&gt; future1,
        ClosingFuture&lt;V2&gt; future2,
        ClosingFuture&lt;V3&gt; future3,
        ClosingFuture&lt;V4&gt; future4,
        ClosingFuture&lt;V5&gt; future5) {
      super(true, ImmutableList.of(future1, future2, future3, future4, future5));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
      this.future4 = future4;
      this.future5 = future5;
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4),
                  peeker.getDone(future5));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4),
                  peeker.getDone(future5));
            }
            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }
  @Override
  public String toString() {
    return toStringHelper(this).add("state", state.get()).addValue(future).toString();
  }
  @Override
  protected void finalize() {
    if (state.get().equals(OPEN)) {
      logger.log(SEVERE, "Uh oh! An open ClosingFuture has leaked and will close: {0}", this);
      FluentFuture&lt;V&gt; unused = finishToFuture();
    }
  }
  private static void closeQuietly(@CheckForNull final Closeable closeable, Executor executor) {
    if (closeable == null) {
      return;
    }
    try {
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              try {
                closeable.close();
              } catch (IOException | RuntimeException e) {
                logger.log(WARNING, "thrown by close()", e);
              }
            }
          });
    } catch (RejectedExecutionException e) {
      if (logger.isLoggable(WARNING)) {
        logger.log(
            WARNING, String.format("while submitting close to %s; will close inline", executor), e);
      }
      closeQuietly(closeable, directExecutor());
    }
  }
  private void checkAndUpdateState(State oldState, State newState) {
    checkState(
        compareAndUpdateState(oldState, newState),
        "Expected state to be %s, but it was %s",
        oldState,
        newState);
  }
  private boolean compareAndUpdateState(State oldState, State newState) {
    return state.compareAndSet(oldState, newState);
  }
  private static final class CloseableList extends IdentityHashMap&lt;Closeable, Executor&gt;
      implements Closeable {
    private final DeferredCloser closer = new DeferredCloser(this);
    private volatile boolean closed;
    @CheckForNull private volatile CountDownLatch whenClosed;
    &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
        ListenableFuture&lt;U&gt; applyClosingFunction(
            ClosingFunction&lt;? super V, U&gt; transformation, @ParametricNullness V input)
            throws Exception {
      CloseableList newCloseables = new CloseableList();
      try {
        return immediateFuture(transformation.apply(newCloseables.closer, input));
      } finally {
        add(newCloseables, directExecutor());
      }
    }
    &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
        FluentFuture&lt;U&gt; applyAsyncClosingFunction(
            AsyncClosingFunction&lt;V, U&gt; transformation, @ParametricNullness V input)
            throws Exception {
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture&lt;U&gt; closingFuture = transformation.apply(newCloseables.closer, input);
        closingFuture.becomeSubsumedInto(newCloseables);
        return closingFuture.future;
      } finally {
        add(newCloseables, directExecutor());
      }
    }
    @Override
    public void close() {
      if (closed) {
        return;
      }
      synchronized (this) {
        if (closed) {
          return;
        }
        closed = true;
      }
      for (Map.Entry&lt;Closeable, Executor&gt; entry : entrySet()) {
        closeQuietly(entry.getKey(), entry.getValue());
      }
      clear();
      if (whenClosed != null) {
        whenClosed.countDown();
      }
    }
    void add(@CheckForNull Closeable closeable, Executor executor) {
      checkNotNull(executor);
      if (closeable == null) {
        return;
      }
      synchronized (this) {
        if (!closed) {
          put(closeable, executor);
          return;
        }
      }
      closeQuietly(closeable, executor);
    }
    CountDownLatch whenClosedCountDown() {
      if (closed) {
        return new CountDownLatch(0);
      }
      synchronized (this) {
        if (closed) {
          return new CountDownLatch(0);
        }
        checkState(whenClosed == null);
        return whenClosed = new CountDownLatch(1);
      }
    }
  }
  @VisibleForTesting
  CountDownLatch whenClosedCountDown() {
    return closeables.whenClosedCountDown();
  }
  enum State {
    OPEN,
    SUBSUMED,
    WILL_CLOSE,
    CLOSING,
    CLOSED,
    WILL_CREATE_VALUE_AND_CLOSER,
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
