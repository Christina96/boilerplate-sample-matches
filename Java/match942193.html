<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableDoubleArray.java (14.61039%)<th>ClosingFuture.java (5.260082%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-81)<td><a href="#" name="0">(50-194)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(485-494)<td><a href="#" name="1">(601-610)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(518-526)<td><a href="#" name="2">(463-483)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(455-458)<td><a href="#" name="3">(831-834)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(426-435)<td><a href="#" name="4">(333-360)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(435-440)<td><a href="#" name="5">(694-699)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(252-261)<td><a href="#" name="6">(1136-1141)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(115-119)<td><a href="#" name="7">(565-580)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableDoubleArray.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2017 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<a name="0"></a>
package com.google.common.primitives;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.CheckReturnValue;
import com.google.errorprone.annotations.Immutable;
import java.io.Serializable;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.RandomAccess;
import javax.annotation.CheckForNull;

/**
 * An immutable array of {@code double} values, with an API resembling {@link List}.
 *
 * &lt;p&gt;Advantages compared to {@code double[]}:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;All the many well-known advantages of immutability (read &lt;i&gt;Effective Java&lt;/i&gt;, third
 *       edition, Item 17).
 *   &lt;li&gt;Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link
 *       #toString} behavior you expect.
 *   &lt;li&gt;Offers useful operations beyond just {@code get} and {@code length}, so you don't have to
 *       hunt through classes like {@link Arrays} and {@link Doubles} for them.
 *   &lt;li&gt;Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to
 *       add overloads that accept start and end indexes.
 *   &lt;li&gt;Access to all collection-based utilities via {@link #asList} (though at the cost of
 *       allocating garbage).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Disadvantages compared to {@code double[]}:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Memory footprint has a fixed overhead (about 24 bytes per instance).
 *   &lt;li&gt;&lt;i&gt;Some&lt;/i&gt; construction use cases force the data to be copied (though several construction
 *       APIs are offered that don't).
 *   &lt;li&gt;Can't be passed directly to methods that expect {@code double[]} (though the most common
 *       utilities do have replacements here).
 *   &lt;li&gt;Dependency on {@code com.google.common} / Guava.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code
 * &lt;Double&gt;}:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Improved memory compactness and locality.
 *   &lt;li&gt;Can be queried without allocating garbage.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Disadvantages compared to {@code ImmutableList&lt;Double&gt;}:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or
 *       {@code List} (though the most common utilities do have replacements here, and there is a
 *       lazy {@link #asList} view).
 * &lt;/ul&gt;
 *
 * @since 22.0
 */
@Beta
@</b></font>GwtCompatible
@Immutable
@ElementTypesAreNonnullByDefault
public final class ImmutableDoubleArray implements Serializable {
  private static final ImmutableDoubleArray EMPTY = new ImmutableDoubleArray(new double[0]);

  /** Returns the empty array. */
  public static ImmutableDoubleArray of() {
    return EMPTY;
  }

  /** Returns an immutable array containing a single value. */
  public static ImmutableDoubleArray of(double e0) {
    return new ImmutableDoubleArray(new double[] {e0});
  }

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray of(double e0, double e1) {
    return new ImmutableDoubleArray(new double[] {e0, e1});
  }

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray of(double e0, double e1, double e2) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2});
  }

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3});
  }

<a name="7"></a>  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3, double e4) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4});
  <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray of(
      double e0, double e1, double e2, double e3, double e4, double e5</b></font>) {
    return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4, e5});
  }

  // TODO(kevinb): go up to 11?

  /**
   * Returns an immutable array containing the given values, in order.
   *
   * &lt;p&gt;The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.
   */
  // Use (first, rest) so that `of(someDoubleArray)` won't compile (they should use copyOf), which
  // is okay since we have to copy the just-created array anyway.
  public static ImmutableDoubleArray of(double first, double... rest) {
    checkArgument(
        rest.length &lt;= Integer.MAX_VALUE - 1, "the total number of elements must fit in an int");
    double[] array = new double[rest.length + 1];
    array[0] = first;
    System.arraycopy(rest, 0, array, 1, rest.length);
    return new ImmutableDoubleArray(array);
  }

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray copyOf(double[] values) {
    return values.length == 0
        ? EMPTY
        : new ImmutableDoubleArray(Arrays.copyOf(values, values.length));
  }

  /** Returns an immutable array containing the given values, in order. */
  public static ImmutableDoubleArray copyOf(Collection&lt;Double&gt; values) {
    return values.isEmpty() ? EMPTY : new ImmutableDoubleArray(Doubles.toArray(values));
  }

  /**
   * Returns an immutable array containing the given values, in order.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; this method delegates to {@link #copyOf(Collection)} if {@code
   * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link
   * Builder#addAll(Iterable)}, with all the performance implications associated with that.
   */
  public static ImmutableDoubleArray copyOf(Iterable&lt;Double&gt; values) {
    if (values instanceof Collection) {
      return copyOf((Collection&lt;Double&gt;) values);
    }
    return builder().addAll(values).build();
  }

  /**
   * Returns a new, empty builder for {@link ImmutableDoubleArray} instances, sized to hold up to
   * {@code initialCapacity} values without resizing. The returned builder is not thread-safe.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; When feasible, {@code initialCapacity} should be the exact number
   * of values that will be added, if that knowledge is readily available. It is better to guess a
   * value slightly too high than slightly too low. If the value is not exact, the {@link
   * ImmutableDoubleArray} that is built will very likely occupy more memory than strictly
   * necessary; to trim memory usage, build using {@code builder.build().trimmed()}.
   */
  public static Builder builder(int initialCapacity) {
    checkArgument(initialCapacity &gt;= 0, "Invalid initialCapacity: %s", initialCapacity);
    return new Builder(initialCapacity);
  }

  /**
   * Returns a new, empty builder for {@link ImmutableDoubleArray} instances, with a default initial
   * capacity. The returned builder is not thread-safe.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; The {@link ImmutableDoubleArray} that is built will very likely
   * occupy more memory than necessary; to trim memory usage, build using {@code
   * builder.build().trimmed()}.
   */
  public static Builder builder() {
    return new Builder(10);
  }

  /**
   * A builder for {@link ImmutableDoubleArray} instances; obtained using {@link
   * ImmutableDoubleArray#builder}.
   */
  @CanIgnoreReturnValue
  public static final class Builder {
    private double[] array;
    private int count = 0; // &lt;= array.length

    Builder(int initialCapacity) {
      array = new double[initialCapacity];
    }

    /**
     * Appends {@code value} to the end of the values the built {@link ImmutableDoubleArray} will
     * contain.
     */
    public Builder add(double value) {
      ensureRoomFor(1);
      array[count] = value;
      count += 1;
      return this;
    }

    /**
     * Appends {@code values}, in order, to the end of the values the built {@link
     * ImmutableDoubleArray} will contain.
     */
    public Builder addAll(double[] values) {
      ensureRoomFor(values.length);
      System.arraycopy(values, 0, array, count, values.length);
      count += values.length;
      return this;
    }

    /**
     * Appends {@code values}, in order, to the end of the values the built {@link
     * ImmutableDoubleArray} will contain.
     */
    public Builder addAll(Iterable&lt;Double&gt; values) {
      if (values instanceof Collection) {
        return addAll((Collection&lt;Double&gt;) values);
      }
      for (Double value : values) {
        add(value);
      }
      return this;
    }

    /**
     * Appends {@code values}, in order, to the end of the values the built {@link
     * ImmutableDoubleArray} will contain.
     */
    public Builder addAll(Collection&lt;Double&gt; values) {
      ensureRoomFor(values.size());
<a name="6"></a>      for (Double value : values) {
        array[count++] = value;
      }
      <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
    }

    /**
     * Appends {@code values}, in order, to the end of the values the built {@link
     * ImmutableDoubleArray} will contain.
     */
    public Builder addAll(ImmutableDoubleArray values) {
      ensureRoomFor(values.length());
      System.arraycopy</b></font>(values.array, values.start, array, count, values.length());
      count += values.length();
      return this;
    }

    private void ensureRoomFor(int numberToAdd) {
      int newCount = count + numberToAdd; // TODO(kevinb): check overflow now?
      if (newCount &gt; array.length) {
        array = Arrays.copyOf(array, expandedCapacity(array.length, newCount));
      }
    }

    // Unfortunately this is pasted from ImmutableCollection.Builder.
    private static int expandedCapacity(int oldCapacity, int minCapacity) {
      if (minCapacity &lt; 0) {
        throw new AssertionError("cannot store more than MAX_VALUE elements");
      }
      // careful of overflow!
      int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) + 1;
      if (newCapacity &lt; minCapacity) {
        newCapacity = Integer.highestOneBit(minCapacity - 1) &lt;&lt; 1;
      }
      if (newCapacity &lt; 0) {
        newCapacity = Integer.MAX_VALUE; // guaranteed to be &gt;= newCapacity
      }
      return newCapacity;
    }

    /**
     * Returns a new immutable array. The builder can continue to be used after this call, to append
     * more values and build again.
     *
     * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; the returned array is backed by the same array as the builder, so
     * no data is copied as part of this step, but this may occupy more memory than strictly
     * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.
     */
    @CheckReturnValue
    public ImmutableDoubleArray build() {
      return count == 0 ? EMPTY : new ImmutableDoubleArray(array, 0, count);
    }
  }

  // Instance stuff here

  // The array is never mutated after storing in this field and the construction strategies ensure
  // it doesn't escape this class
  @SuppressWarnings("Immutable")
  private final double[] array;

  /*
   * TODO(kevinb): evaluate the trade-offs of going bimorphic to save these two fields from most
   * instances. Note that the instances that would get smaller are the right set to care about
   * optimizing, because the rest have the option of calling `trimmed`.
   */

  private final transient int start; // it happens that we only serialize instances where this is 0
  private final int end; // exclusive

  private ImmutableDoubleArray(double[] array) {
    this(array, 0, array.length);
  }

  private ImmutableDoubleArray(double[] array, int start, int end) {
    this.array = array;
    this.start = start;
    this.end = end;
  }

  /** Returns the number of values in this array. */
  public int length() {
    return end - start;
  }

  /** Returns {@code true} if there are no values in this array ({@link #length} is zero). */
  public boolean isEmpty() {
    return end == start;
  }

  /**
   * Returns the {@code double} value present at the given index.
   *
   * @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to
   *     {@link #length}
   */
  public double get(int index) {
    Preconditions.checkElementIndex(index, length());
    return array[start + index];
  }

  /**
   * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no
   * such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code
   * asList().indexOf(target)}.
   */
  public int indexOf(double target) {
    for (int i = start; i &lt; end; i++) {
      if (areEqual(array[i], target)) {
        return i - start;
      }
    }
    return -1;
  }

  /**
   * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no
   * such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code
   * asList().lastIndexOf(target)}.
   */
  public int lastIndexOf(double target) {
    for (int i = end - 1; i &gt;= start; i--) {
      if (areEqual(array[i], target)) {
        return i - start;
      }
    }
    return -1;
  }

  /**
   * Returns {@code true} if {@code target} is present at any index in this array. Values are
   * compared as if by {@link Double#equals}. Equivalent to {@code asList().contains(target)}.
   */
  public boolean contains(double target) {
    return indexOf(target) &gt;= 0;
  }

  /** Returns a new, mutable copy of this array's values, as a primitive {@code double[]}. */
  public double[] toArray() {
    return Arrays.copyOfRange(array, start, end);
  }

  /**
   * Returns a new immutable array containing the values in the specified range.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; The returned array has the same full memory footprint as this one
   * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,
   * end).trimmed()}.
   */
  public ImmutableDoubleArray subArray(int startIndex, int endIndex) {
    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
    return startIndex == endIndex
        ? EMPTY
        : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);
  }

  /**
   * Returns an immutable &lt;i&gt;view&lt;/i&gt; of this array's values as a {@code List}; note that {@code
   * double} values are boxed into {@link Double} instances on demand, which can be very expensive.
   * The returned list should be used once and discarded. For any usages beyond that, pass the
   * returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)
   * ImmutableList.copyOf} and use that list instead.
   */
  public List&lt;Double&gt; asList() {
    /*
     * Typically we cache this kind of thing, but much repeated use of this view is a performance
     * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if
     * they never use this method.
     */
    return new AsList(this);
  }

  static class AsList extends AbstractList&lt;Double&gt; implements RandomAccess, Serializable {
    private final ImmutableDoubleArray parent;
<a name="4"></a>
    private AsList(ImmutableDoubleArray parent) {
      this.parent = parent;
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    // inherit: isEmpty, containsAll, toArray x2, iterator, listIterator, mutations

    @Override
    public int size() {
<a name="5"></a>      return parent.length();
    }

    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Ov</b></font>erride
    public Double get(int index) {
      return parent.get(index);
    }

    @</b></font>Override
    public boolean contains(@CheckForNull Object target) {
      return indexOf(target) &gt;= 0;
    }

    @Override
    public int indexOf(@CheckForNull Object target) {
      return target instanceof Double ? parent.indexOf((Double) target) : -1;
    }

    @Override
    public int lastIndexOf(@CheckForNull Object target) {
<a name="3"></a>      return target instanceof Double ? parent.lastIndexOf((Double) target) : -1;
    }

    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    public List&lt;Double&gt; subList(int fromIndex, int toIndex) {
      return parent.subArray(fromIndex, toIndex).asList();
    }</b></font>

    @Override
    public boolean equals(@CheckForNull Object object) {
      if (object instanceof AsList) {
        AsList that = (AsList) object;
        return this.parent.equals(that.parent);
      }
      // We could delegate to super now but it would still box too much
      if (!(object instanceof List)) {
        return false;
      }
      List&lt;?&gt; that = (List&lt;?&gt;) object;
      if (this.size() != that.size()) {
        return false;
      }
      int i = parent.start;
      // Since `that` is very likely RandomAccess we could avoid allocating this iterator...
      for (Object element : that) {
        if (!(element instanceof Double) || !areEqual(parent.array[i++], (Double) element)) {
          return false;
        }
      }
      return true;
<a name="1"></a>    }

    // Because we happen to use the same formula. If that changes, just don't override this.
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    public int hashCode() {
      return parent.hashCode();
    }

    @Override
    public String toString() {
      return parent.toString();
    }
  }</b></font>

  /**
   * Returns {@code true} if {@code object} is an {@code ImmutableDoubleArray} containing the same
   * values as this one, in the same order. Values are compared as if by {@link Double#equals}.
   */
  @Override
  public boolean equals(@CheckForNull Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof ImmutableDoubleArray)) {
      return false;
    }
    ImmutableDoubleArray that = (ImmutableDoubleArray) object;
    if (this.length() != that.length()) {
      return false;
    }
    for (int i = 0; i &lt; length(); i++) {
      if (!areEqual(this.get(i), that.get(i))) {
        return false;
<a name="2"></a>      }
    }
    return true;
  <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

  // Match the behavior of Double.equals()
  private static boolean areEqual(double a, double b) {
    return Double.doubleToLongBits(a) == Double.doubleToLongBits(b);
  }

  /** Returns an unspecified hash code for the contents of this immutable array. */
  @Overrid</b></font>e
  public int hashCode() {
    int hash = 1;
    for (int i = start; i &lt; end; i++) {
      hash *= 31;
      hash += Doubles.hashCode(array[i]);
    }
    return hash;
  }

  /**
   * Returns a string representation of this array in the same form as {@link
   * Arrays#toString(double[])}, for example {@code "[1, 2, 3]"}.
   */
  @Override
  public String toString() {
    if (isEmpty()) {
      return "[]";
    }
    StringBuilder builder = new StringBuilder(length() * 5); // rough estimate is fine
    builder.append('[').append(array[start]);

    for (int i = start + 1; i &lt; end; i++) {
      builder.append(", ").append(array[i]);
    }
    builder.append(']');
    return builder.toString();
  }

  /**
   * Returns an immutable array containing the same values as {@code this} array. This is logically
   * a no-op, and in some circumstances {@code this} itself is returned. However, if this instance
   * is a {@link #subArray} view of a larger array, this method will copy only the appropriate range
   * of values, resulting in an equivalent array with a smaller memory footprint.
   */
  public ImmutableDoubleArray trimmed() {
    return isPartialView() ? new ImmutableDoubleArray(toArray()) : this;
  }

  private boolean isPartialView() {
    return start &gt; 0 || end &lt; array.length;
  }

  Object writeReplace() {
    return trimmed();
  }

  Object readResolve() {
    return isEmpty() ? EMPTY : this;
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClosingFuture.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2017 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.util.concurrent;

import static com.google.common.base.Functions.constant;
import static com.google.common.base.MoreObjects.toStringHelper;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.Lists.asList;
import static com.google.common.util.concurrent.ClosingFuture.State.CLOSED;
import static com.google.common.util.concurrent.ClosingFuture.State.CLOSING;
import static com.google.common.util.concurrent.ClosingFuture.State.OPEN;
import static com.google.common.util.concurrent.ClosingFuture.State.SUBSUMED;
import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CLOSE;
import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CREATE_VALUE_AND_CLOSER;
import static com.google.common.util.concurrent.Futures.getDone;
import static com.google.common.util.concurrent.Futures.immediateFuture;
import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.logging.Level.FINER;
import static java.util.logging.Level.SEVERE;
import static java.util.logging.Level.WARNING;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable;
import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
import com.google.common.util.concurrent.Futures.FutureCombiner;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<a name="0"></a>import com.google.errorprone.annotations.DoNotMock;
import com.google.j2objc.annotations.RetainedWith;
import java.io.Closeable;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.IOException;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A step in a pipeline of an asynchronous computation. When the last step in the computation is
 * complete, some objects captured during the computation are closed.
 *
 * &lt;p&gt;A pipeline of {@code ClosingFuture}s is a tree of steps. Each step represents either an
 * asynchronously-computed intermediate value, or else an exception that indicates the failure or
 * cancellation of the operation so far. The only way to extract the value or exception from a step
 * is by declaring that step to be the last step of the pipeline. Nevertheless, we refer to the
 * "value" of a successful step or the "result" (value or exception) of any step.
 *
 * &lt;ol&gt;
 *   &lt;li&gt;A pipeline starts at its leaf step (or steps), which is created from either a callable
 *       block or a {@link ListenableFuture}.
 *   &lt;li&gt;Each other step is derived from one or more input steps. At each step, zero or more objects
 *       can be captured for later closing.
 *   &lt;li&gt;There is one last step (the root of the tree), from which you can extract the final result
 *       of the computation. After that result is available (or the computation fails), all objects
 *       captured by any of the steps in the pipeline are closed.
 * &lt;/ol&gt;
 *
 * &lt;h3&gt;Starting a pipeline&lt;/h3&gt;
 *
 * Start a {@code ClosingFuture} pipeline {@linkplain #submit(ClosingCallable, Executor) from a
 * callable block} that may capture objects for later closing. To start a pipeline from a {@link
 * ListenableFuture} that doesn't create resources that should be closed later, you can use {@link
 * #from(ListenableFuture)} instead.
 *
 * &lt;h3&gt;Derived steps&lt;/h3&gt;
 *
 * A {@code ClosingFuture} step can be derived from one or more input {@code ClosingFuture} steps in
 * ways similar to {@link FluentFuture}s:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;by transforming the value from a successful input step,
 *   &lt;li&gt;by catching the exception from a failed input step, or
 *   &lt;li&gt;by combining the results of several input steps.
 * &lt;/ul&gt;
 *
 * Each derivation can capture the next value or any intermediate objects for later closing.
 *
 * &lt;p&gt;A step can be the input to at most one derived step. Once you transform its value, catch its
 * exception, or combine it with others, you cannot do anything else with it, including declare it
 * to be the last step of the pipeline.
 *
 * &lt;h4&gt;Transforming&lt;/h4&gt;
 *
 * To derive the next step by asynchronously applying a function to an input step's value, call
 * {@link #transform(ClosingFunction, Executor)} or {@link #transformAsync(AsyncClosingFunction,
 * Executor)} on the input step.
 *
 * &lt;h4&gt;Catching&lt;/h4&gt;
 *
 * To derive the next step from a failed input step, call {@link #catching(Class, ClosingFunction,
 * Executor)} or {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} on the input step.
 *
 * &lt;h4&gt;Combining&lt;/h4&gt;
 *
 * To derive a {@code ClosingFuture} from two or more input steps, pass the input steps to {@link
 * #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)} or its overloads.
 *
 * &lt;h3&gt;Cancelling&lt;/h3&gt;
 *
 * Any step in a pipeline can be {@linkplain #cancel(boolean) cancelled}, even after another step
 * has been derived, with the same semantics as cancelling a {@link Future}. In addition, a
 * successfully cancelled step will immediately start closing all objects captured for later closing
 * by it and by its input steps.
 *
 * &lt;h3&gt;Ending a pipeline&lt;/h3&gt;
 *
 * Each {@code ClosingFuture} pipeline must be ended. To end a pipeline, decide whether you want to
 * close the captured objects automatically or manually.
 *
 * &lt;h4&gt;Automatically closing&lt;/h4&gt;
 *
 * You can extract a {@link Future} that represents the result of the last step in the pipeline by
 * calling {@link #finishToFuture()}. All objects the pipeline has captured for closing will begin
 * to be closed asynchronously &lt;b&gt;after&lt;/b&gt; the returned {@code Future} is done: the future
 * completes before closing starts, rather than once it has finished.
 *
 * &lt;pre&gt;{@code
 * FluentFuture&lt;UserName&gt; userName =
 *     ClosingFuture.submit(
 *             closer -&gt; closer.eventuallyClose(database.newTransaction(), closingExecutor),
 *             executor)
 *         .transformAsync((closer, transaction) -&gt; transaction.queryClosingFuture("..."), executor)
 *         .transform((closer, result) -&gt; result.get("userName"), directExecutor())
 *         .catching(DBException.class, e -&gt; "no user", directExecutor())
 *         .finishToFuture();
 * }&lt;/pre&gt;
 *
 * In this example, when the {@code userName} {@link Future} is done, the transaction and the query
 * result cursor will both be closed, even if the operation is cancelled or fails.
 *
 * &lt;h4&gt;Manually closing&lt;/h4&gt;
 *
 * If you want to close the captured objects manually, after you've used the final result, call
 * {@link #finishToValueAndCloser(ValueAndCloserConsumer, Executor)} to get an object that holds the
 * final result. You then call {@link ValueAndCloser#closeAsync()} to close the captured objects.
 *
 * &lt;pre&gt;{@code
 *     ClosingFuture.submit(
 *             closer -&gt; closer.eventuallyClose(database.newTransaction(), closingExecutor),
 *             executor)
 *     .transformAsync((closer, transaction) -&gt; transaction.queryClosingFuture("..."), executor)
 *     .transform((closer, result) -&gt; result.get("userName"), directExecutor())
 *     .catching(DBException.class, e -&gt; "no user", directExecutor())
 *     .finishToValueAndCloser(
 *         valueAndCloser -&gt; this.userNameValueAndCloser = valueAndCloser, executor);
 *
 * // later
 * try { // get() will throw if the operation failed or was cancelled.
 *   UserName userName = userNameValueAndCloser.get();
 *   // do something with userName
 * } finally {
 *   userNameValueAndCloser.closeAsync();
 * }
 * }&lt;/pre&gt;
 *
 * In this example, when {@code userNameValueAndCloser.closeAsync()} is called, the transaction and
 * the query result cursor will both be closed, even if the operation is cancelled or fails.
 *
 * &lt;p&gt;Note that if you don't call {@code closeAsync()}, the captured objects will not be closed. The
 * automatic-closing approach described above is safer.
 *
 * @param &lt;V&gt; the type of the value of this step
 * @since 30.0
 */
// TODO(dpb): Consider reusing one CloseableList for the entire pipeline, modulo combinations.
@DoNotMock("Use ClosingFuture.from(Futures.immediate*Future)")
@</b></font>ElementTypesAreNonnullByDefault
// TODO(dpb): GWT compatibility.
public final class ClosingFuture&lt;V extends @Nullable Object&gt; {

  private static final Logger logger = Logger.getLogger(ClosingFuture.class.getName());

  /**
   * An object that can capture objects to be closed later, when a {@link ClosingFuture} pipeline is
   * done.
   */
  public static final class DeferredCloser {
    @RetainedWith private final CloseableList list;

    DeferredCloser(CloseableList list) {
      this.list = list;
    }

    /**
     * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.
     *
     * &lt;p&gt;For users of the {@code -jre} flavor of Guava, the object can be any {@code
     * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code
     * Closeable}. (For more about the flavors, see &lt;a
     * href="https://github.com/google/guava#adding-guava-to-your-build"&gt;Adding Guava to your
     * build&lt;/a&gt;.)
     *
     * &lt;p&gt;Be careful when targeting an older SDK than you are building against (most commonly when
     * building for Android): Ensure that any object you pass implements the interface not just in
     * your current SDK version but also at the oldest version you support. For example, &lt;a
     * href="https://developer.android.com/sdk/api_diff/16/"&gt;API Level 16&lt;/a&gt; is the first version
     * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper
     * {@code Closeable} with a method reference like {@code cursor::close}.
     *
     * &lt;p&gt;Note that this method is still binary-compatible between flavors because the erasure of
     * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.
     *
     * @param closeable the object to be closed (see notes above)
     * @param closingExecutor the object will be closed on this executor
     * @return the first argument
     */
    @CanIgnoreReturnValue
    @ParametricNullness
    // TODO(b/163345357): Widen bound to AutoCloseable once we require API Level 19.
    public &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt; C eventuallyClose(
        @ParametricNullness C closeable, Executor closingExecutor) {
      checkNotNull(closingExecutor);
      if (closeable != null) {
        list.add(closeable, closingExecutor);
      }
      return closeable;
    }
  }

  /**
   * An operation that computes a result.
   *
   * @param &lt;V&gt; the type of the result
   */
  public interface ClosingCallable&lt;V extends @Nullable Object&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
     * not before this method completes), even if this method throws or the pipeline is cancelled.
     */
    @ParametricNullness
    V call(DeferredCloser closer) throws Exception;
  }

  /**
   * An operation that computes a {@link ClosingFuture} of a result.
   *
   * @param &lt;V&gt; the type of the result
   * @since 30.1
   */
  public interface AsyncClosingCallable&lt;V extends @Nullable Object&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
     * not before this method completes), even if this method throws or the pipeline is cancelled.
     */
    ClosingFuture&lt;V&gt; call(DeferredCloser closer) throws Exception;
  }

  /**
   * A function from an input to a result.
   *
   * @param &lt;T&gt; the type of the input to the function
   * @param &lt;U&gt; the type of the result of the function
   */
  public interface ClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {

    /**
     * Applies this function to an input, or throws an exception if unable to do so.
     *
     * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
     * not before this method completes), even if this method throws or the pipeline is cancelled.
     */
    @ParametricNullness
    U apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
  }

  /**
   * A function from an input to a {@link ClosingFuture} of a result.
   *
   * @param &lt;T&gt; the type of the input to the function
   * @param &lt;U&gt; the type of the result of the function
   */
  public interface AsyncClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {
    /**
     * Applies this function to an input, or throws an exception if unable to do so.
     *
     * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
     * not before this method completes), even if this method throws or the pipeline is cancelled.
     */
    ClosingFuture&lt;U&gt; apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
  }

  /**
   * An object that holds the final result of an asynchronous {@link ClosingFuture} operation and
   * allows the user to close all the closeable objects that were captured during it for later
   * closing.
   *
   * &lt;p&gt;The asynchronous operation will have completed before this object is created.
   *
   * @param &lt;V&gt; the type of the value of a successful operation
   * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
   */
  public static final class ValueAndCloser&lt;V extends @Nullable Object&gt; {

    private final ClosingFuture&lt;? extends V&gt; closingFuture;
<a name="4"></a>
    ValueAndCloser(ClosingFuture&lt;? extends V&gt; closingFuture) {
      this.closingFuture = checkNotNull(closingFuture);
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    /**
     * Returns the final value of the associated {@link ClosingFuture}, or throws an exception as
     * {@link Future#get()} would.
     *
     * &lt;p&gt;Because the asynchronous operation has already completed, this method is synchronous and
     * returns immediately.
     *
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an exception
     */
    @ParametricNullness
    public V get() throws ExecutionException {
      return getDone(closingFuture.future);
    }

    /**
     * Starts closing all closeable objects captured during the {@link ClosingFuture}'s asynchronous
     * operation on the {@link Executor}s specified by calls to {@link
     * DeferredCloser#eventuallyClose(Closeable, Executor)}.
     *
     * &lt;p&gt;If any such calls specified {@link MoreExecutors#directExecutor()}, those objects will be
     * closed synchronously.
     *
     * &lt;p&gt;Idempotent: objects will be closed at most once.
     */
    public voi</b></font>d closeAsync() {
      closingFuture.close();
    }
  }

  /**
   * Represents an operation that accepts a {@link ValueAndCloser} for the last step in a {@link
   * ClosingFuture} pipeline.
   *
   * @param &lt;V&gt; the type of the final value of a successful pipeline
   * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
   */
  public interface ValueAndCloserConsumer&lt;V extends @Nullable Object&gt; {

    /** Accepts a {@link ValueAndCloser} for the last step in a {@link ClosingFuture} pipeline. */
    void accept(ValueAndCloser&lt;V&gt; valueAndCloser);
  }

  /**
   * Starts a {@link ClosingFuture} pipeline by submitting a callable block to an executor.
   *
   * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
   *     execution
   */
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submit(
      ClosingCallable&lt;V&gt; callable, Executor executor) {
    return new ClosingFuture&lt;&gt;(callable, executor);
  }

  /**
   * Starts a {@link ClosingFuture} pipeline by submitting a callable block to an executor.
   *
   * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
   *     execution
   * @since 30.1
   */
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submitAsync(
      AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
    return new ClosingFuture&lt;&gt;(callable, executor);
  }

  /**
   * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.
   *
   * &lt;p&gt;{@code future}'s value will not be closed when the pipeline is done even if {@code V}
   * implements {@link Closeable}. In order to start a pipeline with a value that will be closed
   * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.
   */
  public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; from(ListenableFuture&lt;V&gt; future) {
    return new ClosingFuture&lt;V&gt;(future);
  }

  /**
   * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.
   *
   * &lt;p&gt;If {@code future} succeeds, its value will be closed (using {@code closingExecutor)} when
   * the pipeline is done, even if the pipeline is canceled or fails.
   *
   * &lt;p&gt;Cancelling the pipeline will not cancel {@code future}, so that the pipeline can access its
   * value in order to close it.
   *
   * @param future the future to create the {@code ClosingFuture} from. For discussion of the
   *     future's result type {@code C}, see {@link DeferredCloser#eventuallyClose(Closeable,
   *     Executor)}.
   * @param closingExecutor the future's result will be closed on this executor
   * @deprecated Creating {@link Future}s of closeable types is dangerous in general because the
   *     underlying value may never be closed if the {@link Future} is canceled after its operation
   *     begins. Consider replacing code that creates {@link ListenableFuture}s of closeable types,
   *     including those that pass them to this method, with {@link #submit(ClosingCallable,
   *     Executor)} in order to ensure that resources do not leak. Or, to start a pipeline with a
   *     {@link ListenableFuture} that doesn't create values that should be closed, use {@link
   *     ClosingFuture#from}.
   */
  @Deprecated
  // TODO(b/163345357): Widen bound to AutoCloseable once we require API Level 19.
  public static &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt;
      ClosingFuture&lt;C&gt; eventuallyClosing(
          ListenableFuture&lt;C&gt; future, final Executor closingExecutor) {
    checkNotNull(closingExecutor);
    final ClosingFuture&lt;C&gt; closingFuture = new ClosingFuture&lt;&gt;(nonCancellationPropagating(future));
    Futures.addCallback(
        future,
        new FutureCallback&lt;@Nullable Closeable&gt;() {
          @Override
          public void onSuccess(@CheckForNull Closeable result) {
            closingFuture.closeables.closer.eventuallyClose(result, closingExecutor);
          }

          @Override
          public void onFailure(Throwable t) {}
        },
        directExecutor());
    return closingFuture;
  }

  /**
   * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}
<a name="2"></a>   */
  public static Combiner whenAllComplete(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
    return new Combiner(false, futures);
  <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

  /**
   * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static Combiner whenAllComplete(
      ClosingFuture&lt;?&gt; future1, ClosingFuture&lt;?&gt;... moreFutures) {
    return whenAllComplete(asList(future1, moreFutures));
  }

  /**
   * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they
   * all succeed. If any fail, the resulting pipeline will fail.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static </b></font>Combiner whenAllSucceed(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
    return new Combiner(true, futures);
  }

  /**
   * Starts specifying how to combine two {@link ClosingFuture}s into a single pipeline, assuming
   * they all succeed. If any fail, the resulting pipeline will fail.
   *
   * &lt;p&gt;Calling this method allows you to use lambdas or method references typed with the types of
   * the input {@link ClosingFuture}s.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static &lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
      Combiner2&lt;V1, V2&gt; whenAllSucceed(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
    return new Combiner2&lt;&gt;(future1, future2);
  }

  /**
   * Starts specifying how to combine three {@link ClosingFuture}s into a single pipeline, assuming
   * they all succeed. If any fail, the resulting pipeline will fail.
   *
   * &lt;p&gt;Calling this method allows you to use lambdas or method references typed with the types of
   * the input {@link ClosingFuture}s.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static &lt;
          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
      Combiner3&lt;V1, V2, V3&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
    return new Combiner3&lt;&gt;(future1, future2, future3);
  }

  /**
   * Starts specifying how to combine four {@link ClosingFuture}s into a single pipeline, assuming
   * they all succeed. If any fail, the resulting pipeline will fail.
   *
   * &lt;p&gt;Calling this method allows you to use lambdas or method references typed with the types of
   * the input {@link ClosingFuture}s.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static &lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object&gt;
      Combiner4&lt;V1, V2, V3, V4&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1,
          ClosingFuture&lt;V2&gt; future2,
          ClosingFuture&lt;V3&gt; future3,
          ClosingFuture&lt;V4&gt; future4) {
    return new Combiner4&lt;&gt;(future1, future2, future3, future4);
  }

  /**
   * Starts specifying how to combine five {@link ClosingFuture}s into a single pipeline, assuming
   * they all succeed. If any fail, the resulting pipeline will fail.
   *
   * &lt;p&gt;Calling this method allows you to use lambdas or method references typed with the types of
   * the input {@link ClosingFuture}s.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static &lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object,
          V5 extends @Nullable Object&gt;
      Combiner5&lt;V1, V2, V3, V4, V5&gt; whenAllSucceed(
          ClosingFuture&lt;V1&gt; future1,
          ClosingFuture&lt;V2&gt; future2,
          ClosingFuture&lt;V3&gt; future3,
<a name="7"></a>          ClosingFuture&lt;V4&gt; future4,
          ClosingFuture&lt;V5&gt; future5) {
    return new Combiner5&lt;&gt;(future1, future2, future3, future4, future5);
  <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

  /**
   * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they
   * all succeed. If any fail, the resulting pipeline will fail.
   *
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
   *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}
   */
  public static Combiner whenAllSucceed(
      ClosingFuture&lt;?&gt; future1,
      ClosingFuture&lt;?&gt; future2,
      ClosingFuture&lt;?&gt; future3,
      ClosingFuture&lt;?&gt; future4,
      ClosingFuture&lt;?&gt; future5,
      ClosingFuture&lt;?&gt; future6</b></font>,
      ClosingFuture&lt;?&gt;... moreFutures) {
    return whenAllSucceed(
        FluentIterable.of(future1, future2, future3, future4, future5, future6)
            .append(moreFutures));
  }

  private final AtomicReference&lt;State&gt; state = new AtomicReference&lt;&gt;(OPEN);
  private final CloseableList closeables = new CloseableList();
  private final FluentFuture&lt;V&gt; future;

  private ClosingFuture(ListenableFuture&lt;V&gt; future) {
    this.future = FluentFuture.from(future);
  }

  private ClosingFuture(final ClosingCallable&lt;V&gt; callable, Executor executor) {
    checkNotNull(callable);
    TrustedListenableFutureTask&lt;V&gt; task =
<a name="1"></a>        TrustedListenableFutureTask.create(
            new Callable&lt;V&gt;() {
              @Override
              <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@ParametricNullness
              public V call() throws Exception {
                return callable.call(closeables.closer);
              }

              @Override
              public String toString() {
                return callable.toString();
              }
            }</b></font>);
    executor.execute(task);
    this.future = task;
  }

  private ClosingFuture(final AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
    checkNotNull(callable);
    TrustedListenableFutureTask&lt;V&gt; task =
        TrustedListenableFutureTask.create(
            new AsyncCallable&lt;V&gt;() {
              @Override
              public ListenableFuture&lt;V&gt; call() throws Exception {
                CloseableList newCloseables = new CloseableList();
                try {
                  ClosingFuture&lt;V&gt; closingFuture = callable.call(newCloseables.closer);
                  closingFuture.becomeSubsumedInto(closeables);
                  return closingFuture.future;
                } finally {
                  closeables.add(newCloseables, directExecutor());
                }
              }

              @Override
              public String toString() {
                return callable.toString();
              }
            });
    executor.execute(task);
    this.future = task;
  }

  /**
   * Returns a future that finishes when this step does. Calling {@code get()} on the returned
   * future returns {@code null} if the step is successful or throws the same exception that would
   * be thrown by calling {@code finishToFuture().get()} if this were the last step. Calling {@code
   * cancel()} on the returned future has no effect on the {@code ClosingFuture} pipeline.
   *
   * &lt;p&gt;{@code statusFuture} differs from most methods on {@code ClosingFuture}: You can make calls
   * to {@code statusFuture} &lt;i&gt;in addition to&lt;/i&gt; the call you make to {@link #finishToFuture()} or
   * a derivation method &lt;i&gt;on the same instance&lt;/i&gt;. This is important because calling {@code
   * statusFuture} alone does not provide a way to close the pipeline.
   */
  public ListenableFuture&lt;?&gt; statusFuture() {
    return nonCancellationPropagating(future.transform(constant(null), directExecutor()));
  }

  /**
   * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
   * to its value. The function can use a {@link DeferredCloser} to capture objects to be closed
   * when the pipeline is done.
   *
   * &lt;p&gt;If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code
   * ClosingFuture} will be equivalent to this one.
   *
   * &lt;p&gt;If the function throws an exception, that exception is used as the result of the derived
   * {@code ClosingFuture}.
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * ClosingFuture&lt;List&lt;Row&gt;&gt; rowsFuture =
   *     queryFuture.transform((closer, result) -&gt; result.getRows(), executor);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
   * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
   * about heavyweight listeners are also applicable to heavyweight functions passed to this method.
   *
   * &lt;p&gt;After calling this method, you may not call {@link #finishToFuture()}, {@link
   * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
   * this {@code ClosingFuture}.
   *
   * @param function transforms the value of this step to the value of the derived step
   * @param executor executor to run the function in
   * @return the derived step
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this
   *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
   *     finished}
   */
  public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transform(
      final ClosingFunction&lt;? super V, U&gt; function, Executor executor) {
<a name="5"></a>    checkNotNull(function);
    AsyncFunction&lt;V, U&gt; applyFunction =
        new AsyncFunction&lt;V, U&gt;() {
          <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
          public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
            return closeables.applyClosingFunction(function, input);
          }

          @</b></font>Override
          public String toString() {
            return function.toString();
          }
        };
    // TODO(dpb): Switch to future.transformSync when that exists (passing a throwing function).
    return derive(future.transformAsync(applyFunction, executor));
  }

  /**
   * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
   * that returns a {@code ClosingFuture} to its value. The function can use a {@link
   * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
   * captured by the returned {@link ClosingFuture}).
   *
   * &lt;p&gt;If this {@code ClosingFuture} succeeds, the derived one will be equivalent to the one
   * returned by the function.
   *
   * &lt;p&gt;If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code
   * ClosingFuture} will be equivalent to this one.
   *
   * &lt;p&gt;If the function throws an exception, that exception is used as the result of the derived
   * {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code
   * ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be
   * closed.
   *
   * &lt;p&gt;Usage guidelines for this method:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
   *       {@code ClosingFuture}. If possible, prefer calling {@link #transform(ClosingFunction,
   *       Executor)} instead, with a function that returns the next value directly.
   *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor) closer.eventuallyClose()}
   *       for every closeable object this step creates in order to capture it for later closing.
   *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
   *       ClosingFuture} call {@link #from(ListenableFuture)}.
   *   &lt;li&gt;In case this step doesn't create new closeables, you can adapt an API that returns a
   *       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to
   *       {@link #withoutCloser(AsyncFunction)}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * // Result.getRowsClosingFuture() returns a ClosingFuture.
   * ClosingFuture&lt;List&lt;Row&gt;&gt; rowsFuture =
   *     queryFuture.transformAsync((closer, result) -&gt; result.getRowsClosingFuture(), executor);
   *
   * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the
   * // number of written rows. openOutputFile() returns a FileOutputStream (which implements
   * // Closeable).
   * ClosingFuture&lt;Integer&gt; rowsFuture2 =
   *     queryFuture.transformAsync(
   *         (closer, result) -&gt; {
   *           FileOutputStream fos = closer.eventuallyClose(openOutputFile(), closingExecutor);
   *           return ClosingFuture.from(result.writeRowsToOutputStreamFuture(fos));
   *      },
   *      executor);
   *
   * // Result.getRowsFuture() returns a ListenableFuture (no new closeables are created).
   * ClosingFuture&lt;List&lt;Row&gt;&gt; rowsFuture3 =
   *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);
   *
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
   * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
   * about heavyweight listeners are also applicable to heavyweight functions passed to this method.
   * (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside
   * {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads
   * responsible for completing the returned {@code ClosingFuture}.)
   *
   * &lt;p&gt;After calling this method, you may not call {@link #finishToFuture()}, {@link
   * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
   * this {@code ClosingFuture}.
   *
   * @param function transforms the value of this step to a {@code ClosingFuture} with the value of
   *     the derived step
   * @param executor executor to run the function in
   * @return the derived step
   * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this
   *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
   *     finished}
   */
  public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transformAsync(
      final AsyncClosingFunction&lt;? super V, U&gt; function, Executor executor) {
    checkNotNull(function);
    AsyncFunction&lt;V, U&gt; applyFunction =
        new AsyncFunction&lt;V, U&gt;() {
          @Override
          public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
            return closeables.applyAsyncClosingFunction(function, input);
          }

          @Override
          public String toString() {
            return function.toString();
          }
        };
    return derive(future.transformAsync(applyFunction, executor));
  }

  /**
   * Returns an {@link AsyncClosingFunction} that applies an {@link AsyncFunction} to an input,
   * ignoring the DeferredCloser and returning a {@code ClosingFuture} derived from the returned
   * {@link ListenableFuture}.
   *
   * &lt;p&gt;Use this method to pass a transformation to {@link #transformAsync(AsyncClosingFunction,
   * Executor)} or to {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} as long as it
   * meets these conditions:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;It does not need to capture any {@link Closeable} objects by calling {@link
   *       DeferredCloser#eventuallyClose(Closeable, Executor)}.
   *   &lt;li&gt;It returns a {@link ListenableFuture}.
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * // Result.getRowsFuture() returns a ListenableFuture.
   * ClosingFuture&lt;List&lt;Row&gt;&gt; rowsFuture =
   *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);
   * }&lt;/pre&gt;
   *
   * @param function transforms the value of a {@code ClosingFuture} step to a {@link
   *     ListenableFuture} with the value of a derived step
   */
  public static &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
<a name="3"></a>      AsyncClosingFunction&lt;V, U&gt; withoutCloser(final AsyncFunction&lt;V, U&gt; function) {
    checkNotNull(function);
    return new AsyncClosingFunction&lt;V, U&gt;() {
      <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public ClosingFuture&lt;U&gt; apply(DeferredCloser closer, V input) throws Exception {
        return ClosingFuture.from(function.apply(input));
      }</b></font>
    };
  }

  /**
   * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
   * to its exception if it is an instance of a given exception type. The function can use a {@link
   * DeferredCloser} to capture objects to be closed when the pipeline is done.
   *
   * &lt;p&gt;If this {@code ClosingFuture} succeeds or fails with a different exception type, the
   * function will not be called, and the derived {@code ClosingFuture} will be equivalent to this
   * one.
   *
   * &lt;p&gt;If the function throws an exception, that exception is used as the result of the derived
   * {@code ClosingFuture}.
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * ClosingFuture&lt;QueryResult&gt; queryFuture =
   *     queryFuture.catching(
   *         QueryException.class, (closer, x) -&gt; Query.emptyQueryResult(), executor);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
   * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
   * about heavyweight listeners are also applicable to heavyweight functions passed to this method.
   *
   * &lt;p&gt;After calling this method, you may not call {@link #finishToFuture()}, {@link
   * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
   * this {@code ClosingFuture}.
   *
   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
   *     type is matched against this step's exception. "This step's exception" means the cause of
   *     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
   *     underlying this step or, if {@code get()} throws a different kind of exception, that
   *     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
   *     prefer more specific types, avoiding {@code Throwable.class} in particular.
   * @param fallback the function to be called if this step fails with the expected exception type.
   *     The function's argument is this step's exception. "This step's exception" means the cause
   *     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
   *     underlying this step or, if {@code get()} throws a different kind of exception, that
   *     exception itself.
   * @param executor the executor that runs {@code fallback} if the input fails
   */
  public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catching(
      Class&lt;X&gt; exceptionType, ClosingFunction&lt;? super X, ? extends V&gt; fallback, Executor executor) {
    return catchingMoreGeneric(exceptionType, fallback, executor);
  }

  // Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.
  private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingMoreGeneric(
      Class&lt;X&gt; exceptionType, final ClosingFunction&lt;? super X, W&gt; fallback, Executor executor) {
    checkNotNull(fallback);
    AsyncFunction&lt;X, W&gt; applyFallback =
        new AsyncFunction&lt;X, W&gt;() {
          @Override
          public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
            return closeables.applyClosingFunction(fallback, exception);
          }

          @Override
          public String toString() {
            return fallback.toString();
          }
        };
    // TODO(dpb): Switch to future.catchingSync when that exists (passing a throwing function).
    return derive(future.catchingAsync(exceptionType, applyFallback, executor));
  }

  /**
   * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
   * that returns a {@code ClosingFuture} to its exception if it is an instance of a given exception
   * type. The function can use a {@link DeferredCloser} to capture objects to be closed when the
   * pipeline is done (other than those captured by the returned {@link ClosingFuture}).
   *
   * &lt;p&gt;If this {@code ClosingFuture} fails with an exception of the given type, the derived {@code
   * ClosingFuture} will be equivalent to the one returned by the function.
   *
   * &lt;p&gt;If this {@code ClosingFuture} succeeds or fails with a different exception type, the
   * function will not be called, and the derived {@code ClosingFuture} will be equivalent to this
   * one.
   *
   * &lt;p&gt;If the function throws an exception, that exception is used as the result of the derived
   * {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code
   * ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be
   * closed.
   *
   * &lt;p&gt;Usage guidelines for this method:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
   *       {@code ClosingFuture}. If possible, prefer calling {@link #catching(Class,
   *       ClosingFunction, Executor)} instead, with a function that returns the next value
   *       directly.
   *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor) closer.eventuallyClose()}
   *       for every closeable object this step creates in order to capture it for later closing.
   *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
   *       ClosingFuture} call {@link #from(ListenableFuture)}.
   *   &lt;li&gt;In case this step doesn't create new closeables, you can adapt an API that returns a
   *       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to
   *       {@link #withoutCloser(AsyncFunction)}
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Example usage:
   *
   * &lt;pre&gt;{@code
   * // Fall back to a secondary input stream in case of IOException.
   * ClosingFuture&lt;InputStream&gt; inputFuture =
   *     firstInputFuture.catchingAsync(
   *         IOException.class, (closer, x) -&gt; secondaryInputStreamClosingFuture(), executor);
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
   * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
   * about heavyweight listeners are also applicable to heavyweight functions passed to this method.
   * (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside
   * {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads
   * responsible for completing the returned {@code ClosingFuture}.)
   *
   * &lt;p&gt;After calling this method, you may not call {@link #finishToFuture()}, {@link
   * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
   * this {@code ClosingFuture}.
   *
   * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
   *     type is matched against this step's exception. "This step's exception" means the cause of
   *     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
   *     underlying this step or, if {@code get()} throws a different kind of exception, that
   *     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
   *     prefer more specific types, avoiding {@code Throwable.class} in particular.
   * @param fallback the function to be called if this step fails with the expected exception type.
   *     The function's argument is this step's exception. "This step's exception" means the cause
   *     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
   *     underlying this step or, if {@code get()} throws a different kind of exception, that
   *     exception itself.
   * @param executor the executor that runs {@code fallback} if the input fails
   */
  // TODO(dpb): Should this do something special if the function throws CancellationException or
  // ExecutionException?
  public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catchingAsync(
      Class&lt;X&gt; exceptionType,
      AsyncClosingFunction&lt;? super X, ? extends V&gt; fallback,
      Executor executor) {
    return catchingAsyncMoreGeneric(exceptionType, fallback, executor);
  }

  // Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.
  private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingAsyncMoreGeneric(
      Class&lt;X&gt; exceptionType,
      final AsyncClosingFunction&lt;? super X, W&gt; fallback,
      Executor executor) {
    checkNotNull(fallback);
    AsyncFunction&lt;X, W&gt; asyncFunction =
        new AsyncFunction&lt;X, W&gt;() {
          @Override
          public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
            return closeables.applyAsyncClosingFunction(fallback, exception);
          }

          @Override
          public String toString() {
            return fallback.toString();
          }
        };
    return derive(future.catchingAsync(exceptionType, asyncFunction, executor));
  }

  /**
   * Marks this step as the last step in the {@code ClosingFuture} pipeline.
   *
   * &lt;p&gt;The returned {@link Future} is completed when the pipeline's computation completes, or when
   * the pipeline is cancelled.
   *
   * &lt;p&gt;All objects the pipeline has captured for closing will begin to be closed asynchronously
   * &lt;b&gt;after&lt;/b&gt; the returned {@code Future} is done: the future completes before closing starts,
   * rather than once it has finished.
   *
   * &lt;p&gt;After calling this method, you may not call {@link
   * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, this method, or any other
   * derivation method on this {@code ClosingFuture}.
   *
   * @return a {@link Future} that represents the final value or exception of the pipeline
   */
  public FluentFuture&lt;V&gt; finishToFuture() {
    if (compareAndUpdateState(OPEN, WILL_CLOSE)) {
      logger.log(FINER, "will close {0}", this);
      future.addListener(
          new Runnable() {
            @Override
            public void run() {
              checkAndUpdateState(WILL_CLOSE, CLOSING);
              close();
              checkAndUpdateState(CLOSING, CLOSED);
            }
          },
          directExecutor());
    } else {
      switch (state.get()) {
        case SUBSUMED:
          throw new IllegalStateException(
              "Cannot call finishToFuture() after deriving another step");

        case WILL_CREATE_VALUE_AND_CLOSER:
          throw new IllegalStateException(
              "Cannot call finishToFuture() after calling finishToValueAndCloser()");

        case WILL_CLOSE:
        case CLOSING:
        case CLOSED:
          throw new IllegalStateException("Cannot call finishToFuture() twice");

        case OPEN:
          throw new AssertionError();
      }
    }
    return future;
  }

  /**
   * Marks this step as the last step in the {@code ClosingFuture} pipeline. When this step is done,
   * {@code receiver} will be called with an object that contains the result of the operation. The
   * receiver can store the {@link ValueAndCloser} outside the receiver for later synchronous use.
   *
   * &lt;p&gt;After calling this method, you may not call {@link #finishToFuture()}, this method again, or
   * any other derivation method on this {@code ClosingFuture}.
   *
   * @param consumer a callback whose method will be called (using {@code executor}) when this
   *     operation is done
   */
  public void finishToValueAndCloser(
      final ValueAndCloserConsumer&lt;? super V&gt; consumer, Executor executor) {
    checkNotNull(consumer);
    if (!compareAndUpdateState(OPEN, WILL_CREATE_VALUE_AND_CLOSER)) {
      switch (state.get()) {
        case SUBSUMED:
          throw new IllegalStateException(
              "Cannot call finishToValueAndCloser() after deriving another step");

        case WILL_CLOSE:
        case CLOSING:
        case CLOSED:
          throw new IllegalStateException(
              "Cannot call finishToValueAndCloser() after calling finishToFuture()");

        case WILL_CREATE_VALUE_AND_CLOSER:
          throw new IllegalStateException("Cannot call finishToValueAndCloser() twice");

        case OPEN:
          break;
      }
      throw new AssertionError(state);
    }
    future.addListener(
        new Runnable() {
          @Override
          public void run() {
            provideValueAndCloser(consumer, ClosingFuture.this);
          }
        },
        executor);
  }

  private static &lt;C extends @Nullable Object, V extends C&gt; void provideValueAndCloser(
      ValueAndCloserConsumer&lt;C&gt; consumer, ClosingFuture&lt;V&gt; closingFuture) {
    consumer.accept(new ValueAndCloser&lt;C&gt;(closingFuture));
  }

  /**
   * Attempts to cancel execution of this step. This attempt will fail if the step has already
   * completed, has already been cancelled, or could not be cancelled for some other reason. If
   * successful, and this step has not started when {@code cancel} is called, this step should never
   * run.
   *
   * &lt;p&gt;If successful, causes the objects captured by this step (if already started) and its input
   * step(s) for later closing to be closed on their respective {@link Executor}s. If any such calls
   * specified {@link MoreExecutors#directExecutor()}, those objects will be closed synchronously.
   *
   * @param mayInterruptIfRunning {@code true} if the thread executing this task should be
   *     interrupted; otherwise, in-progress tasks are allowed to complete, but the step will be
   *     cancelled regardless
   * @return {@code false} if the step could not be cancelled, typically because it has already
   *     completed normally; {@code true} otherwise
   */
  @CanIgnoreReturnValue
  public boolean cancel(boolean mayInterruptIfRunning) {
    logger.log(FINER, "cancelling {0}", this);
    boolean cancelled = future.cancel(mayInterruptIfRunning);
    if (cancelled) {
      close();
    }
    return cancelled;
  }

  private void close() {
    logger.log(FINER, "closing {0}", this);
    closeables.close();
  }

<a name="6"></a>  private &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; derive(FluentFuture&lt;U&gt; future) {
    ClosingFuture&lt;U&gt; derived = new ClosingFuture&lt;&gt;(future);
    becomeSubsumedInto(derived.closeables);
    <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return derived;
  }

  private void becomeSubsumedInto(CloseableList otherCloseables) {
    checkAndUpdateState(OPEN, SUBSUMED);
    otherCloseables.add(closeables, directExecutor</b></font>());
  }

  /**
   * An object that can return the value of the {@link ClosingFuture}s that are passed to {@link
   * #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)}.
   *
   * &lt;p&gt;Only for use by a {@link CombiningCallable} or {@link AsyncCombiningCallable} object.
   */
  public static final class Peeker {
    private final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures;
    private volatile boolean beingCalled;

    private Peeker(ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures) {
      this.futures = checkNotNull(futures);
    }

    /**
     * Returns the value of {@code closingFuture}.
     *
     * @throws ExecutionException if {@code closingFuture} is a failed step
     * @throws CancellationException if the {@code closingFuture}'s future was cancelled
     * @throws IllegalArgumentException if {@code closingFuture} is not one of the futures passed to
     *     {@link #whenAllComplete(Iterable)} or {@link #whenAllComplete(Iterable)}
     * @throws IllegalStateException if called outside of a call to {@link
     *     CombiningCallable#call(DeferredCloser, Peeker)} or {@link
     *     AsyncCombiningCallable#call(DeferredCloser, Peeker)}
     */
    @ParametricNullness
    public final &lt;D extends @Nullable Object&gt; D getDone(ClosingFuture&lt;D&gt; closingFuture)
        throws ExecutionException {
      checkState(beingCalled);
      checkArgument(futures.contains(closingFuture));
      return Futures.getDone(closingFuture.future);
    }

    @ParametricNullness
    private &lt;V extends @Nullable Object&gt; V call(
        CombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        return combiner.call(newCloseables.closer, this);
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }

    private &lt;V extends @Nullable Object&gt; FluentFuture&lt;V&gt; callAsync(
        AsyncCombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture&lt;V&gt; closingFuture = combiner.call(newCloseables.closer, this);
        closingFuture.becomeSubsumedInto(closeables);
        return closingFuture.future;
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }
  }

  /**
   * A builder of a {@link ClosingFuture} step that is derived from more than one input step.
   *
   * &lt;p&gt;See {@link #whenAllComplete(Iterable)} and {@link #whenAllSucceed(Iterable)} for how to
   * instantiate this class.
   *
   * &lt;p&gt;Example:
   *
   * &lt;pre&gt;{@code
   * final ClosingFuture&lt;BufferedReader&gt; file1ReaderFuture = ...;
   * final ClosingFuture&lt;BufferedReader&gt; file2ReaderFuture = ...;
   * ListenableFuture&lt;Integer&gt; numberOfDifferentLines =
   *       ClosingFuture.whenAllSucceed(file1ReaderFuture, file2ReaderFuture)
   *           .call(
   *               (closer, peeker) -&gt; {
   *                 BufferedReader file1Reader = peeker.getDone(file1ReaderFuture);
   *                 BufferedReader file2Reader = peeker.getDone(file2ReaderFuture);
   *                 return countDifferentLines(file1Reader, file2Reader);
   *               },
   *               executor)
   *           .closing(executor);
   * }&lt;/pre&gt;
   */
  // TODO(cpovirk): Use simple name instead of fully qualified after we stop building with JDK 8.
  @com.google.errorprone.annotations.DoNotMock(
      "Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead.")
  public static class Combiner {

    private final CloseableList closeables = new CloseableList();

    /**
     * An operation that returns a result and may throw an exception.
     *
     * @param &lt;V&gt; the type of the result
     */
    public interface CombiningCallable&lt;V extends @Nullable Object&gt; {
      /**
       * Computes a result, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       *
       * @param peeker used to get the value of any of the input futures
       */
      @ParametricNullness
      V call(DeferredCloser closer, Peeker peeker) throws Exception;
    }

    /**
     * An operation that returns a {@link ClosingFuture} result and may throw an exception.
     *
     * @param &lt;V&gt; the type of the result
     */
    public interface AsyncCombiningCallable&lt;V extends @Nullable Object&gt; {
      /**
       * Computes a {@link ClosingFuture} result, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       *
       * @param peeker used to get the value of any of the input futures
       */
      ClosingFuture&lt;V&gt; call(DeferredCloser closer, Peeker peeker) throws Exception;
    }

    private final boolean allMustSucceed;
    protected final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; inputs;

    private Combiner(boolean allMustSucceed, Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; inputs) {
      this.allMustSucceed = allMustSucceed;
      this.inputs = ImmutableList.copyOf(inputs);
      for (ClosingFuture&lt;?&gt; input : inputs) {
        input.becomeSubsumedInto(closeables);
      }
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * combining function to their values. The function can use a {@link DeferredCloser} to capture
     * objects to be closed when the pipeline is done.
     *
     * &lt;p&gt;If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs
     * fail, so will the returned step.
     *
     * &lt;p&gt;If the combiningCallable throws a {@code CancellationException}, the pipeline will be
     * cancelled.
     *
     * &lt;p&gt;If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown
     * {@code ExecutionException} will be extracted and used as the failure of the derived step.
     */
    public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; call(
        final CombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
      Callable&lt;V&gt; callable =
          new Callable&lt;V&gt;() {
            @Override
            @ParametricNullness
            public V call() throws Exception {
              return new Peeker(inputs).call(combiningCallable, closeables);
            }

            @Override
            public String toString() {
              return combiningCallable.toString();
            }
          };
      ClosingFuture&lt;V&gt; derived = new ClosingFuture&lt;&gt;(futureCombiner().call(callable, executor));
      derived.closeables.add(closeables, directExecutor());
      return derived;
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * {@code ClosingFuture}-returning function to their values. The function can use a {@link
     * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
     * captured by the returned {@link ClosingFuture}).
     *
     * &lt;p&gt;If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs
     * fail, so will the returned step.
     *
     * &lt;p&gt;If the combiningCallable throws a {@code CancellationException}, the pipeline will be
     * cancelled.
     *
     * &lt;p&gt;If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown
     * {@code ExecutionException} will be extracted and used as the failure of the derived step.
     *
     * &lt;p&gt;If the combiningCallable throws any other exception, it will be used as the failure of the
     * derived step.
     *
     * &lt;p&gt;If an exception is thrown after the combiningCallable creates a {@code ClosingFuture},
     * then none of the closeable objects in that {@code ClosingFuture} will be closed.
     *
     * &lt;p&gt;Usage guidelines for this method:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
     *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
     *       Executor)} instead, with a function that returns the next value directly.
     *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     *       closer.eventuallyClose()} for every closeable object this step creates in order to
     *       capture it for later closing.
     *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
     *       ClosingFuture} call {@link #from(ListenableFuture)}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The same warnings about doing heavyweight operations within {@link
     * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
     */
    public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; callAsync(
        final AsyncCombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
      AsyncCallable&lt;V&gt; asyncCallable =
          new AsyncCallable&lt;V&gt;() {
            @Override
            public ListenableFuture&lt;V&gt; call() throws Exception {
              return new Peeker(inputs).callAsync(combiningCallable, closeables);
            }

            @Override
            public String toString() {
              return combiningCallable.toString();
            }
          };
      ClosingFuture&lt;V&gt; derived =
          new ClosingFuture&lt;&gt;(futureCombiner().callAsync(asyncCallable, executor));
      derived.closeables.add(closeables, directExecutor());
      return derived;
    }

    private FutureCombiner&lt;@Nullable Object&gt; futureCombiner() {
      return allMustSucceed
          ? Futures.whenAllSucceed(inputFutures())
          : Futures.whenAllComplete(inputFutures());
    }

    private static final Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt; INNER_FUTURE =
        new Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt;() {
          @Override
          public FluentFuture&lt;?&gt; apply(ClosingFuture&lt;?&gt; future) {
            return future.future;
          }
        };

    private ImmutableList&lt;FluentFuture&lt;?&gt;&gt; inputFutures() {
      return FluentIterable.from(inputs).transform(INNER_FUTURE).toList();
    }
  }

  /**
   * A generic {@link Combiner} that lets you use a lambda or method reference to combine two {@link
   * ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} to start this
   * combination.
   *
   * @param &lt;V1&gt; the type returned by the first future
   * @param &lt;V2&gt; the type returned by the second future
   */
  public static final class Combiner2&lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
      extends Combiner {

    /**
     * A function that returns a value when applied to the values of the two futures passed to
     * {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface ClosingFunction2&lt;
        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {

      /**
       * Applies this function to two inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      @ParametricNullness
      U apply(DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
          throws Exception;
    }

    /**
     * A function that returns a {@link ClosingFuture} when applied to the values of the two futures
     * passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface AsyncClosingFunction2&lt;
        V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {

      /**
       * Applies this function to two inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
          throws Exception;
    }

    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;

    private Combiner2(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
      super(true, ImmutableList.of(future1, future2));
      this.future1 = future1;
      this.future2 = future2;
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * combining function to their values. The function can use a {@link DeferredCloser} to capture
     * objects to be closed when the pipeline is done.
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and
     * any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * {@code ClosingFuture}-returning function to their values. The function can use a {@link
     * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
     * captured by the returned {@link ClosingFuture}).
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and
     * any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     *
     * &lt;p&gt;If the function throws any other exception, it will be used as the failure of the derived
     * step.
     *
     * &lt;p&gt;If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
     * the closeable objects in that {@code ClosingFuture} will be closed.
     *
     * &lt;p&gt;Usage guidelines for this method:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
     *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
     *       Executor)} instead, with a function that returns the next value directly.
     *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     *       closer.eventuallyClose()} for every closeable object this step creates in order to
     *       capture it for later closing.
     *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
     *       ClosingFuture} call {@link #from(ListenableFuture)}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The same warnings about doing heavyweight operations within {@link
     * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }

  /**
   * A generic {@link Combiner} that lets you use a lambda or method reference to combine three
   * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
   * ClosingFuture)} to start this combination.
   *
   * @param &lt;V1&gt; the type returned by the first future
   * @param &lt;V2&gt; the type returned by the second future
   * @param &lt;V3&gt; the type returned by the third future
   */
  public static final class Combiner3&lt;
          V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
      extends Combiner {
    /**
     * A function that returns a value when applied to the values of the three futures passed to
     * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface ClosingFunction3&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to three inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3)
          throws Exception;
    }

    /**
     * A function that returns a {@link ClosingFuture} when applied to the values of the three
     * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface AsyncClosingFunction3&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to three inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3)
          throws Exception;
    }

    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;

    private Combiner3(
        ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
      super(true, ImmutableList.of(future1, future2, future3));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * combining function to their values. The function can use a {@link DeferredCloser} to capture
     * objects to be closed when the pipeline is done.
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture)} and any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * {@code ClosingFuture}-returning function to their values. The function can use a {@link
     * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
     * captured by the returned {@link ClosingFuture}).
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture)} and any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     *
     * &lt;p&gt;If the function throws any other exception, it will be used as the failure of the derived
     * step.
     *
     * &lt;p&gt;If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
     * the closeable objects in that {@code ClosingFuture} will be closed.
     *
     * &lt;p&gt;Usage guidelines for this method:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
     *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
     *       Executor)} instead, with a function that returns the next value directly.
     *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     *       closer.eventuallyClose()} for every closeable object this step creates in order to
     *       capture it for later closing.
     *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
     *       ClosingFuture} call {@link #from(ListenableFuture)}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The same warnings about doing heavyweight operations within {@link
     * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }

  /**
   * A generic {@link Combiner} that lets you use a lambda or method reference to combine four
   * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
   * ClosingFuture)} to start this combination.
   *
   * @param &lt;V1&gt; the type returned by the first future
   * @param &lt;V2&gt; the type returned by the second future
   * @param &lt;V3&gt; the type returned by the third future
   * @param &lt;V4&gt; the type returned by the fourth future
   */
  public static final class Combiner4&lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object&gt;
      extends Combiner {
    /**
     * A function that returns a value when applied to the values of the four futures passed to
     * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;V4&gt; the type returned by the fourth future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface ClosingFunction4&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to four inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4)
          throws Exception;
    }

    /**
     * A function that returns a {@link ClosingFuture} when applied to the values of the four
     * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
     * ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;V4&gt; the type returned by the fourth future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface AsyncClosingFunction4&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to four inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4)
          throws Exception;
    }

    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;
    private final ClosingFuture&lt;V4&gt; future4;

    private Combiner4(
        ClosingFuture&lt;V1&gt; future1,
        ClosingFuture&lt;V2&gt; future2,
        ClosingFuture&lt;V3&gt; future3,
        ClosingFuture&lt;V4&gt; future4) {
      super(true, ImmutableList.of(future1, future2, future3, future4));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
      this.future4 = future4;
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * combining function to their values. The function can use a {@link DeferredCloser} to capture
     * objects to be closed when the pipeline is done.
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * {@code ClosingFuture}-returning function to their values. The function can use a {@link
     * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
     * captured by the returned {@link ClosingFuture}).
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     *
     * &lt;p&gt;If the function throws any other exception, it will be used as the failure of the derived
     * step.
     *
     * &lt;p&gt;If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
     * the closeable objects in that {@code ClosingFuture} will be closed.
     *
     * &lt;p&gt;Usage guidelines for this method:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
     *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
     *       Executor)} instead, with a function that returns the next value directly.
     *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     *       closer.eventuallyClose()} for every closeable object this step creates in order to
     *       capture it for later closing.
     *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
     *       ClosingFuture} call {@link #from(ListenableFuture)}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The same warnings about doing heavyweight operations within {@link
     * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }

  /**
   * A generic {@link Combiner} that lets you use a lambda or method reference to combine five
   * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
   * ClosingFuture, ClosingFuture)} to start this combination.
   *
   * @param &lt;V1&gt; the type returned by the first future
   * @param &lt;V2&gt; the type returned by the second future
   * @param &lt;V3&gt; the type returned by the third future
   * @param &lt;V4&gt; the type returned by the fourth future
   * @param &lt;V5&gt; the type returned by the fifth future
   */
  public static final class Combiner5&lt;
          V1 extends @Nullable Object,
          V2 extends @Nullable Object,
          V3 extends @Nullable Object,
          V4 extends @Nullable Object,
          V5 extends @Nullable Object&gt;
      extends Combiner {
    /**
     * A function that returns a value when applied to the values of the five futures passed to
     * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture,
     * ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;V4&gt; the type returned by the fourth future
     * @param &lt;V5&gt; the type returned by the fifth future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface ClosingFunction5&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        V5 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to five inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      @ParametricNullness
      U apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4,
          @ParametricNullness V5 value5)
          throws Exception;
    }

    /**
     * A function that returns a {@link ClosingFuture} when applied to the values of the five
     * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
     * ClosingFuture, ClosingFuture)}.
     *
     * @param &lt;V1&gt; the type returned by the first future
     * @param &lt;V2&gt; the type returned by the second future
     * @param &lt;V3&gt; the type returned by the third future
     * @param &lt;V4&gt; the type returned by the fourth future
     * @param &lt;V5&gt; the type returned by the fifth future
     * @param &lt;U&gt; the type returned by the function
     */
    public interface AsyncClosingFunction5&lt;
        V1 extends @Nullable Object,
        V2 extends @Nullable Object,
        V3 extends @Nullable Object,
        V4 extends @Nullable Object,
        V5 extends @Nullable Object,
        U extends @Nullable Object&gt; {
      /**
       * Applies this function to five inputs, or throws an exception if unable to do so.
       *
       * &lt;p&gt;Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,
       * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline
       * is done (but not before this method completes), even if this method throws or the pipeline
       * is cancelled.
       */
      ClosingFuture&lt;U&gt; apply(
          DeferredCloser closer,
          @ParametricNullness V1 value1,
          @ParametricNullness V2 value2,
          @ParametricNullness V3 value3,
          @ParametricNullness V4 value4,
          @ParametricNullness V5 value5)
          throws Exception;
    }

    private final ClosingFuture&lt;V1&gt; future1;
    private final ClosingFuture&lt;V2&gt; future2;
    private final ClosingFuture&lt;V3&gt; future3;
    private final ClosingFuture&lt;V4&gt; future4;
    private final ClosingFuture&lt;V5&gt; future5;

    private Combiner5(
        ClosingFuture&lt;V1&gt; future1,
        ClosingFuture&lt;V2&gt; future2,
        ClosingFuture&lt;V3&gt; future3,
        ClosingFuture&lt;V4&gt; future4,
        ClosingFuture&lt;V5&gt; future5) {
      super(true, ImmutableList.of(future1, future2, future3, future4, future5));
      this.future1 = future1;
      this.future2 = future2;
      this.future3 = future3;
      this.future4 = future4;
      this.future5 = future5;
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * combining function to their values. The function can use a {@link DeferredCloser} to capture
     * objects to be closed when the pipeline is done.
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the
     * returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
        final ClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
      return call(
          new CombiningCallable&lt;U&gt;() {
            @Override
            @ParametricNullness
            public U call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4),
                  peeker.getDone(future5));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }

    /**
     * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
     * {@code ClosingFuture}-returning function to their values. The function can use a {@link
     * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
     * captured by the returned {@link ClosingFuture}).
     *
     * &lt;p&gt;If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
     * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the
     * returned step.
     *
     * &lt;p&gt;If the function throws a {@code CancellationException}, the pipeline will be cancelled.
     *
     * &lt;p&gt;If the function throws an {@code ExecutionException}, the cause of the thrown {@code
     * ExecutionException} will be extracted and used as the failure of the derived step.
     *
     * &lt;p&gt;If the function throws any other exception, it will be used as the failure of the derived
     * step.
     *
     * &lt;p&gt;If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
     * the closeable objects in that {@code ClosingFuture} will be closed.
     *
     * &lt;p&gt;Usage guidelines for this method:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;Use this method only when calling an API that returns a {@link ListenableFuture} or a
     *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
     *       Executor)} instead, with a function that returns the next value directly.
     *   &lt;li&gt;Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)
     *       closer.eventuallyClose()} for every closeable object this step creates in order to
     *       capture it for later closing.
     *   &lt;li&gt;Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
     *       ClosingFuture} call {@link #from(ListenableFuture)}.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The same warnings about doing heavyweight operations within {@link
     * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.
     */
    public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
        final AsyncClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
      return callAsync(
          new AsyncCombiningCallable&lt;U&gt;() {
            @Override
            public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
              return function.apply(
                  closer,
                  peeker.getDone(future1),
                  peeker.getDone(future2),
                  peeker.getDone(future3),
                  peeker.getDone(future4),
                  peeker.getDone(future5));
            }

            @Override
            public String toString() {
              return function.toString();
            }
          },
          executor);
    }
  }

  @Override
  public String toString() {
    // TODO(dpb): Better toString, in the style of Futures.transform etc.
    return toStringHelper(this).add("state", state.get()).addValue(future).toString();
  }

  @Override
  protected void finalize() {
    if (state.get().equals(OPEN)) {
      logger.log(SEVERE, "Uh oh! An open ClosingFuture has leaked and will close: {0}", this);
      FluentFuture&lt;V&gt; unused = finishToFuture();
    }
  }

  private static void closeQuietly(@CheckForNull final Closeable closeable, Executor executor) {
    if (closeable == null) {
      return;
    }
    try {
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              try {
                closeable.close();
              } catch (IOException | RuntimeException e) {
                logger.log(WARNING, "thrown by close()", e);
              }
            }
          });
    } catch (RejectedExecutionException e) {
      if (logger.isLoggable(WARNING)) {
        logger.log(
            WARNING, String.format("while submitting close to %s; will close inline", executor), e);
      }
      closeQuietly(closeable, directExecutor());
    }
  }

  private void checkAndUpdateState(State oldState, State newState) {
    checkState(
        compareAndUpdateState(oldState, newState),
        "Expected state to be %s, but it was %s",
        oldState,
        newState);
  }

  private boolean compareAndUpdateState(State oldState, State newState) {
    return state.compareAndSet(oldState, newState);
  }

  // TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?
  private static final class CloseableList extends IdentityHashMap&lt;Closeable, Executor&gt;
      implements Closeable {
    private final DeferredCloser closer = new DeferredCloser(this);
    private volatile boolean closed;
    @CheckForNull private volatile CountDownLatch whenClosed;

    &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
        ListenableFuture&lt;U&gt; applyClosingFunction(
            ClosingFunction&lt;? super V, U&gt; transformation, @ParametricNullness V input)
            throws Exception {
      // TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
      CloseableList newCloseables = new CloseableList();
      try {
        return immediateFuture(transformation.apply(newCloseables.closer, input));
      } finally {
        add(newCloseables, directExecutor());
      }
    }

    &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
        FluentFuture&lt;U&gt; applyAsyncClosingFunction(
            AsyncClosingFunction&lt;V, U&gt; transformation, @ParametricNullness V input)
            throws Exception {
      // TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture&lt;U&gt; closingFuture = transformation.apply(newCloseables.closer, input);
        closingFuture.becomeSubsumedInto(newCloseables);
        return closingFuture.future;
      } finally {
        add(newCloseables, directExecutor());
      }
    }

    @Override
    public void close() {
      if (closed) {
        return;
      }
      synchronized (this) {
        if (closed) {
          return;
        }
        closed = true;
      }
      for (Map.Entry&lt;Closeable, Executor&gt; entry : entrySet()) {
        closeQuietly(entry.getKey(), entry.getValue());
      }
      clear();
      if (whenClosed != null) {
        whenClosed.countDown();
      }
    }

    void add(@CheckForNull Closeable closeable, Executor executor) {
      checkNotNull(executor);
      if (closeable == null) {
        return;
      }
      synchronized (this) {
        if (!closed) {
          put(closeable, executor);
          return;
        }
      }
      closeQuietly(closeable, executor);
    }

    /**
     * Returns a latch that reaches zero when this objects' deferred closeables have been closed.
     */
    CountDownLatch whenClosedCountDown() {
      if (closed) {
        return new CountDownLatch(0);
      }
      synchronized (this) {
        if (closed) {
          return new CountDownLatch(0);
        }
        checkState(whenClosed == null);
        return whenClosed = new CountDownLatch(1);
      }
    }
  }

  /**
   * Returns an object that can be used to wait until this objects' deferred closeables have all had
   * {@link Runnable}s that close them submitted to each one's closing {@link Executor}.
   */
  @VisibleForTesting
  CountDownLatch whenClosedCountDown() {
    return closeables.whenClosedCountDown();
  }

  /** The state of a {@link CloseableList}. */
  enum State {
    /** The {@link CloseableList} has not been subsumed or closed. */
    OPEN,

    /**
     * The {@link CloseableList} has been subsumed into another. It may not be closed or subsumed
     * into any other.
     */
    SUBSUMED,

    /**
     * Some {@link ListenableFuture} has a callback attached that will close the {@link
     * CloseableList}, but it has not yet run. The {@link CloseableList} may not be subsumed.
     */
    WILL_CLOSE,

    /**
     * The callback that closes the {@link CloseableList} is running, but it has not completed. The
     * {@link CloseableList} may not be subsumed.
     */
    CLOSING,

    /** The {@link CloseableList} has been closed. It may not be further subsumed. */
    CLOSED,

    /**
     * {@link ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)} has been
     * called. The step may not be further subsumed, nor may {@link #finishToFuture()} be called.
     */
    WILL_CREATE_VALUE_AND_CLOSER,
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
