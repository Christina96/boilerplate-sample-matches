<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableDoubleArray.java &amp; ClosingFuture.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableDoubleArray.java (14.61039%)<th>ClosingFuture.java (5.260082%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-81)<td><a href="#" name="0">(50-194)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(485-494)<td><a href="#" name="1">(601-610)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(518-526)<td><a href="#" name="2">(463-483)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(455-458)<td><a href="#" name="3">(831-834)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(426-435)<td><a href="#" name="4">(333-360)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(435-440)<td><a href="#" name="5">(694-699)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(252-261)<td><a href="#" name="6">(1136-1141)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(115-119)<td><a href="#" name="7">(565-580)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableDoubleArray.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.primitives;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
4 import com.google.common.annotations.Beta;
5 import com.google.common.annotations.GwtCompatible;
6 import com.google.common.base.Preconditions;
7 import com.google.errorprone.annotations.CanIgnoreReturnValue;
8 import com.google.errorprone.annotations.CheckReturnValue;
9 import com.google.errorprone.annotations.Immutable;
10 import java.io.Serializable;
11 import java.util.AbstractList;
12 import java.util.Arrays;
13 import java.util.Collection;
14 import java.util.List;
15 import java.util.RandomAccess;
16 import javax.annotation.CheckForNull;
17 @Beta
18 @</b></font>GwtCompatible
19 @Immutable
20 @ElementTypesAreNonnullByDefault
21 public final class ImmutableDoubleArray implements Serializable {
22   private static final ImmutableDoubleArray EMPTY = new ImmutableDoubleArray(new double[0]);
23   public static ImmutableDoubleArray of() {
24     return EMPTY;
25   }
26   public static ImmutableDoubleArray of(double e0) {
27     return new ImmutableDoubleArray(new double[] {e0});
28   }
29   public static ImmutableDoubleArray of(double e0, double e1) {
30     return new ImmutableDoubleArray(new double[] {e0, e1});
31   }
32   public static ImmutableDoubleArray of(double e0, double e1, double e2) {
33     return new ImmutableDoubleArray(new double[] {e0, e1, e2});
34   }
35   public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3) {
36     return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3});
37   }
38 <a name="7"></a>    public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3, double e4) {
39     return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4});
40   <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
41   public static ImmutableDoubleArray of(
42       double e0, double e1, double e2, double e3, double e4, double e5</b></font>) {
43     return new ImmutableDoubleArray(new double[] {e0, e1, e2, e3, e4, e5});
44   }
45   public static ImmutableDoubleArray of(double first, double... rest) {
46     checkArgument(
47         rest.length &lt;= Integer.MAX_VALUE - 1, "the total number of elements must fit in an int");
48     double[] array = new double[rest.length + 1];
49     array[0] = first;
50     System.arraycopy(rest, 0, array, 1, rest.length);
51     return new ImmutableDoubleArray(array);
52   }
53   public static ImmutableDoubleArray copyOf(double[] values) {
54     return values.length == 0
55         ? EMPTY
56         : new ImmutableDoubleArray(Arrays.copyOf(values, values.length));
57   }
58   public static ImmutableDoubleArray copyOf(Collection&lt;Double&gt; values) {
59     return values.isEmpty() ? EMPTY : new ImmutableDoubleArray(Doubles.toArray(values));
60   }
61   public static ImmutableDoubleArray copyOf(Iterable&lt;Double&gt; values) {
62     if (values instanceof Collection) {
63       return copyOf((Collection&lt;Double&gt;) values);
64     }
65     return builder().addAll(values).build();
66   }
67   public static Builder builder(int initialCapacity) {
68     checkArgument(initialCapacity &gt;= 0, "Invalid initialCapacity: %s", initialCapacity);
69     return new Builder(initialCapacity);
70   }
71   public static Builder builder() {
72     return new Builder(10);
73   }
74   @CanIgnoreReturnValue
75   public static final class Builder {
76     private double[] array;
77     private int count = 0; 
78     Builder(int initialCapacity) {
79       array = new double[initialCapacity];
80     }
81     public Builder add(double value) {
82       ensureRoomFor(1);
83       array[count] = value;
84       count += 1;
85       return this;
86     }
87     public Builder addAll(double[] values) {
88       ensureRoomFor(values.length);
89       System.arraycopy(values, 0, array, count, values.length);
90       count += values.length;
91       return this;
92     }
93     public Builder addAll(Iterable&lt;Double&gt; values) {
94       if (values instanceof Collection) {
95         return addAll((Collection&lt;Double&gt;) values);
96       }
97       for (Double value : values) {
98         add(value);
99       }
100       return this;
101     }
102     public Builder addAll(Collection&lt;Double&gt; values) {
103       ensureRoomFor(values.size());
104 <a name="6"></a>      for (Double value : values) {
105         array[count++] = value;
106       }
107       <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return this;
108     }
109     public Builder addAll(ImmutableDoubleArray values) {
110       ensureRoomFor(values.length());
111       System.arraycopy</b></font>(values.array, values.start, array, count, values.length());
112       count += values.length();
113       return this;
114     }
115     private void ensureRoomFor(int numberToAdd) {
116       int newCount = count + numberToAdd;       if (newCount &gt; array.length) {
117         array = Arrays.copyOf(array, expandedCapacity(array.length, newCount));
118       }
119     }
120     private static int expandedCapacity(int oldCapacity, int minCapacity) {
121       if (minCapacity &lt; 0) {
122         throw new AssertionError("cannot store more than MAX_VALUE elements");
123       }
124       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) + 1;
125       if (newCapacity &lt; minCapacity) {
126         newCapacity = Integer.highestOneBit(minCapacity - 1) &lt;&lt; 1;
127       }
128       if (newCapacity &lt; 0) {
129         newCapacity = Integer.MAX_VALUE;       }
130       return newCapacity;
131     }
132     @CheckReturnValue
133     public ImmutableDoubleArray build() {
134       return count == 0 ? EMPTY : new ImmutableDoubleArray(array, 0, count);
135     }
136   }
137   @SuppressWarnings("Immutable")
138   private final double[] array;
139   private final transient int start;   private final int end; 
140   private ImmutableDoubleArray(double[] array) {
141     this(array, 0, array.length);
142   }
143   private ImmutableDoubleArray(double[] array, int start, int end) {
144     this.array = array;
145     this.start = start;
146     this.end = end;
147   }
148   public int length() {
149     return end - start;
150   }
151   public boolean isEmpty() {
152     return end == start;
153   }
154   public double get(int index) {
155     Preconditions.checkElementIndex(index, length());
156     return array[start + index];
157   }
158   public int indexOf(double target) {
159     for (int i = start; i &lt; end; i++) {
160       if (areEqual(array[i], target)) {
161         return i - start;
162       }
163     }
164     return -1;
165   }
166   public int lastIndexOf(double target) {
167     for (int i = end - 1; i &gt;= start; i--) {
168       if (areEqual(array[i], target)) {
169         return i - start;
170       }
171     }
172     return -1;
173   }
174   public boolean contains(double target) {
175     return indexOf(target) &gt;= 0;
176   }
177   public double[] toArray() {
178     return Arrays.copyOfRange(array, start, end);
179   }
180   public ImmutableDoubleArray subArray(int startIndex, int endIndex) {
181     Preconditions.checkPositionIndexes(startIndex, endIndex, length());
182     return startIndex == endIndex
183         ? EMPTY
184         : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);
185   }
186   public List&lt;Double&gt; asList() {
187     return new AsList(this);
188   }
189   static class AsList extends AbstractList&lt;Double&gt; implements RandomAccess, Serializable {
190     private final ImmutableDoubleArray parent;
191 <a name="4"></a>
192     private AsList(ImmutableDoubleArray parent) {
193       this.parent = parent;
194     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
195     @Override
196     public int size() {
197 <a name="5"></a>      return parent.length();
198     }
199     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Ov</b></font>erride
200     public Double get(int index) {
201       return parent.get(index);
202     }
203     @</b></font>Override
204     public boolean contains(@CheckForNull Object target) {
205       return indexOf(target) &gt;= 0;
206     }
207     @Override
208     public int indexOf(@CheckForNull Object target) {
209       return target instanceof Double ? parent.indexOf((Double) target) : -1;
210     }
211     @Override
212     public int lastIndexOf(@CheckForNull Object target) {
213 <a name="3"></a>      return target instanceof Double ? parent.lastIndexOf((Double) target) : -1;
214     }
215     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
216     public List&lt;Double&gt; subList(int fromIndex, int toIndex) {
217       return parent.subArray(fromIndex, toIndex).asList();
218     }</b></font>
219     @Override
220     public boolean equals(@CheckForNull Object object) {
221       if (object instanceof AsList) {
222         AsList that = (AsList) object;
223         return this.parent.equals(that.parent);
224       }
225       if (!(object instanceof List)) {
226         return false;
227       }
228       List&lt;?&gt; that = (List&lt;?&gt;) object;
229       if (this.size() != that.size()) {
230         return false;
231       }
232       int i = parent.start;
233       for (Object element : that) {
234         if (!(element instanceof Double) || !areEqual(parent.array[i++], (Double) element)) {
235           return false;
236         }
237       }
238       return true;
239 <a name="1"></a>    }
240     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
241     public int hashCode() {
242       return parent.hashCode();
243     }
244     @Override
245     public String toString() {
246       return parent.toString();
247     }
248   }</b></font>
249   @Override
250   public boolean equals(@CheckForNull Object object) {
251     if (object == this) {
252       return true;
253     }
254     if (!(object instanceof ImmutableDoubleArray)) {
255       return false;
256     }
257     ImmutableDoubleArray that = (ImmutableDoubleArray) object;
258     if (this.length() != that.length()) {
259       return false;
260     }
261     for (int i = 0; i &lt; length(); i++) {
262       if (!areEqual(this.get(i), that.get(i))) {
263         return false;
264 <a name="2"></a>      }
265     }
266     return true;
267   <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
268   private static boolean areEqual(double a, double b) {
269     return Double.doubleToLongBits(a) == Double.doubleToLongBits(b);
270   }
271   @Overrid</b></font>e
272   public int hashCode() {
273     int hash = 1;
274     for (int i = start; i &lt; end; i++) {
275       hash *= 31;
276       hash += Doubles.hashCode(array[i]);
277     }
278     return hash;
279   }
280   @Override
281   public String toString() {
282     if (isEmpty()) {
283       return "[]";
284     }
285     StringBuilder builder = new StringBuilder(length() * 5);     builder.append('[').append(array[start]);
286     for (int i = start + 1; i &lt; end; i++) {
287       builder.append(", ").append(array[i]);
288     }
289     builder.append(']');
290     return builder.toString();
291   }
292   public ImmutableDoubleArray trimmed() {
293     return isPartialView() ? new ImmutableDoubleArray(toArray()) : this;
294   }
295   private boolean isPartialView() {
296     return start &gt; 0 || end &lt; array.length;
297   }
298   Object writeReplace() {
299     return trimmed();
300   }
301   Object readResolve() {
302     return isEmpty() ? EMPTY : this;
303   }
304 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClosingFuture.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.util.concurrent;
2 import static com.google.common.base.Functions.constant;
3 import static com.google.common.base.MoreObjects.toStringHelper;
4 import static com.google.common.base.Preconditions.checkArgument;
5 import static com.google.common.base.Preconditions.checkNotNull;
6 import static com.google.common.base.Preconditions.checkState;
7 import static com.google.common.collect.Lists.asList;
8 import static com.google.common.util.concurrent.ClosingFuture.State.CLOSED;
9 import static com.google.common.util.concurrent.ClosingFuture.State.CLOSING;
10 import static com.google.common.util.concurrent.ClosingFuture.State.OPEN;
11 import static com.google.common.util.concurrent.ClosingFuture.State.SUBSUMED;
12 import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CLOSE;
13 import static com.google.common.util.concurrent.ClosingFuture.State.WILL_CREATE_VALUE_AND_CLOSER;
14 import static com.google.common.util.concurrent.Futures.getDone;
15 import static com.google.common.util.concurrent.Futures.immediateFuture;
16 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
17 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
18 import static java.util.logging.Level.FINER;
19 import static java.util.logging.Level.SEVERE;
20 import static java.util.logging.Level.WARNING;
21 import com.google.common.annotations.VisibleForTesting;
22 import com.google.common.base.Function;
23 import com.google.common.collect.FluentIterable;
24 import com.google.common.collect.ImmutableList;
25 import com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable;
26 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
27 import com.google.common.util.concurrent.Futures.FutureCombiner;
28 import com.google.errorprone.annotations.CanIgnoreReturnValue;
29 <a name="0"></a>import com.google.errorprone.annotations.DoNotMock;
30 import com.google.j2objc.annotations.RetainedWith;
31 import java.io.Closeable;
32 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.IOException;
33 import java.util.IdentityHashMap;
34 import java.util.Map;
35 import java.util.concurrent.Callable;
36 import java.util.concurrent.CancellationException;
37 import java.util.concurrent.CountDownLatch;
38 import java.util.concurrent.ExecutionException;
39 import java.util.concurrent.Executor;
40 import java.util.concurrent.Future;
41 import java.util.concurrent.RejectedExecutionException;
42 import java.util.concurrent.atomic.AtomicReference;
43 import java.util.logging.Logger;
44 import javax.annotation.CheckForNull;
45 import org.checkerframework.checker.nullness.qual.Nullable;
46 @DoNotMock("Use ClosingFuture.from(Futures.immediate*Future)")
47 @</b></font>ElementTypesAreNonnullByDefault
48 public final class ClosingFuture&lt;V extends @Nullable Object&gt; {
49   private static final Logger logger = Logger.getLogger(ClosingFuture.class.getName());
50   public static final class DeferredCloser {
51     @RetainedWith private final CloseableList list;
52     DeferredCloser(CloseableList list) {
53       this.list = list;
54     }
55     @CanIgnoreReturnValue
56     @ParametricNullness
57     public &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt; C eventuallyClose(
58         @ParametricNullness C closeable, Executor closingExecutor) {
59       checkNotNull(closingExecutor);
60       if (closeable != null) {
61         list.add(closeable, closingExecutor);
62       }
63       return closeable;
64     }
65   }
66   public interface ClosingCallable&lt;V extends @Nullable Object&gt; {
67     @ParametricNullness
68     V call(DeferredCloser closer) throws Exception;
69   }
70   public interface AsyncClosingCallable&lt;V extends @Nullable Object&gt; {
71     ClosingFuture&lt;V&gt; call(DeferredCloser closer) throws Exception;
72   }
73   public interface ClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {
74     @ParametricNullness
75     U apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
76   }
77   public interface AsyncClosingFunction&lt;T extends @Nullable Object, U extends @Nullable Object&gt; {
78     ClosingFuture&lt;U&gt; apply(DeferredCloser closer, @ParametricNullness T input) throws Exception;
79   }
80   public static final class ValueAndCloser&lt;V extends @Nullable Object&gt; {
81     private final ClosingFuture&lt;? extends V&gt; closingFuture;
82 <a name="4"></a>
83     ValueAndCloser(ClosingFuture&lt;? extends V&gt; closingFuture) {
84       this.closingFuture = checkNotNull(closingFuture);
85     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
86     @ParametricNullness
87     public V get() throws ExecutionException {
88       return getDone(closingFuture.future);
89     }
90     public voi</b></font>d closeAsync() {
91       closingFuture.close();
92     }
93   }
94   public interface ValueAndCloserConsumer&lt;V extends @Nullable Object&gt; {
95     void accept(ValueAndCloser&lt;V&gt; valueAndCloser);
96   }
97   public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submit(
98       ClosingCallable&lt;V&gt; callable, Executor executor) {
99     return new ClosingFuture&lt;&gt;(callable, executor);
100   }
101   public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; submitAsync(
102       AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
103     return new ClosingFuture&lt;&gt;(callable, executor);
104   }
105   public static &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; from(ListenableFuture&lt;V&gt; future) {
106     return new ClosingFuture&lt;V&gt;(future);
107   }
108   @Deprecated
109   public static &lt;C extends @Nullable Object &amp; @Nullable Closeable&gt;
110       ClosingFuture&lt;C&gt; eventuallyClosing(
111           ListenableFuture&lt;C&gt; future, final Executor closingExecutor) {
112     checkNotNull(closingExecutor);
113     final ClosingFuture&lt;C&gt; closingFuture = new ClosingFuture&lt;&gt;(nonCancellationPropagating(future));
114     Futures.addCallback(
115         future,
116         new FutureCallback&lt;@Nullable Closeable&gt;() {
117           @Override
118           public void onSuccess(@CheckForNull Closeable result) {
119             closingFuture.closeables.closer.eventuallyClose(result, closingExecutor);
120           }
121           @Override
122           public void onFailure(Throwable t) {}
123         },
124         directExecutor());
125     return closingFuture;
126   }
127   public static Combiner whenAllComplete(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
128     return new Combiner(false, futures);
129   <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
130   public static Combiner whenAllComplete(
131       ClosingFuture&lt;?&gt; future1, ClosingFuture&lt;?&gt;... moreFutures) {
132     return whenAllComplete(asList(future1, moreFutures));
133   }
134   public static </b></font>Combiner whenAllSucceed(Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; futures) {
135     return new Combiner(true, futures);
136   }
137   public static &lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
138       Combiner2&lt;V1, V2&gt; whenAllSucceed(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
139     return new Combiner2&lt;&gt;(future1, future2);
140   }
141   public static &lt;
142           V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
143       Combiner3&lt;V1, V2, V3&gt; whenAllSucceed(
144           ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
145     return new Combiner3&lt;&gt;(future1, future2, future3);
146   }
147   public static &lt;
148           V1 extends @Nullable Object,
149           V2 extends @Nullable Object,
150           V3 extends @Nullable Object,
151           V4 extends @Nullable Object&gt;
152       Combiner4&lt;V1, V2, V3, V4&gt; whenAllSucceed(
153           ClosingFuture&lt;V1&gt; future1,
154           ClosingFuture&lt;V2&gt; future2,
155           ClosingFuture&lt;V3&gt; future3,
156           ClosingFuture&lt;V4&gt; future4) {
157     return new Combiner4&lt;&gt;(future1, future2, future3, future4);
158   }
159   public static &lt;
160           V1 extends @Nullable Object,
161           V2 extends @Nullable Object,
162           V3 extends @Nullable Object,
163           V4 extends @Nullable Object,
164           V5 extends @Nullable Object&gt;
165       Combiner5&lt;V1, V2, V3, V4, V5&gt; whenAllSucceed(
166           ClosingFuture&lt;V1&gt; future1,
167           ClosingFuture&lt;V2&gt; future2,
168           ClosingFuture&lt;V3&gt; future3,
169 <a name="7"></a>          ClosingFuture&lt;V4&gt; future4,
170           ClosingFuture&lt;V5&gt; future5) {
171     return new Combiner5&lt;&gt;(future1, future2, future3, future4, future5);
172   <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
173   public static Combiner whenAllSucceed(
174       ClosingFuture&lt;?&gt; future1,
175       ClosingFuture&lt;?&gt; future2,
176       ClosingFuture&lt;?&gt; future3,
177       ClosingFuture&lt;?&gt; future4,
178       ClosingFuture&lt;?&gt; future5,
179       ClosingFuture&lt;?&gt; future6</b></font>,
180       ClosingFuture&lt;?&gt;... moreFutures) {
181     return whenAllSucceed(
182         FluentIterable.of(future1, future2, future3, future4, future5, future6)
183             .append(moreFutures));
184   }
185   private final AtomicReference&lt;State&gt; state = new AtomicReference&lt;&gt;(OPEN);
186   private final CloseableList closeables = new CloseableList();
187   private final FluentFuture&lt;V&gt; future;
188   private ClosingFuture(ListenableFuture&lt;V&gt; future) {
189     this.future = FluentFuture.from(future);
190   }
191   private ClosingFuture(final ClosingCallable&lt;V&gt; callable, Executor executor) {
192     checkNotNull(callable);
193     TrustedListenableFutureTask&lt;V&gt; task =
194 <a name="1"></a>        TrustedListenableFutureTask.create(
195             new Callable&lt;V&gt;() {
196               @Override
197               <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@ParametricNullness
198               public V call() throws Exception {
199                 return callable.call(closeables.closer);
200               }
201               @Override
202               public String toString() {
203                 return callable.toString();
204               }
205             }</b></font>);
206     executor.execute(task);
207     this.future = task;
208   }
209   private ClosingFuture(final AsyncClosingCallable&lt;V&gt; callable, Executor executor) {
210     checkNotNull(callable);
211     TrustedListenableFutureTask&lt;V&gt; task =
212         TrustedListenableFutureTask.create(
213             new AsyncCallable&lt;V&gt;() {
214               @Override
215               public ListenableFuture&lt;V&gt; call() throws Exception {
216                 CloseableList newCloseables = new CloseableList();
217                 try {
218                   ClosingFuture&lt;V&gt; closingFuture = callable.call(newCloseables.closer);
219                   closingFuture.becomeSubsumedInto(closeables);
220                   return closingFuture.future;
221                 } finally {
222                   closeables.add(newCloseables, directExecutor());
223                 }
224               }
225               @Override
226               public String toString() {
227                 return callable.toString();
228               }
229             });
230     executor.execute(task);
231     this.future = task;
232   }
233   public ListenableFuture&lt;?&gt; statusFuture() {
234     return nonCancellationPropagating(future.transform(constant(null), directExecutor()));
235   }
236   public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transform(
237       final ClosingFunction&lt;? super V, U&gt; function, Executor executor) {
238 <a name="5"></a>    checkNotNull(function);
239     AsyncFunction&lt;V, U&gt; applyFunction =
240         new AsyncFunction&lt;V, U&gt;() {
241           <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
242           public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
243             return closeables.applyClosingFunction(function, input);
244           }
245           @</b></font>Override
246           public String toString() {
247             return function.toString();
248           }
249         };
250     return derive(future.transformAsync(applyFunction, executor));
251   }
252   public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; transformAsync(
253       final AsyncClosingFunction&lt;? super V, U&gt; function, Executor executor) {
254     checkNotNull(function);
255     AsyncFunction&lt;V, U&gt; applyFunction =
256         new AsyncFunction&lt;V, U&gt;() {
257           @Override
258           public ListenableFuture&lt;U&gt; apply(V input) throws Exception {
259             return closeables.applyAsyncClosingFunction(function, input);
260           }
261           @Override
262           public String toString() {
263             return function.toString();
264           }
265         };
266     return derive(future.transformAsync(applyFunction, executor));
267   }
268   public static &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
269 <a name="3"></a>      AsyncClosingFunction&lt;V, U&gt; withoutCloser(final AsyncFunction&lt;V, U&gt; function) {
270     checkNotNull(function);
271     return new AsyncClosingFunction&lt;V, U&gt;() {
272       <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
273       public ClosingFuture&lt;U&gt; apply(DeferredCloser closer, V input) throws Exception {
274         return ClosingFuture.from(function.apply(input));
275       }</b></font>
276     };
277   }
278   public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catching(
279       Class&lt;X&gt; exceptionType, ClosingFunction&lt;? super X, ? extends V&gt; fallback, Executor executor) {
280     return catchingMoreGeneric(exceptionType, fallback, executor);
281   }
282   private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingMoreGeneric(
283       Class&lt;X&gt; exceptionType, final ClosingFunction&lt;? super X, W&gt; fallback, Executor executor) {
284     checkNotNull(fallback);
285     AsyncFunction&lt;X, W&gt; applyFallback =
286         new AsyncFunction&lt;X, W&gt;() {
287           @Override
288           public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
289             return closeables.applyClosingFunction(fallback, exception);
290           }
291           @Override
292           public String toString() {
293             return fallback.toString();
294           }
295         };
296     return derive(future.catchingAsync(exceptionType, applyFallback, executor));
297   }
298   public &lt;X extends Throwable&gt; ClosingFuture&lt;V&gt; catchingAsync(
299       Class&lt;X&gt; exceptionType,
300       AsyncClosingFunction&lt;? super X, ? extends V&gt; fallback,
301       Executor executor) {
302     return catchingAsyncMoreGeneric(exceptionType, fallback, executor);
303   }
304   private &lt;X extends Throwable, W extends V&gt; ClosingFuture&lt;V&gt; catchingAsyncMoreGeneric(
305       Class&lt;X&gt; exceptionType,
306       final AsyncClosingFunction&lt;? super X, W&gt; fallback,
307       Executor executor) {
308     checkNotNull(fallback);
309     AsyncFunction&lt;X, W&gt; asyncFunction =
310         new AsyncFunction&lt;X, W&gt;() {
311           @Override
312           public ListenableFuture&lt;W&gt; apply(X exception) throws Exception {
313             return closeables.applyAsyncClosingFunction(fallback, exception);
314           }
315           @Override
316           public String toString() {
317             return fallback.toString();
318           }
319         };
320     return derive(future.catchingAsync(exceptionType, asyncFunction, executor));
321   }
322   public FluentFuture&lt;V&gt; finishToFuture() {
323     if (compareAndUpdateState(OPEN, WILL_CLOSE)) {
324       logger.log(FINER, "will close {0}", this);
325       future.addListener(
326           new Runnable() {
327             @Override
328             public void run() {
329               checkAndUpdateState(WILL_CLOSE, CLOSING);
330               close();
331               checkAndUpdateState(CLOSING, CLOSED);
332             }
333           },
334           directExecutor());
335     } else {
336       switch (state.get()) {
337         case SUBSUMED:
338           throw new IllegalStateException(
339               "Cannot call finishToFuture() after deriving another step");
340         case WILL_CREATE_VALUE_AND_CLOSER:
341           throw new IllegalStateException(
342               "Cannot call finishToFuture() after calling finishToValueAndCloser()");
343         case WILL_CLOSE:
344         case CLOSING:
345         case CLOSED:
346           throw new IllegalStateException("Cannot call finishToFuture() twice");
347         case OPEN:
348           throw new AssertionError();
349       }
350     }
351     return future;
352   }
353   public void finishToValueAndCloser(
354       final ValueAndCloserConsumer&lt;? super V&gt; consumer, Executor executor) {
355     checkNotNull(consumer);
356     if (!compareAndUpdateState(OPEN, WILL_CREATE_VALUE_AND_CLOSER)) {
357       switch (state.get()) {
358         case SUBSUMED:
359           throw new IllegalStateException(
360               "Cannot call finishToValueAndCloser() after deriving another step");
361         case WILL_CLOSE:
362         case CLOSING:
363         case CLOSED:
364           throw new IllegalStateException(
365               "Cannot call finishToValueAndCloser() after calling finishToFuture()");
366         case WILL_CREATE_VALUE_AND_CLOSER:
367           throw new IllegalStateException("Cannot call finishToValueAndCloser() twice");
368         case OPEN:
369           break;
370       }
371       throw new AssertionError(state);
372     }
373     future.addListener(
374         new Runnable() {
375           @Override
376           public void run() {
377             provideValueAndCloser(consumer, ClosingFuture.this);
378           }
379         },
380         executor);
381   }
382   private static &lt;C extends @Nullable Object, V extends C&gt; void provideValueAndCloser(
383       ValueAndCloserConsumer&lt;C&gt; consumer, ClosingFuture&lt;V&gt; closingFuture) {
384     consumer.accept(new ValueAndCloser&lt;C&gt;(closingFuture));
385   }
386   @CanIgnoreReturnValue
387   public boolean cancel(boolean mayInterruptIfRunning) {
388     logger.log(FINER, "cancelling {0}", this);
389     boolean cancelled = future.cancel(mayInterruptIfRunning);
390     if (cancelled) {
391       close();
392     }
393     return cancelled;
394   }
395   private void close() {
396     logger.log(FINER, "closing {0}", this);
397     closeables.close();
398   }
399 <a name="6"></a>  private &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; derive(FluentFuture&lt;U&gt; future) {
400     ClosingFuture&lt;U&gt; derived = new ClosingFuture&lt;&gt;(future);
401     becomeSubsumedInto(derived.closeables);
402     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return derived;
403   }
404   private void becomeSubsumedInto(CloseableList otherCloseables) {
405     checkAndUpdateState(OPEN, SUBSUMED);
406     otherCloseables.add(closeables, directExecutor</b></font>());
407   }
408   public static final class Peeker {
409     private final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures;
410     private volatile boolean beingCalled;
411     private Peeker(ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; futures) {
412       this.futures = checkNotNull(futures);
413     }
414     @ParametricNullness
415     public final &lt;D extends @Nullable Object&gt; D getDone(ClosingFuture&lt;D&gt; closingFuture)
416         throws ExecutionException {
417       checkState(beingCalled);
418       checkArgument(futures.contains(closingFuture));
419       return Futures.getDone(closingFuture.future);
420     }
421     @ParametricNullness
422     private &lt;V extends @Nullable Object&gt; V call(
423         CombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
424       beingCalled = true;
425       CloseableList newCloseables = new CloseableList();
426       try {
427         return combiner.call(newCloseables.closer, this);
428       } finally {
429         closeables.add(newCloseables, directExecutor());
430         beingCalled = false;
431       }
432     }
433     private &lt;V extends @Nullable Object&gt; FluentFuture&lt;V&gt; callAsync(
434         AsyncCombiningCallable&lt;V&gt; combiner, CloseableList closeables) throws Exception {
435       beingCalled = true;
436       CloseableList newCloseables = new CloseableList();
437       try {
438         ClosingFuture&lt;V&gt; closingFuture = combiner.call(newCloseables.closer, this);
439         closingFuture.becomeSubsumedInto(closeables);
440         return closingFuture.future;
441       } finally {
442         closeables.add(newCloseables, directExecutor());
443         beingCalled = false;
444       }
445     }
446   }
447   @com.google.errorprone.annotations.DoNotMock(
448       "Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead.")
449   public static class Combiner {
450     private final CloseableList closeables = new CloseableList();
451     public interface CombiningCallable&lt;V extends @Nullable Object&gt; {
452       @ParametricNullness
453       V call(DeferredCloser closer, Peeker peeker) throws Exception;
454     }
455     public interface AsyncCombiningCallable&lt;V extends @Nullable Object&gt; {
456       ClosingFuture&lt;V&gt; call(DeferredCloser closer, Peeker peeker) throws Exception;
457     }
458     private final boolean allMustSucceed;
459     protected final ImmutableList&lt;ClosingFuture&lt;?&gt;&gt; inputs;
460     private Combiner(boolean allMustSucceed, Iterable&lt;? extends ClosingFuture&lt;?&gt;&gt; inputs) {
461       this.allMustSucceed = allMustSucceed;
462       this.inputs = ImmutableList.copyOf(inputs);
463       for (ClosingFuture&lt;?&gt; input : inputs) {
464         input.becomeSubsumedInto(closeables);
465       }
466     }
467     public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; call(
468         final CombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
469       Callable&lt;V&gt; callable =
470           new Callable&lt;V&gt;() {
471             @Override
472             @ParametricNullness
473             public V call() throws Exception {
474               return new Peeker(inputs).call(combiningCallable, closeables);
475             }
476             @Override
477             public String toString() {
478               return combiningCallable.toString();
479             }
480           };
481       ClosingFuture&lt;V&gt; derived = new ClosingFuture&lt;&gt;(futureCombiner().call(callable, executor));
482       derived.closeables.add(closeables, directExecutor());
483       return derived;
484     }
485     public &lt;V extends @Nullable Object&gt; ClosingFuture&lt;V&gt; callAsync(
486         final AsyncCombiningCallable&lt;V&gt; combiningCallable, Executor executor) {
487       AsyncCallable&lt;V&gt; asyncCallable =
488           new AsyncCallable&lt;V&gt;() {
489             @Override
490             public ListenableFuture&lt;V&gt; call() throws Exception {
491               return new Peeker(inputs).callAsync(combiningCallable, closeables);
492             }
493             @Override
494             public String toString() {
495               return combiningCallable.toString();
496             }
497           };
498       ClosingFuture&lt;V&gt; derived =
499           new ClosingFuture&lt;&gt;(futureCombiner().callAsync(asyncCallable, executor));
500       derived.closeables.add(closeables, directExecutor());
501       return derived;
502     }
503     private FutureCombiner&lt;@Nullable Object&gt; futureCombiner() {
504       return allMustSucceed
505           ? Futures.whenAllSucceed(inputFutures())
506           : Futures.whenAllComplete(inputFutures());
507     }
508     private static final Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt; INNER_FUTURE =
509         new Function&lt;ClosingFuture&lt;?&gt;, FluentFuture&lt;?&gt;&gt;() {
510           @Override
511           public FluentFuture&lt;?&gt; apply(ClosingFuture&lt;?&gt; future) {
512             return future.future;
513           }
514         };
515     private ImmutableList&lt;FluentFuture&lt;?&gt;&gt; inputFutures() {
516       return FluentIterable.from(inputs).transform(INNER_FUTURE).toList();
517     }
518   }
519   public static final class Combiner2&lt;V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
520       extends Combiner {
521     public interface ClosingFunction2&lt;
522         V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {
523       @ParametricNullness
524       U apply(DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
525           throws Exception;
526     }
527     public interface AsyncClosingFunction2&lt;
528         V1 extends @Nullable Object, V2 extends @Nullable Object, U extends @Nullable Object&gt; {
529       ClosingFuture&lt;U&gt; apply(
530           DeferredCloser closer, @ParametricNullness V1 value1, @ParametricNullness V2 value2)
531           throws Exception;
532     }
533     private final ClosingFuture&lt;V1&gt; future1;
534     private final ClosingFuture&lt;V2&gt; future2;
535     private Combiner2(ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2) {
536       super(true, ImmutableList.of(future1, future2));
537       this.future1 = future1;
538       this.future2 = future2;
539     }
540     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
541         final ClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
542       return call(
543           new CombiningCallable&lt;U&gt;() {
544             @Override
545             @ParametricNullness
546             public U call(DeferredCloser closer, Peeker peeker) throws Exception {
547               return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
548             }
549             @Override
550             public String toString() {
551               return function.toString();
552             }
553           },
554           executor);
555     }
556     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
557         final AsyncClosingFunction2&lt;V1, V2, U&gt; function, Executor executor) {
558       return callAsync(
559           new AsyncCombiningCallable&lt;U&gt;() {
560             @Override
561             public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
562               return function.apply(closer, peeker.getDone(future1), peeker.getDone(future2));
563             }
564             @Override
565             public String toString() {
566               return function.toString();
567             }
568           },
569           executor);
570     }
571   }
572   public static final class Combiner3&lt;
573           V1 extends @Nullable Object, V2 extends @Nullable Object, V3 extends @Nullable Object&gt;
574       extends Combiner {
575     public interface ClosingFunction3&lt;
576         V1 extends @Nullable Object,
577         V2 extends @Nullable Object,
578         V3 extends @Nullable Object,
579         U extends @Nullable Object&gt; {
580       @ParametricNullness
581       U apply(
582           DeferredCloser closer,
583           @ParametricNullness V1 value1,
584           @ParametricNullness V2 value2,
585           @ParametricNullness V3 value3)
586           throws Exception;
587     }
588     public interface AsyncClosingFunction3&lt;
589         V1 extends @Nullable Object,
590         V2 extends @Nullable Object,
591         V3 extends @Nullable Object,
592         U extends @Nullable Object&gt; {
593       ClosingFuture&lt;U&gt; apply(
594           DeferredCloser closer,
595           @ParametricNullness V1 value1,
596           @ParametricNullness V2 value2,
597           @ParametricNullness V3 value3)
598           throws Exception;
599     }
600     private final ClosingFuture&lt;V1&gt; future1;
601     private final ClosingFuture&lt;V2&gt; future2;
602     private final ClosingFuture&lt;V3&gt; future3;
603     private Combiner3(
604         ClosingFuture&lt;V1&gt; future1, ClosingFuture&lt;V2&gt; future2, ClosingFuture&lt;V3&gt; future3) {
605       super(true, ImmutableList.of(future1, future2, future3));
606       this.future1 = future1;
607       this.future2 = future2;
608       this.future3 = future3;
609     }
610     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
611         final ClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
612       return call(
613           new CombiningCallable&lt;U&gt;() {
614             @Override
615             @ParametricNullness
616             public U call(DeferredCloser closer, Peeker peeker) throws Exception {
617               return function.apply(
618                   closer,
619                   peeker.getDone(future1),
620                   peeker.getDone(future2),
621                   peeker.getDone(future3));
622             }
623             @Override
624             public String toString() {
625               return function.toString();
626             }
627           },
628           executor);
629     }
630     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
631         final AsyncClosingFunction3&lt;V1, V2, V3, U&gt; function, Executor executor) {
632       return callAsync(
633           new AsyncCombiningCallable&lt;U&gt;() {
634             @Override
635             public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
636               return function.apply(
637                   closer,
638                   peeker.getDone(future1),
639                   peeker.getDone(future2),
640                   peeker.getDone(future3));
641             }
642             @Override
643             public String toString() {
644               return function.toString();
645             }
646           },
647           executor);
648     }
649   }
650   public static final class Combiner4&lt;
651           V1 extends @Nullable Object,
652           V2 extends @Nullable Object,
653           V3 extends @Nullable Object,
654           V4 extends @Nullable Object&gt;
655       extends Combiner {
656     public interface ClosingFunction4&lt;
657         V1 extends @Nullable Object,
658         V2 extends @Nullable Object,
659         V3 extends @Nullable Object,
660         V4 extends @Nullable Object,
661         U extends @Nullable Object&gt; {
662       @ParametricNullness
663       U apply(
664           DeferredCloser closer,
665           @ParametricNullness V1 value1,
666           @ParametricNullness V2 value2,
667           @ParametricNullness V3 value3,
668           @ParametricNullness V4 value4)
669           throws Exception;
670     }
671     public interface AsyncClosingFunction4&lt;
672         V1 extends @Nullable Object,
673         V2 extends @Nullable Object,
674         V3 extends @Nullable Object,
675         V4 extends @Nullable Object,
676         U extends @Nullable Object&gt; {
677       ClosingFuture&lt;U&gt; apply(
678           DeferredCloser closer,
679           @ParametricNullness V1 value1,
680           @ParametricNullness V2 value2,
681           @ParametricNullness V3 value3,
682           @ParametricNullness V4 value4)
683           throws Exception;
684     }
685     private final ClosingFuture&lt;V1&gt; future1;
686     private final ClosingFuture&lt;V2&gt; future2;
687     private final ClosingFuture&lt;V3&gt; future3;
688     private final ClosingFuture&lt;V4&gt; future4;
689     private Combiner4(
690         ClosingFuture&lt;V1&gt; future1,
691         ClosingFuture&lt;V2&gt; future2,
692         ClosingFuture&lt;V3&gt; future3,
693         ClosingFuture&lt;V4&gt; future4) {
694       super(true, ImmutableList.of(future1, future2, future3, future4));
695       this.future1 = future1;
696       this.future2 = future2;
697       this.future3 = future3;
698       this.future4 = future4;
699     }
700     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
701         final ClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
702       return call(
703           new CombiningCallable&lt;U&gt;() {
704             @Override
705             @ParametricNullness
706             public U call(DeferredCloser closer, Peeker peeker) throws Exception {
707               return function.apply(
708                   closer,
709                   peeker.getDone(future1),
710                   peeker.getDone(future2),
711                   peeker.getDone(future3),
712                   peeker.getDone(future4));
713             }
714             @Override
715             public String toString() {
716               return function.toString();
717             }
718           },
719           executor);
720     }
721     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
722         final AsyncClosingFunction4&lt;V1, V2, V3, V4, U&gt; function, Executor executor) {
723       return callAsync(
724           new AsyncCombiningCallable&lt;U&gt;() {
725             @Override
726             public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
727               return function.apply(
728                   closer,
729                   peeker.getDone(future1),
730                   peeker.getDone(future2),
731                   peeker.getDone(future3),
732                   peeker.getDone(future4));
733             }
734             @Override
735             public String toString() {
736               return function.toString();
737             }
738           },
739           executor);
740     }
741   }
742   public static final class Combiner5&lt;
743           V1 extends @Nullable Object,
744           V2 extends @Nullable Object,
745           V3 extends @Nullable Object,
746           V4 extends @Nullable Object,
747           V5 extends @Nullable Object&gt;
748       extends Combiner {
749     public interface ClosingFunction5&lt;
750         V1 extends @Nullable Object,
751         V2 extends @Nullable Object,
752         V3 extends @Nullable Object,
753         V4 extends @Nullable Object,
754         V5 extends @Nullable Object,
755         U extends @Nullable Object&gt; {
756       @ParametricNullness
757       U apply(
758           DeferredCloser closer,
759           @ParametricNullness V1 value1,
760           @ParametricNullness V2 value2,
761           @ParametricNullness V3 value3,
762           @ParametricNullness V4 value4,
763           @ParametricNullness V5 value5)
764           throws Exception;
765     }
766     public interface AsyncClosingFunction5&lt;
767         V1 extends @Nullable Object,
768         V2 extends @Nullable Object,
769         V3 extends @Nullable Object,
770         V4 extends @Nullable Object,
771         V5 extends @Nullable Object,
772         U extends @Nullable Object&gt; {
773       ClosingFuture&lt;U&gt; apply(
774           DeferredCloser closer,
775           @ParametricNullness V1 value1,
776           @ParametricNullness V2 value2,
777           @ParametricNullness V3 value3,
778           @ParametricNullness V4 value4,
779           @ParametricNullness V5 value5)
780           throws Exception;
781     }
782     private final ClosingFuture&lt;V1&gt; future1;
783     private final ClosingFuture&lt;V2&gt; future2;
784     private final ClosingFuture&lt;V3&gt; future3;
785     private final ClosingFuture&lt;V4&gt; future4;
786     private final ClosingFuture&lt;V5&gt; future5;
787     private Combiner5(
788         ClosingFuture&lt;V1&gt; future1,
789         ClosingFuture&lt;V2&gt; future2,
790         ClosingFuture&lt;V3&gt; future3,
791         ClosingFuture&lt;V4&gt; future4,
792         ClosingFuture&lt;V5&gt; future5) {
793       super(true, ImmutableList.of(future1, future2, future3, future4, future5));
794       this.future1 = future1;
795       this.future2 = future2;
796       this.future3 = future3;
797       this.future4 = future4;
798       this.future5 = future5;
799     }
800     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; call(
801         final ClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
802       return call(
803           new CombiningCallable&lt;U&gt;() {
804             @Override
805             @ParametricNullness
806             public U call(DeferredCloser closer, Peeker peeker) throws Exception {
807               return function.apply(
808                   closer,
809                   peeker.getDone(future1),
810                   peeker.getDone(future2),
811                   peeker.getDone(future3),
812                   peeker.getDone(future4),
813                   peeker.getDone(future5));
814             }
815             @Override
816             public String toString() {
817               return function.toString();
818             }
819           },
820           executor);
821     }
822     public &lt;U extends @Nullable Object&gt; ClosingFuture&lt;U&gt; callAsync(
823         final AsyncClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt; function, Executor executor) {
824       return callAsync(
825           new AsyncCombiningCallable&lt;U&gt;() {
826             @Override
827             public ClosingFuture&lt;U&gt; call(DeferredCloser closer, Peeker peeker) throws Exception {
828               return function.apply(
829                   closer,
830                   peeker.getDone(future1),
831                   peeker.getDone(future2),
832                   peeker.getDone(future3),
833                   peeker.getDone(future4),
834                   peeker.getDone(future5));
835             }
836             @Override
837             public String toString() {
838               return function.toString();
839             }
840           },
841           executor);
842     }
843   }
844   @Override
845   public String toString() {
846     return toStringHelper(this).add("state", state.get()).addValue(future).toString();
847   }
848   @Override
849   protected void finalize() {
850     if (state.get().equals(OPEN)) {
851       logger.log(SEVERE, "Uh oh! An open ClosingFuture has leaked and will close: {0}", this);
852       FluentFuture&lt;V&gt; unused = finishToFuture();
853     }
854   }
855   private static void closeQuietly(@CheckForNull final Closeable closeable, Executor executor) {
856     if (closeable == null) {
857       return;
858     }
859     try {
860       executor.execute(
861           new Runnable() {
862             @Override
863             public void run() {
864               try {
865                 closeable.close();
866               } catch (IOException | RuntimeException e) {
867                 logger.log(WARNING, "thrown by close()", e);
868               }
869             }
870           });
871     } catch (RejectedExecutionException e) {
872       if (logger.isLoggable(WARNING)) {
873         logger.log(
874             WARNING, String.format("while submitting close to %s; will close inline", executor), e);
875       }
876       closeQuietly(closeable, directExecutor());
877     }
878   }
879   private void checkAndUpdateState(State oldState, State newState) {
880     checkState(
881         compareAndUpdateState(oldState, newState),
882         "Expected state to be %s, but it was %s",
883         oldState,
884         newState);
885   }
886   private boolean compareAndUpdateState(State oldState, State newState) {
887     return state.compareAndSet(oldState, newState);
888   }
889   private static final class CloseableList extends IdentityHashMap&lt;Closeable, Executor&gt;
890       implements Closeable {
891     private final DeferredCloser closer = new DeferredCloser(this);
892     private volatile boolean closed;
893     @CheckForNull private volatile CountDownLatch whenClosed;
894     &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
895         ListenableFuture&lt;U&gt; applyClosingFunction(
896             ClosingFunction&lt;? super V, U&gt; transformation, @ParametricNullness V input)
897             throws Exception {
898       CloseableList newCloseables = new CloseableList();
899       try {
900         return immediateFuture(transformation.apply(newCloseables.closer, input));
901       } finally {
902         add(newCloseables, directExecutor());
903       }
904     }
905     &lt;V extends @Nullable Object, U extends @Nullable Object&gt;
906         FluentFuture&lt;U&gt; applyAsyncClosingFunction(
907             AsyncClosingFunction&lt;V, U&gt; transformation, @ParametricNullness V input)
908             throws Exception {
909       CloseableList newCloseables = new CloseableList();
910       try {
911         ClosingFuture&lt;U&gt; closingFuture = transformation.apply(newCloseables.closer, input);
912         closingFuture.becomeSubsumedInto(newCloseables);
913         return closingFuture.future;
914       } finally {
915         add(newCloseables, directExecutor());
916       }
917     }
918     @Override
919     public void close() {
920       if (closed) {
921         return;
922       }
923       synchronized (this) {
924         if (closed) {
925           return;
926         }
927         closed = true;
928       }
929       for (Map.Entry&lt;Closeable, Executor&gt; entry : entrySet()) {
930         closeQuietly(entry.getKey(), entry.getValue());
931       }
932       clear();
933       if (whenClosed != null) {
934         whenClosed.countDown();
935       }
936     }
937     void add(@CheckForNull Closeable closeable, Executor executor) {
938       checkNotNull(executor);
939       if (closeable == null) {
940         return;
941       }
942       synchronized (this) {
943         if (!closed) {
944           put(closeable, executor);
945           return;
946         }
947       }
948       closeQuietly(closeable, executor);
949     }
950     CountDownLatch whenClosedCountDown() {
951       if (closed) {
952         return new CountDownLatch(0);
953       }
954       synchronized (this) {
955         if (closed) {
956           return new CountDownLatch(0);
957         }
958         checkState(whenClosed == null);
959         return whenClosed = new CountDownLatch(1);
960       }
961     }
962   }
963   @VisibleForTesting
964   CountDownLatch whenClosedCountDown() {
965     return closeables.whenClosedCountDown();
966   }
967   enum State {
968     OPEN,
969     SUBSUMED,
970     WILL_CLOSE,
971     CLOSING,
972     CLOSED,
973     WILL_CREATE_VALUE_AND_CLOSER,
974   }
975 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
