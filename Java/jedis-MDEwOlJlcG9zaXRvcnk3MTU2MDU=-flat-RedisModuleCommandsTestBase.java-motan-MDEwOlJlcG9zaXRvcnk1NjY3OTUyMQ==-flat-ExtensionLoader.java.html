
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.8417132216014895%, Tokens: 13</h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-RedisModuleCommandsTestBase.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis.modules;
2  import static org.junit.Assume.assumeTrue;
3  import org.junit.After;
4  import org.junit.Before;
5  import redis.clients.jedis.Connection;
6  import redis.clients.jedis.DefaultJedisClientConfig;
7  import redis.clients.jedis.HostAndPort;
8  import redis.clients.jedis.Jedis;
9  import redis.clients.jedis.Protocol;
10  import redis.clients.jedis.RedisProtocol;
11  import redis.clients.jedis.UnifiedJedis;
12  import redis.clients.jedis.exceptions.JedisConnectionException;
13  import redis.clients.jedis.util.RedisProtocolUtil;
</span>14  public abstract class RedisModuleCommandsTestBase {
15    private static final String address = System.getProperty("modulesDocker", Protocol.DEFAULT_HOST + ':' + 6479);
16    protected static final HostAndPort hnp = HostAndPort.from(address);
17    protected final RedisProtocol protocol = RedisProtocolUtil.getRedisProtocol();
18    protected UnifiedJedis client;
19    public RedisModuleCommandsTestBase() {
20      super();
21    }
22    public static void prepare() {
23      try (Connection connection = new Connection(hnp)) {
24        assumeTrue("No Redis running on 6479 port.", connection.ping());
25      } catch (JedisConnectionException jce) {
26        assumeTrue("Could not connect to Redis running on 6479 port.", false);
27      }
28    }
29    @Before
30    public void setUp() {
31      try (Jedis jedis = new Jedis(hnp)) {
32        jedis.flushAll();
33      }
34      client = new UnifiedJedis(hnp, DefaultJedisClientConfig.builder().protocol(protocol).build());
35    }
36    @After
37    public void tearDown() throws Exception {
38      client.close();
39    }
40  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ExtensionLoader.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.core.extension;
2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.exception.MotanFrameworkException;
4  import com.weibo.api.motan.util.LoggerUtil;
5  import org.apache.commons.lang3.StringUtils;
6  import java.io.BufferedReader;
7  import java.io.IOException;
8  import java.io.InputStream;
9  import java.io.InputStreamReader;
10  import java.lang.reflect.Constructor;
11  import java.lang.reflect.Modifier;
12  import java.net.URL;
13  import java.util.*;
</span>14  import java.util.concurrent.ConcurrentHashMap;
15  import java.util.concurrent.ConcurrentMap;
16  public class ExtensionLoader<T> {
17      private static ConcurrentMap<Class<?>, ExtensionLoader<?>> extensionLoaders = new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();
18      private ConcurrentMap<String, T> singletonInstances = null;
19      private ConcurrentMap<String, Class<T>> extensionClasses = null;
20      private Class<T> type;
21      private volatile boolean init = false;
22      private static final String PREFIX = "META-INF/services/";
23      private ClassLoader classLoader;
24      private ExtensionLoader(Class<T> type) {
25          this(type, Thread.currentThread().getContextClassLoader());
26      }
27      private ExtensionLoader(Class<T> type, ClassLoader classLoader) {
28          this.type = type;
29          this.classLoader = classLoader;
30      }
31      private void checkInit() {
32          if (!init) {
33              loadExtensionClasses();
34          }
35      }
36      public Class<T> getExtensionClass(String name) {
37          checkInit();
38          return extensionClasses.get(name);
39      }
40      public T getExtension(String name) {
41          return getExtension(name, true);
42      }
43      public T getExtension(String name, boolean throwWhenNotFound) {
44          checkInit();
45          if (StringUtils.isBlank(name)) {
46              if (throwWhenNotFound) {
47                  failThrows(type, "get extension fail. extension name is empty");
48              }
49              return null;
50          }
51          try {
52              Spi spi = type.getAnnotation(Spi.class);
53              if (spi.scope() == Scope.SINGLETON) {
54                  return getSingletonInstance(name, throwWhenNotFound);
55              } else {
56                  Class<T> clz = extensionClasses.get(name);
57                  if (clz == null) {
58                      if (throwWhenNotFound) {
59                          failThrows(type, "get extension fail. extension name '" + name + "' not found");
60                      }
61                      return null;
62                  }
63                  return clz.newInstance();
64              }
65          } catch (MotanFrameworkException mfe) {
66              throw mfe;
67          } catch (Exception e) {
68              failThrows(type, "Error when getExtension " + name, e);
69          }
70          return null;
71      }
72      private T getSingletonInstance(String name, boolean throwWhenNotFound) throws InstantiationException, IllegalAccessException {
73          T obj = singletonInstances.get(name);
74          if (obj != null) {
75              return obj;
76          }
77          Class<T> clz = extensionClasses.get(name);
78          if (clz == null) {
79              if (throwWhenNotFound) {
80                  failThrows(type, "get extension fail. extension name '" + name + "' not found");
81              }
82              return null;
83          }
84          synchronized (singletonInstances) {
85              obj = singletonInstances.get(name);
86              if (obj != null) {
87                  return obj;
88              }
89              obj = clz.newInstance();
90              singletonInstances.put(name, obj);
91          }
92          return obj;
93      }
94      public void addExtensionClass(Class<T> clz) {
95          if (clz == null) {
96              return;
97          }
98          checkInit();
99          checkExtensionType(clz);
100          String spiName = getSpiName(clz);
101          synchronized (extensionClasses) {
102              if (extensionClasses.containsKey(spiName)) {
103                  failThrows(clz, ":Error spiName already exist " + spiName);
104              } else {
105                  extensionClasses.put(spiName, clz);
106              }
107          }
108      }
109      private synchronized void loadExtensionClasses() {
110          if (init) {
111              return;
112          }
113          extensionClasses = loadExtensionClasses(PREFIX);
114          singletonInstances = new ConcurrentHashMap<>();
115          init = true;
116      }
117      @SuppressWarnings("unchecked")
118      public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
119          checkInterfaceType(type);
120          ExtensionLoader<T> loader = (ExtensionLoader<T>) extensionLoaders.get(type);
121          if (loader == null) {
122              loader = initExtensionLoader(type);
123          }
124          return loader;
125      }
126      @SuppressWarnings("unchecked")
127      public static synchronized <T> ExtensionLoader<T> initExtensionLoader(Class<T> type) {
128          ExtensionLoader<T> loader = (ExtensionLoader<T>) extensionLoaders.get(type);
129          if (loader == null) {
130              loader = new ExtensionLoader<T>(type);
131              extensionLoaders.put(type, loader);
132          }
133          return loader;
134      }
135      @SuppressWarnings("unchecked")
136      public List<T> getExtensions(String key) {
137          checkInit();
138          if (extensionClasses.size() == 0) {
139              return Collections.emptyList();
140          }
141          List<T> exts = new ArrayList<T>(extensionClasses.size());
142          for (Map.Entry<String, Class<T>> entry : extensionClasses.entrySet()) {
143              Activation activation = entry.getValue().getAnnotation(Activation.class);
144              if (StringUtils.isBlank(key)) {
145                  exts.add(getExtension(entry.getKey()));
146              } else if (activation != null && activation.key() != null) {
147                  for (String k : activation.key()) {
148                      if (key.equals(k)) {
149                          exts.add(getExtension(entry.getKey()));
150                          break;
151                      }
152                  }
153              }
154          }
155          Collections.sort(exts, new ActivationComparator<T>());
156          return exts;
157      }
158      private static <T> void checkInterfaceType(Class<T> clz) {
159          if (clz == null) {
160              failThrows(clz, "Error extension type is null");
161          }
162          if (!clz.isInterface()) {
163              failThrows(clz, "Error extension type is not interface");
164          }
165          if (!isSpiType(clz)) {
166              failThrows(clz, "Error extension type without @Spi annotation");
167          }
168      }
169      private void checkExtensionType(Class<T> clz) {
170          checkClassPublic(clz);
171          checkConstructorPublic(clz);
172          checkClassInherit(clz);
173      }
174      private void checkClassInherit(Class<T> clz) {
175          if (!type.isAssignableFrom(clz)) {
176              failThrows(clz, "Error is not instanceof " + type.getName());
177          }
178      }
179      private void checkClassPublic(Class<T> clz) {
180          if (!Modifier.isPublic(clz.getModifiers())) {
181              failThrows(clz, "Error is not a public class");
182          }
183      }
184      private void checkConstructorPublic(Class<T> clz) {
185          Constructor<?>[] constructors = clz.getConstructors();
186          if (constructors == null || constructors.length == 0) {
187              failThrows(clz, "Error has no public no-args constructor");
188          }
189          for (Constructor<?> constructor : constructors) {
190              if (Modifier.isPublic(constructor.getModifiers()) && constructor.getParameterTypes().length == 0) {
191                  return;
192              }
193          }
194          failThrows(clz, "Error has no public no-args constructor");
195      }
196      private static <T> boolean isSpiType(Class<T> clz) {
197          return clz.isAnnotationPresent(Spi.class);
198      }
199      private ConcurrentMap<String, Class<T>> loadExtensionClasses(String prefix) {
200          String fullName = prefix + type.getName();
201          List<String> classNames = new ArrayList<String>();
202          try {
203              Enumeration<URL> urls;
204              if (classLoader == null) {
205                  urls = ClassLoader.getSystemResources(fullName);
206              } else {
207                  urls = classLoader.getResources(fullName);
208              }
209              if (urls == null || !urls.hasMoreElements()) {
210                  return new ConcurrentHashMap<String, Class<T>>();
211              }
212              while (urls.hasMoreElements()) {
213                  URL url = urls.nextElement();
214                  parseUrl(type, url, classNames);
215              }
216          } catch (Exception e) {
217              throw new MotanFrameworkException(
218                      "ExtensionLoader loadExtensionClasses error, prefix: " + prefix + " type: " + type.getClass(), e);
219          }
220          return loadClass(classNames);
221      }
222      @SuppressWarnings("unchecked")
223      private ConcurrentMap<String, Class<T>> loadClass(List<String> classNames) {
224          ConcurrentMap<String, Class<T>> map = new ConcurrentHashMap<>();
225          for (String className : classNames) {
226              try {
227                  Class<T> clz;
228                  if (classLoader == null) {
229                      clz = (Class<T>) Class.forName(className);
230                  } else {
231                      clz = (Class<T>) Class.forName(className, true, classLoader);
232                  }
233                  checkExtensionType(clz);
234                  String spiName = getSpiName(clz);
235                  if (map.containsKey(spiName)) {
236                      failThrows(clz, ":Error spiName already exist " + spiName);
237                  } else {
238                      map.put(spiName, clz);
239                  }
240              } catch (Exception e) {
241                  failLog(type, "Error load spi class", e);
242              }
243          }
244          return map;
245      }
246      public String getSpiName(Class<?> clz) {
247          SpiMeta spiMeta = clz.getAnnotation(SpiMeta.class);
248          String name = (spiMeta != null && !"".equals(spiMeta.name())) ? spiMeta.name() : clz.getSimpleName();
249          return name;
250      }
251      private void parseUrl(Class<T> type, URL url, List<String> classNames) throws ServiceConfigurationError {
252          InputStream inputStream = null;
253          BufferedReader reader = null;
254          try {
255              inputStream = url.openStream();
256              reader = new BufferedReader(new InputStreamReader(inputStream, MotanConstants.DEFAULT_CHARACTER));
257              String line = null;
258              int indexNumber = 0;
259              while ((line = reader.readLine()) != null) {
260                  indexNumber++;
261                  parseLine(type, url, line, indexNumber, classNames);
262              }
263          } catch (Exception x) {
264              failLog(type, "Error reading spi configuration file", x);
265          } finally {
266              try {
267                  if (reader != null) {
268                      reader.close();
269                  }
270                  if (inputStream != null) {
271                      inputStream.close();
272                  }
273              } catch (IOException y) {
274                  failLog(type, "Error closing spi configuration file", y);
275              }
276          }
277      }
278      private void parseLine(Class<T> type, URL url, String line, int lineNumber, List<String> names) throws IOException,
279              ServiceConfigurationError {
280          int ci = line.indexOf('#');
281          if (ci >= 0) {
282              line = line.substring(0, ci);
283          }
284          line = line.trim();
285          if (line.length() <= 0) {
286              return;
287          }
288          if ((line.indexOf(' ') >= 0) || (line.indexOf('\t') >= 0)) {
289              failThrows(type, url, lineNumber, "Illegal spi configuration-file syntax");
290          }
291          int cp = line.codePointAt(0);
292          if (!Character.isJavaIdentifierStart(cp)) {
293              failThrows(type, url, lineNumber, "Illegal spi provider-class name: " + line);
294          }
295          for (int i = Character.charCount(cp); i < line.length(); i += Character.charCount(cp)) {
296              cp = line.codePointAt(i);
297              if (!Character.isJavaIdentifierPart(cp) && (cp != '.')) {
298                  failThrows(type, url, lineNumber, "Illegal spi provider-class name: " + line);
299              }
300          }
301          if (!names.contains(line)) {
302              names.add(line);
303          }
304      }
305      private static <T> void failLog(Class<T> type, String msg, Throwable cause) {
306          LoggerUtil.error(type.getName() + ": " + msg, cause);
307      }
308      private static <T> void failThrows(Class<T> type, String msg, Throwable cause) {
309          throw new MotanFrameworkException(type.getName() + ": " + msg, cause);
310      }
311      private static <T> void failThrows(Class<T> type, String msg) {
312          throw new MotanFrameworkException(type.getName() + ": " + msg);
313      }
314      private static <T> void failThrows(Class<T> type, URL url, int line, String msg) throws ServiceConfigurationError {
315          failThrows(type, url + ":" + line + ": " + msg);
316      }
317  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-RedisModuleCommandsTestBase.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ExtensionLoader.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis.modules;
2  import static org.junit.Assume.assumeTrue;
3  import org.junit.After;
4  import org.junit.Before;
5  import redis.clients.jedis.Connection;
6  import redis.clients.jedis.DefaultJedisClientConfig;
7  import redis.clients.jedis.HostAndPort;
8  import redis.clients.jedis.Jedis;
9  import redis.clients.jedis.Protocol;
10  import redis.clients.jedis.RedisProtocol;
11  import redis.clients.jedis.UnifiedJedis;
12  import redis.clients.jedis.exceptions.JedisConnectionException;
13  import redis.clients.jedis.util.RedisProtocolUtil;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.core.extension;
2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.exception.MotanFrameworkException;
4  import com.weibo.api.motan.util.LoggerUtil;
5  import org.apache.commons.lang3.StringUtils;
6  import java.io.BufferedReader;
7  import java.io.IOException;
8  import java.io.InputStream;
9  import java.io.InputStreamReader;
10  import java.lang.reflect.Constructor;
11  import java.lang.reflect.Modifier;
12  import java.net.URL;
13  import java.util.*;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    