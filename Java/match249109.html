<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for WebSocketFrameAggregatorTest.java & ChunkedWriteHandlerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for WebSocketFrameAggregatorTest.java & ChunkedWriteHandlerTest.java
      </h3>
      <h1 align="center">
        12.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>WebSocketFrameAggregatorTest.java (38.333332%)<TH>ChunkedWriteHandlerTest.java (7.685881%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#0',2,'match249109-1.html#0',3)" NAME="0">(107-116)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#0',2,'match249109-1.html#0',3)" NAME="0">(539-549)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#1',2,'match249109-1.html#1',3)" NAME="1">(71-81)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#1',2,'match249109-1.html#1',3)" NAME="1">(588-599)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#2',2,'match249109-1.html#2',3)" NAME="2">(57-64)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#2',2,'match249109-1.html#2',3)" NAME="2">(217-228)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#3',2,'match249109-1.html#3',3)" NAME="3">(18-34)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#3',2,'match249109-1.html#3',3)" NAME="3">(38-53)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#4',2,'match249109-1.html#4',3)" NAME="4">(64-71)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#4',2,'match249109-1.html#4',3)" NAME="4">(735-744)</A><TD ALIGN=center><FONT COLOR="#a50000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#5',2,'match249109-1.html#5',3)" NAME="5">(138-143)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#5',2,'match249109-1.html#5',3)" NAME="5">(354-359)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match249109-0.html#6',2,'match249109-1.html#6',3)" NAME="6">(144-149)<TD><A HREF="javascript:ZweiFrames('match249109-0.html#6',2,'match249109-1.html#6',3)" NAME="6">(696-702)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketFrameAggregatorTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2013 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="3"></A> */
package io.netty.handler.codec.http.websocketx;

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match249109-1.html#3',3,'match249109-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.TooLongFrameException;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;


public class WebSocketFrameAggregatorTest {
    private static final byte[] content1 = &quot;Content1&quot;.getBytes(CharsetUtil.UTF_8)</B></FONT>;
    private static final byte[] content2 = &quot;Content2&quot;.getBytes(CharsetUtil.UTF_8);
    private static final byte[] content3 = &quot;Content3&quot;.getBytes(CharsetUtil.UTF_8);
    private static final byte[] aggregatedContent = new byte[content1.length + content2.length + content3.length];
    static {
        System.arraycopy(content1, 0, aggregatedContent, 0, content1.length);
        System.arraycopy(content2, 0, aggregatedContent, content1.length, content2.length);
        System.arraycopy(content3, 0, aggregatedContent, content1.length + content2.length, content3.length);
    }

    @Test
    public void testAggregationBinary() {
        EmbeddedChannel channel = new EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
        channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
        channel.writeInbound(new PingWebSocketFrame(Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new PongWebSocketFrame(Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content3)));

<A NAME="2"></A>        assertTrue(channel.finish());

        BinaryWebSocketFrame frame = channel.readInbound();
        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match249109-1.html#2',3,'match249109-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(frame.isFinalFragment());
        assertEquals(1, frame.rsv());
        assertArrayEquals(content1, toBytes(frame.content()));

<A NAME="4"></A>        PingWebSocketFrame frame2 = channel.readInbound();
        assertTrue(frame2.isFinalFragment());
        assertEquals(0, frame2.rsv());
        assertArrayEquals</B></FONT>(content1, toBytes(<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match249109-1.html#4',3,'match249109-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>frame2.content()));

        PongWebSocketFrame frame3 = channel.readInbound();
        assertTrue(frame3.isFinalFragment());
<A NAME="1"></A>        assertEquals(0, frame3.rsv());
        assertArrayEquals(content1, toBytes(frame3.content()));

        BinaryWebSocketFrame frame4 = <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match249109-1.html#1',3,'match249109-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound()</B></FONT>;
        assertTrue(frame4.isFinalFragment());
        assertEquals(0, frame4.rsv());
        assertArrayEquals(aggregatedContent, toBytes(frame4.content()));

        assertNull(channel.readInbound());
    }

    @Test
    public void testAggregationText() {
        EmbeddedChannel channel = new</B></FONT> EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
        channel.writeInbound(new TextWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new TextWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
        channel.writeInbound(new PingWebSocketFrame(Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new PongWebSocketFrame(Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content3)));

        assertTrue(channel.finish());

        TextWebSocketFrame frame = channel.readInbound();
        assertTrue(frame.isFinalFragment());
        assertEquals(1, frame.rsv());
        assertArrayEquals(content1, toBytes(frame.content()));

        PingWebSocketFrame frame2 = channel.readInbound();
        assertTrue(frame2.isFinalFragment());
        assertEquals(0, frame2.rsv());
        assertArrayEquals(content1, toBytes(frame2.content()));

        PongWebSocketFrame frame3 = channel.readInbound();
        assertTrue(frame3.isFinalFragment());
        assertEquals(0, frame3.rsv());
<A NAME="0"></A>        assertArrayEquals(content1, toBytes(frame3.content()));

        TextWebSocketFrame frame4 = channel.readInbound();
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match249109-1.html#0',3,'match249109-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(frame4.isFinalFragment());
        assertEquals(0, frame4.rsv());
        assertArrayEquals(aggregatedContent, toBytes(frame4.content()));

        assertNull(channel.readInbound());
    }

    @Test
    public void textFrameTooBig() throws Exception {
        EmbeddedChannel channel = new EmbeddedChannel(new</B></FONT> WebSocketFrameAggregator(8));
        channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
        try {
            channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
            fail();
        } catch (TooLongFrameException e) {
            // expected
        }
        channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
        channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content2)));

        channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
        channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
        try {
            channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
            fail();
        } catch (TooLongFrameException e) {
            // expected
<A NAME="5"></A>        }
        channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
        channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content2)));
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match249109-1.html#5',3,'match249109-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (;;) {
            Object msg = channel.readInbound();
            if (msg == null) {
<A NAME="6"></A>                break;
            }
            ReferenceCountUtil.release</B></FONT>(msg);
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match249109-1.html#6',3,'match249109-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
        channel.finish();
    }

    private static byte[] toBytes(ByteBuf buf) {
        byte[] bytes = new byte[buf.readableBytes()]</B></FONT>;
        buf.readBytes(bytes);
        buf.release();
        return bytes;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ChunkedWriteHandlerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.handler.stream;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.internal.PlatformDependent;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.io.ByteArrayInputStream;
import java.io.File;
<A NAME="3"></A>import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#3',2,'match249109-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.nio.channels.Channels;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.FileChannel;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.concurrent.TimeUnit.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class ChunkedWriteHandlerTest {
    private static final byte[] BYTES = new byte[1024 * 64]</B></FONT>;
    private static final File TMP;

    static {
        for (int i = 0; i &lt; BYTES.length; i++) {
            BYTES[i] = (byte) i;
        }

        FileOutputStream out = null;
        try {
            TMP = PlatformDependent.createTempFile(&quot;netty-chunk-&quot;, &quot;.tmp&quot;, null);
            TMP.deleteOnExit();
            out = new FileOutputStream(TMP);
            out.write(BYTES);
            out.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }
    }

    // See #310
    @Test
    public void testChunkedStream() {
        check(new ChunkedStream(new ByteArrayInputStream(BYTES)));

        check(new ChunkedStream(new ByteArrayInputStream(BYTES)),
                new ChunkedStream(new ByteArrayInputStream(BYTES)),
                new ChunkedStream(new ByteArrayInputStream(BYTES)));
    }

    @Test
    public void testChunkedNioStream() {
        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));

        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
    }

    @Test
    public void testChunkedFile() throws IOException {
        check(new ChunkedFile(TMP));

        check(new ChunkedFile(TMP), new ChunkedFile(TMP), new ChunkedFile(TMP));
    }

    @Test
    public void testChunkedNioFile() throws IOException {
        check(new ChunkedNioFile(TMP));

        check(new ChunkedNioFile(TMP), new ChunkedNioFile(TMP), new ChunkedNioFile(TMP));
    }

    @Test
    public void testChunkedNioFileLeftPositionUnchanged() throws IOException {
        FileChannel in = null;
        final long expectedPosition = 10;
        try {
            in = new RandomAccessFile(TMP, &quot;r&quot;).getChannel();
            in.position(expectedPosition);
            check(new ChunkedNioFile(in) {
                @Override
                public void close() throws Exception {
                    //no op
                }
            });
            assertTrue(in.isOpen());
            assertEquals(expectedPosition, in.position());
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }

    @Test
    public void testChunkedNioFileFailOnClosedFileChannel() throws IOException {
        final FileChannel in = new RandomAccessFile(TMP, &quot;r&quot;).getChannel();
        in.close();

        assertThrows(ClosedChannelException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                check(new ChunkedNioFile(in) {
                    @Override
                    public void close() throws Exception {
                        //no op
                    }
                });
            }
        });
    }

    @Test
    public void testUnchunkedData() throws IOException {
        check(Unpooled.wrappedBuffer(BYTES));

        check(Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES));
    }

    // Test case which shows that there is not a bug like stated here:
    // https://stackoverflow.com/a/10426305
    @Test
    public void testListenerNotifiedWhenIsEnd() {
        ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.ISO_8859_1);

        ChunkedInput&lt;ByteBuf&gt; input = new ChunkedInput&lt;ByteBuf&gt;() {
            private boolean done;
            private final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.ISO_8859_1);

            @Override
            public boolean isEndOfInput() throws Exception {
                return done;
            }

            @Override
            public void close() throws Exception {
                buffer.release();
            }

            @Deprecated
            @Override
            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
                return readChunk(ctx.alloc());
            }

            @Override
            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
                if (done) {
                    return null;
                }
                done = true;
                return buffer.retainedDuplicate();
            }

            @Override
            public long length() {
                return -1;
            }

            @Override
            public long progress() {
                return 1;
            }
        };

        final AtomicBoolean listenerNotified = new AtomicBoolean(false);
        final ChannelFutureListener listener = new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                listenerNotified.set(true);
            }
<A NAME="2"></A>        };

        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#2',2,'match249109-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();
        assertTrue(ch.finish());

        // the listener should have been notified
        assertTrue(listenerNotified.get());

        ByteBuf buffer2 = ch.readOutbound();
        assertEquals(buffer, buffer2);
        assertNull(ch.readOutbound());

        buffer.release();
        buffer2.release</B></FONT>();
    }

    @Test
    public void testChunkedMessageInput() {

        ChunkedInput&lt;Object&gt; input = new ChunkedInput&lt;Object&gt;() {
            private boolean done;

            @Override
            public boolean isEndOfInput() throws Exception {
                return done;
            }

            @Override
            public void close() throws Exception {
                // NOOP
            }

            @Deprecated
            @Override
            public Object readChunk(ChannelHandlerContext ctx) throws Exception {
                return readChunk(ctx.alloc());
            }

            @Override
            public Object readChunk(ByteBufAllocator ctx) throws Exception {
                if (done) {
                    return false;
                }
                done = true;
                return 0;
            }

            @Override
            public long length() {
                return -1;
            }

            @Override
            public long progress() {
                return 1;
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
        ch.writeAndFlush(input).syncUninterruptibly();
        assertTrue(ch.finish());

        assertEquals(0, (Integer) ch.readOutbound());
        assertNull(ch.readOutbound());
    }

    @Test
    public void testWriteFailureChunkedStream() throws IOException {
        checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));
    }

    @Test
    public void testWriteFailureChunkedNioStream() throws IOException {
        checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
    }

    @Test
    public void testWriteFailureChunkedFile() throws IOException {
        checkFirstFailed(new ChunkedFile(TMP));
    }

    @Test
    public void testWriteFailureChunkedNioFile() throws IOException {
        checkFirstFailed(new ChunkedNioFile(TMP));
    }

    @Test
    public void testWriteFailureUnchunkedData() throws IOException {
        checkFirstFailed(Unpooled.wrappedBuffer(BYTES));
    }

    @Test
    public void testSkipAfterFailedChunkedStream() throws IOException {
        checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),
                        new ChunkedStream(new ByteArrayInputStream(BYTES)));
    }

    @Test
    public void testSkipAfterFailedChunkedNioStream() throws IOException {
        checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
                        new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
    }

    @Test
    public void testSkipAfterFailedChunkedFile() throws IOException {
        checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));
    }

    @Test
    public void testSkipAfterFailedChunkedNioFile() throws IOException {
        checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));
    }

    // See https://github.com/netty/netty/issues/8700.
    @Test
    public void testFailureWhenLastChunkFailed() throws IOException {
        ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {
            private int passedWrites;

            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                if (++this.passedWrites &lt; 4) {
                    ctx.write(msg, promise);
                } else {
                    ReferenceCountUtil.release(msg);
                    promise.tryFailure(new RuntimeException());
                }
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(failLast, new ChunkedWriteHandler());
        ChannelFuture r = ch.writeAndFlush(new ChunkedFile(TMP, 1024 * 16)); // 4 chunks
        assertTrue(ch.finish());

        assertFalse(r.isSuccess());
        assertTrue(r.cause() instanceof RuntimeException);
<A NAME="5"></A>
        // 3 out of 4 chunks were already written
        int read = 0;
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#5',2,'match249109-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (;;) {
            ByteBuf buffer = ch.readOutbound();
            if (buffer == null) {
                break;
            }
            read += buffer.readableBytes</B></FONT>();
            buffer.release();
        }

        assertEquals(1024 * 16 * 3, read);
    }

    @Test
    public void testDiscardPendingWritesOnInactive() throws IOException {

        final AtomicBoolean closeWasCalled = new AtomicBoolean(false);

        ChunkedInput&lt;ByteBuf&gt; notifiableInput = new ChunkedInput&lt;ByteBuf&gt;() {
            private boolean done;
            private final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.ISO_8859_1);

            @Override
            public boolean isEndOfInput() throws Exception {
                return done;
            }

            @Override
            public void close() throws Exception {
                buffer.release();
                closeWasCalled.set(true);
            }

            @Deprecated
            @Override
            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
                return readChunk(ctx.alloc());
            }

            @Override
            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
                if (done) {
                    return null;
                }
                done = true;
                return buffer.retainedDuplicate();
            }

            @Override
            public long length() {
                return -1;
            }

            @Override
            public long progress() {
                return 1;
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        // Write 3 messages and close channel before flushing
        ChannelFuture r1 = ch.write(new ChunkedFile(TMP));
        ChannelFuture r2 = ch.write(new ChunkedNioFile(TMP));
        ch.write(notifiableInput);

        // Should be `false` as we do not expect any messages to be written
        assertFalse(ch.finish());

        assertFalse(r1.isSuccess());
        assertFalse(r2.isSuccess());
        assertTrue(closeWasCalled.get());
    }

    // See https://github.com/netty/netty/issues/8700.
    @Test
    public void testStopConsumingChunksWhenFailed() {
        final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.ISO_8859_1);
        final AtomicInteger chunks = new AtomicInteger(0);

        ChunkedInput&lt;ByteBuf&gt; nonClosableInput = new ChunkedInput&lt;ByteBuf&gt;() {
            @Override
            public boolean isEndOfInput() throws Exception {
                return chunks.get() &gt;= 5;
            }

            @Override
            public void close() throws Exception {
                // no-op
            }

            @Deprecated
            @Override
            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
                return readChunk(ctx.alloc());
            }

            @Override
            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
                chunks.incrementAndGet();
                return buffer.retainedDuplicate();
            }

            @Override
            public long length() {
                return -1;
            }

            @Override
            public long progress() {
                return 1;
            }
        };

        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                ReferenceCountUtil.release(msg);
                promise.tryFailure(new RuntimeException());
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());
        ch.writeAndFlush(nonClosableInput).awaitUninterruptibly();
        // Should be `false` as we do not expect any messages to be written
        assertFalse(ch.finish());
        buffer.release();

        // We should expect only single chunked being read from the input.
        // It's possible to get a race condition here between resolving a promise and
        // allocating a new chunk, but should be fine when working with embedded channels.
        assertEquals(1, chunks.get());
    }

    @Test
    public void testCloseSuccessfulChunkedInput() {
        int chunks = 10;
        TestChunkedInput input = new TestChunkedInput(chunks);
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        assertTrue(ch.writeOutbound(input));

        for (int i = 0; i &lt; chunks; i++) {
            ByteBuf buf = ch.readOutbound();
            assertEquals(i, buf.readInt());
            buf.release();
        }

        assertTrue(input.isClosed());
        assertFalse(ch.finish());
    }

    @Test
    public void testCloseFailedChunkedInput() {
        Exception error = new Exception(&quot;Unable to produce a chunk&quot;);
        final ThrowingChunkedInput input = new ThrowingChunkedInput(error);
        final EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        Exception e = assertThrows(Exception.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                ch.writeOutbound(input);
            }
        });
        assertEquals(error, e);

        assertTrue(input.isClosed());
        assertFalse(ch.finish());
    }

    @Test
    public void testWriteListenerInvokedAfterSuccessfulChunkedInputClosed() throws Exception {
        final TestChunkedInput input = new TestChunkedInput(2);
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
        final CountDownLatch listenerInvoked = new CountDownLatch(1);

        ChannelFuture writeFuture = ch.write(input);
        writeFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                inputClosedWhenListenerInvoked.set(input.isClosed());
<A NAME="0"></A>                listenerInvoked.countDown();
            }
        });
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#0',2,'match249109-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ch.flush();

        assertTrue(listenerInvoked.await(10, SECONDS));
        assertTrue(writeFuture.isSuccess());
        assertTrue(inputClosedWhenListenerInvoked.get());
        assertTrue(ch.finishAndReleaseAll());
    }

    @Test
    public void testWriteListenerInvokedAfterFailedChunkedInputClosed() throws Exception {
        final ThrowingChunkedInput input = new ThrowingChunkedInput(new</B></FONT> RuntimeException());
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
        final CountDownLatch listenerInvoked = new CountDownLatch(1);

        ChannelFuture writeFuture = ch.write(input);
        writeFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                inputClosedWhenListenerInvoked.set(input.isClosed());
                listenerInvoked.countDown();
            }
        });
        ch.flush();

        assertTrue(listenerInvoked.await(10, SECONDS));
        assertFalse(writeFuture.isSuccess());
        assertTrue(inputClosedWhenListenerInvoked.get());
        assertFalse(ch.finish());
    }

    @Test
    public void testWriteListenerInvokedAfterChannelClosedAndInputFullyConsumed() throws Exception {
        // use empty input which has endOfInput = true
        final TestChunkedInput input = new TestChunkedInput(0);
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
        final CountDownLatch listenerInvoked = new CountDownLatch(1);

        ChannelFuture writeFuture = ch.write(input);
        writeFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                inputClosedWhenListenerInvoked.set(input.isClosed());
<A NAME="1"></A>                listenerInvoked.countDown();
            }
        });
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#1',2,'match249109-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ch.close(); // close channel to make handler discard the input on subsequent flush
        ch.flush();

        assertTrue(listenerInvoked.await(10, SECONDS));
        assertTrue(writeFuture.isSuccess());
        assertTrue(inputClosedWhenListenerInvoked.get());
        assertFalse(ch.finish());
    }

    @Test
    public void testEndOfInputWhenChannelIsClosedwhenWrite() {
        ChunkedInput&lt;ByteBuf&gt; input = new</B></FONT> ChunkedInput&lt;ByteBuf&gt;() {

            @Override
            public boolean isEndOfInput() {
                return true;
            }

            @Override
            public void close() {
            }

            @Deprecated
            @Override
            public ByteBuf readChunk(ChannelHandlerContext ctx) {
                return null;
            }

            @Override
            public ByteBuf readChunk(ByteBufAllocator allocator) {
                return null;
            }

            @Override
            public long length() {
                return -1;
            }

            @Override
            public long progress() {
                return 1;
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                ReferenceCountUtil.release(msg);
                // Calling close so we will drop all queued messages in the ChunkedWriteHandler.
                ctx.close();
                promise.setSuccess();
            }
        }, new ChunkedWriteHandler());

        ch.writeAndFlush(input).syncUninterruptibly();
        assertFalse(ch.finishAndReleaseAll());
    }

    @Test
    public void testWriteListenerInvokedAfterChannelClosedAndInputNotFullyConsumed() throws Exception {
        // use non-empty input which has endOfInput = false
        final TestChunkedInput input = new TestChunkedInput(42);
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
        final CountDownLatch listenerInvoked = new CountDownLatch(1);

        ChannelFuture writeFuture = ch.write(input);
        writeFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                inputClosedWhenListenerInvoked.set(input.isClosed());
                listenerInvoked.countDown();
            }
        });
        ch.close(); // close channel to make handler discard the input on subsequent flush
        ch.flush();

        assertTrue(listenerInvoked.await(10, SECONDS));
        assertFalse(writeFuture.isSuccess());
        assertTrue(inputClosedWhenListenerInvoked.get());
        assertFalse(ch.finish());
    }

    private static void check(Object... inputs) {
        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());

        for (Object input: inputs) {
            ch.writeOutbound(input);
        }

        assertTrue(ch.finish());

        int i = 0;
        int read = 0;
        for (;;) {
            ByteBuf buffer = ch.readOutbound();
            if (buffer == null) {
                break;
            }
            while (buffer.isReadable()) {
                assertEquals(BYTES[i++], buffer.readByte());
                read++;
                if (i == BYTES.length) {
                    i = 0;
<A NAME="6"></A>                }
            }
            buffer.release();
        <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#6',2,'match249109-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        assertEquals(BYTES.length * inputs.length, read);
    }

    private static void checkFirstFailed(Object input) {
        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {</B></FONT>
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                ReferenceCountUtil.release(msg);
                promise.tryFailure(new RuntimeException());
            }
        };

        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());
        ChannelFuture r = ch.writeAndFlush(input);

        // Should be `false` as we do not expect any messages to be written
        assertFalse(ch.finish());
        assertTrue(r.cause() instanceof RuntimeException);
    }

    private static void checkSkipFailed(Object input1, Object input2) {
        ChannelOutboundHandlerAdapter failFirst = new ChannelOutboundHandlerAdapter() {
            private boolean alreadyFailed;

            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                if (alreadyFailed) {
                    ctx.write(msg, promise);
                } else {
                    this.alreadyFailed = true;
                    ReferenceCountUtil.release(msg);
                    promise.tryFailure(new RuntimeException());
                }
            }
<A NAME="4"></A>        };

        EmbeddedChannel ch = new EmbeddedChannel(failFirst, new ChunkedWriteHandler());
        ChannelFuture r1 = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match249109-0.html#4',2,'match249109-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ch.write(input1);
        ChannelFuture r2 = ch.writeAndFlush(input2).awaitUninterruptibly();
        assertTrue(ch.finish());

        assertTrue(r1.cause() instanceof RuntimeException);
        assertTrue(r2.isSuccess());

        // note, that after we've &quot;skipped&quot; the first write,
        // we expect to see the second message, chunk by chunk
        int i = 0</B></FONT>;
        int read = 0;
        for (;;) {
            ByteBuf buffer = ch.readOutbound();
            if (buffer == null) {
                break;
            }
            while (buffer.isReadable()) {
                assertEquals(BYTES[i++], buffer.readByte());
                read++;
                if (i == BYTES.length) {
                    i = 0;
                }
            }
            buffer.release();
        }

        assertEquals(BYTES.length, read);
    }

    private static final class TestChunkedInput implements ChunkedInput&lt;ByteBuf&gt; {
        private final int chunksToProduce;

        private int chunksProduced;
        private volatile boolean closed;

        TestChunkedInput(int chunksToProduce) {
            this.chunksToProduce = chunksToProduce;
        }

        @Override
        public boolean isEndOfInput() {
            return chunksProduced &gt;= chunksToProduce;
        }

        @Override
        public void close() {
            closed = true;
        }

        @Override
        public ByteBuf readChunk(ChannelHandlerContext ctx) {
            return readChunk(ctx.alloc());
        }

        @Override
        public ByteBuf readChunk(ByteBufAllocator allocator) {
            ByteBuf buf = allocator.buffer();
            buf.writeInt(chunksProduced);
            chunksProduced++;
            return buf;
        }

        @Override
        public long length() {
            return chunksToProduce;
        }

        @Override
        public long progress() {
            return chunksProduced;
        }

        boolean isClosed() {
            return closed;
        }
    }

    private static final class ThrowingChunkedInput implements ChunkedInput&lt;ByteBuf&gt; {
        private final Exception error;

        private volatile boolean closed;

        ThrowingChunkedInput(Exception error) {
            this.error = error;
        }

        @Override
        public boolean isEndOfInput() {
            return false;
        }

        @Override
        public void close() {
            closed = true;
        }

        @Override
        public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
            return readChunk(ctx.alloc());
        }

        @Override
        public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
            throw error;
        }

        @Override
        public long length() {
            return -1;
        }

        @Override
        public long progress() {
            return -1;
        }

        boolean isClosed() {
            return closed;
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
