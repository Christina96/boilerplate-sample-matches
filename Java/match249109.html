<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for WebSocketFrameAggregatorTest.java &amp; ChunkedWriteHandlerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WebSocketFrameAggregatorTest.java &amp; ChunkedWriteHandlerTest.java
      </h3>
<h1 align="center">
        12.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WebSocketFrameAggregatorTest.java (38.333332%)<th>ChunkedWriteHandlerTest.java (7.685881%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(107-116)<td><a href="#" name="0">(539-549)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(71-81)<td><a href="#" name="1">(588-599)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(57-64)<td><a href="#" name="2">(217-228)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(18-34)<td><a href="#" name="3">(38-53)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(64-71)<td><a href="#" name="4">(735-744)</a><td align="center"><font color="#a50000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(138-143)<td><a href="#" name="5">(354-359)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(144-149)<td><a href="#" name="6">(696-702)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketFrameAggregatorTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2013 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13  * License for the specific language governing permissions and limitations
14  * under the License.
15 <a name="3"></a> */
16 package io.netty.handler.codec.http.websocketx;
17 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.buffer.ByteBuf;
18 import io.netty.buffer.Unpooled;
19 import io.netty.channel.embedded.EmbeddedChannel;
20 import io.netty.handler.codec.TooLongFrameException;
21 import io.netty.util.CharsetUtil;
22 import io.netty.util.ReferenceCountUtil;
23 import org.junit.jupiter.api.Test;
24 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
25 import static org.junit.jupiter.api.Assertions.assertEquals;
26 import static org.junit.jupiter.api.Assertions.assertNull;
27 import static org.junit.jupiter.api.Assertions.assertTrue;
28 import static org.junit.jupiter.api.Assertions.fail;
29 public class WebSocketFrameAggregatorTest {
30     private static final byte[] content1 = "Content1".getBytes(CharsetUtil.UTF_8)</b></font>;
31     private static final byte[] content2 = "Content2".getBytes(CharsetUtil.UTF_8);
32     private static final byte[] content3 = "Content3".getBytes(CharsetUtil.UTF_8);
33     private static final byte[] aggregatedContent = new byte[content1.length + content2.length + content3.length];
34     static {
35         System.arraycopy(content1, 0, aggregatedContent, 0, content1.length);
36         System.arraycopy(content2, 0, aggregatedContent, content1.length, content2.length);
37         System.arraycopy(content3, 0, aggregatedContent, content1.length + content2.length, content3.length);
38     }
39     @Test
40     public void testAggregationBinary() {
41         EmbeddedChannel channel = new EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
42         channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
43         channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
44         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
45         channel.writeInbound(new PingWebSocketFrame(Unpooled.wrappedBuffer(content1)));
46         channel.writeInbound(new PongWebSocketFrame(Unpooled.wrappedBuffer(content1)));
47         channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content3)));
48 <a name="2"></a>        assertTrue(channel.finish());
49         BinaryWebSocketFrame frame = channel.readInbound();
50         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(frame.isFinalFragment());
51         assertEquals(1, frame.rsv());
52         assertArrayEquals(content1, toBytes(frame.content()));
53 <a name="4"></a>        PingWebSocketFrame frame2 = channel.readInbound();
54         assertTrue(frame2.isFinalFragment());
55         assertEquals(0, frame2.rsv());
56         assertArrayEquals</b></font>(content1, toBytes(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>frame2.content()));
57         PongWebSocketFrame frame3 = channel.readInbound();
58         assertTrue(frame3.isFinalFragment());
59 <a name="1"></a>        assertEquals(0, frame3.rsv());
60         assertArrayEquals(content1, toBytes(frame3.content()));
61         BinaryWebSocketFrame frame4 = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound()</b></font>;
62         assertTrue(frame4.isFinalFragment());
63         assertEquals(0, frame4.rsv());
64         assertArrayEquals(aggregatedContent, toBytes(frame4.content()));
65         assertNull(channel.readInbound());
66     }
67     @Test
68     public void testAggregationText() {
69         EmbeddedChannel channel = new</b></font> EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
70         channel.writeInbound(new TextWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
71         channel.writeInbound(new TextWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
72         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
73         channel.writeInbound(new PingWebSocketFrame(Unpooled.wrappedBuffer(content1)));
74         channel.writeInbound(new PongWebSocketFrame(Unpooled.wrappedBuffer(content1)));
75         channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content3)));
76         assertTrue(channel.finish());
77         TextWebSocketFrame frame = channel.readInbound();
78         assertTrue(frame.isFinalFragment());
79         assertEquals(1, frame.rsv());
80         assertArrayEquals(content1, toBytes(frame.content()));
81         PingWebSocketFrame frame2 = channel.readInbound();
82         assertTrue(frame2.isFinalFragment());
83         assertEquals(0, frame2.rsv());
84         assertArrayEquals(content1, toBytes(frame2.content()));
85         PongWebSocketFrame frame3 = channel.readInbound();
86         assertTrue(frame3.isFinalFragment());
87         assertEquals(0, frame3.rsv());
88 <a name="0"></a>        assertArrayEquals(content1, toBytes(frame3.content()));
89         TextWebSocketFrame frame4 = channel.readInbound();
90         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(frame4.isFinalFragment());
91         assertEquals(0, frame4.rsv());
92         assertArrayEquals(aggregatedContent, toBytes(frame4.content()));
93         assertNull(channel.readInbound());
94     }
95     @Test
96     public void textFrameTooBig() throws Exception {
97         EmbeddedChannel channel = new EmbeddedChannel(new</b></font> WebSocketFrameAggregator(8));
98         channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
99         channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
100         try {
101             channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
102             fail();
103         } catch (TooLongFrameException e) {
104         }
105         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
106         channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content2)));
107         channel.writeInbound(new BinaryWebSocketFrame(true, 1, Unpooled.wrappedBuffer(content1)));
108         channel.writeInbound(new BinaryWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content1)));
109         try {
110             channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
111             fail();
112         } catch (TooLongFrameException e) {
113 <a name="5"></a>        }
114         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, Unpooled.wrappedBuffer(content2)));
115         channel.writeInbound(new ContinuationWebSocketFrame(true, 0, Unpooled.wrappedBuffer(content2)));
116         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (;;) {
117             Object msg = channel.readInbound();
118             if (msg == null) {
119 <a name="6"></a>                break;
120             }
121             ReferenceCountUtil.release</b></font>(msg);
122         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
123         channel.finish();
124     }
125     private static byte[] toBytes(ByteBuf buf) {
126         byte[] bytes = new byte[buf.readableBytes()]</b></font>;
127         buf.readBytes(bytes);
128         buf.release();
129         return bytes;
130     }
131 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ChunkedWriteHandlerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2012 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13  * License for the specific language governing permissions and limitations
14  * under the License.
15  */
16 package io.netty.handler.stream;
17 import io.netty.buffer.ByteBuf;
18 import io.netty.buffer.ByteBufAllocator;
19 import io.netty.buffer.Unpooled;
20 import io.netty.channel.ChannelFuture;
21 import io.netty.channel.ChannelFutureListener;
22 import io.netty.channel.ChannelHandlerContext;
23 import io.netty.channel.ChannelOutboundHandlerAdapter;
24 import io.netty.channel.ChannelPromise;
25 import io.netty.channel.embedded.EmbeddedChannel;
26 import io.netty.util.CharsetUtil;
27 import io.netty.util.ReferenceCountUtil;
28 import io.netty.util.internal.PlatformDependent;
29 import org.junit.jupiter.api.Test;
30 import org.junit.jupiter.api.function.Executable;
31 import java.io.ByteArrayInputStream;
32 import java.io.File;
33 <a name="3"></a>import java.io.FileOutputStream;
34 import java.io.IOException;
35 import java.io.RandomAccessFile;
36 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.nio.channels.Channels;
37 import java.nio.channels.ClosedChannelException;
38 import java.nio.channels.FileChannel;
39 import java.util.concurrent.CountDownLatch;
40 import java.util.concurrent.atomic.AtomicBoolean;
41 import java.util.concurrent.atomic.AtomicInteger;
42 import static java.util.concurrent.TimeUnit.*;
43 import static org.junit.jupiter.api.Assertions.assertEquals;
44 import static org.junit.jupiter.api.Assertions.assertFalse;
45 import static org.junit.jupiter.api.Assertions.assertNull;
46 import static org.junit.jupiter.api.Assertions.assertThrows;
47 import static org.junit.jupiter.api.Assertions.assertTrue;
48 public class ChunkedWriteHandlerTest {
49     private static final byte[] BYTES = new byte[1024 * 64]</b></font>;
50     private static final File TMP;
51     static {
52         for (int i = 0; i &lt; BYTES.length; i++) {
53             BYTES[i] = (byte) i;
54         }
55         FileOutputStream out = null;
56         try {
57             TMP = PlatformDependent.createTempFile("netty-chunk-", ".tmp", null);
58             TMP.deleteOnExit();
59             out = new FileOutputStream(TMP);
60             out.write(BYTES);
61             out.flush();
62         } catch (IOException e) {
63             throw new RuntimeException(e);
64         } finally {
65             if (out != null) {
66                 try {
67                     out.close();
68                 } catch (IOException e) {
69                 }
70             }
71         }
72     }
73     @Test
74     public void testChunkedStream() {
75         check(new ChunkedStream(new ByteArrayInputStream(BYTES)));
76         check(new ChunkedStream(new ByteArrayInputStream(BYTES)),
77                 new ChunkedStream(new ByteArrayInputStream(BYTES)),
78                 new ChunkedStream(new ByteArrayInputStream(BYTES)));
79     }
80     @Test
81     public void testChunkedNioStream() {
82         check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
83         check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
84                 new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
85                 new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
86     }
87     @Test
88     public void testChunkedFile() throws IOException {
89         check(new ChunkedFile(TMP));
90         check(new ChunkedFile(TMP), new ChunkedFile(TMP), new ChunkedFile(TMP));
91     }
92     @Test
93     public void testChunkedNioFile() throws IOException {
94         check(new ChunkedNioFile(TMP));
95         check(new ChunkedNioFile(TMP), new ChunkedNioFile(TMP), new ChunkedNioFile(TMP));
96     }
97     @Test
98     public void testChunkedNioFileLeftPositionUnchanged() throws IOException {
99         FileChannel in = null;
100         final long expectedPosition = 10;
101         try {
102             in = new RandomAccessFile(TMP, "r").getChannel();
103             in.position(expectedPosition);
104             check(new ChunkedNioFile(in) {
105                 @Override
106                 public void close() throws Exception {
107                     //no op
108                 }
109             });
110             assertTrue(in.isOpen());
111             assertEquals(expectedPosition, in.position());
112         } finally {
113             if (in != null) {
114                 in.close();
115             }
116         }
117     }
118     @Test
119     public void testChunkedNioFileFailOnClosedFileChannel() throws IOException {
120         final FileChannel in = new RandomAccessFile(TMP, "r").getChannel();
121         in.close();
122         assertThrows(ClosedChannelException.class, new Executable() {
123             @Override
124             public void execute() throws Throwable {
125                 check(new ChunkedNioFile(in) {
126                     @Override
127                     public void close() throws Exception {
128                         //no op
129                     }
130                 });
131             }
132         });
133     }
134     @Test
135     public void testUnchunkedData() throws IOException {
136         check(Unpooled.wrappedBuffer(BYTES));
137         check(Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES));
138     }
139     @Test
140     public void testListenerNotifiedWhenIsEnd() {
141         ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
142         ChunkedInput&lt;ByteBuf&gt; input = new ChunkedInput&lt;ByteBuf&gt;() {
143             private boolean done;
144             private final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
145             @Override
146             public boolean isEndOfInput() throws Exception {
147                 return done;
148             }
149             @Override
150             public void close() throws Exception {
151                 buffer.release();
152             }
153             @Deprecated
154             @Override
155             public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
156                 return readChunk(ctx.alloc());
157             }
158             @Override
159             public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
160                 if (done) {
161                     return null;
162                 }
163                 done = true;
164                 return buffer.retainedDuplicate();
165             }
166             @Override
167             public long length() {
168                 return -1;
169             }
170             @Override
171             public long progress() {
172                 return 1;
173             }
174         };
175         final AtomicBoolean listenerNotified = new AtomicBoolean(false);
176         final ChannelFutureListener listener = new ChannelFutureListener() {
177             @Override
178             public void operationComplete(ChannelFuture future) throws Exception {
179                 listenerNotified.set(true);
180             }
181 <a name="2"></a>        };
182         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
183         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();
184         assertTrue(ch.finish());
185         assertTrue(listenerNotified.get());
186         ByteBuf buffer2 = ch.readOutbound();
187         assertEquals(buffer, buffer2);
188         assertNull(ch.readOutbound());
189         buffer.release();
190         buffer2.release</b></font>();
191     }
192     @Test
193     public void testChunkedMessageInput() {
194         ChunkedInput&lt;Object&gt; input = new ChunkedInput&lt;Object&gt;() {
195             private boolean done;
196             @Override
197             public boolean isEndOfInput() throws Exception {
198                 return done;
199             }
200             @Override
201             public void close() throws Exception {
202             }
203             @Deprecated
204             @Override
205             public Object readChunk(ChannelHandlerContext ctx) throws Exception {
206                 return readChunk(ctx.alloc());
207             }
208             @Override
209             public Object readChunk(ByteBufAllocator ctx) throws Exception {
210                 if (done) {
211                     return false;
212                 }
213                 done = true;
214                 return 0;
215             }
216             @Override
217             public long length() {
218                 return -1;
219             }
220             @Override
221             public long progress() {
222                 return 1;
223             }
224         };
225         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
226         ch.writeAndFlush(input).syncUninterruptibly();
227         assertTrue(ch.finish());
228         assertEquals(0, (Integer) ch.readOutbound());
229         assertNull(ch.readOutbound());
230     }
231     @Test
232     public void testWriteFailureChunkedStream() throws IOException {
233         checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));
234     }
235     @Test
236     public void testWriteFailureChunkedNioStream() throws IOException {
237         checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
238     }
239     @Test
240     public void testWriteFailureChunkedFile() throws IOException {
241         checkFirstFailed(new ChunkedFile(TMP));
242     }
243     @Test
244     public void testWriteFailureChunkedNioFile() throws IOException {
245         checkFirstFailed(new ChunkedNioFile(TMP));
246     }
247     @Test
248     public void testWriteFailureUnchunkedData() throws IOException {
249         checkFirstFailed(Unpooled.wrappedBuffer(BYTES));
250     }
251     @Test
252     public void testSkipAfterFailedChunkedStream() throws IOException {
253         checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),
254                         new ChunkedStream(new ByteArrayInputStream(BYTES)));
255     }
256     @Test
257     public void testSkipAfterFailedChunkedNioStream() throws IOException {
258         checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),
259                         new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));
260     }
261     @Test
262     public void testSkipAfterFailedChunkedFile() throws IOException {
263         checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));
264     }
265     @Test
266     public void testSkipAfterFailedChunkedNioFile() throws IOException {
267         checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));
268     }
269     @Test
270     public void testFailureWhenLastChunkFailed() throws IOException {
271         ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {
272             private int passedWrites;
273             @Override
274             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
275                 if (++this.passedWrites &lt; 4) {
276                     ctx.write(msg, promise);
277                 } else {
278                     ReferenceCountUtil.release(msg);
279                     promise.tryFailure(new RuntimeException());
280                 }
281             }
282         };
283         EmbeddedChannel ch = new EmbeddedChannel(failLast, new ChunkedWriteHandler());
284         ChannelFuture r = ch.writeAndFlush(new ChunkedFile(TMP, 1024 * 16));         assertTrue(ch.finish());
285         assertFalse(r.isSuccess());
286         assertTrue(r.cause() instanceof RuntimeException);
287 <a name="5"></a>
288         int read = 0;
289         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (;;) {
290             ByteBuf buffer = ch.readOutbound();
291             if (buffer == null) {
292                 break;
293             }
294             read += buffer.readableBytes</b></font>();
295             buffer.release();
296         }
297         assertEquals(1024 * 16 * 3, read);
298     }
299     @Test
300     public void testDiscardPendingWritesOnInactive() throws IOException {
301         final AtomicBoolean closeWasCalled = new AtomicBoolean(false);
302         ChunkedInput&lt;ByteBuf&gt; notifiableInput = new ChunkedInput&lt;ByteBuf&gt;() {
303             private boolean done;
304             private final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
305             @Override
306             public boolean isEndOfInput() throws Exception {
307                 return done;
308             }
309             @Override
310             public void close() throws Exception {
311                 buffer.release();
312                 closeWasCalled.set(true);
313             }
314             @Deprecated
315             @Override
316             public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
317                 return readChunk(ctx.alloc());
318             }
319             @Override
320             public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
321                 if (done) {
322                     return null;
323                 }
324                 done = true;
325                 return buffer.retainedDuplicate();
326             }
327             @Override
328             public long length() {
329                 return -1;
330             }
331             @Override
332             public long progress() {
333                 return 1;
334             }
335         };
336         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
337         ChannelFuture r1 = ch.write(new ChunkedFile(TMP));
338         ChannelFuture r2 = ch.write(new ChunkedNioFile(TMP));
339         ch.write(notifiableInput);
340         assertFalse(ch.finish());
341         assertFalse(r1.isSuccess());
342         assertFalse(r2.isSuccess());
343         assertTrue(closeWasCalled.get());
344     }
345     @Test
346     public void testStopConsumingChunksWhenFailed() {
347         final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
348         final AtomicInteger chunks = new AtomicInteger(0);
349         ChunkedInput&lt;ByteBuf&gt; nonClosableInput = new ChunkedInput&lt;ByteBuf&gt;() {
350             @Override
351             public boolean isEndOfInput() throws Exception {
352                 return chunks.get() &gt;= 5;
353             }
354             @Override
355             public void close() throws Exception {
356             }
357             @Deprecated
358             @Override
359             public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
360                 return readChunk(ctx.alloc());
361             }
362             @Override
363             public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
364                 chunks.incrementAndGet();
365                 return buffer.retainedDuplicate();
366             }
367             @Override
368             public long length() {
369                 return -1;
370             }
371             @Override
372             public long progress() {
373                 return 1;
374             }
375         };
376         ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {
377             @Override
378             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
379                 ReferenceCountUtil.release(msg);
380                 promise.tryFailure(new RuntimeException());
381             }
382         };
383         EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());
384         ch.writeAndFlush(nonClosableInput).awaitUninterruptibly();
385         assertFalse(ch.finish());
386         buffer.release();
387         assertEquals(1, chunks.get());
388     }
389     @Test
390     public void testCloseSuccessfulChunkedInput() {
391         int chunks = 10;
392         TestChunkedInput input = new TestChunkedInput(chunks);
393         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
394         assertTrue(ch.writeOutbound(input));
395         for (int i = 0; i &lt; chunks; i++) {
396             ByteBuf buf = ch.readOutbound();
397             assertEquals(i, buf.readInt());
398             buf.release();
399         }
400         assertTrue(input.isClosed());
401         assertFalse(ch.finish());
402     }
403     @Test
404     public void testCloseFailedChunkedInput() {
405         Exception error = new Exception("Unable to produce a chunk");
406         final ThrowingChunkedInput input = new ThrowingChunkedInput(error);
407         final EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
408         Exception e = assertThrows(Exception.class, new Executable() {
409             @Override
410             public void execute() throws Throwable {
411                 ch.writeOutbound(input);
412             }
413         });
414         assertEquals(error, e);
415         assertTrue(input.isClosed());
416         assertFalse(ch.finish());
417     }
418     @Test
419     public void testWriteListenerInvokedAfterSuccessfulChunkedInputClosed() throws Exception {
420         final TestChunkedInput input = new TestChunkedInput(2);
421         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
422         final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
423         final CountDownLatch listenerInvoked = new CountDownLatch(1);
424         ChannelFuture writeFuture = ch.write(input);
425         writeFuture.addListener(new ChannelFutureListener() {
426             @Override
427             public void operationComplete(ChannelFuture future) {
428                 inputClosedWhenListenerInvoked.set(input.isClosed());
429 <a name="0"></a>                listenerInvoked.countDown();
430             }
431         });
432         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.flush();
433         assertTrue(listenerInvoked.await(10, SECONDS));
434         assertTrue(writeFuture.isSuccess());
435         assertTrue(inputClosedWhenListenerInvoked.get());
436         assertTrue(ch.finishAndReleaseAll());
437     }
438     @Test
439     public void testWriteListenerInvokedAfterFailedChunkedInputClosed() throws Exception {
440         final ThrowingChunkedInput input = new ThrowingChunkedInput(new</b></font> RuntimeException());
441         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
442         final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
443         final CountDownLatch listenerInvoked = new CountDownLatch(1);
444         ChannelFuture writeFuture = ch.write(input);
445         writeFuture.addListener(new ChannelFutureListener() {
446             @Override
447             public void operationComplete(ChannelFuture future) {
448                 inputClosedWhenListenerInvoked.set(input.isClosed());
449                 listenerInvoked.countDown();
450             }
451         });
452         ch.flush();
453         assertTrue(listenerInvoked.await(10, SECONDS));
454         assertFalse(writeFuture.isSuccess());
455         assertTrue(inputClosedWhenListenerInvoked.get());
456         assertFalse(ch.finish());
457     }
458     @Test
459     public void testWriteListenerInvokedAfterChannelClosedAndInputFullyConsumed() throws Exception {
460         final TestChunkedInput input = new TestChunkedInput(0);
461         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
462         final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
463         final CountDownLatch listenerInvoked = new CountDownLatch(1);
464         ChannelFuture writeFuture = ch.write(input);
465         writeFuture.addListener(new ChannelFutureListener() {
466             @Override
467             public void operationComplete(ChannelFuture future) {
468                 inputClosedWhenListenerInvoked.set(input.isClosed());
469 <a name="1"></a>                listenerInvoked.countDown();
470             }
471         });
472         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.close();         ch.flush();
473         assertTrue(listenerInvoked.await(10, SECONDS));
474         assertTrue(writeFuture.isSuccess());
475         assertTrue(inputClosedWhenListenerInvoked.get());
476         assertFalse(ch.finish());
477     }
478     @Test
479     public void testEndOfInputWhenChannelIsClosedwhenWrite() {
480         ChunkedInput&lt;ByteBuf&gt; input = new</b></font> ChunkedInput&lt;ByteBuf&gt;() {
481             @Override
482             public boolean isEndOfInput() {
483                 return true;
484             }
485             @Override
486             public void close() {
487             }
488             @Deprecated
489             @Override
490             public ByteBuf readChunk(ChannelHandlerContext ctx) {
491                 return null;
492             }
493             @Override
494             public ByteBuf readChunk(ByteBufAllocator allocator) {
495                 return null;
496             }
497             @Override
498             public long length() {
499                 return -1;
500             }
501             @Override
502             public long progress() {
503                 return 1;
504             }
505         };
506         EmbeddedChannel ch = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {
507             @Override
508             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
509                 ReferenceCountUtil.release(msg);
510                 ctx.close();
511                 promise.setSuccess();
512             }
513         }, new ChunkedWriteHandler());
514         ch.writeAndFlush(input).syncUninterruptibly();
515         assertFalse(ch.finishAndReleaseAll());
516     }
517     @Test
518     public void testWriteListenerInvokedAfterChannelClosedAndInputNotFullyConsumed() throws Exception {
519         final TestChunkedInput input = new TestChunkedInput(42);
520         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
521         final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();
522         final CountDownLatch listenerInvoked = new CountDownLatch(1);
523         ChannelFuture writeFuture = ch.write(input);
524         writeFuture.addListener(new ChannelFutureListener() {
525             @Override
526             public void operationComplete(ChannelFuture future) {
527                 inputClosedWhenListenerInvoked.set(input.isClosed());
528                 listenerInvoked.countDown();
529             }
530         });
531         ch.close();         ch.flush();
532         assertTrue(listenerInvoked.await(10, SECONDS));
533         assertFalse(writeFuture.isSuccess());
534         assertTrue(inputClosedWhenListenerInvoked.get());
535         assertFalse(ch.finish());
536     }
537     private static void check(Object... inputs) {
538         EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
539         for (Object input: inputs) {
540             ch.writeOutbound(input);
541         }
542         assertTrue(ch.finish());
543         int i = 0;
544         int read = 0;
545         for (;;) {
546             ByteBuf buffer = ch.readOutbound();
547             if (buffer == null) {
548                 break;
549             }
550             while (buffer.isReadable()) {
551                 assertEquals(BYTES[i++], buffer.readByte());
552                 read++;
553                 if (i == BYTES.length) {
554                     i = 0;
555 <a name="6"></a>                }
556             }
557             buffer.release();
558         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
559         assertEquals(BYTES.length * inputs.length, read);
560     }
561     private static void checkFirstFailed(Object input) {
562         ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {</b></font>
563             @Override
564             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
565                 ReferenceCountUtil.release(msg);
566                 promise.tryFailure(new RuntimeException());
567             }
568         };
569         EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());
570         ChannelFuture r = ch.writeAndFlush(input);
571         assertFalse(ch.finish());
572         assertTrue(r.cause() instanceof RuntimeException);
573     }
574     private static void checkSkipFailed(Object input1, Object input2) {
575         ChannelOutboundHandlerAdapter failFirst = new ChannelOutboundHandlerAdapter() {
576             private boolean alreadyFailed;
577             @Override
578             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
579                 if (alreadyFailed) {
580                     ctx.write(msg, promise);
581                 } else {
582                     this.alreadyFailed = true;
583                     ReferenceCountUtil.release(msg);
584                     promise.tryFailure(new RuntimeException());
585                 }
586             }
587 <a name="4"></a>        };
588         EmbeddedChannel ch = new EmbeddedChannel(failFirst, new ChunkedWriteHandler());
589         ChannelFuture r1 = <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.write(input1);
590         ChannelFuture r2 = ch.writeAndFlush(input2).awaitUninterruptibly();
591         assertTrue(ch.finish());
592         assertTrue(r1.cause() instanceof RuntimeException);
593         assertTrue(r2.isSuccess());
594         int i = 0</b></font>;
595         int read = 0;
596         for (;;) {
597             ByteBuf buffer = ch.readOutbound();
598             if (buffer == null) {
599                 break;
600             }
601             while (buffer.isReadable()) {
602                 assertEquals(BYTES[i++], buffer.readByte());
603                 read++;
604                 if (i == BYTES.length) {
605                     i = 0;
606                 }
607             }
608             buffer.release();
609         }
610         assertEquals(BYTES.length, read);
611     }
612     private static final class TestChunkedInput implements ChunkedInput&lt;ByteBuf&gt; {
613         private final int chunksToProduce;
614         private int chunksProduced;
615         private volatile boolean closed;
616         TestChunkedInput(int chunksToProduce) {
617             this.chunksToProduce = chunksToProduce;
618         }
619         @Override
620         public boolean isEndOfInput() {
621             return chunksProduced &gt;= chunksToProduce;
622         }
623         @Override
624         public void close() {
625             closed = true;
626         }
627         @Override
628         public ByteBuf readChunk(ChannelHandlerContext ctx) {
629             return readChunk(ctx.alloc());
630         }
631         @Override
632         public ByteBuf readChunk(ByteBufAllocator allocator) {
633             ByteBuf buf = allocator.buffer();
634             buf.writeInt(chunksProduced);
635             chunksProduced++;
636             return buf;
637         }
638         @Override
639         public long length() {
640             return chunksToProduce;
641         }
642         @Override
643         public long progress() {
644             return chunksProduced;
645         }
646         boolean isClosed() {
647             return closed;
648         }
649     }
650     private static final class ThrowingChunkedInput implements ChunkedInput&lt;ByteBuf&gt; {
651         private final Exception error;
652         private volatile boolean closed;
653         ThrowingChunkedInput(Exception error) {
654             this.error = error;
655         }
656         @Override
657         public boolean isEndOfInput() {
658             return false;
659         }
660         @Override
661         public void close() {
662             closed = true;
663         }
664         @Override
665         public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
666             return readChunk(ctx.alloc());
667         }
668         @Override
669         public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
670             throw error;
671         }
672         @Override
673         public long length() {
674             return -1;
675         }
676         @Override
677         public long progress() {
678             return -1;
679         }
680         boolean isClosed() {
681             return closed;
682         }
683     }
684 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
