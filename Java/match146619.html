<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for LocalTransportThreadModelTest.java & DefaultChannelPipelineTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for LocalTransportThreadModelTest.java & DefaultChannelPipelineTest.java
      </h3>
      <h1 align="center">
        16.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>LocalTransportThreadModelTest.java (40.5618%)<TH>DefaultChannelPipelineTest.java (10.485043%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#0',2,'match146619-1.html#0',3)" NAME="0">(103-122)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#0',2,'match146619-1.html#0',3)" NAME="0">(983-1005)</A><TD ALIGN=center><FONT COLOR="#ff0000">33</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#1',2,'match146619-1.html#1',3)" NAME="1">(18-54)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#1',2,'match146619-1.html#1',3)" NAME="1">(46-83)</A><TD ALIGN=center><FONT COLOR="#ff0000">33</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#2',2,'match146619-1.html#2',3)" NAME="2">(202-214)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#2',2,'match146619-1.html#2',3)" NAME="2">(183-198)</A><TD ALIGN=center><FONT COLOR="#9a0000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#3',2,'match146619-1.html#3',3)" NAME="3">(352-363)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#3',2,'match146619-1.html#3',3)" NAME="3">(206-220)</A><TD ALIGN=center><FONT COLOR="#830000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#4',2,'match146619-1.html#4',3)" NAME="4">(245-255)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#4',2,'match146619-1.html#4',3)" NAME="4">(972-983)</A><TD ALIGN=center><FONT COLOR="#830000">17</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#5',2,'match146619-1.html#5',3)" NAME="5">(186-202)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#5',2,'match146619-1.html#5',3)" NAME="5">(482-493)</A><TD ALIGN=center><FONT COLOR="#830000">17</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#6',2,'match146619-1.html#6',3)" NAME="6">(146-153)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#6',2,'match146619-1.html#6',3)" NAME="6">(637-648)</A><TD ALIGN=center><FONT COLOR="#7b0000">16</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#7',2,'match146619-1.html#7',3)" NAME="7">(59-66)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#7',2,'match146619-1.html#7',3)" NAME="7">(97-103)</A><TD ALIGN=center><FONT COLOR="#6c0000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#8',2,'match146619-1.html#8',3)" NAME="8">(255-266)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#8',2,'match146619-1.html#8',3)" NAME="8">(1127-1137)</A><TD ALIGN=center><FONT COLOR="#640000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#9',2,'match146619-1.html#9',3)" NAME="9">(379-385)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#9',2,'match146619-1.html#9',3)" NAME="9">(1882-1888)</A><TD ALIGN=center><FONT COLOR="#550000">11</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#10',2,'match146619-1.html#10',3)" NAME="10">(66-72)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#10',2,'match146619-1.html#10',3)" NAME="10">(397-402)</A><TD ALIGN=center><FONT COLOR="#550000">11</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#11',2,'match146619-1.html#11',3)" NAME="11">(400-405)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#11',2,'match146619-1.html#11',3)" NAME="11">(858-864)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#12',2,'match146619-1.html#12',3)" NAME="12">(385-390)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#12',2,'match146619-1.html#12',3)" NAME="12">(2045-2051)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#13',2,'match146619-1.html#13',3)" NAME="13">(225-232)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#13',2,'match146619-1.html#13',3)" NAME="13">(1734-1743)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#14',2,'match146619-1.html#14',3)" NAME="14">(214-223)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#14',2,'match146619-1.html#14',3)" NAME="14">(1645-1654)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#15',2,'match146619-1.html#15',3)" NAME="15">(91-96)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#15',2,'match146619-1.html#15',3)" NAME="15">(348-353)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#16',2,'match146619-1.html#16',3)" NAME="16">(76-80)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#16',2,'match146619-1.html#16',3)" NAME="16">(124-130)</A><TD ALIGN=center><FONT COLOR="#4d0000">10</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#17',2,'match146619-1.html#17',3)" NAME="17">(599-604)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#17',2,'match146619-1.html#17',3)" NAME="17">(1620-1626)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#18',2,'match146619-1.html#18',3)" NAME="18">(589-594)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#18',2,'match146619-1.html#18',3)" NAME="18">(1632-1637)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#19',2,'match146619-1.html#19',3)" NAME="19">(555-560)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#19',2,'match146619-1.html#19',3)" NAME="19">(1608-1614)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#20',2,'match146619-1.html#20',3)" NAME="20">(544-548)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#20',2,'match146619-1.html#20',3)" NAME="20">(2240-2244)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#21',2,'match146619-1.html#21',3)" NAME="21">(509-514)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#21',2,'match146619-1.html#21',3)" NAME="21">(1270-1275)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#22',2,'match146619-1.html#22',3)" NAME="22">(496-500)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#22',2,'match146619-1.html#22',3)" NAME="22">(1934-1938)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#23',2,'match146619-1.html#23',3)" NAME="23">(457-462)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#23',2,'match146619-1.html#23',3)" NAME="23">(1214-1219)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#24',2,'match146619-1.html#24',3)" NAME="24">(431-439)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#24',2,'match146619-1.html#24',3)" NAME="24">(711-716)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#25',2,'match146619-1.html#25',3)" NAME="25">(394-398)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#25',2,'match146619-1.html#25',3)" NAME="25">(1596-1601)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#26',2,'match146619-1.html#26',3)" NAME="26">(314-316)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#26',2,'match146619-1.html#26',3)" NAME="26">(547-551)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
<TR><TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT><TD><A HREF="javascript:ZweiFrames('match146619-0.html#27',2,'match146619-1.html#27',3)" NAME="27">(81-85)<TD><A HREF="javascript:ZweiFrames('match146619-0.html#27',2,'match146619-1.html#27',3)" NAME="27">(845-849)</A><TD ALIGN=center><FONT COLOR="#450000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LocalTransportThreadModelTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="1"></A> */
package io.netty.channel.local;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match146619-1.html#1',3,'match146619-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.DefaultEventExecutorGroup;
import io.netty.util.concurrent.DefaultThreadFactory;
import io.netty.util.concurrent.EventExecutorGroup;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import java.util.HashSet;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class LocalTransportThreadModelTest {

    private static EventLoopGroup group;
    private static LocalAddress localAddr</B></FONT>;

<A NAME="7"></A>    @BeforeAll
    public static void init() {
        // Configure a test server
        group = <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match146619-1.html#7',3,'match146619-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new DefaultEventLoopGroup();
        ServerBootstrap sb = new ServerBootstrap();
        sb.group(group)
          .channel(LocalServerChannel.class)
<A NAME="10"></A>          .childHandler(new ChannelInitializer&lt;LocalChannel&gt;() {
              @Override
              public void initChannel(LocalChannel ch) throws Exception {
                  ch.pipeline</B></FONT>().addLast(<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match146619-1.html#10',3,'match146619-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new ChannelInboundHandlerAdapter() {
                      @Override
                      public void channelRead(ChannelHandlerContext ctx, Object msg) {
                          // Discard
                          ReferenceCountUtil.release(msg);
                      }
                  }</B></FONT>);
<A NAME="16"></A>              }
          });

        <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match146619-1.html#16',3,'match146619-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>localAddr = (LocalAddress) sb.bind(LocalAddress.ANY).syncUninterruptibly().channel().localAddress();
    }
<A NAME="27"></A>
    @AfterAll
    public static void destroy() throws Exception {</B></FONT>
        <FONT color="#e77471"><A HREF="javascript:ZweiFrames('match146619-1.html#27',3,'match146619-top.html#27',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>group.shutdownGracefully().sync();
    }

    @Test
    @Timeout(value = 30000, u</B></FONT>nit = TimeUnit.MILLISECONDS)
    @Disabled(&quot;regression test&quot;)
    public void testStagedExecutionMultiple() throws Throwable {
<A NAME="15"></A>        for (int i = 0; i &lt; 10; i ++) {
            testStagedExecution();
        }
    <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match146619-1.html#15',3,'match146619-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void testStagedExecution() throws Throwable {
        EventLoopGroup l = new</B></FONT> DefaultEventLoopGroup(4, new DefaultThreadFactory(&quot;l&quot;));
        EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e1&quot;));
        EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e2&quot;));
        ThreadNameAuditor h1 = new ThreadNameAuditor();
<A NAME="0"></A>        ThreadNameAuditor h2 = new ThreadNameAuditor();
        ThreadNameAuditor h3 = new ThreadNameAuditor(true);

        Channel ch = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match146619-1.html#0',3,'match146619-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new LocalChannel();
        // With no EventExecutor specified, h1 will be always invoked by EventLoop 'l'.
        ch.pipeline().addLast(h1);
        // h2 will be always invoked by EventExecutor 'e1'.
        ch.pipeline().addLast(e1, h2);
        // h3 will be always invoked by EventExecutor 'e2'.
        ch.pipeline().addLast(e2, h3);

        l.register(ch).sync().channel().connect(localAddr).sync();

        // Fire inbound events from all possible starting points.
        ch.pipeline().fireChannelRead(&quot;1&quot;);
        ch.pipeline().context(h1).fireChannelRead(&quot;2&quot;);
        ch.pipeline().context(h2).fireChannelRead(&quot;3&quot;);
        ch.pipeline().context(h3).fireChannelRead(&quot;4&quot;);
        // Fire outbound events from all possible starting points.
        ch.pipeline().write(&quot;5&quot;);
        ch.pipeline().context(h3).write(&quot;6&quot;);
        ch.pipeline().context(h2).write(&quot;7&quot;);
        ch.pipeline().context(h1).writeAndFlush</B></FONT>(&quot;8&quot;).sync();

        ch.close().sync();

        // Wait until all events are handled completely.
        while (h1.outboundThreadNames.size() &lt; 3 || h3.inboundThreadNames.size() &lt; 3 ||
               h1.removalThreadNames.size() &lt; 1) {
            if (h1.exception.get() != null) {
                throw h1.exception.get();
            }
            if (h2.exception.get() != null) {
                throw h2.exception.get();
            }
            if (h3.exception.get() != null) {
                throw h3.exception.get();
            }

            Thread.sleep(10);
        }

        String currentName = Thread.currentThread().getName();
<A NAME="6"></A>
        try {
            // Events should never be handled from the current thread.
            <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match146619-1.html#6',3,'match146619-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertFalse(h1.inboundThreadNames.contains(currentName));
            assertFalse(h2.inboundThreadNames.contains(currentName));
            assertFalse(h3.inboundThreadNames.contains(currentName));
            assertFalse(h1.outboundThreadNames.contains(currentName));
            assertFalse(h2.outboundThreadNames.contains(currentName));
            assertFalse(h3.outboundThreadNames.contains(currentName));
            assertFalse(h1.removalThreadNames.contains(currentName));
            assertFalse(h2.removalThreadNames.contains</B></FONT>(currentName));
            assertFalse(h3.removalThreadNames.contains(currentName));

            // Assert that events were handled by the correct executor.
            for (String name: h1.inboundThreadNames) {
                assertTrue(name.startsWith(&quot;l-&quot;));
            }
            for (String name: h2.inboundThreadNames) {
                assertTrue(name.startsWith(&quot;e1-&quot;));
            }
            for (String name: h3.inboundThreadNames) {
                assertTrue(name.startsWith(&quot;e2-&quot;));
            }
            for (String name: h1.outboundThreadNames) {
                assertTrue(name.startsWith(&quot;l-&quot;));
            }
            for (String name: h2.outboundThreadNames) {
                assertTrue(name.startsWith(&quot;e1-&quot;));
            }
            for (String name: h3.outboundThreadNames) {
                assertTrue(name.startsWith(&quot;e2-&quot;));
            }
            for (String name: h1.removalThreadNames) {
                assertTrue(name.startsWith(&quot;l-&quot;));
            }
            for (String name: h2.removalThreadNames) {
                assertTrue(name.startsWith(&quot;e1-&quot;));
            }
            for (String name: h3.removalThreadNames) {
                assertTrue(name.startsWith(&quot;e2-&quot;));
<A NAME="5"></A>            }

            // Assert that the events for the same handler were handled by the same thread.
            Set&lt;String&gt; names = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match146619-1.html#5',3,'match146619-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new HashSet&lt;String&gt;();
            names.addAll(h1.inboundThreadNames);
            names.addAll(h1.outboundThreadNames);
            names.addAll(h1.removalThreadNames);
            assertEquals(1, names.size());

            names.clear();
            names.addAll(h2.inboundThreadNames);
            names.addAll(h2.outboundThreadNames);
            names.addAll(h2.removalThreadNames);
            assertEquals(1, names.size());

            names.clear();
<A NAME="2"></A>            names.addAll(h3.inboundThreadNames);
            names.addAll(h3.outboundThreadNames);
            names.addAll(h3.removalThreadNames);
            assertEquals</B></FONT>(1, <FONT color="#980517"><A HREF="javascript:ZweiFrames('match146619-1.html#2',3,'match146619-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>names.size());

            // Count the number of events
            assertEquals(1, h1.inboundThreadNames.size());
            assertEquals(2, h2.inboundThreadNames.size());
            assertEquals(3, h3.inboundThreadNames.size());
            assertEquals(3, h1.outboundThreadNames.size());
            assertEquals(2, h2.outboundThreadNames.size());
            assertEquals(1, h3.outboundThreadNames.size());
<A NAME="14"></A>            assertEquals(1, h1.removalThreadNames.size());
            assertEquals(1, h2.removalThreadNames.size());
            assertEquals(1, h3.removalThreadNames.size());
        }</B></FONT> catch (AssertionError e) <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match146619-1.html#14',3,'match146619-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            System.out.println(&quot;H1I: &quot; + h1.inboundThreadNames);
            System.out.println(&quot;H2I: &quot; + h2.inboundThreadNames);
            System.out.println(&quot;H3I: &quot; + h3.inboundThreadNames);
            System.out.println(&quot;H1O: &quot; + h1.outboundThreadNames);
            System.out.println(&quot;H2O: &quot; + h2.outboundThreadNames);
            System.out.println(&quot;H3O: &quot; + h3.outboundThreadNames);
            System.out.println(&quot;H1R: &quot; + h1.removalThreadNames);
<A NAME="13"></A>            System.out.println(&quot;H2R: &quot; + h2.removalThreadNames);
            System.out.println</B></FONT>(&quot;H3R: &quot; + h3.removalThreadNames);
            throw e;
        } finally <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match146619-1.html#13',3,'match146619-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            l.shutdownGracefully();
            e1.shutdownGracefully();
            e2.shutdownGracefully();

            l.terminationFuture().sync();
            e1.terminationFuture().sync();
            e2.terminationFuture</B></FONT>().sync();
        }
    }

    @Test
    @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)
    @Disabled
    public void testConcurrentMessageBufferAccess() throws Throwable {
        EventLoopGroup l = new DefaultEventLoopGroup(4, new DefaultThreadFactory(&quot;l&quot;));
        EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e1&quot;));
<A NAME="4"></A>        EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e2&quot;));
        EventExecutorGroup e3 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e3&quot;));
        EventExecutorGroup e4 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory(&quot;e4&quot;));
        EventExecutorGroup e5 = new DefaultEventExecutorGroup(4, <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match146619-1.html#4',3,'match146619-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new DefaultThreadFactory(&quot;e5&quot;));

        try {
            final MessageForwarder1 h1 = new MessageForwarder1();
            final MessageForwarder2 h2 = new MessageForwarder2();
            final MessageForwarder3 h3 = new MessageForwarder3();
            final MessageForwarder1 h4 = new MessageForwarder1();
<A NAME="8"></A>            final MessageForwarder2 h5 = new MessageForwarder2();
            final MessageDiscarder  h6 = new MessageDiscarder();

            final Channel ch = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match146619-1.html#8',3,'match146619-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new LocalChannel()</B></FONT>;

            // inbound:  int -&gt; byte[4] -&gt; int -&gt; int -&gt; byte[4] -&gt; int -&gt; /dev/null
            // outbound: int -&gt; int -&gt; byte[4] -&gt; int -&gt; int -&gt; byte[4] -&gt; /dev/null
            ch.pipeline().addLast(h1)
                         .addLast(e1, h2)
                         .addLast(e2, h3)
                         .addLast(e3, h4)
                         .addLast(e4, h5)
                         .addLast(e5, h6);

            l.register</B></FONT>(ch).sync().channel().connect(localAddr).sync();

            final int ROUNDS = 1024;
            final int ELEMS_PER_ROUNDS = 8192;
            final int TOTAL_CNT = ROUNDS * ELEMS_PER_ROUNDS;
            for (int i = 0; i &lt; TOTAL_CNT;) {
                final int start = i;
                final int end = i + ELEMS_PER_ROUNDS;
                i = end;

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        for (int j = start; j &lt; end; j ++) {
                            ch.pipeline().fireChannelRead(Integer.valueOf(j));
                        }
                    }
                });
            }

            while (h1.inCnt &lt; TOTAL_CNT || h2.inCnt &lt; TOTAL_CNT || h3.inCnt &lt; TOTAL_CNT ||
                    h4.inCnt &lt; TOTAL_CNT || h5.inCnt &lt; TOTAL_CNT || h6.inCnt &lt; TOTAL_CNT) {
                if (h1.exception.get() != null) {
                    throw h1.exception.get();
                }
                if (h2.exception.get() != null) {
                    throw h2.exception.get();
                }
                if (h3.exception.get() != null) {
                    throw h3.exception.get();
                }
                if (h4.exception.get() != null) {
                    throw h4.exception.get();
                }
                if (h5.exception.get() != null) {
                    throw h5.exception.get();
                }
                if (h6.exception.get() != null) {
                    throw h6.exception.get();
                }
                Thread.sleep(10);
            }

            for (int i = 0; i &lt; TOTAL_CNT;) {
                final int start = i;
<A NAME="26"></A>                final int end = i + ELEMS_PER_ROUNDS;
                i = end;

                <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match146619-1.html#26',3,'match146619-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ch.pipeline().context(h6).executor().execute(new Runnable() {
                    @Override
                    public void run() {</B></FONT>
                        for (int j = start; j &lt; end; j ++) {
                            ch.write(Integer.valueOf(j));
                        }
                        ch.flush();
                    }
                });
            }

            while (h1.outCnt &lt; TOTAL_CNT || h2.outCnt &lt; TOTAL_CNT || h3.outCnt &lt; TOTAL_CNT ||
                    h4.outCnt &lt; TOTAL_CNT || h5.outCnt &lt; TOTAL_CNT || h6.outCnt &lt; TOTAL_CNT) {
                if (h1.exception.get() != null) {
                    throw h1.exception.get();
                }
                if (h2.exception.get() != null) {
                    throw h2.exception.get();
                }
                if (h3.exception.get() != null) {
                    throw h3.exception.get();
                }
                if (h4.exception.get() != null) {
                    throw h4.exception.get();
                }
                if (h5.exception.get() != null) {
                    throw h5.exception.get();
                }
                if (h6.exception.get() != null) {
                    throw h6.exception.get();
                }
                Thread.sleep(10);
            }

            ch.close().sync();
<A NAME="3"></A>        } finally {
            l.shutdownGracefully();
            e1.shutdownGracefully();
            <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match146619-1.html#3',3,'match146619-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>e2.shutdownGracefully();
            e3.shutdownGracefully();
            e4.shutdownGracefully();
            e5.shutdownGracefully();

            l.terminationFuture().sync();
            e1.terminationFuture().sync();
            e2.terminationFuture().sync();
            e3.terminationFuture().sync();
            e4.terminationFuture().sync();
            e5.terminationFuture().sync();
        }</B></FONT>
    }

    private static class ThreadNameAuditor extends ChannelDuplexHandler {

        private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();

        private final Queue&lt;String&gt; inboundThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
        private final Queue&lt;String&gt; outboundThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
        private final Queue&lt;String&gt; removalThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
        private final boolean discard;

        ThreadNameAuditor() {
<A NAME="9"></A>            this(false);
        }

        <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match146619-1.html#9',3,'match146619-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ThreadNameAuditor(boolean discard) {
            this.discard = discard;
        }
<A NAME="12"></A>
        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
            removalThreadNames.add</B></FONT>(<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match146619-1.html#12',3,'match146619-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Thread.currentThread().getName());
        }

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            inboundThreadNames.add</B></FONT>(Thread.currentThread().getName());
<A NAME="25"></A>            if (!discard) {
                ctx.fireChannelRead(msg);
            }
        <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match146619-1.html#25',3,'match146619-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

        @Override
<A NAME="11"></A>        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            outboundThreadNames.add</B></FONT>(Thread.currentThread().getName());
            ctx.write(msg, promise);
        <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match146619-1.html#11',3,'match146619-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            exception.compareAndSet(null, cause);
            System.err.print('[' + Thread.currentThread().getName</B></FONT>() + &quot;] &quot;);
            cause.printStackTrace();
            super.exceptionCaught(ctx, cause);
        }
    }

    /**
     * Converts integers into a binary stream.
     */
    private static class MessageForwarder1 extends ChannelDuplexHandler {

        private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
        private volatile int inCnt;
        private volatile int outCnt;
        private volatile Thread t;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            Thread t = this.t;
            if (t == null) {
                this.t = Thread.currentThread();
            } else {
                assertSame(t, Thread.currentThread());
<A NAME="24"></A>            }

            ByteBuf out = ctx.alloc().buffer(4);
            int m = <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match146619-1.html#24',3,'match146619-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>((Integer) msg).intValue();
            int expected = inCnt ++;
            assertEquals(expected, m);
            out.writeInt(m);

            ctx.fireChannelRead(out);
        }

        @</B></FONT>Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            assertSame(t, Thread.currentThread());

            // Don't let the write request go to the server-side channel - just swallow.
            boolean swallow = this == ctx.pipeline().first();

            ByteBuf m = (ByteBuf) msg;
            int count = m.readableBytes() / 4;
            for (int j = 0; j &lt; count; j ++) {
                int actual = m.readInt();
                int expected = outCnt ++;
                assertEquals(expected, actual);
                if (!swallow) {
                    ctx.write(actual);
<A NAME="23"></A>                }
            }
            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER, promise);
            <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match146619-1.html#23',3,'match146619-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>m.release();
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            exception.compareAndSet</B></FONT>(null, cause);
            //System.err.print(&quot;[&quot; + Thread.currentThread().getName() + &quot;] &quot;);
            //cause.printStackTrace();
            super.exceptionCaught(ctx, cause);
        }
    }

    /**
     * Converts a binary stream into integers.
     */
    private static class MessageForwarder2 extends ChannelDuplexHandler {

        private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
        private volatile int inCnt;
        private volatile int outCnt;
        private volatile Thread t;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            Thread t = this.t;
            if (t == null) {
                this.t = Thread.currentThread();
            } else {
                assertSame(t, Thread.currentThread());
            }

            ByteBuf m = (ByteBuf) msg;
            int count = m.readableBytes() / 4;
            for (int j = 0; j &lt; count; j ++) {
                int actual = m.readInt();
                int expected = inCnt ++;
<A NAME="22"></A>                assertEquals(expected, actual);
                ctx.fireChannelRead(actual);
            }
            <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match146619-1.html#22',3,'match146619-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>m.release();
        }

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</B></FONT>
            assertSame(t, Thread.currentThread());

            ByteBuf out = ctx.alloc().buffer(4);
            int m = (Integer) msg;
            int expected = outCnt ++;
<A NAME="21"></A>            assertEquals(expected, m);
            out.writeInt(m);

            <FONT color="#947010"><A HREF="javascript:ZweiFrames('match146619-1.html#21',3,'match146619-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ctx.write(out, promise);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            exception.compareAndSet</B></FONT>(null, cause);
            //System.err.print(&quot;[&quot; + Thread.currentThread().getName() + &quot;] &quot;);
            //cause.printStackTrace();
            super.exceptionCaught(ctx, cause);
        }
    }

    /**
     * Simply forwards the received object to the next handler.
     */
    private static class MessageForwarder3 extends ChannelDuplexHandler {

        private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
        private volatile int inCnt;
        private volatile int outCnt;
        private volatile Thread t;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            Thread t = this.t;
            if (t == null) {
                this.t = Thread.currentThread();
            } else {
                assertSame(t, Thread.currentThread());
            }

            int actual = (Integer) msg;
<A NAME="20"></A>            int expected = inCnt ++;
            assertEquals(expected, actual);

            <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match146619-1.html#20',3,'match146619-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ctx.fireChannelRead(msg);
        }

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</B></FONT>
            assertSame(t, Thread.currentThread());

            int actual = (Integer) msg;
<A NAME="19"></A>            int expected = outCnt ++;
            assertEquals(expected, actual);

            <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match146619-1.html#19',3,'match146619-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ctx.write(msg, promise);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            exception.compareAndSet</B></FONT>(null, cause);
            System.err.print('[' + Thread.currentThread().getName() + &quot;] &quot;);
            cause.printStackTrace();
            super.exceptionCaught(ctx, cause);
        }
    }

    /**
     * Discards all received messages.
     */
    private static class MessageDiscarder extends ChannelDuplexHandler {

        private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
        private volatile int inCnt;
        private volatile int outCnt;
        private volatile Thread t;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            Thread t = this.t;
            if (t == null) {
                this.t = Thread.currentThread();
            } else {
                assertSame(t, Thread.currentThread());
            }

<A NAME="18"></A>            int actual = (Integer) msg;
            int expected = inCnt ++;
            assertEquals(expected, actual);
        <FONT color="#800517"><A HREF="javascript:ZweiFrames('match146619-1.html#18',3,'match146619-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

        @Override
        public void write(
                ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            assertSame</B></FONT>(t, Thread.currentThread());

<A NAME="17"></A>            int actual = (Integer) msg;
            int expected = outCnt ++;
            assertEquals(expected, actual);
            <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match146619-1.html#17',3,'match146619-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ctx.write(msg, promise);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            exception.compareAndSet</B></FONT>(null, cause);
            //System.err.print(&quot;[&quot; + Thread.currentThread().getName() + &quot;] &quot;);
            //cause.printStackTrace();
            super.exceptionCaught(ctx, cause);
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultChannelPipelineTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.channel;


import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerMask.Skip;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.channel.local.LocalAddress;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.local.LocalServerChannel;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.oio.OioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.channel.socket.oio.OioSocketChannel;
import io.netty.util.AbstractReferenceCounted;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import io.netty.util.concurrent.AbstractEventExecutor;
import io.netty.util.concurrent.DefaultEventExecutorGroup;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.EventExecutorGroup;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.ImmediateEventExecutor;
import io.netty.util.concurrent.Promise;
<A NAME="1"></A>import io.netty.util.concurrent.UnorderedThreadPoolEventExecutor;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#1',2,'match146619-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.function.Executable;

import java.net.SocketAddress;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.fail;

public class DefaultChannelPipelineTest {

    private static EventLoopGroup group;

    private Channel self</B></FONT>;
    private Channel peer;

    @BeforeAll
    public static void beforeClass() throws Exception {
        group = new DefaultEventLoopGroup(1);
    }

    @AfterAll
    public static void afterClass() throws Exception {
        group.shutdownGracefully().sync();
<A NAME="7"></A>    }

    private void setUp(final ChannelHandler... handlers) throws Exception {
        final AtomicReference&lt;Channel&gt; peerRef = <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#7',2,'match146619-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new AtomicReference&lt;Channel&gt;();
        ServerBootstrap sb = new ServerBootstrap();
        sb.group(group).channel(LocalServerChannel.class);
        sb.childHandler(new ChannelInboundHandlerAdapter() {
            @Override
            public void channelRegistered(ChannelHandlerContext ctx) {
                peerRef.set(ctx.channel</B></FONT>());
            }

            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) {
                ReferenceCountUtil.release(msg);
            }
        });

        ChannelFuture bindFuture = sb.bind(LocalAddress.ANY).sync();

        Bootstrap b = new Bootstrap();
        b.group(group).channel(LocalChannel.class);
        b.handler(new ChannelInitializer&lt;LocalChannel&gt;() {
            @Override
            protected void initChannel(LocalChannel ch) {
                ch.pipeline().addLast(handlers);
            }
<A NAME="16"></A>        });

        self = b.connect(bindFuture.channel().localAddress()).sync().channel();
        <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#16',2,'match146619-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>peer = peerRef.get();

        bindFuture.channel().close().sync();
    }

    @AfterEach
    public void tearDown() throws Exception {</B></FONT>
        if (peer != null) {
            peer.close();
            peer = null;
        }
        if (self != null) {
            self = null;
        }
    }

    @Test
    public void testFreeCalled() throws Exception {
        final CountDownLatch free = new CountDownLatch(1);

        final ReferenceCounted holder = new AbstractReferenceCounted() {
            @Override
            protected void deallocate() {
                free.countDown();
            }

            @Override
            public ReferenceCounted touch(Object hint) {
                return this;
            }
        };

        StringInboundHandler handler = new StringInboundHandler();
        setUp(handler);

        peer.writeAndFlush(holder).sync();

        assertTrue(free.await(10, TimeUnit.SECONDS));
        assertTrue(handler.called);
    }

    private static final class StringInboundHandler extends ChannelInboundHandlerAdapter {
        boolean called;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            called = true;
            if (!(msg instanceof String)) {
                ctx.fireChannelRead(msg);
            }
        }
    }

    @Test
    public void testRemoveChannelHandler() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
<A NAME="2"></A>
        ChannelHandler handler1 = newHandler();
        ChannelHandler handler2 = newHandler();
        ChannelHandler handler3 = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#2',2,'match146619-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>newHandler();

        pipeline.addLast(&quot;handler1&quot;, handler1);
        pipeline.addLast(&quot;handler2&quot;, handler2);
        pipeline.addLast(&quot;handler3&quot;, handler3);
        assertSame(pipeline.get(&quot;handler1&quot;), handler1);
        assertSame(pipeline.get(&quot;handler2&quot;), handler2);
        assertSame(pipeline.get(&quot;handler3&quot;), handler3);

        pipeline.remove(handler1);
        assertNull(pipeline.get(&quot;handler1&quot;));
        pipeline.remove(handler2);
        assertNull(pipeline.get(&quot;handler2&quot;));
        pipeline.remove(handler3);
        assertNull(pipeline.get(&quot;handler3&quot;));
    }</B></FONT>

    @Test
    public void testRemoveIfExists() {
        DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());
<A NAME="3"></A>
        ChannelHandler handler1 = newHandler();
        ChannelHandler handler2 = newHandler();
        ChannelHandler handler3 = <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#3',2,'match146619-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>newHandler();

        pipeline.addLast(&quot;handler1&quot;, handler1);
        pipeline.addLast(&quot;handler2&quot;, handler2);
        pipeline.addLast(&quot;handler3&quot;, handler3);

        assertNotNull(pipeline.removeIfExists(handler1));
        assertNull(pipeline.get(&quot;handler1&quot;));

        assertNotNull(pipeline.removeIfExists(&quot;handler2&quot;));
        assertNull(pipeline.get(&quot;handler2&quot;));

        assertNotNull(pipeline.removeIfExists(TestHandler.class));
        assertNull(pipeline.get(&quot;handler3&quot;));
    }</B></FONT>

    @Test
    public void testRemoveIfExistsDoesNotThrowException() {
        DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());

        ChannelHandler handler1 = newHandler();
        ChannelHandler handler2 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);

        assertNull(pipeline.removeIfExists(&quot;handlerXXX&quot;));
        assertNull(pipeline.removeIfExists(handler2));
        assertNull(pipeline.removeIfExists(ChannelOutboundHandlerAdapter.class));
        assertNotNull(pipeline.get(&quot;handler1&quot;));
    }

    @Test
    public void testRemoveThrowNoSuchElementException() {
        final DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());

        ChannelHandler handler1 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);

        assertThrows(NoSuchElementException.class, new Executable() {
            @Override
            public void execute() {
                pipeline.remove(&quot;handlerXXX&quot;);
            }
        });
    }

    @Test
    public void testReplaceChannelHandler() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();

        ChannelHandler handler1 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);
        pipeline.addLast(&quot;handler2&quot;, handler1);
        pipeline.addLast(&quot;handler3&quot;, handler1);
        assertSame(pipeline.get(&quot;handler1&quot;), handler1);
        assertSame(pipeline.get(&quot;handler2&quot;), handler1);
        assertSame(pipeline.get(&quot;handler3&quot;), handler1);

        ChannelHandler newHandler1 = newHandler();
        pipeline.replace(&quot;handler1&quot;, &quot;handler1&quot;, newHandler1);
        assertSame(pipeline.get(&quot;handler1&quot;), newHandler1);

        ChannelHandler newHandler3 = newHandler();
        pipeline.replace(&quot;handler3&quot;, &quot;handler3&quot;, newHandler3);
        assertSame(pipeline.get(&quot;handler3&quot;), newHandler3);

        ChannelHandler newHandler2 = newHandler();
        pipeline.replace(&quot;handler2&quot;, &quot;handler2&quot;, newHandler2);
        assertSame(pipeline.get(&quot;handler2&quot;), newHandler2);
    }

    @Test
    public void testReplaceHandlerChecksDuplicateNames() {
        final ChannelPipeline pipeline = new LocalChannel().pipeline();

        ChannelHandler handler1 = newHandler();
        ChannelHandler handler2 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);
        pipeline.addLast(&quot;handler2&quot;, handler2);

        final ChannelHandler newHandler1 = newHandler();
        assertThrows(IllegalArgumentException.class, new Executable() {
            @Override
            public void execute() {
                pipeline.replace(&quot;handler1&quot;, &quot;handler2&quot;, newHandler1);
            }
        });
    }

    @Test
    public void testReplaceNameWithGenerated() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();

        ChannelHandler handler1 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);
        assertSame(pipeline.get(&quot;handler1&quot;), handler1);

        ChannelHandler newHandler1 = newHandler();
        pipeline.replace(&quot;handler1&quot;, null, newHandler1);
        assertSame(pipeline.get(&quot;DefaultChannelPipelineTest$TestHandler#0&quot;), newHandler1);
        assertNull(pipeline.get(&quot;handler1&quot;));
    }

    @Test
    public void testRenameChannelHandler() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();

        ChannelHandler handler1 = newHandler();
        pipeline.addLast(&quot;handler1&quot;, handler1);
        pipeline.addLast(&quot;handler2&quot;, handler1);
        pipeline.addLast(&quot;handler3&quot;, handler1);
        assertSame(pipeline.get(&quot;handler1&quot;), handler1);
        assertSame(pipeline.get(&quot;handler2&quot;), handler1);
        assertSame(pipeline.get(&quot;handler3&quot;), handler1);

        ChannelHandler newHandler1 = newHandler();
        pipeline.replace(&quot;handler1&quot;, &quot;newHandler1&quot;, newHandler1);
        assertSame(pipeline.get(&quot;newHandler1&quot;), newHandler1);
        assertNull(pipeline.get(&quot;handler1&quot;));

        ChannelHandler newHandler3 = newHandler();
        pipeline.replace(&quot;handler3&quot;, &quot;newHandler3&quot;, newHandler3);
        assertSame(pipeline.get(&quot;newHandler3&quot;), newHandler3);
        assertNull(pipeline.get(&quot;handler3&quot;));

        ChannelHandler newHandler2 = newHandler();
        pipeline.replace(&quot;handler2&quot;, &quot;newHandler2&quot;, newHandler2);
        assertSame(pipeline.get(&quot;newHandler2&quot;), newHandler2);
        assertNull(pipeline.get(&quot;handler2&quot;));
    }

    @Test
    public void testChannelHandlerContextNavigation() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();

        final int HANDLER_ARRAY_LEN = 5;
        ChannelHandler[] firstHandlers = newHandlers(HANDLER_ARRAY_LEN);
        ChannelHandler[] lastHandlers = newHandlers(HANDLER_ARRAY_LEN);

        pipeline.addFirst(firstHandlers);
<A NAME="15"></A>        pipeline.addLast(lastHandlers);

        verifyContextNumber(pipeline, HANDLER_ARRAY_LEN * 2);
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#15',2,'match146619-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testThrowInExceptionCaught() throws InterruptedException {
        final CountDownLatch latch = new</B></FONT> CountDownLatch(1);
        final AtomicInteger counter = new AtomicInteger();
        Channel channel = new LocalChannel();
        try {
            group.register(channel).syncUninterruptibly();
            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                class TestException extends Exception { }

                @Override
                public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
                    throw new TestException();
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
                    if (cause instanceof TestException) {
                        ctx.executor().execute(new Runnable() {
                            @Override
                            public void run() {
                                latch.countDown();
                            }
                        });
                    }
                    counter.incrementAndGet();
                    throw new Exception();
                }
            });

            channel.pipeline().fireChannelReadComplete();
            latch.await();
            assertEquals(1, counter.get());
        } finally {
            channel.close().syncUninterruptibly();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testThrowInOtherHandlerAfterInvokedFromExceptionCaught() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicInteger counter = new AtomicInteger();
<A NAME="10"></A>        Channel channel = new LocalChannel();
        try {
            group.register(channel).syncUninterruptibly();
            channel.pipeline().addLast(<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#10',2,'match146619-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new ChannelInboundHandlerAdapter() {
                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                    ctx.fireChannelReadComplete();
                }
            }</B></FONT>, new ChannelInboundHandlerAdapter() {
                class TestException extends Exception { }

                @Override
                public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
                    throw new TestException();
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
                    if (cause instanceof TestException) {
                        ctx.executor().execute(new Runnable() {
                            @Override
                            public void run() {
                                latch.countDown();
                            }
                        });
                    }
                    counter.incrementAndGet();
                    throw new Exception();
                }
            });

            channel.pipeline().fireExceptionCaught(new Exception());
            latch.await();
            assertEquals(1, counter.get());
        } finally {
            channel.close().syncUninterruptibly();
        }
    }

    @Test
    public void testFireChannelRegistered() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addLast(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            protected void initChannel(Channel ch) {
                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                    @Override
                    public void channelRegistered(ChannelHandlerContext ctx) {
                        latch.countDown();
                    }
                });
            }
        });
        group.register(pipeline.channel());
        assertTrue(latch.await(2, TimeUnit.SECONDS));
    }

    @Test
    public void testPipelineOperation() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();

        final int handlerNum = 5;
        ChannelHandler[] handlers1 = newHandlers(handlerNum);
        ChannelHandler[] handlers2 = newHandlers(handlerNum);

        final String prefixX = &quot;x&quot;;
        for (int i = 0; i &lt; handlerNum; i++) {
            if (i % 2 == 0) {
                pipeline.addFirst(prefixX + i, handlers1[i]);
            } else {
                pipeline.addLast(prefixX + i, handlers1[i]);
            }
        }

        for (int i = 0; i &lt; handlerNum; i++) {
            if (i % 2 != 0) {
                pipeline.addBefore(prefixX + i, String.valueOf(i), handlers2[i]);
            } else {
                pipeline.addAfter(prefixX + i, String.valueOf(i), handlers2[i]);
            }
        }

        verifyContextNumber(pipeline, handlerNum * 2);
    }
<A NAME="5"></A>
    @Test
    public void testChannelHandlerContextOrder() {
        ChannelPipeline pipeline = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#5',2,'match146619-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new LocalChannel().pipeline();

        pipeline.addFirst(&quot;1&quot;, newHandler());
        pipeline.addLast(&quot;10&quot;, newHandler());

        pipeline.addBefore(&quot;10&quot;, &quot;5&quot;, newHandler());
        pipeline.addAfter(&quot;1&quot;, &quot;3&quot;, newHandler());
        pipeline.addBefore(&quot;5&quot;, &quot;4&quot;, newHandler());
        pipeline.addAfter(&quot;5&quot;, &quot;6&quot;, newHandler());

        pipeline.addBefore(&quot;1&quot;, &quot;0&quot;, newHandler());
        pipeline.addAfter(&quot;10&quot;, &quot;11&quot;, newHandler</B></FONT>());

        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
        assertNotNull(ctx);
        while (ctx != null) {
            int i = toInt(ctx.name());
            int j = next(ctx);
            if (j != -1) {
                assertTrue(i &lt; j);
            } else {
                assertNull(ctx.next.next);
            }
            ctx = ctx.next;
        }

        verifyContextNumber(pipeline, 8);
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testLifeCycleAwareness() throws Exception {
        setUp();

        ChannelPipeline p = self.pipeline();

        final List&lt;LifeCycleAwareTestHandler&gt; handlers = new ArrayList&lt;LifeCycleAwareTestHandler&gt;();
        final int COUNT = 20;
        final CountDownLatch addLatch = new CountDownLatch(COUNT);
        for (int i = 0; i &lt; COUNT; i++) {
            final LifeCycleAwareTestHandler handler = new LifeCycleAwareTestHandler(&quot;handler-&quot; + i);

            // Add handler.
            p.addFirst(handler.name, handler);
            self.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // Validate handler life-cycle methods called.
                    handler.validate(true, false);

                    // Store handler into the list.
                    handlers.add(handler);

                    addLatch.countDown();
                }
            });
        }
        addLatch.await();

        // Change the order of remove operations over all handlers in the pipeline.
        Collections.shuffle(handlers);

<A NAME="26"></A>        final CountDownLatch removeLatch = new CountDownLatch(COUNT);

        for (final LifeCycleAwareTestHandler handler : handlers) {
            <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#26',2,'match146619-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(handler, p.remove(handler.name));

            self.eventLoop().execute(new Runnable() {
                @Override
                public void run() {</B></FONT>
                    // Validate handler life-cycle methods called.
                    handler.validate(true, true);
                    removeLatch.countDown();
                }
            });
        }
        removeLatch.await();
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testRemoveAndForwardInbound() throws Exception {
        final BufferedTestHandler handler1 = new BufferedTestHandler();
        final BufferedTestHandler handler2 = new BufferedTestHandler();

        setUp(handler1, handler2);

        self.eventLoop().submit(new Runnable() {
            @Override
            public void run() {
                ChannelPipeline p = self.pipeline();
                handler1.inboundBuffer.add(8);
                assertEquals(8, handler1.inboundBuffer.peek());
                assertTrue(handler2.inboundBuffer.isEmpty());
                p.remove(handler1);
                assertEquals(1, handler2.inboundBuffer.size());
                assertEquals(8, handler2.inboundBuffer.peek());
            }
        }).sync();
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testRemoveAndForwardOutbound() throws Exception {
        final BufferedTestHandler handler1 = new BufferedTestHandler();
        final BufferedTestHandler handler2 = new BufferedTestHandler();

        setUp(handler1, handler2);

        self.eventLoop().submit(new Runnable() {
            @Override
            public void run() {
                ChannelPipeline p = self.pipeline();
                handler2.outboundBuffer.add(8);
                assertEquals(8, handler2.outboundBuffer.peek());
                assertTrue(handler1.outboundBuffer.isEmpty());
                p.remove(handler2);
                assertEquals(1, handler1.outboundBuffer.size());
                assertEquals(8, handler1.outboundBuffer.peek());
            }
        }).sync();
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testReplaceAndForwardOutbound() throws Exception {
        final BufferedTestHandler handler1 = new BufferedTestHandler();
        final BufferedTestHandler handler2 = new BufferedTestHandler();

        setUp(handler1);

        self.eventLoop().submit(new Runnable() {
            @Override
            public void run() {
                ChannelPipeline p = self.pipeline();
                handler1.outboundBuffer.add(8);
                assertEquals(8, handler1.outboundBuffer.peek());
                assertTrue(handler2.outboundBuffer.isEmpty());
                p.replace(handler1, &quot;handler2&quot;, handler2);
                assertEquals(8, handler2.outboundBuffer.peek());
            }
        }).sync();
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testReplaceAndForwardInboundAndOutbound() throws Exception {
        final BufferedTestHandler handler1 = new BufferedTestHandler();
        final BufferedTestHandler handler2 = new BufferedTestHandler();

        setUp(handler1);

<A NAME="6"></A>        self.eventLoop().submit(new Runnable() {
            @Override
            public void run() {
                ChannelPipeline p = <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#6',2,'match146619-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>self.pipeline();
                handler1.inboundBuffer.add(8);
                handler1.outboundBuffer.add(8);

                assertEquals(8, handler1.inboundBuffer.peek());
                assertEquals(8, handler1.outboundBuffer.peek());
                assertTrue(handler2.inboundBuffer.isEmpty());
                assertTrue(handler2.outboundBuffer.isEmpty());

                p.replace(handler1, &quot;handler2&quot;, handler2);
                assertEquals(8, handler2.outboundBuffer.peek());
                assertEquals(8, handler2.inboundBuffer.peek</B></FONT>());
            }
        }).sync();
    }

    @Test
    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
    public void testRemoveAndForwardInboundOutbound() throws Exception {
        final BufferedTestHandler handler1 = new BufferedTestHandler();
        final BufferedTestHandler handler2 = new BufferedTestHandler();
        final BufferedTestHandler handler3 = new BufferedTestHandler();

        setUp(handler1, handler2, handler3);

        self.eventLoop().submit(new Runnable() {
            @Override
            public void run() {
                ChannelPipeline p = self.pipeline();
                handler2.inboundBuffer.add(8);
                handler2.outboundBuffer.add(8);

                assertEquals(8, handler2.inboundBuffer.peek());
                assertEquals(8, handler2.outboundBuffer.peek());

                assertEquals(0, handler1.outboundBuffer.size());
                assertEquals(0, handler3.inboundBuffer.size());

                p.remove(handler2);
                assertEquals(8, handler3.inboundBuffer.peek());
                assertEquals(8, handler1.outboundBuffer.peek());
            }
        }).sync();
    }

    // Tests for https://github.com/netty/netty/issues/2349
    @Test
    public void testCancelBind() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ChannelFuture future = pipeline.bind(new LocalAddress(&quot;test&quot;), promise);
        assertTrue(future.isCancelled());
    }

    @Test
    public void testCancelConnect() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ChannelFuture future = pipeline.connect(new LocalAddress(&quot;test&quot;), promise);
        assertTrue(future.isCancelled());
    }

    @Test
    public void testCancelDisconnect() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
<A NAME="24"></A>        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(<FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#24',2,'match146619-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>promise.cancel(false));
        ChannelFuture future = pipeline.disconnect(promise);
        assertTrue(future.isCancelled());
    }

    @</B></FONT>Test
    public void testCancelClose() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ChannelFuture future = pipeline.close(promise);
        assertTrue(future.isCancelled());
    }

    @Test
    public void testWrongPromiseChannel() throws Exception {
        final ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel()).sync();

        ChannelPipeline pipeline2 = new LocalChannel().pipeline();
        group.register(pipeline2.channel()).sync();

        try {
            final ChannelPromise promise2 = pipeline2.channel().newPromise();
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() {
                    pipeline.close(promise2);
                }
            });
        } finally {
            pipeline.close();
            pipeline2.close();
        }
    }

    @Test
    public void testUnexpectedVoidChannelPromise() throws Exception {
        final ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel()).sync();

        try {
            final ChannelPromise promise = new VoidChannelPromise(pipeline.channel(), false);
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() {
                    pipeline.close(promise);
                }
            });
        } finally {
            pipeline.close();
        }
    }

    @Test
    public void testUnexpectedVoidChannelPromiseCloseFuture() throws Exception {
        final ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel()).sync();

        try {
            final ChannelPromise promise = (ChannelPromise) pipeline.channel().closeFuture();
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() {
                    pipeline.close(promise);
                }
            });
        } finally {
            pipeline.close();
        }
    }

    @Test
    public void testCancelDeregister() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ChannelFuture future = pipeline.deregister(promise);
        assertTrue(future.isCancelled());
    }

    @Test
    public void testCancelWrite() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ByteBuf buffer = Unpooled.buffer();
        assertEquals(1, buffer.refCnt());
        ChannelFuture future = pipeline.write(buffer, promise);
        assertTrue(future.isCancelled());
        assertEquals(0, buffer.refCnt());
    }

    @Test
    public void testCancelWriteAndFlush() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        group.register(pipeline.channel());

        ChannelPromise promise = pipeline.channel().newPromise();
        assertTrue(promise.cancel(false));
        ByteBuf buffer = Unpooled.buffer();
        assertEquals(1, buffer.refCnt());
        ChannelFuture future = pipeline.writeAndFlush(buffer, promise);
        assertTrue(future.isCancelled());
        assertEquals(0, buffer.refCnt());
    }

    @Test
    public void testFirstContextEmptyPipeline() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        assertNull(pipeline.firstContext());
    }

    @Test
    public void testLastContextEmptyPipeline() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        assertNull(pipeline.lastContext());
    }

    @Test
    public void testFirstHandlerEmptyPipeline() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        assertNull(pipeline.first());
    }

<A NAME="27"></A>    @Test
    public void testLastHandlerEmptyPipeline() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#27',2,'match146619-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertNull(pipeline.last());
    }

    @Test
    @Timeout(value = 5000, u</B></FONT>nit = TimeUnit.MILLISECONDS)
    public void testChannelInitializerException() throws Exception {
        final IllegalStateException exception = new IllegalStateException();
        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
        final CountDownLatch latch = new CountDownLatch(1);
        EmbeddedChannel channel = new EmbeddedChannel(new ChannelInitializer&lt;Channel&gt;() {
<A NAME="11"></A>            @Override
            protected void initChannel(Channel ch) {
                throw exception;
            <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#11',2,'match146619-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

            @Override
            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
                super.exceptionCaught(ctx, cause);
                error.set(cause);
                latch.countDown</B></FONT>();
            }
        });
        latch.await();
        assertFalse(channel.isActive());
        assertSame(exception, error.get());
    }

    @Test
    public void testChannelUnregistrationWithCustomExecutor() throws Exception {
        final CountDownLatch channelLatch = new CountDownLatch(1);
        final CountDownLatch handlerLatch = new CountDownLatch(1);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addLast(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            protected void initChannel(Channel ch) {
                ch.pipeline().addLast(new WrapperExecutor(),
                        new ChannelInboundHandlerAdapter() {

                            @Override
                            public void channelUnregistered(ChannelHandlerContext ctx) {
                                channelLatch.countDown();
                            }

                            @Override
                            public void handlerRemoved(ChannelHandlerContext ctx) {
                                handlerLatch.countDown();
                            }
                        });
            }
        });
        Channel channel = pipeline.channel();
        group.register(channel);
        channel.close();
        channel.deregister();
        assertTrue(channelLatch.await(2, TimeUnit.SECONDS));
        assertTrue(handlerLatch.await(2, TimeUnit.SECONDS));
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddHandlerBeforeRegisteredThenRemove() {
        final EventLoop loop = group.next();

        CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addFirst(handler);
        assertFalse(handler.addedPromise.isDone());
        group.register(pipeline.channel());
        handler.addedPromise.syncUninterruptibly();
        pipeline.remove(handler);
        handler.removedPromise.syncUninterruptibly();
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddHandlerBeforeRegisteredThenReplace() throws Exception {
        final EventLoop loop = group.next();
        final CountDownLatch latch = new CountDownLatch(1);

        CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addFirst(handler);
        assertFalse(handler.addedPromise.isDone());
        group.register(pipeline.channel());
        handler.addedPromise.syncUninterruptibly();
        pipeline.replace(handler, null, new ChannelHandlerAdapter() {
            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                latch.countDown();
            }
        });
        handler.removedPromise.syncUninterruptibly();
        latch.await();
    }

    @Test
    public void testAddRemoveHandlerNotRegistered() throws Throwable {
        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
        ChannelHandler handler = new ErrorChannelHandler(error);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addFirst(handler);
        pipeline.remove(handler);

        Throwable cause = error.get();
        if (cause != null) {
            throw cause;
        }
    }

    @Test
    public void testAddReplaceHandlerNotRegistered() throws Throwable {
        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
        ChannelHandler handler = new ErrorChannelHandler(error);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addFirst(handler);
        pipeline.replace(handler, null, new ErrorChannelHandler(error));

        Throwable cause = error.get();
        if (cause != null) {
            throw cause;
        }
    }

    @Test
<A NAME="4"></A>    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerAddedAndRemovedCalledInCorrectOrder() throws Throwable {
        final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
        final EventExecutorGroup group2 = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#4',2,'match146619-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new DefaultEventExecutorGroup(1);

        try {
            BlockingQueue&lt;CheckOrderHandler&gt; addedQueue = new LinkedBlockingQueue&lt;CheckOrderHandler&gt;();
            BlockingQueue&lt;CheckOrderHandler&gt; removedQueue = new LinkedBlockingQueue&lt;CheckOrderHandler&gt;();

            CheckOrderHandler handler1 = new CheckOrderHandler(addedQueue, removedQueue);
            CheckOrderHandler handler2 = new CheckOrderHandler(addedQueue, removedQueue);
<A NAME="0"></A>            CheckOrderHandler handler3 = new CheckOrderHandler(addedQueue, removedQueue);
            CheckOrderHandler handler4 = new CheckOrderHandler(addedQueue, removedQueue);

            ChannelPipeline pipeline = <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#0',2,'match146619-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new LocalChannel().pipeline()</B></FONT>;
            pipeline.addLast(handler1);
            group.register(pipeline.channel()).syncUninterruptibly();
            pipeline.addLast(group1, handler2);
            pipeline.addLast(group2, handler3);
            pipeline.addLast(handler4);

            assertTrue(removedQueue.isEmpty());
            pipeline.channel().close().syncUninterruptibly();
            assertHandler(addedQueue.take(), handler1);

            // Depending on timing this can be handler2 or handler3 as these use different EventExecutorGroups.
            assertHandler(addedQueue.take(), handler2, handler3, handler4);
            assertHandler(addedQueue.take(), handler2, handler3, handler4);
            assertHandler(addedQueue.take(), handler2, handler3, handler4);

            assertTrue(addedQueue.isEmpty());

            assertHandler(removedQueue.take(), handler4);
            assertHandler(removedQueue.take(), handler3);
            assertHandler(removedQueue.take(), handler2);
            assertHandler(removedQueue.take(), handler1);
            assertTrue(removedQueue.isEmpty</B></FONT>());
        } finally {
            group1.shutdownGracefully();
            group2.shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerAddedExceptionFromChildHandlerIsPropagated() {
        final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
        try {
            final Promise&lt;Void&gt; promise = group1.next().newPromise();
            final AtomicBoolean handlerAdded = new AtomicBoolean();
            final Exception exception = new RuntimeException();
            ChannelPipeline pipeline = new LocalChannel().pipeline();
            pipeline.addLast(group1, new CheckExceptionHandler(exception, promise));
            pipeline.addFirst(new ChannelHandlerAdapter() {
                @Override
                public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
                    handlerAdded.set(true);
                    throw exception;
                }
            });
            assertFalse(handlerAdded.get());
            group.register(pipeline.channel());
            promise.syncUninterruptibly();
        } finally {
            group1.shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerRemovedExceptionFromChildHandlerIsPropagated() {
        final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
        try {
            final Promise&lt;Void&gt; promise = group1.next().newPromise();
            String handlerName = &quot;foo&quot;;
            final Exception exception = new RuntimeException();
            ChannelPipeline pipeline = new LocalChannel().pipeline();
            pipeline.addLast(handlerName, new ChannelHandlerAdapter() {
                @Override
                public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
                    throw exception;
                }
            });
            pipeline.addLast(group1, new CheckExceptionHandler(exception, promise));
            group.register(pipeline.channel()).syncUninterruptibly();
            pipeline.remove(handlerName);
            promise.syncUninterruptibly();
        } finally {
            group1.shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerAddedThrowsAndRemovedThrowsException() throws InterruptedException {
        final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
        try {
            final CountDownLatch latch = new CountDownLatch(1);
            final Promise&lt;Void&gt; promise = group1.next().newPromise();
            final Exception exceptionAdded = new RuntimeException();
            final Exception exceptionRemoved = new RuntimeException();
            String handlerName = &quot;foo&quot;;
            ChannelPipeline pipeline = new LocalChannel().pipeline();
            pipeline.addLast(group1, new CheckExceptionHandler(exceptionAdded, promise));
            pipeline.addFirst(handlerName, new ChannelHandlerAdapter() {
                @Override
                public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
                    throw exceptionAdded;
                }

                @Override
                public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
                    // Execute this later so we are sure the exception is handled first.
                    ctx.executor().execute(new Runnable() {
                        @Override
                        public void run() {
                            latch.countDown();
                        }
                    });
                    throw exceptionRemoved;
                }
            });
            group.register(pipeline.channel()).syncUninterruptibly();
            latch.await();
            assertNull(pipeline.context(handlerName));
            promise.syncUninterruptibly();
        } finally {
            group1.shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)
    public void testAddRemoveHandlerCalledOnceRegistered() throws Throwable {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        CallbackCheckHandler handler = new CallbackCheckHandler();

        pipeline.addFirst(handler);
        pipeline.remove(handler);

        assertNull(handler.addedHandler.getNow());
        assertNull(handler.removedHandler.getNow());

        group.register(pipeline.channel()).syncUninterruptibly();
        Throwable cause = handler.error.get();
        if (cause != null) {
            throw cause;
        }

        assertTrue(handler.addedHandler.get());
        assertTrue(handler.removedHandler.get());
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
<A NAME="8"></A>    public void testAddReplaceHandlerCalledOnceRegistered() throws Throwable {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        CallbackCheckHandler handler = new CallbackCheckHandler();
        CallbackCheckHandler handler2 = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#8',2,'match146619-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new CallbackCheckHandler();

        pipeline.addFirst(handler);
        pipeline.replace(handler, null, handler2);

        assertNull(handler.addedHandler.getNow());
        assertNull(handler.removedHandler.getNow());
        assertNull(handler2.addedHandler.getNow());
        assertNull(handler2.removedHandler.getNow());

        group.register</B></FONT>(pipeline.channel()).syncUninterruptibly();
        Throwable cause = handler.error.get();
        if (cause != null) {
            throw cause;
        }

        assertTrue(handler.addedHandler.get());
        assertTrue(handler.removedHandler.get());

        Throwable cause2 = handler2.error.get();
        if (cause2 != null) {
            throw cause2;
        }

        assertTrue(handler2.addedHandler.get());
        assertNull(handler2.removedHandler.getNow());
        pipeline.remove(handler2);
        assertTrue(handler2.removedHandler.get());
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddBefore() throws Throwable {
        ChannelPipeline pipeline1 = new LocalChannel().pipeline();
        ChannelPipeline pipeline2 = new LocalChannel().pipeline();

        EventLoopGroup defaultGroup = new DefaultEventLoopGroup(2);
        try {
            EventLoop eventLoop1 = defaultGroup.next();
            EventLoop eventLoop2 = defaultGroup.next();

            eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
            eventLoop2.register(pipeline2.channel()).syncUninterruptibly();

            CountDownLatch latch = new CountDownLatch(2 * 10);
            for (int i = 0; i &lt; 10; i++) {
                eventLoop1.execute(new TestTask(pipeline2, latch));
                eventLoop2.execute(new TestTask(pipeline1, latch));
            }
            latch.await();
        } finally {
            defaultGroup.shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddInListenerNio() {
        testAddInListener(new NioSocketChannel(), new NioEventLoopGroup(1));
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddInListenerOio() {
        testAddInListener(new OioSocketChannel(), new OioEventLoopGroup(1));
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testAddInListenerLocal() {
        testAddInListener(new LocalChannel(), new DefaultEventLoopGroup(1));
    }

    private static void testAddInListener(Channel channel, EventLoopGroup group) {
        ChannelPipeline pipeline1 = channel.pipeline();
        try {
            final Object event = new Object();
            final Promise&lt;Object&gt; promise = ImmediateEventExecutor.INSTANCE.newPromise();
            group.register(pipeline1.channel()).addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) {
                    ChannelPipeline pipeline = future.channel().pipeline();
                    final AtomicBoolean handlerAddedCalled = new AtomicBoolean();
<A NAME="23"></A>                    pipeline.addLast(new ChannelInboundHandlerAdapter() {
                        @Override
                        public void handlerAdded(ChannelHandlerContext ctx) {
                            <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#23',2,'match146619-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>handlerAddedCalled.set(true);
                        }

                        @Override
                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                            promise.setSuccess</B></FONT>(event);
                        }

                        @Override
                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                            promise.setFailure(cause);
                        }
                    });
                    if (!handlerAddedCalled.get()) {
                        promise.setFailure(new AssertionError(&quot;handlerAdded(...) should have been called&quot;));
                        return;
                    }
                    // This event must be captured by the added handler.
                    pipeline.fireUserEventTriggered(event);
                }
            });
            assertSame(event, promise.syncUninterruptibly().getNow());
        } finally {
            pipeline1.channel().close().syncUninterruptibly();
            group.shutdownGracefully();
        }
    }

    @Test
    public void testNullName() {
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.addLast(newHandler());
        pipeline.addLast(null, newHandler());
        pipeline.addFirst(newHandler());
        pipeline.addFirst(null, newHandler());

        pipeline.addLast(&quot;test&quot;, newHandler());
        pipeline.addAfter(&quot;test&quot;, null, newHandler());

        pipeline.addBefore(&quot;test&quot;, null, newHandler());
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testUnorderedEventExecutor() throws Throwable {
        ChannelPipeline pipeline1 = new LocalChannel().pipeline();
        EventExecutorGroup eventExecutors = new UnorderedThreadPoolEventExecutor(2);
        EventLoopGroup defaultGroup = new DefaultEventLoopGroup(1);
        try {
            EventLoop eventLoop1 = defaultGroup.next();
            eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
            final CountDownLatch latch = new CountDownLatch(1);
            pipeline1.addLast(eventExecutors, new ChannelInboundHandlerAdapter() {
<A NAME="21"></A>                @Override
                public void handlerAdded(ChannelHandlerContext ctx) {
                    // Just block one of the two threads.
                    <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#21',2,'match146619-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>LockSupport.park();
                }

                @Override
                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                    latch.countDown</B></FONT>();
                }
            });
            // Trigger an event, as we use UnorderedEventExecutor userEventTriggered should be called even when
            // handlerAdded(...) blocks.
            pipeline1.fireUserEventTriggered(&quot;&quot;);
            latch.await();
        } finally {
            defaultGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
            eventExecutors.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
        }
    }

    @Test
    public void testPinExecutor() {
        EventExecutorGroup group = new DefaultEventExecutorGroup(2);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        ChannelPipeline pipeline2 = new LocalChannel().pipeline();

        pipeline.addLast(group, &quot;h1&quot;, new ChannelInboundHandlerAdapter());
        pipeline.addLast(group, &quot;h2&quot;, new ChannelInboundHandlerAdapter());
        pipeline2.addLast(group, &quot;h3&quot;, new ChannelInboundHandlerAdapter());

        EventExecutor executor1 = pipeline.context(&quot;h1&quot;).executor();
        EventExecutor executor2 = pipeline.context(&quot;h2&quot;).executor();
        assertNotNull(executor1);
        assertNotNull(executor2);
        assertSame(executor1, executor2);
        EventExecutor executor3 = pipeline2.context(&quot;h3&quot;).executor();
        assertNotNull(executor3);
        assertNotSame(executor3, executor2);
        group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
    }

    @Test
    public void testNotPinExecutor() {
        EventExecutorGroup group = new DefaultEventExecutorGroup(2);
        ChannelPipeline pipeline = new LocalChannel().pipeline();
        pipeline.channel().config().setOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP, false);

        pipeline.addLast(group, &quot;h1&quot;, new ChannelInboundHandlerAdapter());
        pipeline.addLast(group, &quot;h2&quot;, new ChannelInboundHandlerAdapter());

        EventExecutor executor1 = pipeline.context(&quot;h1&quot;).executor();
        EventExecutor executor2 = pipeline.context(&quot;h2&quot;).executor();
        assertNotNull(executor1);
        assertNotNull(executor2);
        assertNotSame(executor1, executor2);
        group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testVoidPromiseNotify() {
        ChannelPipeline pipeline1 = new LocalChannel().pipeline();

        EventLoopGroup defaultGroup = new DefaultEventLoopGroup(1);
        EventLoop eventLoop1 = defaultGroup.next();
        final Promise&lt;Throwable&gt; promise = eventLoop1.newPromise();
        final Exception exception = new IllegalArgumentException();
        try {
            eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
            pipeline1.addLast(new ChannelDuplexHandler() {
                @Override
                public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                    throw exception;
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                    promise.setSuccess(cause);
                }
            });
            pipeline1.write(&quot;test&quot;, pipeline1.voidPromise());
            assertSame(exception, promise.syncUninterruptibly().getNow());
        } finally {
            pipeline1.channel().close().syncUninterruptibly();
            defaultGroup.shutdownGracefully();
        }
    }

    // Test for https://github.com/netty/netty/issues/8676.
    @Test
    public void testHandlerRemovedOnlyCalledWhenHandlerAddedCalled() throws Exception {
        EventLoopGroup group = new DefaultEventLoopGroup(1);
        try {
            final AtomicReference&lt;Error&gt; errorRef = new AtomicReference&lt;Error&gt;();

            // As this only happens via a race we will verify 500 times. This was good enough to have it failed most of
            // the time.
            for (int i = 0; i &lt; 500; i++) {

                ChannelPipeline pipeline = new LocalChannel().pipeline();
                group.register(pipeline.channel()).sync();

                final CountDownLatch latch = new CountDownLatch(1);

                pipeline.addLast(new ChannelInboundHandlerAdapter() {
                    @Override
                    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
                        // Block just for a bit so we have a chance to trigger the race mentioned in the issue.
                        latch.await(50, TimeUnit.MILLISECONDS);
                    }
                });

                // Close the pipeline which will call destroy0(). This will remove each handler in the pipeline and
                // should call handlerRemoved(...) if and only if handlerAdded(...) was called for the handler before.
                pipeline.close();

                pipeline.addLast(new ChannelInboundHandlerAdapter() {
                    private boolean handerAddedCalled;

                    @Override
                    public void handlerAdded(ChannelHandlerContext ctx) {
                        handerAddedCalled = true;
                    }

                    @Override
                    public void handlerRemoved(ChannelHandlerContext ctx) {
                        if (!handerAddedCalled) {
                            errorRef.set(new AssertionError(
                                    &quot;handlerRemoved(...) called without handlerAdded(...) before&quot;));
                        }
                    }
                });

                latch.countDown();

                pipeline.channel().closeFuture().syncUninterruptibly();

                // Schedule something on the EventLoop to ensure all other scheduled tasks had a chance to complete.
                pipeline.channel().eventLoop().submit(new Runnable() {
                    @Override
                    public void run() {
                        // NOOP
                    }
                }).syncUninterruptibly();
                Error error = errorRef.get();
                if (error != null) {
                    throw error;
                }
            }
        } finally {
            group.shutdownGracefully();
        }
    }

    @Test
    public void testSkipHandlerMethodsIfAnnotated() {
        EmbeddedChannel channel = new EmbeddedChannel(true);
        ChannelPipeline pipeline = channel.pipeline();

        final class SkipHandler implements ChannelInboundHandler, ChannelOutboundHandler {
            private int state = 2;
            private Error errorRef;

            private void fail() {
                errorRef = new AssertionError(&quot;Method should never been called&quot;);
            }

            @Skip
            @Override
            public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
                fail();
                ctx.bind(localAddress, promise);
            }

            @Skip
            @Override
            public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
                                SocketAddress localAddress, ChannelPromise promise) {
                fail();
                ctx.connect(remoteAddress, localAddress, promise);
            }

            @Skip
            @Override
            public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
                fail();
                ctx.disconnect(promise);
            }

            @Skip
            @Override
            public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
                fail();
                ctx.close(promise);
            }

            @Skip
            @Override
            public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {
                fail();
                ctx.deregister(promise);
            }

            @Skip
            @Override
            public void read(ChannelHandlerContext ctx) {
                fail();
                ctx.read();
            }

            @Skip
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                fail();
                ctx.write(msg, promise);
            }

            @Skip
            @Override
            public void flush(ChannelHandlerContext ctx) {
                fail();
                ctx.flush();
            }

            @Skip
            @Override
            public void channelRegistered(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelRegistered();
            }

            @Skip
            @Override
            public void channelUnregistered(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelUnregistered();
            }

            @Skip
            @Override
            public void channelActive(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelActive();
            }

            @Skip
            @Override
            public void channelInactive(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelInactive();
            }

            @Skip
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) {
                fail();
                ctx.fireChannelRead(msg);
            }

            @Skip
            @Override
            public void channelReadComplete(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelReadComplete();
            }

            @Skip
            @Override
            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                fail();
                ctx.fireUserEventTriggered(evt);
            }

            @Skip
            @Override
            public void channelWritabilityChanged(ChannelHandlerContext ctx) {
                fail();
                ctx.fireChannelWritabilityChanged();
            }

            @Skip
            @Override
            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                fail();
                ctx.fireExceptionCaught(cause);
            }

            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                state--;
            }

            @Override
            public void handlerRemoved(ChannelHandlerContext ctx) {
                state--;
            }

            void assertSkipped() {
                assertEquals(0, state);
                Error error = errorRef;
                if (error != null) {
                    throw error;
                }
            }
        }

        final class OutboundCalledHandler extends ChannelOutboundHandlerAdapter {
            private static final int MASK_BIND = 1;
            private static final int MASK_CONNECT = 1 &lt;&lt; 1;
            private static final int MASK_DISCONNECT = 1 &lt;&lt; 2;
            private static final int MASK_CLOSE = 1 &lt;&lt; 3;
            private static final int MASK_DEREGISTER = 1 &lt;&lt; 4;
            private static final int MASK_READ = 1 &lt;&lt; 5;
            private static final int MASK_WRITE = 1 &lt;&lt; 6;
            private static final int MASK_FLUSH = 1 &lt;&lt; 7;
            private static final int MASK_ADDED = 1 &lt;&lt; 8;
            private static final int MASK_REMOVED = 1 &lt;&lt; 9;

            private int executionMask;

            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                executionMask |= MASK_ADDED;
            }

<A NAME="25"></A>            @Override
            public void handlerRemoved(ChannelHandlerContext ctx) {
                executionMask |= MASK_REMOVED;
            <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#25',2,'match146619-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

            @Override
            public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
                executionMask |= MASK_BIND;
                promise.setSuccess</B></FONT>();
            }

            @Override
<A NAME="19"></A>            public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
                                SocketAddress localAddress, ChannelPromise promise) {
                executionMask |= MASK_CONNECT;
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#19',2,'match146619-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>promise.setSuccess();
            }

            @Override
            public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
                executionMask |= MASK_DISCONNECT;
                promise.setSuccess</B></FONT>();
            }

<A NAME="17"></A>            @Override
            public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
                executionMask |= MASK_CLOSE;
                <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#17',2,'match146619-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>promise.setSuccess();
            }

            @Override
            public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {
                executionMask |= MASK_DEREGISTER;
                promise.setSuccess</B></FONT>();
            }

<A NAME="18"></A>            @Override
            public void read(ChannelHandlerContext ctx) {
                executionMask |= MASK_READ;
            <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#18',2,'match146619-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                executionMask |= MASK_WRITE;
                promise.setSuccess</B></FONT>();
            }

            @Override
            public void flush(ChannelHandlerContext ctx) {
<A NAME="14"></A>                executionMask |= MASK_FLUSH;
            }

            void assertCalled() <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#14',2,'match146619-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                assertCalled(&quot;handlerAdded&quot;, MASK_ADDED);
                assertCalled(&quot;handlerRemoved&quot;, MASK_REMOVED);
                assertCalled(&quot;bind&quot;, MASK_BIND);
                assertCalled(&quot;connect&quot;, MASK_CONNECT);
                assertCalled(&quot;disconnect&quot;, MASK_DISCONNECT);
                assertCalled(&quot;close&quot;, MASK_CLOSE);
                assertCalled(&quot;deregister&quot;, MASK_DEREGISTER);
                assertCalled(&quot;read&quot;, MASK_READ);
                assertCalled</B></FONT>(&quot;write&quot;, MASK_WRITE);
                assertCalled(&quot;flush&quot;, MASK_FLUSH);
            }

            private void assertCalled(String methodName, int mask) {
                assertTrue((executionMask &amp; mask) != 0, methodName + &quot; was not called&quot;);
            }
        }

        final class InboundCalledHandler extends ChannelInboundHandlerAdapter {

            private static final int MASK_CHANNEL_REGISTER = 1;
            private static final int MASK_CHANNEL_UNREGISTER = 1 &lt;&lt; 1;
            private static final int MASK_CHANNEL_ACTIVE = 1 &lt;&lt; 2;
            private static final int MASK_CHANNEL_INACTIVE = 1 &lt;&lt; 3;
            private static final int MASK_CHANNEL_READ = 1 &lt;&lt; 4;
            private static final int MASK_CHANNEL_READ_COMPLETE = 1 &lt;&lt; 5;
            private static final int MASK_USER_EVENT_TRIGGERED = 1 &lt;&lt; 6;
            private static final int MASK_CHANNEL_WRITABILITY_CHANGED = 1 &lt;&lt; 7;
            private static final int MASK_EXCEPTION_CAUGHT = 1 &lt;&lt; 8;
            private static final int MASK_ADDED = 1 &lt;&lt; 9;
            private static final int MASK_REMOVED = 1 &lt;&lt; 10;

            private int executionMask;

            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                executionMask |= MASK_ADDED;
            }

            @Override
            public void handlerRemoved(ChannelHandlerContext ctx) {
                executionMask |= MASK_REMOVED;
            }

            @Override
            public void channelRegistered(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_REGISTER;
            }

            @Override
            public void channelUnregistered(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_UNREGISTER;
            }

            @Override
            public void channelActive(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_ACTIVE;
            }

            @Override
            public void channelInactive(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_INACTIVE;
            }

            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) {
                executionMask |= MASK_CHANNEL_READ;
            }

            @Override
            public void channelReadComplete(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_READ_COMPLETE;
            }

            @Override
            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                executionMask |= MASK_USER_EVENT_TRIGGERED;
            }

            @Override
            public void channelWritabilityChanged(ChannelHandlerContext ctx) {
                executionMask |= MASK_CHANNEL_WRITABILITY_CHANGED;
            }

            @Override
            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
<A NAME="13"></A>                executionMask |= MASK_EXCEPTION_CAUGHT;
            }

            void assertCalled() <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#13',2,'match146619-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                assertCalled(&quot;handlerAdded&quot;, MASK_ADDED);
                assertCalled(&quot;handlerRemoved&quot;, MASK_REMOVED);
                assertCalled(&quot;channelRegistered&quot;, MASK_CHANNEL_REGISTER);
                assertCalled(&quot;channelUnregistered&quot;, MASK_CHANNEL_UNREGISTER);
                assertCalled(&quot;channelActive&quot;, MASK_CHANNEL_ACTIVE);
                assertCalled(&quot;channelInactive&quot;, MASK_CHANNEL_INACTIVE);
                assertCalled(&quot;channelRead&quot;, MASK_CHANNEL_READ);
                assertCalled(&quot;channelReadComplete&quot;, MASK_CHANNEL_READ_COMPLETE);
                assertCalled</B></FONT>(&quot;userEventTriggered&quot;, MASK_USER_EVENT_TRIGGERED);
                assertCalled(&quot;channelWritabilityChanged&quot;, MASK_CHANNEL_WRITABILITY_CHANGED);
                assertCalled(&quot;exceptionCaught&quot;, MASK_EXCEPTION_CAUGHT);
            }

            private void assertCalled(String methodName, int mask) {
                assertTrue((executionMask &amp; mask) != 0, methodName + &quot; was not called&quot;);
            }
        }

        OutboundCalledHandler outboundCalledHandler = new OutboundCalledHandler();
        SkipHandler skipHandler = new SkipHandler();
        InboundCalledHandler inboundCalledHandler = new InboundCalledHandler();
        pipeline.addLast(outboundCalledHandler, skipHandler, inboundCalledHandler);

        pipeline.fireChannelRegistered();
        pipeline.fireChannelUnregistered();
        pipeline.fireChannelActive();
        pipeline.fireChannelInactive();
        pipeline.fireChannelRead(&quot;&quot;);
        pipeline.fireChannelReadComplete();
        pipeline.fireChannelWritabilityChanged();
        pipeline.fireUserEventTriggered(&quot;&quot;);
        pipeline.fireExceptionCaught(new Exception());

        pipeline.deregister().syncUninterruptibly();
        pipeline.bind(new SocketAddress() {
        }).syncUninterruptibly();
        pipeline.connect(new SocketAddress() {
        }).syncUninterruptibly();
        pipeline.disconnect().syncUninterruptibly();
        pipeline.close().syncUninterruptibly();
        pipeline.write(&quot;&quot;);
        pipeline.flush();
        pipeline.read();

        pipeline.remove(outboundCalledHandler);
        pipeline.remove(inboundCalledHandler);
        pipeline.remove(skipHandler);

        assertFalse(channel.finish());

        outboundCalledHandler.assertCalled();
        inboundCalledHandler.assertCalled();
        skipHandler.assertSkipped();
    }

    @Test
    public void testWriteThrowsReleaseMessage() {
        testWriteThrowsReleaseMessage0(false);
    }

    @Test
    public void testWriteAndFlushThrowsReleaseMessage() {
        testWriteThrowsReleaseMessage0(true);
    }

    private void testWriteThrowsReleaseMessage0(boolean flush) {
        ReferenceCounted referenceCounted = new AbstractReferenceCounted() {
            @Override
            protected void deallocate() {
                // NOOP
            }

            @Override
            public ReferenceCounted touch(Object hint) {
                return this;
            }
        };
        assertEquals(1, referenceCounted.refCnt());

        Channel channel = new LocalChannel();
        Channel channel2 = new LocalChannel();
        group.register(channel).syncUninterruptibly();
        group.register(channel2).syncUninterruptibly();

        try {
            if (flush) {
                channel.writeAndFlush(referenceCounted, channel2.newPromise());
            } else {
                channel.write(referenceCounted, channel2.newPromise());
            }
            fail();
        } catch (IllegalArgumentException expected) {
            // expected
        }
        assertEquals(0, referenceCounted.refCnt());

        channel.close().syncUninterruptibly();
        channel2.close().syncUninterruptibly();
    }

    @Test
    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerAddedFailedButHandlerStillRemoved() throws InterruptedException {
        testHandlerAddedFailedButHandlerStillRemoved0(false);
    }

    @Test
    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void testHandlerAddedFailedButHandlerStillRemovedWithLaterRegister() throws InterruptedException {
        testHandlerAddedFailedButHandlerStillRemoved0(true);
    }

    private static void testHandlerAddedFailedButHandlerStillRemoved0(boolean lateRegister)
            throws InterruptedException {
        EventExecutorGroup executorGroup = new DefaultEventExecutorGroup(16);
        final int numHandlers = 32;
        try {
            Channel channel = new LocalChannel();
            channel.config().setOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP, false);
            if (!lateRegister) {
                group.register(channel).sync();
            }
            channel.pipeline().addFirst(newHandler());

            List&lt;CountDownLatch&gt; latchList = new ArrayList&lt;CountDownLatch&gt;(numHandlers);
            for (int i = 0; i &lt; numHandlers; i++) {
                CountDownLatch latch = new CountDownLatch(1);
                channel.pipeline().addFirst(executorGroup, &quot;h&quot; + i, new BadChannelHandler(latch));
                latchList.add(latch);
            }
            if (lateRegister) {
                group.register(channel).sync();
            }

            for (int i = 0; i &lt; numHandlers; i++) {
                // Wait until the latch was countDown which means handlerRemoved(...) was called.
                latchList.get(i).await();
                assertNull(channel.pipeline().get(&quot;h&quot; + i));
            }
        } finally {
            executorGroup.shutdownGracefully();
        }
    }

<A NAME="9"></A>    private static final class BadChannelHandler extends ChannelHandlerAdapter {
        private final CountDownLatch latch;

        <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#9',2,'match146619-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BadChannelHandler(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            TimeUnit.MILLISECONDS.sleep</B></FONT>(10);
            throw new RuntimeException();
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            latch.countDown();
        }
    }

    @Test
    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void handlerAddedStateUpdatedBeforeHandlerAddedDoneForceEventLoop() throws InterruptedException {
        handlerAddedStateUpdatedBeforeHandlerAddedDone(true);
    }

    @Test
    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void handlerAddedStateUpdatedBeforeHandlerAddedDoneOnCallingThread() throws InterruptedException {
        handlerAddedStateUpdatedBeforeHandlerAddedDone(false);
    }

    private static void handlerAddedStateUpdatedBeforeHandlerAddedDone(boolean executeInEventLoop)
            throws InterruptedException {
        final ChannelPipeline pipeline = new LocalChannel().pipeline();
        final Object userEvent = new Object();
        final Object writeObject = new Object();
        final CountDownLatch doneLatch = new CountDownLatch(1);

        group.register(pipeline.channel());

        Runnable r = new Runnable() {
            @Override
            public void run() {
                pipeline.addLast(new ChannelInboundHandlerAdapter() {
                    @Override
                    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                        if (evt == userEvent) {
                            ctx.write(writeObject);
                        }
                        ctx.fireUserEventTriggered(evt);
                    }
                });
<A NAME="22"></A>                pipeline.addFirst(new ChannelDuplexHandler() {
                    @Override
                    public void handlerAdded(ChannelHandlerContext ctx) {
                        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#22',2,'match146619-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ctx.fireUserEventTriggered(userEvent);
                    }

                    @Override
                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {</B></FONT>
                        if (msg == writeObject) {
                            doneLatch.countDown();
                        }
                        ctx.write(msg, promise);
                    }
                });
            }
        };

        if (executeInEventLoop) {
            pipeline.channel().eventLoop().execute(r);
        } else {
            r.run();
        }

        doneLatch.await();
    }

    private static final class TestTask implements Runnable {

        private final ChannelPipeline pipeline;
        private final CountDownLatch latch;

        TestTask(ChannelPipeline pipeline, CountDownLatch latch) {
            this.pipeline = pipeline;
            this.latch = latch;
        }

        @Override
        public void run() {
            pipeline.addLast(new ChannelInboundHandlerAdapter());
            latch.countDown();
        }
    }

    private static final class CallbackCheckHandler extends ChannelHandlerAdapter {
        final Promise&lt;Boolean&gt; addedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
        final Promise&lt;Boolean&gt; removedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            if (!addedHandler.trySuccess(true)) {
                error.set(new AssertionError(&quot;handlerAdded(...) called multiple times: &quot; + ctx.name()));
            } else if (removedHandler.getNow() == Boolean.TRUE) {
                error.set(new AssertionError(&quot;handlerRemoved(...) called before handlerAdded(...): &quot; + ctx.name()));
            }
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            if (!removedHandler.trySuccess(true)) {
                error.set(new AssertionError(&quot;handlerRemoved(...) called multiple times: &quot; + ctx.name()));
            } else if (addedHandler.getNow() == Boolean.FALSE) {
                error.set(new AssertionError(&quot;handlerRemoved(...) called before handlerAdded(...): &quot; + ctx.name()));
            }
        }
    }

    private static final class CheckExceptionHandler extends ChannelInboundHandlerAdapter {
        private final Throwable expected;
        private final Promise&lt;Void&gt; promise;

        CheckExceptionHandler(Throwable expected, Promise&lt;Void&gt; promise) {
            this.expected = expected;
            this.promise = promise;
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            if (cause instanceof ChannelPipelineException &amp;&amp; cause.getCause() == expected) {
                promise.setSuccess(null);
            } else {
                promise.setFailure(new AssertionError(&quot;cause not the expected instance&quot;));
            }
        }
    }

    private static void assertHandler(CheckOrderHandler actual, CheckOrderHandler... handlers) throws Throwable {
        for (CheckOrderHandler h : handlers) {
            if (h == actual) {
                actual.checkError();
                return;
            }
        }
        fail(&quot;handler was not one of the expected handlers&quot;);
    }

    private static final class CheckOrderHandler extends ChannelHandlerAdapter {
        private final Queue&lt;CheckOrderHandler&gt; addedQueue;
        private final Queue&lt;CheckOrderHandler&gt; removedQueue;
        private final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();

        CheckOrderHandler(Queue&lt;CheckOrderHandler&gt; addedQueue, Queue&lt;CheckOrderHandler&gt; removedQueue) {
            this.addedQueue = addedQueue;
            this.removedQueue = removedQueue;
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            addedQueue.add(this);
            checkExecutor(ctx);
        }
<A NAME="12"></A>
        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#12',2,'match146619-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>removedQueue.add(this);
            checkExecutor(ctx);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            error.set</B></FONT>(cause);
        }

        void checkError() throws Throwable {
            Throwable cause = error.get();
            if (cause != null) {
                throw cause;
            }
        }

        private void checkExecutor(ChannelHandlerContext ctx) {
            if (!ctx.executor().inEventLoop()) {
                error.set(new AssertionError());
            }
        }
    }

    private static final class CheckEventExecutorHandler extends ChannelHandlerAdapter {
        final EventExecutor executor;
        final Promise&lt;Void&gt; addedPromise;
        final Promise&lt;Void&gt; removedPromise;

        CheckEventExecutorHandler(EventExecutor executor) {
            this.executor = executor;
            addedPromise = executor.newPromise();
            removedPromise = executor.newPromise();
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            assertExecutor(ctx, addedPromise);
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            assertExecutor(ctx, removedPromise);
        }

        private void assertExecutor(ChannelHandlerContext ctx, Promise&lt;Void&gt; promise) {
            final boolean same;
            try {
                same = executor == ctx.executor();
            } catch (Throwable cause) {
                promise.setFailure(cause);
                return;
            }
            if (same) {
                promise.setSuccess(null);
            } else {
                promise.setFailure(new AssertionError(&quot;EventExecutor not the same&quot;));
            }
        }
    }
    private static final class ErrorChannelHandler extends ChannelHandlerAdapter {
        private final AtomicReference&lt;Throwable&gt; error;

        ErrorChannelHandler(AtomicReference&lt;Throwable&gt; error) {
            this.error = error;
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            error.set(new AssertionError());
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            error.set(new AssertionError());
        }
    }

    private static int next(AbstractChannelHandlerContext ctx) {
        AbstractChannelHandlerContext next = ctx.next;
        if (next == null) {
            return Integer.MAX_VALUE;
        }

        return toInt(next.name());
    }

    private static int toInt(String name) {
        try {
            return Integer.parseInt(name);
        } catch (NumberFormatException e) {
            return -1;
        }
    }

    private static void verifyContextNumber(ChannelPipeline pipeline, int expectedNumber) {
        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
        int handlerNumber = 0;
        while (ctx != ((DefaultChannelPipeline) pipeline).tail) {
            handlerNumber++;
            ctx = ctx.next;
        }
        assertEquals(expectedNumber, handlerNumber);
    }

    private static ChannelHandler[] newHandlers(int num) {
        assert num &gt; 0;

        ChannelHandler[] handlers = new ChannelHandler[num];
        for (int i = 0; i &lt; num; i++) {
            handlers[i] = newHandler();
        }

        return handlers;
    }

    private static ChannelHandler newHandler() {
        return new TestHandler();
    }

    @Sharable
    private static class TestHandler extends ChannelDuplexHandler { }

    private static class BufferedTestHandler extends ChannelDuplexHandler {
        final Queue&lt;Object&gt; inboundBuffer = new ArrayDeque&lt;Object&gt;();
        final Queue&lt;Object&gt; outboundBuffer = new ArrayDeque&lt;Object&gt;();

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            outboundBuffer.add(msg);
        }

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            inboundBuffer.add(msg);
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
            if (!inboundBuffer.isEmpty()) {
                for (Object o: inboundBuffer) {
                    ctx.fireChannelRead(o);
                }
                ctx.fireChannelReadComplete();
            }
            if (!outboundBuffer.isEmpty()) {
                for (Object o: outboundBuffer) {
                    ctx.write(o);
                }
                ctx.flush();
            }
        }
    }

    /** Test handler to validate life-cycle aware behavior. */
    private static final class LifeCycleAwareTestHandler extends ChannelHandlerAdapter {
        private final String name;

        private boolean afterAdd;
        private boolean afterRemove;

        /**
         * Constructs life-cycle aware test handler.
         *
         * @param name Handler name to display in assertion messages.
         */
        private LifeCycleAwareTestHandler(String name) {
            this.name = name;
        }

        public void validate(boolean afterAdd, boolean afterRemove) {
            assertEquals(afterAdd, this.afterAdd, name);
            assertEquals(afterRemove, this.afterRemove, name);
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) {
            validate(false, false);

            afterAdd = true;
        }

        @Override
        public void handlerRemoved(ChannelHandlerContext ctx) {
            validate(true, false);

            afterRemove = true;
        }
    }

    private static final class WrapperExecutor extends AbstractEventExecutor {

        private final ExecutorService wrapped = Executors.newSingleThreadExecutor();
<A NAME="20"></A>
        @Override
        public boolean isShuttingDown() {
            return <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match146619-0.html#20',2,'match146619-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapped.isShutdown();
        }

        @Override
        public Future&lt;?&gt; shutdownGracefully(long l, long l2, TimeUnit timeUnit) {</B></FONT>
            throw new IllegalStateException();
        }

        @Override
        public Future&lt;?&gt; terminationFuture() {
            throw new IllegalStateException();
        }

        @Override
        public void shutdown() {
            wrapped.shutdown();
        }

        @Override
        public List&lt;Runnable&gt; shutdownNow() {
            return wrapped.shutdownNow();
        }

        @Override
        public boolean isShutdown() {
            return wrapped.isShutdown();
        }

        @Override
        public boolean isTerminated() {
            return wrapped.isTerminated();
        }

        @Override
        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
            return wrapped.awaitTermination(timeout, unit);
        }

        @Override
        public EventExecutorGroup parent() {
            return null;
        }

        @Override
        public boolean inEventLoop(Thread thread) {
            return false;
        }

        @Override
        public void execute(Runnable command) {
            wrapped.execute(command);
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
