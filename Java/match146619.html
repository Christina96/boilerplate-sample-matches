<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LocalTransportThreadModelTest.java &amp; DefaultChannelPipelineTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LocalTransportThreadModelTest.java &amp; DefaultChannelPipelineTest.java
      </h3>
<h1 align="center">
        16.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LocalTransportThreadModelTest.java (40.5618%)<th>DefaultChannelPipelineTest.java (10.485043%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(103-122)<td><a href="#" name="0">(983-1005)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(18-54)<td><a href="#" name="1">(46-83)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(202-214)<td><a href="#" name="2">(183-198)</a><td align="center"><font color="#9a0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(352-363)<td><a href="#" name="3">(206-220)</a><td align="center"><font color="#830000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(245-255)<td><a href="#" name="4">(972-983)</a><td align="center"><font color="#830000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(186-202)<td><a href="#" name="5">(482-493)</a><td align="center"><font color="#830000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(146-153)<td><a href="#" name="6">(637-648)</a><td align="center"><font color="#7b0000">16</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(59-66)<td><a href="#" name="7">(97-103)</a><td align="center"><font color="#6c0000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(255-266)<td><a href="#" name="8">(1127-1137)</a><td align="center"><font color="#640000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(379-385)<td><a href="#" name="9">(1882-1888)</a><td align="center"><font color="#550000">11</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(66-72)<td><a href="#" name="10">(397-402)</a><td align="center"><font color="#550000">11</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(400-405)<td><a href="#" name="11">(858-864)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(385-390)<td><a href="#" name="12">(2045-2051)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(225-232)<td><a href="#" name="13">(1734-1743)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(214-223)<td><a href="#" name="14">(1645-1654)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(91-96)<td><a href="#" name="15">(348-353)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(76-80)<td><a href="#" name="16">(124-130)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(599-604)<td><a href="#" name="17">(1620-1626)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(589-594)<td><a href="#" name="18">(1632-1637)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(555-560)<td><a href="#" name="19">(1608-1614)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(544-548)<td><a href="#" name="20">(2240-2244)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(509-514)<td><a href="#" name="21">(1270-1275)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(496-500)<td><a href="#" name="22">(1934-1938)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(457-462)<td><a href="#" name="23">(1214-1219)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(431-439)<td><a href="#" name="24">(711-716)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(394-398)<td><a href="#" name="25">(1596-1601)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(314-316)<td><a href="#" name="26">(547-551)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(81-85)<td><a href="#" name="27">(845-849)</a><td align="center"><font color="#450000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LocalTransportThreadModelTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.channel.local;
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.bootstrap.ServerBootstrap;
3 import io.netty.buffer.ByteBuf;
4 import io.netty.buffer.Unpooled;
5 import io.netty.channel.Channel;
6 import io.netty.channel.ChannelDuplexHandler;
7 import io.netty.channel.ChannelHandlerContext;
8 import io.netty.channel.ChannelInboundHandlerAdapter;
9 import io.netty.channel.ChannelInitializer;
10 import io.netty.channel.ChannelPromise;
11 import io.netty.channel.DefaultEventLoopGroup;
12 import io.netty.channel.EventLoopGroup;
13 import io.netty.util.ReferenceCountUtil;
14 import io.netty.util.concurrent.DefaultEventExecutorGroup;
15 import io.netty.util.concurrent.DefaultThreadFactory;
16 import io.netty.util.concurrent.EventExecutorGroup;
17 import org.junit.jupiter.api.AfterAll;
18 import org.junit.jupiter.api.BeforeAll;
19 import org.junit.jupiter.api.Disabled;
20 import org.junit.jupiter.api.Test;
21 import org.junit.jupiter.api.Timeout;
22 import java.util.HashSet;
23 import java.util.Queue;
24 import java.util.Set;
25 import java.util.concurrent.ConcurrentLinkedQueue;
26 import java.util.concurrent.TimeUnit;
27 import java.util.concurrent.atomic.AtomicReference;
28 import static org.junit.jupiter.api.Assertions.assertEquals;
29 import static org.junit.jupiter.api.Assertions.assertFalse;
30 import static org.junit.jupiter.api.Assertions.assertSame;
31 import static org.junit.jupiter.api.Assertions.assertTrue;
32 public class LocalTransportThreadModelTest {
33     private static EventLoopGroup group;
34     private static LocalAddress localAddr</b></font>;
35 <a name="7"></a>    @BeforeAll
36     public static void init() {
37         group = <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new DefaultEventLoopGroup();
38         ServerBootstrap sb = new ServerBootstrap();
39         sb.group(group)
40           .channel(LocalServerChannel.class)
41 <a name="10"></a>          .childHandler(new ChannelInitializer&lt;LocalChannel&gt;() {
42               @Override
43               public void initChannel(LocalChannel ch) throws Exception {
44                   ch.pipeline</b></font>().addLast(<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ChannelInboundHandlerAdapter() {
45                       @Override
46                       public void channelRead(ChannelHandlerContext ctx, Object msg) {
47                           ReferenceCountUtil.release(msg);
48                       }
49                   }</b></font>);
50 <a name="16"></a>              }
51           });
52         <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>localAddr = (LocalAddress) sb.bind(LocalAddress.ANY).syncUninterruptibly().channel().localAddress();
53     }
54 <a name="27"></a>
55     @AfterAll
56     public static void destroy() throws Exception {</b></font>
57         <font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>group.shutdownGracefully().sync();
58     }
59     @Test
60     @Timeout(value = 30000, u</b></font>nit = TimeUnit.MILLISECONDS)
61     @Disabled("regression test")
62     public void testStagedExecutionMultiple() throws Throwable {
63 <a name="15"></a>        for (int i = 0; i &lt; 10; i ++) {
64             testStagedExecution();
65         }
66     <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
67     @Test
68     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
69     public void testStagedExecution() throws Throwable {
70         EventLoopGroup l = new</b></font> DefaultEventLoopGroup(4, new DefaultThreadFactory("l"));
71         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
72         EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e2"));
73         ThreadNameAuditor h1 = new ThreadNameAuditor();
74 <a name="0"></a>        ThreadNameAuditor h2 = new ThreadNameAuditor();
75         ThreadNameAuditor h3 = new ThreadNameAuditor(true);
76         Channel ch = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new LocalChannel();
77         ch.pipeline().addLast(h1);
78         ch.pipeline().addLast(e1, h2);
79         ch.pipeline().addLast(e2, h3);
80         l.register(ch).sync().channel().connect(localAddr).sync();
81         ch.pipeline().fireChannelRead("1");
82         ch.pipeline().context(h1).fireChannelRead("2");
83         ch.pipeline().context(h2).fireChannelRead("3");
84         ch.pipeline().context(h3).fireChannelRead("4");
85         ch.pipeline().write("5");
86         ch.pipeline().context(h3).write("6");
87         ch.pipeline().context(h2).write("7");
88         ch.pipeline().context(h1).writeAndFlush</b></font>("8").sync();
89         ch.close().sync();
90         while (h1.outboundThreadNames.size() &lt; 3 || h3.inboundThreadNames.size() &lt; 3 ||
91                h1.removalThreadNames.size() &lt; 1) {
92             if (h1.exception.get() != null) {
93                 throw h1.exception.get();
94             }
95             if (h2.exception.get() != null) {
96                 throw h2.exception.get();
97             }
98             if (h3.exception.get() != null) {
99                 throw h3.exception.get();
100             }
101             Thread.sleep(10);
102         }
103         String currentName = Thread.currentThread().getName();
104 <a name="6"></a>
105         try {
106             <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertFalse(h1.inboundThreadNames.contains(currentName));
107             assertFalse(h2.inboundThreadNames.contains(currentName));
108             assertFalse(h3.inboundThreadNames.contains(currentName));
109             assertFalse(h1.outboundThreadNames.contains(currentName));
110             assertFalse(h2.outboundThreadNames.contains(currentName));
111             assertFalse(h3.outboundThreadNames.contains(currentName));
112             assertFalse(h1.removalThreadNames.contains(currentName));
113             assertFalse(h2.removalThreadNames.contains</b></font>(currentName));
114             assertFalse(h3.removalThreadNames.contains(currentName));
115             for (String name: h1.inboundThreadNames) {
116                 assertTrue(name.startsWith("l-"));
117             }
118             for (String name: h2.inboundThreadNames) {
119                 assertTrue(name.startsWith("e1-"));
120             }
121             for (String name: h3.inboundThreadNames) {
122                 assertTrue(name.startsWith("e2-"));
123             }
124             for (String name: h1.outboundThreadNames) {
125                 assertTrue(name.startsWith("l-"));
126             }
127             for (String name: h2.outboundThreadNames) {
128                 assertTrue(name.startsWith("e1-"));
129             }
130             for (String name: h3.outboundThreadNames) {
131                 assertTrue(name.startsWith("e2-"));
132             }
133             for (String name: h1.removalThreadNames) {
134                 assertTrue(name.startsWith("l-"));
135             }
136             for (String name: h2.removalThreadNames) {
137                 assertTrue(name.startsWith("e1-"));
138             }
139             for (String name: h3.removalThreadNames) {
140                 assertTrue(name.startsWith("e2-"));
141 <a name="5"></a>            }
142             Set&lt;String&gt; names = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new HashSet&lt;String&gt;();
143             names.addAll(h1.inboundThreadNames);
144             names.addAll(h1.outboundThreadNames);
145             names.addAll(h1.removalThreadNames);
146             assertEquals(1, names.size());
147             names.clear();
148             names.addAll(h2.inboundThreadNames);
149             names.addAll(h2.outboundThreadNames);
150             names.addAll(h2.removalThreadNames);
151             assertEquals(1, names.size());
152             names.clear();
153 <a name="2"></a>            names.addAll(h3.inboundThreadNames);
154             names.addAll(h3.outboundThreadNames);
155             names.addAll(h3.removalThreadNames);
156             assertEquals</b></font>(1, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>names.size());
157             assertEquals(1, h1.inboundThreadNames.size());
158             assertEquals(2, h2.inboundThreadNames.size());
159             assertEquals(3, h3.inboundThreadNames.size());
160             assertEquals(3, h1.outboundThreadNames.size());
161             assertEquals(2, h2.outboundThreadNames.size());
162             assertEquals(1, h3.outboundThreadNames.size());
163 <a name="14"></a>            assertEquals(1, h1.removalThreadNames.size());
164             assertEquals(1, h2.removalThreadNames.size());
165             assertEquals(1, h3.removalThreadNames.size());
166         }</b></font> catch (AssertionError e) <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
167             System.out.println("H1I: " + h1.inboundThreadNames);
168             System.out.println("H2I: " + h2.inboundThreadNames);
169             System.out.println("H3I: " + h3.inboundThreadNames);
170             System.out.println("H1O: " + h1.outboundThreadNames);
171             System.out.println("H2O: " + h2.outboundThreadNames);
172             System.out.println("H3O: " + h3.outboundThreadNames);
173             System.out.println("H1R: " + h1.removalThreadNames);
174 <a name="13"></a>            System.out.println("H2R: " + h2.removalThreadNames);
175             System.out.println</b></font>("H3R: " + h3.removalThreadNames);
176             throw e;
177         } finally <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
178             l.shutdownGracefully();
179             e1.shutdownGracefully();
180             e2.shutdownGracefully();
181             l.terminationFuture().sync();
182             e1.terminationFuture().sync();
183             e2.terminationFuture</b></font>().sync();
184         }
185     }
186     @Test
187     @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)
188     @Disabled
189     public void testConcurrentMessageBufferAccess() throws Throwable {
190         EventLoopGroup l = new DefaultEventLoopGroup(4, new DefaultThreadFactory("l"));
191         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
192 <a name="4"></a>        EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e2"));
193         EventExecutorGroup e3 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e3"));
194         EventExecutorGroup e4 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e4"));
195         EventExecutorGroup e5 = new DefaultEventExecutorGroup(4, <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new DefaultThreadFactory("e5"));
196         try {
197             final MessageForwarder1 h1 = new MessageForwarder1();
198             final MessageForwarder2 h2 = new MessageForwarder2();
199             final MessageForwarder3 h3 = new MessageForwarder3();
200             final MessageForwarder1 h4 = new MessageForwarder1();
201 <a name="8"></a>            final MessageForwarder2 h5 = new MessageForwarder2();
202             final MessageDiscarder  h6 = new MessageDiscarder();
203             final Channel ch = <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new LocalChannel()</b></font>;
204             ch.pipeline().addLast(h1)
205                          .addLast(e1, h2)
206                          .addLast(e2, h3)
207                          .addLast(e3, h4)
208                          .addLast(e4, h5)
209                          .addLast(e5, h6);
210             l.register</b></font>(ch).sync().channel().connect(localAddr).sync();
211             final int ROUNDS = 1024;
212             final int ELEMS_PER_ROUNDS = 8192;
213             final int TOTAL_CNT = ROUNDS * ELEMS_PER_ROUNDS;
214             for (int i = 0; i &lt; TOTAL_CNT;) {
215                 final int start = i;
216                 final int end = i + ELEMS_PER_ROUNDS;
217                 i = end;
218                 ch.eventLoop().execute(new Runnable() {
219                     @Override
220                     public void run() {
221                         for (int j = start; j &lt; end; j ++) {
222                             ch.pipeline().fireChannelRead(Integer.valueOf(j));
223                         }
224                     }
225                 });
226             }
227             while (h1.inCnt &lt; TOTAL_CNT || h2.inCnt &lt; TOTAL_CNT || h3.inCnt &lt; TOTAL_CNT ||
228                     h4.inCnt &lt; TOTAL_CNT || h5.inCnt &lt; TOTAL_CNT || h6.inCnt &lt; TOTAL_CNT) {
229                 if (h1.exception.get() != null) {
230                     throw h1.exception.get();
231                 }
232                 if (h2.exception.get() != null) {
233                     throw h2.exception.get();
234                 }
235                 if (h3.exception.get() != null) {
236                     throw h3.exception.get();
237                 }
238                 if (h4.exception.get() != null) {
239                     throw h4.exception.get();
240                 }
241                 if (h5.exception.get() != null) {
242                     throw h5.exception.get();
243                 }
244                 if (h6.exception.get() != null) {
245                     throw h6.exception.get();
246                 }
247                 Thread.sleep(10);
248             }
249             for (int i = 0; i &lt; TOTAL_CNT;) {
250                 final int start = i;
251 <a name="26"></a>                final int end = i + ELEMS_PER_ROUNDS;
252                 i = end;
253                 <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ch.pipeline().context(h6).executor().execute(new Runnable() {
254                     @Override
255                     public void run() {</b></font>
256                         for (int j = start; j &lt; end; j ++) {
257                             ch.write(Integer.valueOf(j));
258                         }
259                         ch.flush();
260                     }
261                 });
262             }
263             while (h1.outCnt &lt; TOTAL_CNT || h2.outCnt &lt; TOTAL_CNT || h3.outCnt &lt; TOTAL_CNT ||
264                     h4.outCnt &lt; TOTAL_CNT || h5.outCnt &lt; TOTAL_CNT || h6.outCnt &lt; TOTAL_CNT) {
265                 if (h1.exception.get() != null) {
266                     throw h1.exception.get();
267                 }
268                 if (h2.exception.get() != null) {
269                     throw h2.exception.get();
270                 }
271                 if (h3.exception.get() != null) {
272                     throw h3.exception.get();
273                 }
274                 if (h4.exception.get() != null) {
275                     throw h4.exception.get();
276                 }
277                 if (h5.exception.get() != null) {
278                     throw h5.exception.get();
279                 }
280                 if (h6.exception.get() != null) {
281                     throw h6.exception.get();
282                 }
283                 Thread.sleep(10);
284             }
285             ch.close().sync();
286 <a name="3"></a>        } finally {
287             l.shutdownGracefully();
288             e1.shutdownGracefully();
289             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e2.shutdownGracefully();
290             e3.shutdownGracefully();
291             e4.shutdownGracefully();
292             e5.shutdownGracefully();
293             l.terminationFuture().sync();
294             e1.terminationFuture().sync();
295             e2.terminationFuture().sync();
296             e3.terminationFuture().sync();
297             e4.terminationFuture().sync();
298             e5.terminationFuture().sync();
299         }</b></font>
300     }
301     private static class ThreadNameAuditor extends ChannelDuplexHandler {
302         private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
303         private final Queue&lt;String&gt; inboundThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
304         private final Queue&lt;String&gt; outboundThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
305         private final Queue&lt;String&gt; removalThreadNames = new ConcurrentLinkedQueue&lt;String&gt;();
306         private final boolean discard;
307         ThreadNameAuditor() {
308 <a name="9"></a>            this(false);
309         }
310         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ThreadNameAuditor(boolean discard) {
311             this.discard = discard;
312         }
313 <a name="12"></a>
314         @Override
315         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
316             removalThreadNames.add</b></font>(<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Thread.currentThread().getName());
317         }
318         @Override
319         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
320             inboundThreadNames.add</b></font>(Thread.currentThread().getName());
321 <a name="25"></a>            if (!discard) {
322                 ctx.fireChannelRead(msg);
323             }
324         <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
325         @Override
326 <a name="11"></a>        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
327             outboundThreadNames.add</b></font>(Thread.currentThread().getName());
328             ctx.write(msg, promise);
329         <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
330         @Override
331         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
332             exception.compareAndSet(null, cause);
333             System.err.print('[' + Thread.currentThread().getName</b></font>() + "] ");
334             cause.printStackTrace();
335             super.exceptionCaught(ctx, cause);
336         }
337     }
338     private static class MessageForwarder1 extends ChannelDuplexHandler {
339         private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
340         private volatile int inCnt;
341         private volatile int outCnt;
342         private volatile Thread t;
343         @Override
344         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
345             Thread t = this.t;
346             if (t == null) {
347                 this.t = Thread.currentThread();
348             } else {
349                 assertSame(t, Thread.currentThread());
350 <a name="24"></a>            }
351             ByteBuf out = ctx.alloc().buffer(4);
352             int m = <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>((Integer) msg).intValue();
353             int expected = inCnt ++;
354             assertEquals(expected, m);
355             out.writeInt(m);
356             ctx.fireChannelRead(out);
357         }
358         @</b></font>Override
359         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
360             assertSame(t, Thread.currentThread());
361             boolean swallow = this == ctx.pipeline().first();
362             ByteBuf m = (ByteBuf) msg;
363             int count = m.readableBytes() / 4;
364             for (int j = 0; j &lt; count; j ++) {
365                 int actual = m.readInt();
366                 int expected = outCnt ++;
367                 assertEquals(expected, actual);
368                 if (!swallow) {
369                     ctx.write(actual);
370 <a name="23"></a>                }
371             }
372             ctx.writeAndFlush(Unpooled.EMPTY_BUFFER, promise);
373             <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>m.release();
374         }
375         @Override
376         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
377             exception.compareAndSet</b></font>(null, cause);
378             //System.err.print("[" + Thread.currentThread().getName() + "] ");
379             //cause.printStackTrace();
380             super.exceptionCaught(ctx, cause);
381         }
382     }
383     private static class MessageForwarder2 extends ChannelDuplexHandler {
384         private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
385         private volatile int inCnt;
386         private volatile int outCnt;
387         private volatile Thread t;
388         @Override
389         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
390             Thread t = this.t;
391             if (t == null) {
392                 this.t = Thread.currentThread();
393             } else {
394                 assertSame(t, Thread.currentThread());
395             }
396             ByteBuf m = (ByteBuf) msg;
397             int count = m.readableBytes() / 4;
398             for (int j = 0; j &lt; count; j ++) {
399                 int actual = m.readInt();
400                 int expected = inCnt ++;
401 <a name="22"></a>                assertEquals(expected, actual);
402                 ctx.fireChannelRead(actual);
403             }
404             <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>m.release();
405         }
406         @Override
407         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</b></font>
408             assertSame(t, Thread.currentThread());
409             ByteBuf out = ctx.alloc().buffer(4);
410             int m = (Integer) msg;
411             int expected = outCnt ++;
412 <a name="21"></a>            assertEquals(expected, m);
413             out.writeInt(m);
414             <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ctx.write(out, promise);
415         }
416         @Override
417         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
418             exception.compareAndSet</b></font>(null, cause);
419             //System.err.print("[" + Thread.currentThread().getName() + "] ");
420             //cause.printStackTrace();
421             super.exceptionCaught(ctx, cause);
422         }
423     }
424     private static class MessageForwarder3 extends ChannelDuplexHandler {
425         private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
426         private volatile int inCnt;
427         private volatile int outCnt;
428         private volatile Thread t;
429         @Override
430         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
431             Thread t = this.t;
432             if (t == null) {
433                 this.t = Thread.currentThread();
434             } else {
435                 assertSame(t, Thread.currentThread());
436             }
437             int actual = (Integer) msg;
438 <a name="20"></a>            int expected = inCnt ++;
439             assertEquals(expected, actual);
440             <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ctx.fireChannelRead(msg);
441         }
442         @Override
443         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</b></font>
444             assertSame(t, Thread.currentThread());
445             int actual = (Integer) msg;
446 <a name="19"></a>            int expected = outCnt ++;
447             assertEquals(expected, actual);
448             <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ctx.write(msg, promise);
449         }
450         @Override
451         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
452             exception.compareAndSet</b></font>(null, cause);
453             System.err.print('[' + Thread.currentThread().getName() + "] ");
454             cause.printStackTrace();
455             super.exceptionCaught(ctx, cause);
456         }
457     }
458     private static class MessageDiscarder extends ChannelDuplexHandler {
459         private final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
460         private volatile int inCnt;
461         private volatile int outCnt;
462         private volatile Thread t;
463         @Override
464         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
465             Thread t = this.t;
466             if (t == null) {
467                 this.t = Thread.currentThread();
468             } else {
469                 assertSame(t, Thread.currentThread());
470             }
471 <a name="18"></a>            int actual = (Integer) msg;
472             int expected = inCnt ++;
473             assertEquals(expected, actual);
474         <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
475         @Override
476         public void write(
477                 ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
478             assertSame</b></font>(t, Thread.currentThread());
479 <a name="17"></a>            int actual = (Integer) msg;
480             int expected = outCnt ++;
481             assertEquals(expected, actual);
482             <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ctx.write(msg, promise);
483         }
484         @Override
485         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
486             exception.compareAndSet</b></font>(null, cause);
487             //System.err.print("[" + Thread.currentThread().getName() + "] ");
488             //cause.printStackTrace();
489             super.exceptionCaught(ctx, cause);
490         }
491     }
492 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultChannelPipelineTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.channel;
2 import io.netty.bootstrap.Bootstrap;
3 import io.netty.bootstrap.ServerBootstrap;
4 import io.netty.buffer.ByteBuf;
5 import io.netty.buffer.Unpooled;
6 import io.netty.channel.ChannelHandler.Sharable;
7 import io.netty.channel.ChannelHandlerMask.Skip;
8 import io.netty.channel.embedded.EmbeddedChannel;
9 import io.netty.channel.local.LocalAddress;
10 import io.netty.channel.local.LocalChannel;
11 import io.netty.channel.local.LocalServerChannel;
12 import io.netty.channel.nio.NioEventLoopGroup;
13 import io.netty.channel.oio.OioEventLoopGroup;
14 import io.netty.channel.socket.nio.NioSocketChannel;
15 import io.netty.channel.socket.oio.OioSocketChannel;
16 import io.netty.util.AbstractReferenceCounted;
17 import io.netty.util.ReferenceCountUtil;
18 import io.netty.util.ReferenceCounted;
19 import io.netty.util.concurrent.AbstractEventExecutor;
20 import io.netty.util.concurrent.DefaultEventExecutorGroup;
21 import io.netty.util.concurrent.EventExecutor;
22 import io.netty.util.concurrent.EventExecutorGroup;
23 import io.netty.util.concurrent.Future;
24 import io.netty.util.concurrent.ImmediateEventExecutor;
25 import io.netty.util.concurrent.Promise;
26 <a name="1"></a>import io.netty.util.concurrent.UnorderedThreadPoolEventExecutor;
27 import org.junit.jupiter.api.AfterAll;
28 import org.junit.jupiter.api.AfterEach;
29 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.junit.jupiter.api.BeforeAll;
30 import org.junit.jupiter.api.Test;
31 import org.junit.jupiter.api.Timeout;
32 import org.junit.jupiter.api.function.Executable;
33 import java.net.SocketAddress;
34 import java.util.ArrayDeque;
35 import java.util.ArrayList;
36 import java.util.Collections;
37 import java.util.List;
38 import java.util.NoSuchElementException;
39 import java.util.Queue;
40 import java.util.concurrent.BlockingQueue;
41 import java.util.concurrent.CountDownLatch;
42 import java.util.concurrent.ExecutorService;
43 import java.util.concurrent.Executors;
44 import java.util.concurrent.LinkedBlockingQueue;
45 import java.util.concurrent.TimeUnit;
46 import java.util.concurrent.atomic.AtomicBoolean;
47 import java.util.concurrent.atomic.AtomicInteger;
48 import java.util.concurrent.atomic.AtomicReference;
49 import java.util.concurrent.locks.LockSupport;
50 import static org.junit.jupiter.api.Assertions.assertEquals;
51 import static org.junit.jupiter.api.Assertions.assertFalse;
52 import static org.junit.jupiter.api.Assertions.assertNotNull;
53 import static org.junit.jupiter.api.Assertions.assertNotSame;
54 import static org.junit.jupiter.api.Assertions.assertNull;
55 import static org.junit.jupiter.api.Assertions.assertThrows;
56 import static org.junit.jupiter.api.Assertions.assertTrue;
57 import static org.junit.jupiter.api.Assertions.assertSame;
58 import static org.junit.jupiter.api.Assertions.fail;
59 public class DefaultChannelPipelineTest {
60     private static EventLoopGroup group;
61     private Channel self</b></font>;
62     private Channel peer;
63     @BeforeAll
64     public static void beforeClass() throws Exception {
65         group = new DefaultEventLoopGroup(1);
66     }
67     @AfterAll
68     public static void afterClass() throws Exception {
69         group.shutdownGracefully().sync();
70 <a name="7"></a>    }
71     private void setUp(final ChannelHandler... handlers) throws Exception {
72         final AtomicReference&lt;Channel&gt; peerRef = <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new AtomicReference&lt;Channel&gt;();
73         ServerBootstrap sb = new ServerBootstrap();
74         sb.group(group).channel(LocalServerChannel.class);
75         sb.childHandler(new ChannelInboundHandlerAdapter() {
76             @Override
77             public void channelRegistered(ChannelHandlerContext ctx) {
78                 peerRef.set(ctx.channel</b></font>());
79             }
80             @Override
81             public void channelRead(ChannelHandlerContext ctx, Object msg) {
82                 ReferenceCountUtil.release(msg);
83             }
84         });
85         ChannelFuture bindFuture = sb.bind(LocalAddress.ANY).sync();
86         Bootstrap b = new Bootstrap();
87         b.group(group).channel(LocalChannel.class);
88         b.handler(new ChannelInitializer&lt;LocalChannel&gt;() {
89             @Override
90             protected void initChannel(LocalChannel ch) {
91                 ch.pipeline().addLast(handlers);
92             }
93 <a name="16"></a>        });
94         self = b.connect(bindFuture.channel().localAddress()).sync().channel();
95         <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>peer = peerRef.get();
96         bindFuture.channel().close().sync();
97     }
98     @AfterEach
99     public void tearDown() throws Exception {</b></font>
100         if (peer != null) {
101             peer.close();
102             peer = null;
103         }
104         if (self != null) {
105             self = null;
106         }
107     }
108     @Test
109     public void testFreeCalled() throws Exception {
110         final CountDownLatch free = new CountDownLatch(1);
111         final ReferenceCounted holder = new AbstractReferenceCounted() {
112             @Override
113             protected void deallocate() {
114                 free.countDown();
115             }
116             @Override
117             public ReferenceCounted touch(Object hint) {
118                 return this;
119             }
120         };
121         StringInboundHandler handler = new StringInboundHandler();
122         setUp(handler);
123         peer.writeAndFlush(holder).sync();
124         assertTrue(free.await(10, TimeUnit.SECONDS));
125         assertTrue(handler.called);
126     }
127     private static final class StringInboundHandler extends ChannelInboundHandlerAdapter {
128         boolean called;
129         @Override
130         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
131             called = true;
132             if (!(msg instanceof String)) {
133                 ctx.fireChannelRead(msg);
134             }
135         }
136     }
137     @Test
138     public void testRemoveChannelHandler() {
139         ChannelPipeline pipeline = new LocalChannel().pipeline();
140 <a name="2"></a>
141         ChannelHandler handler1 = newHandler();
142         ChannelHandler handler2 = newHandler();
143         ChannelHandler handler3 = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>newHandler();
144         pipeline.addLast("handler1", handler1);
145         pipeline.addLast("handler2", handler2);
146         pipeline.addLast("handler3", handler3);
147         assertSame(pipeline.get("handler1"), handler1);
148         assertSame(pipeline.get("handler2"), handler2);
149         assertSame(pipeline.get("handler3"), handler3);
150         pipeline.remove(handler1);
151         assertNull(pipeline.get("handler1"));
152         pipeline.remove(handler2);
153         assertNull(pipeline.get("handler2"));
154         pipeline.remove(handler3);
155         assertNull(pipeline.get("handler3"));
156     }</b></font>
157     @Test
158     public void testRemoveIfExists() {
159         DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());
160 <a name="3"></a>
161         ChannelHandler handler1 = newHandler();
162         ChannelHandler handler2 = newHandler();
163         ChannelHandler handler3 = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>newHandler();
164         pipeline.addLast("handler1", handler1);
165         pipeline.addLast("handler2", handler2);
166         pipeline.addLast("handler3", handler3);
167         assertNotNull(pipeline.removeIfExists(handler1));
168         assertNull(pipeline.get("handler1"));
169         assertNotNull(pipeline.removeIfExists("handler2"));
170         assertNull(pipeline.get("handler2"));
171         assertNotNull(pipeline.removeIfExists(TestHandler.class));
172         assertNull(pipeline.get("handler3"));
173     }</b></font>
174     @Test
175     public void testRemoveIfExistsDoesNotThrowException() {
176         DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());
177         ChannelHandler handler1 = newHandler();
178         ChannelHandler handler2 = newHandler();
179         pipeline.addLast("handler1", handler1);
180         assertNull(pipeline.removeIfExists("handlerXXX"));
181         assertNull(pipeline.removeIfExists(handler2));
182         assertNull(pipeline.removeIfExists(ChannelOutboundHandlerAdapter.class));
183         assertNotNull(pipeline.get("handler1"));
184     }
185     @Test
186     public void testRemoveThrowNoSuchElementException() {
187         final DefaultChannelPipeline pipeline = new DefaultChannelPipeline(new LocalChannel());
188         ChannelHandler handler1 = newHandler();
189         pipeline.addLast("handler1", handler1);
190         assertThrows(NoSuchElementException.class, new Executable() {
191             @Override
192             public void execute() {
193                 pipeline.remove("handlerXXX");
194             }
195         });
196     }
197     @Test
198     public void testReplaceChannelHandler() {
199         ChannelPipeline pipeline = new LocalChannel().pipeline();
200         ChannelHandler handler1 = newHandler();
201         pipeline.addLast("handler1", handler1);
202         pipeline.addLast("handler2", handler1);
203         pipeline.addLast("handler3", handler1);
204         assertSame(pipeline.get("handler1"), handler1);
205         assertSame(pipeline.get("handler2"), handler1);
206         assertSame(pipeline.get("handler3"), handler1);
207         ChannelHandler newHandler1 = newHandler();
208         pipeline.replace("handler1", "handler1", newHandler1);
209         assertSame(pipeline.get("handler1"), newHandler1);
210         ChannelHandler newHandler3 = newHandler();
211         pipeline.replace("handler3", "handler3", newHandler3);
212         assertSame(pipeline.get("handler3"), newHandler3);
213         ChannelHandler newHandler2 = newHandler();
214         pipeline.replace("handler2", "handler2", newHandler2);
215         assertSame(pipeline.get("handler2"), newHandler2);
216     }
217     @Test
218     public void testReplaceHandlerChecksDuplicateNames() {
219         final ChannelPipeline pipeline = new LocalChannel().pipeline();
220         ChannelHandler handler1 = newHandler();
221         ChannelHandler handler2 = newHandler();
222         pipeline.addLast("handler1", handler1);
223         pipeline.addLast("handler2", handler2);
224         final ChannelHandler newHandler1 = newHandler();
225         assertThrows(IllegalArgumentException.class, new Executable() {
226             @Override
227             public void execute() {
228                 pipeline.replace("handler1", "handler2", newHandler1);
229             }
230         });
231     }
232     @Test
233     public void testReplaceNameWithGenerated() {
234         ChannelPipeline pipeline = new LocalChannel().pipeline();
235         ChannelHandler handler1 = newHandler();
236         pipeline.addLast("handler1", handler1);
237         assertSame(pipeline.get("handler1"), handler1);
238         ChannelHandler newHandler1 = newHandler();
239         pipeline.replace("handler1", null, newHandler1);
240         assertSame(pipeline.get("DefaultChannelPipelineTest$TestHandler#0"), newHandler1);
241         assertNull(pipeline.get("handler1"));
242     }
243     @Test
244     public void testRenameChannelHandler() {
245         ChannelPipeline pipeline = new LocalChannel().pipeline();
246         ChannelHandler handler1 = newHandler();
247         pipeline.addLast("handler1", handler1);
248         pipeline.addLast("handler2", handler1);
249         pipeline.addLast("handler3", handler1);
250         assertSame(pipeline.get("handler1"), handler1);
251         assertSame(pipeline.get("handler2"), handler1);
252         assertSame(pipeline.get("handler3"), handler1);
253         ChannelHandler newHandler1 = newHandler();
254         pipeline.replace("handler1", "newHandler1", newHandler1);
255         assertSame(pipeline.get("newHandler1"), newHandler1);
256         assertNull(pipeline.get("handler1"));
257         ChannelHandler newHandler3 = newHandler();
258         pipeline.replace("handler3", "newHandler3", newHandler3);
259         assertSame(pipeline.get("newHandler3"), newHandler3);
260         assertNull(pipeline.get("handler3"));
261         ChannelHandler newHandler2 = newHandler();
262         pipeline.replace("handler2", "newHandler2", newHandler2);
263         assertSame(pipeline.get("newHandler2"), newHandler2);
264         assertNull(pipeline.get("handler2"));
265     }
266     @Test
267     public void testChannelHandlerContextNavigation() {
268         ChannelPipeline pipeline = new LocalChannel().pipeline();
269         final int HANDLER_ARRAY_LEN = 5;
270         ChannelHandler[] firstHandlers = newHandlers(HANDLER_ARRAY_LEN);
271         ChannelHandler[] lastHandlers = newHandlers(HANDLER_ARRAY_LEN);
272         pipeline.addFirst(firstHandlers);
273 <a name="15"></a>        pipeline.addLast(lastHandlers);
274         verifyContextNumber(pipeline, HANDLER_ARRAY_LEN * 2);
275     <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
276     @Test
277     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
278     public void testThrowInExceptionCaught() throws InterruptedException {
279         final CountDownLatch latch = new</b></font> CountDownLatch(1);
280         final AtomicInteger counter = new AtomicInteger();
281         Channel channel = new LocalChannel();
282         try {
283             group.register(channel).syncUninterruptibly();
284             channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
285                 class TestException extends Exception { }
286                 @Override
287                 public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
288                     throw new TestException();
289                 }
290                 @Override
291                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
292                     if (cause instanceof TestException) {
293                         ctx.executor().execute(new Runnable() {
294                             @Override
295                             public void run() {
296                                 latch.countDown();
297                             }
298                         });
299                     }
300                     counter.incrementAndGet();
301                     throw new Exception();
302                 }
303             });
304             channel.pipeline().fireChannelReadComplete();
305             latch.await();
306             assertEquals(1, counter.get());
307         } finally {
308             channel.close().syncUninterruptibly();
309         }
310     }
311     @Test
312     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
313     public void testThrowInOtherHandlerAfterInvokedFromExceptionCaught() throws InterruptedException {
314         final CountDownLatch latch = new CountDownLatch(1);
315         final AtomicInteger counter = new AtomicInteger();
316 <a name="10"></a>        Channel channel = new LocalChannel();
317         try {
318             group.register(channel).syncUninterruptibly();
319             channel.pipeline().addLast(<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new ChannelInboundHandlerAdapter() {
320                 @Override
321                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
322                     ctx.fireChannelReadComplete();
323                 }
324             }</b></font>, new ChannelInboundHandlerAdapter() {
325                 class TestException extends Exception { }
326                 @Override
327                 public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
328                     throw new TestException();
329                 }
330                 @Override
331                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
332                     if (cause instanceof TestException) {
333                         ctx.executor().execute(new Runnable() {
334                             @Override
335                             public void run() {
336                                 latch.countDown();
337                             }
338                         });
339                     }
340                     counter.incrementAndGet();
341                     throw new Exception();
342                 }
343             });
344             channel.pipeline().fireExceptionCaught(new Exception());
345             latch.await();
346             assertEquals(1, counter.get());
347         } finally {
348             channel.close().syncUninterruptibly();
349         }
350     }
351     @Test
352     public void testFireChannelRegistered() throws Exception {
353         final CountDownLatch latch = new CountDownLatch(1);
354         ChannelPipeline pipeline = new LocalChannel().pipeline();
355         pipeline.addLast(new ChannelInitializer&lt;Channel&gt;() {
356             @Override
357             protected void initChannel(Channel ch) {
358                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
359                     @Override
360                     public void channelRegistered(ChannelHandlerContext ctx) {
361                         latch.countDown();
362                     }
363                 });
364             }
365         });
366         group.register(pipeline.channel());
367         assertTrue(latch.await(2, TimeUnit.SECONDS));
368     }
369     @Test
370     public void testPipelineOperation() {
371         ChannelPipeline pipeline = new LocalChannel().pipeline();
372         final int handlerNum = 5;
373         ChannelHandler[] handlers1 = newHandlers(handlerNum);
374         ChannelHandler[] handlers2 = newHandlers(handlerNum);
375         final String prefixX = "x";
376         for (int i = 0; i &lt; handlerNum; i++) {
377             if (i % 2 == 0) {
378                 pipeline.addFirst(prefixX + i, handlers1[i]);
379             } else {
380                 pipeline.addLast(prefixX + i, handlers1[i]);
381             }
382         }
383         for (int i = 0; i &lt; handlerNum; i++) {
384             if (i % 2 != 0) {
385                 pipeline.addBefore(prefixX + i, String.valueOf(i), handlers2[i]);
386             } else {
387                 pipeline.addAfter(prefixX + i, String.valueOf(i), handlers2[i]);
388             }
389         }
390         verifyContextNumber(pipeline, handlerNum * 2);
391     }
392 <a name="5"></a>
393     @Test
394     public void testChannelHandlerContextOrder() {
395         ChannelPipeline pipeline = <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new LocalChannel().pipeline();
396         pipeline.addFirst("1", newHandler());
397         pipeline.addLast("10", newHandler());
398         pipeline.addBefore("10", "5", newHandler());
399         pipeline.addAfter("1", "3", newHandler());
400         pipeline.addBefore("5", "4", newHandler());
401         pipeline.addAfter("5", "6", newHandler());
402         pipeline.addBefore("1", "0", newHandler());
403         pipeline.addAfter("10", "11", newHandler</b></font>());
404         AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
405         assertNotNull(ctx);
406         while (ctx != null) {
407             int i = toInt(ctx.name());
408             int j = next(ctx);
409             if (j != -1) {
410                 assertTrue(i &lt; j);
411             } else {
412                 assertNull(ctx.next.next);
413             }
414             ctx = ctx.next;
415         }
416         verifyContextNumber(pipeline, 8);
417     }
418     @Test
419     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
420     public void testLifeCycleAwareness() throws Exception {
421         setUp();
422         ChannelPipeline p = self.pipeline();
423         final List&lt;LifeCycleAwareTestHandler&gt; handlers = new ArrayList&lt;LifeCycleAwareTestHandler&gt;();
424         final int COUNT = 20;
425         final CountDownLatch addLatch = new CountDownLatch(COUNT);
426         for (int i = 0; i &lt; COUNT; i++) {
427             final LifeCycleAwareTestHandler handler = new LifeCycleAwareTestHandler("handler-" + i);
428             p.addFirst(handler.name, handler);
429             self.eventLoop().execute(new Runnable() {
430                 @Override
431                 public void run() {
432                     handler.validate(true, false);
433                     handlers.add(handler);
434                     addLatch.countDown();
435                 }
436             });
437         }
438         addLatch.await();
439         Collections.shuffle(handlers);
440 <a name="26"></a>        final CountDownLatch removeLatch = new CountDownLatch(COUNT);
441         for (final LifeCycleAwareTestHandler handler : handlers) {
442             <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertSame(handler, p.remove(handler.name));
443             self.eventLoop().execute(new Runnable() {
444                 @Override
445                 public void run() {</b></font>
446                     handler.validate(true, true);
447                     removeLatch.countDown();
448                 }
449             });
450         }
451         removeLatch.await();
452     }
453     @Test
454     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
455     public void testRemoveAndForwardInbound() throws Exception {
456         final BufferedTestHandler handler1 = new BufferedTestHandler();
457         final BufferedTestHandler handler2 = new BufferedTestHandler();
458         setUp(handler1, handler2);
459         self.eventLoop().submit(new Runnable() {
460             @Override
461             public void run() {
462                 ChannelPipeline p = self.pipeline();
463                 handler1.inboundBuffer.add(8);
464                 assertEquals(8, handler1.inboundBuffer.peek());
465                 assertTrue(handler2.inboundBuffer.isEmpty());
466                 p.remove(handler1);
467                 assertEquals(1, handler2.inboundBuffer.size());
468                 assertEquals(8, handler2.inboundBuffer.peek());
469             }
470         }).sync();
471     }
472     @Test
473     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
474     public void testRemoveAndForwardOutbound() throws Exception {
475         final BufferedTestHandler handler1 = new BufferedTestHandler();
476         final BufferedTestHandler handler2 = new BufferedTestHandler();
477         setUp(handler1, handler2);
478         self.eventLoop().submit(new Runnable() {
479             @Override
480             public void run() {
481                 ChannelPipeline p = self.pipeline();
482                 handler2.outboundBuffer.add(8);
483                 assertEquals(8, handler2.outboundBuffer.peek());
484                 assertTrue(handler1.outboundBuffer.isEmpty());
485                 p.remove(handler2);
486                 assertEquals(1, handler1.outboundBuffer.size());
487                 assertEquals(8, handler1.outboundBuffer.peek());
488             }
489         }).sync();
490     }
491     @Test
492     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
493     public void testReplaceAndForwardOutbound() throws Exception {
494         final BufferedTestHandler handler1 = new BufferedTestHandler();
495         final BufferedTestHandler handler2 = new BufferedTestHandler();
496         setUp(handler1);
497         self.eventLoop().submit(new Runnable() {
498             @Override
499             public void run() {
500                 ChannelPipeline p = self.pipeline();
501                 handler1.outboundBuffer.add(8);
502                 assertEquals(8, handler1.outboundBuffer.peek());
503                 assertTrue(handler2.outboundBuffer.isEmpty());
504                 p.replace(handler1, "handler2", handler2);
505                 assertEquals(8, handler2.outboundBuffer.peek());
506             }
507         }).sync();
508     }
509     @Test
510     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
511     public void testReplaceAndForwardInboundAndOutbound() throws Exception {
512         final BufferedTestHandler handler1 = new BufferedTestHandler();
513         final BufferedTestHandler handler2 = new BufferedTestHandler();
514         setUp(handler1);
515 <a name="6"></a>        self.eventLoop().submit(new Runnable() {
516             @Override
517             public void run() {
518                 ChannelPipeline p = <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>self.pipeline();
519                 handler1.inboundBuffer.add(8);
520                 handler1.outboundBuffer.add(8);
521                 assertEquals(8, handler1.inboundBuffer.peek());
522                 assertEquals(8, handler1.outboundBuffer.peek());
523                 assertTrue(handler2.inboundBuffer.isEmpty());
524                 assertTrue(handler2.outboundBuffer.isEmpty());
525                 p.replace(handler1, "handler2", handler2);
526                 assertEquals(8, handler2.outboundBuffer.peek());
527                 assertEquals(8, handler2.inboundBuffer.peek</b></font>());
528             }
529         }).sync();
530     }
531     @Test
532     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
533     public void testRemoveAndForwardInboundOutbound() throws Exception {
534         final BufferedTestHandler handler1 = new BufferedTestHandler();
535         final BufferedTestHandler handler2 = new BufferedTestHandler();
536         final BufferedTestHandler handler3 = new BufferedTestHandler();
537         setUp(handler1, handler2, handler3);
538         self.eventLoop().submit(new Runnable() {
539             @Override
540             public void run() {
541                 ChannelPipeline p = self.pipeline();
542                 handler2.inboundBuffer.add(8);
543                 handler2.outboundBuffer.add(8);
544                 assertEquals(8, handler2.inboundBuffer.peek());
545                 assertEquals(8, handler2.outboundBuffer.peek());
546                 assertEquals(0, handler1.outboundBuffer.size());
547                 assertEquals(0, handler3.inboundBuffer.size());
548                 p.remove(handler2);
549                 assertEquals(8, handler3.inboundBuffer.peek());
550                 assertEquals(8, handler1.outboundBuffer.peek());
551             }
552         }).sync();
553     }
554     @Test
555     public void testCancelBind() {
556         ChannelPipeline pipeline = new LocalChannel().pipeline();
557         group.register(pipeline.channel());
558         ChannelPromise promise = pipeline.channel().newPromise();
559         assertTrue(promise.cancel(false));
560         ChannelFuture future = pipeline.bind(new LocalAddress("test"), promise);
561         assertTrue(future.isCancelled());
562     }
563     @Test
564     public void testCancelConnect() {
565         ChannelPipeline pipeline = new LocalChannel().pipeline();
566         group.register(pipeline.channel());
567         ChannelPromise promise = pipeline.channel().newPromise();
568         assertTrue(promise.cancel(false));
569         ChannelFuture future = pipeline.connect(new LocalAddress("test"), promise);
570         assertTrue(future.isCancelled());
571     }
572     @Test
573     public void testCancelDisconnect() {
574         ChannelPipeline pipeline = new LocalChannel().pipeline();
575 <a name="24"></a>        group.register(pipeline.channel());
576         ChannelPromise promise = pipeline.channel().newPromise();
577         assertTrue(<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>promise.cancel(false));
578         ChannelFuture future = pipeline.disconnect(promise);
579         assertTrue(future.isCancelled());
580     }
581     @</b></font>Test
582     public void testCancelClose() {
583         ChannelPipeline pipeline = new LocalChannel().pipeline();
584         group.register(pipeline.channel());
585         ChannelPromise promise = pipeline.channel().newPromise();
586         assertTrue(promise.cancel(false));
587         ChannelFuture future = pipeline.close(promise);
588         assertTrue(future.isCancelled());
589     }
590     @Test
591     public void testWrongPromiseChannel() throws Exception {
592         final ChannelPipeline pipeline = new LocalChannel().pipeline();
593         group.register(pipeline.channel()).sync();
594         ChannelPipeline pipeline2 = new LocalChannel().pipeline();
595         group.register(pipeline2.channel()).sync();
596         try {
597             final ChannelPromise promise2 = pipeline2.channel().newPromise();
598             assertThrows(IllegalArgumentException.class, new Executable() {
599                 @Override
600                 public void execute() {
601                     pipeline.close(promise2);
602                 }
603             });
604         } finally {
605             pipeline.close();
606             pipeline2.close();
607         }
608     }
609     @Test
610     public void testUnexpectedVoidChannelPromise() throws Exception {
611         final ChannelPipeline pipeline = new LocalChannel().pipeline();
612         group.register(pipeline.channel()).sync();
613         try {
614             final ChannelPromise promise = new VoidChannelPromise(pipeline.channel(), false);
615             assertThrows(IllegalArgumentException.class, new Executable() {
616                 @Override
617                 public void execute() {
618                     pipeline.close(promise);
619                 }
620             });
621         } finally {
622             pipeline.close();
623         }
624     }
625     @Test
626     public void testUnexpectedVoidChannelPromiseCloseFuture() throws Exception {
627         final ChannelPipeline pipeline = new LocalChannel().pipeline();
628         group.register(pipeline.channel()).sync();
629         try {
630             final ChannelPromise promise = (ChannelPromise) pipeline.channel().closeFuture();
631             assertThrows(IllegalArgumentException.class, new Executable() {
632                 @Override
633                 public void execute() {
634                     pipeline.close(promise);
635                 }
636             });
637         } finally {
638             pipeline.close();
639         }
640     }
641     @Test
642     public void testCancelDeregister() {
643         ChannelPipeline pipeline = new LocalChannel().pipeline();
644         group.register(pipeline.channel());
645         ChannelPromise promise = pipeline.channel().newPromise();
646         assertTrue(promise.cancel(false));
647         ChannelFuture future = pipeline.deregister(promise);
648         assertTrue(future.isCancelled());
649     }
650     @Test
651     public void testCancelWrite() {
652         ChannelPipeline pipeline = new LocalChannel().pipeline();
653         group.register(pipeline.channel());
654         ChannelPromise promise = pipeline.channel().newPromise();
655         assertTrue(promise.cancel(false));
656         ByteBuf buffer = Unpooled.buffer();
657         assertEquals(1, buffer.refCnt());
658         ChannelFuture future = pipeline.write(buffer, promise);
659         assertTrue(future.isCancelled());
660         assertEquals(0, buffer.refCnt());
661     }
662     @Test
663     public void testCancelWriteAndFlush() {
664         ChannelPipeline pipeline = new LocalChannel().pipeline();
665         group.register(pipeline.channel());
666         ChannelPromise promise = pipeline.channel().newPromise();
667         assertTrue(promise.cancel(false));
668         ByteBuf buffer = Unpooled.buffer();
669         assertEquals(1, buffer.refCnt());
670         ChannelFuture future = pipeline.writeAndFlush(buffer, promise);
671         assertTrue(future.isCancelled());
672         assertEquals(0, buffer.refCnt());
673     }
674     @Test
675     public void testFirstContextEmptyPipeline() {
676         ChannelPipeline pipeline = new LocalChannel().pipeline();
677         assertNull(pipeline.firstContext());
678     }
679     @Test
680     public void testLastContextEmptyPipeline() {
681         ChannelPipeline pipeline = new LocalChannel().pipeline();
682         assertNull(pipeline.lastContext());
683     }
684     @Test
685     public void testFirstHandlerEmptyPipeline() {
686         ChannelPipeline pipeline = new LocalChannel().pipeline();
687         assertNull(pipeline.first());
688     }
689 <a name="27"></a>    @Test
690     public void testLastHandlerEmptyPipeline() {
691         ChannelPipeline pipeline = new LocalChannel().pipeline();
692         <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertNull(pipeline.last());
693     }
694     @Test
695     @Timeout(value = 5000, u</b></font>nit = TimeUnit.MILLISECONDS)
696     public void testChannelInitializerException() throws Exception {
697         final IllegalStateException exception = new IllegalStateException();
698         final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
699         final CountDownLatch latch = new CountDownLatch(1);
700         EmbeddedChannel channel = new EmbeddedChannel(new ChannelInitializer&lt;Channel&gt;() {
701 <a name="11"></a>            @Override
702             protected void initChannel(Channel ch) {
703                 throw exception;
704             <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
705             @Override
706             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
707                 super.exceptionCaught(ctx, cause);
708                 error.set(cause);
709                 latch.countDown</b></font>();
710             }
711         });
712         latch.await();
713         assertFalse(channel.isActive());
714         assertSame(exception, error.get());
715     }
716     @Test
717     public void testChannelUnregistrationWithCustomExecutor() throws Exception {
718         final CountDownLatch channelLatch = new CountDownLatch(1);
719         final CountDownLatch handlerLatch = new CountDownLatch(1);
720         ChannelPipeline pipeline = new LocalChannel().pipeline();
721         pipeline.addLast(new ChannelInitializer&lt;Channel&gt;() {
722             @Override
723             protected void initChannel(Channel ch) {
724                 ch.pipeline().addLast(new WrapperExecutor(),
725                         new ChannelInboundHandlerAdapter() {
726                             @Override
727                             public void channelUnregistered(ChannelHandlerContext ctx) {
728                                 channelLatch.countDown();
729                             }
730                             @Override
731                             public void handlerRemoved(ChannelHandlerContext ctx) {
732                                 handlerLatch.countDown();
733                             }
734                         });
735             }
736         });
737         Channel channel = pipeline.channel();
738         group.register(channel);
739         channel.close();
740         channel.deregister();
741         assertTrue(channelLatch.await(2, TimeUnit.SECONDS));
742         assertTrue(handlerLatch.await(2, TimeUnit.SECONDS));
743     }
744     @Test
745     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
746     public void testAddHandlerBeforeRegisteredThenRemove() {
747         final EventLoop loop = group.next();
748         CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
749         ChannelPipeline pipeline = new LocalChannel().pipeline();
750         pipeline.addFirst(handler);
751         assertFalse(handler.addedPromise.isDone());
752         group.register(pipeline.channel());
753         handler.addedPromise.syncUninterruptibly();
754         pipeline.remove(handler);
755         handler.removedPromise.syncUninterruptibly();
756     }
757     @Test
758     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
759     public void testAddHandlerBeforeRegisteredThenReplace() throws Exception {
760         final EventLoop loop = group.next();
761         final CountDownLatch latch = new CountDownLatch(1);
762         CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
763         ChannelPipeline pipeline = new LocalChannel().pipeline();
764         pipeline.addFirst(handler);
765         assertFalse(handler.addedPromise.isDone());
766         group.register(pipeline.channel());
767         handler.addedPromise.syncUninterruptibly();
768         pipeline.replace(handler, null, new ChannelHandlerAdapter() {
769             @Override
770             public void handlerAdded(ChannelHandlerContext ctx) {
771                 latch.countDown();
772             }
773         });
774         handler.removedPromise.syncUninterruptibly();
775         latch.await();
776     }
777     @Test
778     public void testAddRemoveHandlerNotRegistered() throws Throwable {
779         final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
780         ChannelHandler handler = new ErrorChannelHandler(error);
781         ChannelPipeline pipeline = new LocalChannel().pipeline();
782         pipeline.addFirst(handler);
783         pipeline.remove(handler);
784         Throwable cause = error.get();
785         if (cause != null) {
786             throw cause;
787         }
788     }
789     @Test
790     public void testAddReplaceHandlerNotRegistered() throws Throwable {
791         final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
792         ChannelHandler handler = new ErrorChannelHandler(error);
793         ChannelPipeline pipeline = new LocalChannel().pipeline();
794         pipeline.addFirst(handler);
795         pipeline.replace(handler, null, new ErrorChannelHandler(error));
796         Throwable cause = error.get();
797         if (cause != null) {
798             throw cause;
799         }
800     }
801     @Test
802 <a name="4"></a>    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
803     public void testHandlerAddedAndRemovedCalledInCorrectOrder() throws Throwable {
804         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
805         final EventExecutorGroup group2 = <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new DefaultEventExecutorGroup(1);
806         try {
807             BlockingQueue&lt;CheckOrderHandler&gt; addedQueue = new LinkedBlockingQueue&lt;CheckOrderHandler&gt;();
808             BlockingQueue&lt;CheckOrderHandler&gt; removedQueue = new LinkedBlockingQueue&lt;CheckOrderHandler&gt;();
809             CheckOrderHandler handler1 = new CheckOrderHandler(addedQueue, removedQueue);
810             CheckOrderHandler handler2 = new CheckOrderHandler(addedQueue, removedQueue);
811 <a name="0"></a>            CheckOrderHandler handler3 = new CheckOrderHandler(addedQueue, removedQueue);
812             CheckOrderHandler handler4 = new CheckOrderHandler(addedQueue, removedQueue);
813             ChannelPipeline pipeline = <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new LocalChannel().pipeline()</b></font>;
814             pipeline.addLast(handler1);
815             group.register(pipeline.channel()).syncUninterruptibly();
816             pipeline.addLast(group1, handler2);
817             pipeline.addLast(group2, handler3);
818             pipeline.addLast(handler4);
819             assertTrue(removedQueue.isEmpty());
820             pipeline.channel().close().syncUninterruptibly();
821             assertHandler(addedQueue.take(), handler1);
822             assertHandler(addedQueue.take(), handler2, handler3, handler4);
823             assertHandler(addedQueue.take(), handler2, handler3, handler4);
824             assertHandler(addedQueue.take(), handler2, handler3, handler4);
825             assertTrue(addedQueue.isEmpty());
826             assertHandler(removedQueue.take(), handler4);
827             assertHandler(removedQueue.take(), handler3);
828             assertHandler(removedQueue.take(), handler2);
829             assertHandler(removedQueue.take(), handler1);
830             assertTrue(removedQueue.isEmpty</b></font>());
831         } finally {
832             group1.shutdownGracefully();
833             group2.shutdownGracefully();
834         }
835     }
836     @Test
837     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
838     public void testHandlerAddedExceptionFromChildHandlerIsPropagated() {
839         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
840         try {
841             final Promise&lt;Void&gt; promise = group1.next().newPromise();
842             final AtomicBoolean handlerAdded = new AtomicBoolean();
843             final Exception exception = new RuntimeException();
844             ChannelPipeline pipeline = new LocalChannel().pipeline();
845             pipeline.addLast(group1, new CheckExceptionHandler(exception, promise));
846             pipeline.addFirst(new ChannelHandlerAdapter() {
847                 @Override
848                 public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
849                     handlerAdded.set(true);
850                     throw exception;
851                 }
852             });
853             assertFalse(handlerAdded.get());
854             group.register(pipeline.channel());
855             promise.syncUninterruptibly();
856         } finally {
857             group1.shutdownGracefully();
858         }
859     }
860     @Test
861     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
862     public void testHandlerRemovedExceptionFromChildHandlerIsPropagated() {
863         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
864         try {
865             final Promise&lt;Void&gt; promise = group1.next().newPromise();
866             String handlerName = "foo";
867             final Exception exception = new RuntimeException();
868             ChannelPipeline pipeline = new LocalChannel().pipeline();
869             pipeline.addLast(handlerName, new ChannelHandlerAdapter() {
870                 @Override
871                 public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
872                     throw exception;
873                 }
874             });
875             pipeline.addLast(group1, new CheckExceptionHandler(exception, promise));
876             group.register(pipeline.channel()).syncUninterruptibly();
877             pipeline.remove(handlerName);
878             promise.syncUninterruptibly();
879         } finally {
880             group1.shutdownGracefully();
881         }
882     }
883     @Test
884     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
885     public void testHandlerAddedThrowsAndRemovedThrowsException() throws InterruptedException {
886         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
887         try {
888             final CountDownLatch latch = new CountDownLatch(1);
889             final Promise&lt;Void&gt; promise = group1.next().newPromise();
890             final Exception exceptionAdded = new RuntimeException();
891             final Exception exceptionRemoved = new RuntimeException();
892             String handlerName = "foo";
893             ChannelPipeline pipeline = new LocalChannel().pipeline();
894             pipeline.addLast(group1, new CheckExceptionHandler(exceptionAdded, promise));
895             pipeline.addFirst(handlerName, new ChannelHandlerAdapter() {
896                 @Override
897                 public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
898                     throw exceptionAdded;
899                 }
900                 @Override
901                 public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
902                     ctx.executor().execute(new Runnable() {
903                         @Override
904                         public void run() {
905                             latch.countDown();
906                         }
907                     });
908                     throw exceptionRemoved;
909                 }
910             });
911             group.register(pipeline.channel()).syncUninterruptibly();
912             latch.await();
913             assertNull(pipeline.context(handlerName));
914             promise.syncUninterruptibly();
915         } finally {
916             group1.shutdownGracefully();
917         }
918     }
919     @Test
920     @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)
921     public void testAddRemoveHandlerCalledOnceRegistered() throws Throwable {
922         ChannelPipeline pipeline = new LocalChannel().pipeline();
923         CallbackCheckHandler handler = new CallbackCheckHandler();
924         pipeline.addFirst(handler);
925         pipeline.remove(handler);
926         assertNull(handler.addedHandler.getNow());
927         assertNull(handler.removedHandler.getNow());
928         group.register(pipeline.channel()).syncUninterruptibly();
929         Throwable cause = handler.error.get();
930         if (cause != null) {
931             throw cause;
932         }
933         assertTrue(handler.addedHandler.get());
934         assertTrue(handler.removedHandler.get());
935     }
936     @Test
937     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
938 <a name="8"></a>    public void testAddReplaceHandlerCalledOnceRegistered() throws Throwable {
939         ChannelPipeline pipeline = new LocalChannel().pipeline();
940         CallbackCheckHandler handler = new CallbackCheckHandler();
941         CallbackCheckHandler handler2 = <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new CallbackCheckHandler();
942         pipeline.addFirst(handler);
943         pipeline.replace(handler, null, handler2);
944         assertNull(handler.addedHandler.getNow());
945         assertNull(handler.removedHandler.getNow());
946         assertNull(handler2.addedHandler.getNow());
947         assertNull(handler2.removedHandler.getNow());
948         group.register</b></font>(pipeline.channel()).syncUninterruptibly();
949         Throwable cause = handler.error.get();
950         if (cause != null) {
951             throw cause;
952         }
953         assertTrue(handler.addedHandler.get());
954         assertTrue(handler.removedHandler.get());
955         Throwable cause2 = handler2.error.get();
956         if (cause2 != null) {
957             throw cause2;
958         }
959         assertTrue(handler2.addedHandler.get());
960         assertNull(handler2.removedHandler.getNow());
961         pipeline.remove(handler2);
962         assertTrue(handler2.removedHandler.get());
963     }
964     @Test
965     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
966     public void testAddBefore() throws Throwable {
967         ChannelPipeline pipeline1 = new LocalChannel().pipeline();
968         ChannelPipeline pipeline2 = new LocalChannel().pipeline();
969         EventLoopGroup defaultGroup = new DefaultEventLoopGroup(2);
970         try {
971             EventLoop eventLoop1 = defaultGroup.next();
972             EventLoop eventLoop2 = defaultGroup.next();
973             eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
974             eventLoop2.register(pipeline2.channel()).syncUninterruptibly();
975             CountDownLatch latch = new CountDownLatch(2 * 10);
976             for (int i = 0; i &lt; 10; i++) {
977                 eventLoop1.execute(new TestTask(pipeline2, latch));
978                 eventLoop2.execute(new TestTask(pipeline1, latch));
979             }
980             latch.await();
981         } finally {
982             defaultGroup.shutdownGracefully();
983         }
984     }
985     @Test
986     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
987     public void testAddInListenerNio() {
988         testAddInListener(new NioSocketChannel(), new NioEventLoopGroup(1));
989     }
990     @SuppressWarnings("deprecation")
991     @Test
992     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
993     public void testAddInListenerOio() {
994         testAddInListener(new OioSocketChannel(), new OioEventLoopGroup(1));
995     }
996     @Test
997     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
998     public void testAddInListenerLocal() {
999         testAddInListener(new LocalChannel(), new DefaultEventLoopGroup(1));
1000     }
1001     private static void testAddInListener(Channel channel, EventLoopGroup group) {
1002         ChannelPipeline pipeline1 = channel.pipeline();
1003         try {
1004             final Object event = new Object();
1005             final Promise&lt;Object&gt; promise = ImmediateEventExecutor.INSTANCE.newPromise();
1006             group.register(pipeline1.channel()).addListener(new ChannelFutureListener() {
1007                 @Override
1008                 public void operationComplete(ChannelFuture future) {
1009                     ChannelPipeline pipeline = future.channel().pipeline();
1010                     final AtomicBoolean handlerAddedCalled = new AtomicBoolean();
1011 <a name="23"></a>                    pipeline.addLast(new ChannelInboundHandlerAdapter() {
1012                         @Override
1013                         public void handlerAdded(ChannelHandlerContext ctx) {
1014                             <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>handlerAddedCalled.set(true);
1015                         }
1016                         @Override
1017                         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1018                             promise.setSuccess</b></font>(event);
1019                         }
1020                         @Override
1021                         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
1022                             promise.setFailure(cause);
1023                         }
1024                     });
1025                     if (!handlerAddedCalled.get()) {
1026                         promise.setFailure(new AssertionError("handlerAdded(...) should have been called"));
1027                         return;
1028                     }
1029                     pipeline.fireUserEventTriggered(event);
1030                 }
1031             });
1032             assertSame(event, promise.syncUninterruptibly().getNow());
1033         } finally {
1034             pipeline1.channel().close().syncUninterruptibly();
1035             group.shutdownGracefully();
1036         }
1037     }
1038     @Test
1039     public void testNullName() {
1040         ChannelPipeline pipeline = new LocalChannel().pipeline();
1041         pipeline.addLast(newHandler());
1042         pipeline.addLast(null, newHandler());
1043         pipeline.addFirst(newHandler());
1044         pipeline.addFirst(null, newHandler());
1045         pipeline.addLast("test", newHandler());
1046         pipeline.addAfter("test", null, newHandler());
1047         pipeline.addBefore("test", null, newHandler());
1048     }
1049     @Test
1050     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
1051     public void testUnorderedEventExecutor() throws Throwable {
1052         ChannelPipeline pipeline1 = new LocalChannel().pipeline();
1053         EventExecutorGroup eventExecutors = new UnorderedThreadPoolEventExecutor(2);
1054         EventLoopGroup defaultGroup = new DefaultEventLoopGroup(1);
1055         try {
1056             EventLoop eventLoop1 = defaultGroup.next();
1057             eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
1058             final CountDownLatch latch = new CountDownLatch(1);
1059             pipeline1.addLast(eventExecutors, new ChannelInboundHandlerAdapter() {
1060 <a name="21"></a>                @Override
1061                 public void handlerAdded(ChannelHandlerContext ctx) {
1062                     <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>LockSupport.park();
1063                 }
1064                 @Override
1065                 public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1066                     latch.countDown</b></font>();
1067                 }
1068             });
1069             pipeline1.fireUserEventTriggered("");
1070             latch.await();
1071         } finally {
1072             defaultGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
1073             eventExecutors.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
1074         }
1075     }
1076     @Test
1077     public void testPinExecutor() {
1078         EventExecutorGroup group = new DefaultEventExecutorGroup(2);
1079         ChannelPipeline pipeline = new LocalChannel().pipeline();
1080         ChannelPipeline pipeline2 = new LocalChannel().pipeline();
1081         pipeline.addLast(group, "h1", new ChannelInboundHandlerAdapter());
1082         pipeline.addLast(group, "h2", new ChannelInboundHandlerAdapter());
1083         pipeline2.addLast(group, "h3", new ChannelInboundHandlerAdapter());
1084         EventExecutor executor1 = pipeline.context("h1").executor();
1085         EventExecutor executor2 = pipeline.context("h2").executor();
1086         assertNotNull(executor1);
1087         assertNotNull(executor2);
1088         assertSame(executor1, executor2);
1089         EventExecutor executor3 = pipeline2.context("h3").executor();
1090         assertNotNull(executor3);
1091         assertNotSame(executor3, executor2);
1092         group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
1093     }
1094     @Test
1095     public void testNotPinExecutor() {
1096         EventExecutorGroup group = new DefaultEventExecutorGroup(2);
1097         ChannelPipeline pipeline = new LocalChannel().pipeline();
1098         pipeline.channel().config().setOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP, false);
1099         pipeline.addLast(group, "h1", new ChannelInboundHandlerAdapter());
1100         pipeline.addLast(group, "h2", new ChannelInboundHandlerAdapter());
1101         EventExecutor executor1 = pipeline.context("h1").executor();
1102         EventExecutor executor2 = pipeline.context("h2").executor();
1103         assertNotNull(executor1);
1104         assertNotNull(executor2);
1105         assertNotSame(executor1, executor2);
1106         group.shutdownGracefully(0, 0, TimeUnit.SECONDS);
1107     }
1108     @Test
1109     @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
1110     public void testVoidPromiseNotify() {
1111         ChannelPipeline pipeline1 = new LocalChannel().pipeline();
1112         EventLoopGroup defaultGroup = new DefaultEventLoopGroup(1);
1113         EventLoop eventLoop1 = defaultGroup.next();
1114         final Promise&lt;Throwable&gt; promise = eventLoop1.newPromise();
1115         final Exception exception = new IllegalArgumentException();
1116         try {
1117             eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
1118             pipeline1.addLast(new ChannelDuplexHandler() {
1119                 @Override
1120                 public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
1121                     throw exception;
1122                 }
1123                 @Override
1124                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
1125                     promise.setSuccess(cause);
1126                 }
1127             });
1128             pipeline1.write("test", pipeline1.voidPromise());
1129             assertSame(exception, promise.syncUninterruptibly().getNow());
1130         } finally {
1131             pipeline1.channel().close().syncUninterruptibly();
1132             defaultGroup.shutdownGracefully();
1133         }
1134     }
1135     @Test
1136     public void testHandlerRemovedOnlyCalledWhenHandlerAddedCalled() throws Exception {
1137         EventLoopGroup group = new DefaultEventLoopGroup(1);
1138         try {
1139             final AtomicReference&lt;Error&gt; errorRef = new AtomicReference&lt;Error&gt;();
1140             for (int i = 0; i &lt; 500; i++) {
1141                 ChannelPipeline pipeline = new LocalChannel().pipeline();
1142                 group.register(pipeline.channel()).sync();
1143                 final CountDownLatch latch = new CountDownLatch(1);
1144                 pipeline.addLast(new ChannelInboundHandlerAdapter() {
1145                     @Override
1146                     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
1147                         latch.await(50, TimeUnit.MILLISECONDS);
1148                     }
1149                 });
1150                 pipeline.close();
1151                 pipeline.addLast(new ChannelInboundHandlerAdapter() {
1152                     private boolean handerAddedCalled;
1153                     @Override
1154                     public void handlerAdded(ChannelHandlerContext ctx) {
1155                         handerAddedCalled = true;
1156                     }
1157                     @Override
1158                     public void handlerRemoved(ChannelHandlerContext ctx) {
1159                         if (!handerAddedCalled) {
1160                             errorRef.set(new AssertionError(
1161                                     "handlerRemoved(...) called without handlerAdded(...) before"));
1162                         }
1163                     }
1164                 });
1165                 latch.countDown();
1166                 pipeline.channel().closeFuture().syncUninterruptibly();
1167                 pipeline.channel().eventLoop().submit(new Runnable() {
1168                     @Override
1169                     public void run() {
1170                     }
1171                 }).syncUninterruptibly();
1172                 Error error = errorRef.get();
1173                 if (error != null) {
1174                     throw error;
1175                 }
1176             }
1177         } finally {
1178             group.shutdownGracefully();
1179         }
1180     }
1181     @Test
1182     public void testSkipHandlerMethodsIfAnnotated() {
1183         EmbeddedChannel channel = new EmbeddedChannel(true);
1184         ChannelPipeline pipeline = channel.pipeline();
1185         final class SkipHandler implements ChannelInboundHandler, ChannelOutboundHandler {
1186             private int state = 2;
1187             private Error errorRef;
1188             private void fail() {
1189                 errorRef = new AssertionError("Method should never been called");
1190             }
1191             @Skip
1192             @Override
1193             public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
1194                 fail();
1195                 ctx.bind(localAddress, promise);
1196             }
1197             @Skip
1198             @Override
1199             public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
1200                                 SocketAddress localAddress, ChannelPromise promise) {
1201                 fail();
1202                 ctx.connect(remoteAddress, localAddress, promise);
1203             }
1204             @Skip
1205             @Override
1206             public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
1207                 fail();
1208                 ctx.disconnect(promise);
1209             }
1210             @Skip
1211             @Override
1212             public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
1213                 fail();
1214                 ctx.close(promise);
1215             }
1216             @Skip
1217             @Override
1218             public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {
1219                 fail();
1220                 ctx.deregister(promise);
1221             }
1222             @Skip
1223             @Override
1224             public void read(ChannelHandlerContext ctx) {
1225                 fail();
1226                 ctx.read();
1227             }
1228             @Skip
1229             @Override
1230             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
1231                 fail();
1232                 ctx.write(msg, promise);
1233             }
1234             @Skip
1235             @Override
1236             public void flush(ChannelHandlerContext ctx) {
1237                 fail();
1238                 ctx.flush();
1239             }
1240             @Skip
1241             @Override
1242             public void channelRegistered(ChannelHandlerContext ctx) {
1243                 fail();
1244                 ctx.fireChannelRegistered();
1245             }
1246             @Skip
1247             @Override
1248             public void channelUnregistered(ChannelHandlerContext ctx) {
1249                 fail();
1250                 ctx.fireChannelUnregistered();
1251             }
1252             @Skip
1253             @Override
1254             public void channelActive(ChannelHandlerContext ctx) {
1255                 fail();
1256                 ctx.fireChannelActive();
1257             }
1258             @Skip
1259             @Override
1260             public void channelInactive(ChannelHandlerContext ctx) {
1261                 fail();
1262                 ctx.fireChannelInactive();
1263             }
1264             @Skip
1265             @Override
1266             public void channelRead(ChannelHandlerContext ctx, Object msg) {
1267                 fail();
1268                 ctx.fireChannelRead(msg);
1269             }
1270             @Skip
1271             @Override
1272             public void channelReadComplete(ChannelHandlerContext ctx) {
1273                 fail();
1274                 ctx.fireChannelReadComplete();
1275             }
1276             @Skip
1277             @Override
1278             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1279                 fail();
1280                 ctx.fireUserEventTriggered(evt);
1281             }
1282             @Skip
1283             @Override
1284             public void channelWritabilityChanged(ChannelHandlerContext ctx) {
1285                 fail();
1286                 ctx.fireChannelWritabilityChanged();
1287             }
1288             @Skip
1289             @Override
1290             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
1291                 fail();
1292                 ctx.fireExceptionCaught(cause);
1293             }
1294             @Override
1295             public void handlerAdded(ChannelHandlerContext ctx) {
1296                 state--;
1297             }
1298             @Override
1299             public void handlerRemoved(ChannelHandlerContext ctx) {
1300                 state--;
1301             }
1302             void assertSkipped() {
1303                 assertEquals(0, state);
1304                 Error error = errorRef;
1305                 if (error != null) {
1306                     throw error;
1307                 }
1308             }
1309         }
1310         final class OutboundCalledHandler extends ChannelOutboundHandlerAdapter {
1311             private static final int MASK_BIND = 1;
1312             private static final int MASK_CONNECT = 1 &lt;&lt; 1;
1313             private static final int MASK_DISCONNECT = 1 &lt;&lt; 2;
1314             private static final int MASK_CLOSE = 1 &lt;&lt; 3;
1315             private static final int MASK_DEREGISTER = 1 &lt;&lt; 4;
1316             private static final int MASK_READ = 1 &lt;&lt; 5;
1317             private static final int MASK_WRITE = 1 &lt;&lt; 6;
1318             private static final int MASK_FLUSH = 1 &lt;&lt; 7;
1319             private static final int MASK_ADDED = 1 &lt;&lt; 8;
1320             private static final int MASK_REMOVED = 1 &lt;&lt; 9;
1321             private int executionMask;
1322             @Override
1323             public void handlerAdded(ChannelHandlerContext ctx) {
1324                 executionMask |= MASK_ADDED;
1325             }
1326 <a name="25"></a>            @Override
1327             public void handlerRemoved(ChannelHandlerContext ctx) {
1328                 executionMask |= MASK_REMOVED;
1329             <font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1330             @Override
1331             public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
1332                 executionMask |= MASK_BIND;
1333                 promise.setSuccess</b></font>();
1334             }
1335             @Override
1336 <a name="19"></a>            public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
1337                                 SocketAddress localAddress, ChannelPromise promise) {
1338                 executionMask |= MASK_CONNECT;
1339                 <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>promise.setSuccess();
1340             }
1341             @Override
1342             public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
1343                 executionMask |= MASK_DISCONNECT;
1344                 promise.setSuccess</b></font>();
1345             }
1346 <a name="17"></a>            @Override
1347             public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
1348                 executionMask |= MASK_CLOSE;
1349                 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>promise.setSuccess();
1350             }
1351             @Override
1352             public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {
1353                 executionMask |= MASK_DEREGISTER;
1354                 promise.setSuccess</b></font>();
1355             }
1356 <a name="18"></a>            @Override
1357             public void read(ChannelHandlerContext ctx) {
1358                 executionMask |= MASK_READ;
1359             <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1360             @Override
1361             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
1362                 executionMask |= MASK_WRITE;
1363                 promise.setSuccess</b></font>();
1364             }
1365             @Override
1366             public void flush(ChannelHandlerContext ctx) {
1367 <a name="14"></a>                executionMask |= MASK_FLUSH;
1368             }
1369             void assertCalled() <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1370                 assertCalled("handlerAdded", MASK_ADDED);
1371                 assertCalled("handlerRemoved", MASK_REMOVED);
1372                 assertCalled("bind", MASK_BIND);
1373                 assertCalled("connect", MASK_CONNECT);
1374                 assertCalled("disconnect", MASK_DISCONNECT);
1375                 assertCalled("close", MASK_CLOSE);
1376                 assertCalled("deregister", MASK_DEREGISTER);
1377                 assertCalled("read", MASK_READ);
1378                 assertCalled</b></font>("write", MASK_WRITE);
1379                 assertCalled("flush", MASK_FLUSH);
1380             }
1381             private void assertCalled(String methodName, int mask) {
1382                 assertTrue((executionMask &amp; mask) != 0, methodName + " was not called");
1383             }
1384         }
1385         final class InboundCalledHandler extends ChannelInboundHandlerAdapter {
1386             private static final int MASK_CHANNEL_REGISTER = 1;
1387             private static final int MASK_CHANNEL_UNREGISTER = 1 &lt;&lt; 1;
1388             private static final int MASK_CHANNEL_ACTIVE = 1 &lt;&lt; 2;
1389             private static final int MASK_CHANNEL_INACTIVE = 1 &lt;&lt; 3;
1390             private static final int MASK_CHANNEL_READ = 1 &lt;&lt; 4;
1391             private static final int MASK_CHANNEL_READ_COMPLETE = 1 &lt;&lt; 5;
1392             private static final int MASK_USER_EVENT_TRIGGERED = 1 &lt;&lt; 6;
1393             private static final int MASK_CHANNEL_WRITABILITY_CHANGED = 1 &lt;&lt; 7;
1394             private static final int MASK_EXCEPTION_CAUGHT = 1 &lt;&lt; 8;
1395             private static final int MASK_ADDED = 1 &lt;&lt; 9;
1396             private static final int MASK_REMOVED = 1 &lt;&lt; 10;
1397             private int executionMask;
1398             @Override
1399             public void handlerAdded(ChannelHandlerContext ctx) {
1400                 executionMask |= MASK_ADDED;
1401             }
1402             @Override
1403             public void handlerRemoved(ChannelHandlerContext ctx) {
1404                 executionMask |= MASK_REMOVED;
1405             }
1406             @Override
1407             public void channelRegistered(ChannelHandlerContext ctx) {
1408                 executionMask |= MASK_CHANNEL_REGISTER;
1409             }
1410             @Override
1411             public void channelUnregistered(ChannelHandlerContext ctx) {
1412                 executionMask |= MASK_CHANNEL_UNREGISTER;
1413             }
1414             @Override
1415             public void channelActive(ChannelHandlerContext ctx) {
1416                 executionMask |= MASK_CHANNEL_ACTIVE;
1417             }
1418             @Override
1419             public void channelInactive(ChannelHandlerContext ctx) {
1420                 executionMask |= MASK_CHANNEL_INACTIVE;
1421             }
1422             @Override
1423             public void channelRead(ChannelHandlerContext ctx, Object msg) {
1424                 executionMask |= MASK_CHANNEL_READ;
1425             }
1426             @Override
1427             public void channelReadComplete(ChannelHandlerContext ctx) {
1428                 executionMask |= MASK_CHANNEL_READ_COMPLETE;
1429             }
1430             @Override
1431             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1432                 executionMask |= MASK_USER_EVENT_TRIGGERED;
1433             }
1434             @Override
1435             public void channelWritabilityChanged(ChannelHandlerContext ctx) {
1436                 executionMask |= MASK_CHANNEL_WRITABILITY_CHANGED;
1437             }
1438             @Override
1439             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
1440 <a name="13"></a>                executionMask |= MASK_EXCEPTION_CAUGHT;
1441             }
1442             void assertCalled() <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1443                 assertCalled("handlerAdded", MASK_ADDED);
1444                 assertCalled("handlerRemoved", MASK_REMOVED);
1445                 assertCalled("channelRegistered", MASK_CHANNEL_REGISTER);
1446                 assertCalled("channelUnregistered", MASK_CHANNEL_UNREGISTER);
1447                 assertCalled("channelActive", MASK_CHANNEL_ACTIVE);
1448                 assertCalled("channelInactive", MASK_CHANNEL_INACTIVE);
1449                 assertCalled("channelRead", MASK_CHANNEL_READ);
1450                 assertCalled("channelReadComplete", MASK_CHANNEL_READ_COMPLETE);
1451                 assertCalled</b></font>("userEventTriggered", MASK_USER_EVENT_TRIGGERED);
1452                 assertCalled("channelWritabilityChanged", MASK_CHANNEL_WRITABILITY_CHANGED);
1453                 assertCalled("exceptionCaught", MASK_EXCEPTION_CAUGHT);
1454             }
1455             private void assertCalled(String methodName, int mask) {
1456                 assertTrue((executionMask &amp; mask) != 0, methodName + " was not called");
1457             }
1458         }
1459         OutboundCalledHandler outboundCalledHandler = new OutboundCalledHandler();
1460         SkipHandler skipHandler = new SkipHandler();
1461         InboundCalledHandler inboundCalledHandler = new InboundCalledHandler();
1462         pipeline.addLast(outboundCalledHandler, skipHandler, inboundCalledHandler);
1463         pipeline.fireChannelRegistered();
1464         pipeline.fireChannelUnregistered();
1465         pipeline.fireChannelActive();
1466         pipeline.fireChannelInactive();
1467         pipeline.fireChannelRead("");
1468         pipeline.fireChannelReadComplete();
1469         pipeline.fireChannelWritabilityChanged();
1470         pipeline.fireUserEventTriggered("");
1471         pipeline.fireExceptionCaught(new Exception());
1472         pipeline.deregister().syncUninterruptibly();
1473         pipeline.bind(new SocketAddress() {
1474         }).syncUninterruptibly();
1475         pipeline.connect(new SocketAddress() {
1476         }).syncUninterruptibly();
1477         pipeline.disconnect().syncUninterruptibly();
1478         pipeline.close().syncUninterruptibly();
1479         pipeline.write("");
1480         pipeline.flush();
1481         pipeline.read();
1482         pipeline.remove(outboundCalledHandler);
1483         pipeline.remove(inboundCalledHandler);
1484         pipeline.remove(skipHandler);
1485         assertFalse(channel.finish());
1486         outboundCalledHandler.assertCalled();
1487         inboundCalledHandler.assertCalled();
1488         skipHandler.assertSkipped();
1489     }
1490     @Test
1491     public void testWriteThrowsReleaseMessage() {
1492         testWriteThrowsReleaseMessage0(false);
1493     }
1494     @Test
1495     public void testWriteAndFlushThrowsReleaseMessage() {
1496         testWriteThrowsReleaseMessage0(true);
1497     }
1498     private void testWriteThrowsReleaseMessage0(boolean flush) {
1499         ReferenceCounted referenceCounted = new AbstractReferenceCounted() {
1500             @Override
1501             protected void deallocate() {
1502             }
1503             @Override
1504             public ReferenceCounted touch(Object hint) {
1505                 return this;
1506             }
1507         };
1508         assertEquals(1, referenceCounted.refCnt());
1509         Channel channel = new LocalChannel();
1510         Channel channel2 = new LocalChannel();
1511         group.register(channel).syncUninterruptibly();
1512         group.register(channel2).syncUninterruptibly();
1513         try {
1514             if (flush) {
1515                 channel.writeAndFlush(referenceCounted, channel2.newPromise());
1516             } else {
1517                 channel.write(referenceCounted, channel2.newPromise());
1518             }
1519             fail();
1520         } catch (IllegalArgumentException expected) {
1521         }
1522         assertEquals(0, referenceCounted.refCnt());
1523         channel.close().syncUninterruptibly();
1524         channel2.close().syncUninterruptibly();
1525     }
1526     @Test
1527     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
1528     public void testHandlerAddedFailedButHandlerStillRemoved() throws InterruptedException {
1529         testHandlerAddedFailedButHandlerStillRemoved0(false);
1530     }
1531     @Test
1532     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
1533     public void testHandlerAddedFailedButHandlerStillRemovedWithLaterRegister() throws InterruptedException {
1534         testHandlerAddedFailedButHandlerStillRemoved0(true);
1535     }
1536     private static void testHandlerAddedFailedButHandlerStillRemoved0(boolean lateRegister)
1537             throws InterruptedException {
1538         EventExecutorGroup executorGroup = new DefaultEventExecutorGroup(16);
1539         final int numHandlers = 32;
1540         try {
1541             Channel channel = new LocalChannel();
1542             channel.config().setOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP, false);
1543             if (!lateRegister) {
1544                 group.register(channel).sync();
1545             }
1546             channel.pipeline().addFirst(newHandler());
1547             List&lt;CountDownLatch&gt; latchList = new ArrayList&lt;CountDownLatch&gt;(numHandlers);
1548             for (int i = 0; i &lt; numHandlers; i++) {
1549                 CountDownLatch latch = new CountDownLatch(1);
1550                 channel.pipeline().addFirst(executorGroup, "h" + i, new BadChannelHandler(latch));
1551                 latchList.add(latch);
1552             }
1553             if (lateRegister) {
1554                 group.register(channel).sync();
1555             }
1556             for (int i = 0; i &lt; numHandlers; i++) {
1557                 latchList.get(i).await();
1558                 assertNull(channel.pipeline().get("h" + i));
1559             }
1560         } finally {
1561             executorGroup.shutdownGracefully();
1562         }
1563     }
1564 <a name="9"></a>    private static final class BadChannelHandler extends ChannelHandlerAdapter {
1565         private final CountDownLatch latch;
1566         <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BadChannelHandler(CountDownLatch latch) {
1567             this.latch = latch;
1568         }
1569         @Override
1570         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
1571             TimeUnit.MILLISECONDS.sleep</b></font>(10);
1572             throw new RuntimeException();
1573         }
1574         @Override
1575         public void handlerRemoved(ChannelHandlerContext ctx) {
1576             latch.countDown();
1577         }
1578     }
1579     @Test
1580     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
1581     public void handlerAddedStateUpdatedBeforeHandlerAddedDoneForceEventLoop() throws InterruptedException {
1582         handlerAddedStateUpdatedBeforeHandlerAddedDone(true);
1583     }
1584     @Test
1585     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
1586     public void handlerAddedStateUpdatedBeforeHandlerAddedDoneOnCallingThread() throws InterruptedException {
1587         handlerAddedStateUpdatedBeforeHandlerAddedDone(false);
1588     }
1589     private static void handlerAddedStateUpdatedBeforeHandlerAddedDone(boolean executeInEventLoop)
1590             throws InterruptedException {
1591         final ChannelPipeline pipeline = new LocalChannel().pipeline();
1592         final Object userEvent = new Object();
1593         final Object writeObject = new Object();
1594         final CountDownLatch doneLatch = new CountDownLatch(1);
1595         group.register(pipeline.channel());
1596         Runnable r = new Runnable() {
1597             @Override
1598             public void run() {
1599                 pipeline.addLast(new ChannelInboundHandlerAdapter() {
1600                     @Override
1601                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1602                         if (evt == userEvent) {
1603                             ctx.write(writeObject);
1604                         }
1605                         ctx.fireUserEventTriggered(evt);
1606                     }
1607                 });
1608 <a name="22"></a>                pipeline.addFirst(new ChannelDuplexHandler() {
1609                     @Override
1610                     public void handlerAdded(ChannelHandlerContext ctx) {
1611                         <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ctx.fireUserEventTriggered(userEvent);
1612                     }
1613                     @Override
1614                     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {</b></font>
1615                         if (msg == writeObject) {
1616                             doneLatch.countDown();
1617                         }
1618                         ctx.write(msg, promise);
1619                     }
1620                 });
1621             }
1622         };
1623         if (executeInEventLoop) {
1624             pipeline.channel().eventLoop().execute(r);
1625         } else {
1626             r.run();
1627         }
1628         doneLatch.await();
1629     }
1630     private static final class TestTask implements Runnable {
1631         private final ChannelPipeline pipeline;
1632         private final CountDownLatch latch;
1633         TestTask(ChannelPipeline pipeline, CountDownLatch latch) {
1634             this.pipeline = pipeline;
1635             this.latch = latch;
1636         }
1637         @Override
1638         public void run() {
1639             pipeline.addLast(new ChannelInboundHandlerAdapter());
1640             latch.countDown();
1641         }
1642     }
1643     private static final class CallbackCheckHandler extends ChannelHandlerAdapter {
1644         final Promise&lt;Boolean&gt; addedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
1645         final Promise&lt;Boolean&gt; removedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
1646         final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
1647         @Override
1648         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
1649             if (!addedHandler.trySuccess(true)) {
1650                 error.set(new AssertionError("handlerAdded(...) called multiple times: " + ctx.name()));
1651             } else if (removedHandler.getNow() == Boolean.TRUE) {
1652                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
1653             }
1654         }
1655         @Override
1656         public void handlerRemoved(ChannelHandlerContext ctx) {
1657             if (!removedHandler.trySuccess(true)) {
1658                 error.set(new AssertionError("handlerRemoved(...) called multiple times: " + ctx.name()));
1659             } else if (addedHandler.getNow() == Boolean.FALSE) {
1660                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
1661             }
1662         }
1663     }
1664     private static final class CheckExceptionHandler extends ChannelInboundHandlerAdapter {
1665         private final Throwable expected;
1666         private final Promise&lt;Void&gt; promise;
1667         CheckExceptionHandler(Throwable expected, Promise&lt;Void&gt; promise) {
1668             this.expected = expected;
1669             this.promise = promise;
1670         }
1671         @Override
1672         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1673             if (cause instanceof ChannelPipelineException &amp;&amp; cause.getCause() == expected) {
1674                 promise.setSuccess(null);
1675             } else {
1676                 promise.setFailure(new AssertionError("cause not the expected instance"));
1677             }
1678         }
1679     }
1680     private static void assertHandler(CheckOrderHandler actual, CheckOrderHandler... handlers) throws Throwable {
1681         for (CheckOrderHandler h : handlers) {
1682             if (h == actual) {
1683                 actual.checkError();
1684                 return;
1685             }
1686         }
1687         fail("handler was not one of the expected handlers");
1688     }
1689     private static final class CheckOrderHandler extends ChannelHandlerAdapter {
1690         private final Queue&lt;CheckOrderHandler&gt; addedQueue;
1691         private final Queue&lt;CheckOrderHandler&gt; removedQueue;
1692         private final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
1693         CheckOrderHandler(Queue&lt;CheckOrderHandler&gt; addedQueue, Queue&lt;CheckOrderHandler&gt; removedQueue) {
1694             this.addedQueue = addedQueue;
1695             this.removedQueue = removedQueue;
1696         }
1697         @Override
1698         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
1699             addedQueue.add(this);
1700             checkExecutor(ctx);
1701         }
1702 <a name="12"></a>
1703         @Override
1704         public void handlerRemoved(ChannelHandlerContext ctx) {
1705             <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>removedQueue.add(this);
1706             checkExecutor(ctx);
1707         }
1708         @Override
1709         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1710             error.set</b></font>(cause);
1711         }
1712         void checkError() throws Throwable {
1713             Throwable cause = error.get();
1714             if (cause != null) {
1715                 throw cause;
1716             }
1717         }
1718         private void checkExecutor(ChannelHandlerContext ctx) {
1719             if (!ctx.executor().inEventLoop()) {
1720                 error.set(new AssertionError());
1721             }
1722         }
1723     }
1724     private static final class CheckEventExecutorHandler extends ChannelHandlerAdapter {
1725         final EventExecutor executor;
1726         final Promise&lt;Void&gt; addedPromise;
1727         final Promise&lt;Void&gt; removedPromise;
1728         CheckEventExecutorHandler(EventExecutor executor) {
1729             this.executor = executor;
1730             addedPromise = executor.newPromise();
1731             removedPromise = executor.newPromise();
1732         }
1733         @Override
1734         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
1735             assertExecutor(ctx, addedPromise);
1736         }
1737         @Override
1738         public void handlerRemoved(ChannelHandlerContext ctx) {
1739             assertExecutor(ctx, removedPromise);
1740         }
1741         private void assertExecutor(ChannelHandlerContext ctx, Promise&lt;Void&gt; promise) {
1742             final boolean same;
1743             try {
1744                 same = executor == ctx.executor();
1745             } catch (Throwable cause) {
1746                 promise.setFailure(cause);
1747                 return;
1748             }
1749             if (same) {
1750                 promise.setSuccess(null);
1751             } else {
1752                 promise.setFailure(new AssertionError("EventExecutor not the same"));
1753             }
1754         }
1755     }
1756     private static final class ErrorChannelHandler extends ChannelHandlerAdapter {
1757         private final AtomicReference&lt;Throwable&gt; error;
1758         ErrorChannelHandler(AtomicReference&lt;Throwable&gt; error) {
1759             this.error = error;
1760         }
1761         @Override
1762         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
1763             error.set(new AssertionError());
1764         }
1765         @Override
1766         public void handlerRemoved(ChannelHandlerContext ctx) {
1767             error.set(new AssertionError());
1768         }
1769     }
1770     private static int next(AbstractChannelHandlerContext ctx) {
1771         AbstractChannelHandlerContext next = ctx.next;
1772         if (next == null) {
1773             return Integer.MAX_VALUE;
1774         }
1775         return toInt(next.name());
1776     }
1777     private static int toInt(String name) {
1778         try {
1779             return Integer.parseInt(name);
1780         } catch (NumberFormatException e) {
1781             return -1;
1782         }
1783     }
1784     private static void verifyContextNumber(ChannelPipeline pipeline, int expectedNumber) {
1785         AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
1786         int handlerNumber = 0;
1787         while (ctx != ((DefaultChannelPipeline) pipeline).tail) {
1788             handlerNumber++;
1789             ctx = ctx.next;
1790         }
1791         assertEquals(expectedNumber, handlerNumber);
1792     }
1793     private static ChannelHandler[] newHandlers(int num) {
1794         assert num &gt; 0;
1795         ChannelHandler[] handlers = new ChannelHandler[num];
1796         for (int i = 0; i &lt; num; i++) {
1797             handlers[i] = newHandler();
1798         }
1799         return handlers;
1800     }
1801     private static ChannelHandler newHandler() {
1802         return new TestHandler();
1803     }
1804     @Sharable
1805     private static class TestHandler extends ChannelDuplexHandler { }
1806     private static class BufferedTestHandler extends ChannelDuplexHandler {
1807         final Queue&lt;Object&gt; inboundBuffer = new ArrayDeque&lt;Object&gt;();
1808         final Queue&lt;Object&gt; outboundBuffer = new ArrayDeque&lt;Object&gt;();
1809         @Override
1810         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
1811             outboundBuffer.add(msg);
1812         }
1813         @Override
1814         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
1815             inboundBuffer.add(msg);
1816         }
1817         @Override
1818         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
1819             if (!inboundBuffer.isEmpty()) {
1820                 for (Object o: inboundBuffer) {
1821                     ctx.fireChannelRead(o);
1822                 }
1823                 ctx.fireChannelReadComplete();
1824             }
1825             if (!outboundBuffer.isEmpty()) {
1826                 for (Object o: outboundBuffer) {
1827                     ctx.write(o);
1828                 }
1829                 ctx.flush();
1830             }
1831         }
1832     }
1833     private static final class LifeCycleAwareTestHandler extends ChannelHandlerAdapter {
1834         private final String name;
1835         private boolean afterAdd;
1836         private boolean afterRemove;
1837         private LifeCycleAwareTestHandler(String name) {
1838             this.name = name;
1839         }
1840         public void validate(boolean afterAdd, boolean afterRemove) {
1841             assertEquals(afterAdd, this.afterAdd, name);
1842             assertEquals(afterRemove, this.afterRemove, name);
1843         }
1844         @Override
1845         public void handlerAdded(ChannelHandlerContext ctx) {
1846             validate(false, false);
1847             afterAdd = true;
1848         }
1849         @Override
1850         public void handlerRemoved(ChannelHandlerContext ctx) {
1851             validate(true, false);
1852             afterRemove = true;
1853         }
1854     }
1855     private static final class WrapperExecutor extends AbstractEventExecutor {
1856         private final ExecutorService wrapped = Executors.newSingleThreadExecutor();
1857 <a name="20"></a>
1858         @Override
1859         public boolean isShuttingDown() {
1860             return <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>wrapped.isShutdown();
1861         }
1862         @Override
1863         public Future&lt;?&gt; shutdownGracefully(long l, long l2, TimeUnit timeUnit) {</b></font>
1864             throw new IllegalStateException();
1865         }
1866         @Override
1867         public Future&lt;?&gt; terminationFuture() {
1868             throw new IllegalStateException();
1869         }
1870         @Override
1871         public void shutdown() {
1872             wrapped.shutdown();
1873         }
1874         @Override
1875         public List&lt;Runnable&gt; shutdownNow() {
1876             return wrapped.shutdownNow();
1877         }
1878         @Override
1879         public boolean isShutdown() {
1880             return wrapped.isShutdown();
1881         }
1882         @Override
1883         public boolean isTerminated() {
1884             return wrapped.isTerminated();
1885         }
1886         @Override
1887         public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
1888             return wrapped.awaitTermination(timeout, unit);
1889         }
1890         @Override
1891         public EventExecutorGroup parent() {
1892             return null;
1893         }
1894         @Override
1895         public boolean inEventLoop(Thread thread) {
1896             return false;
1897         }
1898         @Override
1899         public void execute(Runnable command) {
1900             wrapped.execute(command);
1901         }
1902     }
1903 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
