<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ImmutableList.java & ArbitraryInstances_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ImmutableList.java & ArbitraryInstances_1.java
      </h3>
      <h1 align="center">
        5.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ImmutableList.java (5.631399%)<TH>ArbitraryInstances_1.java (4.962406%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1338428-0.html#0',2,'match1338428-1.html#0',3)" NAME="0">(19-39)<TD><A HREF="javascript:ZweiFrames('match1338428-0.html#0',2,'match1338428-1.html#0',3)" NAME="0">(133-169)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1338428-0.html#1',2,'match1338428-1.html#1',3)" NAME="1">(265-272)<TD><A HREF="javascript:ZweiFrames('match1338428-0.html#1',2,'match1338428-1.html#1',3)" NAME="1">(487-494)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1338428-0.html#2',2,'match1338428-1.html#2',3)" NAME="2">(126-129)<TD><A HREF="javascript:ZweiFrames('match1338428-0.html#2',2,'match1338428-1.html#2',3)" NAME="2">(410-413)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableList.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.collect;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1338428-1.html#0',3,'match1338428-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ObjectArrays.checkElementsNotNull;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.RandomAccess;
import java.util.stream.Collector;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * GWT emulated version of {@link com.google.common.collect.ImmutableList}. TODO(cpovirk): more doc
 *
 * @author Hayward Chan
 */
@</B></FONT>SuppressWarnings(&quot;serial&quot;) // we're overriding default serialization
public abstract class ImmutableList&lt;E&gt; extends ImmutableCollection&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess {
  static final ImmutableList&lt;Object&gt; EMPTY =
      new RegularImmutableList&lt;Object&gt;(Collections.emptyList());

  ImmutableList() {}

  public static &lt;E&gt; Collector&lt;E, ?, ImmutableList&lt;E&gt;&gt; toImmutableList() {
    return CollectCollectors.toImmutableList();
  }

  // Casting to any type is safe because the list will never hold any elements.
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E&gt; ImmutableList&lt;E&gt; of() {
    return (ImmutableList&lt;E&gt;) EMPTY;
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) {
    return new SingletonImmutableList&lt;E&gt;(checkNotNull(element));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {
    final int paramCount = 12;
    Object[] array = new Object[paramCount + others.length];
    arrayCopy(array, 0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12);
    arrayCopy(array, paramCount, others);
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(array));
  }

  private static void arrayCopy(Object[] dest, int pos, Object... source) {
    System.arraycopy(source, 0, dest, pos, source.length);
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
    checkNotNull(elements); // for GWT
<A NAME="2"></A>    return (elements instanceof Collection)
        ? copyOf((Collection&lt;? extends E&gt;) elements)
        : copyOf(elements.iterator());
  <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1338428-1.html#2',3,'match1338428-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
    return copyFromCollection(Lists.newArrayList</B></FONT>(elements));
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
    if (elements instanceof ImmutableCollection) {
      /*
       * TODO: When given an ImmutableList that's a sublist, copy the referenced
       * portion of the array into a new array to save space?
       */
      @SuppressWarnings(&quot;unchecked&quot;) // all supported methods are covariant
      ImmutableCollection&lt;E&gt; list = (ImmutableCollection&lt;E&gt;) elements;
      return list.asList();
    }
    return copyFromCollection(elements);
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(E[] elements) {
    checkNotNull(elements); // eager for GWT
    return copyOf(Arrays.asList(elements));
  }

  private static &lt;E&gt; ImmutableList&lt;E&gt; copyFromCollection(Collection&lt;? extends E&gt; collection) {
    Object[] elements = collection.toArray();
    switch (elements.length) {
      case 0:
        return of();
      case 1:
        return of((E) elements[0]);
      default:
        return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(elements));
    }
  }

  // Factory method that skips the null checks.  Used only when the elements
  // are guaranteed to be non-null.
  static &lt;E&gt; ImmutableList&lt;E&gt; unsafeDelegateList(List&lt;? extends E&gt; list) {
    switch (list.size()) {
      case 0:
        return of();
      case 1:
        return of(list.get(0));
      default:
        @SuppressWarnings(&quot;unchecked&quot;)
        List&lt;E&gt; castedList = (List&lt;E&gt;) list;
        return new RegularImmutableList&lt;E&gt;(castedList);
    }
  }

  /**
   * Views the array as an immutable list. The array must have only {@code E} elements.
   *
   * &lt;p&gt;The array must be internally created.
   */
  @SuppressWarnings(&quot;unchecked&quot;) // caller is reponsible for getting this right
  static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements) {
    return unsafeDelegateList((List) Arrays.asList(elements));
  }

  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableList&lt;E&gt; sortedCopyOf(
      Iterable&lt;? extends E&gt; elements) {
    Comparable[] array = Iterables.toArray(elements, new Comparable[0]);
    checkElementsNotNull(array);
    Arrays.sort(array);
    return asImmutableList(array);
  }

  public static &lt;E&gt; ImmutableList&lt;E&gt; sortedCopyOf(
      Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
    checkNotNull(comparator);
    @SuppressWarnings(&quot;unchecked&quot;) // all supported methods are covariant
    E[] array = (E[]) Iterables.toArray(elements);
    checkElementsNotNull(array);
    Arrays.sort(array, comparator);
    return asImmutableList(array);
  }

  private static &lt;E&gt; List&lt;E&gt; nullCheckedList(Object... array) {
    for (int i = 0, len = array.length; i &lt; len; i++) {
      if (array[i] == null) {
        throw new NullPointerException(&quot;at index &quot; + i);
      }
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    E[] castedArray = (E[]) array;
    return Arrays.asList(castedArray);
  }

  @Override
  public int indexOf(@Nullable Object object) {
    return (object == null) ? -1 : Lists.indexOfImpl(this, object);
  }

  @Override
  public int lastIndexOf(@Nullable Object object) {
    return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object);
  }

  public final boolean addAll(int index, Collection&lt;? extends E&gt; newElements) {
    throw new UnsupportedOperationException();
  }

  public final E set(int index, E element) {
    throw new UnsupportedOperationException();
  }

  public final void add(int index, E element) {
    throw new UnsupportedOperationException();
  }

  public final E remove(int index) {
    throw new UnsupportedOperationException();
  }

  @Override
  public UnmodifiableIterator&lt;E&gt; iterator() {
    return listIterator();
  }

  @Override
  public ImmutableList&lt;E&gt; subList(int fromIndex, int toIndex) {
    return unsafeDelegateList(Lists.subListImpl(this, fromIndex, toIndex));
  }

  @Override
  public UnmodifiableListIterator&lt;E&gt; listIterator() {
    return listIterator(0);
  }

  @Override
  public UnmodifiableListIterator&lt;E&gt; listIterator(int index) {
    return new AbstractIndexedListIterator&lt;E&gt;(size(), index) {
      @Override
      protected E get(int index) {
<A NAME="1"></A>        return ImmutableList.this.get(index);
      }
    };
  <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1338428-1.html#1',3,'match1338428-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  @Override
  public ImmutableList&lt;E&gt; asList() {
    return this;
  }

  @Overr</B></FONT>ide
  public boolean equals(@Nullable Object obj) {
    return Lists.equalsImpl(this, obj);
  }

  @Override
  public int hashCode() {
    return Lists.hashCodeImpl(this);
  }

  public ImmutableList&lt;E&gt; reverse() {
    List&lt;E&gt; list = Lists.newArrayList(this);
    Collections.reverse(list);
    return unsafeDelegateList(list);
  }

  public static &lt;E&gt; Builder&lt;E&gt; builder() {
    return new Builder&lt;E&gt;();
  }

  public static &lt;E&gt; Builder&lt;E&gt; builderWithExpectedSize(int expectedSize) {
    return new Builder&lt;E&gt;(expectedSize);
  }

  public static final class Builder&lt;E&gt; extends ImmutableCollection.Builder&lt;E&gt; {
    private final ArrayList&lt;E&gt; contents;

    public Builder() {
      contents = Lists.newArrayList();
    }

    Builder(int capacity) {
      contents = Lists.newArrayListWithCapacity(capacity);
    }

    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E element) {
      contents.add(checkNotNull(element));
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E... elements) {
      checkNotNull(elements); // for GWT
      super.add(elements);
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    @CanIgnoreReturnValue
    Builder&lt;E&gt; combine(Builder&lt;E&gt; builder) {
      checkNotNull(builder);
      contents.addAll(builder.contents);
      return this;
    }

    @Override
    public ImmutableList&lt;E&gt; build() {
      return copyOf(contents);
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ArbitraryInstances_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.testing;

import static com.google.common.base.Preconditions.checkArgument;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.CharMatcher;
import com.google.common.base.Charsets;
import com.google.common.base.Defaults;
import com.google.common.base.Equivalence;
import com.google.common.base.Joiner;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Splitter;
import com.google.common.base.Stopwatch;
import com.google.common.base.Ticker;
import com.google.common.collect.BiMap;
import com.google.common.collect.ClassToInstanceMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableClassToInstanceMap;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Iterators;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.MapDifference;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.collect.PeekingIterator;
import com.google.common.collect.Range;
import com.google.common.collect.RowSortedTable;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.collect.SortedMapDifference;
import com.google.common.collect.SortedMultiset;
import com.google.common.collect.SortedSetMultimap;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import com.google.common.collect.TreeBasedTable;
import com.google.common.collect.TreeMultimap;
import com.google.common.io.ByteSink;
import com.google.common.io.ByteSource;
import com.google.common.io.ByteStreams;
import com.google.common.io.CharSink;
import com.google.common.io.CharSource;
import com.google.common.primitives.Primitives;
import com.google.common.primitives.UnsignedInteger;
import com.google.common.primitives.UnsignedLong;
import com.google.errorprone.annotations.Keep;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import java.nio.charset.Charset;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Currency;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.UUID;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
<A NAME="0"></A>import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentNavigableMap;
import java.util.concurrent.ConcurrentSkipListMap;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1338428-0.html#0',2,'match1338428-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;

/**
 * Supplies an arbitrary &quot;default&quot; instance for a wide range of types, often useful in testing
 * utilities.
 *
 * &lt;p&gt;Covers arrays, enums and common types defined in {@code java.lang}, {@code java.lang.reflect},
 * {@code java.io}, {@code java.nio}, {@code java.math}, {@code java.util}, {@code
 * java.util.concurrent}, {@code java.util.regex}, {@code com.google.common.base}, {@code
 * com.google.common.collect} and {@code com.google.common.primitives}. In addition, if the type
 * exposes at least one public static final constant of the same type, one of the constants will be
 * used; or if the class exposes a public parameter-less constructor then it will be &quot;new&quot;d and
 * returned.
 *
 * &lt;p&gt;All default instances returned by {@link #get} are generics-safe. Clients won't get type
 * errors for using {@code get(Comparator.class)} as a {@code Comparator&lt;Foo&gt;}, for example.
 * Immutable empty instances are returned for collection types; {@code &quot;&quot;} for string; {@code 0} for
 * number types; reasonable default instance for other stateless types. For mutable types, a fresh
 * instance is created each time {@code get()} is called.
 *
 * @author Kevin Bourrillion
 * @author Ben Yu
 * @since 12.0
 */
@</B></FONT>GwtIncompatible
public final class ArbitraryInstances {

  private static final Ordering&lt;Field&gt; BY_FIELD_NAME =
      new Ordering&lt;Field&gt;() {
        @Override
        public int compare(Field left, Field right) {
          return left.getName().compareTo(right.getName());
        }
      };

  /**
   * Returns a new {@code MatchResult} that corresponds to a successful match. Apache Harmony (used
   * in Android) requires a successful match in order to generate a {@code MatchResult}:
   * http://goo.gl/5VQFmC
   */
  private static MatchResult newMatchResult() {
    Matcher matcher = Pattern.compile(&quot;.&quot;).matcher(&quot;X&quot;);
    matcher.find();
    return matcher.toMatchResult();
  }

  private static final ClassToInstanceMap&lt;Object&gt; DEFAULTS =
      ImmutableClassToInstanceMap.builder()
          // primitives
          .put(Object.class, &quot;&quot;)
          .put(Number.class, 0)
          .put(UnsignedInteger.class, UnsignedInteger.ZERO)
          .put(UnsignedLong.class, UnsignedLong.ZERO)
          .put(BigInteger.class, BigInteger.ZERO)
          .put(BigDecimal.class, BigDecimal.ZERO)
          .put(CharSequence.class, &quot;&quot;)
          .put(String.class, &quot;&quot;)
          .put(Pattern.class, Pattern.compile(&quot;&quot;))
          .put(MatchResult.class, newMatchResult())
          .put(TimeUnit.class, TimeUnit.SECONDS)
          .put(Charset.class, Charsets.UTF_8)
          .put(Currency.class, Currency.getInstance(Locale.US))
          .put(Locale.class, Locale.US)
          .put(UUID.class, UUID.randomUUID())
          // common.base
          .put(CharMatcher.class, CharMatcher.none())
          .put(Joiner.class, Joiner.on(','))
          .put(Splitter.class, Splitter.on(','))
          .put(com.google.common.base.Optional.class, com.google.common.base.Optional.absent())
          .put(Predicate.class, Predicates.alwaysTrue())
          .put(Equivalence.class, Equivalence.equals())
          .put(Ticker.class, Ticker.systemTicker())
          .put(Stopwatch.class, Stopwatch.createUnstarted())
          // io types
          .put(InputStream.class, new ByteArrayInputStream(new byte[0]))
          .put(ByteArrayInputStream.class, new ByteArrayInputStream(new byte[0]))
          .put(Readable.class, new StringReader(&quot;&quot;))
          .put(Reader.class, new StringReader(&quot;&quot;))
          .put(StringReader.class, new StringReader(&quot;&quot;))
          .put(Buffer.class, ByteBuffer.allocate(0))
          .put(CharBuffer.class, CharBuffer.allocate(0))
          .put(ByteBuffer.class, ByteBuffer.allocate(0))
          .put(ShortBuffer.class, ShortBuffer.allocate(0))
          .put(IntBuffer.class, IntBuffer.allocate(0))
          .put(LongBuffer.class, LongBuffer.allocate(0))
          .put(FloatBuffer.class, FloatBuffer.allocate(0))
          .put(DoubleBuffer.class, DoubleBuffer.allocate(0))
          .put(File.class, new File(&quot;&quot;))
          .put(ByteSource.class, ByteSource.empty())
          .put(CharSource.class, CharSource.empty())
          .put(ByteSink.class, NullByteSink.INSTANCE)
          .put(CharSink.class, NullByteSink.INSTANCE.asCharSink(Charsets.UTF_8))
          // All collections are immutable empty. So safe for any type parameter.
          .put(Iterator.class, ImmutableSet.of().iterator())
          .put(PeekingIterator.class, Iterators.peekingIterator(ImmutableSet.of().iterator()))
          .put(ListIterator.class, ImmutableList.of().listIterator())
          .put(Iterable.class, ImmutableSet.of())
          .put(Collection.class, ImmutableList.of())
          .put(ImmutableCollection.class, ImmutableList.of())
          .put(List.class, ImmutableList.of())
          .put(ImmutableList.class, ImmutableList.of())
          .put(Set.class, ImmutableSet.of())
          .put(ImmutableSet.class, ImmutableSet.of())
          .put(SortedSet.class, ImmutableSortedSet.of())
          .put(ImmutableSortedSet.class, ImmutableSortedSet.of())
          .put(NavigableSet.class, Sets.unmodifiableNavigableSet(Sets.newTreeSet()))
          .put(Map.class, ImmutableMap.of())
          .put(ImmutableMap.class, ImmutableMap.of())
          .put(SortedMap.class, ImmutableSortedMap.of())
          .put(ImmutableSortedMap.class, ImmutableSortedMap.of())
          .put(NavigableMap.class, Maps.unmodifiableNavigableMap(Maps.newTreeMap()))
          .put(Multimap.class, ImmutableMultimap.of())
          .put(ImmutableMultimap.class, ImmutableMultimap.of())
          .put(ListMultimap.class, ImmutableListMultimap.of())
          .put(ImmutableListMultimap.class, ImmutableListMultimap.of())
          .put(SetMultimap.class, ImmutableSetMultimap.of())
          .put(ImmutableSetMultimap.class, ImmutableSetMultimap.of())
          .put(
              SortedSetMultimap.class,
              Multimaps.unmodifiableSortedSetMultimap(TreeMultimap.create()))
          .put(Multiset.class, ImmutableMultiset.of())
          .put(ImmutableMultiset.class, ImmutableMultiset.of())
          .put(SortedMultiset.class, ImmutableSortedMultiset.of())
          .put(ImmutableSortedMultiset.class, ImmutableSortedMultiset.of())
          .put(BiMap.class, ImmutableBiMap.of())
          .put(ImmutableBiMap.class, ImmutableBiMap.of())
          .put(Table.class, ImmutableTable.of())
          .put(ImmutableTable.class, ImmutableTable.of())
          .put(RowSortedTable.class, Tables.unmodifiableRowSortedTable(TreeBasedTable.create()))
          .put(ClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
          .put(ImmutableClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
          .put(Comparable.class, ByToString.INSTANCE)
          .put(Comparator.class, AlwaysEqual.INSTANCE)
          .put(Ordering.class, AlwaysEqual.INSTANCE)
          .put(Range.class, Range.all())
          .put(MapDifference.class, Maps.difference(ImmutableMap.of(), ImmutableMap.of()))
          .put(
              SortedMapDifference.class,
              Maps.difference(ImmutableSortedMap.of(), ImmutableSortedMap.of()))
          // reflect
          .put(AnnotatedElement.class, Object.class)
          .put(GenericDeclaration.class, Object.class)
          .put(Type.class, Object.class)
          .build();

  /**
   * type â†’ implementation. Inherently mutable interfaces and abstract classes are mapped to their
   * default implementations and are &quot;new&quot;d upon get().
   */
  private static final ConcurrentMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; implementations = Maps.newConcurrentMap();

  private static &lt;T&gt; void setImplementation(Class&lt;T&gt; type, Class&lt;? extends T&gt; implementation) {
    checkArgument(type != implementation, &quot;Don't register %s to itself!&quot;, type);
    checkArgument(
        !DEFAULTS.containsKey(type), &quot;A default value was already registered for %s&quot;, type);
    checkArgument(
        implementations.put(type, implementation) == null,
        &quot;Implementation for %s was already registered&quot;,
        type);
  }

  static {
    setImplementation(Appendable.class, StringBuilder.class);
    setImplementation(BlockingQueue.class, LinkedBlockingDeque.class);
    setImplementation(BlockingDeque.class, LinkedBlockingDeque.class);
    setImplementation(ConcurrentMap.class, ConcurrentHashMap.class);
    setImplementation(ConcurrentNavigableMap.class, ConcurrentSkipListMap.class);
    setImplementation(CountDownLatch.class, Dummies.DummyCountDownLatch.class);
    setImplementation(Deque.class, ArrayDeque.class);
    setImplementation(OutputStream.class, ByteArrayOutputStream.class);
    setImplementation(PrintStream.class, Dummies.InMemoryPrintStream.class);
    setImplementation(PrintWriter.class, Dummies.InMemoryPrintWriter.class);
    setImplementation(Queue.class, ArrayDeque.class);
    setImplementation(Random.class, Dummies.DeterministicRandom.class);
    setImplementation(
        ScheduledThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
    setImplementation(ThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
    setImplementation(Writer.class, StringWriter.class);
    setImplementation(Runnable.class, Dummies.DummyRunnable.class);
    setImplementation(ThreadFactory.class, Dummies.DummyThreadFactory.class);
    setImplementation(Executor.class, Dummies.DummyExecutor.class);
  }

  @SuppressWarnings(&quot;unchecked&quot;) // it's a subtype map
  @CheckForNull
  private static &lt;T&gt; Class&lt;? extends T&gt; getImplementation(Class&lt;T&gt; type) {
    return (Class&lt;? extends T&gt;) implementations.get(type);
  }

  private static final Logger logger = Logger.getLogger(ArbitraryInstances.class.getName());

  /**
   * Returns an arbitrary instance for {@code type}, or {@code null} if no arbitrary instance can be
   * determined.
   */
  @CheckForNull
  public static &lt;T&gt; T get(Class&lt;T&gt; type) {
    T defaultValue = DEFAULTS.getInstance(type);
    if (defaultValue != null) {
      return defaultValue;
    }
    Class&lt;? extends T&gt; implementation = getImplementation(type);
    if (implementation != null) {
      return get(implementation);
    }
    if (type.isEnum()) {
      T[] enumConstants = type.getEnumConstants();
      return (enumConstants.length == 0) ? null : enumConstants[0];
    }
    if (type.isArray()) {
      return createEmptyArray(type);
    }
    T jvmDefault = Defaults.defaultValue(Primitives.unwrap(type));
    if (jvmDefault != null) {
      return jvmDefault;
    }
    if (Modifier.isAbstract(type.getModifiers()) || !Modifier.isPublic(type.getModifiers())) {
      return arbitraryConstantInstanceOrNull(type);
    }
    final Constructor&lt;T&gt; constructor;
    try {
      constructor = type.getConstructor();
    } catch (NoSuchMethodException e) {
      return arbitraryConstantInstanceOrNull(type);
    }
    constructor.setAccessible(true); // accessibility check is too slow
    try {
      return constructor.newInstance();
      /*
       * Do not merge the 2 catch blocks below. javac would infer a type of
       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of
       * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)
       */
    } catch (InstantiationException impossible) {
      throw new AssertionError(impossible);
    } catch (IllegalAccessException impossible) {
      throw new AssertionError(impossible);
    } catch (InvocationTargetException e) {
      logger.log(Level.WARNING, &quot;Exception while invoking default constructor.&quot;, e.getCause());
      return arbitraryConstantInstanceOrNull(type);
    }
  }

  @CheckForNull
  private static &lt;T&gt; T arbitraryConstantInstanceOrNull(Class&lt;T&gt; type) {
    Field[] fields = type.getDeclaredFields();
    Arrays.sort(fields, BY_FIELD_NAME);
    for (Field field : fields) {
      if (Modifier.isPublic(field.getModifiers())
          &amp;&amp; Modifier.isStatic(field.getModifiers())
          &amp;&amp; Modifier.isFinal(field.getModifiers())) {
        if (field.getGenericType() == field.getType() &amp;&amp; type.isAssignableFrom(field.getType())) {
          field.setAccessible(true);
          try {
            T constant = type.cast(field.get(null));
            if (constant != null) {
              return constant;
            }
          } catch (IllegalAccessException impossible) {
            throw new AssertionError(impossible);
          }
        }
<A NAME="2"></A>      }
    }
    return null;
  <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1338428-0.html#2',2,'match1338428-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  private static &lt;T&gt; T createEmptyArray(Class&lt;T&gt; arrayType) {
    return arrayType.cast(Array.newInstance</B></FONT>(arrayType.getComponentType(), 0));
  }

  // Internal implementations of some classes, with public default constructor that get() needs.
  private static final class Dummies {

    public static final class InMemoryPrintStream extends PrintStream {
      public InMemoryPrintStream() {
        super(new ByteArrayOutputStream());
      }
    }

    public static final class InMemoryPrintWriter extends PrintWriter {
      public InMemoryPrintWriter() {
        super(new StringWriter());
      }
    }

    public static final class DeterministicRandom extends Random {
      @Keep
      public DeterministicRandom() {
        super(0);
      }
    }

    public static final class DummyScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {
      public DummyScheduledThreadPoolExecutor() {
        super(1);
      }
    }

    public static final class DummyCountDownLatch extends CountDownLatch {
      public DummyCountDownLatch() {
        super(0);
      }
    }

    public static final class DummyRunnable implements Runnable, Serializable {
      @Override
      public void run() {}
    }

    public static final class DummyThreadFactory implements ThreadFactory, Serializable {
      @Override
      public Thread newThread(Runnable r) {
        return new Thread(r);
      }
    }

    public static final class DummyExecutor implements Executor, Serializable {
      @Override
      public void execute(Runnable command) {}
    }
  }

  private static final class NullByteSink extends ByteSink implements Serializable {
    private static final NullByteSink INSTANCE = new NullByteSink();

    @Override
    public OutputStream openStream() {
      return ByteStreams.nullOutputStream();
    }
  }

  // Compare by toString() to satisfy 2 properties:
  // 1. compareTo(null) should throw NullPointerException
  // 2. the order is deterministic and easy to understand, for debugging purpose.
  @SuppressWarnings(&quot;ComparableType&quot;)
  private static final class ByToString implements Comparable&lt;Object&gt;, Serializable {
    private static final ByToString INSTANCE = new ByToString();

<A NAME="1"></A>    @Override
    public int compareTo(Object o) {
      return toString().compareTo(o.toString());
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1338428-0.html#1',2,'match1338428-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public String toString() {
      return &quot;BY_TO_STRING&quot;;
    }

    private Obj</B></FONT>ect readResolve() {
      return INSTANCE;
    }
  }

  // Always equal is a valid total ordering. And it works for any Object.
  private static final class AlwaysEqual extends Ordering&lt;Object&gt; implements Serializable {
    private static final AlwaysEqual INSTANCE = new AlwaysEqual();

    @Override
    public int compare(Object o1, Object o2) {
      return 0;
    }

    @Override
    public String toString() {
      return &quot;ALWAYS_EQUAL&quot;;
    }

    private Object readResolve() {
      return INSTANCE;
    }
  }

  private ArbitraryInstances() {}
}
</PRE>
</div>
  </div>
</body>
</html>
