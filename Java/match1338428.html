<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ImmutableList.java &amp; ArbitraryInstances_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableList.java &amp; ArbitraryInstances_1.java
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableList.java (5.631399%)<th>ArbitraryInstances_1.java (4.962406%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-39)<td><a href="#" name="0">(133-169)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(265-272)<td><a href="#" name="1">(487-494)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(126-129)<td><a href="#" name="2">(410-413)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableList.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.collect;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.RandomAccess;
import java.util.stream.Collector;
import org.checkerframework.checker.nullness.qual.Nullable;
@</b></font>SuppressWarnings("serial") public abstract class ImmutableList&lt;E&gt; extends ImmutableCollection&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess {
  static final ImmutableList&lt;Object&gt; EMPTY =
      new RegularImmutableList&lt;Object&gt;(Collections.emptyList());
  ImmutableList() {}
  public static &lt;E&gt; Collector&lt;E, ?, ImmutableList&lt;E&gt;&gt; toImmutableList() {
    return CollectCollectors.toImmutableList();
  }
  @SuppressWarnings("unchecked")
  public static &lt;E&gt; ImmutableList&lt;E&gt; of() {
    return (ImmutableList&lt;E&gt;) EMPTY;
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) {
    return new SingletonImmutableList&lt;E&gt;(checkNotNull(element));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) {
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) {
    return new RegularImmutableList&lt;E&gt;(
        ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {
    final int paramCount = 12;
    Object[] array = new Object[paramCount + others.length];
    arrayCopy(array, 0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12);
    arrayCopy(array, paramCount, others);
    return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(array));
  }
  private static void arrayCopy(Object[] dest, int pos, Object... source) {
    System.arraycopy(source, 0, dest, pos, source.length);
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
    checkNotNull(elements); <a name="2"></a>    return (elements instanceof Collection)
        ? copyOf((Collection&lt;? extends E&gt;) elements)
        : copyOf(elements.iterator());
  <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
    return copyFromCollection(Lists.newArrayList</b></font>(elements));
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
    if (elements instanceof ImmutableCollection) {
      @SuppressWarnings("unchecked")       ImmutableCollection&lt;E&gt; list = (ImmutableCollection&lt;E&gt;) elements;
      return list.asList();
    }
    return copyFromCollection(elements);
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(E[] elements) {
    checkNotNull(elements);     return copyOf(Arrays.asList(elements));
  }
  private static &lt;E&gt; ImmutableList&lt;E&gt; copyFromCollection(Collection&lt;? extends E&gt; collection) {
    Object[] elements = collection.toArray();
    switch (elements.length) {
      case 0:
        return of();
      case 1:
        return of((E) elements[0]);
      default:
        return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(elements));
    }
  }
  static &lt;E&gt; ImmutableList&lt;E&gt; unsafeDelegateList(List&lt;? extends E&gt; list) {
    switch (list.size()) {
      case 0:
        return of();
      case 1:
        return of(list.get(0));
      default:
        @SuppressWarnings("unchecked")
        List&lt;E&gt; castedList = (List&lt;E&gt;) list;
        return new RegularImmutableList&lt;E&gt;(castedList);
    }
  }
  @SuppressWarnings("unchecked")   static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements) {
    return unsafeDelegateList((List) Arrays.asList(elements));
  }
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableList&lt;E&gt; sortedCopyOf(
      Iterable&lt;? extends E&gt; elements) {
    Comparable[] array = Iterables.toArray(elements, new Comparable[0]);
    checkElementsNotNull(array);
    Arrays.sort(array);
    return asImmutableList(array);
  }
  public static &lt;E&gt; ImmutableList&lt;E&gt; sortedCopyOf(
      Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
    checkNotNull(comparator);
    @SuppressWarnings("unchecked")     E[] array = (E[]) Iterables.toArray(elements);
    checkElementsNotNull(array);
    Arrays.sort(array, comparator);
    return asImmutableList(array);
  }
  private static &lt;E&gt; List&lt;E&gt; nullCheckedList(Object... array) {
    for (int i = 0, len = array.length; i &lt; len; i++) {
      if (array[i] == null) {
        throw new NullPointerException("at index " + i);
      }
    }
    @SuppressWarnings("unchecked")
    E[] castedArray = (E[]) array;
    return Arrays.asList(castedArray);
  }
  @Override
  public int indexOf(@Nullable Object object) {
    return (object == null) ? -1 : Lists.indexOfImpl(this, object);
  }
  @Override
  public int lastIndexOf(@Nullable Object object) {
    return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object);
  }
  public final boolean addAll(int index, Collection&lt;? extends E&gt; newElements) {
    throw new UnsupportedOperationException();
  }
  public final E set(int index, E element) {
    throw new UnsupportedOperationException();
  }
  public final void add(int index, E element) {
    throw new UnsupportedOperationException();
  }
  public final E remove(int index) {
    throw new UnsupportedOperationException();
  }
  @Override
  public UnmodifiableIterator&lt;E&gt; iterator() {
    return listIterator();
  }
  @Override
  public ImmutableList&lt;E&gt; subList(int fromIndex, int toIndex) {
    return unsafeDelegateList(Lists.subListImpl(this, fromIndex, toIndex));
  }
  @Override
  public UnmodifiableListIterator&lt;E&gt; listIterator() {
    return listIterator(0);
  }
  @Override
  public UnmodifiableListIterator&lt;E&gt; listIterator(int index) {
    return new AbstractIndexedListIterator&lt;E&gt;(size(), index) {
      @Override
      protected E get(int index) {
<a name="1"></a>        return ImmutableList.this.get(index);
      }
    };
  <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  @Override
  public ImmutableList&lt;E&gt; asList() {
    return this;
  }
  @Overr</b></font>ide
  public boolean equals(@Nullable Object obj) {
    return Lists.equalsImpl(this, obj);
  }
  @Override
  public int hashCode() {
    return Lists.hashCodeImpl(this);
  }
  public ImmutableList&lt;E&gt; reverse() {
    List&lt;E&gt; list = Lists.newArrayList(this);
    Collections.reverse(list);
    return unsafeDelegateList(list);
  }
  public static &lt;E&gt; Builder&lt;E&gt; builder() {
    return new Builder&lt;E&gt;();
  }
  public static &lt;E&gt; Builder&lt;E&gt; builderWithExpectedSize(int expectedSize) {
    return new Builder&lt;E&gt;(expectedSize);
  }
  public static final class Builder&lt;E&gt; extends ImmutableCollection.Builder&lt;E&gt; {
    private final ArrayList&lt;E&gt; contents;
    public Builder() {
      contents = Lists.newArrayList();
    }
    Builder(int capacity) {
      contents = Lists.newArrayListWithCapacity(capacity);
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E element) {
      contents.add(checkNotNull(element));
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E... elements) {
      checkNotNull(elements);       super.add(elements);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }
    @CanIgnoreReturnValue
    Builder&lt;E&gt; combine(Builder&lt;E&gt; builder) {
      checkNotNull(builder);
      contents.addAll(builder.contents);
      return this;
    }
    @Override
    public ImmutableList&lt;E&gt; build() {
      return copyOf(contents);
    }
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ArbitraryInstances_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.testing;
import static com.google.common.base.Preconditions.checkArgument;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.CharMatcher;
import com.google.common.base.Charsets;
import com.google.common.base.Defaults;
import com.google.common.base.Equivalence;
import com.google.common.base.Joiner;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Splitter;
import com.google.common.base.Stopwatch;
import com.google.common.base.Ticker;
import com.google.common.collect.BiMap;
import com.google.common.collect.ClassToInstanceMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableClassToInstanceMap;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Iterators;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.MapDifference;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.collect.PeekingIterator;
import com.google.common.collect.Range;
import com.google.common.collect.RowSortedTable;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.collect.SortedMapDifference;
import com.google.common.collect.SortedMultiset;
import com.google.common.collect.SortedSetMultimap;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import com.google.common.collect.TreeBasedTable;
import com.google.common.collect.TreeMultimap;
import com.google.common.io.ByteSink;
import com.google.common.io.ByteSource;
import com.google.common.io.ByteStreams;
import com.google.common.io.CharSink;
import com.google.common.io.CharSource;
import com.google.common.primitives.Primitives;
import com.google.common.primitives.UnsignedInteger;
import com.google.common.primitives.UnsignedLong;
import com.google.errorprone.annotations.Keep;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import java.nio.charset.Charset;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Currency;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.UUID;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
<a name="0"></a>import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentNavigableMap;
import java.util.concurrent.ConcurrentSkipListMap;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
@</b></font>GwtIncompatible
public final class ArbitraryInstances {
  private static final Ordering&lt;Field&gt; BY_FIELD_NAME =
      new Ordering&lt;Field&gt;() {
        @Override
        public int compare(Field left, Field right) {
          return left.getName().compareTo(right.getName());
        }
      };
  private static MatchResult newMatchResult() {
    Matcher matcher = Pattern.compile(".").matcher("X");
    matcher.find();
    return matcher.toMatchResult();
  }
  private static final ClassToInstanceMap&lt;Object&gt; DEFAULTS =
      ImmutableClassToInstanceMap.builder()
          .put(Object.class, "")
          .put(Number.class, 0)
          .put(UnsignedInteger.class, UnsignedInteger.ZERO)
          .put(UnsignedLong.class, UnsignedLong.ZERO)
          .put(BigInteger.class, BigInteger.ZERO)
          .put(BigDecimal.class, BigDecimal.ZERO)
          .put(CharSequence.class, "")
          .put(String.class, "")
          .put(Pattern.class, Pattern.compile(""))
          .put(MatchResult.class, newMatchResult())
          .put(TimeUnit.class, TimeUnit.SECONDS)
          .put(Charset.class, Charsets.UTF_8)
          .put(Currency.class, Currency.getInstance(Locale.US))
          .put(Locale.class, Locale.US)
          .put(UUID.class, UUID.randomUUID())
          .put(CharMatcher.class, CharMatcher.none())
          .put(Joiner.class, Joiner.on(','))
          .put(Splitter.class, Splitter.on(','))
          .put(com.google.common.base.Optional.class, com.google.common.base.Optional.absent())
          .put(Predicate.class, Predicates.alwaysTrue())
          .put(Equivalence.class, Equivalence.equals())
          .put(Ticker.class, Ticker.systemTicker())
          .put(Stopwatch.class, Stopwatch.createUnstarted())
          .put(InputStream.class, new ByteArrayInputStream(new byte[0]))
          .put(ByteArrayInputStream.class, new ByteArrayInputStream(new byte[0]))
          .put(Readable.class, new StringReader(""))
          .put(Reader.class, new StringReader(""))
          .put(StringReader.class, new StringReader(""))
          .put(Buffer.class, ByteBuffer.allocate(0))
          .put(CharBuffer.class, CharBuffer.allocate(0))
          .put(ByteBuffer.class, ByteBuffer.allocate(0))
          .put(ShortBuffer.class, ShortBuffer.allocate(0))
          .put(IntBuffer.class, IntBuffer.allocate(0))
          .put(LongBuffer.class, LongBuffer.allocate(0))
          .put(FloatBuffer.class, FloatBuffer.allocate(0))
          .put(DoubleBuffer.class, DoubleBuffer.allocate(0))
          .put(File.class, new File(""))
          .put(ByteSource.class, ByteSource.empty())
          .put(CharSource.class, CharSource.empty())
          .put(ByteSink.class, NullByteSink.INSTANCE)
          .put(CharSink.class, NullByteSink.INSTANCE.asCharSink(Charsets.UTF_8))
          .put(Iterator.class, ImmutableSet.of().iterator())
          .put(PeekingIterator.class, Iterators.peekingIterator(ImmutableSet.of().iterator()))
          .put(ListIterator.class, ImmutableList.of().listIterator())
          .put(Iterable.class, ImmutableSet.of())
          .put(Collection.class, ImmutableList.of())
          .put(ImmutableCollection.class, ImmutableList.of())
          .put(List.class, ImmutableList.of())
          .put(ImmutableList.class, ImmutableList.of())
          .put(Set.class, ImmutableSet.of())
          .put(ImmutableSet.class, ImmutableSet.of())
          .put(SortedSet.class, ImmutableSortedSet.of())
          .put(ImmutableSortedSet.class, ImmutableSortedSet.of())
          .put(NavigableSet.class, Sets.unmodifiableNavigableSet(Sets.newTreeSet()))
          .put(Map.class, ImmutableMap.of())
          .put(ImmutableMap.class, ImmutableMap.of())
          .put(SortedMap.class, ImmutableSortedMap.of())
          .put(ImmutableSortedMap.class, ImmutableSortedMap.of())
          .put(NavigableMap.class, Maps.unmodifiableNavigableMap(Maps.newTreeMap()))
          .put(Multimap.class, ImmutableMultimap.of())
          .put(ImmutableMultimap.class, ImmutableMultimap.of())
          .put(ListMultimap.class, ImmutableListMultimap.of())
          .put(ImmutableListMultimap.class, ImmutableListMultimap.of())
          .put(SetMultimap.class, ImmutableSetMultimap.of())
          .put(ImmutableSetMultimap.class, ImmutableSetMultimap.of())
          .put(
              SortedSetMultimap.class,
              Multimaps.unmodifiableSortedSetMultimap(TreeMultimap.create()))
          .put(Multiset.class, ImmutableMultiset.of())
          .put(ImmutableMultiset.class, ImmutableMultiset.of())
          .put(SortedMultiset.class, ImmutableSortedMultiset.of())
          .put(ImmutableSortedMultiset.class, ImmutableSortedMultiset.of())
          .put(BiMap.class, ImmutableBiMap.of())
          .put(ImmutableBiMap.class, ImmutableBiMap.of())
          .put(Table.class, ImmutableTable.of())
          .put(ImmutableTable.class, ImmutableTable.of())
          .put(RowSortedTable.class, Tables.unmodifiableRowSortedTable(TreeBasedTable.create()))
          .put(ClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
          .put(ImmutableClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
          .put(Comparable.class, ByToString.INSTANCE)
          .put(Comparator.class, AlwaysEqual.INSTANCE)
          .put(Ordering.class, AlwaysEqual.INSTANCE)
          .put(Range.class, Range.all())
          .put(MapDifference.class, Maps.difference(ImmutableMap.of(), ImmutableMap.of()))
          .put(
              SortedMapDifference.class,
              Maps.difference(ImmutableSortedMap.of(), ImmutableSortedMap.of()))
          .put(AnnotatedElement.class, Object.class)
          .put(GenericDeclaration.class, Object.class)
          .put(Type.class, Object.class)
          .build();
  private static final ConcurrentMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; implementations = Maps.newConcurrentMap();
  private static &lt;T&gt; void setImplementation(Class&lt;T&gt; type, Class&lt;? extends T&gt; implementation) {
    checkArgument(type != implementation, "Don't register %s to itself!", type);
    checkArgument(
        !DEFAULTS.containsKey(type), "A default value was already registered for %s", type);
    checkArgument(
        implementations.put(type, implementation) == null,
        "Implementation for %s was already registered",
        type);
  }
  static {
    setImplementation(Appendable.class, StringBuilder.class);
    setImplementation(BlockingQueue.class, LinkedBlockingDeque.class);
    setImplementation(BlockingDeque.class, LinkedBlockingDeque.class);
    setImplementation(ConcurrentMap.class, ConcurrentHashMap.class);
    setImplementation(ConcurrentNavigableMap.class, ConcurrentSkipListMap.class);
    setImplementation(CountDownLatch.class, Dummies.DummyCountDownLatch.class);
    setImplementation(Deque.class, ArrayDeque.class);
    setImplementation(OutputStream.class, ByteArrayOutputStream.class);
    setImplementation(PrintStream.class, Dummies.InMemoryPrintStream.class);
    setImplementation(PrintWriter.class, Dummies.InMemoryPrintWriter.class);
    setImplementation(Queue.class, ArrayDeque.class);
    setImplementation(Random.class, Dummies.DeterministicRandom.class);
    setImplementation(
        ScheduledThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
    setImplementation(ThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
    setImplementation(Writer.class, StringWriter.class);
    setImplementation(Runnable.class, Dummies.DummyRunnable.class);
    setImplementation(ThreadFactory.class, Dummies.DummyThreadFactory.class);
    setImplementation(Executor.class, Dummies.DummyExecutor.class);
  }
  @SuppressWarnings("unchecked")   @CheckForNull
  private static &lt;T&gt; Class&lt;? extends T&gt; getImplementation(Class&lt;T&gt; type) {
    return (Class&lt;? extends T&gt;) implementations.get(type);
  }
  private static final Logger logger = Logger.getLogger(ArbitraryInstances.class.getName());
  @CheckForNull
  public static &lt;T&gt; T get(Class&lt;T&gt; type) {
    T defaultValue = DEFAULTS.getInstance(type);
    if (defaultValue != null) {
      return defaultValue;
    }
    Class&lt;? extends T&gt; implementation = getImplementation(type);
    if (implementation != null) {
      return get(implementation);
    }
    if (type.isEnum()) {
      T[] enumConstants = type.getEnumConstants();
      return (enumConstants.length == 0) ? null : enumConstants[0];
    }
    if (type.isArray()) {
      return createEmptyArray(type);
    }
    T jvmDefault = Defaults.defaultValue(Primitives.unwrap(type));
    if (jvmDefault != null) {
      return jvmDefault;
    }
    if (Modifier.isAbstract(type.getModifiers()) || !Modifier.isPublic(type.getModifiers())) {
      return arbitraryConstantInstanceOrNull(type);
    }
    final Constructor&lt;T&gt; constructor;
    try {
      constructor = type.getConstructor();
    } catch (NoSuchMethodException e) {
      return arbitraryConstantInstanceOrNull(type);
    }
    constructor.setAccessible(true);     try {
      return constructor.newInstance();
      /*
       * Do not merge the 2 catch blocks below. javac would infer a type of
       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of
       * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)
       */
    } catch (InstantiationException impossible) {
      throw new AssertionError(impossible);
    } catch (IllegalAccessException impossible) {
      throw new AssertionError(impossible);
    } catch (InvocationTargetException e) {
      logger.log(Level.WARNING, "Exception while invoking default constructor.", e.getCause());
      return arbitraryConstantInstanceOrNull(type);
    }
  }
  @CheckForNull
  private static &lt;T&gt; T arbitraryConstantInstanceOrNull(Class&lt;T&gt; type) {
    Field[] fields = type.getDeclaredFields();
    Arrays.sort(fields, BY_FIELD_NAME);
    for (Field field : fields) {
      if (Modifier.isPublic(field.getModifiers())
          &amp;&amp; Modifier.isStatic(field.getModifiers())
          &amp;&amp; Modifier.isFinal(field.getModifiers())) {
        if (field.getGenericType() == field.getType() &amp;&amp; type.isAssignableFrom(field.getType())) {
          field.setAccessible(true);
          try {
            T constant = type.cast(field.get(null));
            if (constant != null) {
              return constant;
            }
          } catch (IllegalAccessException impossible) {
            throw new AssertionError(impossible);
          }
        }
<a name="2"></a>      }
    }
    return null;
  <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
  private static &lt;T&gt; T createEmptyArray(Class&lt;T&gt; arrayType) {
    return arrayType.cast(Array.newInstance</b></font>(arrayType.getComponentType(), 0));
  }
  private static final class Dummies {
    public static final class InMemoryPrintStream extends PrintStream {
      public InMemoryPrintStream() {
        super(new ByteArrayOutputStream());
      }
    }
    public static final class InMemoryPrintWriter extends PrintWriter {
      public InMemoryPrintWriter() {
        super(new StringWriter());
      }
    }
    public static final class DeterministicRandom extends Random {
      @Keep
      public DeterministicRandom() {
        super(0);
      }
    }
    public static final class DummyScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {
      public DummyScheduledThreadPoolExecutor() {
        super(1);
      }
    }
    public static final class DummyCountDownLatch extends CountDownLatch {
      public DummyCountDownLatch() {
        super(0);
      }
    }
    public static final class DummyRunnable implements Runnable, Serializable {
      @Override
      public void run() {}
    }
    public static final class DummyThreadFactory implements ThreadFactory, Serializable {
      @Override
      public Thread newThread(Runnable r) {
        return new Thread(r);
      }
    }
    public static final class DummyExecutor implements Executor, Serializable {
      @Override
      public void execute(Runnable command) {}
    }
  }
  private static final class NullByteSink extends ByteSink implements Serializable {
    private static final NullByteSink INSTANCE = new NullByteSink();
    @Override
    public OutputStream openStream() {
      return ByteStreams.nullOutputStream();
    }
  }
  @SuppressWarnings("ComparableType")
  private static final class ByToString implements Comparable&lt;Object&gt;, Serializable {
    private static final ByToString INSTANCE = new ByToString();
<a name="1"></a>    @Override
    public int compareTo(Object o) {
      return toString().compareTo(o.toString());
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Override
    public String toString() {
      return "BY_TO_STRING";
    }
    private Obj</b></font>ect readResolve() {
      return INSTANCE;
    }
  }
  private static final class AlwaysEqual extends Ordering&lt;Object&gt; implements Serializable {
    private static final AlwaysEqual INSTANCE = new AlwaysEqual();
    @Override
    public int compare(Object o1, Object o2) {
      return 0;
    }
    @Override
    public String toString() {
      return "ALWAYS_EQUAL";
    }
    private Object readResolve() {
      return INSTANCE;
    }
  }
  private ArbitraryInstances() {}
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
