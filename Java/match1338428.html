<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ImmutableList.java &amp; ArbitraryInstances_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableList.java &amp; ArbitraryInstances_1.java
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableList.java (5.631399%)<th>ArbitraryInstances_1.java (4.962406%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-39)<td><a href="#" name="0">(133-169)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(265-272)<td><a href="#" name="1">(487-494)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(126-129)<td><a href="#" name="2">(410-413)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableList.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
5 import com.google.errorprone.annotations.CanIgnoreReturnValue;
6 import java.util.ArrayList;
7 import java.util.Arrays;
8 import java.util.Collection;
9 import java.util.Collections;
10 import java.util.Comparator;
11 import java.util.Iterator;
12 import java.util.List;
13 import java.util.RandomAccess;
14 import java.util.stream.Collector;
15 import org.checkerframework.checker.nullness.qual.Nullable;
16 @</b></font>SuppressWarnings("serial") public abstract class ImmutableList&lt;E&gt; extends ImmutableCollection&lt;E&gt;
17     implements List&lt;E&gt;, RandomAccess {
18   static final ImmutableList&lt;Object&gt; EMPTY =
19       new RegularImmutableList&lt;Object&gt;(Collections.emptyList());
20   ImmutableList() {}
21   public static &lt;E&gt; Collector&lt;E, ?, ImmutableList&lt;E&gt;&gt; toImmutableList() {
22     return CollectCollectors.toImmutableList();
23   }
24   @SuppressWarnings("unchecked")
25   public static &lt;E&gt; ImmutableList&lt;E&gt; of() {
26     return (ImmutableList&lt;E&gt;) EMPTY;
27   }
28   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) {
29     return new SingletonImmutableList&lt;E&gt;(checkNotNull(element));
30   }
31   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) {
32     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2));
33   }
34   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) {
35     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3));
36   }
37   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4) {
38     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4));
39   }
40   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) {
41     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5));
42   }
43   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) {
44     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6));
45   }
46   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
47     return new RegularImmutableList&lt;E&gt;(
48         ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7));
49   }
50   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
51     return new RegularImmutableList&lt;E&gt;(
52         ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8));
53   }
54   public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
55     return new RegularImmutableList&lt;E&gt;(
56         ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9));
57   }
58   public static &lt;E&gt; ImmutableList&lt;E&gt; of(
59       E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
60     return new RegularImmutableList&lt;E&gt;(
61         ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10));
62   }
63   public static &lt;E&gt; ImmutableList&lt;E&gt; of(
64       E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) {
65     return new RegularImmutableList&lt;E&gt;(
66         ImmutableList.&lt;E&gt;nullCheckedList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11));
67   }
68   public static &lt;E&gt; ImmutableList&lt;E&gt; of(
69       E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {
70     final int paramCount = 12;
71     Object[] array = new Object[paramCount + others.length];
72     arrayCopy(array, 0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12);
73     arrayCopy(array, paramCount, others);
74     return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(array));
75   }
76   private static void arrayCopy(Object[] dest, int pos, Object... source) {
77     System.arraycopy(source, 0, dest, pos, source.length);
78   }
79   public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
80     checkNotNull(elements); <a name="2"></a>    return (elements instanceof Collection)
81         ? copyOf((Collection&lt;? extends E&gt;) elements)
82         : copyOf(elements.iterator());
83   <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
84   public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
85     return copyFromCollection(Lists.newArrayList</b></font>(elements));
86   }
87   public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
88     if (elements instanceof ImmutableCollection) {
89       @SuppressWarnings("unchecked")       ImmutableCollection&lt;E&gt; list = (ImmutableCollection&lt;E&gt;) elements;
90       return list.asList();
91     }
92     return copyFromCollection(elements);
93   }
94   public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(E[] elements) {
95     checkNotNull(elements);     return copyOf(Arrays.asList(elements));
96   }
97   private static &lt;E&gt; ImmutableList&lt;E&gt; copyFromCollection(Collection&lt;? extends E&gt; collection) {
98     Object[] elements = collection.toArray();
99     switch (elements.length) {
100       case 0:
101         return of();
102       case 1:
103         return of((E) elements[0]);
104       default:
105         return new RegularImmutableList&lt;E&gt;(ImmutableList.&lt;E&gt;nullCheckedList(elements));
106     }
107   }
108   static &lt;E&gt; ImmutableList&lt;E&gt; unsafeDelegateList(List&lt;? extends E&gt; list) {
109     switch (list.size()) {
110       case 0:
111         return of();
112       case 1:
113         return of(list.get(0));
114       default:
115         @SuppressWarnings("unchecked")
116         List&lt;E&gt; castedList = (List&lt;E&gt;) list;
117         return new RegularImmutableList&lt;E&gt;(castedList);
118     }
119   }
120   @SuppressWarnings("unchecked")   static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements) {
121     return unsafeDelegateList((List) Arrays.asList(elements));
122   }
123   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableList&lt;E&gt; sortedCopyOf(
124       Iterable&lt;? extends E&gt; elements) {
125     Comparable[] array = Iterables.toArray(elements, new Comparable[0]);
126     checkElementsNotNull(array);
127     Arrays.sort(array);
128     return asImmutableList(array);
129   }
130   public static &lt;E&gt; ImmutableList&lt;E&gt; sortedCopyOf(
131       Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
132     checkNotNull(comparator);
133     @SuppressWarnings("unchecked")     E[] array = (E[]) Iterables.toArray(elements);
134     checkElementsNotNull(array);
135     Arrays.sort(array, comparator);
136     return asImmutableList(array);
137   }
138   private static &lt;E&gt; List&lt;E&gt; nullCheckedList(Object... array) {
139     for (int i = 0, len = array.length; i &lt; len; i++) {
140       if (array[i] == null) {
141         throw new NullPointerException("at index " + i);
142       }
143     }
144     @SuppressWarnings("unchecked")
145     E[] castedArray = (E[]) array;
146     return Arrays.asList(castedArray);
147   }
148   @Override
149   public int indexOf(@Nullable Object object) {
150     return (object == null) ? -1 : Lists.indexOfImpl(this, object);
151   }
152   @Override
153   public int lastIndexOf(@Nullable Object object) {
154     return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object);
155   }
156   public final boolean addAll(int index, Collection&lt;? extends E&gt; newElements) {
157     throw new UnsupportedOperationException();
158   }
159   public final E set(int index, E element) {
160     throw new UnsupportedOperationException();
161   }
162   public final void add(int index, E element) {
163     throw new UnsupportedOperationException();
164   }
165   public final E remove(int index) {
166     throw new UnsupportedOperationException();
167   }
168   @Override
169   public UnmodifiableIterator&lt;E&gt; iterator() {
170     return listIterator();
171   }
172   @Override
173   public ImmutableList&lt;E&gt; subList(int fromIndex, int toIndex) {
174     return unsafeDelegateList(Lists.subListImpl(this, fromIndex, toIndex));
175   }
176   @Override
177   public UnmodifiableListIterator&lt;E&gt; listIterator() {
178     return listIterator(0);
179   }
180   @Override
181   public UnmodifiableListIterator&lt;E&gt; listIterator(int index) {
182     return new AbstractIndexedListIterator&lt;E&gt;(size(), index) {
183       @Override
184       protected E get(int index) {
185 <a name="1"></a>        return ImmutableList.this.get(index);
186       }
187     };
188   <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
189   @Override
190   public ImmutableList&lt;E&gt; asList() {
191     return this;
192   }
193   @Overr</b></font>ide
194   public boolean equals(@Nullable Object obj) {
195     return Lists.equalsImpl(this, obj);
196   }
197   @Override
198   public int hashCode() {
199     return Lists.hashCodeImpl(this);
200   }
201   public ImmutableList&lt;E&gt; reverse() {
202     List&lt;E&gt; list = Lists.newArrayList(this);
203     Collections.reverse(list);
204     return unsafeDelegateList(list);
205   }
206   public static &lt;E&gt; Builder&lt;E&gt; builder() {
207     return new Builder&lt;E&gt;();
208   }
209   public static &lt;E&gt; Builder&lt;E&gt; builderWithExpectedSize(int expectedSize) {
210     return new Builder&lt;E&gt;(expectedSize);
211   }
212   public static final class Builder&lt;E&gt; extends ImmutableCollection.Builder&lt;E&gt; {
213     private final ArrayList&lt;E&gt; contents;
214     public Builder() {
215       contents = Lists.newArrayList();
216     }
217     Builder(int capacity) {
218       contents = Lists.newArrayListWithCapacity(capacity);
219     }
220     @CanIgnoreReturnValue
221     @Override
222     public Builder&lt;E&gt; add(E element) {
223       contents.add(checkNotNull(element));
224       return this;
225     }
226     @CanIgnoreReturnValue
227     @Override
228     public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
229       super.addAll(elements);
230       return this;
231     }
232     @CanIgnoreReturnValue
233     @Override
234     public Builder&lt;E&gt; add(E... elements) {
235       checkNotNull(elements);       super.add(elements);
236       return this;
237     }
238     @CanIgnoreReturnValue
239     @Override
240     public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
241       super.addAll(elements);
242       return this;
243     }
244     @CanIgnoreReturnValue
245     Builder&lt;E&gt; combine(Builder&lt;E&gt; builder) {
246       checkNotNull(builder);
247       contents.addAll(builder.contents);
248       return this;
249     }
250     @Override
251     public ImmutableList&lt;E&gt; build() {
252       return copyOf(contents);
253     }
254   }
255 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ArbitraryInstances_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.testing;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import com.google.common.annotations.GwtIncompatible;
4 import com.google.common.base.CharMatcher;
5 import com.google.common.base.Charsets;
6 import com.google.common.base.Defaults;
7 import com.google.common.base.Equivalence;
8 import com.google.common.base.Joiner;
9 import com.google.common.base.Predicate;
10 import com.google.common.base.Predicates;
11 import com.google.common.base.Splitter;
12 import com.google.common.base.Stopwatch;
13 import com.google.common.base.Ticker;
14 import com.google.common.collect.BiMap;
15 import com.google.common.collect.ClassToInstanceMap;
16 import com.google.common.collect.ImmutableBiMap;
17 import com.google.common.collect.ImmutableClassToInstanceMap;
18 import com.google.common.collect.ImmutableCollection;
19 import com.google.common.collect.ImmutableList;
20 import com.google.common.collect.ImmutableListMultimap;
21 import com.google.common.collect.ImmutableMap;
22 import com.google.common.collect.ImmutableMultimap;
23 import com.google.common.collect.ImmutableMultiset;
24 import com.google.common.collect.ImmutableSet;
25 import com.google.common.collect.ImmutableSetMultimap;
26 import com.google.common.collect.ImmutableSortedMap;
27 import com.google.common.collect.ImmutableSortedMultiset;
28 import com.google.common.collect.ImmutableSortedSet;
29 import com.google.common.collect.ImmutableTable;
30 import com.google.common.collect.Iterators;
31 import com.google.common.collect.ListMultimap;
32 import com.google.common.collect.MapDifference;
33 import com.google.common.collect.Maps;
34 import com.google.common.collect.Multimap;
35 import com.google.common.collect.Multimaps;
36 import com.google.common.collect.Multiset;
37 import com.google.common.collect.Ordering;
38 import com.google.common.collect.PeekingIterator;
39 import com.google.common.collect.Range;
40 import com.google.common.collect.RowSortedTable;
41 import com.google.common.collect.SetMultimap;
42 import com.google.common.collect.Sets;
43 import com.google.common.collect.SortedMapDifference;
44 import com.google.common.collect.SortedMultiset;
45 import com.google.common.collect.SortedSetMultimap;
46 import com.google.common.collect.Table;
47 import com.google.common.collect.Tables;
48 import com.google.common.collect.TreeBasedTable;
49 import com.google.common.collect.TreeMultimap;
50 import com.google.common.io.ByteSink;
51 import com.google.common.io.ByteSource;
52 import com.google.common.io.ByteStreams;
53 import com.google.common.io.CharSink;
54 import com.google.common.io.CharSource;
55 import com.google.common.primitives.Primitives;
56 import com.google.common.primitives.UnsignedInteger;
57 import com.google.common.primitives.UnsignedLong;
58 import com.google.errorprone.annotations.Keep;
59 import java.io.ByteArrayInputStream;
60 import java.io.ByteArrayOutputStream;
61 import java.io.File;
62 import java.io.InputStream;
63 import java.io.OutputStream;
64 import java.io.PrintStream;
65 import java.io.PrintWriter;
66 import java.io.Reader;
67 import java.io.Serializable;
68 import java.io.StringReader;
69 import java.io.StringWriter;
70 import java.io.Writer;
71 import java.lang.reflect.AnnotatedElement;
72 import java.lang.reflect.Array;
73 import java.lang.reflect.Constructor;
74 import java.lang.reflect.Field;
75 import java.lang.reflect.GenericDeclaration;
76 import java.lang.reflect.InvocationTargetException;
77 import java.lang.reflect.Modifier;
78 import java.lang.reflect.Type;
79 import java.math.BigDecimal;
80 import java.math.BigInteger;
81 import java.nio.Buffer;
82 import java.nio.ByteBuffer;
83 import java.nio.CharBuffer;
84 import java.nio.DoubleBuffer;
85 import java.nio.FloatBuffer;
86 import java.nio.IntBuffer;
87 import java.nio.LongBuffer;
88 import java.nio.ShortBuffer;
89 import java.nio.charset.Charset;
90 import java.util.ArrayDeque;
91 import java.util.Arrays;
92 import java.util.Collection;
93 import java.util.Comparator;
94 import java.util.Currency;
95 import java.util.Deque;
96 import java.util.Iterator;
97 import java.util.List;
98 import java.util.ListIterator;
99 import java.util.Locale;
100 import java.util.Map;
101 import java.util.NavigableMap;
102 import java.util.NavigableSet;
103 import java.util.Queue;
104 import java.util.Random;
105 import java.util.Set;
106 import java.util.SortedMap;
107 import java.util.SortedSet;
108 import java.util.UUID;
109 import java.util.concurrent.BlockingDeque;
110 import java.util.concurrent.BlockingQueue;
111 import java.util.concurrent.ConcurrentHashMap;
112 <a name="0"></a>import java.util.concurrent.ConcurrentMap;
113 import java.util.concurrent.ConcurrentNavigableMap;
114 import java.util.concurrent.ConcurrentSkipListMap;
115 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.concurrent.CountDownLatch;
116 import java.util.concurrent.Executor;
117 import java.util.concurrent.LinkedBlockingDeque;
118 import java.util.concurrent.ScheduledThreadPoolExecutor;
119 import java.util.concurrent.ThreadFactory;
120 import java.util.concurrent.ThreadPoolExecutor;
121 import java.util.concurrent.TimeUnit;
122 import java.util.logging.Level;
123 import java.util.logging.Logger;
124 import java.util.regex.MatchResult;
125 import java.util.regex.Matcher;
126 import java.util.regex.Pattern;
127 import javax.annotation.CheckForNull;
128 @</b></font>GwtIncompatible
129 public final class ArbitraryInstances {
130   private static final Ordering&lt;Field&gt; BY_FIELD_NAME =
131       new Ordering&lt;Field&gt;() {
132         @Override
133         public int compare(Field left, Field right) {
134           return left.getName().compareTo(right.getName());
135         }
136       };
137   private static MatchResult newMatchResult() {
138     Matcher matcher = Pattern.compile(".").matcher("X");
139     matcher.find();
140     return matcher.toMatchResult();
141   }
142   private static final ClassToInstanceMap&lt;Object&gt; DEFAULTS =
143       ImmutableClassToInstanceMap.builder()
144           .put(Object.class, "")
145           .put(Number.class, 0)
146           .put(UnsignedInteger.class, UnsignedInteger.ZERO)
147           .put(UnsignedLong.class, UnsignedLong.ZERO)
148           .put(BigInteger.class, BigInteger.ZERO)
149           .put(BigDecimal.class, BigDecimal.ZERO)
150           .put(CharSequence.class, "")
151           .put(String.class, "")
152           .put(Pattern.class, Pattern.compile(""))
153           .put(MatchResult.class, newMatchResult())
154           .put(TimeUnit.class, TimeUnit.SECONDS)
155           .put(Charset.class, Charsets.UTF_8)
156           .put(Currency.class, Currency.getInstance(Locale.US))
157           .put(Locale.class, Locale.US)
158           .put(UUID.class, UUID.randomUUID())
159           .put(CharMatcher.class, CharMatcher.none())
160           .put(Joiner.class, Joiner.on(','))
161           .put(Splitter.class, Splitter.on(','))
162           .put(com.google.common.base.Optional.class, com.google.common.base.Optional.absent())
163           .put(Predicate.class, Predicates.alwaysTrue())
164           .put(Equivalence.class, Equivalence.equals())
165           .put(Ticker.class, Ticker.systemTicker())
166           .put(Stopwatch.class, Stopwatch.createUnstarted())
167           .put(InputStream.class, new ByteArrayInputStream(new byte[0]))
168           .put(ByteArrayInputStream.class, new ByteArrayInputStream(new byte[0]))
169           .put(Readable.class, new StringReader(""))
170           .put(Reader.class, new StringReader(""))
171           .put(StringReader.class, new StringReader(""))
172           .put(Buffer.class, ByteBuffer.allocate(0))
173           .put(CharBuffer.class, CharBuffer.allocate(0))
174           .put(ByteBuffer.class, ByteBuffer.allocate(0))
175           .put(ShortBuffer.class, ShortBuffer.allocate(0))
176           .put(IntBuffer.class, IntBuffer.allocate(0))
177           .put(LongBuffer.class, LongBuffer.allocate(0))
178           .put(FloatBuffer.class, FloatBuffer.allocate(0))
179           .put(DoubleBuffer.class, DoubleBuffer.allocate(0))
180           .put(File.class, new File(""))
181           .put(ByteSource.class, ByteSource.empty())
182           .put(CharSource.class, CharSource.empty())
183           .put(ByteSink.class, NullByteSink.INSTANCE)
184           .put(CharSink.class, NullByteSink.INSTANCE.asCharSink(Charsets.UTF_8))
185           .put(Iterator.class, ImmutableSet.of().iterator())
186           .put(PeekingIterator.class, Iterators.peekingIterator(ImmutableSet.of().iterator()))
187           .put(ListIterator.class, ImmutableList.of().listIterator())
188           .put(Iterable.class, ImmutableSet.of())
189           .put(Collection.class, ImmutableList.of())
190           .put(ImmutableCollection.class, ImmutableList.of())
191           .put(List.class, ImmutableList.of())
192           .put(ImmutableList.class, ImmutableList.of())
193           .put(Set.class, ImmutableSet.of())
194           .put(ImmutableSet.class, ImmutableSet.of())
195           .put(SortedSet.class, ImmutableSortedSet.of())
196           .put(ImmutableSortedSet.class, ImmutableSortedSet.of())
197           .put(NavigableSet.class, Sets.unmodifiableNavigableSet(Sets.newTreeSet()))
198           .put(Map.class, ImmutableMap.of())
199           .put(ImmutableMap.class, ImmutableMap.of())
200           .put(SortedMap.class, ImmutableSortedMap.of())
201           .put(ImmutableSortedMap.class, ImmutableSortedMap.of())
202           .put(NavigableMap.class, Maps.unmodifiableNavigableMap(Maps.newTreeMap()))
203           .put(Multimap.class, ImmutableMultimap.of())
204           .put(ImmutableMultimap.class, ImmutableMultimap.of())
205           .put(ListMultimap.class, ImmutableListMultimap.of())
206           .put(ImmutableListMultimap.class, ImmutableListMultimap.of())
207           .put(SetMultimap.class, ImmutableSetMultimap.of())
208           .put(ImmutableSetMultimap.class, ImmutableSetMultimap.of())
209           .put(
210               SortedSetMultimap.class,
211               Multimaps.unmodifiableSortedSetMultimap(TreeMultimap.create()))
212           .put(Multiset.class, ImmutableMultiset.of())
213           .put(ImmutableMultiset.class, ImmutableMultiset.of())
214           .put(SortedMultiset.class, ImmutableSortedMultiset.of())
215           .put(ImmutableSortedMultiset.class, ImmutableSortedMultiset.of())
216           .put(BiMap.class, ImmutableBiMap.of())
217           .put(ImmutableBiMap.class, ImmutableBiMap.of())
218           .put(Table.class, ImmutableTable.of())
219           .put(ImmutableTable.class, ImmutableTable.of())
220           .put(RowSortedTable.class, Tables.unmodifiableRowSortedTable(TreeBasedTable.create()))
221           .put(ClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
222           .put(ImmutableClassToInstanceMap.class, ImmutableClassToInstanceMap.builder().build())
223           .put(Comparable.class, ByToString.INSTANCE)
224           .put(Comparator.class, AlwaysEqual.INSTANCE)
225           .put(Ordering.class, AlwaysEqual.INSTANCE)
226           .put(Range.class, Range.all())
227           .put(MapDifference.class, Maps.difference(ImmutableMap.of(), ImmutableMap.of()))
228           .put(
229               SortedMapDifference.class,
230               Maps.difference(ImmutableSortedMap.of(), ImmutableSortedMap.of()))
231           .put(AnnotatedElement.class, Object.class)
232           .put(GenericDeclaration.class, Object.class)
233           .put(Type.class, Object.class)
234           .build();
235   private static final ConcurrentMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; implementations = Maps.newConcurrentMap();
236   private static &lt;T&gt; void setImplementation(Class&lt;T&gt; type, Class&lt;? extends T&gt; implementation) {
237     checkArgument(type != implementation, "Don't register %s to itself!", type);
238     checkArgument(
239         !DEFAULTS.containsKey(type), "A default value was already registered for %s", type);
240     checkArgument(
241         implementations.put(type, implementation) == null,
242         "Implementation for %s was already registered",
243         type);
244   }
245   static {
246     setImplementation(Appendable.class, StringBuilder.class);
247     setImplementation(BlockingQueue.class, LinkedBlockingDeque.class);
248     setImplementation(BlockingDeque.class, LinkedBlockingDeque.class);
249     setImplementation(ConcurrentMap.class, ConcurrentHashMap.class);
250     setImplementation(ConcurrentNavigableMap.class, ConcurrentSkipListMap.class);
251     setImplementation(CountDownLatch.class, Dummies.DummyCountDownLatch.class);
252     setImplementation(Deque.class, ArrayDeque.class);
253     setImplementation(OutputStream.class, ByteArrayOutputStream.class);
254     setImplementation(PrintStream.class, Dummies.InMemoryPrintStream.class);
255     setImplementation(PrintWriter.class, Dummies.InMemoryPrintWriter.class);
256     setImplementation(Queue.class, ArrayDeque.class);
257     setImplementation(Random.class, Dummies.DeterministicRandom.class);
258     setImplementation(
259         ScheduledThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
260     setImplementation(ThreadPoolExecutor.class, Dummies.DummyScheduledThreadPoolExecutor.class);
261     setImplementation(Writer.class, StringWriter.class);
262     setImplementation(Runnable.class, Dummies.DummyRunnable.class);
263     setImplementation(ThreadFactory.class, Dummies.DummyThreadFactory.class);
264     setImplementation(Executor.class, Dummies.DummyExecutor.class);
265   }
266   @SuppressWarnings("unchecked")   @CheckForNull
267   private static &lt;T&gt; Class&lt;? extends T&gt; getImplementation(Class&lt;T&gt; type) {
268     return (Class&lt;? extends T&gt;) implementations.get(type);
269   }
270   private static final Logger logger = Logger.getLogger(ArbitraryInstances.class.getName());
271   @CheckForNull
272   public static &lt;T&gt; T get(Class&lt;T&gt; type) {
273     T defaultValue = DEFAULTS.getInstance(type);
274     if (defaultValue != null) {
275       return defaultValue;
276     }
277     Class&lt;? extends T&gt; implementation = getImplementation(type);
278     if (implementation != null) {
279       return get(implementation);
280     }
281     if (type.isEnum()) {
282       T[] enumConstants = type.getEnumConstants();
283       return (enumConstants.length == 0) ? null : enumConstants[0];
284     }
285     if (type.isArray()) {
286       return createEmptyArray(type);
287     }
288     T jvmDefault = Defaults.defaultValue(Primitives.unwrap(type));
289     if (jvmDefault != null) {
290       return jvmDefault;
291     }
292     if (Modifier.isAbstract(type.getModifiers()) || !Modifier.isPublic(type.getModifiers())) {
293       return arbitraryConstantInstanceOrNull(type);
294     }
295     final Constructor&lt;T&gt; constructor;
296     try {
297       constructor = type.getConstructor();
298     } catch (NoSuchMethodException e) {
299       return arbitraryConstantInstanceOrNull(type);
300     }
301     constructor.setAccessible(true);     try {
302       return constructor.newInstance();
303       /*
304        * Do not merge the 2 catch blocks below. javac would infer a type of
305        * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of
306        * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)
307        */
308     } catch (InstantiationException impossible) {
309       throw new AssertionError(impossible);
310     } catch (IllegalAccessException impossible) {
311       throw new AssertionError(impossible);
312     } catch (InvocationTargetException e) {
313       logger.log(Level.WARNING, "Exception while invoking default constructor.", e.getCause());
314       return arbitraryConstantInstanceOrNull(type);
315     }
316   }
317   @CheckForNull
318   private static &lt;T&gt; T arbitraryConstantInstanceOrNull(Class&lt;T&gt; type) {
319     Field[] fields = type.getDeclaredFields();
320     Arrays.sort(fields, BY_FIELD_NAME);
321     for (Field field : fields) {
322       if (Modifier.isPublic(field.getModifiers())
323           &amp;&amp; Modifier.isStatic(field.getModifiers())
324           &amp;&amp; Modifier.isFinal(field.getModifiers())) {
325         if (field.getGenericType() == field.getType() &amp;&amp; type.isAssignableFrom(field.getType())) {
326           field.setAccessible(true);
327           try {
328             T constant = type.cast(field.get(null));
329             if (constant != null) {
330               return constant;
331             }
332           } catch (IllegalAccessException impossible) {
333             throw new AssertionError(impossible);
334           }
335         }
336 <a name="2"></a>      }
337     }
338     return null;
339   <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
340   private static &lt;T&gt; T createEmptyArray(Class&lt;T&gt; arrayType) {
341     return arrayType.cast(Array.newInstance</b></font>(arrayType.getComponentType(), 0));
342   }
343   private static final class Dummies {
344     public static final class InMemoryPrintStream extends PrintStream {
345       public InMemoryPrintStream() {
346         super(new ByteArrayOutputStream());
347       }
348     }
349     public static final class InMemoryPrintWriter extends PrintWriter {
350       public InMemoryPrintWriter() {
351         super(new StringWriter());
352       }
353     }
354     public static final class DeterministicRandom extends Random {
355       @Keep
356       public DeterministicRandom() {
357         super(0);
358       }
359     }
360     public static final class DummyScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {
361       public DummyScheduledThreadPoolExecutor() {
362         super(1);
363       }
364     }
365     public static final class DummyCountDownLatch extends CountDownLatch {
366       public DummyCountDownLatch() {
367         super(0);
368       }
369     }
370     public static final class DummyRunnable implements Runnable, Serializable {
371       @Override
372       public void run() {}
373     }
374     public static final class DummyThreadFactory implements ThreadFactory, Serializable {
375       @Override
376       public Thread newThread(Runnable r) {
377         return new Thread(r);
378       }
379     }
380     public static final class DummyExecutor implements Executor, Serializable {
381       @Override
382       public void execute(Runnable command) {}
383     }
384   }
385   private static final class NullByteSink extends ByteSink implements Serializable {
386     private static final NullByteSink INSTANCE = new NullByteSink();
387     @Override
388     public OutputStream openStream() {
389       return ByteStreams.nullOutputStream();
390     }
391   }
392   @SuppressWarnings("ComparableType")
393   private static final class ByToString implements Comparable&lt;Object&gt;, Serializable {
394     private static final ByToString INSTANCE = new ByToString();
395 <a name="1"></a>    @Override
396     public int compareTo(Object o) {
397       return toString().compareTo(o.toString());
398     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
399     @Override
400     public String toString() {
401       return "BY_TO_STRING";
402     }
403     private Obj</b></font>ect readResolve() {
404       return INSTANCE;
405     }
406   }
407   private static final class AlwaysEqual extends Ordering&lt;Object&gt; implements Serializable {
408     private static final AlwaysEqual INSTANCE = new AlwaysEqual();
409     @Override
410     public int compare(Object o1, Object o2) {
411       return 0;
412     }
413     @Override
414     public String toString() {
415       return "ALWAYS_EQUAL";
416     }
417     private Object readResolve() {
418       return INSTANCE;
419     }
420   }
421   private ArbitraryInstances() {}
422 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
