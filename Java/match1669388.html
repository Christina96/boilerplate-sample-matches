<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for AbstractIterator.java &amp; TreeMultiset.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractIterator.java &amp; TreeMultiset.java
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractIterator.java (28.846153%)<th>TreeMultiset.java (1.8761727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-178)<td><a href="#" name="0">(461-467)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(155-159)<td><a href="#" name="1">(506-510)</a><td align="center"><font color="#bf0000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(19-65)<td><a href="#" name="2">(33-58)</a><td align="center"><font color="#bf0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="2"></a>
package com.google.common.collect;

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;

import com.google.common.annotations.GwtCompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * This class provides a skeletal implementation of the {@code Iterator} interface, to make this
 * interface easier to implement for certain types of data sources.
 *
 * &lt;p&gt;{@code Iterator} requires its implementations to support querying the end-of-data status
 * without changing the iterator's state, using the {@link #hasNext} method. But many data sources,
 * such as {@link java.io.Reader#read()}, do not expose this information; the only way to discover
 * whether there is any data left is by trying to retrieve it. These types of data sources are
 * ordinarily difficult to write iterators for. But using this class, one must implement only the
 * {@link #computeNext} method, and invoke the {@link #endOfData} method when appropriate.
 *
 * &lt;p&gt;Another example is an iterator that skips over null elements in a backing iterator. This could
 * be implemented as:
 *
 * &lt;pre&gt;{@code
 * public static Iterator&lt;String&gt; skipNulls(final Iterator&lt;String&gt; in) {
 *   return new AbstractIterator&lt;String&gt;() {
 *     protected String computeNext() {
 *       while (in.hasNext()) {
 *         String s = in.next();
 *         if (s != null) {
 *           return s;
 *         }
 *       }
 *       return endOfData();
 *     }
 *   };
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;This class supports iterators that include null elements.
 *
 * @author Kevin Bourrillion
 * @since 2.0
 */
// When making changes to this class, please also update the copy at
// com.google.common.base.AbstractIterator
@</b></font>GwtCompatible
@ElementTypesAreNonnullByDefault
public abstract class AbstractIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
  private State state = State.NOT_READY;

  /** Constructor for use by subclasses. */
  protected AbstractIterator() {}

  private enum State {
    /** We have computed the next element and haven't returned it yet. */
    READY,

    /** We haven't yet computed or have already returned the element. */
    NOT_READY,

    /** We have reached the end of the data and are finished. */
    DONE,

    /** We've suffered an exception and are kaput. */
    FAILED,
  }

  @CheckForNull private T next;

  /**
   * Returns the next element. &lt;b&gt;Note:&lt;/b&gt; the implementation must call {@link #endOfData()} when
   * there are no elements left in the iteration. Failure to do so could result in an infinite loop.
   *
   * &lt;p&gt;The initial invocation of {@link #hasNext()} or {@link #next()} calls this method, as does
   * the first invocation of {@code hasNext} or {@code next} following each successful call to
   * {@code next}. Once the implementation either invokes {@code endOfData} or throws an exception,
   * {@code computeNext} is guaranteed to never be called again.
   *
   * &lt;p&gt;If this method throws an exception, it will propagate outward to the {@code hasNext} or
   * {@code next} invocation that invoked this method. Any further attempts to use the iterator will
   * result in an {@link IllegalStateException}.
   *
   * &lt;p&gt;The implementation of this method may not invoke the {@code hasNext}, {@code next}, or
   * {@link #peek()} methods on this instance; if it does, an {@code IllegalStateException} will
   * result.
   *
   * @return the next element if there was one. If {@code endOfData} was called during execution,
   *     the return value will be ignored.
   * @throws RuntimeException if any unrecoverable error happens. This exception will propagate
   *     outward to the {@code hasNext()}, {@code next()}, or {@code peek()} invocation that invoked
   *     this method. Any further attempts to use the iterator will result in an {@link
   *     IllegalStateException}.
   */
  @CheckForNull
  protected abstract T computeNext();

  /**
   * Implementations of {@link #computeNext} &lt;b&gt;must&lt;/b&gt; invoke this method when there are no
   * elements left in the iteration.
   *
   * @return {@code null}; a convenience so your {@code computeNext} implementation can use the
   *     simple statement {@code return endOfData();}
   */
  @CanIgnoreReturnValue
  @CheckForNull
  protected final T endOfData() {
    state = State.DONE;
    return null;
  }

  @Override
  public final boolean hasNext() {
    checkState(state != State.FAILED);
    switch (state) {
      case DONE:
        return false;
      case READY:
        return true;
      default:
    }
    return tryToComputeNext();
  }

  private boolean tryToComputeNext() {
    state = State.FAILED; // temporary pessimism
    next = computeNext();
    if (state != State.DONE) {
      state = State.READY;
      return true;
    }
    return false;
  }
<a name="1"></a>
  @CanIgnoreReturnValue // TODO(kak): Should we remove this?
  @Override
  <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@ParametricNullness
  public final T next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }</b></font>
    state = State.NOT_READY;
    // Safe because hasNext() ensures that tryToComputeNext() has put a T into `next`.
<a name="0"></a>    T result = uncheckedCastNullableTToT(next);
    next = null;
    return result;
  <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

  /**
   * Returns the next element in the iteration without advancing the iteration, according to the
   * contract of {@link PeekingIterator#peek()}.
   *
   * &lt;p&gt;Implementations of {@code AbstractIterator} that wish to expose this functionality should
   * implement {@code PeekingIterator}.
   */
  @ParametricNullness
  public final T peek() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }</b></font>
    // Safe because hasNext() ensures that tryToComputeNext() has put a T into `next`.
    return uncheckedCastNullableTToT(next);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeMultiset.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.MoreObjects;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<a name="2"></a>import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.Serializable;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A multiset which maintains the ordering of its elements, according to either their natural order
 * or an explicit {@link Comparator}. In all cases, this implementation uses {@link
 * Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to determine
 * equivalence of instances.
 *
 * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; The comparison must be &lt;i&gt;consistent with equals&lt;/i&gt; as explained by the
 * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link
 * java.util.Collection} contract, which is specified in terms of {@link Object#equals}.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset"&gt;{@code Multiset}&lt;/a&gt;.
 *
 * @author Louis Wasserman
 * @author Jared Levy
 * @since 2.0
 */
@</b></font>GwtCompatible(emulated = true)
@ElementTypesAreNonnullByDefault
public final class TreeMultiset&lt;E extends @Nullable Object&gt; extends AbstractSortedMultiset&lt;E&gt;
    implements Serializable {

  /**
   * Creates a new, empty multiset, sorted according to the elements' natural order. All elements
   * inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all
   * such elements must be &lt;i&gt;mutually comparable&lt;/i&gt;: {@code e1.compareTo(e2)} must not throw a
   * {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the
   * user attempts to add an element to the multiset that violates this constraint (for example, the
   * user attempts to add a string element to a set whose elements are integers), the {@code
   * add(Object)} call will throw a {@code ClassCastException}.
   *
   * &lt;p&gt;The type specification is {@code &lt;E extends Comparable&gt;}, instead of the more specific
   * {@code &lt;E extends Comparable&lt;? super E&gt;&gt;}, to support classes defined without generics.
   */
  public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create() {
    return new TreeMultiset&lt;E&gt;(Ordering.natural());
  }

  /**
   * Creates a new, empty multiset, sorted according to the specified comparator. All elements
   * inserted into the multiset must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator:
   * {@code comparator.compare(e1, e2)} must not throw a {@code ClassCastException} for any elements
   * {@code e1} and {@code e2} in the multiset. If the user attempts to add an element to the
   * multiset that violates this constraint, the {@code add(Object)} call will throw a {@code
   * ClassCastException}.
   *
   * @param comparator the comparator that will be used to sort this multiset. A null value
   *     indicates that the elements' &lt;i&gt;natural ordering&lt;/i&gt; should be used.
   */
  @SuppressWarnings("unchecked")
  public static &lt;E extends @Nullable Object&gt; TreeMultiset&lt;E&gt; create(
      @CheckForNull Comparator&lt;? super E&gt; comparator) {
    return (comparator == null)
        ? new TreeMultiset&lt;E&gt;((Comparator) Ordering.natural())
        : new TreeMultiset&lt;E&gt;(comparator);
  }

  /**
   * Creates an empty multiset containing the given initial elements, sorted according to the
   * elements' natural order.
   *
   * &lt;p&gt;This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.
   *
   * &lt;p&gt;The type specification is {@code &lt;E extends Comparable&gt;}, instead of the more specific
   * {@code &lt;E extends Comparable&lt;? super E&gt;&gt;}, to support classes defined without generics.
   */
  public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create(Iterable&lt;? extends E&gt; elements) {
    TreeMultiset&lt;E&gt; multiset = create();
    Iterables.addAll(multiset, elements);
    return multiset;
  }

  private final transient Reference&lt;AvlNode&lt;E&gt;&gt; rootReference;
  private final transient GeneralRange&lt;E&gt; range;
  private final transient AvlNode&lt;E&gt; header;

  TreeMultiset(Reference&lt;AvlNode&lt;E&gt;&gt; rootReference, GeneralRange&lt;E&gt; range, AvlNode&lt;E&gt; endLink) {
    super(range.comparator());
    this.rootReference = rootReference;
    this.range = range;
    this.header = endLink;
  }

  TreeMultiset(Comparator&lt;? super E&gt; comparator) {
    super(comparator);
    this.range = GeneralRange.all(comparator);
    this.header = new AvlNode&lt;&gt;();
    successor(header, header);
    this.rootReference = new Reference&lt;&gt;();
  }

  /** A function which can be summed across a subtree. */
  private enum Aggregate {
    SIZE {
      @Override
      int nodeAggregate(AvlNode&lt;?&gt; node) {
        return node.elemCount;
      }

      @Override
      long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
        return (root == null) ? 0 : root.totalCount;
      }
    },
    DISTINCT {
      @Override
      int nodeAggregate(AvlNode&lt;?&gt; node) {
        return 1;
      }

      @Override
      long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
        return (root == null) ? 0 : root.distinctElements;
      }
    };

    abstract int nodeAggregate(AvlNode&lt;?&gt; node);

    abstract long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root);
  }

  private long aggregateForEntries(Aggregate aggr) {
    AvlNode&lt;E&gt; root = rootReference.get();
    long total = aggr.treeAggregate(root);
    if (range.hasLowerBound()) {
      total -= aggregateBelowRange(aggr, root);
    }
    if (range.hasUpperBound()) {
      total -= aggregateAboveRange(aggr, root);
    }
    return total;
  }

  private long aggregateBelowRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
    if (node == null) {
      return 0;
    }
    // The cast is safe because we call this method only if hasLowerBound().
    int cmp =
        comparator()
            .compare(uncheckedCastNullableTToT(range.getLowerEndpoint()), node.getElement());
    if (cmp &lt; 0) {
      return aggregateBelowRange(aggr, node.left);
    } else if (cmp == 0) {
      switch (range.getLowerBoundType()) {
        case OPEN:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);
        case CLOSED:
          return aggr.treeAggregate(node.left);
        default:
          throw new AssertionError();
      }
    } else {
      return aggr.treeAggregate(node.left)
          + aggr.nodeAggregate(node)
          + aggregateBelowRange(aggr, node.right);
    }
  }

  private long aggregateAboveRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
    if (node == null) {
      return 0;
    }
    // The cast is safe because we call this method only if hasUpperBound().
    int cmp =
        comparator()
            .compare(uncheckedCastNullableTToT(range.getUpperEndpoint()), node.getElement());
    if (cmp &gt; 0) {
      return aggregateAboveRange(aggr, node.right);
    } else if (cmp == 0) {
      switch (range.getUpperBoundType()) {
        case OPEN:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.right);
        case CLOSED:
          return aggr.treeAggregate(node.right);
        default:
          throw new AssertionError();
      }
    } else {
      return aggr.treeAggregate(node.right)
          + aggr.nodeAggregate(node)
          + aggregateAboveRange(aggr, node.left);
    }
  }

  @Override
  public int size() {
    return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE));
  }

  @Override
  int distinctElements() {
    return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));
  }

  static int distinctElements(@CheckForNull AvlNode&lt;?&gt; node) {
    return (node == null) ? 0 : node.distinctElements;
  }

  @Override
  public int count(@CheckForNull Object element) {
    try {
      @SuppressWarnings("unchecked")
      E e = (E) element;
      AvlNode&lt;E&gt; root = rootReference.get();
      if (!range.contains(e) || root == null) {
        return 0;
      }
      return root.count(comparator(), e);
    } catch (ClassCastException | NullPointerException e) {
      return 0;
    }
  }

  @CanIgnoreReturnValue
  @Override
  public int add(@ParametricNullness E element, int occurrences) {
    checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0) {
      return count(element);
    }
    checkArgument(range.contains(element));
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      comparator().compare(element, element);
      AvlNode&lt;E&gt; newRoot = new AvlNode&lt;E&gt;(element, occurrences);
      successor(header, newRoot, header);
      rootReference.checkAndSet(root, newRoot);
      return 0;
    }
    int[] result = new int[1]; // used as a mutable int reference to hold result
    AvlNode&lt;E&gt; newRoot = root.add(comparator(), element, occurrences, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }

  @CanIgnoreReturnValue
  @Override
  public int remove(@CheckForNull Object element, int occurrences) {
    checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0) {
      return count(element);
    }
    AvlNode&lt;E&gt; root = rootReference.get();
    int[] result = new int[1]; // used as a mutable int reference to hold result
    AvlNode&lt;E&gt; newRoot;
    try {
      @SuppressWarnings("unchecked")
      E e = (E) element;
      if (!range.contains(e) || root == null) {
        return 0;
      }
      newRoot = root.remove(comparator(), e, occurrences, result);
    } catch (ClassCastException | NullPointerException e) {
      return 0;
    }
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }

  @CanIgnoreReturnValue
  @Override
  public int setCount(@ParametricNullness E element, int count) {
    checkNonnegative(count, "count");
    if (!range.contains(element)) {
      checkArgument(count == 0);
      return 0;
    }

    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      if (count &gt; 0) {
        add(element, count);
      }
      return 0;
    }
    int[] result = new int[1]; // used as a mutable int reference to hold result
    AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, count, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }

  @CanIgnoreReturnValue
  @Override
  public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
    checkNonnegative(newCount, "newCount");
    checkNonnegative(oldCount, "oldCount");
    checkArgument(range.contains(element));

    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      if (oldCount == 0) {
        if (newCount &gt; 0) {
          add(element, newCount);
        }
        return true;
      } else {
        return false;
      }
    }
    int[] result = new int[1]; // used as a mutable int reference to hold result
    AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, oldCount, newCount, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0] == oldCount;
  }

  @Override
  public void clear() {
    if (!range.hasLowerBound() &amp;&amp; !range.hasUpperBound()) {
      // We can do this in O(n) rather than removing one by one, which could force rebalancing.
      for (AvlNode&lt;E&gt; current = header.succ(); current != header; ) {
        AvlNode&lt;E&gt; next = current.succ();

        current.elemCount = 0;
        // Also clear these fields so that one deleted Entry doesn't retain all elements.
        current.left = null;
        current.right = null;
        current.pred = null;
        current.succ = null;

        current = next;
      }
      successor(header, header);
      rootReference.clear();
    } else {
      // TODO(cpovirk): Perhaps we can optimize in this case, too?
      Iterators.clear(entryIterator());
    }
  }

  private Entry&lt;E&gt; wrapEntry(final AvlNode&lt;E&gt; baseEntry) {
    return new Multisets.AbstractEntry&lt;E&gt;() {
      @Override
      @ParametricNullness
      public E getElement() {
        return baseEntry.getElement();
      }

      @Override
      public int getCount() {
        int result = baseEntry.getCount();
        if (result == 0) {
          return count(getElement());
        } else {
          return result;
        }
      }
    };
  }

  /** Returns the first node in the tree that is in range. */
  @CheckForNull
  private AvlNode&lt;E&gt; firstNode() {
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      return null;
    }
    AvlNode&lt;E&gt; node;
    if (range.hasLowerBound()) {
      // The cast is safe because of the hasLowerBound check.
      E endpoint = uncheckedCastNullableTToT(range.getLowerEndpoint());
      node = root.ceiling(comparator(), endpoint);
      if (node == null) {
        return null;
      }
      if (range.getLowerBoundType() == BoundType.OPEN
          &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
        node = node.succ();
      }
    } else {
      node = header.succ();
    }
    return (node == header || !range.contains(node.getElement())) ? null : node;
  }

  @CheckForNull
  private AvlNode&lt;E&gt; lastNode() {
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      return null;
    }
    AvlNode&lt;E&gt; node;
    if (range.hasUpperBound()) {
      // The cast is safe because of the hasUpperBound check.
      E endpoint = uncheckedCastNullableTToT(range.getUpperEndpoint());
      node = root.floor(comparator(), endpoint);
      if (node == null) {
        return null;
      }
      if (range.getUpperBoundType() == BoundType.OPEN
          &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
        node = node.pred();
      }
    } else {
      node = header.pred();
    }
    return (node == header || !range.contains(node.getElement())) ? null : node;
  }

  @Override
  Iterator&lt;E&gt; elementIterator() {
    return Multisets.elementIterator(entryIterator());
  }

  @Override
  Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
    return new Iterator&lt;Entry&lt;E&gt;&gt;() {
      @CheckForNull AvlNode&lt;E&gt; current = firstNode();
      @CheckForNull Entry&lt;E&gt; prevEntry;

      @Override
      public boolean hasNext() {
        if (current == null) {
          return false;
        } else if (range.tooHigh(current.getElement())) {
          current = null;
          return false;
<a name="0"></a>        } else {
          return true;
        }
      <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

      @Override
      public Entry&lt;E&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }</b></font>
        // requireNonNull is safe because current is only nulled out after iteration is complete.
        Entry&lt;E&gt; result = wrapEntry(requireNonNull(current));
        prevEntry = result;
        if (current.succ() == header) {
          current = null;
        } else {
          current = current.succ();
        }
        return result;
      }

      @Override
      public void remove() {
        checkState(prevEntry != null, "no calls to next() since the last call to remove()");
        setCount(prevEntry.getElement(), 0);
        prevEntry = null;
      }
    };
  }

  @Override
  Iterator&lt;Entry&lt;E&gt;&gt; descendingEntryIterator() {
    return new Iterator&lt;Entry&lt;E&gt;&gt;() {
      @CheckForNull AvlNode&lt;E&gt; current = lastNode();
      @CheckForNull Entry&lt;E&gt; prevEntry = null;

      @Override
      public boolean hasNext() {
        if (current == null) {
          return false;
        } else if (range.tooLow(current.getElement())) {
          current = null;
          return false;
        } else {
          return true;
<a name="1"></a>        }
      }

      <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public Entry&lt;E&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }</b></font>
        // requireNonNull is safe because current is only nulled out after iteration is complete.
        requireNonNull(current);
        Entry&lt;E&gt; result = wrapEntry(current);
        prevEntry = result;
        if (current.pred() == header) {
          current = null;
        } else {
          current = current.pred();
        }
        return result;
      }

      @Override
      public void remove() {
        checkState(prevEntry != null, "no calls to next() since the last call to remove()");
        setCount(prevEntry.getElement(), 0);
        prevEntry = null;
      }
    };
  }

  @Override
  public Iterator&lt;E&gt; iterator() {
    return Multisets.iteratorImpl(this);
  }

  @Override
  public SortedMultiset&lt;E&gt; headMultiset(@ParametricNullness E upperBound, BoundType boundType) {
    return new TreeMultiset&lt;E&gt;(
        rootReference,
        range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),
        header);
  }

  @Override
  public SortedMultiset&lt;E&gt; tailMultiset(@ParametricNullness E lowerBound, BoundType boundType) {
    return new TreeMultiset&lt;E&gt;(
        rootReference,
        range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),
        header);
  }

  private static final class Reference&lt;T&gt; {
    @CheckForNull private T value;

    @CheckForNull
    public T get() {
      return value;
    }

    public void checkAndSet(@CheckForNull T expected, @CheckForNull T newValue) {
      if (value != expected) {
        throw new ConcurrentModificationException();
      }
      value = newValue;
    }

    void clear() {
      value = null;
    }
  }

  private static final class AvlNode&lt;E extends @Nullable Object&gt; {
    /*
     * For "normal" nodes, the type of this field is `E`, not `@Nullable E` (though note that E is a
     * type that can include null, as in a TreeMultiset&lt;@Nullable String&gt;).
     *
     * For the header node, though, this field contains `null`, regardless of the type of the
     * multiset.
     *
     * Most code that operates on an AvlNode never operates on the header node. Such code can access
     * the elem field without a null check by calling getElement().
     */
    @CheckForNull private final E elem;

    // elemCount is 0 iff this node has been deleted.
    private int elemCount;

    private int distinctElements;
    private long totalCount;
    private int height;
    @CheckForNull private AvlNode&lt;E&gt; left;
    @CheckForNull private AvlNode&lt;E&gt; right;
    /*
     * pred and succ are nullable after construction, but we always call successor() to initialize
     * them immediately thereafter.
     *
     * They may be subsequently nulled out by TreeMultiset.clear(). I think that the only place that
     * we can reference a node whose fields have been cleared is inside the iterator (and presumably
     * only under concurrent modification).
     *
     * To access these fields when you know that they are not null, call the pred() and succ()
     * methods, which perform null checks before returning the fields.
     */
    @CheckForNull private AvlNode&lt;E&gt; pred;
    @CheckForNull private AvlNode&lt;E&gt; succ;

    AvlNode(@ParametricNullness E elem, int elemCount) {
      checkArgument(elemCount &gt; 0);
      this.elem = elem;
      this.elemCount = elemCount;
      this.totalCount = elemCount;
      this.distinctElements = 1;
      this.height = 1;
      this.left = null;
      this.right = null;
    }

    /** Constructor for the header node. */
    AvlNode() {
      this.elem = null;
      this.elemCount = 1;
    }

    // For discussion of pred() and succ(), see the comment on the pred and succ fields.

    private AvlNode&lt;E&gt; pred() {
      return requireNonNull(pred);
    }

    private AvlNode&lt;E&gt; succ() {
      return requireNonNull(succ);
    }

    int count(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        return (left == null) ? 0 : left.count(comparator, e);
      } else if (cmp &gt; 0) {
        return (right == null) ? 0 : right.count(comparator, e);
      } else {
        return elemCount;
      }
    }

    private AvlNode&lt;E&gt; addRightChild(@ParametricNullness E e, int count) {
      right = new AvlNode&lt;E&gt;(e, count);
      successor(this, right, succ());
      height = Math.max(2, height);
      distinctElements++;
      totalCount += count;
      return this;
    }

    private AvlNode&lt;E&gt; addLeftChild(@ParametricNullness E e, int count) {
      left = new AvlNode&lt;E&gt;(e, count);
      successor(pred(), left, this);
      height = Math.max(2, height);
      distinctElements++;
      totalCount += count;
      return this;
    }

    AvlNode&lt;E&gt; add(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      /*
       * It speeds things up considerably to unconditionally add count to totalCount here,
       * but that destroys failure atomicity in the case of count overflow. =(
       */
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return addLeftChild(e, count);
        }
        int initHeight = initLeft.height;

        left = initLeft.add(comparator, e, count, result);
        if (result[0] == 0) {
          distinctElements++;
        }
        this.totalCount += count;
        return (left.height == initHeight) ? this : rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return addRightChild(e, count);
        }
        int initHeight = initRight.height;

        right = initRight.add(comparator, e, count, result);
        if (result[0] == 0) {
          distinctElements++;
        }
        this.totalCount += count;
        return (right.height == initHeight) ? this : rebalance();
      }

      // adding count to me!  No rebalance possible.
      result[0] = elemCount;
      long resultCount = (long) elemCount + count;
      checkArgument(resultCount &lt;= Integer.MAX_VALUE);
      this.elemCount += count;
      this.totalCount += count;
      return this;
    }

    @CheckForNull
    AvlNode&lt;E&gt; remove(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return this;
        }

        left = initLeft.remove(comparator, e, count, result);

        if (result[0] &gt; 0) {
          if (count &gt;= result[0]) {
            this.distinctElements--;
            this.totalCount -= result[0];
          } else {
            this.totalCount -= count;
          }
        }
        return (result[0] == 0) ? this : rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return this;
        }

        right = initRight.remove(comparator, e, count, result);

        if (result[0] &gt; 0) {
          if (count &gt;= result[0]) {
            this.distinctElements--;
            this.totalCount -= result[0];
          } else {
            this.totalCount -= count;
          }
        }
        return rebalance();
      }

      // removing count from me!
      result[0] = elemCount;
      if (count &gt;= elemCount) {
        return deleteMe();
      } else {
        this.elemCount -= count;
        this.totalCount -= count;
        return this;
      }
    }

    @CheckForNull
    AvlNode&lt;E&gt; setCount(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return (count &gt; 0) ? addLeftChild(e, count) : this;
        }

        left = initLeft.setCount(comparator, e, count, result);

        if (count == 0 &amp;&amp; result[0] != 0) {
          this.distinctElements--;
        } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
          this.distinctElements++;
        }

        this.totalCount += count - result[0];
        return rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return (count &gt; 0) ? addRightChild(e, count) : this;
        }

        right = initRight.setCount(comparator, e, count, result);

        if (count == 0 &amp;&amp; result[0] != 0) {
          this.distinctElements--;
        } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
          this.distinctElements++;
        }

        this.totalCount += count - result[0];
        return rebalance();
      }

      // setting my count
      result[0] = elemCount;
      if (count == 0) {
        return deleteMe();
      }
      this.totalCount += count - elemCount;
      this.elemCount = count;
      return this;
    }

    @CheckForNull
    AvlNode&lt;E&gt; setCount(
        Comparator&lt;? super E&gt; comparator,
        @ParametricNullness E e,
        int expectedCount,
        int newCount,
        int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
            return addLeftChild(e, newCount);
          }
          return this;
        }

        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);

        if (result[0] == expectedCount) {
          if (newCount == 0 &amp;&amp; result[0] != 0) {
            this.distinctElements--;
          } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
            this.distinctElements++;
          }
          this.totalCount += newCount - result[0];
        }
        return rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
            return addRightChild(e, newCount);
          }
          return this;
        }

        right = initRight.setCount(comparator, e, expectedCount, newCount, result);

        if (result[0] == expectedCount) {
          if (newCount == 0 &amp;&amp; result[0] != 0) {
            this.distinctElements--;
          } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
            this.distinctElements++;
          }
          this.totalCount += newCount - result[0];
        }
        return rebalance();
      }

      // setting my count
      result[0] = elemCount;
      if (expectedCount == elemCount) {
        if (newCount == 0) {
          return deleteMe();
        }
        this.totalCount += newCount - elemCount;
        this.elemCount = newCount;
      }
      return this;
    }

    @CheckForNull
    private AvlNode&lt;E&gt; deleteMe() {
      int oldElemCount = this.elemCount;
      this.elemCount = 0;
      successor(pred(), succ());
      if (left == null) {
        return right;
      } else if (right == null) {
        return left;
      } else if (left.height &gt;= right.height) {
        AvlNode&lt;E&gt; newTop = pred();
        // newTop is the maximum node in my left subtree
        newTop.left = left.removeMax(newTop);
        newTop.right = right;
        newTop.distinctElements = distinctElements - 1;
        newTop.totalCount = totalCount - oldElemCount;
        return newTop.rebalance();
      } else {
        AvlNode&lt;E&gt; newTop = succ();
        newTop.right = right.removeMin(newTop);
        newTop.left = left;
        newTop.distinctElements = distinctElements - 1;
        newTop.totalCount = totalCount - oldElemCount;
        return newTop.rebalance();
      }
    }

    // Removes the minimum node from this subtree to be reused elsewhere
    @CheckForNull
    private AvlNode&lt;E&gt; removeMin(AvlNode&lt;E&gt; node) {
      if (left == null) {
        return right;
      } else {
        left = left.removeMin(node);
        distinctElements--;
        totalCount -= node.elemCount;
        return rebalance();
      }
    }

    // Removes the maximum node from this subtree to be reused elsewhere
    @CheckForNull
    private AvlNode&lt;E&gt; removeMax(AvlNode&lt;E&gt; node) {
      if (right == null) {
        return left;
      } else {
        right = right.removeMax(node);
        distinctElements--;
        totalCount -= node.elemCount;
        return rebalance();
      }
    }

    private void recomputeMultiset() {
      this.distinctElements =
          1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);
      this.totalCount = elemCount + totalCount(left) + totalCount(right);
    }

    private void recomputeHeight() {
      this.height = 1 + Math.max(height(left), height(right));
    }

    private void recompute() {
      recomputeMultiset();
      recomputeHeight();
    }

    private AvlNode&lt;E&gt; rebalance() {
      switch (balanceFactor()) {
        case -2:
          // requireNonNull is safe because right must exist in order to get a negative factor.
          requireNonNull(right);
          if (right.balanceFactor() &gt; 0) {
            right = right.rotateRight();
          }
          return rotateLeft();
        case 2:
          // requireNonNull is safe because left must exist in order to get a positive factor.
          requireNonNull(left);
          if (left.balanceFactor() &lt; 0) {
            left = left.rotateLeft();
          }
          return rotateRight();
        default:
          recomputeHeight();
          return this;
      }
    }

    private int balanceFactor() {
      return height(left) - height(right);
    }

    private AvlNode&lt;E&gt; rotateLeft() {
      checkState(right != null);
      AvlNode&lt;E&gt; newTop = right;
      this.right = newTop.left;
      newTop.left = this;
      newTop.totalCount = this.totalCount;
      newTop.distinctElements = this.distinctElements;
      this.recompute();
      newTop.recomputeHeight();
      return newTop;
    }

    private AvlNode&lt;E&gt; rotateRight() {
      checkState(left != null);
      AvlNode&lt;E&gt; newTop = left;
      this.left = newTop.right;
      newTop.right = this;
      newTop.totalCount = this.totalCount;
      newTop.distinctElements = this.distinctElements;
      this.recompute();
      newTop.recomputeHeight();
      return newTop;
    }

    private static long totalCount(@CheckForNull AvlNode&lt;?&gt; node) {
      return (node == null) ? 0 : node.totalCount;
    }

    private static int height(@CheckForNull AvlNode&lt;?&gt; node) {
      return (node == null) ? 0 : node.height;
    }

    @CheckForNull
    private AvlNode&lt;E&gt; ceiling(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);
      } else if (cmp == 0) {
        return this;
      } else {
        return (right == null) ? null : right.ceiling(comparator, e);
      }
    }

    @CheckForNull
    private AvlNode&lt;E&gt; floor(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &gt; 0) {
        return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);
      } else if (cmp == 0) {
        return this;
      } else {
        return (left == null) ? null : left.floor(comparator, e);
      }
    }

    @ParametricNullness
    E getElement() {
      // For discussion of this cast, see the comment on the elem field.
      return uncheckedCastNullableTToT(elem);
    }

    int getCount() {
      return elemCount;
    }

    @Override
    public String toString() {
      return Multisets.immutableEntry(getElement(), getCount()).toString();
    }
  }

  private static &lt;T extends @Nullable Object&gt; void successor(AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b) {
    a.succ = b;
    b.pred = a;
  }

  private static &lt;T extends @Nullable Object&gt; void successor(
      AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b, AvlNode&lt;T&gt; c) {
    successor(a, b);
    successor(b, c);
  }

  /*
   * TODO(jlevy): Decide whether entrySet() should return entries with an equals() method that
   * calls the comparator to compare the two keys. If that change is made,
   * AbstractMultiset.equals() can simply check whether two multisets have equal entry sets.
   */

  /**
   * @serialData the comparator, the number of distinct elements, the first element, its count, the
   *     second element, its count, and so on
   */
  @GwtIncompatible // java.io.ObjectOutputStream
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeObject(elementSet().comparator());
    Serialization.writeMultiset(this, stream);
  }

  @GwtIncompatible // java.io.ObjectInputStream
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    @SuppressWarnings("unchecked")
    // reading data stored by writeObject
    Comparator&lt;? super E&gt; comparator = (Comparator&lt;? super E&gt;) stream.readObject();
    Serialization.getFieldSetter(AbstractSortedMultiset.class, "comparator").set(this, comparator);
    Serialization.getFieldSetter(TreeMultiset.class, "range")
        .set(this, GeneralRange.all(comparator));
    Serialization.getFieldSetter(TreeMultiset.class, "rootReference")
        .set(this, new Reference&lt;AvlNode&lt;E&gt;&gt;());
    AvlNode&lt;E&gt; header = new AvlNode&lt;&gt;();
    Serialization.getFieldSetter(TreeMultiset.class, "header").set(this, header);
    successor(header, header);
    Serialization.populateMultiset(this, stream);
  }

  @GwtIncompatible // not needed in emulated source
  private static final long serialVersionUID = 1;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
