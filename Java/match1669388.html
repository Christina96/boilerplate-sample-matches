<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractIterator.java &amp; TreeMultiset.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractIterator.java &amp; TreeMultiset.java
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractIterator.java (28.846153%)<th>TreeMultiset.java (1.8761727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-178)<td><a href="#" name="0">(461-467)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(155-159)<td><a href="#" name="1">(506-510)</a><td align="center"><font color="#bf0000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(19-65)<td><a href="#" name="2">(33-58)</a><td align="center"><font color="#bf0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="2"></a>
2 package com.google.common.collect;
3 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkState;
4 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
5 import com.google.common.annotations.GwtCompatible;
6 import com.google.errorprone.annotations.CanIgnoreReturnValue;
7 import java.util.NoSuchElementException;
8 import javax.annotation.CheckForNull;
9 import org.checkerframework.checker.nullness.qual.Nullable;
10 @</b></font>GwtCompatible
11 @ElementTypesAreNonnullByDefault
12 public abstract class AbstractIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
13   private State state = State.NOT_READY;
14   protected AbstractIterator() {}
15   private enum State {
16     READY,
17     NOT_READY,
18     DONE,
19     FAILED,
20   }
21   @CheckForNull private T next;
22   @CheckForNull
23   protected abstract T computeNext();
24   @CanIgnoreReturnValue
25   @CheckForNull
26   protected final T endOfData() {
27     state = State.DONE;
28     return null;
29   }
30   @Override
31   public final boolean hasNext() {
32     checkState(state != State.FAILED);
33     switch (state) {
34       case DONE:
35         return false;
36       case READY:
37         return true;
38       default:
39     }
40     return tryToComputeNext();
41   }
42   private boolean tryToComputeNext() {
43     state = State.FAILED;     next = computeNext();
44     if (state != State.DONE) {
45       state = State.READY;
46       return true;
47     }
48     return false;
49   }
50 <a name="1"></a>
51   @CanIgnoreReturnValue   @Override
52   <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@ParametricNullness
53   public final T next() {
54     if (!hasNext()) {
55       throw new NoSuchElementException();
56     }</b></font>
57     state = State.NOT_READY;
58 <a name="0"></a>    T result = uncheckedCastNullableTToT(next);
59     next = null;
60     return result;
61   <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
62   @ParametricNullness
63   public final T peek() {
64     if (!hasNext()) {
65       throw new NoSuchElementException();
66     }</b></font>
67     return uncheckedCastNullableTToT(next);
68   }
69 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeMultiset.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkState;
4 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
5 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
6 import static java.util.Objects.requireNonNull;
7 import com.google.common.annotations.GwtCompatible;
8 import com.google.common.annotations.GwtIncompatible;
9 import com.google.common.base.MoreObjects;
10 import com.google.common.primitives.Ints;
11 import com.google.errorprone.annotations.CanIgnoreReturnValue;
12 <a name="2"></a>import java.io.IOException;
13 import java.io.ObjectInputStream;
14 import java.io.ObjectOutputStream;
15 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.Serializable;
16 import java.util.Comparator;
17 import java.util.ConcurrentModificationException;
18 import java.util.Iterator;
19 import java.util.NoSuchElementException;
20 import javax.annotation.CheckForNull;
21 import org.checkerframework.checker.nullness.qual.Nullable;
22 @</b></font>GwtCompatible(emulated = true)
23 @ElementTypesAreNonnullByDefault
24 public final class TreeMultiset&lt;E extends @Nullable Object&gt; extends AbstractSortedMultiset&lt;E&gt;
25     implements Serializable {
26   public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create() {
27     return new TreeMultiset&lt;E&gt;(Ordering.natural());
28   }
29   @SuppressWarnings("unchecked")
30   public static &lt;E extends @Nullable Object&gt; TreeMultiset&lt;E&gt; create(
31       @CheckForNull Comparator&lt;? super E&gt; comparator) {
32     return (comparator == null)
33         ? new TreeMultiset&lt;E&gt;((Comparator) Ordering.natural())
34         : new TreeMultiset&lt;E&gt;(comparator);
35   }
36   public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create(Iterable&lt;? extends E&gt; elements) {
37     TreeMultiset&lt;E&gt; multiset = create();
38     Iterables.addAll(multiset, elements);
39     return multiset;
40   }
41   private final transient Reference&lt;AvlNode&lt;E&gt;&gt; rootReference;
42   private final transient GeneralRange&lt;E&gt; range;
43   private final transient AvlNode&lt;E&gt; header;
44   TreeMultiset(Reference&lt;AvlNode&lt;E&gt;&gt; rootReference, GeneralRange&lt;E&gt; range, AvlNode&lt;E&gt; endLink) {
45     super(range.comparator());
46     this.rootReference = rootReference;
47     this.range = range;
48     this.header = endLink;
49   }
50   TreeMultiset(Comparator&lt;? super E&gt; comparator) {
51     super(comparator);
52     this.range = GeneralRange.all(comparator);
53     this.header = new AvlNode&lt;&gt;();
54     successor(header, header);
55     this.rootReference = new Reference&lt;&gt;();
56   }
57   private enum Aggregate {
58     SIZE {
59       @Override
60       int nodeAggregate(AvlNode&lt;?&gt; node) {
61         return node.elemCount;
62       }
63       @Override
64       long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
65         return (root == null) ? 0 : root.totalCount;
66       }
67     },
68     DISTINCT {
69       @Override
70       int nodeAggregate(AvlNode&lt;?&gt; node) {
71         return 1;
72       }
73       @Override
74       long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
75         return (root == null) ? 0 : root.distinctElements;
76       }
77     };
78     abstract int nodeAggregate(AvlNode&lt;?&gt; node);
79     abstract long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root);
80   }
81   private long aggregateForEntries(Aggregate aggr) {
82     AvlNode&lt;E&gt; root = rootReference.get();
83     long total = aggr.treeAggregate(root);
84     if (range.hasLowerBound()) {
85       total -= aggregateBelowRange(aggr, root);
86     }
87     if (range.hasUpperBound()) {
88       total -= aggregateAboveRange(aggr, root);
89     }
90     return total;
91   }
92   private long aggregateBelowRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
93     if (node == null) {
94       return 0;
95     }
96     int cmp =
97         comparator()
98             .compare(uncheckedCastNullableTToT(range.getLowerEndpoint()), node.getElement());
99     if (cmp &lt; 0) {
100       return aggregateBelowRange(aggr, node.left);
101     } else if (cmp == 0) {
102       switch (range.getLowerBoundType()) {
103         case OPEN:
104           return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);
105         case CLOSED:
106           return aggr.treeAggregate(node.left);
107         default:
108           throw new AssertionError();
109       }
110     } else {
111       return aggr.treeAggregate(node.left)
112           + aggr.nodeAggregate(node)
113           + aggregateBelowRange(aggr, node.right);
114     }
115   }
116   private long aggregateAboveRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
117     if (node == null) {
118       return 0;
119     }
120     int cmp =
121         comparator()
122             .compare(uncheckedCastNullableTToT(range.getUpperEndpoint()), node.getElement());
123     if (cmp &gt; 0) {
124       return aggregateAboveRange(aggr, node.right);
125     } else if (cmp == 0) {
126       switch (range.getUpperBoundType()) {
127         case OPEN:
128           return aggr.nodeAggregate(node) + aggr.treeAggregate(node.right);
129         case CLOSED:
130           return aggr.treeAggregate(node.right);
131         default:
132           throw new AssertionError();
133       }
134     } else {
135       return aggr.treeAggregate(node.right)
136           + aggr.nodeAggregate(node)
137           + aggregateAboveRange(aggr, node.left);
138     }
139   }
140   @Override
141   public int size() {
142     return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE));
143   }
144   @Override
145   int distinctElements() {
146     return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));
147   }
148   static int distinctElements(@CheckForNull AvlNode&lt;?&gt; node) {
149     return (node == null) ? 0 : node.distinctElements;
150   }
151   @Override
152   public int count(@CheckForNull Object element) {
153     try {
154       @SuppressWarnings("unchecked")
155       E e = (E) element;
156       AvlNode&lt;E&gt; root = rootReference.get();
157       if (!range.contains(e) || root == null) {
158         return 0;
159       }
160       return root.count(comparator(), e);
161     } catch (ClassCastException | NullPointerException e) {
162       return 0;
163     }
164   }
165   @CanIgnoreReturnValue
166   @Override
167   public int add(@ParametricNullness E element, int occurrences) {
168     checkNonnegative(occurrences, "occurrences");
169     if (occurrences == 0) {
170       return count(element);
171     }
172     checkArgument(range.contains(element));
173     AvlNode&lt;E&gt; root = rootReference.get();
174     if (root == null) {
175       comparator().compare(element, element);
176       AvlNode&lt;E&gt; newRoot = new AvlNode&lt;E&gt;(element, occurrences);
177       successor(header, newRoot, header);
178       rootReference.checkAndSet(root, newRoot);
179       return 0;
180     }
181     int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.add(comparator(), element, occurrences, result);
182     rootReference.checkAndSet(root, newRoot);
183     return result[0];
184   }
185   @CanIgnoreReturnValue
186   @Override
187   public int remove(@CheckForNull Object element, int occurrences) {
188     checkNonnegative(occurrences, "occurrences");
189     if (occurrences == 0) {
190       return count(element);
191     }
192     AvlNode&lt;E&gt; root = rootReference.get();
193     int[] result = new int[1];     AvlNode&lt;E&gt; newRoot;
194     try {
195       @SuppressWarnings("unchecked")
196       E e = (E) element;
197       if (!range.contains(e) || root == null) {
198         return 0;
199       }
200       newRoot = root.remove(comparator(), e, occurrences, result);
201     } catch (ClassCastException | NullPointerException e) {
202       return 0;
203     }
204     rootReference.checkAndSet(root, newRoot);
205     return result[0];
206   }
207   @CanIgnoreReturnValue
208   @Override
209   public int setCount(@ParametricNullness E element, int count) {
210     checkNonnegative(count, "count");
211     if (!range.contains(element)) {
212       checkArgument(count == 0);
213       return 0;
214     }
215     AvlNode&lt;E&gt; root = rootReference.get();
216     if (root == null) {
217       if (count &gt; 0) {
218         add(element, count);
219       }
220       return 0;
221     }
222     int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, count, result);
223     rootReference.checkAndSet(root, newRoot);
224     return result[0];
225   }
226   @CanIgnoreReturnValue
227   @Override
228   public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
229     checkNonnegative(newCount, "newCount");
230     checkNonnegative(oldCount, "oldCount");
231     checkArgument(range.contains(element));
232     AvlNode&lt;E&gt; root = rootReference.get();
233     if (root == null) {
234       if (oldCount == 0) {
235         if (newCount &gt; 0) {
236           add(element, newCount);
237         }
238         return true;
239       } else {
240         return false;
241       }
242     }
243     int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, oldCount, newCount, result);
244     rootReference.checkAndSet(root, newRoot);
245     return result[0] == oldCount;
246   }
247   @Override
248   public void clear() {
249     if (!range.hasLowerBound() &amp;&amp; !range.hasUpperBound()) {
250       for (AvlNode&lt;E&gt; current = header.succ(); current != header; ) {
251         AvlNode&lt;E&gt; next = current.succ();
252         current.elemCount = 0;
253         current.left = null;
254         current.right = null;
255         current.pred = null;
256         current.succ = null;
257         current = next;
258       }
259       successor(header, header);
260       rootReference.clear();
261     } else {
262       Iterators.clear(entryIterator());
263     }
264   }
265   private Entry&lt;E&gt; wrapEntry(final AvlNode&lt;E&gt; baseEntry) {
266     return new Multisets.AbstractEntry&lt;E&gt;() {
267       @Override
268       @ParametricNullness
269       public E getElement() {
270         return baseEntry.getElement();
271       }
272       @Override
273       public int getCount() {
274         int result = baseEntry.getCount();
275         if (result == 0) {
276           return count(getElement());
277         } else {
278           return result;
279         }
280       }
281     };
282   }
283   @CheckForNull
284   private AvlNode&lt;E&gt; firstNode() {
285     AvlNode&lt;E&gt; root = rootReference.get();
286     if (root == null) {
287       return null;
288     }
289     AvlNode&lt;E&gt; node;
290     if (range.hasLowerBound()) {
291       E endpoint = uncheckedCastNullableTToT(range.getLowerEndpoint());
292       node = root.ceiling(comparator(), endpoint);
293       if (node == null) {
294         return null;
295       }
296       if (range.getLowerBoundType() == BoundType.OPEN
297           &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
298         node = node.succ();
299       }
300     } else {
301       node = header.succ();
302     }
303     return (node == header || !range.contains(node.getElement())) ? null : node;
304   }
305   @CheckForNull
306   private AvlNode&lt;E&gt; lastNode() {
307     AvlNode&lt;E&gt; root = rootReference.get();
308     if (root == null) {
309       return null;
310     }
311     AvlNode&lt;E&gt; node;
312     if (range.hasUpperBound()) {
313       E endpoint = uncheckedCastNullableTToT(range.getUpperEndpoint());
314       node = root.floor(comparator(), endpoint);
315       if (node == null) {
316         return null;
317       }
318       if (range.getUpperBoundType() == BoundType.OPEN
319           &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
320         node = node.pred();
321       }
322     } else {
323       node = header.pred();
324     }
325     return (node == header || !range.contains(node.getElement())) ? null : node;
326   }
327   @Override
328   Iterator&lt;E&gt; elementIterator() {
329     return Multisets.elementIterator(entryIterator());
330   }
331   @Override
332   Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
333     return new Iterator&lt;Entry&lt;E&gt;&gt;() {
334       @CheckForNull AvlNode&lt;E&gt; current = firstNode();
335       @CheckForNull Entry&lt;E&gt; prevEntry;
336       @Override
337       public boolean hasNext() {
338         if (current == null) {
339           return false;
340         } else if (range.tooHigh(current.getElement())) {
341           current = null;
342           return false;
343 <a name="0"></a>        } else {
344           return true;
345         }
346       <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
347       @Override
348       public Entry&lt;E&gt; next() {
349         if (!hasNext()) {
350           throw new NoSuchElementException();
351         }</b></font>
352         Entry&lt;E&gt; result = wrapEntry(requireNonNull(current));
353         prevEntry = result;
354         if (current.succ() == header) {
355           current = null;
356         } else {
357           current = current.succ();
358         }
359         return result;
360       }
361       @Override
362       public void remove() {
363         checkState(prevEntry != null, "no calls to next() since the last call to remove()");
364         setCount(prevEntry.getElement(), 0);
365         prevEntry = null;
366       }
367     };
368   }
369   @Override
370   Iterator&lt;Entry&lt;E&gt;&gt; descendingEntryIterator() {
371     return new Iterator&lt;Entry&lt;E&gt;&gt;() {
372       @CheckForNull AvlNode&lt;E&gt; current = lastNode();
373       @CheckForNull Entry&lt;E&gt; prevEntry = null;
374       @Override
375       public boolean hasNext() {
376         if (current == null) {
377           return false;
378         } else if (range.tooLow(current.getElement())) {
379           current = null;
380           return false;
381         } else {
382           return true;
383 <a name="1"></a>        }
384       }
385       <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
386       public Entry&lt;E&gt; next() {
387         if (!hasNext()) {
388           throw new NoSuchElementException();
389         }</b></font>
390         requireNonNull(current);
391         Entry&lt;E&gt; result = wrapEntry(current);
392         prevEntry = result;
393         if (current.pred() == header) {
394           current = null;
395         } else {
396           current = current.pred();
397         }
398         return result;
399       }
400       @Override
401       public void remove() {
402         checkState(prevEntry != null, "no calls to next() since the last call to remove()");
403         setCount(prevEntry.getElement(), 0);
404         prevEntry = null;
405       }
406     };
407   }
408   @Override
409   public Iterator&lt;E&gt; iterator() {
410     return Multisets.iteratorImpl(this);
411   }
412   @Override
413   public SortedMultiset&lt;E&gt; headMultiset(@ParametricNullness E upperBound, BoundType boundType) {
414     return new TreeMultiset&lt;E&gt;(
415         rootReference,
416         range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),
417         header);
418   }
419   @Override
420   public SortedMultiset&lt;E&gt; tailMultiset(@ParametricNullness E lowerBound, BoundType boundType) {
421     return new TreeMultiset&lt;E&gt;(
422         rootReference,
423         range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),
424         header);
425   }
426   private static final class Reference&lt;T&gt; {
427     @CheckForNull private T value;
428     @CheckForNull
429     public T get() {
430       return value;
431     }
432     public void checkAndSet(@CheckForNull T expected, @CheckForNull T newValue) {
433       if (value != expected) {
434         throw new ConcurrentModificationException();
435       }
436       value = newValue;
437     }
438     void clear() {
439       value = null;
440     }
441   }
442   private static final class AvlNode&lt;E extends @Nullable Object&gt; {
443     @CheckForNull private final E elem;
444     private int elemCount;
445     private int distinctElements;
446     private long totalCount;
447     private int height;
448     @CheckForNull private AvlNode&lt;E&gt; left;
449     @CheckForNull private AvlNode&lt;E&gt; right;
450     @CheckForNull private AvlNode&lt;E&gt; pred;
451     @CheckForNull private AvlNode&lt;E&gt; succ;
452     AvlNode(@ParametricNullness E elem, int elemCount) {
453       checkArgument(elemCount &gt; 0);
454       this.elem = elem;
455       this.elemCount = elemCount;
456       this.totalCount = elemCount;
457       this.distinctElements = 1;
458       this.height = 1;
459       this.left = null;
460       this.right = null;
461     }
462     AvlNode() {
463       this.elem = null;
464       this.elemCount = 1;
465     }
466     private AvlNode&lt;E&gt; pred() {
467       return requireNonNull(pred);
468     }
469     private AvlNode&lt;E&gt; succ() {
470       return requireNonNull(succ);
471     }
472     int count(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
473       int cmp = comparator.compare(e, getElement());
474       if (cmp &lt; 0) {
475         return (left == null) ? 0 : left.count(comparator, e);
476       } else if (cmp &gt; 0) {
477         return (right == null) ? 0 : right.count(comparator, e);
478       } else {
479         return elemCount;
480       }
481     }
482     private AvlNode&lt;E&gt; addRightChild(@ParametricNullness E e, int count) {
483       right = new AvlNode&lt;E&gt;(e, count);
484       successor(this, right, succ());
485       height = Math.max(2, height);
486       distinctElements++;
487       totalCount += count;
488       return this;
489     }
490     private AvlNode&lt;E&gt; addLeftChild(@ParametricNullness E e, int count) {
491       left = new AvlNode&lt;E&gt;(e, count);
492       successor(pred(), left, this);
493       height = Math.max(2, height);
494       distinctElements++;
495       totalCount += count;
496       return this;
497     }
498     AvlNode&lt;E&gt; add(
499         Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
500       int cmp = comparator.compare(e, getElement());
501       if (cmp &lt; 0) {
502         AvlNode&lt;E&gt; initLeft = left;
503         if (initLeft == null) {
504           result[0] = 0;
505           return addLeftChild(e, count);
506         }
507         int initHeight = initLeft.height;
508         left = initLeft.add(comparator, e, count, result);
509         if (result[0] == 0) {
510           distinctElements++;
511         }
512         this.totalCount += count;
513         return (left.height == initHeight) ? this : rebalance();
514       } else if (cmp &gt; 0) {
515         AvlNode&lt;E&gt; initRight = right;
516         if (initRight == null) {
517           result[0] = 0;
518           return addRightChild(e, count);
519         }
520         int initHeight = initRight.height;
521         right = initRight.add(comparator, e, count, result);
522         if (result[0] == 0) {
523           distinctElements++;
524         }
525         this.totalCount += count;
526         return (right.height == initHeight) ? this : rebalance();
527       }
528       result[0] = elemCount;
529       long resultCount = (long) elemCount + count;
530       checkArgument(resultCount &lt;= Integer.MAX_VALUE);
531       this.elemCount += count;
532       this.totalCount += count;
533       return this;
534     }
535     @CheckForNull
536     AvlNode&lt;E&gt; remove(
537         Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
538       int cmp = comparator.compare(e, getElement());
539       if (cmp &lt; 0) {
540         AvlNode&lt;E&gt; initLeft = left;
541         if (initLeft == null) {
542           result[0] = 0;
543           return this;
544         }
545         left = initLeft.remove(comparator, e, count, result);
546         if (result[0] &gt; 0) {
547           if (count &gt;= result[0]) {
548             this.distinctElements--;
549             this.totalCount -= result[0];
550           } else {
551             this.totalCount -= count;
552           }
553         }
554         return (result[0] == 0) ? this : rebalance();
555       } else if (cmp &gt; 0) {
556         AvlNode&lt;E&gt; initRight = right;
557         if (initRight == null) {
558           result[0] = 0;
559           return this;
560         }
561         right = initRight.remove(comparator, e, count, result);
562         if (result[0] &gt; 0) {
563           if (count &gt;= result[0]) {
564             this.distinctElements--;
565             this.totalCount -= result[0];
566           } else {
567             this.totalCount -= count;
568           }
569         }
570         return rebalance();
571       }
572       result[0] = elemCount;
573       if (count &gt;= elemCount) {
574         return deleteMe();
575       } else {
576         this.elemCount -= count;
577         this.totalCount -= count;
578         return this;
579       }
580     }
581     @CheckForNull
582     AvlNode&lt;E&gt; setCount(
583         Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
584       int cmp = comparator.compare(e, getElement());
585       if (cmp &lt; 0) {
586         AvlNode&lt;E&gt; initLeft = left;
587         if (initLeft == null) {
588           result[0] = 0;
589           return (count &gt; 0) ? addLeftChild(e, count) : this;
590         }
591         left = initLeft.setCount(comparator, e, count, result);
592         if (count == 0 &amp;&amp; result[0] != 0) {
593           this.distinctElements--;
594         } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
595           this.distinctElements++;
596         }
597         this.totalCount += count - result[0];
598         return rebalance();
599       } else if (cmp &gt; 0) {
600         AvlNode&lt;E&gt; initRight = right;
601         if (initRight == null) {
602           result[0] = 0;
603           return (count &gt; 0) ? addRightChild(e, count) : this;
604         }
605         right = initRight.setCount(comparator, e, count, result);
606         if (count == 0 &amp;&amp; result[0] != 0) {
607           this.distinctElements--;
608         } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
609           this.distinctElements++;
610         }
611         this.totalCount += count - result[0];
612         return rebalance();
613       }
614       result[0] = elemCount;
615       if (count == 0) {
616         return deleteMe();
617       }
618       this.totalCount += count - elemCount;
619       this.elemCount = count;
620       return this;
621     }
622     @CheckForNull
623     AvlNode&lt;E&gt; setCount(
624         Comparator&lt;? super E&gt; comparator,
625         @ParametricNullness E e,
626         int expectedCount,
627         int newCount,
628         int[] result) {
629       int cmp = comparator.compare(e, getElement());
630       if (cmp &lt; 0) {
631         AvlNode&lt;E&gt; initLeft = left;
632         if (initLeft == null) {
633           result[0] = 0;
634           if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
635             return addLeftChild(e, newCount);
636           }
637           return this;
638         }
639         left = initLeft.setCount(comparator, e, expectedCount, newCount, result);
640         if (result[0] == expectedCount) {
641           if (newCount == 0 &amp;&amp; result[0] != 0) {
642             this.distinctElements--;
643           } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
644             this.distinctElements++;
645           }
646           this.totalCount += newCount - result[0];
647         }
648         return rebalance();
649       } else if (cmp &gt; 0) {
650         AvlNode&lt;E&gt; initRight = right;
651         if (initRight == null) {
652           result[0] = 0;
653           if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
654             return addRightChild(e, newCount);
655           }
656           return this;
657         }
658         right = initRight.setCount(comparator, e, expectedCount, newCount, result);
659         if (result[0] == expectedCount) {
660           if (newCount == 0 &amp;&amp; result[0] != 0) {
661             this.distinctElements--;
662           } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
663             this.distinctElements++;
664           }
665           this.totalCount += newCount - result[0];
666         }
667         return rebalance();
668       }
669       result[0] = elemCount;
670       if (expectedCount == elemCount) {
671         if (newCount == 0) {
672           return deleteMe();
673         }
674         this.totalCount += newCount - elemCount;
675         this.elemCount = newCount;
676       }
677       return this;
678     }
679     @CheckForNull
680     private AvlNode&lt;E&gt; deleteMe() {
681       int oldElemCount = this.elemCount;
682       this.elemCount = 0;
683       successor(pred(), succ());
684       if (left == null) {
685         return right;
686       } else if (right == null) {
687         return left;
688       } else if (left.height &gt;= right.height) {
689         AvlNode&lt;E&gt; newTop = pred();
690         newTop.left = left.removeMax(newTop);
691         newTop.right = right;
692         newTop.distinctElements = distinctElements - 1;
693         newTop.totalCount = totalCount - oldElemCount;
694         return newTop.rebalance();
695       } else {
696         AvlNode&lt;E&gt; newTop = succ();
697         newTop.right = right.removeMin(newTop);
698         newTop.left = left;
699         newTop.distinctElements = distinctElements - 1;
700         newTop.totalCount = totalCount - oldElemCount;
701         return newTop.rebalance();
702       }
703     }
704     @CheckForNull
705     private AvlNode&lt;E&gt; removeMin(AvlNode&lt;E&gt; node) {
706       if (left == null) {
707         return right;
708       } else {
709         left = left.removeMin(node);
710         distinctElements--;
711         totalCount -= node.elemCount;
712         return rebalance();
713       }
714     }
715     @CheckForNull
716     private AvlNode&lt;E&gt; removeMax(AvlNode&lt;E&gt; node) {
717       if (right == null) {
718         return left;
719       } else {
720         right = right.removeMax(node);
721         distinctElements--;
722         totalCount -= node.elemCount;
723         return rebalance();
724       }
725     }
726     private void recomputeMultiset() {
727       this.distinctElements =
728           1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);
729       this.totalCount = elemCount + totalCount(left) + totalCount(right);
730     }
731     private void recomputeHeight() {
732       this.height = 1 + Math.max(height(left), height(right));
733     }
734     private void recompute() {
735       recomputeMultiset();
736       recomputeHeight();
737     }
738     private AvlNode&lt;E&gt; rebalance() {
739       switch (balanceFactor()) {
740         case -2:
741           requireNonNull(right);
742           if (right.balanceFactor() &gt; 0) {
743             right = right.rotateRight();
744           }
745           return rotateLeft();
746         case 2:
747           requireNonNull(left);
748           if (left.balanceFactor() &lt; 0) {
749             left = left.rotateLeft();
750           }
751           return rotateRight();
752         default:
753           recomputeHeight();
754           return this;
755       }
756     }
757     private int balanceFactor() {
758       return height(left) - height(right);
759     }
760     private AvlNode&lt;E&gt; rotateLeft() {
761       checkState(right != null);
762       AvlNode&lt;E&gt; newTop = right;
763       this.right = newTop.left;
764       newTop.left = this;
765       newTop.totalCount = this.totalCount;
766       newTop.distinctElements = this.distinctElements;
767       this.recompute();
768       newTop.recomputeHeight();
769       return newTop;
770     }
771     private AvlNode&lt;E&gt; rotateRight() {
772       checkState(left != null);
773       AvlNode&lt;E&gt; newTop = left;
774       this.left = newTop.right;
775       newTop.right = this;
776       newTop.totalCount = this.totalCount;
777       newTop.distinctElements = this.distinctElements;
778       this.recompute();
779       newTop.recomputeHeight();
780       return newTop;
781     }
782     private static long totalCount(@CheckForNull AvlNode&lt;?&gt; node) {
783       return (node == null) ? 0 : node.totalCount;
784     }
785     private static int height(@CheckForNull AvlNode&lt;?&gt; node) {
786       return (node == null) ? 0 : node.height;
787     }
788     @CheckForNull
789     private AvlNode&lt;E&gt; ceiling(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
790       int cmp = comparator.compare(e, getElement());
791       if (cmp &lt; 0) {
792         return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);
793       } else if (cmp == 0) {
794         return this;
795       } else {
796         return (right == null) ? null : right.ceiling(comparator, e);
797       }
798     }
799     @CheckForNull
800     private AvlNode&lt;E&gt; floor(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
801       int cmp = comparator.compare(e, getElement());
802       if (cmp &gt; 0) {
803         return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);
804       } else if (cmp == 0) {
805         return this;
806       } else {
807         return (left == null) ? null : left.floor(comparator, e);
808       }
809     }
810     @ParametricNullness
811     E getElement() {
812       return uncheckedCastNullableTToT(elem);
813     }
814     int getCount() {
815       return elemCount;
816     }
817     @Override
818     public String toString() {
819       return Multisets.immutableEntry(getElement(), getCount()).toString();
820     }
821   }
822   private static &lt;T extends @Nullable Object&gt; void successor(AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b) {
823     a.succ = b;
824     b.pred = a;
825   }
826   private static &lt;T extends @Nullable Object&gt; void successor(
827       AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b, AvlNode&lt;T&gt; c) {
828     successor(a, b);
829     successor(b, c);
830   }
831   @GwtIncompatible   private void writeObject(ObjectOutputStream stream) throws IOException {
832     stream.defaultWriteObject();
833     stream.writeObject(elementSet().comparator());
834     Serialization.writeMultiset(this, stream);
835   }
836   @GwtIncompatible   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
837     stream.defaultReadObject();
838     @SuppressWarnings("unchecked")
839     Comparator&lt;? super E&gt; comparator = (Comparator&lt;? super E&gt;) stream.readObject();
840     Serialization.getFieldSetter(AbstractSortedMultiset.class, "comparator").set(this, comparator);
841     Serialization.getFieldSetter(TreeMultiset.class, "range")
842         .set(this, GeneralRange.all(comparator));
843     Serialization.getFieldSetter(TreeMultiset.class, "rootReference")
844         .set(this, new Reference&lt;AvlNode&lt;E&gt;&gt;());
845     AvlNode&lt;E&gt; header = new AvlNode&lt;&gt;();
846     Serialization.getFieldSetter(TreeMultiset.class, "header").set(this, header);
847     successor(header, header);
848     Serialization.populateMultiset(this, stream);
849   }
850   @GwtIncompatible   private static final long serialVersionUID = 1;
851 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
