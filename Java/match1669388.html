<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractIterator.java &amp; TreeMultiset.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractIterator.java &amp; TreeMultiset.java
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractIterator.java (28.846153%)<th>TreeMultiset.java (1.8761727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-178)<td><a href="#" name="0">(461-467)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(155-159)<td><a href="#" name="1">(506-510)</a><td align="center"><font color="#bf0000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(19-65)<td><a href="#" name="2">(33-58)</a><td align="center"><font color="#bf0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="2"></a>
package com.google.common.collect;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import com.google.common.annotations.GwtCompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@</b></font>GwtCompatible
@ElementTypesAreNonnullByDefault
public abstract class AbstractIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
  private State state = State.NOT_READY;
  protected AbstractIterator() {}
  private enum State {
    READY,
    NOT_READY,
    DONE,
    FAILED,
  }
  @CheckForNull private T next;
  @CheckForNull
  protected abstract T computeNext();
  @CanIgnoreReturnValue
  @CheckForNull
  protected final T endOfData() {
    state = State.DONE;
    return null;
  }
  @Override
  public final boolean hasNext() {
    checkState(state != State.FAILED);
    switch (state) {
      case DONE:
        return false;
      case READY:
        return true;
      default:
    }
    return tryToComputeNext();
  }
  private boolean tryToComputeNext() {
    state = State.FAILED;     next = computeNext();
    if (state != State.DONE) {
      state = State.READY;
      return true;
    }
    return false;
  }
<a name="1"></a>
  @CanIgnoreReturnValue   @Override
  <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@ParametricNullness
  public final T next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }</b></font>
    state = State.NOT_READY;
<a name="0"></a>    T result = uncheckedCastNullableTToT(next);
    next = null;
    return result;
  <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  @ParametricNullness
  public final T peek() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }</b></font>
    return uncheckedCastNullableTToT(next);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeMultiset.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import static java.util.Objects.requireNonNull;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.MoreObjects;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<a name="2"></a>import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.Serializable;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@</b></font>GwtCompatible(emulated = true)
@ElementTypesAreNonnullByDefault
public final class TreeMultiset&lt;E extends @Nullable Object&gt; extends AbstractSortedMultiset&lt;E&gt;
    implements Serializable {
  public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create() {
    return new TreeMultiset&lt;E&gt;(Ordering.natural());
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends @Nullable Object&gt; TreeMultiset&lt;E&gt; create(
      @CheckForNull Comparator&lt;? super E&gt; comparator) {
    return (comparator == null)
        ? new TreeMultiset&lt;E&gt;((Comparator) Ordering.natural())
        : new TreeMultiset&lt;E&gt;(comparator);
  }
  public static &lt;E extends Comparable&gt; TreeMultiset&lt;E&gt; create(Iterable&lt;? extends E&gt; elements) {
    TreeMultiset&lt;E&gt; multiset = create();
    Iterables.addAll(multiset, elements);
    return multiset;
  }
  private final transient Reference&lt;AvlNode&lt;E&gt;&gt; rootReference;
  private final transient GeneralRange&lt;E&gt; range;
  private final transient AvlNode&lt;E&gt; header;
  TreeMultiset(Reference&lt;AvlNode&lt;E&gt;&gt; rootReference, GeneralRange&lt;E&gt; range, AvlNode&lt;E&gt; endLink) {
    super(range.comparator());
    this.rootReference = rootReference;
    this.range = range;
    this.header = endLink;
  }
  TreeMultiset(Comparator&lt;? super E&gt; comparator) {
    super(comparator);
    this.range = GeneralRange.all(comparator);
    this.header = new AvlNode&lt;&gt;();
    successor(header, header);
    this.rootReference = new Reference&lt;&gt;();
  }
  private enum Aggregate {
    SIZE {
      @Override
      int nodeAggregate(AvlNode&lt;?&gt; node) {
        return node.elemCount;
      }
      @Override
      long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
        return (root == null) ? 0 : root.totalCount;
      }
    },
    DISTINCT {
      @Override
      int nodeAggregate(AvlNode&lt;?&gt; node) {
        return 1;
      }
      @Override
      long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root) {
        return (root == null) ? 0 : root.distinctElements;
      }
    };
    abstract int nodeAggregate(AvlNode&lt;?&gt; node);
    abstract long treeAggregate(@CheckForNull AvlNode&lt;?&gt; root);
  }
  private long aggregateForEntries(Aggregate aggr) {
    AvlNode&lt;E&gt; root = rootReference.get();
    long total = aggr.treeAggregate(root);
    if (range.hasLowerBound()) {
      total -= aggregateBelowRange(aggr, root);
    }
    if (range.hasUpperBound()) {
      total -= aggregateAboveRange(aggr, root);
    }
    return total;
  }
  private long aggregateBelowRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
    if (node == null) {
      return 0;
    }
    int cmp =
        comparator()
            .compare(uncheckedCastNullableTToT(range.getLowerEndpoint()), node.getElement());
    if (cmp &lt; 0) {
      return aggregateBelowRange(aggr, node.left);
    } else if (cmp == 0) {
      switch (range.getLowerBoundType()) {
        case OPEN:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);
        case CLOSED:
          return aggr.treeAggregate(node.left);
        default:
          throw new AssertionError();
      }
    } else {
      return aggr.treeAggregate(node.left)
          + aggr.nodeAggregate(node)
          + aggregateBelowRange(aggr, node.right);
    }
  }
  private long aggregateAboveRange(Aggregate aggr, @CheckForNull AvlNode&lt;E&gt; node) {
    if (node == null) {
      return 0;
    }
    int cmp =
        comparator()
            .compare(uncheckedCastNullableTToT(range.getUpperEndpoint()), node.getElement());
    if (cmp &gt; 0) {
      return aggregateAboveRange(aggr, node.right);
    } else if (cmp == 0) {
      switch (range.getUpperBoundType()) {
        case OPEN:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.right);
        case CLOSED:
          return aggr.treeAggregate(node.right);
        default:
          throw new AssertionError();
      }
    } else {
      return aggr.treeAggregate(node.right)
          + aggr.nodeAggregate(node)
          + aggregateAboveRange(aggr, node.left);
    }
  }
  @Override
  public int size() {
    return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE));
  }
  @Override
  int distinctElements() {
    return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));
  }
  static int distinctElements(@CheckForNull AvlNode&lt;?&gt; node) {
    return (node == null) ? 0 : node.distinctElements;
  }
  @Override
  public int count(@CheckForNull Object element) {
    try {
      @SuppressWarnings("unchecked")
      E e = (E) element;
      AvlNode&lt;E&gt; root = rootReference.get();
      if (!range.contains(e) || root == null) {
        return 0;
      }
      return root.count(comparator(), e);
    } catch (ClassCastException | NullPointerException e) {
      return 0;
    }
  }
  @CanIgnoreReturnValue
  @Override
  public int add(@ParametricNullness E element, int occurrences) {
    checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0) {
      return count(element);
    }
    checkArgument(range.contains(element));
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      comparator().compare(element, element);
      AvlNode&lt;E&gt; newRoot = new AvlNode&lt;E&gt;(element, occurrences);
      successor(header, newRoot, header);
      rootReference.checkAndSet(root, newRoot);
      return 0;
    }
    int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.add(comparator(), element, occurrences, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  @CanIgnoreReturnValue
  @Override
  public int remove(@CheckForNull Object element, int occurrences) {
    checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0) {
      return count(element);
    }
    AvlNode&lt;E&gt; root = rootReference.get();
    int[] result = new int[1];     AvlNode&lt;E&gt; newRoot;
    try {
      @SuppressWarnings("unchecked")
      E e = (E) element;
      if (!range.contains(e) || root == null) {
        return 0;
      }
      newRoot = root.remove(comparator(), e, occurrences, result);
    } catch (ClassCastException | NullPointerException e) {
      return 0;
    }
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  @CanIgnoreReturnValue
  @Override
  public int setCount(@ParametricNullness E element, int count) {
    checkNonnegative(count, "count");
    if (!range.contains(element)) {
      checkArgument(count == 0);
      return 0;
    }
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      if (count &gt; 0) {
        add(element, count);
      }
      return 0;
    }
    int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, count, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  @CanIgnoreReturnValue
  @Override
  public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
    checkNonnegative(newCount, "newCount");
    checkNonnegative(oldCount, "oldCount");
    checkArgument(range.contains(element));
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      if (oldCount == 0) {
        if (newCount &gt; 0) {
          add(element, newCount);
        }
        return true;
      } else {
        return false;
      }
    }
    int[] result = new int[1];     AvlNode&lt;E&gt; newRoot = root.setCount(comparator(), element, oldCount, newCount, result);
    rootReference.checkAndSet(root, newRoot);
    return result[0] == oldCount;
  }
  @Override
  public void clear() {
    if (!range.hasLowerBound() &amp;&amp; !range.hasUpperBound()) {
      for (AvlNode&lt;E&gt; current = header.succ(); current != header; ) {
        AvlNode&lt;E&gt; next = current.succ();
        current.elemCount = 0;
        current.left = null;
        current.right = null;
        current.pred = null;
        current.succ = null;
        current = next;
      }
      successor(header, header);
      rootReference.clear();
    } else {
      Iterators.clear(entryIterator());
    }
  }
  private Entry&lt;E&gt; wrapEntry(final AvlNode&lt;E&gt; baseEntry) {
    return new Multisets.AbstractEntry&lt;E&gt;() {
      @Override
      @ParametricNullness
      public E getElement() {
        return baseEntry.getElement();
      }
      @Override
      public int getCount() {
        int result = baseEntry.getCount();
        if (result == 0) {
          return count(getElement());
        } else {
          return result;
        }
      }
    };
  }
  @CheckForNull
  private AvlNode&lt;E&gt; firstNode() {
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      return null;
    }
    AvlNode&lt;E&gt; node;
    if (range.hasLowerBound()) {
      E endpoint = uncheckedCastNullableTToT(range.getLowerEndpoint());
      node = root.ceiling(comparator(), endpoint);
      if (node == null) {
        return null;
      }
      if (range.getLowerBoundType() == BoundType.OPEN
          &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
        node = node.succ();
      }
    } else {
      node = header.succ();
    }
    return (node == header || !range.contains(node.getElement())) ? null : node;
  }
  @CheckForNull
  private AvlNode&lt;E&gt; lastNode() {
    AvlNode&lt;E&gt; root = rootReference.get();
    if (root == null) {
      return null;
    }
    AvlNode&lt;E&gt; node;
    if (range.hasUpperBound()) {
      E endpoint = uncheckedCastNullableTToT(range.getUpperEndpoint());
      node = root.floor(comparator(), endpoint);
      if (node == null) {
        return null;
      }
      if (range.getUpperBoundType() == BoundType.OPEN
          &amp;&amp; comparator().compare(endpoint, node.getElement()) == 0) {
        node = node.pred();
      }
    } else {
      node = header.pred();
    }
    return (node == header || !range.contains(node.getElement())) ? null : node;
  }
  @Override
  Iterator&lt;E&gt; elementIterator() {
    return Multisets.elementIterator(entryIterator());
  }
  @Override
  Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
    return new Iterator&lt;Entry&lt;E&gt;&gt;() {
      @CheckForNull AvlNode&lt;E&gt; current = firstNode();
      @CheckForNull Entry&lt;E&gt; prevEntry;
      @Override
      public boolean hasNext() {
        if (current == null) {
          return false;
        } else if (range.tooHigh(current.getElement())) {
          current = null;
          return false;
<a name="0"></a>        } else {
          return true;
        }
      <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
      @Override
      public Entry&lt;E&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }</b></font>
        Entry&lt;E&gt; result = wrapEntry(requireNonNull(current));
        prevEntry = result;
        if (current.succ() == header) {
          current = null;
        } else {
          current = current.succ();
        }
        return result;
      }
      @Override
      public void remove() {
        checkState(prevEntry != null, "no calls to next() since the last call to remove()");
        setCount(prevEntry.getElement(), 0);
        prevEntry = null;
      }
    };
  }
  @Override
  Iterator&lt;Entry&lt;E&gt;&gt; descendingEntryIterator() {
    return new Iterator&lt;Entry&lt;E&gt;&gt;() {
      @CheckForNull AvlNode&lt;E&gt; current = lastNode();
      @CheckForNull Entry&lt;E&gt; prevEntry = null;
      @Override
      public boolean hasNext() {
        if (current == null) {
          return false;
        } else if (range.tooLow(current.getElement())) {
          current = null;
          return false;
        } else {
          return true;
<a name="1"></a>        }
      }
      <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public Entry&lt;E&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }</b></font>
        requireNonNull(current);
        Entry&lt;E&gt; result = wrapEntry(current);
        prevEntry = result;
        if (current.pred() == header) {
          current = null;
        } else {
          current = current.pred();
        }
        return result;
      }
      @Override
      public void remove() {
        checkState(prevEntry != null, "no calls to next() since the last call to remove()");
        setCount(prevEntry.getElement(), 0);
        prevEntry = null;
      }
    };
  }
  @Override
  public Iterator&lt;E&gt; iterator() {
    return Multisets.iteratorImpl(this);
  }
  @Override
  public SortedMultiset&lt;E&gt; headMultiset(@ParametricNullness E upperBound, BoundType boundType) {
    return new TreeMultiset&lt;E&gt;(
        rootReference,
        range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),
        header);
  }
  @Override
  public SortedMultiset&lt;E&gt; tailMultiset(@ParametricNullness E lowerBound, BoundType boundType) {
    return new TreeMultiset&lt;E&gt;(
        rootReference,
        range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),
        header);
  }
  private static final class Reference&lt;T&gt; {
    @CheckForNull private T value;
    @CheckForNull
    public T get() {
      return value;
    }
    public void checkAndSet(@CheckForNull T expected, @CheckForNull T newValue) {
      if (value != expected) {
        throw new ConcurrentModificationException();
      }
      value = newValue;
    }
    void clear() {
      value = null;
    }
  }
  private static final class AvlNode&lt;E extends @Nullable Object&gt; {
    @CheckForNull private final E elem;
    private int elemCount;
    private int distinctElements;
    private long totalCount;
    private int height;
    @CheckForNull private AvlNode&lt;E&gt; left;
    @CheckForNull private AvlNode&lt;E&gt; right;
    @CheckForNull private AvlNode&lt;E&gt; pred;
    @CheckForNull private AvlNode&lt;E&gt; succ;
    AvlNode(@ParametricNullness E elem, int elemCount) {
      checkArgument(elemCount &gt; 0);
      this.elem = elem;
      this.elemCount = elemCount;
      this.totalCount = elemCount;
      this.distinctElements = 1;
      this.height = 1;
      this.left = null;
      this.right = null;
    }
    AvlNode() {
      this.elem = null;
      this.elemCount = 1;
    }
    private AvlNode&lt;E&gt; pred() {
      return requireNonNull(pred);
    }
    private AvlNode&lt;E&gt; succ() {
      return requireNonNull(succ);
    }
    int count(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        return (left == null) ? 0 : left.count(comparator, e);
      } else if (cmp &gt; 0) {
        return (right == null) ? 0 : right.count(comparator, e);
      } else {
        return elemCount;
      }
    }
    private AvlNode&lt;E&gt; addRightChild(@ParametricNullness E e, int count) {
      right = new AvlNode&lt;E&gt;(e, count);
      successor(this, right, succ());
      height = Math.max(2, height);
      distinctElements++;
      totalCount += count;
      return this;
    }
    private AvlNode&lt;E&gt; addLeftChild(@ParametricNullness E e, int count) {
      left = new AvlNode&lt;E&gt;(e, count);
      successor(pred(), left, this);
      height = Math.max(2, height);
      distinctElements++;
      totalCount += count;
      return this;
    }
    AvlNode&lt;E&gt; add(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return addLeftChild(e, count);
        }
        int initHeight = initLeft.height;
        left = initLeft.add(comparator, e, count, result);
        if (result[0] == 0) {
          distinctElements++;
        }
        this.totalCount += count;
        return (left.height == initHeight) ? this : rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return addRightChild(e, count);
        }
        int initHeight = initRight.height;
        right = initRight.add(comparator, e, count, result);
        if (result[0] == 0) {
          distinctElements++;
        }
        this.totalCount += count;
        return (right.height == initHeight) ? this : rebalance();
      }
      result[0] = elemCount;
      long resultCount = (long) elemCount + count;
      checkArgument(resultCount &lt;= Integer.MAX_VALUE);
      this.elemCount += count;
      this.totalCount += count;
      return this;
    }
    @CheckForNull
    AvlNode&lt;E&gt; remove(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return this;
        }
        left = initLeft.remove(comparator, e, count, result);
        if (result[0] &gt; 0) {
          if (count &gt;= result[0]) {
            this.distinctElements--;
            this.totalCount -= result[0];
          } else {
            this.totalCount -= count;
          }
        }
        return (result[0] == 0) ? this : rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return this;
        }
        right = initRight.remove(comparator, e, count, result);
        if (result[0] &gt; 0) {
          if (count &gt;= result[0]) {
            this.distinctElements--;
            this.totalCount -= result[0];
          } else {
            this.totalCount -= count;
          }
        }
        return rebalance();
      }
      result[0] = elemCount;
      if (count &gt;= elemCount) {
        return deleteMe();
      } else {
        this.elemCount -= count;
        this.totalCount -= count;
        return this;
      }
    }
    @CheckForNull
    AvlNode&lt;E&gt; setCount(
        Comparator&lt;? super E&gt; comparator, @ParametricNullness E e, int count, int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return (count &gt; 0) ? addLeftChild(e, count) : this;
        }
        left = initLeft.setCount(comparator, e, count, result);
        if (count == 0 &amp;&amp; result[0] != 0) {
          this.distinctElements--;
        } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
          this.distinctElements++;
        }
        this.totalCount += count - result[0];
        return rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          return (count &gt; 0) ? addRightChild(e, count) : this;
        }
        right = initRight.setCount(comparator, e, count, result);
        if (count == 0 &amp;&amp; result[0] != 0) {
          this.distinctElements--;
        } else if (count &gt; 0 &amp;&amp; result[0] == 0) {
          this.distinctElements++;
        }
        this.totalCount += count - result[0];
        return rebalance();
      }
      result[0] = elemCount;
      if (count == 0) {
        return deleteMe();
      }
      this.totalCount += count - elemCount;
      this.elemCount = count;
      return this;
    }
    @CheckForNull
    AvlNode&lt;E&gt; setCount(
        Comparator&lt;? super E&gt; comparator,
        @ParametricNullness E e,
        int expectedCount,
        int newCount,
        int[] result) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        AvlNode&lt;E&gt; initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
            return addLeftChild(e, newCount);
          }
          return this;
        }
        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);
        if (result[0] == expectedCount) {
          if (newCount == 0 &amp;&amp; result[0] != 0) {
            this.distinctElements--;
          } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
            this.distinctElements++;
          }
          this.totalCount += newCount - result[0];
        }
        return rebalance();
      } else if (cmp &gt; 0) {
        AvlNode&lt;E&gt; initRight = right;
        if (initRight == null) {
          result[0] = 0;
          if (expectedCount == 0 &amp;&amp; newCount &gt; 0) {
            return addRightChild(e, newCount);
          }
          return this;
        }
        right = initRight.setCount(comparator, e, expectedCount, newCount, result);
        if (result[0] == expectedCount) {
          if (newCount == 0 &amp;&amp; result[0] != 0) {
            this.distinctElements--;
          } else if (newCount &gt; 0 &amp;&amp; result[0] == 0) {
            this.distinctElements++;
          }
          this.totalCount += newCount - result[0];
        }
        return rebalance();
      }
      result[0] = elemCount;
      if (expectedCount == elemCount) {
        if (newCount == 0) {
          return deleteMe();
        }
        this.totalCount += newCount - elemCount;
        this.elemCount = newCount;
      }
      return this;
    }
    @CheckForNull
    private AvlNode&lt;E&gt; deleteMe() {
      int oldElemCount = this.elemCount;
      this.elemCount = 0;
      successor(pred(), succ());
      if (left == null) {
        return right;
      } else if (right == null) {
        return left;
      } else if (left.height &gt;= right.height) {
        AvlNode&lt;E&gt; newTop = pred();
        newTop.left = left.removeMax(newTop);
        newTop.right = right;
        newTop.distinctElements = distinctElements - 1;
        newTop.totalCount = totalCount - oldElemCount;
        return newTop.rebalance();
      } else {
        AvlNode&lt;E&gt; newTop = succ();
        newTop.right = right.removeMin(newTop);
        newTop.left = left;
        newTop.distinctElements = distinctElements - 1;
        newTop.totalCount = totalCount - oldElemCount;
        return newTop.rebalance();
      }
    }
    @CheckForNull
    private AvlNode&lt;E&gt; removeMin(AvlNode&lt;E&gt; node) {
      if (left == null) {
        return right;
      } else {
        left = left.removeMin(node);
        distinctElements--;
        totalCount -= node.elemCount;
        return rebalance();
      }
    }
    @CheckForNull
    private AvlNode&lt;E&gt; removeMax(AvlNode&lt;E&gt; node) {
      if (right == null) {
        return left;
      } else {
        right = right.removeMax(node);
        distinctElements--;
        totalCount -= node.elemCount;
        return rebalance();
      }
    }
    private void recomputeMultiset() {
      this.distinctElements =
          1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);
      this.totalCount = elemCount + totalCount(left) + totalCount(right);
    }
    private void recomputeHeight() {
      this.height = 1 + Math.max(height(left), height(right));
    }
    private void recompute() {
      recomputeMultiset();
      recomputeHeight();
    }
    private AvlNode&lt;E&gt; rebalance() {
      switch (balanceFactor()) {
        case -2:
          requireNonNull(right);
          if (right.balanceFactor() &gt; 0) {
            right = right.rotateRight();
          }
          return rotateLeft();
        case 2:
          requireNonNull(left);
          if (left.balanceFactor() &lt; 0) {
            left = left.rotateLeft();
          }
          return rotateRight();
        default:
          recomputeHeight();
          return this;
      }
    }
    private int balanceFactor() {
      return height(left) - height(right);
    }
    private AvlNode&lt;E&gt; rotateLeft() {
      checkState(right != null);
      AvlNode&lt;E&gt; newTop = right;
      this.right = newTop.left;
      newTop.left = this;
      newTop.totalCount = this.totalCount;
      newTop.distinctElements = this.distinctElements;
      this.recompute();
      newTop.recomputeHeight();
      return newTop;
    }
    private AvlNode&lt;E&gt; rotateRight() {
      checkState(left != null);
      AvlNode&lt;E&gt; newTop = left;
      this.left = newTop.right;
      newTop.right = this;
      newTop.totalCount = this.totalCount;
      newTop.distinctElements = this.distinctElements;
      this.recompute();
      newTop.recomputeHeight();
      return newTop;
    }
    private static long totalCount(@CheckForNull AvlNode&lt;?&gt; node) {
      return (node == null) ? 0 : node.totalCount;
    }
    private static int height(@CheckForNull AvlNode&lt;?&gt; node) {
      return (node == null) ? 0 : node.height;
    }
    @CheckForNull
    private AvlNode&lt;E&gt; ceiling(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &lt; 0) {
        return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);
      } else if (cmp == 0) {
        return this;
      } else {
        return (right == null) ? null : right.ceiling(comparator, e);
      }
    }
    @CheckForNull
    private AvlNode&lt;E&gt; floor(Comparator&lt;? super E&gt; comparator, @ParametricNullness E e) {
      int cmp = comparator.compare(e, getElement());
      if (cmp &gt; 0) {
        return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);
      } else if (cmp == 0) {
        return this;
      } else {
        return (left == null) ? null : left.floor(comparator, e);
      }
    }
    @ParametricNullness
    E getElement() {
      return uncheckedCastNullableTToT(elem);
    }
    int getCount() {
      return elemCount;
    }
    @Override
    public String toString() {
      return Multisets.immutableEntry(getElement(), getCount()).toString();
    }
  }
  private static &lt;T extends @Nullable Object&gt; void successor(AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b) {
    a.succ = b;
    b.pred = a;
  }
  private static &lt;T extends @Nullable Object&gt; void successor(
      AvlNode&lt;T&gt; a, AvlNode&lt;T&gt; b, AvlNode&lt;T&gt; c) {
    successor(a, b);
    successor(b, c);
  }
  @GwtIncompatible   private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeObject(elementSet().comparator());
    Serialization.writeMultiset(this, stream);
  }
  @GwtIncompatible   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    @SuppressWarnings("unchecked")
    Comparator&lt;? super E&gt; comparator = (Comparator&lt;? super E&gt;) stream.readObject();
    Serialization.getFieldSetter(AbstractSortedMultiset.class, "comparator").set(this, comparator);
    Serialization.getFieldSetter(TreeMultiset.class, "range")
        .set(this, GeneralRange.all(comparator));
    Serialization.getFieldSetter(TreeMultiset.class, "rootReference")
        .set(this, new Reference&lt;AvlNode&lt;E&gt;&gt;());
    AvlNode&lt;E&gt; header = new AvlNode&lt;&gt;();
    Serialization.getFieldSetter(TreeMultiset.class, "header").set(this, header);
    successor(header, header);
    Serialization.populateMultiset(this, stream);
  }
  @GwtIncompatible   private static final long serialVersionUID = 1;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
