<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DirectedNetworkConnections_1.java & ValueGraphTest_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DirectedNetworkConnections_1.java & ValueGraphTest_1.java
      </h3>
      <h1 align="center">
        2.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DirectedNetworkConnections_1.java (13.043478%)<TH>ValueGraphTest_1.java (1.2145749%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1917234-0.html#0',2,'match1917234-1.html#0',3)" NAME="0">(19-35)<TD><A HREF="javascript:ZweiFrames('match1917234-0.html#0',2,'match1917234-1.html#0',3)" NAME="0">(28-38)</A><TD ALIGN=center><FONT COLOR="#ff0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DirectedNetworkConnections_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.graph;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1917234-1.html#0',3,'match1917234-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.graph.GraphConstants.EXPECTED_DEGREE;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableBiMap;
import java.util.Collections;
import java.util.Map;
import java.util.Set;

/**
 * An implementation of {@link NetworkConnections} for directed networks.
 *
 * @author James Sexton
 * @param &lt;N&gt; Node parameter type
 * @param &lt;E&gt; Edge parameter type
 */
@</B></FONT>ElementTypesAreNonnullByDefault
final class DirectedNetworkConnections&lt;N, E&gt; extends AbstractDirectedNetworkConnections&lt;N, E&gt; {

  DirectedNetworkConnections(Map&lt;E, N&gt; inEdgeMap, Map&lt;E, N&gt; outEdgeMap, int selfLoopCount) {
    super(inEdgeMap, outEdgeMap, selfLoopCount);
  }

  static &lt;N, E&gt; DirectedNetworkConnections&lt;N, E&gt; of() {
    return new DirectedNetworkConnections&lt;&gt;(
        HashBiMap.&lt;E, N&gt;create(EXPECTED_DEGREE), HashBiMap.&lt;E, N&gt;create(EXPECTED_DEGREE), 0);
  }

  static &lt;N, E&gt; DirectedNetworkConnections&lt;N, E&gt; ofImmutable(
      Map&lt;E, N&gt; inEdges, Map&lt;E, N&gt; outEdges, int selfLoopCount) {
    return new DirectedNetworkConnections&lt;&gt;(
        ImmutableBiMap.copyOf(inEdges), ImmutableBiMap.copyOf(outEdges), selfLoopCount);
  }

  @Override
  public Set&lt;N&gt; predecessors() {
    return Collections.unmodifiableSet(((BiMap&lt;E, N&gt;) inEdgeMap).values());
  }

  @Override
  public Set&lt;N&gt; successors() {
    return Collections.unmodifiableSet(((BiMap&lt;E, N&gt;) outEdgeMap).values());
  }

  @Override
  public Set&lt;E&gt; edgesConnecting(N node) {
    return new EdgesConnecting&lt;&gt;(((BiMap&lt;E, N&gt;) outEdgeMap).inverse(), node);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ValueGraphTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.graph;

import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
import static com.google.common.truth.Truth.assertThat;
import static java.util.concurrent.Executors.newFixedThreadPool;
import static org.junit.Assert.fail;

<A NAME="0"></A>import com.google.common.collect.ImmutableList;
import java.util.Set;
import java.util.concurrent.Callable;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1917234-0.html#0',2,'match1917234-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for {@link StandardMutableValueGraph} and related functionality. */
// TODO(user): Expand coverage and move to proper test suite.
@</B></FONT>RunWith(JUnit4.class)
public final class ValueGraphTest {
  private static final String DEFAULT = &quot;default&quot;;

  MutableValueGraph&lt;Integer, String&gt; graph;

  @After
  public void validateGraphState() {
    assertStronglyEquivalent(graph, Graphs.copyOf(graph));
    assertStronglyEquivalent(graph, ImmutableValueGraph.copyOf(graph));

    Graph&lt;Integer&gt; asGraph = graph.asGraph();
    AbstractGraphTest.validateGraph(asGraph);
    assertThat(graph.nodes()).isEqualTo(asGraph.nodes());
    assertThat(graph.edges()).isEqualTo(asGraph.edges());
    assertThat(graph.nodeOrder()).isEqualTo(asGraph.nodeOrder());
    assertThat(graph.incidentEdgeOrder()).isEqualTo(asGraph.incidentEdgeOrder());
    assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());
    assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());

    for (Integer node : graph.nodes()) {
      assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));
      assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));
      assertThat(graph.successors(node)).isEqualTo(asGraph.successors(node));
      assertThat(graph.degree(node)).isEqualTo(asGraph.degree(node));
      assertThat(graph.inDegree(node)).isEqualTo(asGraph.inDegree(node));
      assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));

      for (Integer otherNode : graph.nodes()) {
        boolean hasEdge = graph.hasEdgeConnecting(node, otherNode);
        assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode));
        assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge);
        assertThat(!graph.edgeValueOrDefault(node, otherNode, DEFAULT).equals(DEFAULT))
            .isEqualTo(hasEdge);
      }
    }
  }

  @Test
  public void directedGraph() {
    graph = ValueGraphBuilder.directed().allowsSelfLoops(true).build();
    graph.putEdgeValue(1, 2, &quot;valueA&quot;);
    graph.putEdgeValue(2, 1, &quot;valueB&quot;);
    graph.putEdgeValue(2, 3, &quot;valueC&quot;);
    graph.putEdgeValue(4, 4, &quot;valueD&quot;);

    assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(&quot;valueD&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo(&quot;valueD&quot;);

    String toString = graph.toString();
    assertThat(toString).contains(&quot;valueA&quot;);
    assertThat(toString).contains(&quot;valueB&quot;);
    assertThat(toString).contains(&quot;valueC&quot;);
    assertThat(toString).contains(&quot;valueD&quot;);
  }

  @Test
  public void undirectedGraph() {
    graph = ValueGraphBuilder.undirected().allowsSelfLoops(true).build();
    graph.putEdgeValue(1, 2, &quot;valueA&quot;);
    graph.putEdgeValue(2, 1, &quot;valueB&quot;); // overwrites valueA in undirected case
    graph.putEdgeValue(2, 3, &quot;valueC&quot;);
    graph.putEdgeValue(4, 4, &quot;valueD&quot;);

    assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(&quot;valueD&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo(&quot;valueD&quot;);

    String toString = graph.toString();
    assertThat(toString).doesNotContain(&quot;valueA&quot;);
    assertThat(toString).contains(&quot;valueB&quot;);
    assertThat(toString).contains(&quot;valueC&quot;);
    assertThat(toString).contains(&quot;valueD&quot;);
  }

  @Test
  public void incidentEdgeOrder_unordered() {
    graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.unordered()).build();
    assertThat(graph.incidentEdgeOrder()).isEqualTo(ElementOrder.unordered());
  }

  @Test
  public void incidentEdgeOrder_stable() {
    graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();
    assertThat(graph.incidentEdgeOrder()).isEqualTo(ElementOrder.stable());
  }

  @Test
  public void hasEdgeConnecting_directed_correct() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();
  }

  @Test
  public void hasEdgeConnecting_directed_backwards() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isFalse();
  }

  @Test
  public void hasEdgeConnecting_directed_mismatch() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isFalse();
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isFalse();
  }

  @Test
  public void hasEdgeConnecting_undirected_correct() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isTrue();
  }

  @Test
  public void hasEdgeConnecting_undirected_backwards() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isTrue();
  }

  @Test
  public void hasEdgeConnecting_undirected_mismatch() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isTrue();
  }

  @Test
  public void edgeValueOrDefault_directed_correct() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(1, 2), &quot;default&quot;)).isEqualTo(&quot;A&quot;);
  }

  @Test
  public void edgeValueOrDefault_directed_backwards() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), &quot;default&quot;))
        .isEqualTo(&quot;default&quot;);
  }

  @Test
  public void edgeValueOrDefault_directed_mismatch() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    try {
      String unused = graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), &quot;default&quot;);
      unused = graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), &quot;default&quot;);
      fail(&quot;Expected IllegalArgumentException: &quot; + ENDPOINTS_MISMATCH);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
    }
  }

  @Test
  public void edgeValueOrDefault_undirected_correct() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), &quot;default&quot;)).isEqualTo(&quot;A&quot;);
  }

  @Test
  public void edgeValueOrDefault_undirected_backwards() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), &quot;default&quot;)).isEqualTo(&quot;A&quot;);
  }

  @Test
  public void edgeValueOrDefault_undirected_mismatch() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), &quot;default&quot;)).isEqualTo(&quot;A&quot;);
    assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), &quot;default&quot;)).isEqualTo(&quot;A&quot;);
  }

  @Test
  public void putEdgeValue_directed() {
    graph = ValueGraphBuilder.directed().build();

    assertThat(graph.putEdgeValue(1, 2, &quot;valueA&quot;)).isNull();
    assertThat(graph.putEdgeValue(2, 1, &quot;valueB&quot;)).isNull();
    assertThat(graph.putEdgeValue(1, 2, &quot;valueC&quot;)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.putEdgeValue(2, 1, &quot;valueD&quot;)).isEqualTo(&quot;valueB&quot;);
  }

  @Test
  public void putEdgeValue_directed_orderMismatch() {
    graph = ValueGraphBuilder.directed().build();
    try {
      graph.putEdgeValue(EndpointPair.unordered(1, 2), &quot;irrelevant&quot;);
      fail(&quot;Expected IllegalArgumentException: &quot; + ENDPOINTS_MISMATCH);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
    }
  }

  @Test
  public void putEdgeValue_undirected_orderMismatch() {
    graph = ValueGraphBuilder.undirected().build();
    assertThat(graph.putEdgeValue(EndpointPair.ordered(1, 2), &quot;irrelevant&quot;)).isNull();
  }

  @Test
  public void putEdgeValue_undirected() {
    graph = ValueGraphBuilder.undirected().build();

    assertThat(graph.putEdgeValue(1, 2, &quot;valueA&quot;)).isNull();
    assertThat(graph.putEdgeValue(2, 1, &quot;valueB&quot;)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.putEdgeValue(1, 2, &quot;valueC&quot;)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.putEdgeValue(2, 1, &quot;valueD&quot;)).isEqualTo(&quot;valueC&quot;);
  }

  @Test
  public void removeEdge_directed() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;valueA&quot;);
    graph.putEdgeValue(2, 1, &quot;valueB&quot;);
    graph.putEdgeValue(2, 3, &quot;valueC&quot;);

    assertThat(graph.removeEdge(1, 2)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.removeEdge(1, 2)).isNull();
    assertThat(graph.removeEdge(2, 1)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.removeEdge(2, 1)).isNull();
    assertThat(graph.removeEdge(2, 3)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.removeEdge(2, 3)).isNull();
  }

  @Test
  public void removeEdge_undirected() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;valueA&quot;);
    graph.putEdgeValue(2, 1, &quot;valueB&quot;);
    graph.putEdgeValue(2, 3, &quot;valueC&quot;);

    assertThat(graph.removeEdge(1, 2)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.removeEdge(1, 2)).isNull();
    assertThat(graph.removeEdge(2, 1)).isNull();
    assertThat(graph.removeEdge(2, 3)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.removeEdge(2, 3)).isNull();
  }

  @Test
  public void removeEdge_directed_orderMismatch() {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;1-&gt;2&quot;);
    graph.putEdgeValue(2, 1, &quot;2-&gt;1&quot;);
    try {
      graph.removeEdge(EndpointPair.unordered(1, 2));
      graph.removeEdge(EndpointPair.unordered(2, 1));
      fail(&quot;Expected IllegalArgumentException: &quot; + ENDPOINTS_MISMATCH);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
    }
  }

  @Test
  public void removeEdge_undirected_orderMismatch() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;1-2&quot;);
    assertThat(graph.removeEdge(EndpointPair.ordered(1, 2))).isEqualTo(&quot;1-2&quot;);
  }

  @Test
  public void edgeValue_missing() {
    graph = ValueGraphBuilder.directed().build();

    assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(DEFAULT);
    assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(DEFAULT);
    assertThat(graph.edgeValueOrDefault(1, 2, null)).isNull();
    assertThat(graph.edgeValueOrDefault(2, 1, null)).isNull();

    graph.putEdgeValue(1, 2, &quot;valueA&quot;);
    graph.putEdgeValue(2, 1, &quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(&quot;valueB&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo(&quot;valueA&quot;);
    assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(&quot;valueB&quot;);

    graph.removeEdge(1, 2);
    graph.putEdgeValue(2, 1, &quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(DEFAULT);
    assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(&quot;valueC&quot;);
    assertThat(graph.edgeValueOrDefault(1, 2, null)).isNull();
    assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(&quot;valueC&quot;);
  }

  @Test
  public void equivalence_considersEdgeValue() {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, &quot;valueA&quot;);

    MutableValueGraph&lt;Integer, String&gt; otherGraph = ValueGraphBuilder.undirected().build();
    otherGraph.putEdgeValue(1, 2, &quot;valueA&quot;);
    assertThat(graph).isEqualTo(otherGraph);

    otherGraph.putEdgeValue(1, 2, &quot;valueB&quot;);
    assertThat(graph).isNotEqualTo(otherGraph); // values differ
  }

  @Test
  public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder_directed() {
    graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();
    graph.putEdgeValue(2, 1, &quot;2-1&quot;);
    graph.putEdgeValue(2, 3, &quot;2-3&quot;);
    graph.putEdgeValue(1, 2, &quot;1-2&quot;);

    assertThat(graph.incidentEdges(2))
        .containsExactly(
            EndpointPair.ordered(2, 1), EndpointPair.ordered(2, 3), EndpointPair.ordered(1, 2))
        .inOrder();
  }

  @Test
  public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder_undirected() {
    graph = ValueGraphBuilder.undirected().incidentEdgeOrder(ElementOrder.stable()).build();
    graph.putEdgeValue(2, 3, &quot;2-3&quot;);
    graph.putEdgeValue(2, 1, &quot;2-1&quot;);
    graph.putEdgeValue(2, 4, &quot;2-4&quot;);
    graph.putEdgeValue(1, 2, &quot;1-2&quot;); // Duplicate nodes, different value

    assertThat(graph.incidentEdges(2))
        .containsExactly(
            EndpointPair.unordered(2, 3),
            EndpointPair.unordered(1, 2),
            EndpointPair.unordered(2, 4))
        .inOrder();
  }


  @Test
  public void concurrentIteration() throws Exception {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, &quot;A&quot;);
    graph.putEdgeValue(3, 4, &quot;B&quot;);
    graph.putEdgeValue(5, 6, &quot;C&quot;);

    int threadCount = 20;
    ExecutorService executor = newFixedThreadPool(threadCount);
    final CyclicBarrier barrier = new CyclicBarrier(threadCount);
    ImmutableList.Builder&lt;Future&lt;?&gt;&gt; futures = ImmutableList.builder();
    for (int i = 0; i &lt; threadCount; i++) {
      futures.add(
          executor.submit(
              new Callable&lt;Object&gt;() {
                @Override
                public Object call() throws Exception {
                  barrier.await();
                  Integer first = graph.nodes().iterator().next();
                  for (Integer node : graph.nodes()) {
                    Set&lt;Integer&gt; unused = graph.successors(node);
                  }
                  /*
                   * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
                   * we read one of the fields declared in that class.
                   */
                  Set&lt;Integer&gt; unused = graph.successors(first);
                  return null;
                }
              }));
    }

    // For more about this test, see the equivalent in AbstractNetworkTest.
    for (Future&lt;?&gt; future : futures.build()) {
      future.get();
    }
    executor.shutdown();
  }
}
</PRE>
</div>
  </div>
</body>
</html>
