<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ImmutableNetworkTest_1.java &amp; SpliteratorTester.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ImmutableNetworkTest_1.java &amp; SpliteratorTester.java
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ImmutableNetworkTest_1.java (4.6632123%)<th>SpliteratorTester.java (2.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(40-46)<td><a href="#" name="0">(139-144)</a><td align="center"><font color="#ff0000">9</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableNetworkTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.graph;

import static com.google.common.truth.Truth.assertThat;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for {@link ImmutableNetwork}. */
@RunWith(JUnit4.class)
public class ImmutableNetworkTest {

  @Test
  public void immutableNetwork() {
    MutableNetwork&lt;String, Integer&gt; mutableNetwork = NetworkBuilder.directed().build();
    mutableNetwork.addNode("A");
    ImmutableNetwork&lt;String, Integer&gt; immutableNetwork = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(immutableNetwork.asGraph()).isInstanceOf(ImmutableGraph.class);
    assertThat(immutableNetwork).isNotInstanceOf(MutableNetwork.class);
<a name="0"></a>    assertThat(immutableNetwork).isEqualTo(mutableNetwork);

    mutableNetwork.addNode("B");
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(immutableNetwork).isNotEqualTo(mutableNetwork);
  }

  @Test
  public void copyOfImmutableNetwork_optimized() {
    Network&lt;String, String&gt; network1 =
        ImmutableNetwork.copyOf</b></font>(NetworkBuilder.directed().&lt;String, String&gt;build());
    Network&lt;String, String&gt; network2 = ImmutableNetwork.copyOf(network1);

    assertThat(network2).isSameInstanceAs(network1);
  }

  @Test
  public void edgesConnecting_directed() {
    MutableNetwork&lt;String, String&gt; mutableNetwork =
        NetworkBuilder.directed().allowsSelfLoops(true).build();
    mutableNetwork.addEdge("A", "A", "AA");
    mutableNetwork.addEdge("A", "B", "AB");
    Network&lt;String, String&gt; network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting("A", "A")).containsExactly("AA");
    assertThat(network.edgesConnecting("A", "B")).containsExactly("AB");
    assertThat(network.edgesConnecting("B", "A")).isEmpty();
  }

  @Test
  public void edgesConnecting_undirected() {
    MutableNetwork&lt;String, String&gt; mutableNetwork =
        NetworkBuilder.undirected().allowsSelfLoops(true).build();
    mutableNetwork.addEdge("A", "A", "AA");
    mutableNetwork.addEdge("A", "B", "AB");
    Network&lt;String, String&gt; network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting("A", "A")).containsExactly("AA");
    assertThat(network.edgesConnecting("A", "B")).containsExactly("AB");
    assertThat(network.edgesConnecting("B", "A")).containsExactly("AB");
  }

  @Test
  public void immutableNetworkBuilder_appliesNetworkBuilderConfig() {
    ImmutableNetwork&lt;String, Integer&gt; emptyNetwork =
        NetworkBuilder.directed()
            .allowsSelfLoops(true)
            .nodeOrder(ElementOrder.&lt;String&gt;natural())
            .&lt;String, Integer&gt;immutable()
            .build();

    assertThat(emptyNetwork.isDirected()).isTrue();
    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.&lt;String&gt;natural());
  }

  /**
   * Tests that the ImmutableNetwork.Builder doesn't change when the creating NetworkBuilder
   * changes.
   */
  @Test
  @SuppressWarnings("CheckReturnValue")
  public void immutableNetworkBuilder_copiesNetworkBuilder() {
    NetworkBuilder&lt;String, Object&gt; networkBuilder =
        NetworkBuilder.directed()
            .allowsSelfLoops(true)
            .&lt;String&gt;nodeOrder(ElementOrder.&lt;String&gt;natural());
    ImmutableNetwork.Builder&lt;String, Integer&gt; immutableNetworkBuilder =
        networkBuilder.&lt;String, Integer&gt;immutable();

    // Update NetworkBuilder, but this shouldn't impact immutableNetworkBuilder
    networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.&lt;String&gt;unordered());

    ImmutableNetwork&lt;String, Integer&gt; emptyNetwork = immutableNetworkBuilder.build();

    assertThat(emptyNetwork.isDirected()).isTrue();
    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.&lt;String&gt;natural());
  }

  @Test
  public void immutableNetworkBuilder_addNode() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed().&lt;String, Integer&gt;immutable().addNode("A").build();

    assertThat(network.nodes()).containsExactly("A");
    assertThat(network.edges()).isEmpty();
  }

  @Test
  public void immutableNetworkBuilder_putEdgeFromNodes() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed().&lt;String, Integer&gt;immutable().addEdge("A", "B", 10).build();

    assertThat(network.nodes()).containsExactly("A", "B");
    assertThat(network.edges()).containsExactly(10);
    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered("A", "B"));
  }

  @Test
  public void immutableNetworkBuilder_putEdgeFromEndpointPair() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed()
            .&lt;String, Integer&gt;immutable()
            .addEdge(EndpointPair.ordered("A", "B"), 10)
            .build();

    assertThat(network.nodes()).containsExactly("A", "B");
    assertThat(network.edges()).containsExactly(10);
    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered("A", "B"));
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SpliteratorTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2015 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect.testing;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder;
import static com.google.common.collect.testing.Helpers.assertEqualInOrder;
import static com.google.common.collect.testing.Platform.format;
import static java.util.Comparator.naturalOrder;
import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertTrue;
import static junit.framework.Assert.fail;

import com.google.common.annotations.GwtCompatible;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Ints;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.checkerframework.checker.nullness.qual.Nullable;

/** Tester for {@code Spliterator} implementations. */
@GwtCompatible
public final class SpliteratorTester&lt;E&gt; {
  /** Return type from "contains the following elements" assertions. */
  public interface Ordered {
    /**
     * Attests that the expected values must not just be present but must be present in the order
     * they were given.
     */
    void inOrder();
  }

  private abstract static class GeneralSpliterator&lt;E&gt; {
    final Spliterator&lt;E&gt; spliterator;

    GeneralSpliterator(Spliterator&lt;E&gt; spliterator) {
      this.spliterator = checkNotNull(spliterator);
    }

    abstract void forEachRemaining(Consumer&lt;? super E&gt; action);

    abstract boolean tryAdvance(Consumer&lt;? super E&gt; action);

    abstract GeneralSpliterator&lt;E&gt; trySplit();

    final int characteristics() {
      return spliterator.characteristics();
    }

    final long estimateSize() {
      return spliterator.estimateSize();
    }

    final Comparator&lt;? super E&gt; getComparator() {
      return spliterator.getComparator();
    }

    final long getExactSizeIfKnown() {
      return spliterator.getExactSizeIfKnown();
    }

    final boolean hasCharacteristics(int characteristics) {
      return spliterator.hasCharacteristics(characteristics);
    }
  }

  private static final class GeneralSpliteratorOfObject&lt;E&gt; extends GeneralSpliterator&lt;E&gt; {
    GeneralSpliteratorOfObject(Spliterator&lt;E&gt; spliterator) {
      super(spliterator);
    }

    @Override
    void forEachRemaining(Consumer&lt;? super E&gt; action) {
      spliterator.forEachRemaining(action);
    }

    @Override
    boolean tryAdvance(Consumer&lt;? super E&gt; action) {
      return spliterator.tryAdvance(action);
    }

    @Override
    GeneralSpliterator&lt;E&gt; trySplit() {
      Spliterator&lt;E&gt; split = spliterator.trySplit();
      return split == null ? null : new GeneralSpliteratorOfObject&lt;&gt;(split);
    }
  }

  /*
   * The AndroidJdkLibsChecker violation is informing us that this method isn't usable under
   * Desugar. But we want to include it here for Nougat+ users -- and, mainly, for non-Android
   * users. Fortunately, anyone who tries to use it under Desugar will presumably already see errors
   * from creating the Spliterator.OfInt in the first place. So it's probably OK for us to suppress
   * this particular violation.
   */
  @SuppressWarnings("AndroidJdkLibsChecker")
  private static final class GeneralSpliteratorOfPrimitive&lt;E, C&gt; extends GeneralSpliterator&lt;E&gt; {
    final Spliterator.OfPrimitive&lt;E, C, ?&gt; spliterator;
    final Function&lt;Consumer&lt;? super E&gt;, C&gt; consumerizer;

    GeneralSpliteratorOfPrimitive(
        Spliterator.OfPrimitive&lt;E, C, ?&gt; spliterator,
        Function&lt;Consumer&lt;? super E&gt;, C&gt; consumerizer) {
      super(spliterator);
      this.spliterator = spliterator;
      this.consumerizer = consumerizer;
    }

    @Override
    void forEachRemaining(Consumer&lt;? super E&gt; action) {
      spliterator.forEachRemaining(consumerizer.apply(action));
    }
<a name="0"></a>
    @Override
    boolean tryAdvance(Consumer&lt;? super E&gt; action) {
      return <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>spliterator.tryAdvance(consumerizer.apply(action));
    }

    @Override
    GeneralSpliterator&lt;E&gt; trySplit() {
      Spliterator.OfPrimitive&lt;E, C, ?&gt; split = spliterator.trySplit</b></font>();
      return split == null ? null : new GeneralSpliteratorOfPrimitive&lt;&gt;(split, consumerizer);
    }
  }

  /**
   * Different ways of decomposing a Spliterator, all of which must produce the same elements (up to
   * ordering, if Spliterator.ORDERED is not present).
   */
  enum SpliteratorDecompositionStrategy {
    NO_SPLIT_FOR_EACH_REMAINING {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        spliterator.forEachRemaining(consumer);
      }
    },
    NO_SPLIT_TRY_ADVANCE {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        while (spliterator.tryAdvance(consumer)) {
          // do nothing
        }
      }
    },
    MAXIMUM_SPLIT {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        for (GeneralSpliterator&lt;E&gt; prefix = trySplitTestingSize(spliterator);
            prefix != null;
            prefix = trySplitTestingSize(spliterator)) {
          forEach(prefix, consumer);
        }
        long size = spliterator.getExactSizeIfKnown();
        long[] counter = {0};
        spliterator.forEachRemaining(
            e -&gt; {
              consumer.accept(e);
              counter[0]++;
            });
        if (size &gt;= 0) {
          assertEquals(size, counter[0]);
        }
      }
    },
    ALTERNATE_ADVANCE_AND_SPLIT {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        while (spliterator.tryAdvance(consumer)) {
          GeneralSpliterator&lt;E&gt; prefix = trySplitTestingSize(spliterator);
          if (prefix != null) {
            forEach(prefix, consumer);
          }
        }
      }
    };

    abstract &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer);
  }

  private static &lt;E&gt; @Nullable GeneralSpliterator&lt;E&gt; trySplitTestingSize(
      GeneralSpliterator&lt;E&gt; spliterator) {
    boolean subsized = spliterator.hasCharacteristics(Spliterator.SUBSIZED);
    long originalSize = spliterator.estimateSize();
    GeneralSpliterator&lt;E&gt; trySplit = spliterator.trySplit();
    if (spliterator.estimateSize() &gt; originalSize) {
      fail(
          format(
              "estimated size of spliterator after trySplit (%s) is larger than original size (%s)",
              spliterator.estimateSize(), originalSize));
    }
    if (trySplit != null) {
      if (trySplit.estimateSize() &gt; originalSize) {
        fail(
            format(
                "estimated size of trySplit result (%s) is larger than original size (%s)",
                trySplit.estimateSize(), originalSize));
      }
    }
    if (subsized) {
      if (trySplit != null) {
        assertEquals(
            "sum of estimated sizes of trySplit and original spliterator after trySplit",
            originalSize,
            trySplit.estimateSize() + spliterator.estimateSize());
      } else {
        assertEquals(
            "estimated size of spliterator after failed trySplit",
            originalSize,
            spliterator.estimateSize());
      }
    }
    return trySplit;
  }

  public static &lt;E&gt; SpliteratorTester&lt;E&gt; of(Supplier&lt;Spliterator&lt;E&gt;&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(() -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get())));
  }

  /** @since 28.1 */
  @SuppressWarnings("AndroidJdkLibsChecker") // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Integer&gt; ofInt(Supplier&lt;Spliterator.OfInt&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  /** @since 28.1 */
  @SuppressWarnings("AndroidJdkLibsChecker") // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Long&gt; ofLong(Supplier&lt;Spliterator.OfLong&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  /** @since 28.1 */
  @SuppressWarnings("AndroidJdkLibsChecker") // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Double&gt; ofDouble(
      Supplier&lt;Spliterator.OfDouble&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  private final ImmutableSet&lt;Supplier&lt;GeneralSpliterator&lt;E&gt;&gt;&gt; spliteratorSuppliers;

  private SpliteratorTester(ImmutableSet&lt;Supplier&lt;GeneralSpliterator&lt;E&gt;&gt;&gt; spliteratorSuppliers) {
    this.spliteratorSuppliers = checkNotNull(spliteratorSuppliers);
  }

  @SafeVarargs
  public final Ordered expect(Object... elements) {
    return expect(Arrays.asList(elements));
  }

  public final Ordered expect(Iterable&lt;?&gt; elements) {
    List&lt;List&lt;E&gt;&gt; resultsForAllStrategies = new ArrayList&lt;&gt;();
    for (Supplier&lt;GeneralSpliterator&lt;E&gt;&gt; spliteratorSupplier : spliteratorSuppliers) {
      GeneralSpliterator&lt;E&gt; spliterator = spliteratorSupplier.get();
      int characteristics = spliterator.characteristics();
      long estimatedSize = spliterator.estimateSize();
      for (SpliteratorDecompositionStrategy strategy :
          EnumSet.allOf(SpliteratorDecompositionStrategy.class)) {
        List&lt;E&gt; resultsForStrategy = new ArrayList&lt;&gt;();
        strategy.forEach(spliteratorSupplier.get(), resultsForStrategy::add);

        // TODO(cpovirk): better failure messages
        if ((characteristics &amp; Spliterator.NONNULL) != 0) {
          assertFalse(resultsForStrategy.contains(null));
        }
        if ((characteristics &amp; Spliterator.SORTED) != 0) {
          Comparator&lt;? super E&gt; comparator = spliterator.getComparator();
          if (comparator == null) {
            comparator = (Comparator) naturalOrder();
          }
          assertTrue(Ordering.from(comparator).isOrdered(resultsForStrategy));
        }
        if ((characteristics &amp; Spliterator.SIZED) != 0) {
          assertEquals(Ints.checkedCast(estimatedSize), resultsForStrategy.size());
        }

        assertEqualIgnoringOrder(elements, resultsForStrategy);
        resultsForAllStrategies.add(resultsForStrategy);
      }
    }
    return new Ordered() {
      @Override
      public void inOrder() {
        for (List&lt;E&gt; resultsForStrategy : resultsForAllStrategies) {
          assertEqualInOrder(elements, resultsForStrategy);
        }
      }
    };
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
