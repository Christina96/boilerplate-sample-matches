<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ImmutableNetworkTest_1.java & SpliteratorTester.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ImmutableNetworkTest_1.java & SpliteratorTester.java
      </h3>
      <h1 align="center">
        2.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ImmutableNetworkTest_1.java (4.6632123%)<TH>SpliteratorTester.java (2.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1807446-0.html#0',2,'match1807446-1.html#0',3)" NAME="0">(40-46)<TD><A HREF="javascript:ZweiFrames('match1807446-0.html#0',2,'match1807446-1.html#0',3)" NAME="0">(139-144)</A><TD ALIGN=center><FONT COLOR="#ff0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableNetworkTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.graph;

import static com.google.common.truth.Truth.assertThat;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for {@link ImmutableNetwork}. */
@RunWith(JUnit4.class)
public class ImmutableNetworkTest {

  @Test
  public void immutableNetwork() {
    MutableNetwork&lt;String, Integer&gt; mutableNetwork = NetworkBuilder.directed().build();
    mutableNetwork.addNode(&quot;A&quot;);
    ImmutableNetwork&lt;String, Integer&gt; immutableNetwork = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(immutableNetwork.asGraph()).isInstanceOf(ImmutableGraph.class);
    assertThat(immutableNetwork).isNotInstanceOf(MutableNetwork.class);
<A NAME="0"></A>    assertThat(immutableNetwork).isEqualTo(mutableNetwork);

    mutableNetwork.addNode(&quot;B&quot;);
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1807446-1.html#0',3,'match1807446-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(immutableNetwork).isNotEqualTo(mutableNetwork);
  }

  @Test
  public void copyOfImmutableNetwork_optimized() {
    Network&lt;String, String&gt; network1 =
        ImmutableNetwork.copyOf</B></FONT>(NetworkBuilder.directed().&lt;String, String&gt;build());
    Network&lt;String, String&gt; network2 = ImmutableNetwork.copyOf(network1);

    assertThat(network2).isSameInstanceAs(network1);
  }

  @Test
  public void edgesConnecting_directed() {
    MutableNetwork&lt;String, String&gt; mutableNetwork =
        NetworkBuilder.directed().allowsSelfLoops(true).build();
    mutableNetwork.addEdge(&quot;A&quot;, &quot;A&quot;, &quot;AA&quot;);
    mutableNetwork.addEdge(&quot;A&quot;, &quot;B&quot;, &quot;AB&quot;);
    Network&lt;String, String&gt; network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting(&quot;A&quot;, &quot;A&quot;)).containsExactly(&quot;AA&quot;);
    assertThat(network.edgesConnecting(&quot;A&quot;, &quot;B&quot;)).containsExactly(&quot;AB&quot;);
    assertThat(network.edgesConnecting(&quot;B&quot;, &quot;A&quot;)).isEmpty();
  }

  @Test
  public void edgesConnecting_undirected() {
    MutableNetwork&lt;String, String&gt; mutableNetwork =
        NetworkBuilder.undirected().allowsSelfLoops(true).build();
    mutableNetwork.addEdge(&quot;A&quot;, &quot;A&quot;, &quot;AA&quot;);
    mutableNetwork.addEdge(&quot;A&quot;, &quot;B&quot;, &quot;AB&quot;);
    Network&lt;String, String&gt; network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting(&quot;A&quot;, &quot;A&quot;)).containsExactly(&quot;AA&quot;);
    assertThat(network.edgesConnecting(&quot;A&quot;, &quot;B&quot;)).containsExactly(&quot;AB&quot;);
    assertThat(network.edgesConnecting(&quot;B&quot;, &quot;A&quot;)).containsExactly(&quot;AB&quot;);
  }

  @Test
  public void immutableNetworkBuilder_appliesNetworkBuilderConfig() {
    ImmutableNetwork&lt;String, Integer&gt; emptyNetwork =
        NetworkBuilder.directed()
            .allowsSelfLoops(true)
            .nodeOrder(ElementOrder.&lt;String&gt;natural())
            .&lt;String, Integer&gt;immutable()
            .build();

    assertThat(emptyNetwork.isDirected()).isTrue();
    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.&lt;String&gt;natural());
  }

  /**
   * Tests that the ImmutableNetwork.Builder doesn't change when the creating NetworkBuilder
   * changes.
   */
  @Test
  @SuppressWarnings(&quot;CheckReturnValue&quot;)
  public void immutableNetworkBuilder_copiesNetworkBuilder() {
    NetworkBuilder&lt;String, Object&gt; networkBuilder =
        NetworkBuilder.directed()
            .allowsSelfLoops(true)
            .&lt;String&gt;nodeOrder(ElementOrder.&lt;String&gt;natural());
    ImmutableNetwork.Builder&lt;String, Integer&gt; immutableNetworkBuilder =
        networkBuilder.&lt;String, Integer&gt;immutable();

    // Update NetworkBuilder, but this shouldn't impact immutableNetworkBuilder
    networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.&lt;String&gt;unordered());

    ImmutableNetwork&lt;String, Integer&gt; emptyNetwork = immutableNetworkBuilder.build();

    assertThat(emptyNetwork.isDirected()).isTrue();
    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.&lt;String&gt;natural());
  }

  @Test
  public void immutableNetworkBuilder_addNode() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed().&lt;String, Integer&gt;immutable().addNode(&quot;A&quot;).build();

    assertThat(network.nodes()).containsExactly(&quot;A&quot;);
    assertThat(network.edges()).isEmpty();
  }

  @Test
  public void immutableNetworkBuilder_putEdgeFromNodes() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed().&lt;String, Integer&gt;immutable().addEdge(&quot;A&quot;, &quot;B&quot;, 10).build();

    assertThat(network.nodes()).containsExactly(&quot;A&quot;, &quot;B&quot;);
    assertThat(network.edges()).containsExactly(10);
    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(&quot;A&quot;, &quot;B&quot;));
  }

  @Test
  public void immutableNetworkBuilder_putEdgeFromEndpointPair() {
    ImmutableNetwork&lt;String, Integer&gt; network =
        NetworkBuilder.directed()
            .&lt;String, Integer&gt;immutable()
            .addEdge(EndpointPair.ordered(&quot;A&quot;, &quot;B&quot;), 10)
            .build();

    assertThat(network.nodes()).containsExactly(&quot;A&quot;, &quot;B&quot;);
    assertThat(network.edges()).containsExactly(10);
    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(&quot;A&quot;, &quot;B&quot;));
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SpliteratorTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2015 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect.testing;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder;
import static com.google.common.collect.testing.Helpers.assertEqualInOrder;
import static com.google.common.collect.testing.Platform.format;
import static java.util.Comparator.naturalOrder;
import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertTrue;
import static junit.framework.Assert.fail;

import com.google.common.annotations.GwtCompatible;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Ints;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.checkerframework.checker.nullness.qual.Nullable;

/** Tester for {@code Spliterator} implementations. */
@GwtCompatible
public final class SpliteratorTester&lt;E&gt; {
  /** Return type from &quot;contains the following elements&quot; assertions. */
  public interface Ordered {
    /**
     * Attests that the expected values must not just be present but must be present in the order
     * they were given.
     */
    void inOrder();
  }

  private abstract static class GeneralSpliterator&lt;E&gt; {
    final Spliterator&lt;E&gt; spliterator;

    GeneralSpliterator(Spliterator&lt;E&gt; spliterator) {
      this.spliterator = checkNotNull(spliterator);
    }

    abstract void forEachRemaining(Consumer&lt;? super E&gt; action);

    abstract boolean tryAdvance(Consumer&lt;? super E&gt; action);

    abstract GeneralSpliterator&lt;E&gt; trySplit();

    final int characteristics() {
      return spliterator.characteristics();
    }

    final long estimateSize() {
      return spliterator.estimateSize();
    }

    final Comparator&lt;? super E&gt; getComparator() {
      return spliterator.getComparator();
    }

    final long getExactSizeIfKnown() {
      return spliterator.getExactSizeIfKnown();
    }

    final boolean hasCharacteristics(int characteristics) {
      return spliterator.hasCharacteristics(characteristics);
    }
  }

  private static final class GeneralSpliteratorOfObject&lt;E&gt; extends GeneralSpliterator&lt;E&gt; {
    GeneralSpliteratorOfObject(Spliterator&lt;E&gt; spliterator) {
      super(spliterator);
    }

    @Override
    void forEachRemaining(Consumer&lt;? super E&gt; action) {
      spliterator.forEachRemaining(action);
    }

    @Override
    boolean tryAdvance(Consumer&lt;? super E&gt; action) {
      return spliterator.tryAdvance(action);
    }

    @Override
    GeneralSpliterator&lt;E&gt; trySplit() {
      Spliterator&lt;E&gt; split = spliterator.trySplit();
      return split == null ? null : new GeneralSpliteratorOfObject&lt;&gt;(split);
    }
  }

  /*
   * The AndroidJdkLibsChecker violation is informing us that this method isn't usable under
   * Desugar. But we want to include it here for Nougat+ users -- and, mainly, for non-Android
   * users. Fortunately, anyone who tries to use it under Desugar will presumably already see errors
   * from creating the Spliterator.OfInt in the first place. So it's probably OK for us to suppress
   * this particular violation.
   */
  @SuppressWarnings(&quot;AndroidJdkLibsChecker&quot;)
  private static final class GeneralSpliteratorOfPrimitive&lt;E, C&gt; extends GeneralSpliterator&lt;E&gt; {
    final Spliterator.OfPrimitive&lt;E, C, ?&gt; spliterator;
    final Function&lt;Consumer&lt;? super E&gt;, C&gt; consumerizer;

    GeneralSpliteratorOfPrimitive(
        Spliterator.OfPrimitive&lt;E, C, ?&gt; spliterator,
        Function&lt;Consumer&lt;? super E&gt;, C&gt; consumerizer) {
      super(spliterator);
      this.spliterator = spliterator;
      this.consumerizer = consumerizer;
    }

    @Override
    void forEachRemaining(Consumer&lt;? super E&gt; action) {
      spliterator.forEachRemaining(consumerizer.apply(action));
    }
<A NAME="0"></A>
    @Override
    boolean tryAdvance(Consumer&lt;? super E&gt; action) {
      return <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1807446-0.html#0',2,'match1807446-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>spliterator.tryAdvance(consumerizer.apply(action));
    }

    @Override
    GeneralSpliterator&lt;E&gt; trySplit() {
      Spliterator.OfPrimitive&lt;E, C, ?&gt; split = spliterator.trySplit</B></FONT>();
      return split == null ? null : new GeneralSpliteratorOfPrimitive&lt;&gt;(split, consumerizer);
    }
  }

  /**
   * Different ways of decomposing a Spliterator, all of which must produce the same elements (up to
   * ordering, if Spliterator.ORDERED is not present).
   */
  enum SpliteratorDecompositionStrategy {
    NO_SPLIT_FOR_EACH_REMAINING {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        spliterator.forEachRemaining(consumer);
      }
    },
    NO_SPLIT_TRY_ADVANCE {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        while (spliterator.tryAdvance(consumer)) {
          // do nothing
        }
      }
    },
    MAXIMUM_SPLIT {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        for (GeneralSpliterator&lt;E&gt; prefix = trySplitTestingSize(spliterator);
            prefix != null;
            prefix = trySplitTestingSize(spliterator)) {
          forEach(prefix, consumer);
        }
        long size = spliterator.getExactSizeIfKnown();
        long[] counter = {0};
        spliterator.forEachRemaining(
            e -&gt; {
              consumer.accept(e);
              counter[0]++;
            });
        if (size &gt;= 0) {
          assertEquals(size, counter[0]);
        }
      }
    },
    ALTERNATE_ADVANCE_AND_SPLIT {
      @Override
      &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer) {
        while (spliterator.tryAdvance(consumer)) {
          GeneralSpliterator&lt;E&gt; prefix = trySplitTestingSize(spliterator);
          if (prefix != null) {
            forEach(prefix, consumer);
          }
        }
      }
    };

    abstract &lt;E&gt; void forEach(GeneralSpliterator&lt;E&gt; spliterator, Consumer&lt;? super E&gt; consumer);
  }

  private static &lt;E&gt; @Nullable GeneralSpliterator&lt;E&gt; trySplitTestingSize(
      GeneralSpliterator&lt;E&gt; spliterator) {
    boolean subsized = spliterator.hasCharacteristics(Spliterator.SUBSIZED);
    long originalSize = spliterator.estimateSize();
    GeneralSpliterator&lt;E&gt; trySplit = spliterator.trySplit();
    if (spliterator.estimateSize() &gt; originalSize) {
      fail(
          format(
              &quot;estimated size of spliterator after trySplit (%s) is larger than original size (%s)&quot;,
              spliterator.estimateSize(), originalSize));
    }
    if (trySplit != null) {
      if (trySplit.estimateSize() &gt; originalSize) {
        fail(
            format(
                &quot;estimated size of trySplit result (%s) is larger than original size (%s)&quot;,
                trySplit.estimateSize(), originalSize));
      }
    }
    if (subsized) {
      if (trySplit != null) {
        assertEquals(
            &quot;sum of estimated sizes of trySplit and original spliterator after trySplit&quot;,
            originalSize,
            trySplit.estimateSize() + spliterator.estimateSize());
      } else {
        assertEquals(
            &quot;estimated size of spliterator after failed trySplit&quot;,
            originalSize,
            spliterator.estimateSize());
      }
    }
    return trySplit;
  }

  public static &lt;E&gt; SpliteratorTester&lt;E&gt; of(Supplier&lt;Spliterator&lt;E&gt;&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(() -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get())));
  }

  /** @since 28.1 */
  @SuppressWarnings(&quot;AndroidJdkLibsChecker&quot;) // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Integer&gt; ofInt(Supplier&lt;Spliterator.OfInt&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  /** @since 28.1 */
  @SuppressWarnings(&quot;AndroidJdkLibsChecker&quot;) // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Long&gt; ofLong(Supplier&lt;Spliterator.OfLong&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  /** @since 28.1 */
  @SuppressWarnings(&quot;AndroidJdkLibsChecker&quot;) // see comment on GeneralSpliteratorOfPrimitive
  public static SpliteratorTester&lt;Double&gt; ofDouble(
      Supplier&lt;Spliterator.OfDouble&gt; spliteratorSupplier) {
    return new SpliteratorTester&lt;&gt;(
        ImmutableSet.of(
            () -&gt; new GeneralSpliteratorOfObject&lt;&gt;(spliteratorSupplier.get()),
            () -&gt; new GeneralSpliteratorOfPrimitive&lt;&gt;(spliteratorSupplier.get(), c -&gt; c::accept)));
  }

  private final ImmutableSet&lt;Supplier&lt;GeneralSpliterator&lt;E&gt;&gt;&gt; spliteratorSuppliers;

  private SpliteratorTester(ImmutableSet&lt;Supplier&lt;GeneralSpliterator&lt;E&gt;&gt;&gt; spliteratorSuppliers) {
    this.spliteratorSuppliers = checkNotNull(spliteratorSuppliers);
  }

  @SafeVarargs
  public final Ordered expect(Object... elements) {
    return expect(Arrays.asList(elements));
  }

  public final Ordered expect(Iterable&lt;?&gt; elements) {
    List&lt;List&lt;E&gt;&gt; resultsForAllStrategies = new ArrayList&lt;&gt;();
    for (Supplier&lt;GeneralSpliterator&lt;E&gt;&gt; spliteratorSupplier : spliteratorSuppliers) {
      GeneralSpliterator&lt;E&gt; spliterator = spliteratorSupplier.get();
      int characteristics = spliterator.characteristics();
      long estimatedSize = spliterator.estimateSize();
      for (SpliteratorDecompositionStrategy strategy :
          EnumSet.allOf(SpliteratorDecompositionStrategy.class)) {
        List&lt;E&gt; resultsForStrategy = new ArrayList&lt;&gt;();
        strategy.forEach(spliteratorSupplier.get(), resultsForStrategy::add);

        // TODO(cpovirk): better failure messages
        if ((characteristics &amp; Spliterator.NONNULL) != 0) {
          assertFalse(resultsForStrategy.contains(null));
        }
        if ((characteristics &amp; Spliterator.SORTED) != 0) {
          Comparator&lt;? super E&gt; comparator = spliterator.getComparator();
          if (comparator == null) {
            comparator = (Comparator) naturalOrder();
          }
          assertTrue(Ordering.from(comparator).isOrdered(resultsForStrategy));
        }
        if ((characteristics &amp; Spliterator.SIZED) != 0) {
          assertEquals(Ints.checkedCast(estimatedSize), resultsForStrategy.size());
        }

        assertEqualIgnoringOrder(elements, resultsForStrategy);
        resultsForAllStrategies.add(resultsForStrategy);
      }
    }
    return new Ordered() {
      @Override
      public void inOrder() {
        for (List&lt;E&gt; resultsForStrategy : resultsForAllStrategies) {
          assertEqualInOrder(elements, resultsForStrategy);
        }
      }
    };
  }
}
</PRE>
</div>
  </div>
</body>
</html>
