<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for DocValuesGroupByOptimizedIterator.java &amp; NodeStatsTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DocValuesGroupByOptimizedIterator.java &amp; NodeStatsTest.java
      </h3>
<h1 align="center">
        12.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DocValuesGroupByOptimizedIterator.java (13.162705%)<th>NodeStatsTest.java (12.5%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(372-375)<td><a href="#" name="1">(280-284)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(240-243)<td><a href="#" name="2">(152-155)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(389-393)<td><a href="#" name="3">(332-335)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(360-362)<td><a href="#" name="4">(168-170)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(147-154)<td><a href="#" name="5">(134-136)</a><td align="center"><font color="#5b0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DocValuesGroupByOptimizedIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.engine.collect;

import static io.crate.execution.dsl.projection.Projections.shardProjections;
import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Function;

import javax.annotation.Nullable;

import io.crate.execution.engine.fetch.ReaderContext;
import io.crate.memory.MemoryManager;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreMode;
import org.apache.lucene.search.Scorer;
import org.apache.lucene.search.Weight;
import org.apache.lucene.util.Bits;
import</b></font> org.elasticsearch.Version;
import org.elasticsearch.index.query.QueryShardContext;
import org.elasticsearch.index.shard.IndexShard;
import org.elasticsearch.index.shard.ShardId;

import io.crate.breaker.MultiSizeEstimator;
import io.crate.breaker.RamAccounting;
import io.crate.breaker.SizeEstimatorFactory;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.data.BatchIterator;
import io.crate.data.CollectingBatchIterator;
import io.crate.data.Row;
import io.crate.data.RowN;
import io.crate.exceptions.Exceptions;
import io.crate.execution.dsl.phases.RoutedCollectPhase;
import io.crate.execution.dsl.projection.GroupProjection;
import io.crate.execution.dsl.projection.Projection;
import io.crate.execution.engine.aggregation.DocValueAggregator;
import io.crate.execution.engine.aggregation.GroupByMaps;
import io.crate.execution.jobs.SharedShardContext;
import io.crate.expression.InputFactory;
import io.crate.expression.reference.doc.lucene.CollectorContext;
import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
import io.crate.expression.symbol.AggregateMode;
import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.lucene.FieldTypeLookup;
import io.crate.lucene.LuceneQueryBuilder;
import io.crate.metadata.DocReferences;
import io.crate.metadata.Functions;
import io.crate.metadata.Reference;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;

final class DocValuesGroupByOptimizedIterator {

    @Nullable
    static BatchIterator&lt;Row&gt; tryOptimize(Functions functions,
                                          IndexShard indexShard,
                                          DocTableInfo table,
                                          LuceneQueryBuilder luceneQueryBuilder,
                                          FieldTypeLookup fieldTypeLookup,
                                          DocInputFactory docInputFactory,
                                          RoutedCollectPhase collectPhase,
                                          CollectTask collectTask) {
        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)
            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {
            return null;
        }

        Collection&lt;? extends Projection&gt; shardProjections = shardProjections(collectPhase.projections());
        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);
        if (groupProjection == null) {
            return null;
        }

        ArrayList&lt;Reference&gt; columnKeyRefs = new ArrayList&lt;&gt;(groupProjection.keys().size());
        for (var key : groupProjection.keys()) {
            var docKeyRef = getKeyRef(collectPhase.toCollect(), key);
            if (docKeyRef == null) {
                return null; // group by on non-reference
            }
            var columnKeyRef = (Reference) DocReferences.inverseSourceLookup(docKeyRef);
            var keyFieldType = fieldTypeLookup.get(columnKeyRef.column().fqn());
            if (keyFieldType == null || !keyFieldType.hasDocValues()) {
                return null;
            } else {
                columnKeyRefs.add(columnKeyRef);
            }
        }

        //noinspection rawtypes
        List&lt;DocValueAggregator&gt; aggregators = DocValuesAggregates.createAggregators(
            functions,
            groupProjection.values(),
            collectPhase.toCollect(),
            collectTask.txnCtx().sessionSettings().searchPath(),
            table
        );
        if (aggregators == null) {
            return null;
        }

        ShardId shardId = indexShard.shardId();
        SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);
        var searcher = sharedShardContext.acquireSearcher("group-by-doc-value-aggregates: " + formatSource(collectPhase));
        collectTask.addSearcher(sharedShardContext.readerId(), searcher);
        QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();

        InputFactory.Context&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; docCtx
            = docInputFactory.getCtx(collectTask.txnCtx());
        List&lt;LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions = new ArrayList&lt;&gt;();
<a name="5"></a>        for (var keyRef : columnKeyRefs) {
            keyExpressions.add((LuceneCollectorExpression&lt;?&gt;) docCtx.add(keyRef));
        }
        <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(
            collectPhase.where(),
            collectTask.txnCtx(),
            indexShard.mapperService(),
            indexShard.shardId().getIndexName(),
            queryShardContext,
            table,
            sharedShardContext.indexService</b></font>().cache()
        );

        if (columnKeyRefs.size() == 1) {
            return GroupByIterator.forSingleKey(
                aggregators,
                searcher.item(),
                columnKeyRefs.get(0),
                keyExpressions,
                collectTask.getRamAccounting(),
                collectTask.memoryManager(),
                collectTask.minNodeVersion(),
                queryContext.query(),
                new CollectorContext(sharedShardContext.readerId())
            );
        } else {
            return GroupByIterator.forManyKeys(
                aggregators,
                searcher.item(),
                columnKeyRefs,
                keyExpressions,
                collectTask.getRamAccounting(),
                collectTask.memoryManager(),
                collectTask.minNodeVersion(),
                queryContext.query(),
                new CollectorContext(sharedShardContext.readerId())
            );
        }
    }

    static class GroupByIterator {

        @VisibleForTesting
        static BatchIterator&lt;Row&gt; forSingleKey(List&lt;DocValueAggregator&gt; aggregators,
                                               IndexSearcher indexSearcher,
                                               Reference keyReference,
                                               List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                               RamAccounting ramAccounting,
                                               MemoryManager memoryManager,
                                               Version minNodeVersion,
                                               Query query,
                                               CollectorContext collectorContext) {
            return GroupByIterator.getIterator(
                aggregators,
                indexSearcher,
                keyExpressions,
                ramAccounting,
                memoryManager,
                minNodeVersion,
                GroupByMaps.accountForNewEntry(
                    ramAccounting,
                    SizeEstimatorFactory.create(keyReference.valueType()),
                    null
                ),
                (expressions) -&gt; expressions.get(0).value(),
                (key, cells) -&gt; cells[0] = key,
                query,
                new CollectorContext(collectorContext.readerId())
            );
        }

        @VisibleForTesting
        static &lt;K&gt; BatchIterator&lt;Row&gt; forManyKeys(List&lt;DocValueAggregator&gt; aggregators,
                                                  IndexSearcher indexSearcher,
                                                  List&lt;Reference&gt; keyColumnRefs,
                                                  List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                                  RamAccounting ramAccounting,
                                                  MemoryManager memoryManager,
                                                  Version minNodeVersion,
                                                  Query query,
                                                  CollectorContext collectorContext) {
            return GroupByIterator.getIterator(
                aggregators,
                indexSearcher,
                keyExpressions,
                ramAccounting,
                memoryManager,
                minNodeVersion,
                GroupByMaps.accountForNewEntry(
                    ramAccounting,
                    new MultiSizeEstimator(
                        Lists2.map(keyColumnRefs, Reference::valueType)
                    ),
<a name="2"></a>                    null
                ),
                (expressions) -&gt; {
                    ArrayList&lt;Object&gt; key = new ArrayList&lt;&gt;(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>keyColumnRefs.size());
                    for (int i = 0; i &lt; expressions.size(); i++) {
                        key.add(expressions.get(i).value());
                    }</b></font>
                    return key;
                },
                (List&lt;Object&gt; keys, Object[] cells) -&gt; {
                    for (int i = 0; i &lt; keys.size(); i++) {
                        cells[i] = keys.get(i);
                    }
                },
                query,
                new CollectorContext(collectorContext.readerId())
            );
        }

        @VisibleForTesting
        static &lt;K&gt; BatchIterator&lt;Row&gt; getIterator(List&lt;DocValueAggregator&gt; aggregators,
                                                  IndexSearcher indexSearcher,
                                                  List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                                  RamAccounting ramAccounting,
                                                  MemoryManager memoryManager,
                                                  Version minNodeVersion,
                                                  BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
                                                  Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
                                                  BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                                                  Query query,
                                                  CollectorContext collectorContext) {
            for (int i = 0; i &lt; keyExpressions.size(); i++) {
                keyExpressions.get(i).startCollect(collectorContext);
            }

            AtomicReference&lt;Throwable&gt; killed = new AtomicReference&lt;&gt;();
            return CollectingBatchIterator.newInstance(
                () -&gt; killed.set(BatchIterator.CLOSED),
                killed::set,
                () -&gt; {
                    try {
                        return CompletableFuture.completedFuture(
                            getRows(
                                applyAggregatesGroupedByKey(
                                    aggregators,
                                    indexSearcher,
                                    keyExpressions,
                                    accountForNewKeyEntry,
                                    keyExtractor,
                                    ramAccounting,
                                    memoryManager,
                                    minNodeVersion,
                                    query,
                                    killed
                                ),
                                keyExpressions.size(),
                                applyKeyToCells,
                                aggregators,
                                ramAccounting
                            )
                        );
                    } catch (Throwable t) {
                        return CompletableFuture.failedFuture(t);
                    }
                },
                true
            );
        }

        private static &lt;K&gt; Iterable&lt;Row&gt; getRows(Map&lt;K, Object[]&gt; groupedStates,
                                                 int numberOfKeys,
                                                 BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                                                 List&lt;DocValueAggregator&gt; aggregators,
                                                 RamAccounting ramAccounting) {
            return () -&gt; {
                Object[] cells = new Object[numberOfKeys + aggregators.size()];
                RowN row = new RowN(cells);
                Function&lt;Map.Entry&lt;K, Object[]&gt;, Row&gt; mapper = entry -&gt; {
                    K key = entry.getKey();
                    applyKeyToCells.accept(key, cells);

                    Object[] states = entry.getValue();
                    int c = numberOfKeys;
                    for (int i = 0; i &lt; states.length; i++) {
                        //noinspection unchecked
                        cells[c] = aggregators.get(i).partialResult(ramAccounting, states[i]);
                        c++;
                    }
                    return row;
                };
                return groupedStates.entrySet().stream().map(mapper).iterator();
            };
        }

        private static &lt;K&gt; Map&lt;K, Object[]&gt; applyAggregatesGroupedByKey(
            List&lt;DocValueAggregator&gt; aggregators,
            IndexSearcher indexSearcher,
            List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
            BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
            Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
            RamAccounting ramAccounting,
            MemoryManager memoryManager,
            Version minNodeVersion,
            Query query,
            AtomicReference&lt;Throwable&gt; killed
        ) throws IOException {

            HashMap&lt;K, Object[]&gt; statesByKey = new HashMap&lt;&gt;();
            Weight weight = indexSearcher.createWeight(
                indexSearcher.rewrite(query),
                ScoreMode.COMPLETE_NO_SCORES,
                1f
            );
            List&lt;LeafReaderContext&gt; leaves = indexSearcher.getTopReaderContext().leaves();
            for (var leaf : leaves) {
                raiseIfClosedOrKilled(killed);
                Scorer scorer = weight.scorer(leaf);
                if (scorer == null) {
                    continue;
                }
<a name="4"></a>                for (int i = 0; i &lt; keyExpressions.size(); i++) {
                    keyExpressions.get(i).setNextReader(new ReaderContext(leaf));
                }
                <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; aggregators.size(); i++) {
                    aggregators.get(i).loadDocValues(leaf.reader());
                }</b></font>

                DocIdSetIterator docs = scorer.iterator();
                Bits liveDocs = leaf.reader().getLiveDocs();
                for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docs.nextDoc()) {
                    raiseIfClosedOrKilled(killed);
                    if (docDeleted(liveDocs, doc)) {
<a name="1"></a>                        continue;
                    }

                    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; keyExpressions.size(); i++) {
                        keyExpressions.get(i).setNextDocId(doc);
                    }
                    K key = keyExtractor.apply</b></font>(keyExpressions);

                    Object[] states = statesByKey.get(key);
                    if (states == null) {
                        states = new Object[aggregators.size()];
                        for (int i = 0; i &lt; aggregators.size(); i++) {
                            var aggregator = aggregators.get(i);
                            states[i] = aggregator.initialState(ramAccounting, memoryManager, minNodeVersion);
                            //noinspection unchecked
                            aggregator.apply(ramAccounting, doc, states[i]);
                        }
<a name="3"></a>                        accountForNewKeyEntry.accept(statesByKey, key);
                        statesByKey.put(key, states);
                    } else {
                        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; aggregators.size(); i++) {
                            //noinspection unchecked
                            aggregators.get(i).apply(ramAccounting, doc, states[i]);
                        }
                    }</b></font>
                }
            }
            return statesByKey;
        }

        private static boolean docDeleted(@Nullable Bits liveDocs, int doc) {
            return liveDocs != null &amp;&amp; !liveDocs.get(doc);
        }

        private static void raiseIfClosedOrKilled(AtomicReference&lt;Throwable&gt; killed) {
            Throwable killedException = killed.get();
            if (killedException != null) {
                Exceptions.rethrowUnchecked(killedException);
            }
        }
    }

    @Nullable
    private static Reference getKeyRef(List&lt;Symbol&gt; toCollect, Symbol key) {
        if (key instanceof InputColumn) {
            Symbol keyRef = toCollect.get(((InputColumn) key).index());
            if (keyRef instanceof Reference) {
                return ((Reference) keyRef);
            }
        }
        return null;
    }

    private static GroupProjection getSinglePartialGroupProjection(Collection&lt;? extends Projection&gt; shardProjections) {
        if (shardProjections.size() != 1) {
            return null;
        }
        Projection shardProjection = shardProjections.iterator().next();
        if (!(shardProjection instanceof GroupProjection) ||
            ((GroupProjection) shardProjection).mode() == AggregateMode.ITER_FINAL) {
            return null;
        }
        return (GroupProjection) shardProjection;
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>NodeStatsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.integrationtests;

import io.crate.testing.SQLResponse;
import io.crate.testing.UseJdbc;
import org.apache.lucene.util.Constants;
import org.elasticsearch.Version;
import org.elasticsearch.env.NodeEnvironment;
import org.elasticsearch.test.ESIntegTestCase;
import org.hamcrest.Matchers;
import org.junit.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.anyOf;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.lessThan;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import</b></font> static org.hamcrest.core.Is.is;

@ESIntegTestCase.ClusterScope(numClientNodes = 0, numDataNodes = 2, supportsDedicatedMasters = false)
public class NodeStatsTest extends SQLIntegrationTestCase {

    @Test
    public void testSysNodesMem() throws Exception {
        SQLResponse response = execute("select mem['free'], mem['used'], mem['free_percent'], mem['used_percent'] from sys.nodes limit 1");
        long free = (long) response.rows()[0][0];
        long used = (long) response.rows()[0][1];

        double free_percent = ((Number) response.rows()[0][2]).intValue() * 0.01;
        double used_percent = ((Number) response.rows()[0][3]).intValue() * 0.01;

        double calculated_free_percent = free / (double) (free + used);
        double calculated_used_percent = used / (double) (free + used);

        double max_delta = 0.02; // result should not differ from calculated result more than 2%
        double free_delta = Math.abs(calculated_free_percent - free_percent);
        double used_delta = Math.abs(calculated_used_percent - used_percent);
        assertThat(free_delta, is(lessThan(max_delta)));
        assertThat(used_delta, is(lessThan(max_delta)));

    }

    @SuppressWarnings("ConstantConditions")
    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testThreadPools() throws Exception {
        SQLResponse response = execute("select thread_pools from sys.nodes limit 1");

        List threadPools = (List) response.rows()[0][0];
        assertThat(threadPools.size(), greaterThanOrEqualTo(1));

        Map&lt;String, Object&gt; threadPool = null;
        for (Object t : threadPools) {
            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) t;
            if (map.get("name").equals("generic")) {
                threadPool = map;
                break;
            }
        }
        assertThat(threadPool.get("name"), is("generic"));
        assertThat((Integer) threadPool.get("active"), greaterThanOrEqualTo(0));
        assertThat((Long) threadPool.get("rejected"), greaterThanOrEqualTo(0L));
        assertThat((Integer) threadPool.get("largest"), greaterThanOrEqualTo(0));
        assertThat((Long) threadPool.get("completed"), greaterThanOrEqualTo(0L));
        assertThat((Integer) threadPool.get("threads"), greaterThanOrEqualTo(0));
        assertThat((Integer) threadPool.get("queue"), greaterThanOrEqualTo(0));
    }

    @Test
    public void testThreadPoolValue() throws Exception {
        SQLResponse response = execute("select thread_pools['name'], thread_pools['queue'] from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));

        List&lt;Object&gt; objects = (List&lt;Object&gt;) response.rows()[0][0];
        assertThat(objects, Matchers.hasItem("generic"));

        List queues = (List) response.rows()[0][1];
        assertThat(queues.size(), greaterThanOrEqualTo(1));
        assertThat((Integer) queues.get(0), greaterThanOrEqualTo(0));
    }

    @Test
    public void testNetwork() throws Exception {
        SQLResponse response = execute("select network from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));

        Map&lt;String, Object&gt; network = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertThat(network, hasKey("tcp"));
        Map&lt;String, Object&gt; tcp = (Map&lt;String, Object&gt;) network.get("tcp");
        assertNetworkTCP(tcp);


        response = execute("select network['tcp'] from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));
        tcp = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertNetworkTCP(tcp);
    }

    private void assertNetworkTCP(Map&lt;String, Object&gt; tcp) {
<a name="5"></a>        assertThat(tcp.keySet().size(), is(2));
        assertThat(tcp.keySet(), hasItems("packets", "connections"));

        <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Map&lt;String, Object&gt; connections = (Map&lt;String, Object&gt;) tcp.get("connections");
        assertThat(connections.keySet().size(), is(5));
        assertThat(connections.keySet(), hasItems</b></font>("initiated", "accepted", "curr_established", "dropped", "embryonic_dropped"));

        Map&lt;String, Object&gt; packets = (Map&lt;String, Object&gt;) tcp.get("packets");
        assertThat(packets.keySet().size(), is(5));
        assertThat(packets.keySet(), hasItems("sent", "received", "errors_received", "retransmitted", "rst_sent"));
    }

    @Test
    public void testNetworkTcpConnectionFields() throws Exception {
        SQLResponse response = execute("select " +
                                       "network['tcp']['connections']['initiated'], " +
                                       "network['tcp']['connections']['accepted'], " +
                                       "network['tcp']['connections']['curr_established']," +
<a name="2"></a>                                       "network['tcp']['connections']['dropped']," +
                                       "network['tcp']['connections']['embryonic_dropped']" +
                                       " from sys.nodes limit 1");
        assertThat(response.rowCount(), <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>is(1L));
        for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }</b></font>
    }

    @Test
    public void testNetworkTcpPacketsFields() throws Exception {
        SQLResponse response = execute("select " +
                                       "network['tcp']['packets']['sent'], " +
                                       "network['tcp']['packets']['received'], " +
                                       "network['tcp']['packets']['retransmitted'], " +
                                       "network['tcp']['packets']['errors_received'], " +
<a name="4"></a>                                       "network['tcp']['packets']['rst_sent'] " +
                                       "from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));
        <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }</b></font>
    }

    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testSysNodesOs() throws Exception {
        SQLResponse response = execute("select os from sys.nodes limit 1");
        Map results = (Map) response.rows()[0][0];
        assertThat(response.rowCount(), is(1L));

        assertThat((Long) results.get("timestamp"), greaterThan(0L));
        assertThat((Long) results.get("uptime"), greaterThanOrEqualTo(-1L));

        assertThat((Short) ((Map) results.get("cpu")).get("system"), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get("cpu")).get("system"), lessThanOrEqualTo((short) 100));

        assertThat((Short) ((Map) results.get("cpu")).get("user"), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get("cpu")).get("user"), lessThanOrEqualTo((short) 100));

        assertThat((Short) ((Map) results.get("cpu")).get("used"), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get("cpu")).get("used"), lessThanOrEqualTo((short) 100));

    }

    @Test
    public void testSysNodesCgroup() throws Exception {
        if (Constants.LINUX &amp;&amp; !"true".equals(System.getenv("SHIPPABLE"))) { // cgroups are only available on Linux
            SQLResponse response = execute("select" +
                                           " os['cgroup']['cpuacct']['control_group']," +
                                           " os['cgroup']['cpuacct']['usage_nanos']," +
                                           " os['cgroup']['cpu']['control_group']," +
                                           " os['cgroup']['cpu']['cfs_period_micros']," +
                                           " os['cgroup']['cpu']['cfs_quota_micros']," +
                                           " os['cgroup']['cpu']['num_elapsed_periods']," +
                                           " os['cgroup']['cpu']['num_times_throttled']," +
                                           " os['cgroup']['cpu']['time_throttled_nanos']" +
                                           " from sys.nodes limit 1");
            assertThat(response.rowCount(), is(1L));
            assertThat(response.rows()[0][0], notNullValue());
            assertThat((long) response.rows()[0][1], greaterThanOrEqualTo(0L));
            assertThat(response.rows()[0][2], notNullValue());
            assertThat((long) response.rows()[0][3], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][4], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][5], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][6], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][7], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
        } else {
            // for all other OS cgroup fields should return `null`
            response = execute("select os['cgroup']," +
                               " os['cgroup']['cpuacct']," +
                               " os['cgroup']['cpuacct']['control_group']," +
                               " os['cgroup']['cpuacct']['usage_nanos']," +
                               " os['cgroup']['cpu']," +
                               " os['cgroup']['cpu']['control_group']," +
                               " os['cgroup']['cpu']['cfs_period_micros']," +
                               " os['cgroup']['cpu']['cfs_quota_micros']," +
                               " os['cgroup']['cpu']['num_elapsed_periods']," +
                               " os['cgroup']['cpu']['num_times_throttled']," +
                               " os['cgroup']['cpu']['time_throttled_nanos']" +
                               " from sys.nodes limit 1");
            assertThat(response.rowCount(), is(1L));
            for (int i = 0; i &lt;= 10; i++) {
                assertThat(response.rows()[0][1], Matchers.is(Map.of()));
            }
        }

    }

    @Test
    public void testSysNodsOsInfo() throws Exception {
        SQLResponse response = execute("select os_info from sys.nodes limit 1");
        Map results = (Map) response.rows()[0][0];
        assertThat(response.rowCount(), is(1L));

        assertThat((Integer) results.get("available_processors"), greaterThan(0));
        assertEquals(Constants.OS_NAME, results.get("name"));
        assertEquals(Constants.OS_ARCH, results.get("arch"));
        assertEquals(Constants.OS_VERSION, results.get("version"));

        Map&lt;String, Object&gt; jvmObj = new HashMap&lt;&gt;(4);
        jvmObj.put("version", Constants.JAVA_VERSION);
        jvmObj.put("vm_name", Constants.JVM_NAME);
        jvmObj.put("vm_vendor", Constants.JVM_VENDOR);
        jvmObj.put("vm_version", Constants.JVM_VERSION);
        assertEquals(jvmObj, results.get("jvm"));
    }

    @Test
    public void testSysNodesProcess() throws Exception {
        SQLResponse response = execute("select process['open_file_descriptors'], " +
                                       "process['max_open_file_descriptors'] " +
                                       "from sys.nodes limit 1");
        for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }
    }

    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testFs() throws Exception {
        SQLResponse response = execute("select fs from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));
        assertThat(response.rows()[0][0], instanceOf(Map.class));
        Map&lt;String, Object&gt; fs = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertThat(fs.keySet().size(), is(3));
        assertThat(fs.keySet(), hasItems("total", "disks", "data"));

<a name="1"></a>        Map&lt;String, Object&gt; total = (Map&lt;String, Object&gt;) fs.get("total");
        assertThat(total.keySet(), hasItems("size", "used", "available", "reads", "writes",
            "bytes_written", "bytes_read"));
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (Object val : total.values()) {
            assertThat((Long) val, greaterThanOrEqualTo(-1L));
        }

        List disks = (List) fs.get</b></font>("disks");
        if (disks.size() &gt; 0) {
            // on travis there are no accessible disks
            assertThat(disks.size(), greaterThanOrEqualTo(1));
            Map&lt;String, Object&gt; someDisk = (Map&lt;String, Object&gt;) disks.get(0);
            assertThat(someDisk.keySet().size(), is(4));
            assertThat(someDisk.keySet(), hasItems("dev", "size", "used", "available"));
            for (Map.Entry&lt;String, Object&gt; entry : someDisk.entrySet()) {
                if (!entry.getKey().equals("dev")) {
                    assertThat((Long) entry.getValue(), greaterThanOrEqualTo(-1L));
                }
            }
        }

        List data = (List) fs.get("data");
        if (data.size() &gt; 0) {
            // without sigar, no data definition returned
            int numDataPaths = internalCluster().getInstance(NodeEnvironment.class).nodeDataPaths().length;
            assertThat(data.size(), is(numDataPaths));
            Map&lt;String, Object&gt; someData = (Map&lt;String, Object&gt;) data.get(0);
            assertThat(someData.keySet().size(), is(2));
            assertThat(someData.keySet(), hasItems("dev", "path"));
        }
    }

    @Test
    public void testFsNoRootFS() throws Exception {
        SQLResponse response = execute("select fs['data']['dev'], fs['disks'] from sys.nodes");
        assertThat(response.rowCount(), is(2L));
        for (Object[] row : response.rows()) {
            // data device name
            for (Object diskDevName : (List) row[0]) {
                assertThat(diskDevName, is(not("rootfs")));
            }
            List disks = (List) row[1];
            // disks device name
            for (Object disk : disks) {
                String diskDevName = (String) ((Map&lt;String, Object&gt;) disk).get("dev");
                assertThat(diskDevName, is(notNullValue()));
                assertThat(diskDevName, is(not("rootfs")));
            }
        }
    }

    @Test
<a name="3"></a>    public void testSysNodesObjectArrayStringChildColumn() throws Exception {
        SQLResponse response = execute("select fs['data']['path'] from sys.nodes");
        assertThat(response.rowCount(), Matchers.is(2L));
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (Object path : (List) response.rows()[0][0]) {
            assertThat(path, instanceOf(String.class));
        }
    }</b></font>

    @Test
    public void testVersion() throws Exception {
        SQLResponse response = execute("select version, version['number'], " +
                                       "version['build_hash'], version['build_snapshot'] " +
                                       "from sys.nodes limit 1");
        assertThat(response.rowCount(), is(1L));
        assertThat(response.rows()[0][0], instanceOf(Map.class));
        assertThat((Map&lt;String, Object&gt;) response.rows()[0][0], allOf(hasKey("number"), hasKey("build_hash"), hasKey("build_snapshot")));
        assertThat((String) response.rows()[0][1], is(Version.CURRENT.externalNumber()));
        assertThat(response.rows()[0][2], instanceOf(String.class));
        assertThat((Boolean) response.rows()[0][3], is(Version.CURRENT.isSnapshot()));
    }

    @Test
    public void testRegexpMatchOnNode() throws Exception {
        SQLResponse response = execute("select name from sys.nodes where name ~ 'node_s[0-1]{1,2}' order by name");
        assertThat(response.rowCount(), is(2L));
        assertThat((String) response.rows()[0][0], is("node_s0"));
        assertThat((String) response.rows()[1][0], is("node_s1"));
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
