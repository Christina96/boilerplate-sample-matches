<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for DocValuesGroupByOptimizedIterator.java &amp; NodeStatsTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DocValuesGroupByOptimizedIterator.java &amp; NodeStatsTest.java
      </h3>
<h1 align="center">
        12.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DocValuesGroupByOptimizedIterator.java (13.162705%)<th>NodeStatsTest.java (12.5%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(372-375)<td><a href="#" name="1">(280-284)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(240-243)<td><a href="#" name="2">(152-155)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(389-393)<td><a href="#" name="3">(332-335)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(360-362)<td><a href="#" name="4">(168-170)</a><td align="center"><font color="#5b0000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(147-154)<td><a href="#" name="5">(134-136)</a><td align="center"><font color="#5b0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DocValuesGroupByOptimizedIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.engine.collect;
22 import static io.crate.execution.dsl.projection.Projections.shardProjections;
23 import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;
24 import java.io.IOException;
25 import java.util.ArrayList;
26 import java.util.Collection;
27 import java.util.HashMap;
28 import java.util.List;
29 import java.util.Map;
30 import java.util.concurrent.CompletableFuture;
31 import java.util.concurrent.atomic.AtomicReference;
32 import java.util.function.BiConsumer;
33 import java.util.function.Function;
34 import javax.annotation.Nullable;
35 import io.crate.execution.engine.fetch.ReaderContext;
36 import io.crate.memory.MemoryManager;
37 import org.apache.lucene.index.LeafReaderContext;
38 import org.apache.lucene.search.DocIdSetIterator;
39 import org.apache.lucene.search.IndexSearcher;
40 import org.apache.lucene.search.Query;
41 import org.apache.lucene.search.ScoreMode;
42 import org.apache.lucene.search.Scorer;
43 import org.apache.lucene.search.Weight;
44 import org.apache.lucene.util.Bits;
45 import</b></font> org.elasticsearch.Version;
46 import org.elasticsearch.index.query.QueryShardContext;
47 import org.elasticsearch.index.shard.IndexShard;
48 import org.elasticsearch.index.shard.ShardId;
49 import io.crate.breaker.MultiSizeEstimator;
50 import io.crate.breaker.RamAccounting;
51 import io.crate.breaker.SizeEstimatorFactory;
52 import io.crate.common.annotations.VisibleForTesting;
53 import io.crate.common.collections.Lists2;
54 import io.crate.data.BatchIterator;
55 import io.crate.data.CollectingBatchIterator;
56 import io.crate.data.Row;
57 import io.crate.data.RowN;
58 import io.crate.exceptions.Exceptions;
59 import io.crate.execution.dsl.phases.RoutedCollectPhase;
60 import io.crate.execution.dsl.projection.GroupProjection;
61 import io.crate.execution.dsl.projection.Projection;
62 import io.crate.execution.engine.aggregation.DocValueAggregator;
63 import io.crate.execution.engine.aggregation.GroupByMaps;
64 import io.crate.execution.jobs.SharedShardContext;
65 import io.crate.expression.InputFactory;
66 import io.crate.expression.reference.doc.lucene.CollectorContext;
67 import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
68 import io.crate.expression.symbol.AggregateMode;
69 import io.crate.expression.symbol.InputColumn;
70 import io.crate.expression.symbol.Symbol;
71 import io.crate.expression.symbol.Symbols;
72 import io.crate.lucene.FieldTypeLookup;
73 import io.crate.lucene.LuceneQueryBuilder;
74 import io.crate.metadata.DocReferences;
75 import io.crate.metadata.Functions;
76 import io.crate.metadata.Reference;
77 import io.crate.metadata.doc.DocSysColumns;
78 import io.crate.metadata.doc.DocTableInfo;
79 final class DocValuesGroupByOptimizedIterator {
80     @Nullable
81     static BatchIterator&lt;Row&gt; tryOptimize(Functions functions,
82                                           IndexShard indexShard,
83                                           DocTableInfo table,
84                                           LuceneQueryBuilder luceneQueryBuilder,
85                                           FieldTypeLookup fieldTypeLookup,
86                                           DocInputFactory docInputFactory,
87                                           RoutedCollectPhase collectPhase,
88                                           CollectTask collectTask) {
89         if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)
90             || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {
91             return null;
92         }
93         Collection&lt;? extends Projection&gt; shardProjections = shardProjections(collectPhase.projections());
94         GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);
95         if (groupProjection == null) {
96             return null;
97         }
98         ArrayList&lt;Reference&gt; columnKeyRefs = new ArrayList&lt;&gt;(groupProjection.keys().size());
99         for (var key : groupProjection.keys()) {
100             var docKeyRef = getKeyRef(collectPhase.toCollect(), key);
101             if (docKeyRef == null) {
102                 return null;             }
103             var columnKeyRef = (Reference) DocReferences.inverseSourceLookup(docKeyRef);
104             var keyFieldType = fieldTypeLookup.get(columnKeyRef.column().fqn());
105             if (keyFieldType == null || !keyFieldType.hasDocValues()) {
106                 return null;
107             } else {
108                 columnKeyRefs.add(columnKeyRef);
109             }
110         }
111         //noinspection rawtypes
112         List&lt;DocValueAggregator&gt; aggregators = DocValuesAggregates.createAggregators(
113             functions,
114             groupProjection.values(),
115             collectPhase.toCollect(),
116             collectTask.txnCtx().sessionSettings().searchPath(),
117             table
118         );
119         if (aggregators == null) {
120             return null;
121         }
122         ShardId shardId = indexShard.shardId();
123         SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);
124         var searcher = sharedShardContext.acquireSearcher("group-by-doc-value-aggregates: " + formatSource(collectPhase));
125         collectTask.addSearcher(sharedShardContext.readerId(), searcher);
126         QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();
127         InputFactory.Context&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; docCtx
128             = docInputFactory.getCtx(collectTask.txnCtx());
129         List&lt;LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions = new ArrayList&lt;&gt;();
130 <a name="5"></a>        for (var keyRef : columnKeyRefs) {
131             keyExpressions.add((LuceneCollectorExpression&lt;?&gt;) docCtx.add(keyRef));
132         }
133         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(
134             collectPhase.where(),
135             collectTask.txnCtx(),
136             indexShard.mapperService(),
137             indexShard.shardId().getIndexName(),
138             queryShardContext,
139             table,
140             sharedShardContext.indexService</b></font>().cache()
141         );
142         if (columnKeyRefs.size() == 1) {
143             return GroupByIterator.forSingleKey(
144                 aggregators,
145                 searcher.item(),
146                 columnKeyRefs.get(0),
147                 keyExpressions,
148                 collectTask.getRamAccounting(),
149                 collectTask.memoryManager(),
150                 collectTask.minNodeVersion(),
151                 queryContext.query(),
152                 new CollectorContext(sharedShardContext.readerId())
153             );
154         } else {
155             return GroupByIterator.forManyKeys(
156                 aggregators,
157                 searcher.item(),
158                 columnKeyRefs,
159                 keyExpressions,
160                 collectTask.getRamAccounting(),
161                 collectTask.memoryManager(),
162                 collectTask.minNodeVersion(),
163                 queryContext.query(),
164                 new CollectorContext(sharedShardContext.readerId())
165             );
166         }
167     }
168     static class GroupByIterator {
169         @VisibleForTesting
170         static BatchIterator&lt;Row&gt; forSingleKey(List&lt;DocValueAggregator&gt; aggregators,
171                                                IndexSearcher indexSearcher,
172                                                Reference keyReference,
173                                                List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
174                                                RamAccounting ramAccounting,
175                                                MemoryManager memoryManager,
176                                                Version minNodeVersion,
177                                                Query query,
178                                                CollectorContext collectorContext) {
179             return GroupByIterator.getIterator(
180                 aggregators,
181                 indexSearcher,
182                 keyExpressions,
183                 ramAccounting,
184                 memoryManager,
185                 minNodeVersion,
186                 GroupByMaps.accountForNewEntry(
187                     ramAccounting,
188                     SizeEstimatorFactory.create(keyReference.valueType()),
189                     null
190                 ),
191                 (expressions) -&gt; expressions.get(0).value(),
192                 (key, cells) -&gt; cells[0] = key,
193                 query,
194                 new CollectorContext(collectorContext.readerId())
195             );
196         }
197         @VisibleForTesting
198         static &lt;K&gt; BatchIterator&lt;Row&gt; forManyKeys(List&lt;DocValueAggregator&gt; aggregators,
199                                                   IndexSearcher indexSearcher,
200                                                   List&lt;Reference&gt; keyColumnRefs,
201                                                   List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
202                                                   RamAccounting ramAccounting,
203                                                   MemoryManager memoryManager,
204                                                   Version minNodeVersion,
205                                                   Query query,
206                                                   CollectorContext collectorContext) {
207             return GroupByIterator.getIterator(
208                 aggregators,
209                 indexSearcher,
210                 keyExpressions,
211                 ramAccounting,
212                 memoryManager,
213                 minNodeVersion,
214                 GroupByMaps.accountForNewEntry(
215                     ramAccounting,
216                     new MultiSizeEstimator(
217                         Lists2.map(keyColumnRefs, Reference::valueType)
218                     ),
219 <a name="2"></a>                    null
220                 ),
221                 (expressions) -&gt; {
222                     ArrayList&lt;Object&gt; key = new ArrayList&lt;&gt;(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>keyColumnRefs.size());
223                     for (int i = 0; i &lt; expressions.size(); i++) {
224                         key.add(expressions.get(i).value());
225                     }</b></font>
226                     return key;
227                 },
228                 (List&lt;Object&gt; keys, Object[] cells) -&gt; {
229                     for (int i = 0; i &lt; keys.size(); i++) {
230                         cells[i] = keys.get(i);
231                     }
232                 },
233                 query,
234                 new CollectorContext(collectorContext.readerId())
235             );
236         }
237         @VisibleForTesting
238         static &lt;K&gt; BatchIterator&lt;Row&gt; getIterator(List&lt;DocValueAggregator&gt; aggregators,
239                                                   IndexSearcher indexSearcher,
240                                                   List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
241                                                   RamAccounting ramAccounting,
242                                                   MemoryManager memoryManager,
243                                                   Version minNodeVersion,
244                                                   BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
245                                                   Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
246                                                   BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
247                                                   Query query,
248                                                   CollectorContext collectorContext) {
249             for (int i = 0; i &lt; keyExpressions.size(); i++) {
250                 keyExpressions.get(i).startCollect(collectorContext);
251             }
252             AtomicReference&lt;Throwable&gt; killed = new AtomicReference&lt;&gt;();
253             return CollectingBatchIterator.newInstance(
254                 () -&gt; killed.set(BatchIterator.CLOSED),
255                 killed::set,
256                 () -&gt; {
257                     try {
258                         return CompletableFuture.completedFuture(
259                             getRows(
260                                 applyAggregatesGroupedByKey(
261                                     aggregators,
262                                     indexSearcher,
263                                     keyExpressions,
264                                     accountForNewKeyEntry,
265                                     keyExtractor,
266                                     ramAccounting,
267                                     memoryManager,
268                                     minNodeVersion,
269                                     query,
270                                     killed
271                                 ),
272                                 keyExpressions.size(),
273                                 applyKeyToCells,
274                                 aggregators,
275                                 ramAccounting
276                             )
277                         );
278                     } catch (Throwable t) {
279                         return CompletableFuture.failedFuture(t);
280                     }
281                 },
282                 true
283             );
284         }
285         private static &lt;K&gt; Iterable&lt;Row&gt; getRows(Map&lt;K, Object[]&gt; groupedStates,
286                                                  int numberOfKeys,
287                                                  BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
288                                                  List&lt;DocValueAggregator&gt; aggregators,
289                                                  RamAccounting ramAccounting) {
290             return () -&gt; {
291                 Object[] cells = new Object[numberOfKeys + aggregators.size()];
292                 RowN row = new RowN(cells);
293                 Function&lt;Map.Entry&lt;K, Object[]&gt;, Row&gt; mapper = entry -&gt; {
294                     K key = entry.getKey();
295                     applyKeyToCells.accept(key, cells);
296                     Object[] states = entry.getValue();
297                     int c = numberOfKeys;
298                     for (int i = 0; i &lt; states.length; i++) {
299                         //noinspection unchecked
300                         cells[c] = aggregators.get(i).partialResult(ramAccounting, states[i]);
301                         c++;
302                     }
303                     return row;
304                 };
305                 return groupedStates.entrySet().stream().map(mapper).iterator();
306             };
307         }
308         private static &lt;K&gt; Map&lt;K, Object[]&gt; applyAggregatesGroupedByKey(
309             List&lt;DocValueAggregator&gt; aggregators,
310             IndexSearcher indexSearcher,
311             List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
312             BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
313             Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
314             RamAccounting ramAccounting,
315             MemoryManager memoryManager,
316             Version minNodeVersion,
317             Query query,
318             AtomicReference&lt;Throwable&gt; killed
319         ) throws IOException {
320             HashMap&lt;K, Object[]&gt; statesByKey = new HashMap&lt;&gt;();
321             Weight weight = indexSearcher.createWeight(
322                 indexSearcher.rewrite(query),
323                 ScoreMode.COMPLETE_NO_SCORES,
324                 1f
325             );
326             List&lt;LeafReaderContext&gt; leaves = indexSearcher.getTopReaderContext().leaves();
327             for (var leaf : leaves) {
328                 raiseIfClosedOrKilled(killed);
329                 Scorer scorer = weight.scorer(leaf);
330                 if (scorer == null) {
331                     continue;
332                 }
333 <a name="4"></a>                for (int i = 0; i &lt; keyExpressions.size(); i++) {
334                     keyExpressions.get(i).setNextReader(new ReaderContext(leaf));
335                 }
336                 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; aggregators.size(); i++) {
337                     aggregators.get(i).loadDocValues(leaf.reader());
338                 }</b></font>
339                 DocIdSetIterator docs = scorer.iterator();
340                 Bits liveDocs = leaf.reader().getLiveDocs();
341                 for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docs.nextDoc()) {
342                     raiseIfClosedOrKilled(killed);
343                     if (docDeleted(liveDocs, doc)) {
344 <a name="1"></a>                        continue;
345                     }
346                     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; keyExpressions.size(); i++) {
347                         keyExpressions.get(i).setNextDocId(doc);
348                     }
349                     K key = keyExtractor.apply</b></font>(keyExpressions);
350                     Object[] states = statesByKey.get(key);
351                     if (states == null) {
352                         states = new Object[aggregators.size()];
353                         for (int i = 0; i &lt; aggregators.size(); i++) {
354                             var aggregator = aggregators.get(i);
355                             states[i] = aggregator.initialState(ramAccounting, memoryManager, minNodeVersion);
356                             //noinspection unchecked
357                             aggregator.apply(ramAccounting, doc, states[i]);
358                         }
359 <a name="3"></a>                        accountForNewKeyEntry.accept(statesByKey, key);
360                         statesByKey.put(key, states);
361                     } else {
362                         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for (int i = 0; i &lt; aggregators.size(); i++) {
363                             //noinspection unchecked
364                             aggregators.get(i).apply(ramAccounting, doc, states[i]);
365                         }
366                     }</b></font>
367                 }
368             }
369             return statesByKey;
370         }
371         private static boolean docDeleted(@Nullable Bits liveDocs, int doc) {
372             return liveDocs != null &amp;&amp; !liveDocs.get(doc);
373         }
374         private static void raiseIfClosedOrKilled(AtomicReference&lt;Throwable&gt; killed) {
375             Throwable killedException = killed.get();
376             if (killedException != null) {
377                 Exceptions.rethrowUnchecked(killedException);
378             }
379         }
380     }
381     @Nullable
382     private static Reference getKeyRef(List&lt;Symbol&gt; toCollect, Symbol key) {
383         if (key instanceof InputColumn) {
384             Symbol keyRef = toCollect.get(((InputColumn) key).index());
385             if (keyRef instanceof Reference) {
386                 return ((Reference) keyRef);
387             }
388         }
389         return null;
390     }
391     private static GroupProjection getSinglePartialGroupProjection(Collection&lt;? extends Projection&gt; shardProjections) {
392         if (shardProjections.size() != 1) {
393             return null;
394         }
395         Projection shardProjection = shardProjections.iterator().next();
396         if (!(shardProjection instanceof GroupProjection) ||
397             ((GroupProjection) shardProjection).mode() == AggregateMode.ITER_FINAL) {
398             return null;
399         }
400         return (GroupProjection) shardProjection;
401     }
402 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>NodeStatsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.integrationtests;
22 import io.crate.testing.SQLResponse;
23 import io.crate.testing.UseJdbc;
24 import org.apache.lucene.util.Constants;
25 import org.elasticsearch.Version;
26 import org.elasticsearch.env.NodeEnvironment;
27 import org.elasticsearch.test.ESIntegTestCase;
28 import org.hamcrest.Matchers;
29 import org.junit.Test;
30 import java.util.HashMap;
31 import java.util.List;
32 import java.util.Map;
33 import static org.hamcrest.Matchers.allOf;
34 import static org.hamcrest.Matchers.anyOf;
35 import static org.hamcrest.Matchers.equalTo;
36 import static org.hamcrest.Matchers.greaterThan;
37 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
38 import static org.hamcrest.Matchers.hasItems;
39 import static org.hamcrest.Matchers.hasKey;
40 import static org.hamcrest.Matchers.instanceOf;
41 import static org.hamcrest.Matchers.lessThan;
42 import static org.hamcrest.Matchers.lessThanOrEqualTo;
43 import static org.hamcrest.Matchers.not;
44 import static org.hamcrest.Matchers.notNullValue;
45 import</b></font> static org.hamcrest.core.Is.is;
46 @ESIntegTestCase.ClusterScope(numClientNodes = 0, numDataNodes = 2, supportsDedicatedMasters = false)
47 public class NodeStatsTest extends SQLIntegrationTestCase {
48     @Test
49     public void testSysNodesMem() throws Exception {
50         SQLResponse response = execute("select mem['free'], mem['used'], mem['free_percent'], mem['used_percent'] from sys.nodes limit 1");
51         long free = (long) response.rows()[0][0];
52         long used = (long) response.rows()[0][1];
53         double free_percent = ((Number) response.rows()[0][2]).intValue() * 0.01;
54         double used_percent = ((Number) response.rows()[0][3]).intValue() * 0.01;
55         double calculated_free_percent = free / (double) (free + used);
56         double calculated_used_percent = used / (double) (free + used);
57         double max_delta = 0.02;         double free_delta = Math.abs(calculated_free_percent - free_percent);
58         double used_delta = Math.abs(calculated_used_percent - used_percent);
59         assertThat(free_delta, is(lessThan(max_delta)));
60         assertThat(used_delta, is(lessThan(max_delta)));
61     }
62     @SuppressWarnings("ConstantConditions")
63     @Test
64     @UseJdbc(0)     public void testThreadPools() throws Exception {
65         SQLResponse response = execute("select thread_pools from sys.nodes limit 1");
66         List threadPools = (List) response.rows()[0][0];
67         assertThat(threadPools.size(), greaterThanOrEqualTo(1));
68         Map&lt;String, Object&gt; threadPool = null;
69         for (Object t : threadPools) {
70             Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) t;
71             if (map.get("name").equals("generic")) {
72                 threadPool = map;
73                 break;
74             }
75         }
76         assertThat(threadPool.get("name"), is("generic"));
77         assertThat((Integer) threadPool.get("active"), greaterThanOrEqualTo(0));
78         assertThat((Long) threadPool.get("rejected"), greaterThanOrEqualTo(0L));
79         assertThat((Integer) threadPool.get("largest"), greaterThanOrEqualTo(0));
80         assertThat((Long) threadPool.get("completed"), greaterThanOrEqualTo(0L));
81         assertThat((Integer) threadPool.get("threads"), greaterThanOrEqualTo(0));
82         assertThat((Integer) threadPool.get("queue"), greaterThanOrEqualTo(0));
83     }
84     @Test
85     public void testThreadPoolValue() throws Exception {
86         SQLResponse response = execute("select thread_pools['name'], thread_pools['queue'] from sys.nodes limit 1");
87         assertThat(response.rowCount(), is(1L));
88         List&lt;Object&gt; objects = (List&lt;Object&gt;) response.rows()[0][0];
89         assertThat(objects, Matchers.hasItem("generic"));
90         List queues = (List) response.rows()[0][1];
91         assertThat(queues.size(), greaterThanOrEqualTo(1));
92         assertThat((Integer) queues.get(0), greaterThanOrEqualTo(0));
93     }
94     @Test
95     public void testNetwork() throws Exception {
96         SQLResponse response = execute("select network from sys.nodes limit 1");
97         assertThat(response.rowCount(), is(1L));
98         Map&lt;String, Object&gt; network = (Map&lt;String, Object&gt;) response.rows()[0][0];
99         assertThat(network, hasKey("tcp"));
100         Map&lt;String, Object&gt; tcp = (Map&lt;String, Object&gt;) network.get("tcp");
101         assertNetworkTCP(tcp);
102         response = execute("select network['tcp'] from sys.nodes limit 1");
103         assertThat(response.rowCount(), is(1L));
104         tcp = (Map&lt;String, Object&gt;) response.rows()[0][0];
105         assertNetworkTCP(tcp);
106     }
107     private void assertNetworkTCP(Map&lt;String, Object&gt; tcp) {
108 <a name="5"></a>        assertThat(tcp.keySet().size(), is(2));
109         assertThat(tcp.keySet(), hasItems("packets", "connections"));
110         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Map&lt;String, Object&gt; connections = (Map&lt;String, Object&gt;) tcp.get("connections");
111         assertThat(connections.keySet().size(), is(5));
112         assertThat(connections.keySet(), hasItems</b></font>("initiated", "accepted", "curr_established", "dropped", "embryonic_dropped"));
113         Map&lt;String, Object&gt; packets = (Map&lt;String, Object&gt;) tcp.get("packets");
114         assertThat(packets.keySet().size(), is(5));
115         assertThat(packets.keySet(), hasItems("sent", "received", "errors_received", "retransmitted", "rst_sent"));
116     }
117     @Test
118     public void testNetworkTcpConnectionFields() throws Exception {
119         SQLResponse response = execute("select " +
120                                        "network['tcp']['connections']['initiated'], " +
121                                        "network['tcp']['connections']['accepted'], " +
122                                        "network['tcp']['connections']['curr_established']," +
123 <a name="2"></a>                                       "network['tcp']['connections']['dropped']," +
124                                        "network['tcp']['connections']['embryonic_dropped']" +
125                                        " from sys.nodes limit 1");
126         assertThat(response.rowCount(), <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>is(1L));
127         for (int i = 0; i &lt; response.cols().length; i++) {
128             assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
129         }</b></font>
130     }
131     @Test
132     public void testNetworkTcpPacketsFields() throws Exception {
133         SQLResponse response = execute("select " +
134                                        "network['tcp']['packets']['sent'], " +
135                                        "network['tcp']['packets']['received'], " +
136                                        "network['tcp']['packets']['retransmitted'], " +
137                                        "network['tcp']['packets']['errors_received'], " +
138 <a name="4"></a>                                       "network['tcp']['packets']['rst_sent'] " +
139                                        "from sys.nodes limit 1");
140         assertThat(response.rowCount(), is(1L));
141         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (int i = 0; i &lt; response.cols().length; i++) {
142             assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
143         }</b></font>
144     }
145     @Test
146     @UseJdbc(0)     public void testSysNodesOs() throws Exception {
147         SQLResponse response = execute("select os from sys.nodes limit 1");
148         Map results = (Map) response.rows()[0][0];
149         assertThat(response.rowCount(), is(1L));
150         assertThat((Long) results.get("timestamp"), greaterThan(0L));
151         assertThat((Long) results.get("uptime"), greaterThanOrEqualTo(-1L));
152         assertThat((Short) ((Map) results.get("cpu")).get("system"), greaterThanOrEqualTo((short) -1));
153         assertThat((Short) ((Map) results.get("cpu")).get("system"), lessThanOrEqualTo((short) 100));
154         assertThat((Short) ((Map) results.get("cpu")).get("user"), greaterThanOrEqualTo((short) -1));
155         assertThat((Short) ((Map) results.get("cpu")).get("user"), lessThanOrEqualTo((short) 100));
156         assertThat((Short) ((Map) results.get("cpu")).get("used"), greaterThanOrEqualTo((short) -1));
157         assertThat((Short) ((Map) results.get("cpu")).get("used"), lessThanOrEqualTo((short) 100));
158     }
159     @Test
160     public void testSysNodesCgroup() throws Exception {
161         if (Constants.LINUX &amp;&amp; !"true".equals(System.getenv("SHIPPABLE"))) {             SQLResponse response = execute("select" +
162                                            " os['cgroup']['cpuacct']['control_group']," +
163                                            " os['cgroup']['cpuacct']['usage_nanos']," +
164                                            " os['cgroup']['cpu']['control_group']," +
165                                            " os['cgroup']['cpu']['cfs_period_micros']," +
166                                            " os['cgroup']['cpu']['cfs_quota_micros']," +
167                                            " os['cgroup']['cpu']['num_elapsed_periods']," +
168                                            " os['cgroup']['cpu']['num_times_throttled']," +
169                                            " os['cgroup']['cpu']['time_throttled_nanos']" +
170                                            " from sys.nodes limit 1");
171             assertThat(response.rowCount(), is(1L));
172             assertThat(response.rows()[0][0], notNullValue());
173             assertThat((long) response.rows()[0][1], greaterThanOrEqualTo(0L));
174             assertThat(response.rows()[0][2], notNullValue());
175             assertThat((long) response.rows()[0][3], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
176             assertThat((long) response.rows()[0][4], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
177             assertThat((long) response.rows()[0][5], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
178             assertThat((long) response.rows()[0][6], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
179             assertThat((long) response.rows()[0][7], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
180         } else {
181             response = execute("select os['cgroup']," +
182                                " os['cgroup']['cpuacct']," +
183                                " os['cgroup']['cpuacct']['control_group']," +
184                                " os['cgroup']['cpuacct']['usage_nanos']," +
185                                " os['cgroup']['cpu']," +
186                                " os['cgroup']['cpu']['control_group']," +
187                                " os['cgroup']['cpu']['cfs_period_micros']," +
188                                " os['cgroup']['cpu']['cfs_quota_micros']," +
189                                " os['cgroup']['cpu']['num_elapsed_periods']," +
190                                " os['cgroup']['cpu']['num_times_throttled']," +
191                                " os['cgroup']['cpu']['time_throttled_nanos']" +
192                                " from sys.nodes limit 1");
193             assertThat(response.rowCount(), is(1L));
194             for (int i = 0; i &lt;= 10; i++) {
195                 assertThat(response.rows()[0][1], Matchers.is(Map.of()));
196             }
197         }
198     }
199     @Test
200     public void testSysNodsOsInfo() throws Exception {
201         SQLResponse response = execute("select os_info from sys.nodes limit 1");
202         Map results = (Map) response.rows()[0][0];
203         assertThat(response.rowCount(), is(1L));
204         assertThat((Integer) results.get("available_processors"), greaterThan(0));
205         assertEquals(Constants.OS_NAME, results.get("name"));
206         assertEquals(Constants.OS_ARCH, results.get("arch"));
207         assertEquals(Constants.OS_VERSION, results.get("version"));
208         Map&lt;String, Object&gt; jvmObj = new HashMap&lt;&gt;(4);
209         jvmObj.put("version", Constants.JAVA_VERSION);
210         jvmObj.put("vm_name", Constants.JVM_NAME);
211         jvmObj.put("vm_vendor", Constants.JVM_VENDOR);
212         jvmObj.put("vm_version", Constants.JVM_VERSION);
213         assertEquals(jvmObj, results.get("jvm"));
214     }
215     @Test
216     public void testSysNodesProcess() throws Exception {
217         SQLResponse response = execute("select process['open_file_descriptors'], " +
218                                        "process['max_open_file_descriptors'] " +
219                                        "from sys.nodes limit 1");
220         for (int i = 0; i &lt; response.cols().length; i++) {
221             assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
222         }
223     }
224     @Test
225     @UseJdbc(0)     public void testFs() throws Exception {
226         SQLResponse response = execute("select fs from sys.nodes limit 1");
227         assertThat(response.rowCount(), is(1L));
228         assertThat(response.rows()[0][0], instanceOf(Map.class));
229         Map&lt;String, Object&gt; fs = (Map&lt;String, Object&gt;) response.rows()[0][0];
230         assertThat(fs.keySet().size(), is(3));
231         assertThat(fs.keySet(), hasItems("total", "disks", "data"));
232 <a name="1"></a>        Map&lt;String, Object&gt; total = (Map&lt;String, Object&gt;) fs.get("total");
233         assertThat(total.keySet(), hasItems("size", "used", "available", "reads", "writes",
234             "bytes_written", "bytes_read"));
235         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (Object val : total.values()) {
236             assertThat((Long) val, greaterThanOrEqualTo(-1L));
237         }
238         List disks = (List) fs.get</b></font>("disks");
239         if (disks.size() &gt; 0) {
240             assertThat(disks.size(), greaterThanOrEqualTo(1));
241             Map&lt;String, Object&gt; someDisk = (Map&lt;String, Object&gt;) disks.get(0);
242             assertThat(someDisk.keySet().size(), is(4));
243             assertThat(someDisk.keySet(), hasItems("dev", "size", "used", "available"));
244             for (Map.Entry&lt;String, Object&gt; entry : someDisk.entrySet()) {
245                 if (!entry.getKey().equals("dev")) {
246                     assertThat((Long) entry.getValue(), greaterThanOrEqualTo(-1L));
247                 }
248             }
249         }
250         List data = (List) fs.get("data");
251         if (data.size() &gt; 0) {
252             int numDataPaths = internalCluster().getInstance(NodeEnvironment.class).nodeDataPaths().length;
253             assertThat(data.size(), is(numDataPaths));
254             Map&lt;String, Object&gt; someData = (Map&lt;String, Object&gt;) data.get(0);
255             assertThat(someData.keySet().size(), is(2));
256             assertThat(someData.keySet(), hasItems("dev", "path"));
257         }
258     }
259     @Test
260     public void testFsNoRootFS() throws Exception {
261         SQLResponse response = execute("select fs['data']['dev'], fs['disks'] from sys.nodes");
262         assertThat(response.rowCount(), is(2L));
263         for (Object[] row : response.rows()) {
264             for (Object diskDevName : (List) row[0]) {
265                 assertThat(diskDevName, is(not("rootfs")));
266             }
267             List disks = (List) row[1];
268             for (Object disk : disks) {
269                 String diskDevName = (String) ((Map&lt;String, Object&gt;) disk).get("dev");
270                 assertThat(diskDevName, is(notNullValue()));
271                 assertThat(diskDevName, is(not("rootfs")));
272             }
273         }
274     }
275     @Test
276 <a name="3"></a>    public void testSysNodesObjectArrayStringChildColumn() throws Exception {
277         SQLResponse response = execute("select fs['data']['path'] from sys.nodes");
278         assertThat(response.rowCount(), Matchers.is(2L));
279         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for (Object path : (List) response.rows()[0][0]) {
280             assertThat(path, instanceOf(String.class));
281         }
282     }</b></font>
283     @Test
284     public void testVersion() throws Exception {
285         SQLResponse response = execute("select version, version['number'], " +
286                                        "version['build_hash'], version['build_snapshot'] " +
287                                        "from sys.nodes limit 1");
288         assertThat(response.rowCount(), is(1L));
289         assertThat(response.rows()[0][0], instanceOf(Map.class));
290         assertThat((Map&lt;String, Object&gt;) response.rows()[0][0], allOf(hasKey("number"), hasKey("build_hash"), hasKey("build_snapshot")));
291         assertThat((String) response.rows()[0][1], is(Version.CURRENT.externalNumber()));
292         assertThat(response.rows()[0][2], instanceOf(String.class));
293         assertThat((Boolean) response.rows()[0][3], is(Version.CURRENT.isSnapshot()));
294     }
295     @Test
296     public void testRegexpMatchOnNode() throws Exception {
297         SQLResponse response = execute("select name from sys.nodes where name ~ 'node_s[0-1]{1,2}' order by name");
298         assertThat(response.rowCount(), is(2L));
299         assertThat((String) response.rows()[0][0], is("node_s0"));
300         assertThat((String) response.rows()[1][0], is("node_s1"));
301     }
302 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
