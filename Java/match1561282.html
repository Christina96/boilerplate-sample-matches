<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DocValuesGroupByOptimizedIterator.java & NodeStatsTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DocValuesGroupByOptimizedIterator.java & NodeStatsTest.java
      </h3>
      <h1 align="center">
        12.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DocValuesGroupByOptimizedIterator.java (13.162705%)<TH>NodeStatsTest.java (12.5%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#0',2,'match1561282-1.html#0',3)" NAME="0">(22-50)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#0',2,'match1561282-1.html#0',3)" NAME="0">(22-49)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#1',2,'match1561282-1.html#1',3)" NAME="1">(372-375)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#1',2,'match1561282-1.html#1',3)" NAME="1">(280-284)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#2',2,'match1561282-1.html#2',3)" NAME="2">(240-243)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#2',2,'match1561282-1.html#2',3)" NAME="2">(152-155)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#3',2,'match1561282-1.html#3',3)" NAME="3">(389-393)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#3',2,'match1561282-1.html#3',3)" NAME="3">(332-335)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#4',2,'match1561282-1.html#4',3)" NAME="4">(360-362)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#4',2,'match1561282-1.html#4',3)" NAME="4">(168-170)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1561282-0.html#5',2,'match1561282-1.html#5',3)" NAME="5">(147-154)<TD><A HREF="javascript:ZweiFrames('match1561282-0.html#5',2,'match1561282-1.html#5',3)" NAME="5">(134-136)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DocValuesGroupByOptimizedIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1561282-1.html#0',3,'match1561282-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.execution.engine.collect;

import static io.crate.execution.dsl.projection.Projections.shardProjections;
import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Function;

import javax.annotation.Nullable;

import io.crate.execution.engine.fetch.ReaderContext;
import io.crate.memory.MemoryManager;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreMode;
import org.apache.lucene.search.Scorer;
import org.apache.lucene.search.Weight;
import org.apache.lucene.util.Bits;
import</B></FONT> org.elasticsearch.Version;
import org.elasticsearch.index.query.QueryShardContext;
import org.elasticsearch.index.shard.IndexShard;
import org.elasticsearch.index.shard.ShardId;

import io.crate.breaker.MultiSizeEstimator;
import io.crate.breaker.RamAccounting;
import io.crate.breaker.SizeEstimatorFactory;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.data.BatchIterator;
import io.crate.data.CollectingBatchIterator;
import io.crate.data.Row;
import io.crate.data.RowN;
import io.crate.exceptions.Exceptions;
import io.crate.execution.dsl.phases.RoutedCollectPhase;
import io.crate.execution.dsl.projection.GroupProjection;
import io.crate.execution.dsl.projection.Projection;
import io.crate.execution.engine.aggregation.DocValueAggregator;
import io.crate.execution.engine.aggregation.GroupByMaps;
import io.crate.execution.jobs.SharedShardContext;
import io.crate.expression.InputFactory;
import io.crate.expression.reference.doc.lucene.CollectorContext;
import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
import io.crate.expression.symbol.AggregateMode;
import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.lucene.FieldTypeLookup;
import io.crate.lucene.LuceneQueryBuilder;
import io.crate.metadata.DocReferences;
import io.crate.metadata.Functions;
import io.crate.metadata.Reference;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;

final class DocValuesGroupByOptimizedIterator {

    @Nullable
    static BatchIterator&lt;Row&gt; tryOptimize(Functions functions,
                                          IndexShard indexShard,
                                          DocTableInfo table,
                                          LuceneQueryBuilder luceneQueryBuilder,
                                          FieldTypeLookup fieldTypeLookup,
                                          DocInputFactory docInputFactory,
                                          RoutedCollectPhase collectPhase,
                                          CollectTask collectTask) {
        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)
            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {
            return null;
        }

        Collection&lt;? extends Projection&gt; shardProjections = shardProjections(collectPhase.projections());
        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);
        if (groupProjection == null) {
            return null;
        }

        ArrayList&lt;Reference&gt; columnKeyRefs = new ArrayList&lt;&gt;(groupProjection.keys().size());
        for (var key : groupProjection.keys()) {
            var docKeyRef = getKeyRef(collectPhase.toCollect(), key);
            if (docKeyRef == null) {
                return null; // group by on non-reference
            }
            var columnKeyRef = (Reference) DocReferences.inverseSourceLookup(docKeyRef);
            var keyFieldType = fieldTypeLookup.get(columnKeyRef.column().fqn());
            if (keyFieldType == null || !keyFieldType.hasDocValues()) {
                return null;
            } else {
                columnKeyRefs.add(columnKeyRef);
            }
        }

        //noinspection rawtypes
        List&lt;DocValueAggregator&gt; aggregators = DocValuesAggregates.createAggregators(
            functions,
            groupProjection.values(),
            collectPhase.toCollect(),
            collectTask.txnCtx().sessionSettings().searchPath(),
            table
        );
        if (aggregators == null) {
            return null;
        }

        ShardId shardId = indexShard.shardId();
        SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);
        var searcher = sharedShardContext.acquireSearcher(&quot;group-by-doc-value-aggregates: &quot; + formatSource(collectPhase));
        collectTask.addSearcher(sharedShardContext.readerId(), searcher);
        QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();

        InputFactory.Context&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; docCtx
            = docInputFactory.getCtx(collectTask.txnCtx());
        List&lt;LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions = new ArrayList&lt;&gt;();
<A NAME="5"></A>        for (var keyRef : columnKeyRefs) {
            keyExpressions.add((LuceneCollectorExpression&lt;?&gt;) docCtx.add(keyRef));
        }
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1561282-1.html#5',3,'match1561282-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(
            collectPhase.where(),
            collectTask.txnCtx(),
            indexShard.mapperService(),
            indexShard.shardId().getIndexName(),
            queryShardContext,
            table,
            sharedShardContext.indexService</B></FONT>().cache()
        );

        if (columnKeyRefs.size() == 1) {
            return GroupByIterator.forSingleKey(
                aggregators,
                searcher.item(),
                columnKeyRefs.get(0),
                keyExpressions,
                collectTask.getRamAccounting(),
                collectTask.memoryManager(),
                collectTask.minNodeVersion(),
                queryContext.query(),
                new CollectorContext(sharedShardContext.readerId())
            );
        } else {
            return GroupByIterator.forManyKeys(
                aggregators,
                searcher.item(),
                columnKeyRefs,
                keyExpressions,
                collectTask.getRamAccounting(),
                collectTask.memoryManager(),
                collectTask.minNodeVersion(),
                queryContext.query(),
                new CollectorContext(sharedShardContext.readerId())
            );
        }
    }

    static class GroupByIterator {

        @VisibleForTesting
        static BatchIterator&lt;Row&gt; forSingleKey(List&lt;DocValueAggregator&gt; aggregators,
                                               IndexSearcher indexSearcher,
                                               Reference keyReference,
                                               List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                               RamAccounting ramAccounting,
                                               MemoryManager memoryManager,
                                               Version minNodeVersion,
                                               Query query,
                                               CollectorContext collectorContext) {
            return GroupByIterator.getIterator(
                aggregators,
                indexSearcher,
                keyExpressions,
                ramAccounting,
                memoryManager,
                minNodeVersion,
                GroupByMaps.accountForNewEntry(
                    ramAccounting,
                    SizeEstimatorFactory.create(keyReference.valueType()),
                    null
                ),
                (expressions) -&gt; expressions.get(0).value(),
                (key, cells) -&gt; cells[0] = key,
                query,
                new CollectorContext(collectorContext.readerId())
            );
        }

        @VisibleForTesting
        static &lt;K&gt; BatchIterator&lt;Row&gt; forManyKeys(List&lt;DocValueAggregator&gt; aggregators,
                                                  IndexSearcher indexSearcher,
                                                  List&lt;Reference&gt; keyColumnRefs,
                                                  List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                                  RamAccounting ramAccounting,
                                                  MemoryManager memoryManager,
                                                  Version minNodeVersion,
                                                  Query query,
                                                  CollectorContext collectorContext) {
            return GroupByIterator.getIterator(
                aggregators,
                indexSearcher,
                keyExpressions,
                ramAccounting,
                memoryManager,
                minNodeVersion,
                GroupByMaps.accountForNewEntry(
                    ramAccounting,
                    new MultiSizeEstimator(
                        Lists2.map(keyColumnRefs, Reference::valueType)
                    ),
<A NAME="2"></A>                    null
                ),
                (expressions) -&gt; {
                    ArrayList&lt;Object&gt; key = new ArrayList&lt;&gt;(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1561282-1.html#2',3,'match1561282-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>keyColumnRefs.size());
                    for (int i = 0; i &lt; expressions.size(); i++) {
                        key.add(expressions.get(i).value());
                    }</B></FONT>
                    return key;
                },
                (List&lt;Object&gt; keys, Object[] cells) -&gt; {
                    for (int i = 0; i &lt; keys.size(); i++) {
                        cells[i] = keys.get(i);
                    }
                },
                query,
                new CollectorContext(collectorContext.readerId())
            );
        }

        @VisibleForTesting
        static &lt;K&gt; BatchIterator&lt;Row&gt; getIterator(List&lt;DocValueAggregator&gt; aggregators,
                                                  IndexSearcher indexSearcher,
                                                  List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
                                                  RamAccounting ramAccounting,
                                                  MemoryManager memoryManager,
                                                  Version minNodeVersion,
                                                  BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
                                                  Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
                                                  BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                                                  Query query,
                                                  CollectorContext collectorContext) {
            for (int i = 0; i &lt; keyExpressions.size(); i++) {
                keyExpressions.get(i).startCollect(collectorContext);
            }

            AtomicReference&lt;Throwable&gt; killed = new AtomicReference&lt;&gt;();
            return CollectingBatchIterator.newInstance(
                () -&gt; killed.set(BatchIterator.CLOSED),
                killed::set,
                () -&gt; {
                    try {
                        return CompletableFuture.completedFuture(
                            getRows(
                                applyAggregatesGroupedByKey(
                                    aggregators,
                                    indexSearcher,
                                    keyExpressions,
                                    accountForNewKeyEntry,
                                    keyExtractor,
                                    ramAccounting,
                                    memoryManager,
                                    minNodeVersion,
                                    query,
                                    killed
                                ),
                                keyExpressions.size(),
                                applyKeyToCells,
                                aggregators,
                                ramAccounting
                            )
                        );
                    } catch (Throwable t) {
                        return CompletableFuture.failedFuture(t);
                    }
                },
                true
            );
        }

        private static &lt;K&gt; Iterable&lt;Row&gt; getRows(Map&lt;K, Object[]&gt; groupedStates,
                                                 int numberOfKeys,
                                                 BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                                                 List&lt;DocValueAggregator&gt; aggregators,
                                                 RamAccounting ramAccounting) {
            return () -&gt; {
                Object[] cells = new Object[numberOfKeys + aggregators.size()];
                RowN row = new RowN(cells);
                Function&lt;Map.Entry&lt;K, Object[]&gt;, Row&gt; mapper = entry -&gt; {
                    K key = entry.getKey();
                    applyKeyToCells.accept(key, cells);

                    Object[] states = entry.getValue();
                    int c = numberOfKeys;
                    for (int i = 0; i &lt; states.length; i++) {
                        //noinspection unchecked
                        cells[c] = aggregators.get(i).partialResult(ramAccounting, states[i]);
                        c++;
                    }
                    return row;
                };
                return groupedStates.entrySet().stream().map(mapper).iterator();
            };
        }

        private static &lt;K&gt; Map&lt;K, Object[]&gt; applyAggregatesGroupedByKey(
            List&lt;DocValueAggregator&gt; aggregators,
            IndexSearcher indexSearcher,
            List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; keyExpressions,
            BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewKeyEntry,
            Function&lt;List&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt;, K&gt; keyExtractor,
            RamAccounting ramAccounting,
            MemoryManager memoryManager,
            Version minNodeVersion,
            Query query,
            AtomicReference&lt;Throwable&gt; killed
        ) throws IOException {

            HashMap&lt;K, Object[]&gt; statesByKey = new HashMap&lt;&gt;();
            Weight weight = indexSearcher.createWeight(
                indexSearcher.rewrite(query),
                ScoreMode.COMPLETE_NO_SCORES,
                1f
            );
            List&lt;LeafReaderContext&gt; leaves = indexSearcher.getTopReaderContext().leaves();
            for (var leaf : leaves) {
                raiseIfClosedOrKilled(killed);
                Scorer scorer = weight.scorer(leaf);
                if (scorer == null) {
                    continue;
                }
<A NAME="4"></A>                for (int i = 0; i &lt; keyExpressions.size(); i++) {
                    keyExpressions.get(i).setNextReader(new ReaderContext(leaf));
                }
                <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1561282-1.html#4',3,'match1561282-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (int i = 0; i &lt; aggregators.size(); i++) {
                    aggregators.get(i).loadDocValues(leaf.reader());
                }</B></FONT>

                DocIdSetIterator docs = scorer.iterator();
                Bits liveDocs = leaf.reader().getLiveDocs();
                for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docs.nextDoc()) {
                    raiseIfClosedOrKilled(killed);
                    if (docDeleted(liveDocs, doc)) {
<A NAME="1"></A>                        continue;
                    }

                    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1561282-1.html#1',3,'match1561282-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (int i = 0; i &lt; keyExpressions.size(); i++) {
                        keyExpressions.get(i).setNextDocId(doc);
                    }
                    K key = keyExtractor.apply</B></FONT>(keyExpressions);

                    Object[] states = statesByKey.get(key);
                    if (states == null) {
                        states = new Object[aggregators.size()];
                        for (int i = 0; i &lt; aggregators.size(); i++) {
                            var aggregator = aggregators.get(i);
                            states[i] = aggregator.initialState(ramAccounting, memoryManager, minNodeVersion);
                            //noinspection unchecked
                            aggregator.apply(ramAccounting, doc, states[i]);
                        }
<A NAME="3"></A>                        accountForNewKeyEntry.accept(statesByKey, key);
                        statesByKey.put(key, states);
                    } else {
                        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1561282-1.html#3',3,'match1561282-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (int i = 0; i &lt; aggregators.size(); i++) {
                            //noinspection unchecked
                            aggregators.get(i).apply(ramAccounting, doc, states[i]);
                        }
                    }</B></FONT>
                }
            }
            return statesByKey;
        }

        private static boolean docDeleted(@Nullable Bits liveDocs, int doc) {
            return liveDocs != null &amp;&amp; !liveDocs.get(doc);
        }

        private static void raiseIfClosedOrKilled(AtomicReference&lt;Throwable&gt; killed) {
            Throwable killedException = killed.get();
            if (killedException != null) {
                Exceptions.rethrowUnchecked(killedException);
            }
        }
    }

    @Nullable
    private static Reference getKeyRef(List&lt;Symbol&gt; toCollect, Symbol key) {
        if (key instanceof InputColumn) {
            Symbol keyRef = toCollect.get(((InputColumn) key).index());
            if (keyRef instanceof Reference) {
                return ((Reference) keyRef);
            }
        }
        return null;
    }

    private static GroupProjection getSinglePartialGroupProjection(Collection&lt;? extends Projection&gt; shardProjections) {
        if (shardProjections.size() != 1) {
            return null;
        }
        Projection shardProjection = shardProjections.iterator().next();
        if (!(shardProjection instanceof GroupProjection) ||
            ((GroupProjection) shardProjection).mode() == AggregateMode.ITER_FINAL) {
            return null;
        }
        return (GroupProjection) shardProjection;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>NodeStatsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#0',2,'match1561282-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.integrationtests;

import io.crate.testing.SQLResponse;
import io.crate.testing.UseJdbc;
import org.apache.lucene.util.Constants;
import org.elasticsearch.Version;
import org.elasticsearch.env.NodeEnvironment;
import org.elasticsearch.test.ESIntegTestCase;
import org.hamcrest.Matchers;
import org.junit.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.anyOf;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.lessThan;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import</B></FONT> static org.hamcrest.core.Is.is;

@ESIntegTestCase.ClusterScope(numClientNodes = 0, numDataNodes = 2, supportsDedicatedMasters = false)
public class NodeStatsTest extends SQLIntegrationTestCase {

    @Test
    public void testSysNodesMem() throws Exception {
        SQLResponse response = execute(&quot;select mem['free'], mem['used'], mem['free_percent'], mem['used_percent'] from sys.nodes limit 1&quot;);
        long free = (long) response.rows()[0][0];
        long used = (long) response.rows()[0][1];

        double free_percent = ((Number) response.rows()[0][2]).intValue() * 0.01;
        double used_percent = ((Number) response.rows()[0][3]).intValue() * 0.01;

        double calculated_free_percent = free / (double) (free + used);
        double calculated_used_percent = used / (double) (free + used);

        double max_delta = 0.02; // result should not differ from calculated result more than 2%
        double free_delta = Math.abs(calculated_free_percent - free_percent);
        double used_delta = Math.abs(calculated_used_percent - used_percent);
        assertThat(free_delta, is(lessThan(max_delta)));
        assertThat(used_delta, is(lessThan(max_delta)));

    }

    @SuppressWarnings(&quot;ConstantConditions&quot;)
    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testThreadPools() throws Exception {
        SQLResponse response = execute(&quot;select thread_pools from sys.nodes limit 1&quot;);

        List threadPools = (List) response.rows()[0][0];
        assertThat(threadPools.size(), greaterThanOrEqualTo(1));

        Map&lt;String, Object&gt; threadPool = null;
        for (Object t : threadPools) {
            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) t;
            if (map.get(&quot;name&quot;).equals(&quot;generic&quot;)) {
                threadPool = map;
                break;
            }
        }
        assertThat(threadPool.get(&quot;name&quot;), is(&quot;generic&quot;));
        assertThat((Integer) threadPool.get(&quot;active&quot;), greaterThanOrEqualTo(0));
        assertThat((Long) threadPool.get(&quot;rejected&quot;), greaterThanOrEqualTo(0L));
        assertThat((Integer) threadPool.get(&quot;largest&quot;), greaterThanOrEqualTo(0));
        assertThat((Long) threadPool.get(&quot;completed&quot;), greaterThanOrEqualTo(0L));
        assertThat((Integer) threadPool.get(&quot;threads&quot;), greaterThanOrEqualTo(0));
        assertThat((Integer) threadPool.get(&quot;queue&quot;), greaterThanOrEqualTo(0));
    }

    @Test
    public void testThreadPoolValue() throws Exception {
        SQLResponse response = execute(&quot;select thread_pools['name'], thread_pools['queue'] from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));

        List&lt;Object&gt; objects = (List&lt;Object&gt;) response.rows()[0][0];
        assertThat(objects, Matchers.hasItem(&quot;generic&quot;));

        List queues = (List) response.rows()[0][1];
        assertThat(queues.size(), greaterThanOrEqualTo(1));
        assertThat((Integer) queues.get(0), greaterThanOrEqualTo(0));
    }

    @Test
    public void testNetwork() throws Exception {
        SQLResponse response = execute(&quot;select network from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));

        Map&lt;String, Object&gt; network = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertThat(network, hasKey(&quot;tcp&quot;));
        Map&lt;String, Object&gt; tcp = (Map&lt;String, Object&gt;) network.get(&quot;tcp&quot;);
        assertNetworkTCP(tcp);


        response = execute(&quot;select network['tcp'] from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));
        tcp = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertNetworkTCP(tcp);
    }

    private void assertNetworkTCP(Map&lt;String, Object&gt; tcp) {
<A NAME="5"></A>        assertThat(tcp.keySet().size(), is(2));
        assertThat(tcp.keySet(), hasItems(&quot;packets&quot;, &quot;connections&quot;));

        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#5',2,'match1561282-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Map&lt;String, Object&gt; connections = (Map&lt;String, Object&gt;) tcp.get(&quot;connections&quot;);
        assertThat(connections.keySet().size(), is(5));
        assertThat(connections.keySet(), hasItems</B></FONT>(&quot;initiated&quot;, &quot;accepted&quot;, &quot;curr_established&quot;, &quot;dropped&quot;, &quot;embryonic_dropped&quot;));

        Map&lt;String, Object&gt; packets = (Map&lt;String, Object&gt;) tcp.get(&quot;packets&quot;);
        assertThat(packets.keySet().size(), is(5));
        assertThat(packets.keySet(), hasItems(&quot;sent&quot;, &quot;received&quot;, &quot;errors_received&quot;, &quot;retransmitted&quot;, &quot;rst_sent&quot;));
    }

    @Test
    public void testNetworkTcpConnectionFields() throws Exception {
        SQLResponse response = execute(&quot;select &quot; +
                                       &quot;network['tcp']['connections']['initiated'], &quot; +
                                       &quot;network['tcp']['connections']['accepted'], &quot; +
                                       &quot;network['tcp']['connections']['curr_established'],&quot; +
<A NAME="2"></A>                                       &quot;network['tcp']['connections']['dropped'],&quot; +
                                       &quot;network['tcp']['connections']['embryonic_dropped']&quot; +
                                       &quot; from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#2',2,'match1561282-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>is(1L));
        for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }</B></FONT>
    }

    @Test
    public void testNetworkTcpPacketsFields() throws Exception {
        SQLResponse response = execute(&quot;select &quot; +
                                       &quot;network['tcp']['packets']['sent'], &quot; +
                                       &quot;network['tcp']['packets']['received'], &quot; +
                                       &quot;network['tcp']['packets']['retransmitted'], &quot; +
                                       &quot;network['tcp']['packets']['errors_received'], &quot; +
<A NAME="4"></A>                                       &quot;network['tcp']['packets']['rst_sent'] &quot; +
                                       &quot;from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));
        <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#4',2,'match1561282-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }</B></FONT>
    }

    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testSysNodesOs() throws Exception {
        SQLResponse response = execute(&quot;select os from sys.nodes limit 1&quot;);
        Map results = (Map) response.rows()[0][0];
        assertThat(response.rowCount(), is(1L));

        assertThat((Long) results.get(&quot;timestamp&quot;), greaterThan(0L));
        assertThat((Long) results.get(&quot;uptime&quot;), greaterThanOrEqualTo(-1L));

        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;system&quot;), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;system&quot;), lessThanOrEqualTo((short) 100));

        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;user&quot;), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;user&quot;), lessThanOrEqualTo((short) 100));

        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;used&quot;), greaterThanOrEqualTo((short) -1));
        assertThat((Short) ((Map) results.get(&quot;cpu&quot;)).get(&quot;used&quot;), lessThanOrEqualTo((short) 100));

    }

    @Test
    public void testSysNodesCgroup() throws Exception {
        if (Constants.LINUX &amp;&amp; !&quot;true&quot;.equals(System.getenv(&quot;SHIPPABLE&quot;))) { // cgroups are only available on Linux
            SQLResponse response = execute(&quot;select&quot; +
                                           &quot; os['cgroup']['cpuacct']['control_group'],&quot; +
                                           &quot; os['cgroup']['cpuacct']['usage_nanos'],&quot; +
                                           &quot; os['cgroup']['cpu']['control_group'],&quot; +
                                           &quot; os['cgroup']['cpu']['cfs_period_micros'],&quot; +
                                           &quot; os['cgroup']['cpu']['cfs_quota_micros'],&quot; +
                                           &quot; os['cgroup']['cpu']['num_elapsed_periods'],&quot; +
                                           &quot; os['cgroup']['cpu']['num_times_throttled'],&quot; +
                                           &quot; os['cgroup']['cpu']['time_throttled_nanos']&quot; +
                                           &quot; from sys.nodes limit 1&quot;);
            assertThat(response.rowCount(), is(1L));
            assertThat(response.rows()[0][0], notNullValue());
            assertThat((long) response.rows()[0][1], greaterThanOrEqualTo(0L));
            assertThat(response.rows()[0][2], notNullValue());
            assertThat((long) response.rows()[0][3], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][4], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][5], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][6], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
            assertThat((long) response.rows()[0][7], anyOf(equalTo(-1L), greaterThanOrEqualTo(0L)));
        } else {
            // for all other OS cgroup fields should return `null`
            response = execute(&quot;select os['cgroup'],&quot; +
                               &quot; os['cgroup']['cpuacct'],&quot; +
                               &quot; os['cgroup']['cpuacct']['control_group'],&quot; +
                               &quot; os['cgroup']['cpuacct']['usage_nanos'],&quot; +
                               &quot; os['cgroup']['cpu'],&quot; +
                               &quot; os['cgroup']['cpu']['control_group'],&quot; +
                               &quot; os['cgroup']['cpu']['cfs_period_micros'],&quot; +
                               &quot; os['cgroup']['cpu']['cfs_quota_micros'],&quot; +
                               &quot; os['cgroup']['cpu']['num_elapsed_periods'],&quot; +
                               &quot; os['cgroup']['cpu']['num_times_throttled'],&quot; +
                               &quot; os['cgroup']['cpu']['time_throttled_nanos']&quot; +
                               &quot; from sys.nodes limit 1&quot;);
            assertThat(response.rowCount(), is(1L));
            for (int i = 0; i &lt;= 10; i++) {
                assertThat(response.rows()[0][1], Matchers.is(Map.of()));
            }
        }

    }

    @Test
    public void testSysNodsOsInfo() throws Exception {
        SQLResponse response = execute(&quot;select os_info from sys.nodes limit 1&quot;);
        Map results = (Map) response.rows()[0][0];
        assertThat(response.rowCount(), is(1L));

        assertThat((Integer) results.get(&quot;available_processors&quot;), greaterThan(0));
        assertEquals(Constants.OS_NAME, results.get(&quot;name&quot;));
        assertEquals(Constants.OS_ARCH, results.get(&quot;arch&quot;));
        assertEquals(Constants.OS_VERSION, results.get(&quot;version&quot;));

        Map&lt;String, Object&gt; jvmObj = new HashMap&lt;&gt;(4);
        jvmObj.put(&quot;version&quot;, Constants.JAVA_VERSION);
        jvmObj.put(&quot;vm_name&quot;, Constants.JVM_NAME);
        jvmObj.put(&quot;vm_vendor&quot;, Constants.JVM_VENDOR);
        jvmObj.put(&quot;vm_version&quot;, Constants.JVM_VERSION);
        assertEquals(jvmObj, results.get(&quot;jvm&quot;));
    }

    @Test
    public void testSysNodesProcess() throws Exception {
        SQLResponse response = execute(&quot;select process['open_file_descriptors'], &quot; +
                                       &quot;process['max_open_file_descriptors'] &quot; +
                                       &quot;from sys.nodes limit 1&quot;);
        for (int i = 0; i &lt; response.cols().length; i++) {
            assertThat((Long) response.rows()[0][i], greaterThanOrEqualTo(-1L));
        }
    }

    @Test
    @UseJdbc(0) // because of json some values are transfered as integer instead of long
    public void testFs() throws Exception {
        SQLResponse response = execute(&quot;select fs from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));
        assertThat(response.rows()[0][0], instanceOf(Map.class));
        Map&lt;String, Object&gt; fs = (Map&lt;String, Object&gt;) response.rows()[0][0];
        assertThat(fs.keySet().size(), is(3));
        assertThat(fs.keySet(), hasItems(&quot;total&quot;, &quot;disks&quot;, &quot;data&quot;));

<A NAME="1"></A>        Map&lt;String, Object&gt; total = (Map&lt;String, Object&gt;) fs.get(&quot;total&quot;);
        assertThat(total.keySet(), hasItems(&quot;size&quot;, &quot;used&quot;, &quot;available&quot;, &quot;reads&quot;, &quot;writes&quot;,
            &quot;bytes_written&quot;, &quot;bytes_read&quot;));
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#1',2,'match1561282-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (Object val : total.values()) {
            assertThat((Long) val, greaterThanOrEqualTo(-1L));
        }

        List disks = (List) fs.get</B></FONT>(&quot;disks&quot;);
        if (disks.size() &gt; 0) {
            // on travis there are no accessible disks
            assertThat(disks.size(), greaterThanOrEqualTo(1));
            Map&lt;String, Object&gt; someDisk = (Map&lt;String, Object&gt;) disks.get(0);
            assertThat(someDisk.keySet().size(), is(4));
            assertThat(someDisk.keySet(), hasItems(&quot;dev&quot;, &quot;size&quot;, &quot;used&quot;, &quot;available&quot;));
            for (Map.Entry&lt;String, Object&gt; entry : someDisk.entrySet()) {
                if (!entry.getKey().equals(&quot;dev&quot;)) {
                    assertThat((Long) entry.getValue(), greaterThanOrEqualTo(-1L));
                }
            }
        }

        List data = (List) fs.get(&quot;data&quot;);
        if (data.size() &gt; 0) {
            // without sigar, no data definition returned
            int numDataPaths = internalCluster().getInstance(NodeEnvironment.class).nodeDataPaths().length;
            assertThat(data.size(), is(numDataPaths));
            Map&lt;String, Object&gt; someData = (Map&lt;String, Object&gt;) data.get(0);
            assertThat(someData.keySet().size(), is(2));
            assertThat(someData.keySet(), hasItems(&quot;dev&quot;, &quot;path&quot;));
        }
    }

    @Test
    public void testFsNoRootFS() throws Exception {
        SQLResponse response = execute(&quot;select fs['data']['dev'], fs['disks'] from sys.nodes&quot;);
        assertThat(response.rowCount(), is(2L));
        for (Object[] row : response.rows()) {
            // data device name
            for (Object diskDevName : (List) row[0]) {
                assertThat(diskDevName, is(not(&quot;rootfs&quot;)));
            }
            List disks = (List) row[1];
            // disks device name
            for (Object disk : disks) {
                String diskDevName = (String) ((Map&lt;String, Object&gt;) disk).get(&quot;dev&quot;);
                assertThat(diskDevName, is(notNullValue()));
                assertThat(diskDevName, is(not(&quot;rootfs&quot;)));
            }
        }
    }

    @Test
<A NAME="3"></A>    public void testSysNodesObjectArrayStringChildColumn() throws Exception {
        SQLResponse response = execute(&quot;select fs['data']['path'] from sys.nodes&quot;);
        assertThat(response.rowCount(), Matchers.is(2L));
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1561282-0.html#3',2,'match1561282-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (Object path : (List) response.rows()[0][0]) {
            assertThat(path, instanceOf(String.class));
        }
    }</B></FONT>

    @Test
    public void testVersion() throws Exception {
        SQLResponse response = execute(&quot;select version, version['number'], &quot; +
                                       &quot;version['build_hash'], version['build_snapshot'] &quot; +
                                       &quot;from sys.nodes limit 1&quot;);
        assertThat(response.rowCount(), is(1L));
        assertThat(response.rows()[0][0], instanceOf(Map.class));
        assertThat((Map&lt;String, Object&gt;) response.rows()[0][0], allOf(hasKey(&quot;number&quot;), hasKey(&quot;build_hash&quot;), hasKey(&quot;build_snapshot&quot;)));
        assertThat((String) response.rows()[0][1], is(Version.CURRENT.externalNumber()));
        assertThat(response.rows()[0][2], instanceOf(String.class));
        assertThat((Boolean) response.rows()[0][3], is(Version.CURRENT.isSnapshot()));
    }

    @Test
    public void testRegexpMatchOnNode() throws Exception {
        SQLResponse response = execute(&quot;select name from sys.nodes where name ~ 'node_s[0-1]{1,2}' order by name&quot;);
        assertThat(response.rowCount(), is(2L));
        assertThat((String) response.rows()[0][0], is(&quot;node_s0&quot;));
        assertThat((String) response.rows()[1][0], is(&quot;node_s1&quot;));
    }
}
</PRE>
</div>
  </div>
</body>
</html>
