<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for RateLimiter_1.java & MultimapBuilder.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for RateLimiter_1.java & MultimapBuilder.java
      </h3>
      <h1 align="center">
        12.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>RateLimiter_1.java (16.149069%)<TH>MultimapBuilder.java (9.665427%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match522648-0.html#0',2,'match522648-1.html#0',3)" NAME="0">(17-96)<TD><A HREF="javascript:ZweiFrames('match522648-0.html#0',2,'match522648-1.html#0',3)" NAME="0">(20-65)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match522648-0.html#1',2,'match522648-1.html#1',3)" NAME="1">(277-303)<TD><A HREF="javascript:ZweiFrames('match522648-0.html#1',2,'match522648-1.html#1',3)" NAME="1">(95-118)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match522648-0.html#2',2,'match522648-1.html#2',3)" NAME="2">(478-484)<TD><A HREF="javascript:ZweiFrames('match522648-0.html#2',2,'match522648-1.html#2',3)" NAME="2">(77-87)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match522648-0.html#3',2,'match522648-1.html#3',3)" NAME="3">(454-459)<TD><A HREF="javascript:ZweiFrames('match522648-0.html#3',2,'match522648-1.html#3',3)" NAME="3">(126-141)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RateLimiter_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<A NAME="0"></A>
package com.google.common.util.concurrent;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match522648-1.html#0',3,'match522648-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.util.concurrent.Internal.toNanosSaturated;
import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MICROSECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.util.concurrent.SmoothRateLimiter.SmoothBursty;
import com.google.common.util.concurrent.SmoothRateLimiter.SmoothWarmingUp;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.time.Duration;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import javax.annotation.CheckForNull;

/**
 * A rate limiter. Conceptually, a rate limiter distributes permits at a configurable rate. Each
 * {@link #acquire()} blocks if necessary until a permit is available, and then takes it. Once
 * acquired, permits need not be released.
 *
 * &lt;p&gt;{@code RateLimiter} is safe for concurrent use: It will restrict the total rate of calls from
 * all threads. Note, however, that it does not guarantee fairness.
 *
 * &lt;p&gt;Rate limiters are often used to restrict the rate at which some physical or logical resource
 * is accessed. This is in contrast to {@link java.util.concurrent.Semaphore} which restricts the
 * number of concurrent accesses instead of the rate (note though that concurrency and rate are
 * closely related, e.g. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Little%27s_law&quot;&gt;Little's
 * Law&lt;/a&gt;).
 *
 * &lt;p&gt;A {@code RateLimiter} is defined primarily by the rate at which permits are issued. Absent
 * additional configuration, permits will be distributed at a fixed rate, defined in terms of
 * permits per second. Permits will be distributed smoothly, with the delay between individual
 * permits being adjusted to ensure that the configured rate is maintained.
 *
 * &lt;p&gt;It is possible to configure a {@code RateLimiter} to have a warmup period during which time
 * the permits issued each second steadily increases until it hits the stable rate.
 *
 * &lt;p&gt;As an example, imagine that we have a list of tasks to execute, but we don't want to submit
 * more than 2 per second:
 *
 * &lt;pre&gt;{@code
 * final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is &quot;2 permits per second&quot;
 * void submitTasks(List&lt;Runnable&gt; tasks, Executor executor) {
 *   for (Runnable task : tasks) {
 *     rateLimiter.acquire(); // may wait
 *     executor.execute(task);
 *   }
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;As another example, imagine that we produce a stream of data, and we want to cap it at 5kb per
 * second. This could be accomplished by requiring a permit per byte, and specifying a rate of 5000
 * permits per second:
 *
 * &lt;pre&gt;{@code
 * final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second
 * void submitPacket(byte[] packet) {
 *   rateLimiter.acquire(packet.length);
 *   networkService.send(packet);
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;It is important to note that the number of permits requested &lt;i&gt;never&lt;/i&gt; affects the
 * throttling of the request itself (an invocation to {@code acquire(1)} and an invocation to {@code
 * acquire(1000)} will result in exactly the same throttling, if any), but it affects the throttling
 * of the &lt;i&gt;next&lt;/i&gt; request. I.e., if an expensive task arrives at an idle RateLimiter, it will be
 * granted immediately, but it is the &lt;i&gt;next&lt;/i&gt; request that will experience extra throttling,
 * thus paying for the cost of the expensive task.
 *
 * @author Dimitris Andreou
 * @since 13.0
 */
// TODO(user): switch to nano precision. A natural unit of cost is &quot;bytes&quot;, and a micro precision
// would mean a maximum rate of &quot;1MB/s&quot;, which might be small in some cases.
@Beta
@</B></FONT>GwtIncompatible
@ElementTypesAreNonnullByDefault
public abstract class RateLimiter {
  /**
   * Creates a {@code RateLimiter} with the specified stable throughput, given as &quot;permits per
   * second&quot; (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second).
   *
   * &lt;p&gt;The returned {@code RateLimiter} ensures that on average no more than {@code
   * permitsPerSecond} are issued during any given second, with sustained requests being smoothly
   * spread over each second. When the incoming request rate exceeds {@code permitsPerSecond} the
   * rate limiter will release one permit every {@code (1.0 / permitsPerSecond)} seconds. When the
   * rate limiter is unused, bursts of up to {@code permitsPerSecond} permits will be allowed, with
   * subsequent requests being smoothly limited at the stable rate of {@code permitsPerSecond}.
   *
   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
   *     permits become available per second
   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
   */
  // TODO(user): &quot;This is equivalent to
  // {@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)}&quot;.
  public static RateLimiter create(double permitsPerSecond) {
    /*
     * The default RateLimiter configuration can save the unused permits of up to one second. This
     * is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps, and 4 threads,
     * all calling acquire() at these moments:
     *
     * T0 at 0 seconds
     * T1 at 1.05 seconds
     * T2 at 2 seconds
     * T3 at 3 seconds
     *
     * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds, and T3 would also
     * have to sleep till 3.05 seconds.
     */
    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());
  }

  @VisibleForTesting
  static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {
    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);
    rateLimiter.setRate(permitsPerSecond);
    return rateLimiter;
  }

  /**
   * Creates a {@code RateLimiter} with the specified stable throughput, given as &quot;permits per
   * second&quot; (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second), and a &lt;i&gt;warmup period&lt;/i&gt;,
   * during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum
   * rate at the end of the period (as long as there are enough requests to saturate it). Similarly,
   * if the {@code RateLimiter} is left &lt;i&gt;unused&lt;/i&gt; for a duration of {@code warmupPeriod}, it
   * will gradually return to its &quot;cold&quot; state, i.e. it will go through the same warming up process
   * as when it was first created.
   *
   * &lt;p&gt;The returned {@code RateLimiter} is intended for cases where the resource that actually
   * fulfills the requests (e.g., a remote server) needs &quot;warmup&quot; time, rather than being
   * immediately accessed at the stable (maximum) rate.
   *
   * &lt;p&gt;The returned {@code RateLimiter} starts in a &quot;cold&quot; state (i.e. the warmup period will
   * follow), and if it is left unused for long enough, it will return to that state.
   *
   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
   *     permits become available per second
   * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,
   *     before reaching its stable (maximum) rate
   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code
   *     warmupPeriod} is negative
   * @since 28.0
   */
  public static RateLimiter create(double permitsPerSecond, Duration warmupPeriod) {
    return create(permitsPerSecond, toNanosSaturated(warmupPeriod), TimeUnit.NANOSECONDS);
  }

  /**
   * Creates a {@code RateLimiter} with the specified stable throughput, given as &quot;permits per
   * second&quot; (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second), and a &lt;i&gt;warmup period&lt;/i&gt;,
   * during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum
   * rate at the end of the period (as long as there are enough requests to saturate it). Similarly,
   * if the {@code RateLimiter} is left &lt;i&gt;unused&lt;/i&gt; for a duration of {@code warmupPeriod}, it
   * will gradually return to its &quot;cold&quot; state, i.e. it will go through the same warming up process
   * as when it was first created.
   *
   * &lt;p&gt;The returned {@code RateLimiter} is intended for cases where the resource that actually
   * fulfills the requests (e.g., a remote server) needs &quot;warmup&quot; time, rather than being
   * immediately accessed at the stable (maximum) rate.
   *
   * &lt;p&gt;The returned {@code RateLimiter} starts in a &quot;cold&quot; state (i.e. the warmup period will
   * follow), and if it is left unused for long enough, it will return to that state.
   *
   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
   *     permits become available per second
   * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,
   *     before reaching its stable (maximum) rate
   * @param unit the time unit of the warmupPeriod argument
   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code
   *     warmupPeriod} is negative
   */
  @SuppressWarnings(&quot;GoodTime&quot;) // should accept a java.time.Duration
  public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) {
    checkArgument(warmupPeriod &gt;= 0, &quot;warmupPeriod must not be negative: %s&quot;, warmupPeriod);
    return create(
        permitsPerSecond, warmupPeriod, unit, 3.0, SleepingStopwatch.createFromSystemTimer());
  }

  @VisibleForTesting
  static RateLimiter create(
      double permitsPerSecond,
      long warmupPeriod,
      TimeUnit unit,
      double coldFactor,
      SleepingStopwatch stopwatch) {
    RateLimiter rateLimiter = new SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);
    rateLimiter.setRate(permitsPerSecond);
    return rateLimiter;
  }

  /**
   * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate
   * object to facilitate testing.
   */
  private final SleepingStopwatch stopwatch;

  // Can't be initialized in the constructor because mocks don't call the constructor.
  @CheckForNull private volatile Object mutexDoNotUseDirectly;

  private Object mutex() {
    Object mutex = mutexDoNotUseDirectly;
    if (mutex == null) {
      synchronized (this) {
        mutex = mutexDoNotUseDirectly;
        if (mutex == null) {
          mutexDoNotUseDirectly = mutex = new Object();
        }
      }
    }
    return mutex;
  }

  RateLimiter(SleepingStopwatch stopwatch) {
    this.stopwatch = checkNotNull(stopwatch);
  }

  /**
   * Updates the stable rate of this {@code RateLimiter}, that is, the {@code permitsPerSecond}
   * argument provided in the factory method that constructed the {@code RateLimiter}. Currently
   * throttled threads will &lt;b&gt;not&lt;/b&gt; be awakened as a result of this invocation, thus they do not
   * observe the new rate; only subsequent requests will.
   *
   * &lt;p&gt;Note though that, since each request repays (by waiting, if necessary) the cost of the
   * &lt;i&gt;previous&lt;/i&gt; request, this means that the very next request after an invocation to {@code
   * setRate} will not be affected by the new rate; it will pay the cost of the previous request,
   * which is in terms of the previous rate.
   *
   * &lt;p&gt;The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the {@code
   * RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup period of
   * 20 seconds after this method invocation.
   *
   * @param permitsPerSecond the new stable rate of this {@code RateLimiter}
   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
   */
  public final void setRate(double permitsPerSecond) {
    checkArgument(
        permitsPerSecond &gt; 0.0 &amp;&amp; !Double.isNaN(permitsPerSecond), &quot;rate must be positive&quot;);
    synchronized (mutex()) {
      doSetRate(permitsPerSecond, stopwatch.readMicros());
    }
  }

  abstract void doSetRate(double permitsPerSecond, long nowMicros);

  /**
   * Returns the stable rate (as {@code permits per seconds}) with which this {@code RateLimiter} is
   * configured with. The initial value of this is the same as the {@code permitsPerSecond} argument
   * passed in the factory method that produced this {@code RateLimiter}, and it is only updated
   * after invocations to {@linkplain #setRate}.
   */
  public final double getRate() {
    synchronized (mutex()) {
      return doGetRate();
<A NAME="1"></A>    }
  }

  abstract double doGetRate()<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match522648-1.html#1',3,'match522648-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>;

  /**
   * Acquires a single permit from this {@code RateLimiter}, blocking until the request can be
   * granted. Tells the amount of time slept, if any.
   *
   * &lt;p&gt;This method is equivalent to {@code acquire(1)}.
   *
   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
   * @since 16.0 (present in 13.0 with {@code void} return type})
   */
  @CanIgnoreReturnValue
  public double acquire() {
    return acquire(1);
  }

  /**
   * Acquires the given number of permits from this {@code RateLimiter}, blocking until the request
   * can be granted. Tells the amount of time slept, if any.
   *
   * @param permits the number of permits to acquire
   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   * @since 16.0 (present in 13.0 with {@code void} return type})
   */
  @CanIgnoreReturnValue
  public double acquire(int permits) {</B></FONT>
    long microsToWait = reserve(permits);
    stopwatch.sleepMicrosUninterruptibly(microsToWait);
    return 1.0 * microsToWait / SECONDS.toMicros(1L);
  }

  /**
   * Reserves the given number of permits from this {@code RateLimiter} for future use, returning
   * the number of microseconds until the reservation can be consumed.
   *
   * @return time in microseconds to wait until the resource can be acquired, never negative
   */
  final long reserve(int permits) {
    checkPermits(permits);
    synchronized (mutex()) {
      return reserveAndGetWaitLength(permits, stopwatch.readMicros());
    }
  }

  /**
   * Acquires a permit from this {@code RateLimiter} if it can be obtained without exceeding the
   * specified {@code timeout}, or returns {@code false} immediately (without waiting) if the permit
   * would not have been granted before the timeout expired.
   *
   * &lt;p&gt;This method is equivalent to {@code tryAcquire(1, timeout)}.
   *
   * @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
   * @return {@code true} if the permit was acquired, {@code false} otherwise
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   * @since 28.0
   */
  public boolean tryAcquire(Duration timeout) {
    return tryAcquire(1, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
  }

  /**
   * Acquires a permit from this {@code RateLimiter} if it can be obtained without exceeding the
   * specified {@code timeout}, or returns {@code false} immediately (without waiting) if the permit
   * would not have been granted before the timeout expired.
   *
   * &lt;p&gt;This method is equivalent to {@code tryAcquire(1, timeout, unit)}.
   *
   * @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
   * @param unit the time unit of the timeout argument
   * @return {@code true} if the permit was acquired, {@code false} otherwise
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   */
  @SuppressWarnings(&quot;GoodTime&quot;) // should accept a java.time.Duration
  public boolean tryAcquire(long timeout, TimeUnit unit) {
    return tryAcquire(1, timeout, unit);
  }

  /**
   * Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay.
   *
   * &lt;p&gt;This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}.
   *
   * @param permits the number of permits to acquire
   * @return {@code true} if the permits were acquired, {@code false} otherwise
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   * @since 14.0
   */
  public boolean tryAcquire(int permits) {
    return tryAcquire(permits, 0, MICROSECONDS);
  }

  /**
   * Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without
   * delay.
   *
   * &lt;p&gt;This method is equivalent to {@code tryAcquire(1)}.
   *
   * @return {@code true} if the permit was acquired, {@code false} otherwise
   * @since 14.0
   */
  public boolean tryAcquire() {
    return tryAcquire(1, 0, MICROSECONDS);
  }

  /**
   * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
   * without exceeding the specified {@code timeout}, or returns {@code false} immediately (without
   * waiting) if the permits would not have been granted before the timeout expired.
   *
   * @param permits the number of permits to acquire
   * @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
   * @return {@code true} if the permits were acquired, {@code false} otherwise
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   * @since 28.0
   */
  public boolean tryAcquire(int permits, Duration timeout) {
    return tryAcquire(permits, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
  }

  /**
   * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
   * without exceeding the specified {@code timeout}, or returns {@code false} immediately (without
   * waiting) if the permits would not have been granted before the timeout expired.
   *
   * @param permits the number of permits to acquire
   * @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
   * @param unit the time unit of the timeout argument
   * @return {@code true} if the permits were acquired, {@code false} otherwise
   * @throws IllegalArgumentException if the requested number of permits is negative or zero
   */
  @SuppressWarnings(&quot;GoodTime&quot;) // should accept a java.time.Duration
  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
    long timeoutMicros = max(unit.toMicros(timeout), 0);
    checkPermits(permits);
    long microsToWait;
    synchronized (mutex()) {
      long nowMicros = stopwatch.readMicros();
      if (!canAcquire(nowMicros, timeoutMicros)) {
        return false;
      } else {
        microsToWait = reserveAndGetWaitLength(permits, nowMicros);
      }
    }
    stopwatch.sleepMicrosUninterruptibly(microsToWait);
    return true;
  }

  private boolean canAcquire(long nowMicros, long timeoutMicros) {
    return queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros;
  }

  /**
   * Reserves next ticket and returns the wait time that the caller must wait for.
   *
   * @return the required wait time, never negative
   */
  final long reserveAndGetWaitLength(int permits, long nowMicros) {
    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);
    return max(momentAvailable - nowMicros, 0);
  }

  /**
   * Returns the earliest time that permits are available (with one caveat).
   *
   * @return the time that permits are available, or, if permits are available immediately, an
   *     arbitrary past or present time
   */
  abstract long queryEarliestAvailable(long nowMicros);

  /**
   * Reserves the requested number of permits and returns the time that those permits can be used
   * (with one caveat).
   *
<A NAME="3"></A>   * @return the time that the permits may be used, or, if the permits may be used immediately, an
   *     arbitrary past or present time
   */
  abstract long reserveEarliestAvailable(int permits, long nowMicros)<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match522648-1.html#3',3,'match522648-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>;

  @Override
  public String toString() {
    return String.format(Locale.ROOT, &quot;RateLimiter[stableRate=%3.1fqps]&quot;, getRate());
  }</B></FONT>

  abstract static class SleepingStopwatch {
    /** Constructor for use by subclasses. */
    protected SleepingStopwatch() {}

    /*
     * We always hold the mutex when calling this. TODO(cpovirk): Is that important? Perhaps we need
     * to guarantee that each call to reserveEarliestAvailable, etc. sees a value &gt;= the previous?
     * Also, is it OK that we don't hold the mutex when sleeping?
     */
    protected abstract long readMicros();

    protected abstract void sleepMicrosUninterruptibly(long micros);

    public static SleepingStopwatch createFromSystemTimer() {
<A NAME="2"></A>      return new SleepingStopwatch() {
        final Stopwatch stopwatch = Stopwatch.createStarted();

        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match522648-1.html#2',3,'match522648-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
        protected long readMicros() {
          return stopwatch.elapsed(MICROSECONDS);
        }

        @Override
        protected void sleepMicrosUninterruptibly(long micros) {</B></FONT>
          if (micros &gt; 0) {
            Uninterruptibles.sleepUninterruptibly(micros, MICROSECONDS);
          }
        }
      };
    }
  }

  private static void checkPermits(int permits) {
    checkArgument(permits &gt; 0, &quot;Requested permits (%s) must be positive&quot;, permits);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultimapBuilder.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2013 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

<A NAME="0"></A>package com.google.common.collect;

import static com.google.common.base.Preconditions.checkNotNull;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match522648-0.html#0',2,'match522648-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.collect.CollectPreconditions.checkNonnegative;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Supplier;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A builder for a multimap implementation that allows customization of the backing map and value
 * collection implementations used in a particular multimap.
 *
 * &lt;p&gt;This can be used to easily configure multimap data structure implementations not provided
 * explicitly in {@code com.google.common.collect}, for example:
 *
 * &lt;pre&gt;{@code
 * ListMultimap&lt;String, Integer&gt; treeListMultimap =
 *     MultimapBuilder.treeKeys().arrayListValues().build();
 * SetMultimap&lt;Integer, MyEnum&gt; hashEnumMultimap =
 *     MultimapBuilder.hashKeys().enumSetValues(MyEnum.class).build();
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;{@code MultimapBuilder} instances are immutable. Invoking a configuration method has no effect
 * on the receiving instance; you must store and use the new builder instance it returns instead.
 *
 * &lt;p&gt;The generated multimaps are serializable if the key and value types are serializable, unless
 * stated otherwise in one of the configuration methods.
 *
 * @author Louis Wasserman
 * @param &lt;K0&gt; An upper bound on the key type of the generated multimap.
 * @param &lt;V0&gt; An upper bound on the value type of the generated multimap.
 * @since 16.0
 */
@GwtCompatible
@</B></FONT>ElementTypesAreNonnullByDefault
public abstract class MultimapBuilder&lt;K0 extends @Nullable Object, V0 extends @Nullable Object&gt; {
  /*
   * Leaving K and V as upper bounds rather than the actual key and value types allows type
   * parameters to be left implicit more often. CacheBuilder uses the same technique.
   */

  private MultimapBuilder() {}

<A NAME="2"></A>  private static final int DEFAULT_EXPECTED_KEYS = 8;

  /** Uses a hash table to map keys to value collections. */
  <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match522648-0.html#2',2,'match522648-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; hashKeys() {
    return hashKeys(DEFAULT_EXPECTED_KEYS);
  }

  /**
   * Uses a hash table to map keys to value collections, initialized to expect the specified number
   * of keys.
   *
   * @throws IllegalArgumentException if {@code expectedKeys &lt; 0}
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; hashKeys(int expectedKeys) {</B></FONT>
    checkNonnegative(expectedKeys, &quot;expectedKeys&quot;);
    return new MultimapBuilderWithKeys&lt;@Nullable Object&gt;() {
      @Override
      &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
<A NAME="1"></A>        return Platform.newHashMapWithExpectedSize(expectedKeys);
      }
    };
  <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match522648-0.html#1',2,'match522648-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  /**
   * Uses a hash table to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in the order that they were first added to the
   * multimap, save that if all values associated with a key are removed and then the key is added
   * back into the multimap, that key will come last in the key iteration order.
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; linkedHashKeys() {
    return linkedHashKeys(DEFAULT_EXPECTED_KEYS);
  }

  /**
   * Uses an hash table to map keys to value collections, initialized to expect the specified number
   * of keys.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in the order that they were first added to the
   * multimap, save that if all values associated with a key are removed and then the key is added
   * back into the multimap, that key will come last in the key iteration order.
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; linkedHashKeys(int expectedKeys) {</B></FONT>
    checkNonnegative(expectedKeys, &quot;expectedKeys&quot;);
    return new MultimapBuilderWithKeys&lt;@Nullable Object&gt;() {
      @Override
      &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
<A NAME="3"></A>        return Platform.newLinkedHashMapWithExpectedSize(expectedKeys);
      }
    };
  <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match522648-0.html#3',2,'match522648-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  /**
   * Uses a naturally-ordered {@link TreeMap} to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in sorted order.
   *
   * &lt;p&gt;For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
   * safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
   * cast to a {@link java.util.SortedMap}.
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  public static MultimapBuilderWithKeys&lt;Comparable&gt; treeKeys() {
    return treeKeys(Ordering.natural());
  }</B></FONT>

  /**
   * Uses a {@link TreeMap} sorted by the specified comparator to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in sorted order.
   *
   * &lt;p&gt;For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
   * safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
   * cast to a {@link java.util.SortedMap}.
   *
   * &lt;p&gt;Multimaps generated by the resulting builder will not be serializable if {@code comparator}
   * is not serializable.
   */
  public static &lt;K0 extends @Nullable Object&gt; MultimapBuilderWithKeys&lt;K0&gt; treeKeys(
      Comparator&lt;K0&gt; comparator) {
    checkNotNull(comparator);
    return new MultimapBuilderWithKeys&lt;K0&gt;() {
      @Override
      &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        return new TreeMap&lt;&gt;(comparator);
      }
    };
  }

  /**
   * Uses an {@link EnumMap} to map keys to value collections.
   *
   * @since 16.0
   */
  public static &lt;K0 extends Enum&lt;K0&gt;&gt; MultimapBuilderWithKeys&lt;K0&gt; enumKeys(Class&lt;K0&gt; keyClass) {
    checkNotNull(keyClass);
    return new MultimapBuilderWithKeys&lt;K0&gt;() {
      @SuppressWarnings(&quot;unchecked&quot;)
      @Override
      &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        // K must actually be K0, since enums are effectively final
        // (their subclasses are inaccessible)
        return (Map&lt;K, Collection&lt;V&gt;&gt;) new EnumMap&lt;K0, Collection&lt;V&gt;&gt;(keyClass);
      }
    };
  }

  private static final class ArrayListSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;List&lt;V&gt;&gt;, Serializable {
    private final int expectedValuesPerKey;

    ArrayListSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public List&lt;V&gt; get() {
      return new ArrayList&lt;&gt;(expectedValuesPerKey);
    }
  }

  private enum LinkedListSupplier implements Supplier&lt;List&lt;?&gt;&gt; {
    INSTANCE;

    public static &lt;V extends @Nullable Object&gt; Supplier&lt;List&lt;V&gt;&gt; instance() {
      // Each call generates a fresh LinkedList, which can serve as a List&lt;V&gt; for any V.
      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
      Supplier&lt;List&lt;V&gt;&gt; result = (Supplier) INSTANCE;
      return result;
    }

    @Override
    public List&lt;?&gt; get() {
      return new LinkedList&lt;&gt;();
    }
  }

  private static final class HashSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    private final int expectedValuesPerKey;

    HashSetSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public Set&lt;V&gt; get() {
      return Platform.newHashSetWithExpectedSize(expectedValuesPerKey);
    }
  }

  private static final class LinkedHashSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    private final int expectedValuesPerKey;

    LinkedHashSetSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public Set&lt;V&gt; get() {
      return Platform.newLinkedHashSetWithExpectedSize(expectedValuesPerKey);
    }
  }

  private static final class TreeSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;SortedSet&lt;V&gt;&gt;, Serializable {
    private final Comparator&lt;? super V&gt; comparator;

    TreeSetSupplier(Comparator&lt;? super V&gt; comparator) {
      this.comparator = checkNotNull(comparator);
    }

    @Override
    public SortedSet&lt;V&gt; get() {
      return new TreeSet&lt;&gt;(comparator);
    }
  }

  private static final class EnumSetSupplier&lt;V extends Enum&lt;V&gt;&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    private final Class&lt;V&gt; clazz;

    EnumSetSupplier(Class&lt;V&gt; clazz) {
      this.clazz = checkNotNull(clazz);
    }

    @Override
    public Set&lt;V&gt; get() {
      return EnumSet.noneOf(clazz);
    }
  }

  /**
   * An intermediate stage in a {@link MultimapBuilder} in which the key-value collection map
   * implementation has been specified, but the value collection implementation has not.
   *
   * @param &lt;K0&gt; The upper bound on the key type of the generated multimap.
   * @since 16.0
   */
  public abstract static class MultimapBuilderWithKeys&lt;K0 extends @Nullable Object&gt; {

    private static final int DEFAULT_EXPECTED_VALUES_PER_KEY = 2;

    MultimapBuilderWithKeys() {}

    abstract &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap();

    /** Uses an {@link ArrayList} to store value collections. */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; arrayListValues() {
      return arrayListValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses an {@link ArrayList} to store value collections, initialized to expect the specified
     * number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; arrayListValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new ListMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; ListMultimap&lt;K, V&gt; build() {
          return Multimaps.newListMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new ArrayListSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses a {@link LinkedList} to store value collections. */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; linkedListValues() {
      return new ListMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; ListMultimap&lt;K, V&gt; build() {
          return Multimaps.newListMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), LinkedListSupplier.&lt;V&gt;instance());
        }
      };
    }

    /** Uses a hash-based {@code Set} to store value collections. */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; hashSetValues() {
      return hashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses a hash-based {@code Set} to store value collections, initialized to expect the specified
     * number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; hashSetValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new SetMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; SetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new HashSetSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses an insertion-ordered hash-based {@code Set} to store value collections. */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; linkedHashSetValues() {
      return linkedHashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses an insertion-ordered hash-based {@code Set} to store value collections, initialized to
     * expect the specified number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; linkedHashSetValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new SetMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; SetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new LinkedHashSetSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses a naturally-ordered {@link TreeSet} to store value collections. */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public SortedSetMultimapBuilder&lt;K0, Comparable&gt; treeSetValues() {
      return treeSetValues(Ordering.natural());
    }

    /**
     * Uses a {@link TreeSet} ordered by the specified comparator to store value collections.
     *
     * &lt;p&gt;Multimaps generated by the resulting builder will not be serializable if {@code
     * comparator} is not serializable.
     */
    public &lt;V0 extends @Nullable Object&gt; SortedSetMultimapBuilder&lt;K0, V0&gt; treeSetValues(
        Comparator&lt;V0&gt; comparator) {
      checkNotNull(comparator, &quot;comparator&quot;);
      return new SortedSetMultimapBuilder&lt;K0, V0&gt;() {
        @Override
        public &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSortedSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), new TreeSetSupplier&lt;V&gt;(comparator));
        }
      };
    }

    /** Uses an {@link EnumSet} to store value collections. */
    public &lt;V0 extends Enum&lt;V0&gt;&gt; SetMultimapBuilder&lt;K0, V0&gt; enumSetValues(Class&lt;V0&gt; valueClass) {
      checkNotNull(valueClass, &quot;valueClass&quot;);
      return new SetMultimapBuilder&lt;K0, V0&gt;() {
        @Override
        public &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build() {
          // V must actually be V0, since enums are effectively final
          // (their subclasses are inaccessible)
          @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
          Supplier&lt;Set&lt;V&gt;&gt; factory = (Supplier) new EnumSetSupplier&lt;V0&gt;(valueClass);
          return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), factory);
        }
      };
    }
  }

  /** Returns a new, empty {@code Multimap} with the specified implementation. */
  public abstract &lt;K extends K0, V extends V0&gt; Multimap&lt;K, V&gt; build();

  /**
   * Returns a {@code Multimap} with the specified implementation, initialized with the entries of
   * {@code multimap}.
   */
  public &lt;K extends K0, V extends V0&gt; Multimap&lt;K, V&gt; build(
      Multimap&lt;? extends K, ? extends V&gt; multimap) {
    Multimap&lt;K, V&gt; result = build();
    result.putAll(multimap);
    return result;
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link ListMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class ListMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends MultimapBuilder&lt;K0, V0&gt; {
    ListMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; ListMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; ListMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (ListMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link SetMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class SetMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends MultimapBuilder&lt;K0, V0&gt; {
    SetMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (SetMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link SortedSetMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class SortedSetMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends SetMultimapBuilder&lt;K0, V0&gt; {
    SortedSetMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (SortedSetMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
