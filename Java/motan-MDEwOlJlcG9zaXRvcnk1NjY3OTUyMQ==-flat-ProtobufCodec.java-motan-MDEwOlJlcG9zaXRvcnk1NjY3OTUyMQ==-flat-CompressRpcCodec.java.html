
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 43, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ProtobufCodec.java</h3>
            <pre><code>1  package com.weibo.api.motan.codec;
2  import java.io.ByteArrayOutputStream;
3  import java.io.IOException;
4  import java.util.HashMap;
5  import java.util.Map;
6  import com.google.protobuf.CodedInputStream;
7  import com.google.protobuf.CodedOutputStream;
8  import com.weibo.api.motan.common.MotanConstants;
9  import com.weibo.api.motan.common.URLParamType;
10  import com.weibo.api.motan.core.extension.ExtensionLoader;
11  import com.weibo.api.motan.core.extension.SpiMeta;
12  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
13  import com.weibo.api.motan.exception.MotanFrameworkException;
14  import com.weibo.api.motan.protocol.rpc.RpcProtocolVersion;
15  import com.weibo.api.motan.rpc.DefaultRequest;
16  import com.weibo.api.motan.rpc.DefaultResponse;
17  import com.weibo.api.motan.rpc.Request;
18  import com.weibo.api.motan.rpc.Response;
19  import com.weibo.api.motan.transport.Channel;
20  import com.weibo.api.motan.util.ByteUtil;
21  import com.weibo.api.motan.util.ExceptionUtil;
22  import com.weibo.api.motan.util.ReflectUtil;
23  @SpiMeta(name = "protobuf")
24  public class ProtobufCodec implements Codec {
25  	private static final short MAGIC = (short) 0xF0F0;
26  	private static final byte MASK = 0x07;
27  	@Override
28  	public byte[] encode(Channel channel, Object message) throws IOException {
29  		try {
30  			if (message instanceof Request) {
31  				return encodeRequest(channel, (Request) message);
32  			} else if (message instanceof Response) {
33  				return encodeResponse(channel, (Response) message);
34  			}
35  		} catch (Exception e) {
36  			if (ExceptionUtil.isMotanException(e)) {
37  				throw (RuntimeException) e;
38  			} else {
39  				throw new MotanFrameworkException("encode error: isResponse=" + (message instanceof Response), e,
40  						MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
41  			}
42  		}
43  		throw new MotanFrameworkException("encode error: message type not support, " + message.getClass(),
44  				MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
45  	}
46  	private byte[] encodeRequest(Channel channel, Request request) throws IOException {
47  		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
48  		CodedOutputStream output = CodedOutputStream.newInstance(outputStream);
49  		output.writeStringNoTag(request.getInterfaceName());
50  		output.writeStringNoTag(request.getMethodName());
51  		output.writeStringNoTag(request.getParamtersDesc());
52  		Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
53  				channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
54  		if (request.getArguments() != null && request.getArguments().length > 0) {
55  			for (Object obj : request.getArguments()) {
56  				output.writeByteArrayNoTag(serialization.serialize(obj));
57  			}
58  		}
59  		if (request.getAttachments() == null || request.getAttachments().isEmpty()) {
60  			output.writeUInt32NoTag(0);
61  		} else {
62  			output.writeUInt32NoTag(request.getAttachments().size());
63  			for (Map.Entry<String, String> entry : request.getAttachments().entrySet()) {
64  				output.writeStringNoTag(entry.getKey());
65  				output.writeStringNoTag(entry.getValue());
66  			}
67  		}
68  		output.flush();
69  		byte[] body = outputStream.toByteArray();
70  		byte flag = MotanConstants.FLAG_REQUEST;
71  		return encode(body, flag, request.getRequestId());
72  	}
73  	private byte[] encodeResponse(Channel channel, Response value) throws IOException {
74  		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
75  		CodedOutputStream output = CodedOutputStream.newInstance(outputStream);
76  		Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
77  				channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
78  		byte flag = 0;
79  		output.writeUInt64NoTag(value.getProcessTime());
80  		if (value.getException() != null) {
81  			output.writeStringNoTag(value.getException().getClass().getName());
82  			output.writeByteArrayNoTag(serialization.serialize(value.getException()));
83  			flag = MotanConstants.FLAG_RESPONSE_EXCEPTION;
84  		} else if (value.getValue() == null) {
85  			flag = MotanConstants.FLAG_RESPONSE_VOID;
86  		} else {
87  			output.writeStringNoTag(value.getValue().getClass().getName());
88  			output.writeByteArrayNoTag(serialization.serialize(value.getValue()));
89  			flag = MotanConstants.FLAG_RESPONSE;
90  		}
91  		output.flush();
92  		byte[] body = outputStream.toByteArray();
93  		return encode(body, flag, value.getRequestId());
94  	}
95  	@Override
96  	public Object decode(Channel channel, String remoteIp, byte[] data) throws IOException {
97  		if (data.length <= RpcProtocolVersion.VERSION_1.getHeaderLength()) {
<span onclick='openModal()' class='match'>98  			throw new MotanFrameworkException("decode error: format problem",
99  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
100  		}
101  		short type = ByteUtil.bytes2short(data, 0);
102  		if (type != MAGIC) {
103  			throw new MotanFrameworkException("decode error: magic error",
104  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
105  		}
106  		if (data[2] != RpcProtocolVersion.VERSION_1.getVersion()) {
</span>107  			throw new MotanFrameworkException("decode error: version error",
108  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
109  		}
110  		int bodyLength = ByteUtil.bytes2int(data, 12);
111  		if (RpcProtocolVersion.VERSION_1.getHeaderLength() + bodyLength != data.length) {
112  			throw new MotanFrameworkException("decode error: content length error",
113  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
114  		}
115  		byte flag = data[3];
116  		byte dataType = (byte) (flag & MASK);
117  		boolean isResponse = (dataType != MotanConstants.FLAG_REQUEST);
118  		CodedInputStream body = CodedInputStream.newInstance(data, RpcProtocolVersion.VERSION_1.getHeaderLength(),
119  				bodyLength);
120  		long requestId = ByteUtil.bytes2long(data, 4);
121  		Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
122  				channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
123  		try {
124  			if (isResponse) { 
125  				return decodeResponse(body, dataType, requestId, serialization);
126  			} else {
127  				return decodeRequest(body, requestId, serialization);
128  			}
129  		} catch (ClassNotFoundException e) {
130  			throw new MotanFrameworkException(
131  					"decode " + (isResponse ? "response" : "request") + " error: class not found", e,
132  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
133  		} catch (Exception e) {
134  			if (ExceptionUtil.isMotanException(e)) {
135  				throw (RuntimeException) e;
136  			} else {
137  				throw new MotanFrameworkException("decode error: isResponse=" + isResponse, e,
138  						MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
139  			}
140  		}
141  	}
142  	private Object decodeRequest(CodedInputStream input, long requestId, Serialization serialization)
143  			throws IOException, ClassNotFoundException {
144  		String interfaceName = input.readString();
145  		String methodName = input.readString();
146  		String paramtersDesc = input.readString();
147  		DefaultRequest rpcRequest = new DefaultRequest();
148  		rpcRequest.setRequestId(requestId);
149  		rpcRequest.setInterfaceName(interfaceName);
150  		rpcRequest.setMethodName(methodName);
151  		rpcRequest.setParamtersDesc(paramtersDesc);
152  		rpcRequest.setArguments(decodeRequestParameter(input, paramtersDesc, serialization));
153  		rpcRequest.setAttachments(decodeRequestAttachments(input));
154  		return rpcRequest;
155  	}
156  	private Object[] decodeRequestParameter(CodedInputStream input, String parameterDesc, Serialization serialization)
157  			throws IOException, ClassNotFoundException {
158  		if (parameterDesc == null || parameterDesc.equals("")) {
159  			return null;
160  		}
161  		Class<?>[] classTypes = ReflectUtil.forNames(parameterDesc);
162  		Object[] paramObjs = new Object[classTypes.length];
163  		for (int i = 0; i < classTypes.length; i++) {
164  			paramObjs[i] = serialization.deserialize(input.readByteArray(), classTypes[i]);
165  		}
166  		return paramObjs;
167  	}
168  	private Map<String, String> decodeRequestAttachments(CodedInputStream input)
169  			throws IOException, ClassNotFoundException {
170  		int size = input.readUInt32();
171  		if (size <= 0) {
172  			return null;
173  		}
174  		Map<String, String> attachments = new HashMap<String, String>();
175  		for (int i = 0; i < size; i++) {
176  			attachments.put(input.readString(), input.readString());
177  		}
178  		return attachments;
179  	}
180  	private Object decodeResponse(CodedInputStream input, byte dataType, long requestId, Serialization serialization)
181  			throws IOException, ClassNotFoundException {
182  		long processTime = input.readInt64();
183  		DefaultResponse response = new DefaultResponse();
184  		response.setRequestId(requestId);
185  		response.setProcessTime(processTime);
186  		if (dataType == MotanConstants.FLAG_RESPONSE_VOID) {
187  			return response;
188  		}
189  		String className = input.readString();
190  		Class<?> clz = ReflectUtil.forName(className);
191  		Object result = serialization.deserialize(input.readByteArray(), clz);
192  		if (dataType == MotanConstants.FLAG_RESPONSE) {
193  			response.setValue(result);
194  		} else if (dataType == MotanConstants.FLAG_RESPONSE_EXCEPTION) {
195  			response.setException((Exception) result);
196  		} else {
197  			throw new MotanFrameworkException("decode error: response dataType not support " + dataType,
198  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
199  		}
200  		response.setRequestId(requestId);
201  		return response;
202  	}
203  	private byte[] encode(byte[] body, byte flag, long requestId) throws IOException {
204  		byte[] header = new byte[RpcProtocolVersion.VERSION_1.getHeaderLength()];
205  		int offset = 0;
206  		ByteUtil.short2bytes(MAGIC, header, offset);
207  		offset += 2;
208  		header[offset++] = RpcProtocolVersion.VERSION_1.getVersion();
209  		header[offset++] = flag;
210  		ByteUtil.long2bytes(requestId, header, offset);
211  		offset += 8;
212  		ByteUtil.int2bytes(body.length, header, offset);
213  		byte[] data = new byte[header.length + body.length];
214  		System.arraycopy(header, 0, data, 0, header.length);
215  		System.arraycopy(body, 0, data, header.length, body.length);
216  		return data;
217  	}
218  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-CompressRpcCodec.java</h3>
            <pre><code>1  package com.weibo.api.motan.protocol.rpc;
2  import com.weibo.api.motan.codec.AbstractCodec;
3  import com.weibo.api.motan.codec.Serialization;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.common.URLParamType;
6  import com.weibo.api.motan.core.extension.ExtensionLoader;
7  import com.weibo.api.motan.core.extension.SpiMeta;
8  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
9  import com.weibo.api.motan.exception.MotanFrameworkException;
10  import com.weibo.api.motan.rpc.*;
11  import com.weibo.api.motan.transport.Channel;
12  import com.weibo.api.motan.transport.support.DefaultRpcHeartbeatFactory;
13  import com.weibo.api.motan.util.*;
14  import org.apache.commons.lang3.StringUtils;
15  import java.io.*;
16  import java.lang.reflect.Method;
17  import java.util.HashMap;
18  import java.util.List;
19  import java.util.Map;
20  import java.util.concurrent.ConcurrentHashMap;
21  import java.util.zip.GZIPInputStream;
22  import java.util.zip.GZIPOutputStream;
23  @Deprecated
24  @SpiMeta(name = "compressMotan")
25  public class CompressRpcCodec extends AbstractCodec {
26      private static final short MAGIC = (short) 0xF0F0;
27      private static final byte MASK = 0x07;
28      private static ConcurrentHashMap<String, MethodInfo> SIGN_METHOD_MAP = new ConcurrentHashMap<String, MethodInfo>();
29      private static ConcurrentHashMap<String, String> METHOD_SIGN_MAP = new ConcurrentHashMap<String, String>();
30      private static ConcurrentHashMap<String, AttachmentInfo> SIGN_ATTACHMENT_MAP = new ConcurrentHashMap<String, AttachmentInfo>();
31      private static ConcurrentHashSet<String> ACCEPT_ATTACHMENT_SIGN = new ConcurrentHashSet<String>();
32      private static final String SIGN_FLAG = "1";
33      private static final String ATTACHMENT_SIGN = "_A";
34      private static final String UN_ATTACHMENT_SIGN = "_UA";
35      private static final String CLIENT_REQUESTID = "_RID";
36      public static final String CODEC_VERSION_SWITCHER = "feature.motanrpc.codecversion.degrade";
37      public static final String GROUP_CODEC_VERSION_SWITCHER = "feature.motanrpc.codecversion.groupdegrade.";
38      private DefaultRpcCodec v1Codec = new DefaultRpcCodec();
39      static {
40          LoggerUtil.info("init compress codec");
41          MotanSwitcherUtil.initSwitcher(CODEC_VERSION_SWITCHER, false);
42      }
43      @Override
44      public byte[] encode(Channel channel, Object message) throws IOException {
45          if (needEncodeV1(message)) {
46              return v1Codec.encode(channel, message);
47          } else {
48              return encodeV2(channel, message);
49          }
50      }
51      private boolean needEncodeV1(Object message) {
52          if (MotanSwitcherUtil.isOpen(CODEC_VERSION_SWITCHER)) {
53              return true;
54          }
55          if (message instanceof Request) {
56              if (DefaultRpcHeartbeatFactory.isHeartbeatRequest(message)) {
57                  return true;
58              }
59              String group = MotanFrameworkUtil.getGroupFromRequest((Request) message);
60              if (MotanSwitcherUtil.switcherIsOpenWithDefault(GROUP_CODEC_VERSION_SWITCHER + group, false)) {
61                  return true;
62              }
63          }
64          return message instanceof Response && ((Response) message).getRpcProtocolVersion() == RpcProtocolVersion.VERSION_1.getVersion();
65      }
66      @Override
67      public Object decode(Channel channel, String remoteIp, byte[] data) throws IOException {
68          if (MotanSwitcherUtil.isOpen(CODEC_VERSION_SWITCHER)) {
69              return v1Codec.decode(channel, remoteIp, data);
70          } else {
71              if (data.length <= 3) {
72                  throw new MotanFrameworkException("decode error: format problem", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
73              }
74              if (data[2] == RpcProtocolVersion.VERSION_1.getVersion()) {
75                  return v1Codec.decode(channel, remoteIp, data);
76              } else if (data[2] == RpcProtocolVersion.VERSION_1_Compress.getVersion()) {
77                  return decodeV2(channel, remoteIp, data);
78              } else {
79                  throw new MotanFrameworkException("decode error: version error. version=" + data[2],
80                          MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
81              }
82          }
83      }
84      public byte[] encodeV2(Channel channel, Object message) throws IOException {
85          try {
86              if (message instanceof Request) {
87                  return encodeRequest(channel, (Request) message);
88              } else if (message instanceof Response) {
89                  return encodeResponse(channel, (Response) message);
90              }
91          } catch (Exception e) {
92              if (ExceptionUtil.isMotanException(e)) {
93                  throw (RuntimeException) e;
94              } else {
95                  throw new MotanFrameworkException("encode error: isResponse=" + (message instanceof Response), e,
96                          MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
97              }
98          }
99          throw new MotanFrameworkException("encode error: message type not support, " + message.getClass(),
100                  MotanErrorMsgConstant.FRAMEWORK_ENCODE_ERROR);
101      }
102      public Object decodeV2(Channel channel, String remoteIp, byte[] data) throws IOException {
103          if (data.length <= RpcProtocolVersion.VERSION_1_Compress.getHeaderLength()) {
<span onclick='openModal()' class='match'>104              throw new MotanFrameworkException("decode error: format problem", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
105          }
106          short type = ByteUtil.bytes2short(data, 0);
107          if (type != MAGIC) {
108              throw new MotanFrameworkException("decode error: magic error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
109          }
110          int bodyLength = ByteUtil.bytes2int(data, 12);
</span>111          if (RpcProtocolVersion.VERSION_1_Compress.getHeaderLength() + bodyLength != data.length) {
112              throw new MotanFrameworkException("decode error: content length error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
113          }
114          byte flag = data[3];
115          byte dataType = (byte) (flag & MASK);
116          boolean isResponse = (dataType != MotanConstants.FLAG_REQUEST);
117          byte[] body = new byte[bodyLength];
118          System.arraycopy(data, RpcProtocolVersion.VERSION_1.getHeaderLength(), body, 0, bodyLength);
119          long requestId = ByteUtil.bytes2long(data, 4);
120          Serialization serialization =
121                  ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
122                          channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
123          try {
124              if (isResponse) {
125                  return decodeResponse(body, dataType, requestId, data[2], serialization);
126              } else {
127                  return decodeRequest(body, requestId, remoteIp, serialization);
128              }
129          } catch (ClassNotFoundException e) {
130              throw new MotanFrameworkException("decode " + (isResponse ? "response" : "request") + " error: class not found", e,
131                      MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
132          } catch (Exception e) {
133              if (ExceptionUtil.isMotanException(e)) {
134                  throw (RuntimeException) e;
135              } else {
136                  throw new MotanFrameworkException("decode error: isResponse=" + isResponse, e, MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
137              }
138          }
139      }
140      private byte[] encodeRequest(Channel channel, Request request) throws IOException {
141          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
142          ObjectOutput output = createOutput(outputStream);
143          addMethodInfo(output, request);
144          Serialization serialization =
145                  ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
146                          channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
147          if (request.getArguments() != null && request.getArguments().length > 0) {
148              for (Object obj : request.getArguments()) {
149                  serialize(output, obj, serialization);
150              }
151          }
152          if (request.getAttachments() == null || request.getAttachments().isEmpty()) {
153              output.writeShort(0);
154          } else {
155              Map<String, String> attachments = copyMap(request.getAttachments());
156              replaceAttachmentParamsBySign(channel, attachments);
157              addAttachment(output, attachments);
158          }
159          output.flush();
160          byte[] body = outputStream.toByteArray();
161          byte flag = MotanConstants.FLAG_REQUEST;
162          output.close();
163          int minGzSize = channel.getUrl().getIntParameter(URLParamType.mingzSize.getName(), 0);
164          return encode(compress(body, minGzSize), flag, request.getRequestId());
165      }
166      private Map<String, String> copyMap(Map<String, String> attachments) {
167          Map<String, String> resultMap = new HashMap<String, String>();
168          for (Map.Entry<String, String> entry : attachments.entrySet()) {
169              resultMap.put(entry.getKey(), entry.getValue());
170          }
171          return resultMap;
172      }
173      private void addMethodInfo(ObjectOutput output, Request request) throws IOException {
174          String methodInfoStr = MotanFrameworkUtil.getServiceKey(request) + request.getMethodName() + request.getParamtersDesc();
175          String methodSign = METHOD_SIGN_MAP.get(methodInfoStr);
176          if (methodSign == null) {
177              MethodInfo temp =
178                      new MethodInfo(MotanFrameworkUtil.getGroupFromRequest(request), request.getInterfaceName(), request.getMethodName(),
179                              request.getParamtersDesc(), MotanFrameworkUtil.getVersionFromRequest(request));
180              try {
181                  methodSign = temp.getSign();
182                  METHOD_SIGN_MAP.putIfAbsent(methodInfoStr, methodSign);
183                  LoggerUtil.info("add method sign:" + methodSign + ", methodinfo:" + temp.toString());
184              } catch (Exception e) {
185                  LoggerUtil.warn("gen method sign fail!" + e.getMessage());
186              }
187          }
188          if (methodSign != null) {
189              output.writeUTF(SIGN_FLAG);
190              output.writeUTF(methodSign);
191          } else {
192              output.writeUTF(request.getInterfaceName());
193              output.writeUTF(request.getMethodName());
194              output.writeUTF(request.getParamtersDesc());
195          }
196      }
197      private void replaceAttachmentParamsBySign(Channel channel, Map<String, String> attachments) {
198          AttachmentInfo info = getAttachmentInfoMap(attachments);
199          if (info != null) {
200              String sign = info.getAttachmentSign();
201              if (sign != null) {
202                  attachments.put(ATTACHMENT_SIGN, sign);
203                  if (ACCEPT_ATTACHMENT_SIGN.contains(sign)) {
204                      removeAttachmentInfoMap(attachments);
205                  }
206              }
207          }
208          String clientRequestid = attachments.get(URLParamType.requestIdFromClient.getName());
209          if (clientRequestid != null && !URLParamType.requestIdFromClient.getValue().equals(clientRequestid)) {
210              attachments.put(CLIENT_REQUESTID, clientRequestid);
211          }
212          attachments.remove(URLParamType.requestIdFromClient.getName());
213      }
214      private void addAttachment(ObjectOutput output, Map<String, String> attachments) throws IOException {
215          output.writeShort(attachments.size());
216          for (Map.Entry<String, String> entry : attachments.entrySet()) {
217              output.writeUTF(entry.getKey());
218              output.writeUTF(entry.getValue());
219          }
220      }
221      private byte[] encodeResponse(Channel channel, Response value) throws IOException {
222          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
223          ObjectOutput output = createOutput(outputStream);
224          Serialization serialization =
225                  ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(
226                          channel.getUrl().getParameter(URLParamType.serialize.getName(), URLParamType.serialize.getValue()));
227          byte flag = 0;
228          output.writeLong(value.getProcessTime());
229          if (value.getException() != null) {
230              output.writeUTF(value.getException().getClass().getName());
231              serialize(output, value.getException(), serialization);
232              flag = MotanConstants.FLAG_RESPONSE_EXCEPTION;
233          } else if (value.getValue() == null) {
234              flag = MotanConstants.FLAG_RESPONSE_VOID;
235          } else {
236              output.writeUTF(value.getValue().getClass().getName());
237              serialize(output, value.getValue(), serialization);
238              Map<String, String> attachments = value.getAttachments();
239              Map<String, String> responseAttachments = new HashMap<>();
240              if (attachments != null) {
241                  String signed = attachments.get(ATTACHMENT_SIGN);
242                  String unSigned = attachments.get(UN_ATTACHMENT_SIGN);
243                  if (StringUtils.isNotBlank(signed)) {
244                      responseAttachments.put(ATTACHMENT_SIGN, signed);
245                  }
246                  if (StringUtils.isNotBlank(unSigned)) {
247                      responseAttachments.put(UN_ATTACHMENT_SIGN, unSigned);
248                  }
249              }
250              if (!responseAttachments.isEmpty()) {
251                  addAttachment(output, responseAttachments);
252              } else {
253                  output.writeShort(0);
254              }
255              flag = MotanConstants.FLAG_RESPONSE_ATTACHMENT; 
256          }
257          output.flush();
258          byte[] body = outputStream.toByteArray();
259          output.close();
260          int minGzSize = channel.getUrl().getIntParameter(URLParamType.mingzSize.getName(), 0);
261          return encode(compress(body, minGzSize), flag, value.getRequestId());
262      }
263      private byte[] encode(byte[] body, byte flag, long requestId) throws IOException {
264          byte[] header = new byte[RpcProtocolVersion.VERSION_1_Compress.getHeaderLength()];
265          int offset = 0;
266          ByteUtil.short2bytes(MAGIC, header, offset);
267          offset += 2;
268          header[offset++] = RpcProtocolVersion.VERSION_1_Compress.getVersion();
269          header[offset++] = flag;
270          ByteUtil.long2bytes(requestId, header, offset);
271          offset += 8;
272          ByteUtil.int2bytes(body.length, header, offset);
273          byte[] data = new byte[header.length + body.length];
274          System.arraycopy(header, 0, data, 0, header.length);
275          System.arraycopy(body, 0, data, header.length, body.length);
276          return data;
277      }
278      private Object decodeRequest(byte[] body, long requestId, String remoteIp, Serialization serialization) throws IOException,
279              ClassNotFoundException {
280          ObjectInput input = createInput(getInputStream(body));
281          String interfaceName = null;
282          String methodName = null;
283          String paramtersDesc = null;
284          String group = null;
285          String version = null;
286          String flag = input.readUTF();
287          if (SIGN_FLAG.equals(flag)) {
288              String sign = input.readUTF();
289              MethodInfo mInfo = SIGN_METHOD_MAP.get(sign);
290              if (mInfo == null) {
291                  throw new MotanFrameworkException("decode error: invalid method sign: " + sign + ", serverIp: " + NetUtils.getLocalAddress().getHostAddress(),
292                          MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
293              }
294              interfaceName = mInfo.getInterfaceName();
295              methodName = mInfo.getMethodName();
296              paramtersDesc = mInfo.getParamtersDesc();
297              group = mInfo.getGroup();
298              version = mInfo.getVersion();
299          } else {
300              interfaceName = flag;
301              methodName = input.readUTF();
302              paramtersDesc = input.readUTF();
303          }
304          DefaultRequest rpcRequest = new DefaultRequest();
305          rpcRequest.setRequestId(requestId);
306          rpcRequest.setInterfaceName(interfaceName);
307          rpcRequest.setMethodName(methodName);
308          rpcRequest.setParamtersDesc(paramtersDesc);
309          rpcRequest.setArguments(decodeRequestParameter(input, paramtersDesc, serialization));
310          rpcRequest.setAttachments(decodeRequestAttachments(input));
311          rpcRequest.setRpcProtocolVersion(RpcProtocolVersion.VERSION_1_Compress.getVersion());
312          input.close();
313          Map<String, String> attachments = rpcRequest.getAttachments();
314          putSignedAttachment(attachments, remoteIp);
315          if (attachments.get(URLParamType.group.name()) == null) {
316              attachments.put(URLParamType.group.name(), group);
317              attachments.put(URLParamType.version.name(), version);
318          }
319          return rpcRequest;
320      }
321      private void putSignedAttachment(Map<String, String> attachments, String remoteIp) {
322          if (attachments != null && !attachments.isEmpty()) {
323              AttachmentInfo info = getAttachmentInfoMap(attachments);
324              if (info != null) {
325                  String sign = attachments.get(ATTACHMENT_SIGN);
326                  if (StringUtils.isNotBlank(sign)) {
327                      SIGN_ATTACHMENT_MAP.put(remoteIp + sign, info);
328                      LoggerUtil.info("update attachment sign:" + remoteIp + sign + ", info-group:" + info.getGroup());
329                  }
330              } else {
331                  String sign = attachments.get(ATTACHMENT_SIGN);
332                  if (StringUtils.isNotBlank(sign)) {
333                      info = SIGN_ATTACHMENT_MAP.get(remoteIp + sign);
334                      if (info != null) {
335                          putAttachmentInfoMap(info, attachments);
336                      } else {
337                          attachments.put(UN_ATTACHMENT_SIGN, sign);
338                          LoggerUtil.info("miss attachment sign:" + remoteIp + sign);
339                      }
340                      attachments.remove(ATTACHMENT_SIGN);
341                  } else {
342                      LoggerUtil.warn("attachment sign is blank，application info miss!");
343                  }
344              }
345              String clientRequestid = URLParamType.requestIdFromClient.getValue();
346              if (attachments.containsKey(CLIENT_REQUESTID)) {
347                  clientRequestid = attachments.get(CLIENT_REQUESTID);
348              }
349              attachments.put(URLParamType.requestIdFromClient.getName(), clientRequestid);
350          }
351      }
352      private Object[] decodeRequestParameter(ObjectInput input, String parameterDesc, Serialization serialization) throws IOException,
353              ClassNotFoundException {
354          if (parameterDesc == null || parameterDesc.equals("")) {
355              return null;
356          }
357          Class<?>[] classTypes = ReflectUtil.forNames(parameterDesc);
358          Object[] paramObjs = new Object[classTypes.length];
359          for (int i = 0; i < classTypes.length; i++) {
360              paramObjs[i] = deserialize((byte[]) input.readObject(), classTypes[i], serialization);
361          }
362          return paramObjs;
363      }
364      private Map<String, String> decodeRequestAttachments(ObjectInput input) throws IOException, ClassNotFoundException {
365          int size = input.readShort();
366          if (size <= 0) {
367              return null;
368          }
369          Map<String, String> attachments = new HashMap<String, String>();
370          for (int i = 0; i < size; i++) {
371              attachments.put(input.readUTF(), input.readUTF());
372          }
373          return attachments;
374      }
375      private Object decodeResponse(byte[] body, byte dataType, long requestId, byte rpcProtocolVersion, Serialization serialization)
376              throws IOException, ClassNotFoundException {
377          ObjectInput input = createInput(getInputStream(body));
378          long processTime = input.readLong();
379          DefaultResponse response = new DefaultResponse();
380          response.setRequestId(requestId);
381          response.setProcessTime(processTime);
382          if (dataType == MotanConstants.FLAG_RESPONSE_VOID) {
383              return response;
384          }
385          String className = input.readUTF();
386          Class<?> clz = ReflectUtil.forName(className);
387          Object result = deserialize((byte[]) input.readObject(), clz, serialization);
388          if (dataType == MotanConstants.FLAG_RESPONSE) {
389              response.setValue(result);
390          } else if (dataType == MotanConstants.FLAG_RESPONSE_ATTACHMENT) {
391              response.setValue(result);
392              Map<String, String> attachment = decodeRequestAttachments(input);
393              checkAttachment(attachment);
394          } else if (dataType == MotanConstants.FLAG_RESPONSE_EXCEPTION) {
395              response.setException((Exception) result);
396          } else {
397              throw new MotanFrameworkException("decode error: response dataType not support " + dataType,
398                      MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
399          }
400          response.setRequestId(requestId);
401          input.close();
402          return response;
403      }
404      private void checkAttachment(Map<String, String> attachment) {
405          if (attachment != null && !attachment.isEmpty()) {
406              String acceptSign = attachment.get(ATTACHMENT_SIGN);
407              if (StringUtils.isNotBlank(acceptSign)) {
408                  ACCEPT_ATTACHMENT_SIGN.add(acceptSign);
409              }
410              String notAcceptSign = attachment.get(UN_ATTACHMENT_SIGN);
411              if (StringUtils.isNotBlank(notAcceptSign)) {
412                  ACCEPT_ATTACHMENT_SIGN.remove(notAcceptSign);
413              }
414          }
415      }
416      private AttachmentInfo getAttachmentInfoMap(Map<String, String> attachments) {
417          AttachmentInfo result = null;
418          if (attachments != null && attachments.containsKey(URLParamType.application.name())) {
419              String group = attachments.get(URLParamType.group.name());
420              String application = attachments.get(URLParamType.application.name());
421              String module = attachments.get(URLParamType.module.name());
422              String version = attachments.get(URLParamType.version.name());
423              result = new AttachmentInfo(group, application, module, version);
424          }
425          return result;
426      }
427      private void putAttachmentInfoMap(AttachmentInfo attachmentInfo, Map<String, String> attachments) {
428          if (attachments != null) {
429              attachments.put(URLParamType.group.name(), attachmentInfo.getGroup());
430              attachments.put(URLParamType.application.name(), attachmentInfo.getApplication());
431              attachments.put(URLParamType.module.name(), attachmentInfo.getModule());
432              attachments.put(URLParamType.version.name(), attachmentInfo.getVersion());
433          }
434      }
435      private void removeAttachmentInfoMap(Map<String, String> attachments) {
436          if (attachments != null) {
437              attachments.remove(URLParamType.group.name());
438              attachments.remove(URLParamType.module.name());
439              attachments.remove(URLParamType.version.name());
440          }
441      }
442      public static InputStream getInputStream(byte[] data) {
443          if (isGzipData(data)) {
444              try {
445                  return new GZIPInputStream(new ByteArrayInputStream(data));
446              } catch (Exception ignore) {
447              }
448          }
449          return new ByteArrayInputStream(data);
450      }
451      private static boolean isGzipData(byte[] data) {
452          if (data.length > 2) {
453              int header = (int) (((data[0] & 0xff)) | (data[1] & 0xff) << 8);
454              if (GZIPInputStream.GZIP_MAGIC == header) {
455                  return true;
456              }
457          }
458          return false;
459      }
460      public byte[] compress(byte[] org, int minGzSize) throws IOException {
461          if (minGzSize > 0 && org.length > minGzSize) {
462              ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
463              GZIPOutputStream gos = new GZIPOutputStream(outputStream);
464              gos.write(org);
465              gos.finish();
466              gos.flush();
467              gos.close();
468              byte[] ret = outputStream.toByteArray();
469              return ret;
470          } else {
471              return org;
472          }
473      }
474      public static void putMethodSign(Provider<?> provider, List<Method> methods) {
475          String group = provider.getUrl().getGroup();
476          String interfaceName = provider.getInterface().getName();
477          String version = provider.getUrl().getVersion();
478          for (Method method : methods) {
479              MethodInfo temp = new MethodInfo(group, interfaceName, method.getName(), ReflectUtil.getMethodParamDesc(method), version);
480              String sign = temp.getSign();
481              MethodInfo priInfo = SIGN_METHOD_MAP.putIfAbsent(sign, temp);
482              if (priInfo != null && !temp.equals(priInfo)) {
483                  throw new MotanFrameworkException("add method sign conflict! " + temp.toString() + " with " + priInfo.toString(),
484                          MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
485              } else {
486                  LoggerUtil.info("add method sign:" + sign + ", methodinfo:" + temp.toString());
487              }
488          }
489      }
490      public static void putMethodSign(String methodSign, MethodInfo methodInfo) {
491          SIGN_METHOD_MAP.putIfAbsent(methodSign, methodInfo);
492      }
493      static class MethodInfo {
494          String group;
495          String interfaceName;
496          String methodName;
497          String paramtersDesc;
498          String version;
499          public MethodInfo(String group, String interfaceName, String methodName, String paramtersDesc, String version) {
500              super();
501              this.group = group;
502              this.interfaceName = interfaceName;
503              this.methodName = methodName;
504              this.paramtersDesc = paramtersDesc;
505              this.version = version;
506          }
507          public String getSign() {
508              try {
509                  StringBuilder sb = new StringBuilder();
510                  sb.append(group).append(interfaceName).append(methodName).append(paramtersDesc).append(version);
511                  String surfix = MotanDigestUtil.md5LowerCase(sb.toString()).substring(8, 20); 
512                  int endIndex = methodName.length() > 4 ? 4 : methodName.length();
513                  String prefix = methodName.substring(0, endIndex);
514                  return prefix + surfix;
515              } catch (Exception e) {
516                  throw new MotanFrameworkException("gen method sign error! " + this.toString(), MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
517              }
518          }
519          public String getGroup() {
520              return group;
521          }
522          public void setGroup(String group) {
523              this.group = group;
524          }
525          public String getInterfaceName() {
526              return interfaceName;
527          }
528          public void setInterfaceName(String interfaceName) {
529              this.interfaceName = interfaceName;
530          }
531          public String getMethodName() {
532              return methodName;
533          }
534          public void setMethodName(String methodName) {
535              this.methodName = methodName;
536          }
537          public String getParamtersDesc() {
538              return paramtersDesc;
539          }
540          public void setParamtersDesc(String paramtersDesc) {
541              this.paramtersDesc = paramtersDesc;
542          }
543          public String getVersion() {
544              return version;
545          }
546          public void setVersion(String version) {
547              this.version = version;
548          }
549          @Override
550          public int hashCode() {
551              final int prime = 31;
552              int result = 1;
553              result = prime * result + ((group == null) ? 0 : group.hashCode());
554              result = prime * result + ((interfaceName == null) ? 0 : interfaceName.hashCode());
555              result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());
556              result = prime * result + ((paramtersDesc == null) ? 0 : paramtersDesc.hashCode());
557              result = prime * result + ((version == null) ? 0 : version.hashCode());
558              return result;
559          }
560          @Override
561          public boolean equals(Object obj) {
562              if (this == obj) return true;
563              if (obj == null) return false;
564              if (getClass() != obj.getClass()) return false;
565              MethodInfo other = (MethodInfo) obj;
566              if (group == null) {
567                  if (other.group != null) return false;
568              } else if (!group.equals(other.group)) return false;
569              if (interfaceName == null) {
570                  if (other.interfaceName != null) return false;
571              } else if (!interfaceName.equals(other.interfaceName)) return false;
572              if (methodName == null) {
573                  if (other.methodName != null) return false;
574              } else if (!methodName.equals(other.methodName)) return false;
575              if (paramtersDesc == null) {
576                  if (other.paramtersDesc != null) return false;
577              } else if (!paramtersDesc.equals(other.paramtersDesc)) return false;
578              if (version == null) {
579                  if (other.version != null) return false;
580              } else if (!version.equals(other.version)) return false;
581              return true;
582          }
583          @Override
584          public String toString() {
585              return "MethodInfo [group=" + group + ", interfaceName=" + interfaceName + ", methodName=" + methodName + ", paramtersDesc="
586                      + paramtersDesc + ", version=" + version + "]";
587          }
588      }
589      static class AttachmentInfo {
590          String group;
591          String application;
592          String module;
593          String version;
594          public AttachmentInfo(String group, String application, String module, String version) {
595              super();
596              this.group = group;
597              this.application = application;
598              this.module = module;
599              this.version = version;
600          }
601          public String getAttachmentSign() {
602              String signstr = group + application + module + version;
603              String hashcodeStr = null;
604              try {
605                  hashcodeStr = MotanDigestUtil.md5LowerCase(signstr).substring(8, 12); 
606              } catch (Exception e) {
607                  LoggerUtil.warn("getAttachmentSign fail!" + e.getMessage());
608              }
609              return hashcodeStr;
610          }
611          public String getGroup() {
612              return group;
613          }
614          public String getApplication() {
615              return application;
616          }
617          public String getModule() {
618              return module;
619          }
620          public String getVersion() {
621              return version;
622          }
623      }
624  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ProtobufCodec.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-CompressRpcCodec.java</div>
                </div>
                <div class="column column_space"><pre><code>98  			throw new MotanFrameworkException("decode error: format problem",
99  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
100  		}
101  		short type = ByteUtil.bytes2short(data, 0);
102  		if (type != MAGIC) {
103  			throw new MotanFrameworkException("decode error: magic error",
104  					MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
105  		}
106  		if (data[2] != RpcProtocolVersion.VERSION_1.getVersion()) {
</pre></code></div>
                <div class="column column_space"><pre><code>104              throw new MotanFrameworkException("decode error: format problem", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
105          }
106          short type = ByteUtil.bytes2short(data, 0);
107          if (type != MAGIC) {
108              throw new MotanFrameworkException("decode error: magic error", MotanErrorMsgConstant.FRAMEWORK_DECODE_ERROR);
109          }
110          int bodyLength = ByteUtil.bytes2int(data, 12);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    