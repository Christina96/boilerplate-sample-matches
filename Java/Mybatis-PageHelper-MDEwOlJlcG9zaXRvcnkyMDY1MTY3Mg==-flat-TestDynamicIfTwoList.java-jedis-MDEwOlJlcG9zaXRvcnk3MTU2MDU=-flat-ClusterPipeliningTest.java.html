
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.7573805689747717%, Tokens: 13</h2>
        <div class="column">
            <h3>Mybatis-PageHelper-MDEwOlJlcG9zaXRvcnkyMDY1MTY3Mg==-flat-TestDynamicIfTwoList.java</h3>
            <pre><code>1  package com.github.pagehelper.test.basic.dynamic;
2  import com.github.pagehelper.Page;
3  import com.github.pagehelper.PageHelper;
4  import com.github.pagehelper.mapper.UserMapper;
5  import com.github.pagehelper.model.User;
6  import com.github.pagehelper.util.MybatisHelper;
7  import org.apache.ibatis.session.SqlSession;
8  import org.junit.Test;
9  import java.util.ArrayList;
10  import java.util.Arrays;
11  import java.util.List;
12  import static org.junit.Assert.assertEquals;
13  public class TestDynamicIfTwoList {
14      @Test
15      public void testMapperWithStartPage() {
16          SqlSession sqlSession = MybatisHelper.getSqlSession();
17          UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
18          try {
<span onclick='openModal()' class='match'>19              PageHelper.startPage(1, 10);
20              List<User> list = userMapper.selectIf2List(Arrays.asList(1, 2), Arrays.asList(3, 4));
21              assertEquals(5, list.get(0).getId());
22              assertEquals(10, list.size());
23              assertEquals(179, ((Page<?>) list).getTotal());
24              PageHelper.startPage(1, 10);
</span>25              list = userMapper.selectIf2List(Arrays.asList(1, 2), null);
26              assertEquals(3, list.get(0).getId());
27              assertEquals(10, list.size());
28              assertEquals(181, ((Page<?>) list).getTotal());
29              PageHelper.startPage(1, 10);
30              list = userMapper.selectIf2List(new ArrayList<Integer>(0), null);
31              assertEquals(1, list.get(0).getId());
32              assertEquals(10, list.size());
33              assertEquals(183, ((Page<?>) list).getTotal());
34          } finally {
35              sqlSession.close();
36          }
37      }
38  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterPipeliningTest.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static org.junit.Assert.*;
3  import static redis.clients.jedis.Protocol.CLUSTER_HASHSLOTS;
4  import java.util.*;
5  import org.hamcrest.MatcherAssert;
6  import org.hamcrest.Matchers;
7  import org.junit.After;
8  import org.junit.AfterClass;
9  import org.junit.Before;
10  import org.junit.Test;
11  import redis.clients.jedis.args.*;
12  import redis.clients.jedis.exceptions.JedisDataException;
13  import redis.clients.jedis.params.*;
14  import redis.clients.jedis.providers.ClusterConnectionProvider;
15  import redis.clients.jedis.resps.GeoRadiusResponse;
16  import redis.clients.jedis.resps.StreamEntry;
17  import redis.clients.jedis.resps.Tuple;
18  import redis.clients.jedis.util.AssertUtil;
19  import redis.clients.jedis.util.JedisClusterTestUtil;
20  import redis.clients.jedis.util.SafeEncoder;
21  public class ClusterPipeliningTest {
22    private static final String LOCAL_IP = "127.0.0.1";
23    private static final DefaultJedisClientConfig DEFAULT_CLIENT_CONFIG
24        = DefaultJedisClientConfig.builder().password("cluster").build();
25    private static Jedis node1;
26    private static Jedis node2;
27    private static Jedis node3;
28    private HostAndPort nodeInfo1 = HostAndPorts.getClusterServers().get(0);
29    private HostAndPort nodeInfo2 = HostAndPorts.getClusterServers().get(1);
30    private HostAndPort nodeInfo3 = HostAndPorts.getClusterServers().get(2);
31    private Set<HostAndPort> nodes = new HashSet<>(Arrays.asList(nodeInfo1, nodeInfo2, nodeInfo3));
32    @Before
33    public void setUp() throws InterruptedException {
34      node1 = new Jedis(nodeInfo1);
35      node1.auth("cluster");
36      node1.flushAll();
37      node2 = new Jedis(nodeInfo2);
38      node2.auth("cluster");
39      node2.flushAll();
40      node3 = new Jedis(nodeInfo3);
41      node3.auth("cluster");
42      node3.flushAll();
43      node1.clusterMeet(LOCAL_IP, nodeInfo2.getPort());
44      node1.clusterMeet(LOCAL_IP, nodeInfo3.getPort());
45      int slotsPerNode = CLUSTER_HASHSLOTS / 3;
46      int[] node1Slots = new int[slotsPerNode];
47      int[] node2Slots = new int[slotsPerNode + 1];
48      int[] node3Slots = new int[slotsPerNode];
49      for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0; i < CLUSTER_HASHSLOTS; i++) {
50        if (i < slotsPerNode) {
51          node1Slots[slot1++] = i;
52        } else if (i > slotsPerNode * 2) {
53          node3Slots[slot3++] = i;
54        } else {
55          node2Slots[slot2++] = i;
56        }
57      }
58      node1.clusterAddSlots(node1Slots);
59      node2.clusterAddSlots(node2Slots);
60      node3.clusterAddSlots(node3Slots);
61      JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
62    }
63    @AfterClass
64    public static void cleanUp() {
65      node1.flushDB();
66      node2.flushDB();
67      node3.flushDB();
68      node1.clusterReset(ClusterResetType.SOFT);
69      node2.clusterReset(ClusterResetType.SOFT);
70      node3.clusterReset(ClusterResetType.SOFT);
71    }
72    @After
73    public void tearDown() throws InterruptedException {
74      cleanUp();
75    }
76    @Test
77    public void constructorClientConfig() {
78      try (ClusterPipeline pipe = new ClusterPipeline(nodes, DEFAULT_CLIENT_CONFIG)) {
79        Response<String> r1 = pipe.set("key1", "value1");
80        Response<String> r2 = pipe.set("key2", "value2");
81        Response<String> r3 = pipe.set("key3", "value3");
82        Response<String> r4 = pipe.get("key1");
<span onclick='openModal()' class='match'>83        Response<String> r5 = pipe.get("key2");
84        Response<String> r6 = pipe.get("key3");
85        pipe.sync();
86        assertEquals("OK", r1.get());
87        assertEquals("OK", r2.get());
88        assertEquals("OK", r3.get());
89        assertEquals("value1", r4.get());
90        assertEquals("value2", r5.get());
</span>91        assertEquals("value3", r6.get());
92      }
93    }
94    @Test
95    public void constructorPoolConfig() {
96      try (ClusterPipeline pipe = new ClusterPipeline(nodes, DEFAULT_CLIENT_CONFIG, new ConnectionPoolConfig())) {
97        Response<String> r1 = pipe.set("key1", "value1");
98        Response<String> r2 = pipe.set("key2", "value2");
99        Response<String> r3 = pipe.set("key3", "value3");
100        Response<String> r4 = pipe.get("key1");
101        Response<String> r5 = pipe.get("key2");
102        Response<String> r6 = pipe.get("key3");
103        pipe.sync();
104        assertEquals("OK", r1.get());
105        assertEquals("OK", r2.get());
106        assertEquals("OK", r3.get());
107        assertEquals("value1", r4.get());
108        assertEquals("value2", r5.get());
109        assertEquals("value3", r6.get());
110      }
111    }
112    @Test
113    public void constructorConnectionProvider() {
114      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
115          ClusterPipeline pipeline = new ClusterPipeline(provider)) {
116        Response<String> r1 = pipeline.set("key1", "value1");
117        Response<String> r2 = pipeline.set("key2", "value2");
118        Response<String> r3 = pipeline.set("key3", "value3");
119        Response<String> r4 = pipeline.get("key1");
120        Response<String> r5 = pipeline.get("key2");
121        Response<String> r6 = pipeline.get("key3");
122        pipeline.sync();
123        assertEquals("OK", r1.get());
124        assertEquals("OK", r2.get());
125        assertEquals("OK", r3.get());
126        assertEquals("value1", r4.get());
127        assertEquals("value2", r5.get());
128        assertEquals("value3", r6.get());
129      }
130    }
131    @Test
132    public void clusterPipelined() {
133      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
134          ClusterPipeline pipeline = cluster.pipelined()) {
135        Response<String> r1 = pipeline.set("key1", "value1");
136        Response<String> r2 = pipeline.set("key2", "value2");
137        Response<String> r3 = pipeline.set("key3", "value3");
138        Response<String> r4 = pipeline.get("key1");
139        Response<String> r5 = pipeline.get("key2");
140        Response<String> r6 = pipeline.get("key3");
141        pipeline.sync();
142        assertEquals("OK", r1.get());
143        assertEquals("OK", r2.get());
144        assertEquals("OK", r3.get());
145        assertEquals("value1", r4.get());
146        assertEquals("value2", r5.get());
147        assertEquals("value3", r6.get());
148      }
149    }
150    @Test
151    public void intermediateSync() {
152      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
153          ClusterPipeline pipeline = cluster.pipelined()) {
154        Response<String> r1 = pipeline.set("key1", "value1");
155        Response<String> r2 = pipeline.set("key2", "value2");
156        Response<String> r3 = pipeline.set("key3", "value3");
157        pipeline.sync();
158        assertEquals("OK", r1.get());
159        assertEquals("OK", r2.get());
160        assertEquals("OK", r3.get());
161        Response<String> r4 = pipeline.get("key1");
162        Response<String> r5 = pipeline.get("key2");
163        Response<String> r6 = pipeline.get("key3");
164        pipeline.sync();
165        assertEquals("value1", r4.get());
166        assertEquals("value2", r5.get());
167        assertEquals("value3", r6.get());
168      }
169    }
170    @Test
171    public void intermediateSyncs() {
172      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG);
173          ClusterPipeline pipeline = cluster.pipelined()) {
174        Response<String> r1 = pipeline.set("key1", "value1");
175        Response<String> r2 = pipeline.set("key2", "value2");
176        Response<String> r3 = pipeline.set("key3", "value3");
177        for (int i = 0; i < 100; i++) pipeline.sync();
178        assertEquals("OK", r1.get());
179        assertEquals("OK", r2.get());
180        assertEquals("OK", r3.get());
181        Response<String> r4 = pipeline.get("key1");
182        Response<String> r5 = pipeline.get("key2");
183        Response<String> r6 = pipeline.get("key3");
184        for (int i = 0; i < 100; i++) pipeline.sync();
185        assertEquals("value1", r4.get());
186        assertEquals("value2", r5.get());
187        assertEquals("value3", r6.get());
188      }
189    }
190    @Test
191    public void pipelineResponse() {
192      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
193        jc.set("string", "foo");
194        jc.lpush("list", "foo");
195        jc.hset("hash", "foo", "bar");
196        jc.zadd("zset", 1, "foo");
197        jc.sadd("set", "foo");
198        jc.setrange("setrange", 0, "0123456789");
199        byte[] bytesForSetRange = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
200        jc.setrange("setrangebytes".getBytes(), 0, bytesForSetRange);
201      }
202      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
203        ClusterPipeline p = new ClusterPipeline(provider);
204        Response<String> string = p.get("string");
205        Response<String> list = p.lpop("list");
206        Response<String> hash = p.hget("hash", "foo");
207        Response<List<String>> zset = p.zrange("zset", 0, -1);
208        Response<String> set = p.spop("set");
209        Response<Boolean> blist = p.exists("list");
210        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
211        Response<Long> zcard = p.zcard("zset");
212        p.lpush("list", "bar");
213        Response<List<String>> lrange = p.lrange("list", 0, -1);
214        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
215        p.sadd("set", "foo");
216        Response<Set<String>> smembers = p.smembers("set");
217        Response<List<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0, -1);
218        Response<String> getrange = p.getrange("setrange", 1, 3);
219        Response<byte[]> getrangeBytes = p.getrange("setrangebytes".getBytes(), 6, 8);
220        p.sync();
221        assertEquals("foo", string.get());
222        assertEquals("foo", list.get());
223        assertEquals("bar", hash.get());
224        assertEquals("foo", zset.get().iterator().next());
225        assertEquals("foo", set.get());
226        assertEquals(false, blist.get());
227        assertEquals(Double.valueOf(2), zincrby.get());
228        assertEquals(Long.valueOf(1), zcard.get());
229        assertEquals(1, lrange.get().size());
230        assertNotNull(hgetAll.get().get("foo"));
231        assertEquals(1, smembers.get().size());
232        assertEquals(1, zrangeWithScores.get().size());
233        assertEquals("123", getrange.get());
234        byte[] expectedGetRangeBytes = {6, 7, 8};
235        assertArrayEquals(expectedGetRangeBytes, getrangeBytes.get());
236      }
237    }
238    @Test
239    public void pipelineBinarySafeHashCommands() {
240      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
241        jc.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
242        jc.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());
243      }
244      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
245        ClusterPipeline p = new ClusterPipeline(provider);
246        Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
247        Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
248        Response<List<byte[]>> fordered = p.hmget("key".getBytes(), "f22".getBytes(), "f1".getBytes());
249        Response<List<byte[]>> fvals = p.hvals("key".getBytes());
250        p.sync();
251        assertNotNull(fmap.get());
252        Map<byte[], byte[]> map = fmap.get();
253        Set<byte[]> mapKeys = map.keySet();
254        Iterator<byte[]> iterMap = mapKeys.iterator();
255        byte[] firstMapKey = iterMap.next();
256        byte[] secondMapKey = iterMap.next();
257        assertFalse(iterMap.hasNext());
258        verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(), "f22".getBytes());
259        byte[] firstMapValue = map.get(firstMapKey);
260        byte[] secondMapValue = map.get(secondMapKey);
261        verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(), "v2222".getBytes());
262        assertNotNull(fkeys.get());
263        Iterator<byte[]> iter = fkeys.get().iterator();
264        byte[] firstKey = iter.next();
265        byte[] secondKey = iter.next();
266        assertFalse(iter.hasNext());
267        verifyHasBothValues(firstKey, secondKey, "f1".getBytes(), "f22".getBytes());
268        assertNotNull(fordered.get());
269        assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
270        assertArrayEquals("v111".getBytes(), fordered.get().get(1));
271        assertNotNull(fvals.get());
272        assertEquals(2, fvals.get().size());
273        byte[] firstValue = fvals.get().get(0);
274        byte[] secondValue = fvals.get().get(1);
275        verifyHasBothValues(firstValue, secondValue, "v111".getBytes(), "v2222".getBytes());
276      }
277    }
278    private void verifyHasBothValues(byte[] firstKey, byte[] secondKey, byte[] value1, byte[] value2) {
279      assertFalse(Arrays.equals(firstKey, secondKey));
280      assertTrue(Arrays.equals(firstKey, value1) || Arrays.equals(firstKey, value2));
281      assertTrue(Arrays.equals(secondKey, value1) || Arrays.equals(secondKey, value2));
282    }
283    @Test(expected = IllegalStateException.class)
284    public void pipelineResponseWithinPipeline() {
285      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
286        ClusterPipeline p = new ClusterPipeline(provider);
287        Response<String> string = p.get("string");
288        string.get();
289        p.sync();
290      }
291    }
292    @Test
293    public void pipelineWithPubSub() {
294      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
295        ClusterPipeline pipelined = new ClusterPipeline(provider);
296        Response<Long> p1 = pipelined.publish("foo", "bar");
297        Response<Long> p2 = pipelined.publish("foo".getBytes(), "bar".getBytes());
298        pipelined.sync();
299        assertEquals(0, p1.get().longValue());
300        assertEquals(0, p2.get().longValue());
301      }
302    }
303    @Test
304    public void canRetrieveUnsetKey() {
305      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
306        ClusterPipeline p = new ClusterPipeline(provider);
307        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
308        p.sync();
309        assertNull(shouldNotExist.get());
310      }
311    }
312    @Test
313    public void piplineWithError() {
314      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
315        ClusterPipeline p = new ClusterPipeline(provider);
316        p.set("foo", "bar");
317        Response<Set<String>> error = p.smembers("foo");
318        Response<String> r = p.get("foo");
319        p.sync();
320        try {
321          error.get();
322          fail();
323        } catch (JedisDataException e) {
324        }
325        assertEquals(r.get(), "bar");
326      }
327    }
328    @Test
329    public void getSetParams() {
330      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
331      ClusterPipeline p = new ClusterPipeline(provider);
332      Response<String> r1 = p.set("key1", "value1");
333      Response<String> r2 = p.set("key2", "value2");
334      Response<String> r3 = p.set("key3", "value3");
335      Response<String> r4 = p.set("key3", "value4", new SetParams().nx()); 
336      Response<String> r5 = p.get("key1");
337      Response<String> r6 = p.get("key2");
338      Response<String> r7 = p.get("key3");
339      p.sync();
340      assertEquals("OK", r1.get());
341      assertEquals("OK", r2.get());
342      assertEquals("OK", r3.get());
343      assertNull(r4.get());
344      assertEquals("value1", r5.get());
345      assertEquals("value2", r6.get());
346      assertEquals("value3", r7.get());
347    }
348    @Test
349    public void clusterPipelineSort() {
350      List<String> sorted = new ArrayList<>();
351      sorted.add("1");
352      sorted.add("2");
353      sorted.add("3");
354      sorted.add("4");
355      sorted.add("5");
356      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
357      ClusterPipeline p = new ClusterPipeline(provider);
358      Response<Long> r1 = p.rpush("key1", "2", "3", "5", "1", "4");
359      Response<List<String>> r2 = p.sort("key1");
360      Response<Long> r3 = p.sort("key1", "key1");
361      Response<List<String>> r4 = p.lrange("key1", 0, 4);
362      Response<List<String>> r5 = p.sort("key1", new SortingParams().limit(0, 2));
363      Response<Long> r6 = p.sort("key1", new SortingParams().desc(), "key1");
364      Response<List<String>> r7 = p.lrange("key1", 0, 4);
365      p.sync();
366      assertEquals(Long.valueOf(5), r1.get());
367      assertEquals(sorted, r2.get());
368      assertEquals(Long.valueOf(5), r3.get());
369      assertEquals(sorted, r4.get());
370      assertEquals(2, r5.get().size());
371      assertEquals(Long.valueOf(5), r6.get());
372      Collections.reverse(sorted);
373      assertEquals(sorted, r7.get());
374    }
375    @Test
376    public void clusterPipelineList() {
377      List<String> vals = new ArrayList<>();
378      vals.add("foobar");
379      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
380      ClusterPipeline p = new ClusterPipeline(provider);
381      Response<Long> r1 = p.lpush("my{list}", "hello", "hello", "foo", "foo"); 
382      Response<Long> r2 = p.rpush("my{newlist}", "hello", "hello", "foo", "foo");  
383      Response<Long> r3 = p.lpos("my{list}", "foo");
384      Response<Long> r4 = p.lpos("my{list}", "foo", new LPosParams().maxlen(1));
385      Response<List<Long>> r5 = p.lpos("my{list}", "foo", new LPosParams().maxlen(1), 2);
386      Response<String> r6 = p.ltrim("my{list}", 2, 3); 
387      Response<Long> r7 = p.llen("my{list}");
388      Response<String> r8 = p.lindex("my{list}", -1);
389      Response<String> r9 = p.lset("my{list}", 1, "foobar"); 
390      Response<Long> r10 = p.lrem("my{list}", 1, "hello"); 
391      Response<List<String>> r11 = p.lrange("my{list}", 0, 10);
392      Response<String> r12 = p.rpop("my{newlist}"); 
393      Response<List<String>> r13 = p.lpop("my{list}", 1); 
394      Response<List<String>> r14 = p.rpop("my{newlist}", 2); 
395      Response<Long> r15 = p.linsert("my{newlist}", ListPosition.AFTER, "hello", "world"); 
396      Response<Long> r16 = p.lpushx("myother{newlist}", "foo", "bar");
397      Response<Long> r17 = p.rpushx("myother{newlist}", "foo", "bar");
398      Response<String> r18 = p.rpoplpush("my{newlist}", "myother{newlist}");
399      Response<String> r19 = p.lmove("my{newlist}", "myother{newlist}", ListDirection.LEFT, ListDirection.RIGHT);
400      p.sync();
401      assertEquals(Long.valueOf(4), r1.get());
402      assertEquals(Long.valueOf(4), r2.get());
403      assertEquals(Long.valueOf(0), r3.get());
404      assertEquals(Long.valueOf(0), r4.get());
405      assertEquals(1, r5.get().size());
406      assertEquals("OK", r6.get());
407      assertEquals(Long.valueOf(2), r7.get());
408      assertEquals("hello", r8.get());
409      assertEquals("OK", r9.get());
410      assertEquals(Long.valueOf(1), r10.get());
411      assertEquals(vals, r11.get());
412      assertEquals("foo", r12.get());
413      assertEquals(vals, r13.get());
414      assertEquals(2, r14.get().size());
415      assertEquals(Long.valueOf(2), r15.get());
416      assertEquals(Long.valueOf(0), r16.get());
417      assertEquals(Long.valueOf(0), r17.get());
418      assertEquals("world", r18.get());
419      assertEquals("hello", r19.get());
420    }
421    @Test
422    public void clusterPipelineSet() {
423      Set<String> diff = new HashSet<>();
424      diff.add("bar");
425      diff.add("foo");
426      Set<String> union = new HashSet<>();
427      union.add("hello");
428      union.add("world");
429      union.add("bar");
430      union.add("foo");
431      Set<String> inter = new HashSet<>();
432      inter.add("world");
433      inter.add("hello");
434      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
435      ClusterPipeline p = new ClusterPipeline(provider);
436      Response<Long> r1 = p.sadd("my{set}", "hello", "hello", "world", "foo", "bar");
437      p.sadd("mynew{set}", "hello", "hello", "world");
438      Response<Set<String>> r2 = p.sdiff("my{set}", "mynew{set}");
439      Response<Long> r3 = p.sdiffStore("diffset{set}", "my{set}", "mynew{set}");
440      Response<Set<String>> r4 = p.smembers("diffset{set}");
441      Response<Set<String>> r5 = p.sinter("my{set}", "mynew{set}");
442      Response<Long> r6 = p.sinterstore("interset{set}", "my{set}", "mynew{set}");
443      Response<Set<String>> r7 = p.smembers("interset{set}");
444      Response<Set<String>> r8 = p.sunion("my{set}", "mynew{set}");
445      Response<Long> r9 = p.sunionstore("unionset{set}", "my{set}", "mynew{set}");
446      Response<Set<String>> r10 = p.smembers("unionset{set}");
447      Response<Boolean> r11 = p.sismember("my{set}", "foo");
448      Response<List<Boolean>> r12 = p.smismember("my{set}", "foo", "foobar");
449      Response<Long> r13 = p.srem("my{set}", "foo");
450      Response<Set<String>> r14 = p.spop("my{set}", 1);
451      Response<Long> r15 = p.scard("my{set}");
452      Response<String> r16 = p.srandmember("my{set}");
453      Response<List<String>> r17 = p.srandmember("my{set}", 2);
454      p.sync();
455      assertEquals(Long.valueOf(4), r1.get());
456      assertEquals(diff, r2.get());
457      assertEquals(Long.valueOf(diff.size()), r3.get());
458      assertEquals(diff, r4.get());
459      assertEquals(inter, r5.get());
460      assertEquals(Long.valueOf(inter.size()), r6.get());
461      assertEquals(inter, r7.get());
462      assertEquals(union, r8.get());
463      assertEquals(Long.valueOf(union.size()), r9.get());
464      assertEquals(union, r10.get());
465      assertTrue(r11.get());
466      assertTrue(r12.get().get(0) && !r12.get().get(1));
467      assertEquals(Long.valueOf(1), r13.get());
468      assertTrue(union.containsAll(r14.get()));
469      assertEquals(Long.valueOf(2), r15.get());
470      assertTrue(union.contains(r16.get()));
471      assertTrue(union.containsAll(r17.get()));
472    }
473    @Test
474    public void clusterPipelineSortedSet() {
475      Map<String, Double> hm = new HashMap<>();
476      hm.put("a1", 1d);
477      hm.put("a2", 2d);
478      hm.put("a3", 3d);
479      Set<String> members = new HashSet<>(hm.keySet());
480      Tuple max = new Tuple("a3", 3d);
481      Tuple min = new Tuple("a1", 1d);
482      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
483      ClusterPipeline p = new ClusterPipeline(provider);
484      Response<Long> r1 = p.zadd("myset", hm);
485      Response<Long> r2 = p.zrank("myset", "a3");
486      Response<Long> r3 = p.zrevrank("myset", "a3");
487      Response<Long> r4 = p.zrem("myset", "a1");
488      Response<Long> r5 = p.zadd("myset", 1d, "a1");
489      Response<Long> r6 = p.zadd("myotherset", 2d, "a1", new ZAddParams().nx());
490      Response<Double> r7 = p.zaddIncr("myset", 3d, "a4", new ZAddParams().xx()); 
491      Response<List<String>> r8 = p.zrevrange("myset", 0, 0);
492      Response<List<Tuple>> r9 = p.zrevrangeWithScores("myset", 0, 0);
493      Response<String> r10 = p.zrandmember("myset");
494      Response<List<String>> r11 = p.zrandmember("myset", 2);
495      Response<List<Tuple>> r12 = p.zrandmemberWithScores("myset", 1);
496      Response<Double> r13 = p.zscore("myset", "a1");
497      Response<List<Double>> r14 = p.zmscore("myset", "a1", "a2");
498      Response<Tuple> r15 = p.zpopmax("myset");
499      Response<Tuple> r16 = p.zpopmin("myset");
500      Response<Long> r17 = p.zcount("myotherset", 2, 5);
501      Response<Long> r18 = p.zcount("myotherset", "(2", "5");
502      p.zadd("myset", hm, new ZAddParams().nx()); 
503      Response<List<Tuple>> r19 = p.zpopmax("myset", 2);
504      Response<List<Tuple>> r20 = p.zpopmin("myset", 1);
505      p.sync();
506      assertEquals(Long.valueOf(3), r1.get());
507      assertEquals(Long.valueOf(2), r2.get());
508      assertEquals(Long.valueOf(0), r3.get());
509      assertEquals(Long.valueOf(1), r4.get());
510      assertEquals(Long.valueOf(1), r5.get());
511      assertEquals(Long.valueOf(1), r6.get());
512      assertNull(r7.get());
513      assertTrue(r8.get().size() == 1 && r8.get().contains("a3"));
514      assertTrue(r9.get().size() == 1 && r9.get().contains(max));
515      assertTrue(members.contains(r10.get()));
516      assertTrue(members.containsAll(r11.get()));
517      assertEquals(1, r12.get().size());
518      assertEquals(Double.valueOf(1), r13.get());
519      assertTrue(hm.values().containsAll(r14.get()));
520      assertEquals(max, r15.get());
521      assertEquals(min, r16.get());
522      assertEquals(Long.valueOf(1), r17.get());
523      assertEquals(Long.valueOf(0), r18.get());
524      assertTrue(r19.get().size() == 2 && r19.get().contains(max));
525      assertTrue(r20.get().size() == 1 && r20.get().contains(min));
526    }
527    @Test
528    public void clusterPipelineHash() {
529      Map<String, String> hm = new HashMap<>();
530      hm.put("field2", "2");
531      hm.put("field3", "5");
532      Set<String> keys = new HashSet<>();
533      keys.add("field2");
534      List<String> vals = new ArrayList<>();
535      vals.add("3.5");
536      List<String> vals2 = new ArrayList<>();
537      vals2.add("hello");
538      vals2.add(null);
539      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
540      ClusterPipeline p = new ClusterPipeline(provider);
541      Response<Long> r1 = p.hset("myhash", "field1", "hello");
542      Response<Long> r2 = p.hsetnx("myhash", "field1", "hello");
543      Response<String> r3 = p.hget("myhash", "field1");
544      Response<Long> r4 = p.hset("myotherhash", hm);
545      Response<String> r5 = p.hmset("mynewhash", hm);
546      p.hincrBy("mynewhash", "field2", 1);
547      Response<Double> r6 = p.hincrByFloat("mynewhash", "field2", 0.5);
548      Response<Long> r7 = p.hlen("myhash");
549      Response<Long> r8 = p.hdel("mynewhash", "field3");
550      Response<Boolean> r9 = p.hexists("mynewhash", "field3");
551      Response<Set<String>> r10 = p.hkeys("mynewhash");
552      Response<List<String>> r11 = p.hvals("mynewhash");
553      Response<List<String>> r12 = p.hmget("myhash", "field1", "field2");
554      Response<String> r13 = p.hrandfield("myotherhash");
555      Response<List<String>> r14 = p.hrandfield("myotherhash", 4);
556      Response<List<String>> r15 = p.hrandfield("myotherhash", -4);
557      Response<Long> r16 = p.hstrlen("myhash", "field1");
558      Response<List<Map.Entry<String, String>>> r17 = p.hrandfieldWithValues("myotherhash", 4);
559      Response<List<Map.Entry<String, String>>> r18 = p.hrandfieldWithValues("myotherhash", -4);
560      p.sync();
561      assertEquals(Long.valueOf(1), r1.get());
562      assertEquals(Long.valueOf(0), r2.get());
563      assertEquals("hello", r3.get());
564      assertEquals(Long.valueOf(2), r4.get());
565      assertEquals("OK", r5.get());
566      assertEquals(Double.valueOf(3.5), r6.get());
567      assertEquals(Long.valueOf(1), r7.get());
568      assertEquals(Long.valueOf(1), r8.get());
569      assertFalse(r9.get());
570      assertEquals(keys, r10.get());
571      assertEquals(vals, r11.get());
572      assertEquals(vals2, r12.get());
573      AssertUtil.assertCollectionContains(hm.keySet(), r13.get());
574      assertEquals(2, r14.get().size());
575      assertEquals(4, r15.get().size());
576      assertEquals(Long.valueOf(5), r16.get());
577      assertEquals(2, r17.get().size());
578      assertEquals(4, r18.get().size());
579    }
580    @Test
581    public void clusterPipelineGeo() {
582      Map<String, GeoCoordinate> hm = new HashMap<>();
583      hm.put("place1", new GeoCoordinate(2.1909389952632, 41.433791470673));
584      hm.put("place2", new GeoCoordinate(2.1873744593677, 41.406342043777));
585      List<GeoCoordinate> values = new ArrayList<>();
586      values.add(new GeoCoordinate(2.19093829393386841, 41.43379028184083523));
587      values.add(new GeoCoordinate(2.18737632036209106, 41.40634178640635099));
588      List<String> hashValues = new ArrayList<>();
589      hashValues.add("sp3e9yg3kd0");
590      hashValues.add("sp3e9cbc3t0");
591      hashValues.add(null);
592      GeoRadiusParam params = new GeoRadiusParam().withCoord().withHash().withDist();
593      GeoRadiusParam params2 = new GeoRadiusParam().count(1, true);
594      GeoRadiusStoreParam storeParams = new GeoRadiusStoreParam().store("radius{#}");
595      GeoRadiusResponse expectedResponse = new GeoRadiusResponse("place1".getBytes());
596      expectedResponse.setCoordinate(new GeoCoordinate(2.19093829393386841, 41.43379028184083523));
597      expectedResponse.setDistance(0.0881);
598      expectedResponse.setRawScore(3471609698139488L);
599      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
600      ClusterPipeline p = new ClusterPipeline(provider);
601      Response<Long> r1 = p.geoadd("barcelona", hm);
602      p.geoadd("barcelona{#}", new GeoAddParams().nx(), hm);
603      Response<Double> r2 = p.geodist("barcelona", "place1", "place2");
604      Response<Double> r3 = p.geodist("barcelona", "place1", "place2", GeoUnit.KM);
605      Response<List<String>> r4 = p.geohash("barcelona", "place1", "place2", "place3");
606      Response<List<GeoCoordinate>> r5 = p.geopos("barcelona", "place1", "place2");
607      Response<List<GeoRadiusResponse>> r6 = p.georadius("barcelona", 2.191, 41.433, 1000, GeoUnit.M);
608      Response<List<GeoRadiusResponse>> r7 = p.georadiusReadonly("barcelona", 2.191, 41.433, 1000, GeoUnit.M);
609      Response<List<GeoRadiusResponse>> r8 = p.georadius("barcelona", 2.191, 41.433, 1, GeoUnit.KM, params);
610      Response<List<GeoRadiusResponse>> r9 = p.georadiusReadonly("barcelona", 2.191, 41.433, 1, GeoUnit.KM, params);
611      Response<Long> r10 = p.georadiusStore("barcelona{#}", 2.191, 41.433, 1000, GeoUnit.M, params2, storeParams);
612      Response<List<String>> r11 = p.zrange("radius{#}", 0, -1);
613      Response<List<GeoRadiusResponse>> r12 = p.georadiusByMember("barcelona", "place1", 4, GeoUnit.KM);
614      Response<List<GeoRadiusResponse>> r13 = p.georadiusByMemberReadonly("barcelona", "place1", 4, GeoUnit.KM);
615      Response<List<GeoRadiusResponse>> r14 = p.georadiusByMember("barcelona", "place1", 4, GeoUnit.KM, params2);
616      Response<List<GeoRadiusResponse>> r15 = p.georadiusByMemberReadonly("barcelona", "place1", 4, GeoUnit.KM, params2);
617      Response<Long> r16 = p.georadiusByMemberStore("barcelona{#}", "place1", 4, GeoUnit.KM, params2, storeParams);
618      Response<List<String>> r17 = p.zrange("radius{#}", 0, -1);
619      p.sync();
620      assertEquals(Long.valueOf(2), r1.get());
621      assertEquals(Double.valueOf(3067.4157), r2.get());
622      assertEquals(Double.valueOf(3.0674), r3.get());
623      assertEquals(hashValues, r4.get());
624      assertEquals(values, r5.get());
625      assertTrue(r6.get().size() == 1 && r6.get().get(0).getMemberByString().equals("place1"));
626      assertTrue(r7.get().size() == 1 && r7.get().get(0).getMemberByString().equals("place1"));
627      assertEquals(expectedResponse, r8.get().get(0));
628      assertEquals(expectedResponse, r9.get().get(0));
629      assertEquals(Long.valueOf(1), r10.get());
630      assertTrue(r11.get().size() == 1 && r11.get().contains("place1"));
631      assertTrue(r12.get().size() == 2 && r12.get().get(0).getMemberByString().equals("place2"));
632      assertTrue(r13.get().size() == 2 && r13.get().get(0).getMemberByString().equals("place2"));
633      assertTrue(r14.get().size() == 1 && r14.get().get(0).getMemberByString().equals("place2"));
634      assertTrue(r15.get().size() == 1 && r15.get().get(0).getMemberByString().equals("place2"));
635      assertEquals(Long.valueOf(1), r16.get());
636      assertTrue(r17.get().size() == 1 && r17.get().contains("place2"));
637    }
638    @Test
639    public void clusterPipelineHyperLogLog() {
640      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
641      ClusterPipeline p = new ClusterPipeline(provider);
642      Response<Long> r1 = p.pfadd("{hll}_1", "foo", "bar", "zap", "a");
643      Response<Long> r2 = p.pfadd("{hll}_2", "foo", "bar", "zap");
644      Response<Long> r3 = p.pfcount("{hll}_1", "{hll}_2");
645      Response<String> r4 = p.pfmerge("{hll}3", "{hll}_1", "{hll}_2");
646      Response<Long> r5 = p.pfcount("{hll}3");
647      p.sync();
648      assertEquals(Long.valueOf(1), r1.get());
649      assertEquals(Long.valueOf(1), r2.get());
650      assertEquals(Long.valueOf(4), r3.get());
651      assertEquals("OK", r4.get());
652      assertEquals(Long.valueOf(4), r5.get());
653    }
654    @Test
655    public void clusterPipelineStringsAndBits() {
656      List<Long> fieldRes = new ArrayList<>();
657      fieldRes.add(1L);
658      fieldRes.add(0L);
659      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
660      ClusterPipeline p = new ClusterPipeline(provider);
661      Response<String> r1 = p.set("{mykey}", "foobar"); 
662      p.set("my{otherkey}", "foo");
663      Response<String> r2 = p.substr("{mykey}", 0, 2);
664      Response<Long> r3 = p.strlen("{mykey}");
665      Response<Long> r4 = p.bitcount("my{otherkey}");
666      Response<Long> r5 = p.bitcount("my{otherkey}", 1, 1);
667      Response<Long> r6 = p.bitpos("{mykey}", true);
668      Response<Long> r7 = p.bitpos("{mykey}", false, new BitPosParams(1, 2));
669      Response<List<Long>> r8 = p.bitfield("mynew{key}", "INCRBY", "i5", "100", "1", "GET", "u4", "0");
670      Response<List<Long>> r9 = p.bitfieldReadonly("hello", "GET", "i8", "17");
671      p.set("myother{mykey}", "abcdef");
672      Response<Long> r10 = p.bitop(BitOP.AND, "dest{mykey}", "{mykey}", "myother{mykey}");
673      Response<String> r11 = p.get("dest{mykey}");
674      Response<Boolean> r12 = p.setbit("my{otherkey}", 7, true);
675      Response<Boolean> r13 = p.getbit("my{otherkey}", 7);
676      p.sync();
677      assertEquals("OK", r1.get());
678      assertEquals("foo", r2.get());
679      assertEquals(Long.valueOf(6), r3.get());
680      assertEquals(Long.valueOf(16), r4.get());
681      assertEquals(Long.valueOf(6), r5.get());
682      assertEquals(Long.valueOf(1), r6.get());
683      assertEquals(Long.valueOf(8), r7.get());
684      assertEquals(fieldRes, r8.get());
685      assertEquals(fieldRes.subList(1, 2), r9.get());
686      assertEquals(Long.valueOf(6), r10.get());
687      assertEquals("`bc`ab", r11.get());
688      assertFalse(r12.get());
689      assertTrue(r13.get());
690    }
691    @Test
692    public void clusterPipelineStream() {
693      Map<String, String> hm = new HashMap<>();
694      hm.put("one", "one");
695      hm.put("two", "two");
696      hm.put("three", "three");
697      StreamEntryID streamId1 = new StreamEntryID("1638277876711-0");
698      StreamEntryID streamId2 = new StreamEntryID("1638277959731-0");
699      ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG);
700      ClusterPipeline p = new ClusterPipeline(provider);
701      Response<StreamEntryID> r1 = p.xadd("mystream", streamId1, hm);
702      Response<StreamEntryID> r2 = p.xadd("mystream", new XAddParams().id(new StreamEntryID("1638277959731-0")).maxLen(2).approximateTrimming(), hm);
703      Response<Long> r3 = p.xlen("mystream");
704      Response<List<StreamEntry>> r4 = p.xrange("mystream", streamId1, streamId2);
705      Response<List<StreamEntry>> r5 = p.xrange("mystream", streamId1, streamId2, 1);
706      Response<List<StreamEntry>> r6 = p.xrevrange("mystream", streamId2, streamId1);
707      Response<List<StreamEntry>> r7 = p.xrevrange("mystream", streamId2, streamId1, 1);
708      Response<String> r8 = p.xgroupCreate("mystream", "group", streamId1, false);
709      Response<String> r9 = p.xgroupSetID("mystream", "group", streamId2);
710      p.sync();
711      assertEquals(streamId1, r1.get());
712      assertEquals(streamId2, r2.get());
713      assertEquals(Long.valueOf(2), r3.get());
714      assertTrue(r4.get().size() == 2
715          && r4.get().get(0).getID().compareTo(streamId1) == 0
716          && r4.get().get(1).getID().compareTo(streamId2) == 0);
717      assertTrue(r5.get().size() == 1 && r5.get().get(0).getID().compareTo(streamId1) == 0);
718      assertTrue(r6.get().size() == 2
719          && r6.get().get(1).getID().compareTo(streamId1) == 0
720          && r6.get().get(0).getID().compareTo(streamId2) == 0);
721      assertTrue(r7.get().size() == 1 && r7.get().get(0).getID().compareTo(streamId2) == 0);
722      assertEquals("OK", r8.get());
723      assertEquals("OK", r9.get());
724    }
725    @Test
726    public void testEval() {
727      String script = "return 'success!'";
728      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
729        ClusterPipeline p = new ClusterPipeline(provider);
730        Response<Object> result = p.eval(script);
731        p.sync();
732        assertEquals("success!", result.get());
733      }
734    }
735    @Test
736    public void testEvalWithBinary() {
737      String script = "return 'success!'";
738      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
739        ClusterPipeline p = new ClusterPipeline(provider);
740        Response<Object> result = p.eval(SafeEncoder.encode(script));
741        p.sync();
742        assertArrayEquals(SafeEncoder.encode("success!"), (byte[]) result.get());
743      }
744    }
745    @Test
746    public void testEvalKeyAndArg() {
747      String key = "test";
748      String arg = "3";
749      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
750      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
751        ClusterPipeline p = new ClusterPipeline(provider);
752        p.set(key, "0");
753        Response<Object> result0 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
754        p.incr(key);
755        Response<Object> result1 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
756        Response<String> result2 = p.get(key);
757        p.sync();
758        assertNull(result0.get());
759        assertNull(result1.get());
760        assertEquals("13", result2.get());
761      }
762    }
763    @Test
764    public void testEvalKeyAndArgWithBinary() {
765      byte[] bKey = SafeEncoder.encode("test");
766      byte[] bArg = SafeEncoder.encode("3");
767      byte[] bScript = SafeEncoder.encode("redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])");
768      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
769        ClusterPipeline bP = new ClusterPipeline(provider);
770        bP.set(bKey, SafeEncoder.encode("0"));
771        Response<Object> bResult0 = bP.eval(bScript, Arrays.asList(bKey), Arrays.asList(bArg));
772        bP.incr(bKey);
773        Response<Object> bResult1 = bP.eval(bScript, Arrays.asList(bKey), Arrays.asList(bArg));
774        Response<byte[]> bResult2 = bP.get(bKey);
775        bP.sync();
776        assertNull(bResult0.get());
777        assertNull(bResult1.get());
778        assertArrayEquals(SafeEncoder.encode("13"), bResult2.get());
779      }
780    }
781    @Test
782    public void testEvalNestedLists() {
783      String script = "return { {KEYS[1]} , {2} }";
784      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
785        ClusterPipeline p = new ClusterPipeline(provider);
786        Response<Object> result = p.eval(script, 1, "key1");
787        p.sync();
788        List<?> results = (List<?>) result.get();
789        MatcherAssert.assertThat((List<String>) results.get(0), Matchers.hasItem("key1"));
790        MatcherAssert.assertThat((List<Long>) results.get(1), Matchers.hasItem(2L));
791      }
792    }
793    @Test
794    public void testEvalNestedListsWithBinary() {
795      byte[] bScript = SafeEncoder.encode("return { {KEYS[1]} , {2} }");
796      byte[] bKey = SafeEncoder.encode("key1");
797      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
798        ClusterPipeline p = new ClusterPipeline(provider);
799        Response<Object> result = p.eval(bScript, 1, bKey);
800        p.sync();
801        List<?> results = (List<?>) result.get();
802        MatcherAssert.assertThat((List<byte[]>) results.get(0), Matchers.hasItem(bKey));
803        MatcherAssert.assertThat((List<Long>) results.get(1), Matchers.hasItem(2L));
804      }
805    }
806    @Test
807    public void testEvalsha() {
808      String script = "return 'success!'";
809      String sha1;
810      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
811        sha1 = jc.scriptLoad(script, "sampleKey");
812        assertTrue(jc.scriptExists(sha1, "sampleKey"));
813      }
814      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
815        ClusterPipeline p = new ClusterPipeline(provider);
816        Response<Object> result = p.evalsha(sha1, 1, "sampleKey");
817        p.sync();
818        assertEquals("success!", result.get());
819      }
820    }
821    @Test
822    public void testEvalshaKeyAndArg() {
823      String key = "test";
824      String arg = "3";
825      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
826      String sha1;
827      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
828        sha1 = jc.scriptLoad(script, key);
829        assertTrue(jc.scriptExists(sha1, key));
830      }
831      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
832        ClusterPipeline p = new ClusterPipeline(provider);
833        p.set(key, "0");
834        Response<Object> result0 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
835        p.incr(key);
836        Response<Object> result1 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
837        Response<String> result2 = p.get(key);
838        p.sync();
839        assertNull(result0.get());
840        assertNull(result1.get());
841        assertEquals("13", result2.get());
842      }
843    }
844    @Test
845    public void testEvalshaKeyAndArgWithBinary() {
846      byte[] bKey = SafeEncoder.encode("test");
847      byte[] bArg = SafeEncoder.encode("3");
848      String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
849      byte[] bScript = SafeEncoder.encode(script);
850      byte[] bSha1;
851      try (JedisCluster jc = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
852        bSha1 = jc.scriptLoad(bScript, bKey);
853        assertTrue(jc.scriptExists(bSha1, bKey));
854      }
855      try (ClusterConnectionProvider provider = new ClusterConnectionProvider(nodes, DEFAULT_CLIENT_CONFIG)) {
856        ClusterPipeline p = new ClusterPipeline(provider);
857        p.set(bKey, SafeEncoder.encode("0"));
858        Response<Object> result0 = p.evalsha(bSha1, Arrays.asList(bKey), Arrays.asList(bArg));
859        p.incr(bKey);
860        Response<Object> result1 = p.evalsha(bSha1, Arrays.asList(bKey), Arrays.asList(bArg));
861        Response<byte[]> result2 = p.get(bKey);
862        p.sync();
863        assertNull(result0.get());
864        assertNull(result1.get());
865        assertArrayEquals(SafeEncoder.encode("13"), result2.get());
866      }
867    }
868    @Test
869    public void simple() { 
870      try (JedisCluster jedis = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
871        final int count = 10;
872        int totalCount = 0;
873        for (int i = 0; i < count; i++) {
874          jedis.set("foo" + i, "bar" + i);
875        }
876        totalCount += count;
877        for (int i = 0; i < count; i++) {
878          jedis.rpush("foobar" + i, "foo" + i, "bar" + i);
879        }
880        totalCount += count;
881        List<Response<?>> responses = new ArrayList<>(totalCount);
882        List<Object> expected = new ArrayList<>(totalCount);
883        try (ClusterPipeline pipeline = jedis.pipelined()) {
884          for (int i = 0; i < count; i++) {
885            responses.add(pipeline.get("foo" + i));
886            expected.add("bar" + i);
887          }
888          for (int i = 0; i < count; i++) {
889            responses.add(pipeline.lrange("foobar" + i, 0, -1));
890            expected.add(Arrays.asList("foo" + i, "bar" + i));
891          }
892        }
893        for (int i = 0; i < totalCount; i++) {
894          assertEquals(expected.get(i), responses.get(i).get());
895        }
896      }
897    }
898    @Test
899    public void transaction() {
900      try (JedisCluster cluster = new JedisCluster(nodes, DEFAULT_CLIENT_CONFIG)) {
901        assertThrows(UnsupportedOperationException.class, () -> cluster.multi());
902      }
903    }
904  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Mybatis-PageHelper-MDEwOlJlcG9zaXRvcnkyMDY1MTY3Mg==-flat-TestDynamicIfTwoList.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ClusterPipeliningTest.java</div>
                <div class="column column_space"><pre><code>19              PageHelper.startPage(1, 10);
20              List<User> list = userMapper.selectIf2List(Arrays.asList(1, 2), Arrays.asList(3, 4));
21              assertEquals(5, list.get(0).getId());
22              assertEquals(10, list.size());
23              assertEquals(179, ((Page<?>) list).getTotal());
24              PageHelper.startPage(1, 10);
</pre></code></div>
                <div class="column column_space"><pre><code>83        Response<String> r5 = pipe.get("key2");
84        Response<String> r6 = pipe.get("key3");
85        pipe.sync();
86        assertEquals("OK", r1.get());
87        assertEquals("OK", r2.get());
88        assertEquals("OK", r3.get());
89        assertEquals("value1", r4.get());
90        assertEquals("value2", r5.get());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    