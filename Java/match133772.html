<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for CycleDetectingLockFactoryTest_1.java & AbstractStandardDirectedGraphTest_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for CycleDetectingLockFactoryTest_1.java & AbstractStandardDirectedGraphTest_1.java
      </h3>
      <h1 align="center">
        24.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>CycleDetectingLockFactoryTest_1.java (26.323988%)<TH>AbstractStandardDirectedGraphTest_1.java (22.837837%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#0',2,'match133772-1.html#0',3)" NAME="0">(292-308)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#0',2,'match133772-1.html#0',3)" NAME="0">(398-405)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#1',2,'match133772-1.html#1',3)" NAME="1">(96-110)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#1',2,'match133772-1.html#1',3)" NAME="1">(35-43)</A><TD ALIGN=center><FONT COLOR="#f00000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#2',2,'match133772-1.html#2',3)" NAME="2">(458-469)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#2',2,'match133772-1.html#2',3)" NAME="2">(312-331)</A><TD ALIGN=center><FONT COLOR="#e10000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#3',2,'match133772-1.html#3',3)" NAME="3">(471-481)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#3',2,'match133772-1.html#3',3)" NAME="3">(182-188)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#4',2,'match133772-1.html#4',3)" NAME="4">(115-122)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#4',2,'match133772-1.html#4',3)" NAME="4">(55-61)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#5',2,'match133772-1.html#5',3)" NAME="5">(430-445)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#5',2,'match133772-1.html#5',3)" NAME="5">(130-136)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#6',2,'match133772-1.html#6',3)" NAME="6">(246-258)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#6',2,'match133772-1.html#6',3)" NAME="6">(166-171)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#7',2,'match133772-1.html#7',3)" NAME="7">(447-456)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#7',2,'match133772-1.html#7',3)" NAME="7">(114-120)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#8',2,'match133772-1.html#8',3)" NAME="8">(371-384)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#8',2,'match133772-1.html#8',3)" NAME="8">(172-177)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#9',2,'match133772-1.html#9',3)" NAME="9">(201-206)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#9',2,'match133772-1.html#9',3)" NAME="9">(451-456)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#10',2,'match133772-1.html#10',3)" NAME="10">(182-188)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#10',2,'match133772-1.html#10',3)" NAME="10">(366-371)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#11',2,'match133772-1.html#11',3)" NAME="11">(166-171)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#11',2,'match133772-1.html#11',3)" NAME="11">(86-91)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#12',2,'match133772-1.html#12',3)" NAME="12">(140-147)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#12',2,'match133772-1.html#12',3)" NAME="12">(70-75)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match133772-0.html#13',2,'match133772-1.html#13',3)" NAME="13">(157-165)<TD><A HREF="javascript:ZweiFrames('match133772-0.html#13',2,'match133772-1.html#13',3)" NAME="13">(153-158)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CycleDetectingLockFactoryTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.util.concurrent;


import com.google.common.base.Joiner;
import com.google.common.util.concurrent.CycleDetectingLockFactory.Policies;
import com.google.common.util.concurrent.CycleDetectingLockFactory.Policy;
import com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import junit.framework.TestCase;

/**
 * Unittests for {@link CycleDetectingLockFactory}.
 *
 * @author Darick Tong
 */
public class CycleDetectingLockFactoryTest extends TestCase {

  private ReentrantLock lockA;
  private ReentrantLock lockB;
  private ReentrantLock lockC;
  private ReentrantReadWriteLock.ReadLock readLockA;
  private ReentrantReadWriteLock.ReadLock readLockB;
  private ReentrantReadWriteLock.ReadLock readLockC;
  private ReentrantReadWriteLock.WriteLock writeLockA;
  private ReentrantReadWriteLock.WriteLock writeLockB;
  private ReentrantReadWriteLock.WriteLock writeLockC;
  private ReentrantLock lock1;
  private ReentrantLock lock2;
  private ReentrantLock lock3;
  private ReentrantLock lock01;
  private ReentrantLock lock02;
  private ReentrantLock lock03;

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    CycleDetectingLockFactory factory = CycleDetectingLockFactory.newInstance(Policies.THROW);
    lockA = factory.newReentrantLock(&quot;LockA&quot;);
    lockB = factory.newReentrantLock(&quot;LockB&quot;);
    lockC = factory.newReentrantLock(&quot;LockC&quot;);
    ReentrantReadWriteLock readWriteLockA = factory.newReentrantReadWriteLock(&quot;ReadWriteA&quot;);
    ReentrantReadWriteLock readWriteLockB = factory.newReentrantReadWriteLock(&quot;ReadWriteB&quot;);
    ReentrantReadWriteLock readWriteLockC = factory.newReentrantReadWriteLock(&quot;ReadWriteC&quot;);
    readLockA = readWriteLockA.readLock();
    readLockB = readWriteLockB.readLock();
    readLockC = readWriteLockC.readLock();
    writeLockA = readWriteLockA.writeLock();
    writeLockB = readWriteLockB.writeLock();
    writeLockC = readWriteLockC.writeLock();

    CycleDetectingLockFactory.WithExplicitOrdering&lt;MyOrder&gt; factory2 =
        newInstanceWithExplicitOrdering(MyOrder.class, Policies.THROW);
    lock1 = factory2.newReentrantLock(MyOrder.FIRST);
    lock2 = factory2.newReentrantLock(MyOrder.SECOND);
    lock3 = factory2.newReentrantLock(MyOrder.THIRD);

    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory3 =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    lock01 = factory3.newReentrantLock(OtherOrder.FIRST);
    lock02 = factory3.newReentrantLock(OtherOrder.SECOND);
    lock03 = factory3.newReentrantLock(OtherOrder.THIRD);
  }

  // In the unittest, create each ordered factory with its own set of lock
  // graph nodes (as opposed to using the static per-Enum map) to avoid
  // conflicts across different test runs.
  private &lt;E extends Enum&lt;E&gt;&gt;
      CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt; newInstanceWithExplicitOrdering(
          Class&lt;E&gt; enumClass, Policy policy) {
    return new CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt;(
<A NAME="1"></A>        policy, CycleDetectingLockFactory.createNodes(enumClass));
  }

  public void testDeadlock_twoLocks() <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match133772-1.html#1',3,'match133772-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    // Establish an acquisition order of lockA -&gt; lockB.
    lockA.lock();
    lockB.lock();
    lockA.unlock();
    lockB.unlock();

    // The opposite order should fail (Policies.THROW).
    PotentialDeadlockException firstException = null;
    lockB.lock();
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(expected, &quot;LockB -&gt; LockA&quot;, &quot;LockA -&gt; LockB&quot;);
      firstException = expected;
<A NAME="4"></A>    }

    // Second time should also fail, with a cached causal chain.
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match133772-1.html#4',3,'match133772-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; LockA&quot;, &quot;LockA -&gt; LockB&quot;);
      // The causal chain should be cached.
      assertSame(firstException.getCause(), expected.getCause());
    }</B></FONT>

    // lockA should work after lockB is released.
    lockB.unlock();
    lockA.lock();
  }

  // Tests transitive deadlock detection.
  public void testDeadlock_threeLocks() {
    // Establish an ordering from lockA -&gt; lockB.
    lockA.lock();
    lockB.lock();
    lockB.unlock();
    lockA.unlock();

<A NAME="12"></A>    // Establish an ordering from lockB -&gt; lockC.
    lockB.lock();
    lockC.lock();
    <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match133772-1.html#12',3,'match133772-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>lockB.unlock();

    // lockC -&gt; lockA should fail.
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(expected, &quot;LockC -&gt; LockA&quot;, &quot;LockB -&gt; LockC&quot;, &quot;LockA -&gt; LockB&quot;);
    }
  }

  public void testReentrancy_noDeadlock() {
    lockA.lock();
    lockB.lock();
<A NAME="13"></A>    lockA.lock(); // Should not assert on lockB -&gt; reentrant(lockA)
  }

  public void testExplicitOrdering_noViolations() <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match133772-1.html#13',3,'match133772-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    lock1.lock();
    lock3.lock();
    lock3.unlock();
    lock2.lock();
    lock3.lock();
<A NAME="11"></A>  }

  public void testExplicitOrderin</B></FONT>g_violations() {
    <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match133772-1.html#11',3,'match133772-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>lock3.lock();
    try {
      lock2.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(expected, &quot;MyOrder.THIRD -&gt; MyOrder.SECOND&quot;);
    }

    try {
      lock1.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;MyOrder.THIRD -&gt; MyOrder.FIRST&quot;);
<A NAME="10"></A>    }

    lock3.unlock();
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match133772-1.html#10',3,'match133772-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>lock2.lock();

    try {
      lock1.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(expected, &quot;MyOrder.SECOND -&gt; MyOrder.FIRST&quot;);
    }
  }

  public void testDifferentOrderings_noViolations() {
    lock3.lock(); // MyOrder, ordinal() == 3
    lock01.lock(); // OtherOrder, ordinal() == 1
  }

  public void testExplicitOrderings_generalCycleDetection() {
<A NAME="9"></A>    lock3.lock(); // MyOrder, ordinal() == 3
    lock01.lock(); // OtherOrder, ordinal() == 1

    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match133772-1.html#9',3,'match133772-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>lock3.unlock();
    try {
      lock3.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(
          expected, &quot;OtherOrder.FIRST -&gt; MyOrder.THIRD&quot;, &quot;MyOrder.THIRD -&gt; OtherOrder.FIRST&quot;);
    }

    lockA.lock();
    lock01.unlock();
    lockB.lock();
    lockA.unlock();

    try {
      lock01.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected, &quot;LockB -&gt; OtherOrder.FIRST&quot;, &quot;LockA -&gt; LockB&quot;, &quot;OtherOrder.FIRST -&gt; LockA&quot;);
    }
  }

  public void testExplicitOrdering_cycleWithUnorderedLock() {
    Lock myLock = CycleDetectingLockFactory.newInstance(Policies.THROW).newReentrantLock(&quot;MyLock&quot;);
    lock03.lock();
    myLock.lock();
    lock03.unlock();

    try {
      lock01.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          &quot;MyLock -&gt; OtherOrder.FIRST&quot;,
          &quot;OtherOrder.THIRD -&gt; MyLock&quot;,
          &quot;OtherOrder.FIRST -&gt; OtherOrder.THIRD&quot;);
    }
  }

  public void testExplicitOrdering_reentrantAcquisition() {
<A NAME="6"></A>    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    Lock lockA = factory.newReentrantReadWriteLock(OtherOrder.FIRST).readLock();
    Lock lockB = <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match133772-1.html#6',3,'match133772-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>factory.newReentrantLock(OtherOrder.SECOND);

    lockA.lock();
    lockA.lock();
    lockB.lock();
    lockB.lock();
    lockA.unlock();
    lockA.unlock();
    lockB.unlock();
    lockB.unlock();
  }

  public void testExplicitOrdering_acquiringMultipleLocks</B></FONT>WithSameRank() {
    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    Lock lockA = factory.newReentrantLock(OtherOrder.FIRST);
    Lock lockB = factory.newReentrantReadWriteLock(OtherOrder.FIRST).readLock();

    lockA.lock();
    try {
      lockB.lock();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }

    lockA.unlock();
    lockB.lock();
  }

  public void testReadLock_deadlock() {
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB.
    lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    lockB.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }
<A NAME="0"></A>
  public void testReadLock_transitive() {
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB.
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match133772-1.html#0',3,'match133772-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    // Establish an ordering from lockB -&gt; readLockC.
    lockB.lock();
    readLockC.lock();
    lockB.unlock();
    readLockC.unlock();

    // readLockC -&gt; readLockA
    readLockC.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage</B></FONT>(
          expected, &quot;ReadWriteC -&gt; ReadWriteA&quot;, &quot;LockB -&gt; ReadWriteC&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testWriteLock_threeLockDeadLock() {
    // Establish an ordering from writeLockA -&gt; writeLockB.
    writeLockA.lock();
    writeLockB.lock();
    writeLockB.unlock();
    writeLockA.unlock();

    // Establish an ordering from writeLockB -&gt; writeLockC.
    writeLockB.lock();
    writeLockC.lock();
    writeLockB.unlock();

    // writeLockC -&gt; writeLockA should fail.
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          &quot;ReadWriteC -&gt; ReadWriteA&quot;,
          &quot;ReadWriteB -&gt; ReadWriteC&quot;,
          &quot;ReadWriteA -&gt; ReadWriteB&quot;);
    }
  }

  public void testWriteToReadLockDowngrading() {
    writeLockA.lock(); // writeLockA downgrades to readLockA
    readLockA.lock();
    writeLockA.unlock();

    lockB.lock(); // readLockA -&gt; lockB
    readLockA.unlock();

    // lockB -&gt; writeLockA should fail
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadWriteLockDeadlock() {
    writeLockA.lock(); // Establish an ordering from writeLockA -&gt; lockB
    lockB.lock();
    writeLockA.unlock();
    lockB.unlock();

    // lockB -&gt; readLockA should fail.
    lockB.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
<A NAME="8"></A>    }
  }

  public void testReadWriteLockDeadlock_transitive() <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match133772-1.html#8',3,'match133772-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB
    lockB.lock();
    readLockA.unlock();
    lockB.unlock();

    // Establish an ordering from lockB -&gt; lockC
    lockB.lock();
    lockC.lock();
    lockB.unlock();
    lockC.unlock();

    // lockC -&gt; writeLockA should fail.
    lockC.lock</B></FONT>();
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockC -&gt; ReadWriteA&quot;, &quot;LockB -&gt; LockC&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadWriteLockDeadlock_treatedEquivalently() {
    readLockA.lock(); // readLockA -&gt; writeLockB
    writeLockB.lock();
    readLockA.unlock();
    writeLockB.unlock();

    // readLockB -&gt; writeLockA should fail.
    readLockB.lock();
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;ReadWriteB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; ReadWriteB&quot;);
    }
  }

  public void testDifferentLockFactories() {
    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);
    ReentrantLock lockD = otherFactory.newReentrantLock(&quot;LockD&quot;);

    // lockA -&gt; lockD
    lockA.lock();
    lockD.lock();
    lockA.unlock();
    lockD.unlock();

    // lockD -&gt; lockA should fail even though lockD is from a different factory.
    lockD.lock();
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockD -&gt; LockA&quot;, &quot;LockA -&gt; LockD&quot;);
    }
<A NAME="5"></A>  }

  public void testDifferentLockFactories_policyExecution() {
    CycleDetectingLockFactory otherFactory = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match133772-1.html#5',3,'match133772-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>CycleDetectingLockFactory.newInstance(Policies.WARN);
    ReentrantLock lockD = otherFactory.newReentrantLock(&quot;LockD&quot;);

    // lockD -&gt; lockA
    lockD.lock();
    lockA.lock();
    lockA.unlock();
    lockD.unlock();

    // lockA -&gt; lockD should warn but otherwise succeed because lockD was
    // created by a factory with the WARN policy.
    lockA.lock();
    lockD.lock();
  }
<A NAME="7"></A>
  public void testReentrant</B></FONT>Lock_tryLock() throws Exception {
    LockingThread thread = new LockingThread(lockA);
    <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match133772-1.html#7',3,'match133772-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(lockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(lockA.tryLock());
  }
<A NAME="2"></A>
  public void testReentrantWrite</B></FONT>Lock_tryLock() throws Exception {
    LockingThread thread = new LockingThread(writeLockA);
    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match133772-1.html#2',3,'match133772-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertFalse(readLockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }
<A NAME="3"></A>
  public void testReentrantReadLock_tryLock() throws Exception {</B></FONT>
    LockingThread thread = new LockingThread(readLockA);
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match133772-1.html#3',3,'match133772-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
    readLockA.unlock();

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }</B></FONT>

  private static class LockingThread extends Thread {
    final CountDownLatch locked = new CountDownLatch(1);
    final CountDownLatch finishLatch = new CountDownLatch(1);
    final Lock lock;

    LockingThread(Lock lock) {
      this.lock = lock;
    }

    @Override
    public void run() {
      lock.lock();
      try {
        locked.countDown();
        finishLatch.await(1, TimeUnit.MINUTES);
      } catch (InterruptedException e) {
        fail(e.toString());
      } finally {
        lock.unlock();
      }
    }

    void waitUntilHoldingLock() throws InterruptedException {
      locked.await(1, TimeUnit.MINUTES);
    }

    void releaseLockAndFinish() throws InterruptedException {
      finishLatch.countDown();
      this.join(10000);
      assertFalse(this.isAlive());
    }
  }

  public void testReentrantReadWriteLock_implDoesNotExposeShadowedLocks() {
    assertEquals(
        &quot;Unexpected number of public methods in ReentrantReadWriteLock. &quot;
            + &quot;The correctness of CycleDetectingReentrantReadWriteLock depends on &quot;
            + &quot;the fact that the shadowed ReadLock and WriteLock are never used or &quot;
            + &quot;exposed by the superclass implementation. If the implementation has &quot;
            + &quot;changed, the code must be re-inspected to ensure that the &quot;
            + &quot;assumption is still valid.&quot;,
        24,
        ReentrantReadWriteLock.class.getMethods().length);
  }

  private enum MyOrder {
    FIRST,
    SECOND,
    THIRD;
  }

  private enum OtherOrder {
    FIRST,
    SECOND,
    THIRD;
  }

  // Given a sequence of lock acquisition descriptions
  // (e.g. &quot;LockA -&gt; LockB&quot;, &quot;LockB -&gt; LockC&quot;, ...)
  // Checks that the exception.getMessage() matches a regex of the form:
  // &quot;LockA -&gt; LockB \b.*\b LockB -&gt; LockC \b.*\b LockC -&gt; LockA&quot;
  private void checkMessage(IllegalStateException exception, String... expectedLockCycle) {
    String regex = Joiner.on(&quot;\\b.*\\b&quot;).join(expectedLockCycle);
    assertContainsRegex(regex, exception.getMessage());
  }

  // TODO(cpovirk): consider adding support for regex to Truth
  private static void assertContainsRegex(String expectedRegex, String actual) {
    Pattern pattern = Pattern.compile(expectedRegex);
    Matcher matcher = pattern.matcher(actual);
    if (!matcher.find()) {
      String actualDesc = (actual == null) ? &quot;null&quot; : ('&lt;' + actual + '&gt;');
      fail(&quot;expected to contain regex:&lt;&quot; + expectedRegex + &quot;&gt; but was:&quot; + actualDesc);
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractStandardDirectedGraphTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.graph;

import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.TruthJUnit.assume;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Set;
import org.junit.Test;

/**
 * Abstract base class for testing directed {@link Graph} implementations defined in this package.
 */
public abstract class AbstractStandardDirectedGraphTest extends AbstractGraphTest {
<A NAME="1"></A>
  @Override
  @Test
  public void nodes_checkReturnedSetMutability() <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#1',2,'match133772-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    assume().that(graphIsMutable()).isTrue();

    Set&lt;Integer&gt; nodes = graph.nodes();
    try {
      nodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      addNode</B></FONT>(N1);
      assertThat(graph.nodes()).containsExactlyElementsIn(nodes);
    }
  }

  @Override
  @Test
  public void adjacentNodes_checkReturnedSetMutability() {
    assume().that(graphIsMutable()).isTrue();
<A NAME="4"></A>
    addNode(N1);
    Set&lt;Integer&gt; adjacentNodes = graph.adjacentNodes(N1);
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#4',2,'match133772-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }</B></FONT>
  }

  @Override
  @Test
  public void predecessors_checkReturnedSetMutability() {
<A NAME="12"></A>    assume().that(graphIsMutable()).isTrue();

    addNode(N2);
    Set&lt;Integer&gt; predecessors = <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#12',2,'match133772-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>graph.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge</B></FONT>(N1, N2);
      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }

  @Override
  @Test
  public void successors_checkReturnedSetMutability() {
<A NAME="11"></A>    assume().that(graphIsMutable()).isTrue();

    addNode(N1);
    Set&lt;Integer&gt; successors = <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#11',2,'match133772-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>graph.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge</B></FONT>(N1, N2);
      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));
    }
  }

  @Override
  @Test
  public void incidentEdges_checkReturnedSetMutability() {
    assume().that(graphIsMutable()).isTrue();

    addNode(N1);
    Set&lt;EndpointPair&lt;Integer&gt;&gt; incidentEdges = graph.incidentEdges(N1);
    try {
      incidentEdges.add(EndpointPair.ordered(N1, N2));
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));
    }
  }
<A NAME="7"></A>
  @Test
  public void predecessors_oneEdge() {
    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#7',2,'match133772-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>putEdge(N1, N2);
    assertThat(graph.predecessors(N2)).containsExactly(N1);
    // Edge direction handled correctly
    assertThat(graph.predecessors(N1)).isEmpty();
  }

  @Test</B></FONT>
  public void successors_oneEdge() {
    putEdge(N1, N2);
    assertThat(graph.successors(N1)).containsExactly(N2);
    // Edge direction handled correctly
    assertThat(graph.successors(N2)).isEmpty();
  }
<A NAME="5"></A>
  @Test
  public void incidentEdges_oneEdge() {
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#5',2,'match133772-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>putEdge(N1, N2);
    EndpointPair&lt;Integer&gt; expectedEndpoints = EndpointPair.ordered(N1, N2);
    assertThat(graph.incidentEdges(N1)).containsExactly(expectedEndpoints);
    assertThat(graph.incidentEdges(N2)).containsExactly(expectedEndpoints);
  }

  @Test</B></FONT>
  public void inDegree_oneEdge() {
    putEdge(N1, N2);
    assertThat(graph.inDegree(N2)).isEqualTo(1);
    // Edge direction handled correctly
    assertThat(graph.inDegree(N1)).isEqualTo(0);
  }

  @Test
  public void outDegree_oneEdge() {
    putEdge(N1, N2);
    assertThat(graph.outDegree(N1)).isEqualTo(1);
    // Edge direction handled correctly
    assertThat(graph.outDegree(N2)).isEqualTo(0);
<A NAME="13"></A>  }

  @Test
  public void hasEdgeConnecting_correct() <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#13',2,'match133772-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    putEdge(N1, N2);
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N1, N2))).isTrue();
  }

  @Test</B></FONT>
  public void hasEdgeConnecting_backwards() {
    putEdge(N1, N2);
    assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(N2, N1))).isFalse();
  }
<A NAME="6"></A>
  @Test
  public void hasEdgeConnecting_mismatch() {
    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#6',2,'match133772-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>putEdge(N1, N2);
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N1, N2))).isFalse();
    assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(N2, N1))).isFalse();
<A NAME="8"></A>  }

  @Test</B></FONT>
  public void adjacentNodes_selfLoop() <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#8',2,'match133772-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    putEdge(N1, N2);
    assertThat(graph.adjacentNodes</B></FONT>(N1)).containsExactly(N1, N2);
  }
<A NAME="3"></A>
  @Test
  public void predecessors_selfLoop() {
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#3',2,'match133772-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.predecessors(N1)).containsExactly(N1);
    putEdge(N4, N1);
    assertThat(graph.predecessors(N1)).containsExactly(N1, N4);
  }</B></FONT>

  @Test
  public void successors_selfLoop() {
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.successors(N1)).containsExactly(N1);
    putEdge(N1, N2);
    assertThat(graph.successors(N1)).containsExactly(N1, N2);
  }

  @Test
  public void incidentEdges_selfLoop() {
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.incidentEdges(N1)).containsExactly(EndpointPair.ordered(N1, N1));
    putEdge(N1, N2);
    assertThat(graph.incidentEdges(N1))
        .containsExactly(EndpointPair.ordered(N1, N1), EndpointPair.ordered(N1, N2));
  }

  @Test
  public void degree_selfLoop() {
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.degree(N1)).isEqualTo(2);
    putEdge(N1, N2);
    assertThat(graph.degree(N1)).isEqualTo(3);
  }

  @Test
  public void inDegree_selfLoop() {
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.inDegree(N1)).isEqualTo(1);
    putEdge(N4, N1);
    assertThat(graph.inDegree(N1)).isEqualTo(2);
  }

  @Test
  public void outDegree_selfLoop() {
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graph.outDegree(N1)).isEqualTo(1);
    putEdge(N1, N2);
    assertThat(graph.outDegree(N1)).isEqualTo(2);
  }

  // Stable order tests

  // Note: Stable order means that the ordering doesn't change between iterations and versions.
  // Ideally, the ordering in test should never be updated.
  @Test
  public void stableIncidentEdgeOrder_edges_returnsInStableOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);

    populateStarShapedGraph();

    assertThat(graph.edges())
        .containsExactly(
            EndpointPair.ordered(2, 1),
            EndpointPair.ordered(1, 4),
            EndpointPair.ordered(1, 3),
            EndpointPair.ordered(1, 2),
            EndpointPair.ordered(3, 1),
            EndpointPair.ordered(5, 1))
        .inOrder();
  }

  @Test
  public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);

    populateStarShapedGraph();

    assertThat(graph.adjacentNodes(1)).containsExactly(2, 4, 3, 5).inOrder();
  }

  @Test
  public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);

    populateStarShapedGraph();

    assertThat(graph.predecessors(1)).containsExactly(2, 5, 3).inOrder();
  }

  @Test
  public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);

    populateStarShapedGraph();

    assertThat(graph.successors(1)).containsExactly(4, 3, 2).inOrder();
  }

  @Test
  public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);

    populateStarShapedGraph();

    assertThat(graph.incidentEdges(1))
        .containsExactly(
            EndpointPair.ordered(2, 1),
            EndpointPair.ordered(1, 4),
            EndpointPair.ordered(1, 3),
            EndpointPair.ordered(5, 1),
            EndpointPair.ordered(1, 2),
            EndpointPair.ordered(3, 1))
        .inOrder();
  }

  @Test
  public void stableIncidentEdgeOrder_incidentEdges_withSelfLoop_returnsInEdgeInsertionOrder() {
    assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);
<A NAME="2"></A>    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(2, 1);
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#2',2,'match133772-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>putEdge(1, 1);
    putEdge(1, 3);
    putEdge(1, 2);

    assertThat(graph.incidentEdges(1))
        .containsExactly(
            EndpointPair.ordered(2, 1),
            EndpointPair.ordered(1, 1),
            EndpointPair.ordered(1, 3),
            EndpointPair.ordered(1, 2))
        .inOrder();
  }

  /**
   * Populates the graph with nodes and edges in a star shape with node `1` in the middle.
   *
   * &lt;p&gt;Note that the edges are added in a shuffled order to properly test the effect of the
   * insertion order.
   */
  private void populateStarShapedGraph() {</B></FONT>
    putEdge(2, 1);
    putEdge(1, 4);
    putEdge(1, 3);
    putEdge(5, 1);
    putEdge(1, 2);
    putEdge(3, 1);
  }

  // Element Mutation

  @Test
  public void putEdge_existingNodes() {
    assume().that(graphIsMutable()).isTrue();

    // Adding nodes initially for safety (insulating from possible future
    // modifications to proxy methods)
    addNode(N1);
    addNode(N2);

    assertThat(graphAsMutableGraph.putEdge(N1, N2)).isTrue();
  }

  @Test
  public void putEdge_existingEdgeBetweenSameNodes() {
    assume().that(graphIsMutable()).isTrue();

    assertThat(graphAsMutableGraph.putEdge(N1, N2)).isTrue();
    assertThat(graphAsMutableGraph.putEdge(N1, N2)).isFalse();
  }

  @Test
<A NAME="10"></A>  public void putEdge_orderMismatch() {
    assume().that(graphIsMutable()).isTrue();

    EndpointPair&lt;Integer&gt; endpoints = <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#10',2,'match133772-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>EndpointPair.unordered(N1, N2);
    try {
      graphAsMutableGraph.putEdge(endpoints);
      fail(&quot;Expected IllegalArgumentException: &quot; + ENDPOINTS_MISMATCH);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains</B></FONT>(ENDPOINTS_MISMATCH);
    }
  }

  /**
   * Tests that the method {@code putEdge} will silently add the missing nodes to the graph, then
   * add the edge connecting them. We are not using the proxy methods here as we want to test {@code
   * putEdge} when the end-points are not elements of the graph.
   */
  @Test
  public void putEdge_nodesNotInGraph() {
    assume().that(graphIsMutable()).isTrue();

    graphAsMutableGraph.addNode(N1);
    assertTrue(graphAsMutableGraph.putEdge(N1, N5));
    assertTrue(graphAsMutableGraph.putEdge(N4, N1));
    assertTrue(graphAsMutableGraph.putEdge(N2, N3));
    assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();
    assertThat(graph.successors(N1)).containsExactly(N5);
    assertThat(graph.successors(N2)).containsExactly(N3);
    assertThat(graph.successors(N3)).isEmpty();
    assertThat(graph.successors(N4)).containsExactly(N1);
    assertThat(graph.successors(N5)).isEmpty();
  }
<A NAME="0"></A>
  @Test
  public void putEdge_doesntAllowSelfLoops() {
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#0',2,'match133772-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assume().that(graphIsMutable()).isTrue();
    assume().that(graph.allowsSelfLoops()).isFalse();

    try {
      graphAsMutableGraph.putEdge(N1, N1);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains</B></FONT>(ERROR_SELF_LOOP);
    }
  }

  @Test
  public void putEdge_allowsSelfLoops() {
    assume().that(graphIsMutable()).isTrue();
    assume().that(graph.allowsSelfLoops()).isTrue();

    assertThat(graphAsMutableGraph.putEdge(N1, N1)).isTrue();
    assertThat(graph.successors(N1)).containsExactly(N1);
    assertThat(graph.predecessors(N1)).containsExactly(N1);
  }

  @Test
  public void putEdge_existingSelfLoopEdgeBetweenSameNodes() {
    assume().that(graphIsMutable()).isTrue();
    assume().that(graph.allowsSelfLoops()).isTrue();

    graphAsMutableGraph.putEdge(N1, N1);
    assertThat(graphAsMutableGraph.putEdge(N1, N1)).isFalse();
  }

  @Test
  public void removeEdge_antiparallelEdges() {
    assume().that(graphIsMutable()).isTrue();

    putEdge(N1, N2);
    putEdge(N2, N1);

    assertThat(graphAsMutableGraph.removeEdge(N1, N2)).isTrue();
    assertThat(graph.successors(N1)).isEmpty();
    assertThat(graph.predecessors(N1)).containsExactly(N2);
    assertThat(graph.edges()).hasSize(1);

    assertThat(graphAsMutableGraph.removeEdge(N2, N1)).isTrue();
    assertThat(graph.successors(N1)).isEmpty();
    assertThat(graph.predecessors(N1)).isEmpty();
    assertThat(graph.edges()).isEmpty();
  }

  @Test
  public void removeEdge_orderMismatch() {
<A NAME="9"></A>    assume().that(graphIsMutable()).isTrue();

    putEdge(N1, N2);
    EndpointPair&lt;Integer&gt; endpoints = <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match133772-0.html#9',2,'match133772-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>EndpointPair.unordered(N1, N2);
    try {
      graphAsMutableGraph.removeEdge(endpoints);
      fail(&quot;Expected IllegalArgumentException: &quot; + ENDPOINTS_MISMATCH);
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().contains</B></FONT>(ENDPOINTS_MISMATCH);
    }
  }

  @Test
  public void removeNode_existingNodeWithSelfLoopEdge() {
    assume().that(graphIsMutable()).isTrue();
    assume().that(graph.allowsSelfLoops()).isTrue();

    addNode(N1);
    putEdge(N1, N1);
    assertThat(graphAsMutableGraph.removeNode(N1)).isTrue();
    assertThat(graph.nodes()).isEmpty();
  }

  @Test
  public void removeEdge_existingSelfLoopEdge() {
    assume().that(graphIsMutable()).isTrue();
    assume().that(graph.allowsSelfLoops()).isTrue();

    putEdge(N1, N1);
    assertThat(graphAsMutableGraph.removeEdge(N1, N1)).isTrue();
    assertThat(graph.nodes()).containsExactly(N1);
    assertThat(graph.successors(N1)).isEmpty();
  }
}
</PRE>
</div>
  </div>
</body>
</html>
