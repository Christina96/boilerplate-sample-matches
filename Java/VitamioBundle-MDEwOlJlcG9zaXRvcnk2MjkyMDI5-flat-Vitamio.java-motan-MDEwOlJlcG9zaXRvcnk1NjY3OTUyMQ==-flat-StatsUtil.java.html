
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.4981949458483745%, Tokens: 10</h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Vitamio.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.content.Context;
3  import io.vov.vitamio.utils.CPU;
4  import io.vov.vitamio.utils.ContextUtils;
5  import io.vov.vitamio.utils.IOUtils;
6  import io.vov.vitamio.utils.Log;
7  import java.io.BufferedInputStream;
8  import java.io.BufferedReader;
9  import java.io.File;
10  import java.io.FileOutputStream;
11  import java.io.FileReader;
12  import java.io.FileWriter;
13  import java.io.IOException;
14  import java.io.InputStream;
15  import java.util.ArrayList;
16  import java.util.Arrays;
17  import java.util.List;
18  public class Vitamio {
19    private static final String[] LIBS_ARM_CODECS = {"libvvo.7.so", "libvvo.8.so", "libffmpeg.so", "libOMX.9.so", "libOMX.11.so", "libOMX.14.so", "libOMX.18.so"};
20    private static final String[] LIBS_X86_CODECS = {"libffmpeg.so", "libOMX.9.so", "libOMX.14.so", "libOMX.18.so"};
21    private static final String[] LIBS_MIPS_CODECS = {"libffmpeg.so", "libOMX.14.so"};
22    private static final String[] LIBS_PLAYER = {"libvplayer.so"};
23    private static final String[] LIBS_SCANNER = {"libvscanner.so"};
24    private static final String[] LIBS_AV = {"libvao.0.so", "libvvo.0.so", "libvvo.9.so", "libvvo.j.so"};
<span onclick='openModal()' class='match'>25    private static final String LIBS_LOCK = ".lock";
26    private static final int VITAMIO_NOT_SUPPORTED = -1;
27    private static final int VITAMIO_MIPS = 40;
28    private static final int VITAMIO_X86 = 50;
29    private static final int VITAMIO_ARMV6 = 60;
30    private static final int VITAMIO_ARMV6_VFP = 61;
31    private static final int VITAMIO_ARMV7_VFPV3 = 70;
32    private static final int VITAMIO_ARMV7_NEON = 71;
33    private static final int vitamioType;
34    static {
35      int cpu = CPU.getFeature();
</span>36      if ((cpu & CPU.FEATURE_ARM_NEON) > 0)
37        vitamioType = VITAMIO_ARMV7_NEON;
38      else if ((cpu & CPU.FEATURE_ARM_VFPV3) > 0 && (cpu & CPU.FEATURE_ARM_V7A) > 0)
39        vitamioType = VITAMIO_ARMV7_VFPV3;
40      else if ((cpu & CPU.FEATURE_ARM_VFP) > 0 && (cpu & CPU.FEATURE_ARM_V6) > 0)
41        vitamioType = VITAMIO_ARMV6_VFP;
42      else if ((cpu & CPU.FEATURE_ARM_V6) > 0)
43      	vitamioType = VITAMIO_ARMV6;
44      else if ((cpu & CPU.FEATURE_X86) > 0)
45      	vitamioType = VITAMIO_X86;
46      else if ((cpu & CPU.FEATURE_MIPS) > 0) 
47      	vitamioType = VITAMIO_MIPS;
48      else
49      	vitamioType = VITAMIO_NOT_SUPPORTED;
50    }
51    private static String vitamioPackage;
52    private static String vitamioLibraryPath;
53    public static boolean initialize(Context ctx) {
54      return isInitialized(ctx) || extractLibs(ctx, R.raw.libarm);
55    }
56    public static boolean initialize(Context ctx, int rawId) {
57      return isInitialized(ctx) || extractLibs(ctx, rawId);
58    }
59    public static boolean isInitialized(Context ctx) {
60      vitamioPackage = ctx.getPackageName();
61      vitamioLibraryPath = ContextUtils.getDataDir(ctx) + "libs/";
62      File dir = new File(getLibraryPath());
63      if (dir.exists() && dir.isDirectory()) {
64        String[] libs = dir.list();
65        if (libs != null) {
66          Arrays.sort(libs);
67          for (String L : getRequiredLibs()) {
68            if (Arrays.binarySearch(libs, L) < 0) {
69              Log.e("Native libs %s not exists!", L);
70              return false;
71            }
72          }
73          File lock = new File(getLibraryPath() + LIBS_LOCK);
74          BufferedReader buffer = null; 
75          try {
76            buffer = new BufferedReader(new FileReader(lock));  
77            int appVersion = ContextUtils.getVersionCode(ctx);
78            int libVersion = Integer.valueOf(buffer.readLine());  
79            Log.i("isNativeLibsInited, APP VERSION: %d, Vitamio Library version: %d", appVersion, libVersion);
80            if (libVersion == appVersion)
81              return true;
82          } catch (IOException e) {
83            Log.e("isNativeLibsInited", e);
84          } catch (NumberFormatException e) {
85          	Log.e("isNativeLibsInited", e);
86          } finally {
87            IOUtils.closeSilently(buffer);
88          }
89        }
90      }
91      return false;
92    }
93    public static String getVitamioPackage() {
94      return vitamioPackage;
95    }
96    public static int getVitamioType() {
97      return vitamioType;
98    }
99    public static final String getLibraryPath() {
100      return vitamioLibraryPath;
101    }
102    private static final List<String> getRequiredLibs() {
103      List<String> libs = new ArrayList<String>();
104      String[][] vitamioLibs = null;
105      switch (vitamioType) {
106  		case VITAMIO_ARMV6:
107  		case VITAMIO_ARMV6_VFP:
108  		case VITAMIO_ARMV7_VFPV3:
109  		case VITAMIO_ARMV7_NEON:
110  			vitamioLibs = new String[][]{LIBS_ARM_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
111  			break;
112  		case VITAMIO_X86:
113  			vitamioLibs = new String[][]{LIBS_X86_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
114  			break;
115  		case VITAMIO_MIPS:
116  			vitamioLibs = new String[][]{LIBS_MIPS_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
117  			break;
118  		default:
119  			break;
120  		}
121      if (vitamioLibs == null)
122      	return libs;
123      for (String[] libArray : vitamioLibs) {
124        for (String lib : libArray)
125          libs.add(lib);
126      }
127      libs.add(LIBS_LOCK);
128      return libs;
129    }
130    private static boolean extractLibs(Context ctx, int rawID) {
131      long begin = System.currentTimeMillis();
132      final int version = ContextUtils.getVersionCode(ctx);
133      Log.d("loadLibs start " + version);
134      File lock = new File(getLibraryPath() + LIBS_LOCK);
135      if (lock.exists())
136        lock.delete();
137      String libPath = copyCompressedLib(ctx, rawID, "libarm.so");
138      Log.d("copyCompressedLib time: " + (System.currentTimeMillis() - begin) / 1000.0);
139      boolean inited = native_initializeLibs(libPath, getLibraryPath(), String.valueOf(Vitamio.getVitamioType()));
140      new File(libPath).delete();
141      FileWriter fw = null;
142      try {
143        lock.createNewFile();
144        fw = new FileWriter(lock);
145        fw.write(String.valueOf(version));
146        return true;
147      } catch (IOException e) {
148        Log.e("Error creating lock file", e);
149      } finally {
150        Log.d("initializeNativeLibs: " + inited);
151        Log.d("loadLibs time: " + (System.currentTimeMillis() - begin) / 1000.0);
152        IOUtils.closeSilently(fw);
153      }
154      return false;
155    }
156    private static String copyCompressedLib(Context ctx, int rawID, String destName) {
157      byte[] buffer = new byte[1024];
158      InputStream is = null;
159      BufferedInputStream bis = null;
160      FileOutputStream fos = null;
161      String destPath = null;
162      try {
163        try {
164          String destDir = getLibraryPath();
165          destPath = destDir + destName;
166          File f = new File(destDir);
167          if (f.exists() && !f.isDirectory())
168            f.delete();
169          if (!f.exists())
170            f.mkdirs();
171          f = new File(destPath);
172          if (f.exists() && !f.isFile())
173            f.delete();
174          if (!f.exists())
175            f.createNewFile();
176        } catch (Exception fe) {
177          Log.e("loadLib", fe);
178        }
179        is = ctx.getResources().openRawResource(rawID);
180        bis = new BufferedInputStream(is);
181        fos = new FileOutputStream(destPath);
182        while (bis.read(buffer) != -1) {
183          fos.write(buffer);
184        }
185      } catch (Exception e) {
186        Log.e("loadLib", e);
187        return null;
188      } finally {
189        IOUtils.closeSilently(fos);
190        IOUtils.closeSilently(bis);
191        IOUtils.closeSilently(is);
192      }
193      return destPath;
194    }
195    static {
196      System.loadLibrary("vinit");
197    }
198    private native static boolean native_initializeLibs(String libPath, String destDir, String prefix);
199  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.util;
2  import com.codahale.metrics.Histogram;
3  import com.codahale.metrics.MetricRegistry;
4  import com.codahale.metrics.Snapshot;
5  import com.weibo.api.motan.closable.Closable;
6  import com.weibo.api.motan.closable.ShutDownHook;
7  import com.weibo.api.motan.common.MotanConstants;
8  import com.weibo.api.motan.common.URLParamType;
9  import com.weibo.api.motan.util.StatsUtil.AccessStatus;
10  import org.apache.commons.lang3.StringUtils;
11  import java.text.DecimalFormat;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.concurrent.*;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import static com.weibo.api.motan.common.MotanConstants.APPLICATION_STATISTIC;
17  public class StatsUtil {
18      public static final String HISTOGRAM_NAME = MetricRegistry.name(AccessStatisticItem.class, "costTimeMillis");
19      public static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
20      public static String SEPARATE = "\\|";
21      protected static ConcurrentMap<String, AccessStatisticItem> accessStatistics = new ConcurrentHashMap<>();
22      protected static List<StatisticCallback> statisticCallbacks = new CopyOnWriteArrayList<>();
23      protected static ScheduledFuture<?> scheduledFuture;
24      static {
25          scheduledFuture = executorService.scheduleAtFixedRate(new Runnable() {
26              @Override
27              public void run() {
28                  logAccessStatistic(true);
29                  logMemoryStatistic();
30                  logStatisticCallback();
31              }
32          }, MotanConstants.STATISTIC_PEROID, MotanConstants.STATISTIC_PEROID, TimeUnit.SECONDS);
33          ShutDownHook.registerShutdownHook(new Closable() {
34              @Override
35              public void close() {
36                  if (!executorService.isShutdown()) {
37                      executorService.shutdown();
38                  }
39              }
40          });
41      }
42      public static void registryStatisticCallback(StatisticCallback callback) {
43          if (callback == null) {
44              LoggerUtil.warn("StatsUtil registryStatisticCallback is null");
45              return;
46          }
47          statisticCallbacks.add(callback);
48      }
49      public static void unRegistryStatisticCallback(StatisticCallback callback) {
50          if (callback == null) {
51              LoggerUtil.warn("StatsUtil unRegistryStatisticCallback is null");
52              return;
53          }
54          statisticCallbacks.remove(callback);
55      }
56      @Deprecated
57      public static void accessStatistic(String name, long currentTimeMillis, long costTimeMillis, long bizProcessTime,
58                                         AccessStatus accessStatus) {
59          accessStatistic(name, URLParamType.application.getValue(), URLParamType.module.getValue(), currentTimeMillis, costTimeMillis, bizProcessTime, accessStatus);
60      }
61      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
62                                         long bizProcessTime, AccessStatus accessStatus) {
63          accessStatistic(name, application, module, currentTimeMillis, costTimeMillis, bizProcessTime, MotanConstants.SLOW_COST, accessStatus);
64      }
65      public static void accessStatistic(String name, String application, String module, long currentTimeMillis, long costTimeMillis,
66                                         long bizProcessTime, int slowCost, AccessStatus accessStatus) {
67          if (name == null || name.isEmpty()) {
68              return;
69          }
70          if (StringUtils.isBlank(application)) {
71              application = URLParamType.application.getValue();
72          }
73          if (StringUtils.isBlank(module)) {
74              module = URLParamType.module.getValue();
75          }
76          name = name + "|" + application + "|" + module;
77          try {
78              AccessStatisticItem item = getStatisticItem(name, currentTimeMillis);
79              item.statistic(currentTimeMillis, costTimeMillis, bizProcessTime, slowCost, accessStatus);
80          } catch (Exception e) {
81          }
82      }
83      public static AccessStatisticItem getStatisticItem(String name, long currentTime) {
84          AccessStatisticItem item = accessStatistics.get(name);
85          if (item == null) {
86              accessStatistics.putIfAbsent(name, new AccessStatisticItem(name, currentTime));
87              item = accessStatistics.get(name);
88          }
89          return item;
90      }
91      public static ConcurrentMap<String, AccessStatisticResult> getTotalAccessStatistic() {
92          return getTotalAccessStatistic(MotanConstants.STATISTIC_PEROID);
93      }
94      public static ConcurrentMap<String, AccessStatisticResult> getTotalAccessStatistic(int peroid) {
95          if (peroid > MotanConstants.STATISTIC_PEROID) {
96              throw new RuntimeException("peroid need <= " + MotanConstants.STATISTIC_PEROID);
97          }
98          long currentTimeMillis = System.currentTimeMillis();
99          ConcurrentMap<String, AccessStatisticResult> totalResults = new ConcurrentHashMap<>();
100          for (Map.Entry<String, AccessStatisticItem> entry : accessStatistics.entrySet()) {
101              AccessStatisticItem item = entry.getValue();
102              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
103              String key = entry.getKey();
104              String[] keys = key.split(SEPARATE);
105              if (keys.length != 3) {
106                  continue;
107              }
108              String application = keys[1];
109              String module = keys[2];
110              key = application + "|" + module;
111              AccessStatisticResult appResult = totalResults.get(key);
112              if (appResult == null) {
113                  totalResults.putIfAbsent(key, new AccessStatisticResult());
114                  appResult = totalResults.get(key);
115              }
116              appResult.totalCount += result.totalCount;
117              appResult.bizExceptionCount += result.bizExceptionCount;
118              appResult.slowCount += result.slowCount;
119              appResult.costTime += result.costTime;
120              appResult.bizTime += result.bizTime;
121              appResult.otherExceptionCount += result.otherExceptionCount;
122          }
123          return totalResults;
124      }
125      public static void logAccessStatistic(boolean clear) {
126          DecimalFormat mbFormat = new DecimalFormat("#0.00");
127          long currentTimeMillis = System.currentTimeMillis();
128          ConcurrentMap<String, AccessStatisticResult> totalResults = new ConcurrentHashMap<>();
129          for (Map.Entry<String, AccessStatisticItem> entry : accessStatistics.entrySet()) {
130              AccessStatisticItem item = entry.getValue();
131              AccessStatisticResult result = item.getStatisticResult(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
132              if (clear) {
133                  item.clearStatistic(currentTimeMillis, MotanConstants.STATISTIC_PEROID);
134              }
135              String key = entry.getKey();
136              String[] keys = key.split(SEPARATE);
137              if (keys.length != 3) {
138                  continue;
139              }
140              String application = keys[1];
141              String module = keys[2];
142              key = application + "|" + module;
143              AccessStatisticResult appResult = totalResults.get(key);
144              if (appResult == null) {
145                  totalResults.putIfAbsent(key, new AccessStatisticResult());
146                  appResult = totalResults.get(key);
147              }
148              appResult.totalCount += result.totalCount;
149              appResult.bizExceptionCount += result.bizExceptionCount;
150              appResult.slowCount += result.slowCount;
151              appResult.costTime += result.costTime;
152              appResult.bizTime += result.bizTime;
153              appResult.otherExceptionCount += result.otherExceptionCount;
154              Snapshot snapshot = InternalMetricsFactory.getRegistryInstance(entry.getKey())
155                      .histogram(HISTOGRAM_NAME).getSnapshot();
156              if (application.equals(APPLICATION_STATISTIC)) {
157                  continue;
158              }
159              if (result.totalCount == 0) {
160                  LoggerUtil.accessStatsLog("[motan-accessStatistic] app: " + application + " module: " + module + " item: " + keys[0]
161                          + " total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0 max_tps: 0 min_tps: 0");
162              } else {
163                  LoggerUtil.accessStatsLog(
164                          "[motan-accessStatistic] app: {} module: {} item: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {} max_tps: {} min_tps: {} ",
165                          application, module, keys[0], result.totalCount, result.slowCount,
166                          mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
167                          mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
168                          mbFormat.format(snapshot.get999thPercentile()), result.bizExceptionCount, result.otherExceptionCount,
169                          mbFormat.format(result.costTime / result.totalCount), mbFormat.format(result.bizTime / result.totalCount),
170                          (result.totalCount / MotanConstants.STATISTIC_PEROID), result.maxCount, result.minCount);
171              }
172          }
173          if (!totalResults.isEmpty()) {
174              for (Map.Entry<String, AccessStatisticResult> entry : totalResults.entrySet()) {
175                  String application = entry.getKey().split(SEPARATE)[0];
176                  String module = entry.getKey().split(SEPARATE)[1];
177                  AccessStatisticResult totalResult = entry.getValue();
178                  Snapshot snapshot =
179                          InternalMetricsFactory.getRegistryInstance(entry.getKey())
180                                  .histogram(HISTOGRAM_NAME).getSnapshot();
181                  if (totalResult.totalCount > 0) {
182                      LoggerUtil.accessStatsLog(
183                              "[motan-totalAccessStatistic] app: {} module: {} total_count: {} slow_count: {} p75: {} p95: {} p98: {} p99: {} p999: {} biz_excp: {} other_excp: {} avg_time: {}ms biz_time: {}ms avg_tps: {}",
184                              application, module, totalResult.totalCount, totalResult.slowCount,
185                              mbFormat.format(snapshot.get75thPercentile()), mbFormat.format(snapshot.get95thPercentile()),
186                              mbFormat.format(snapshot.get98thPercentile()), mbFormat.format(snapshot.get99thPercentile()),
187                              mbFormat.format(snapshot.get999thPercentile()), totalResult.bizExceptionCount,
188                              totalResult.otherExceptionCount, mbFormat.format(totalResult.costTime / totalResult.totalCount),
189                              mbFormat.format(totalResult.bizTime / totalResult.totalCount),
190                              (totalResult.totalCount / MotanConstants.STATISTIC_PEROID));
191                  } else {
192                      LoggerUtil.accessStatsLog("[motan-totalAccessStatistic] app: " + application + " module: " + module
193                              + " total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0");
194                  }
195              }
196          } else {
197              LoggerUtil.accessStatsLog("[motan-totalAccessStatistic] app: " + URLParamType.application.getValue() + " module: " + URLParamType.module.getValue()
198                      + " total_count: 0 slow_count: 0 biz_excp: 0 other_excp: 0 avg_time: 0.00ms biz_time: 0.00ms avg_tps: 0");
199          }
200      }
201      public static void logMemoryStatistic() {
202          LoggerUtil.accessStatsLog("[motan-memoryStatistic] {} ", memoryStatistic());
203      }
204      public static String memoryStatistic() {
205          Runtime runtime = Runtime.getRuntime();
206          double freeMemory = (double) runtime.freeMemory() / (1024 * 1024);
207          double maxMemory = (double) runtime.maxMemory() / (1024 * 1024);
208          double totalMemory = (double) runtime.totalMemory() / (1024 * 1024);
209          double usedMemory = totalMemory - freeMemory;
210          double percentFree = ((maxMemory - usedMemory) / maxMemory) * 100.0;
211          double percentUsed = 100 - percentFree;
212          DecimalFormat mbFormat = new DecimalFormat("#0.00");
213          DecimalFormat percentFormat = new DecimalFormat("#0.0");
214          StringBuilder sb = new StringBuilder();
215          sb.append(mbFormat.format(usedMemory)).append("MB of ").append(mbFormat.format(maxMemory)).append(" MB (")
216                  .append(percentFormat.format(percentUsed)).append("%) used");
217          return sb.toString();
218      }
219      public static void logStatisticCallback() {
220          for (StatisticCallback callback : statisticCallbacks) {
221              try {
222                  String msg = callback.statisticCallback();
223                  if (msg != null && !msg.isEmpty()) {
224                      LoggerUtil.accessStatsLog("[motan-statisticCallback] {}", msg);
225                  }
226              } catch (Exception e) {
227                  LoggerUtil.error("StatsUtil logStatisticCallback Error: " + e.getMessage(), e);
228              }
229          }
230      }
231      public enum AccessStatus {
232          NORMAL, BIZ_EXCEPTION, OTHER_EXCEPTION
233      }
234  }
235  class AccessStatisticItem {
<span onclick='openModal()' class='match'>236      private String name;
237      private int currentIndex;
238      private AtomicInteger[] costTimes = null;
239      private AtomicInteger[] bizProcessTimes = null;
240      private AtomicInteger[] totalCounter = null;
241      private AtomicInteger[] slowCounter = null;
242      private AtomicInteger[] bizExceptionCounter = null;
243      private AtomicInteger[] otherExceptionCounter = null;
244      private Histogram histogram = null;
245      private int length;
</span>246      public AccessStatisticItem(String name, long currentTimeMillis) {
247          this(name, currentTimeMillis, MotanConstants.STATISTIC_PEROID * 2);
248      }
249      public AccessStatisticItem(String name, long currentTimeMillis, int length) {
250          this.name = name;
251          this.costTimes = initAtomicIntegerArr(length);
252          this.bizProcessTimes = initAtomicIntegerArr(length);
253          this.totalCounter = initAtomicIntegerArr(length);
254          this.slowCounter = initAtomicIntegerArr(length);
255          this.bizExceptionCounter = initAtomicIntegerArr(length);
256          this.otherExceptionCounter = initAtomicIntegerArr(length);
257          this.length = length;
258          this.currentIndex = getIndex(currentTimeMillis, length);
259          this.histogram =
260                  InternalMetricsFactory.getRegistryInstance(name)
261                          .histogram(StatsUtil.HISTOGRAM_NAME);
262      }
263      private AtomicInteger[] initAtomicIntegerArr(int size) {
264          AtomicInteger[] arrs = new AtomicInteger[size];
265          for (int i = 0; i < arrs.length; i++) {
266              arrs[i] = new AtomicInteger(0);
267          }
268          return arrs;
269      }
270      void statistic(long currentTimeMillis, long costTimeMillis, long bizProcessTime, int slowCost, AccessStatus accessStatus) {
271          int tempIndex = getIndex(currentTimeMillis, length);
272          if (currentIndex != tempIndex) {
273              synchronized (this) {
274                  if (currentIndex != tempIndex) {
275                      reset(tempIndex);
276                      currentIndex = tempIndex;
277                  }
278              }
279          }
280          costTimes[currentIndex].addAndGet((int) costTimeMillis);
281          bizProcessTimes[currentIndex].addAndGet((int) bizProcessTime);
282          totalCounter[currentIndex].incrementAndGet();
283          if (costTimeMillis >= slowCost) {
284              slowCounter[currentIndex].incrementAndGet();
285          }
286          if (accessStatus == AccessStatus.BIZ_EXCEPTION) {
287              bizExceptionCounter[currentIndex].incrementAndGet();
288          } else if (accessStatus == AccessStatus.OTHER_EXCEPTION) {
289              otherExceptionCounter[currentIndex].incrementAndGet();
290          }
291          histogram.update(costTimeMillis);
292          String[] names = name.split("\\|");
293          String appName = names[1] + "|" + names[2];
294          InternalMetricsFactory.getRegistryInstance(appName).histogram(StatsUtil.HISTOGRAM_NAME)
295                  .update(costTimeMillis);
296      }
297      private int getIndex(long currentTimeMillis, int periodSecond) {
298          return (int) ((currentTimeMillis / 1000) % periodSecond);
299      }
300      private void reset(int index) {
301          costTimes[index].set(0);
302          totalCounter[index].set(0);
303          bizProcessTimes[index].set(0);
304          slowCounter[index].set(0);
305          bizExceptionCounter[index].set(0);
306          otherExceptionCounter[index].set(0);
307      }
308      AccessStatisticResult getStatisticResult(long currentTimeMillis, int peroidSecond) {
309          long currentTimeSecond = currentTimeMillis / 1000;
310          currentTimeSecond--; 
311          int startIndex = getIndex(currentTimeSecond * 1000, length);
312          AccessStatisticResult result = new AccessStatisticResult();
313          for (int i = 0; i < peroidSecond; i++) {
314              int currentIndex = (startIndex - i + length) % length;
315              result.costTime += costTimes[currentIndex].get();
316              result.bizTime += bizProcessTimes[currentIndex].get();
317              result.totalCount += totalCounter[currentIndex].get();
318              result.slowCount += slowCounter[currentIndex].get();
319              result.bizExceptionCount += bizExceptionCounter[currentIndex].get();
320              result.otherExceptionCount += otherExceptionCounter[currentIndex].get();
321              if (totalCounter[currentIndex].get() > result.maxCount) {
322                  result.maxCount = totalCounter[currentIndex].get();
323              } else if (totalCounter[currentIndex].get() < result.minCount || result.minCount == -1) {
324                  result.minCount = totalCounter[currentIndex].get();
325              }
326          }
327          return result;
328      }
329      void clearStatistic(long currentTimeMillis, int peroidSecond) {
330          long currentTimeSecond = currentTimeMillis / 1000;
331          currentTimeSecond--; 
332          int startIndex = getIndex(currentTimeSecond * 1000, length);
333          for (int i = 0; i < peroidSecond; i++) {
334              int currentIndex = (startIndex - i + length) % length;
335              reset(currentIndex);
336          }
337      }
338  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Vitamio.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StatsUtil.java</div>
                </div>
                <div class="column column_space"><pre><code>25    private static final String LIBS_LOCK = ".lock";
26    private static final int VITAMIO_NOT_SUPPORTED = -1;
27    private static final int VITAMIO_MIPS = 40;
28    private static final int VITAMIO_X86 = 50;
29    private static final int VITAMIO_ARMV6 = 60;
30    private static final int VITAMIO_ARMV6_VFP = 61;
31    private static final int VITAMIO_ARMV7_VFPV3 = 70;
32    private static final int VITAMIO_ARMV7_NEON = 71;
33    private static final int vitamioType;
34    static {
35      int cpu = CPU.getFeature();
</pre></code></div>
                <div class="column column_space"><pre><code>236      private String name;
237      private int currentIndex;
238      private AtomicInteger[] costTimes = null;
239      private AtomicInteger[] bizProcessTimes = null;
240      private AtomicInteger[] totalCounter = null;
241      private AtomicInteger[] slowCounter = null;
242      private AtomicInteger[] bizExceptionCounter = null;
243      private AtomicInteger[] otherExceptionCounter = null;
244      private Histogram histogram = null;
245      private int length;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    