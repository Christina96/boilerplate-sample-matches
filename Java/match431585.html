<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for MoveOrderBeneathFetchOrEval.java & SourceFieldMapper.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for MoveOrderBeneathFetchOrEval.java & SourceFieldMapper.java
      </h3>
      <h1 align="center">
        23.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>MoveOrderBeneathFetchOrEval.java (40.298508%)<TH>SourceFieldMapper.java (16.463415%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match431585-0.html#0',2,'match431585-1.html#0',3)" NAME="0">(28-46)<TD><A HREF="javascript:ZweiFrames('match431585-0.html#0',2,'match431585-1.html#0',3)" NAME="0">(22-39)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match431585-0.html#1',2,'match431585-1.html#1',3)" NAME="1">(52-61)<TD><A HREF="javascript:ZweiFrames('match431585-0.html#1',2,'match431585-1.html#1',3)" NAME="1">(133-141)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoveOrderBeneathFetchOrEval.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.planner.optimizer.rule;

import io.crate.expression.symbol.Symbol;
<A NAME="0"></A>import io.crate.metadata.NodeContext;
import io.crate.metadata.TransactionContext;
import io.crate.planner.operators.Eval;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match431585-1.html#0',3,'match431585-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.planner.operators.LogicalPlan;
import io.crate.planner.operators.Order;
import io.crate.planner.optimizer.Rule;
import io.crate.planner.optimizer.matcher.Capture;
import io.crate.planner.optimizer.matcher.Captures;
import io.crate.planner.optimizer.matcher.Pattern;
import io.crate.statistics.TableStats;

import java.util.List;

import static io.crate.planner.operators.LogicalPlanner.extractColumns;
import static io.crate.planner.optimizer.matcher.Pattern.typeOf;
import static io.crate.planner.optimizer.matcher.Patterns.source;
import static io.crate.planner.optimizer.rule.Util.transpose;

public final class MoveOrderBeneathFetchOrEval implements Rule&lt;Order&gt; {

    private final Capture&lt;Eval&gt; fetchCapture;
    private final Pattern&lt;Order&gt; pattern</B></FONT>;

    public MoveOrderBeneathFetchOrEval() {
<A NAME="1"></A>        this.fetchCapture = new Capture&lt;&gt;();
        this.pattern = typeOf(Order.class)
            .with(source(), typeOf(Eval.class).capturedAs(fetchCapture));
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match431585-1.html#1',3,'match431585-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public Pattern&lt;Order&gt; pattern() {
        return pattern;
    }

    @Override
    public LogicalPlan apply(Order plan,
                             Captures captures</B></FONT>,
                             TableStats tableStats,
                             TransactionContext txnCtx,
                             NodeContext nodeCtx) {
        Eval eval = captures.get(fetchCapture);
        List&lt;Symbol&gt; outputsOfSourceOfFetch = eval.source().outputs();
        List&lt;Symbol&gt; orderBySymbols = plan.orderBy().orderBySymbols();
        if (outputsOfSourceOfFetch.containsAll(orderBySymbols)
            || outputsOfSourceOfFetch.containsAll(extractColumns(orderBySymbols))) {
            return transpose(plan, eval);
        }
        return null;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SourceFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
<A NAME="0"></A>
package org.elasticsearch.index.mapper;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match431585-0.html#0',2,'match431585-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.NumericDocValuesField;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.XContentBuilder;

public class SourceFieldMapper extends MetadataFieldMapper {

    public static final String NAME = &quot;_source&quot;;
    public static final String RECOVERY_SOURCE_NAME = &quot;_recovery_source&quot;</B></FONT>;

    public static final String CONTENT_TYPE = &quot;_source&quot;;

    public static class Defaults {
        public static final String NAME = SourceFieldMapper.NAME;

        public static final FieldType FIELD_TYPE = new FieldType();

        static {
            FIELD_TYPE.setIndexOptions(IndexOptions.NONE); // not indexed
            FIELD_TYPE.setStored(true);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.freeze();
        }

    }

    public static class Builder extends MetadataFieldMapper.Builder&lt;Builder&gt; {


        public Builder() {
            super(Defaults.NAME, new FieldType(Defaults.FIELD_TYPE));
        }

        @Override
        public SourceFieldMapper build(BuilderContext context) {
            return new SourceFieldMapper(context.indexSettings());
        }
    }

    public static class TypeParser implements MetadataFieldMapper.TypeParser {

        @Override
        public MetadataFieldMapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node, ParserContext parserContext) throws MapperParsingException {
            return new Builder();
        }

        @Override
        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {
            final Settings indexSettings = context.mapperService().getIndexSettings().getSettings();
            return new SourceFieldMapper(indexSettings);
        }
    }

    static final class SourceFieldType extends MappedFieldType {

        public static final SourceFieldType INSTANCE = new SourceFieldType();

        private SourceFieldType() {
            super(NAME, false, false);
        }

        @Override
        public String typeName() {
            return CONTENT_TYPE;
        }

    }


    private SourceFieldMapper(Settings indexSettings) {
        super(Defaults.FIELD_TYPE, SourceFieldType.INSTANCE, indexSettings);
    }

    @Override
    public void preParse(ParseContext context) throws IOException {
        super.parse(context);
    }

    @Override
    public void parse(ParseContext context) throws IOException {
        // nothing to do here, we will call it in pre parse
    }

    @Override
    protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
        BytesReference originalSource = context.sourceToParse().source();
        BytesReference source = originalSource;
        if (fieldType.stored() &amp;&amp; source != null) {
            // Percolate and tv APIs may not set the source and that is ok, because these APIs will not index any data
            BytesRef ref = source.toBytesRef();
            fields.add(new StoredField(fieldType().name(), ref.bytes, ref.offset, ref.length));
        } else {
            source = null;
        }

        if (originalSource != null &amp;&amp; source != originalSource &amp;&amp; context.indexSettings().isSoftDeleteEnabled()) {
            // if we omitted source or modified it we add the _recovery_source to ensure we
            // have it for ops based recovery
            BytesRef ref = originalSource.toBytesRef();
<A NAME="1"></A>            fields.add(new StoredField(RECOVERY_SOURCE_NAME, ref.bytes, ref.offset, ref.length));
            fields.add(new NumericDocValuesField(RECOVERY_SOURCE_NAME, 1));
        }
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match431585-0.html#1',2,'match431585-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    protected String contentType() {
        return CONTENT_TYPE;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params</B></FONT>) throws IOException {
        return builder;
    }

    @Override
    protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts) {
    }
}
</PRE>
</div>
  </div>
</body>
</html>
