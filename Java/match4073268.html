<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for StopWatch.java &amp; CoordinatorTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for StopWatch.java &amp; CoordinatorTests.java
      </h3>
<h1 align="center">
        4.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>StopWatch.java (21.052631%)<th>CoordinatorTests.java (2.2222223%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(205-208)<td><a href="#" name="0">(811-817)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(220-222)<td><a href="#" name="1">(388-402)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(194-203)<td><a href="#" name="2">(1242-1247)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>StopWatch.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.common;
2 import io.crate.common.unit.TimeValue;
3 import org.elasticsearch.common.lease.Releasable;
4 import java.text.NumberFormat;
5 import java.util.LinkedList;
6 import java.util.List;
7 import java.util.Locale;
8 import java.util.concurrent.TimeUnit;
9 public class StopWatch {
10     private final String id;
11     private final List&lt;TaskInfo&gt; taskList = new LinkedList&lt;&gt;();
12     private long startTimeNS;
13     private boolean running;
14     private String currentTaskName;
15     private TaskInfo lastTaskInfo;
16     private long totalTimeNS;
17     public StopWatch() {
18         this.id = "";
19     }
20     public StopWatch(String id) {
21         this.id = id;
22     }
23     public StopWatch start() throws IllegalStateException {
24         return start("");
25     }
26     public StopWatch start(String taskName) throws IllegalStateException {
27         if (this.running) {
28             throw new IllegalStateException("Can't start StopWatch: it's already running");
29         }
30         this.startTimeNS = System.nanoTime();
31         this.running = true;
32         this.currentTaskName = taskName;
33         return this;
34     }
35     public StopWatch stop() throws IllegalStateException {
36         if (!this.running) {
37             throw new IllegalStateException("Can't stop StopWatch: it's not running");
38         }
39         long lastTimeNS = System.nanoTime() - this.startTimeNS;
40         this.totalTimeNS += lastTimeNS;
41         this.lastTaskInfo = new TaskInfo(this.currentTaskName, TimeValue.nsecToMSec(lastTimeNS));
42         this.taskList.add(lastTaskInfo);
43         this.running = false;
44         this.currentTaskName = null;
45         return this;
46     }
47     public Releasable timing(String taskName) {
48         start(taskName);
49         return this::stop;
50     }
51     public boolean isRunning() {
52         return this.running;
53     }
54     public TimeValue lastTaskTime() throws IllegalStateException {
55         if (this.lastTaskInfo == null) {
56             throw new IllegalStateException("No tests run: can't get last interval");
57         }
58         return this.lastTaskInfo.getTime();
59     }
60     public TimeValue totalTime() {
61         return new TimeValue(totalTimeNS, TimeUnit.NANOSECONDS);
62     }
63     public TaskInfo[] taskInfo() {
64         return this.taskList.toArray(new TaskInfo[0]);
65     }
66     public String shortSummary() {
67         return "StopWatch '" + this.id + "': running time  = " + totalTime();
68     }
69     public String prettyPrint() {
70         StringBuilder sb = new StringBuilder(shortSummary());
71         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sb.append('\n');
72         sb.append("-----------------------------------------\n");
73         sb.append("ms     %     Task name\n");
74         sb.append("-----------------------------------------\n");
75         NumberFormat nf = NumberFormat.getNumberInstance(Locale.ROOT);
76         nf.setMinimumIntegerDigits(5);
77         nf.setGroupingUsed(false);
78         NumberFormat pf = NumberFormat.getPercentInstance(Locale.ROOT);
79 <a name="0"></a>        pf.setMinimumIntegerDigits(3);
80         pf.setGroupingUsed</b></font>(false);
81         for (TaskInfo task : taskInfo()) {
82             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sb.append(nf.format(task.getTime().millis())).append("  ");
83             sb.append(pf.format(task.getTime().secondsFrac() / totalTime().secondsFrac())).append("  ");
84             sb.append(task.getTaskName()).append("\n");
85         }</b></font>
86         return sb.toString();
87     }
88     @Override
89 <a name="1"></a>    public String toString() {
90         StringBuilder sb = new StringBuilder(shortSummary());
91         for (TaskInfo task : taskInfo()) {
92             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>sb.append("; [").append(task.getTaskName()).append("] took ").append(task.getTime());
93             long percent = Math.round((100.0f * task.getTime().millis()) / totalTime().millis());
94             sb.append</b></font>(" = ").append(percent).append("%");
95         }
96         return sb.toString();
97     }
98     public static class TaskInfo {
99         private final String taskName;
100         private final TimeValue timeValue;
101         private TaskInfo(String taskName, long timeMillis) {
102             this.taskName = taskName;
103             this.timeValue = new TimeValue(timeMillis, TimeUnit.MILLISECONDS);
104         }
105         public String getTaskName() {
106             return taskName;
107         }
108         public TimeValue getTime() {
109             return timeValue;
110         }
111     }
112 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CoordinatorTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.cluster.coordination;
2 import static org.elasticsearch.cluster.coordination.AbstractCoordinatorTestCase.Cluster.DEFAULT_DELAY_VARIABILITY;
3 import static org.elasticsearch.cluster.coordination.Coordinator.PUBLISH_TIMEOUT_SETTING;
4 import static org.elasticsearch.cluster.coordination.Coordinator.Mode.CANDIDATE;
5 import static org.elasticsearch.cluster.coordination.ElectionSchedulerFactory.ELECTION_INITIAL_TIMEOUT_SETTING;
6 import static org.elasticsearch.cluster.coordination.FollowersChecker.FOLLOWER_CHECK_INTERVAL_SETTING;
7 import static org.elasticsearch.cluster.coordination.FollowersChecker.FOLLOWER_CHECK_RETRY_COUNT_SETTING;
8 import static org.elasticsearch.cluster.coordination.FollowersChecker.FOLLOWER_CHECK_TIMEOUT_SETTING;
9 import static org.elasticsearch.cluster.coordination.LeaderChecker.LEADER_CHECK_INTERVAL_SETTING;
10 import static org.elasticsearch.cluster.coordination.LeaderChecker.LEADER_CHECK_RETRY_COUNT_SETTING;
11 import static org.elasticsearch.cluster.coordination.LeaderChecker.LEADER_CHECK_TIMEOUT_SETTING;
12 import static org.elasticsearch.cluster.coordination.NoMasterBlockService.NO_MASTER_BLOCK_ALL;
13 import static org.elasticsearch.cluster.coordination.NoMasterBlockService.NO_MASTER_BLOCK_SETTING;
14 import static org.elasticsearch.cluster.coordination.NoMasterBlockService.NO_MASTER_BLOCK_WRITES;
15 import static org.elasticsearch.cluster.coordination.Reconfigurator.CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION;
16 import static org.elasticsearch.discovery.PeerFinder.DISCOVERY_FIND_PEERS_INTERVAL_SETTING;
17 import static org.hamcrest.CoreMatchers.allOf;
18 import static org.hamcrest.Matchers.containsString;
19 import static org.hamcrest.Matchers.equalTo;
20 import static org.hamcrest.Matchers.hasItem;
21 import static org.hamcrest.Matchers.hasSize;
22 import static org.hamcrest.Matchers.instanceOf;
23 import static org.hamcrest.Matchers.is;
24 import static org.hamcrest.Matchers.not;
25 import static org.hamcrest.Matchers.startsWith;
26 import java.io.IOException;
27 import java.util.Arrays;
28 import java.util.Collections;
29 import java.util.HashSet;
30 import java.util.List;
31 import java.util.Map;
32 import java.util.Set;
33 import java.util.concurrent.atomic.AtomicBoolean;
34 import java.util.function.Function;
35 import java.util.stream.Collectors;
36 import org.apache.logging.log4j.Level;
37 import org.apache.logging.log4j.LogManager;
38 import org.apache.logging.log4j.Logger;
39 import org.apache.logging.log4j.core.LogEvent;
40 import org.apache.lucene.util.LuceneTestCase.AwaitsFix;
41 import org.elasticsearch.ElasticsearchException;
42 import org.elasticsearch.Version;
43 import org.elasticsearch.cluster.AbstractDiffable;
44 import org.elasticsearch.cluster.ClusterState;
45 import org.elasticsearch.cluster.block.ClusterBlock;
46 import org.elasticsearch.cluster.coordination.AbstractCoordinatorTestCase.Cluster.ClusterNode;
47 import org.elasticsearch.cluster.coordination.CoordinationMetadata.VotingConfiguration;
48 import org.elasticsearch.cluster.coordination.Coordinator.Mode;
49 import org.elasticsearch.cluster.metadata.Metadata;
50 import org.elasticsearch.cluster.node.DiscoveryNode;
51 import org.elasticsearch.common.io.stream.StreamOutput;
52 import org.elasticsearch.common.logging.Loggers;
53 import org.elasticsearch.common.regex.Regex;
54 import org.elasticsearch.common.settings.Settings;
55 import org.elasticsearch.common.settings.Settings.Builder;
56 import org.elasticsearch.common.xcontent.XContentBuilder;
57 import org.elasticsearch.discovery.DiscoveryModule;
58 import org.elasticsearch.gateway.GatewayService;
59 import org.elasticsearch.node.Node;
60 import org.elasticsearch.test.MockLogAppender;
61 @AwaitsFix(bugUrl = "https://github.com/crate/crate/issues/10811")
62 public class CoordinatorTests extends AbstractCoordinatorTestCase {
63     public void testStateRecoveryResetAfterPreviousLeadership() {
64         try (Cluster cluster = new Cluster(3)) {
65             cluster.runRandomly();
66             cluster.stabilise();
67             final ClusterNode leader = cluster.getAnyLeader();
68             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader);
69             final ClusterNode follower2 = cluster.getAnyNodeExcept(leader, follower1);
70             for (ClusterNode clusterNode : Arrays.asList(follower1, follower2)) {
71                 clusterNode.close();
72                 cluster.clusterNodes.forEach(
73                     cn -&gt; cluster.deterministicTaskQueue.scheduleNow(cn.onNode(
74                         new Runnable() {
75                             @Override
76                             public void run() {
77                                 cn.transportService.disconnectFromNode(clusterNode.getLocalNode());
78                             }
79                             @Override
80                             public String toString() {
81                                 return "disconnect from " + clusterNode.getLocalNode() + " after shutdown";
82                             }
83                         })));
84                 cluster.clusterNodes.replaceAll(cn -&gt; cn == clusterNode ? cn.restartedNode() : cn);
85             }
86             cluster.stabilise();
87         }
88     }
89     public void testCanUpdateClusterStateAfterStabilisation() {
90         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
91             cluster.runRandomly();
92             cluster.stabilise();
93             final ClusterNode leader = cluster.getAnyLeader();
94             long finalValue = randomLong();
95             logger.info("--&gt; submitting value [{}] to [{}]", finalValue, leader);
96             leader.submitValue(finalValue);
97             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
98             for (final ClusterNode clusterNode : cluster.clusterNodes) {
99                 final String nodeId = clusterNode.getId();
100                 final ClusterState appliedState = clusterNode.getLastAppliedClusterState();
101                 assertThat(nodeId + " has the applied value", value(appliedState), is(finalValue));
102             }
103         }
104     }
105     public void testDoesNotElectNonMasterNode() {
106         try (Cluster cluster = new Cluster(randomIntBetween(1, 5), false, Settings.EMPTY)) {
107             cluster.runRandomly();
108             cluster.stabilise();
109             final ClusterNode leader = cluster.getAnyLeader();
110             assertTrue(leader.getLocalNode().isMasterEligibleNode());
111         }
112     }
113     public void testNodesJoinAfterStableCluster() {
114         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
115             cluster.runRandomly();
116             cluster.stabilise();
117             final long currentTerm = cluster.getAnyLeader().coordinator.getCurrentTerm();
118             cluster.addNodesAndStabilise(randomIntBetween(1, 2));
119             final long newTerm = cluster.getAnyLeader().coordinator.getCurrentTerm();
120             assertEquals(currentTerm, newTerm);
121         }
122     }
123     public void testExpandsConfigurationWhenGrowingFromOneNodeToThreeButDoesNotShrink() {
124         try (Cluster cluster = new Cluster(1)) {
125             cluster.runRandomly();
126             cluster.stabilise();
127             final ClusterNode leader = cluster.getAnyLeader();
128             cluster.addNodesAndStabilise(2);
129             {
130                 assertThat(leader.coordinator.getMode(), is(Mode.LEADER));
131                 final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();
132                 assertThat(lastCommittedConfiguration + " should be all nodes", lastCommittedConfiguration.getNodeIds(),
133                     equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));
134             }
135             final ClusterNode disconnect1 = cluster.getAnyNode();
136             logger.info("--&gt; disconnecting {}", disconnect1);
137             disconnect1.disconnect();
138             cluster.stabilise();
139             {
140                 final ClusterNode newLeader = cluster.getAnyLeader();
141                 final VotingConfiguration lastCommittedConfiguration
142                     = newLeader.getLastAppliedClusterState().getLastCommittedConfiguration();
143                 assertThat(lastCommittedConfiguration + " should be all nodes", lastCommittedConfiguration.getNodeIds(),
144                     equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));
145             }
146         }
147     }
148     public void testExpandsConfigurationWhenGrowingFromThreeToFiveNodesAndShrinksBackToThreeOnFailure() {
149         try (Cluster cluster = new Cluster(3)) {
150             cluster.runRandomly();
151             cluster.stabilise();
152             final ClusterNode leader = cluster.getAnyLeader();
153             logger.info("setting auto-shrink reconfiguration to true");
154             leader.submitSetAutoShrinkVotingConfiguration(true);
155             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
156             assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));
157             cluster.addNodesAndStabilise(2);
158             {
159                 assertThat(leader.coordinator.getMode(), is(Mode.LEADER));
160                 final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();
161                 assertThat(lastCommittedConfiguration + " should be all nodes", lastCommittedConfiguration.getNodeIds(),
162                     equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));
163             }
164             final ClusterNode disconnect1 = cluster.getAnyNode();
165             final ClusterNode disconnect2 = cluster.getAnyNodeExcept(disconnect1);
166             logger.info("--&gt; disconnecting {} and {}", disconnect1, disconnect2);
167             disconnect1.disconnect();
168             disconnect2.disconnect();
169             cluster.stabilise();
170             {
171                 final ClusterNode newLeader = cluster.getAnyLeader();
172                 final VotingConfiguration lastCommittedConfiguration
173                     = newLeader.getLastAppliedClusterState().getLastCommittedConfiguration();
174                 assertThat(lastCommittedConfiguration + " should be 3 nodes", lastCommittedConfiguration.getNodeIds().size(), equalTo(3));
175                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect1.getId()));
176                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect2.getId()));
177             }
178             final ClusterNode disconnect3 = cluster.getAnyNodeExcept(disconnect1, disconnect2);
179             logger.info("--&gt; disconnecting {}", disconnect3);
180             disconnect3.disconnect();
181             cluster.stabilise();
182             {
183                 final ClusterNode newLeader = cluster.getAnyLeader();
184                 final VotingConfiguration lastCommittedConfiguration
185                     = newLeader.getLastAppliedClusterState().getLastCommittedConfiguration();
186                 assertThat(lastCommittedConfiguration + " should be 3 nodes", lastCommittedConfiguration.getNodeIds().size(), equalTo(3));
187                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect1.getId()));
188                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect2.getId()));
189                 assertTrue(lastCommittedConfiguration.getNodeIds().contains(disconnect3.getId()));
190             }
191             final ClusterNode disconnect4 = cluster.getAnyNodeExcept(disconnect1, disconnect2, disconnect3);
192             logger.info("--&gt; disconnecting {}", disconnect4);
193             disconnect4.disconnect();
194             cluster.runFor(DEFAULT_STABILISATION_TIME, "allowing time for fault detection");
195             for (final ClusterNode clusterNode : cluster.clusterNodes) {
196                 assertThat(clusterNode.getId() + " should be a candidate", clusterNode.coordinator.getMode(), equalTo(Mode.CANDIDATE));
197             }
198             logger.info("--&gt; healing {} and {}", disconnect1, disconnect2);
199             disconnect1.heal();
200             disconnect2.heal();
201             cluster.runFor(DEFAULT_STABILISATION_TIME, "allowing time for fault detection");
202             for (final ClusterNode clusterNode : cluster.clusterNodes) {
203                 assertThat(clusterNode.getId() + " should be a candidate", clusterNode.coordinator.getMode(), equalTo(Mode.CANDIDATE));
204             }
205             final ClusterNode toHeal = randomBoolean() ? disconnect3 : disconnect4;
206             logger.info("--&gt; healing {}", toHeal);
207             toHeal.heal();
208             cluster.stabilise();
209         }
210     }
211     public void testCanShrinkFromFiveNodesToThree() {
212         try (Cluster cluster = new Cluster(5)) {
213             cluster.runRandomly();
214             cluster.stabilise();
215             {
216                 final ClusterNode leader = cluster.getAnyLeader();
217                 logger.info("setting auto-shrink reconfiguration to false");
218                 leader.submitSetAutoShrinkVotingConfiguration(false);
219                 cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
220                 assertFalse(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));
221             }
222             final ClusterNode disconnect1 = cluster.getAnyNode();
223             final ClusterNode disconnect2 = cluster.getAnyNodeExcept(disconnect1);
224             logger.info("--&gt; disconnecting {} and {}", disconnect1, disconnect2);
225             disconnect1.disconnect();
226             disconnect2.disconnect();
227             cluster.stabilise();
228             final ClusterNode leader = cluster.getAnyLeader();
229             {
230                 final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();
231                 assertThat(lastCommittedConfiguration + " should be all nodes", lastCommittedConfiguration.getNodeIds(),
232                     equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));
233             }
234             logger.info("setting auto-shrink reconfiguration to true");
235             leader.submitSetAutoShrinkVotingConfiguration(true);
236             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY * 2);             assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));
237             {
238                 final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();
239                 assertThat(lastCommittedConfiguration + " should be 3 nodes", lastCommittedConfiguration.getNodeIds().size(), equalTo(3));
240                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect1.getId()));
241                 assertFalse(lastCommittedConfiguration.getNodeIds().contains(disconnect2.getId()));
242             }
243         }
244     }
245     public void testDoesNotShrinkConfigurationBelowThreeNodes() {
246         try (Cluster cluster = new Cluster(3)) {
247             cluster.runRandomly();
248             cluster.stabilise();
249             final ClusterNode disconnect1 = cluster.getAnyNode();
250             logger.info("--&gt; disconnecting {}", disconnect1);
251             disconnect1.disconnect();
252             cluster.stabilise();
253             final ClusterNode disconnect2 = cluster.getAnyNodeExcept(disconnect1);
254             logger.info("--&gt; disconnecting {}", disconnect2);
255             disconnect2.disconnect();
256             cluster.runFor(DEFAULT_STABILISATION_TIME, "allowing time for fault detection");
257             for (final ClusterNode clusterNode : cluster.clusterNodes) {
258                 assertThat(clusterNode.getId() + " should be a candidate", clusterNode.coordinator.getMode(), equalTo(Mode.CANDIDATE));
259             }
260             disconnect1.heal();
261             cluster.stabilise();         }
262     }
263     public void testDoesNotShrinkConfigurationBelowFiveNodesIfAutoShrinkDisabled() {
264         try (Cluster cluster = new Cluster(5)) {
265             cluster.runRandomly();
266             cluster.stabilise();
267             cluster.getAnyLeader().submitSetAutoShrinkVotingConfiguration(false);
268             cluster.stabilise(DEFAULT_ELECTION_DELAY);
269             final ClusterNode disconnect1 = cluster.getAnyNode();
270             final ClusterNode disconnect2 = cluster.getAnyNodeExcept(disconnect1);
271             logger.info("--&gt; disconnecting {} and {}", disconnect1, disconnect2);
272             disconnect1.disconnect();
273             disconnect2.disconnect();
274             cluster.stabilise();
275             final ClusterNode disconnect3 = cluster.getAnyNodeExcept(disconnect1, disconnect2);
276             logger.info("--&gt; disconnecting {}", disconnect3);
277             disconnect3.disconnect();
278             cluster.runFor(DEFAULT_STABILISATION_TIME, "allowing time for fault detection");
279             for (final ClusterNode clusterNode : cluster.clusterNodes) {
280                 assertThat(clusterNode.getId() + " should be a candidate", clusterNode.coordinator.getMode(), equalTo(Mode.CANDIDATE));
281             }
282             disconnect1.heal();
283             cluster.stabilise();         }
284     }
285     public void testLeaderDisconnectionWithDisconnectEventDetectedQuickly() {
286         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
287 <a name="1"></a>            cluster.runRandomly();
288             cluster.stabilise();
289             final ClusterNode originalLeader = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cluster.getAnyLeader();
290             logger.info("--&gt; disconnecting leader {}", originalLeader);
291             originalLeader.disconnect();
292             logger.info("--&gt; followers get disconnect event for leader {} ", originalLeader);
293             cluster.getAllNodesExcept(originalLeader).forEach(cn -&gt; cn.onDisconnectEventFrom(originalLeader));
294             cluster.getAllNodesExcept(originalLeader).forEach(originalLeader::onDisconnectEventFrom);
295             cluster.stabilise(DEFAULT_DELAY_VARIABILITY                 + DEFAULT_ELECTION_DELAY
296                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
297                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
298             assertThat(cluster.getAnyLeader().getId(), not</b></font>(equalTo(originalLeader.getId())));
299         }
300     }
301     public void testLeaderDisconnectionWithoutDisconnectEventDetectedQuickly() {
302         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
303             cluster.runRandomly();
304             cluster.stabilise();
305             final ClusterNode originalLeader = cluster.getAnyLeader();
306             logger.info("--&gt; disconnecting leader {}", originalLeader);
307             originalLeader.disconnect();
308             cluster.stabilise(Math.max(
309                 defaultMillis(LEADER_CHECK_TIMEOUT_SETTING)
310                     + defaultMillis(LEADER_CHECK_INTERVAL_SETTING)
311                     + DEFAULT_DELAY_VARIABILITY
312                     + DEFAULT_ELECTION_DELAY,
313                 defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING)
314                     + defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING)
315                     + DEFAULT_DELAY_VARIABILITY)
316                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
317                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
318             assertThat(cluster.getAnyLeader().getId(), not(equalTo(originalLeader.getId())));
319         }
320     }
321     public void testUnresponsiveLeaderDetectedEventually() {
322         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
323             cluster.runRandomly();
324             cluster.stabilise();
325             final ClusterNode originalLeader = cluster.getAnyLeader();
326             logger.info("--&gt; blackholing leader {}", originalLeader);
327             originalLeader.blackhole();
328             cluster.stabilise(Math.max(
329                 (defaultMillis(LEADER_CHECK_INTERVAL_SETTING) + defaultMillis(LEADER_CHECK_TIMEOUT_SETTING))
330                     * defaultInt(LEADER_CHECK_RETRY_COUNT_SETTING)
331                     + DEFAULT_ELECTION_DELAY
332                     + defaultMillis(PUBLISH_TIMEOUT_SETTING)
333                     + DEFAULT_ELECTION_DELAY
334                     + Math.max(
335                     defaultMillis(PUBLISH_TIMEOUT_SETTING),
336                     (defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING) + defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING))
337                         * defaultInt(FOLLOWER_CHECK_RETRY_COUNT_SETTING))
338                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
339                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,
340                 (defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING) + defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING))
341                     * defaultInt(FOLLOWER_CHECK_RETRY_COUNT_SETTING)
342                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
343             ));
344             assertThat(cluster.getAnyLeader().getId(), not(equalTo(originalLeader.getId())));
345         }
346     }
347     public void testFollowerDisconnectionDetectedQuickly() {
348         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
349             cluster.runRandomly();
350             cluster.stabilise();
351             final ClusterNode leader = cluster.getAnyLeader();
352             final ClusterNode follower = cluster.getAnyNodeExcept(leader);
353             logger.info("--&gt; disconnecting follower {}", follower);
354             follower.disconnect();
355             logger.info("--&gt; leader {} and follower {} get disconnect event", leader, follower);
356             leader.onDisconnectEventFrom(follower);
357             follower.onDisconnectEventFrom(leader);             cluster.stabilise(DEFAULT_DELAY_VARIABILITY                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
358                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
359             assertThat(cluster.getAnyLeader().getId(), equalTo(leader.getId()));
360         }
361     }
362     public void testFollowerDisconnectionWithoutDisconnectEventDetectedQuickly() {
363         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
364             cluster.runRandomly();
365             cluster.stabilise();
366             final ClusterNode leader = cluster.getAnyLeader();
367             final ClusterNode follower = cluster.getAnyNodeExcept(leader);
368             logger.info("--&gt; disconnecting follower {}", follower);
369             follower.disconnect();
370             cluster.stabilise(Math.max(
371                 defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING)
372                     + defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING)
373                     + DEFAULT_DELAY_VARIABILITY
374                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
375                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,
376                 defaultMillis(LEADER_CHECK_TIMEOUT_SETTING)
377                     + defaultMillis(LEADER_CHECK_INTERVAL_SETTING)
378                     + DEFAULT_DELAY_VARIABILITY
379             ));
380             assertThat(cluster.getAnyLeader().getId(), equalTo(leader.getId()));
381         }
382     }
383     public void testUnresponsiveFollowerDetectedEventually() {
384         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
385             cluster.runRandomly();
386             cluster.stabilise();
387             final ClusterNode leader = cluster.getAnyLeader();
388             final ClusterNode follower = cluster.getAnyNodeExcept(leader);
389             logger.info("--&gt; blackholing follower {}", follower);
390             follower.blackhole();
391             cluster.stabilise(Math.max(
392                 (defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING) + defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING))
393                     * defaultInt(FOLLOWER_CHECK_RETRY_COUNT_SETTING)
394                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
395                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,
396                 (defaultMillis(LEADER_CHECK_INTERVAL_SETTING) + defaultMillis(LEADER_CHECK_TIMEOUT_SETTING))
397                     * defaultInt(LEADER_CHECK_RETRY_COUNT_SETTING)
398             ));
399             assertThat(cluster.getAnyLeader().getId(), equalTo(leader.getId()));
400         }
401     }
402     public void testAckListenerReceivesAcksFromAllNodes() {
403         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
404             cluster.runRandomly();
405             cluster.stabilise();
406             final ClusterNode leader = cluster.getAnyLeader();
407             AckCollector ackCollector = leader.submitValue(randomLong());
408             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
409             for (final ClusterNode clusterNode : cluster.clusterNodes) {
410                 assertTrue("expected ack from " + clusterNode, ackCollector.hasAckedSuccessfully(clusterNode));
411             }
412             assertThat("leader should be last to ack", ackCollector.getSuccessfulAckIndex(leader),
413                 equalTo(cluster.clusterNodes.size() - 1));
414         }
415     }
416     public void testAckListenerReceivesNackFromFollower() {
417         try (Cluster cluster = new Cluster(3)) {
418             cluster.runRandomly();
419             cluster.stabilise();
420             final ClusterNode leader = cluster.getAnyLeader();
421             final ClusterNode follower0 = cluster.getAnyNodeExcept(leader);
422             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader, follower0);
423             follower0.allowClusterStateApplicationFailure();
424             follower0.setClusterStateApplyResponse(ClusterStateApplyResponse.FAIL);
425             AckCollector ackCollector = leader.submitValue(randomLong());
426             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
427             assertTrue("expected ack from " + leader, ackCollector.hasAckedSuccessfully(leader));
428             assertTrue("expected nack from " + follower0, ackCollector.hasAckedUnsuccessfully(follower0));
429             assertTrue("expected ack from " + follower1, ackCollector.hasAckedSuccessfully(follower1));
430             assertThat("leader should be last to ack", ackCollector.getSuccessfulAckIndex(leader), equalTo(1));
431         }
432     }
433     public void testAckListenerReceivesNackFromLeader() {
434         try (Cluster cluster = new Cluster(3)) {
435             cluster.runRandomly();
436             cluster.stabilise();
437             final ClusterNode leader = cluster.getAnyLeader();
438             final ClusterNode follower0 = cluster.getAnyNodeExcept(leader);
439             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader, follower0);
440             final long startingTerm = leader.coordinator.getCurrentTerm();
441             leader.allowClusterStateApplicationFailure();
442             leader.setClusterStateApplyResponse(ClusterStateApplyResponse.FAIL);
443             AckCollector ackCollector = leader.submitValue(randomLong());
444             cluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "committing value");
445             assertTrue(leader.coordinator.getMode() != Coordinator.Mode.LEADER || leader.coordinator.getCurrentTerm() &gt; startingTerm);
446             leader.setClusterStateApplyResponse(ClusterStateApplyResponse.SUCCEED);
447             cluster.stabilise();
448             assertTrue("expected nack from " + leader, ackCollector.hasAckedUnsuccessfully(leader));
449             assertTrue("expected ack from " + follower0, ackCollector.hasAckedSuccessfully(follower0));
450             assertTrue("expected ack from " + follower1, ackCollector.hasAckedSuccessfully(follower1));
451             assertTrue(leader.coordinator.getMode() != Coordinator.Mode.LEADER || leader.coordinator.getCurrentTerm() &gt; startingTerm);
452         }
453     }
454     public void testAckListenerReceivesNoAckFromHangingFollower() {
455         try (Cluster cluster = new Cluster(3)) {
456             cluster.runRandomly();
457             cluster.stabilise();
458             final ClusterNode leader = cluster.getAnyLeader();
459             final ClusterNode follower0 = cluster.getAnyNodeExcept(leader);
460             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader, follower0);
461             logger.info("--&gt; blocking cluster state application on {}", follower0);
462             follower0.setClusterStateApplyResponse(ClusterStateApplyResponse.HANG);
463             logger.info("--&gt; publishing another value");
464             AckCollector ackCollector = leader.submitValue(randomLong());
465             cluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "committing value");
466             assertTrue("expected immediate ack from " + follower1, ackCollector.hasAckedSuccessfully(follower1));
467             assertFalse("expected no ack from " + leader, ackCollector.hasAckedSuccessfully(leader));
468             cluster.stabilise(defaultMillis(PUBLISH_TIMEOUT_SETTING));
469             assertTrue("expected eventual ack from " + leader, ackCollector.hasAckedSuccessfully(leader));
470             assertFalse("expected no ack from " + follower0, ackCollector.hasAcked(follower0));
471         }
472     }
473     public void testAckListenerReceivesNacksIfPublicationTimesOut() {
474         try (Cluster cluster = new Cluster(3)) {
475             cluster.runRandomly();
476             cluster.stabilise();
477             final ClusterNode leader = cluster.getAnyLeader();
478             final ClusterNode follower0 = cluster.getAnyNodeExcept(leader);
479             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader, follower0);
480             follower0.blackhole();
481             follower1.blackhole();
482             AckCollector ackCollector = leader.submitValue(randomLong());
483             cluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "committing value");
484             assertFalse("expected no immediate ack from " + leader, ackCollector.hasAcked(leader));
485             assertFalse("expected no immediate ack from " + follower0, ackCollector.hasAcked(follower0));
486             assertFalse("expected no immediate ack from " + follower1, ackCollector.hasAcked(follower1));
487             follower0.heal();
488             follower1.heal();
489             cluster.stabilise();
490             assertTrue("expected eventual nack from " + follower0, ackCollector.hasAckedUnsuccessfully(follower0));
491             assertTrue("expected eventual nack from " + follower1, ackCollector.hasAckedUnsuccessfully(follower1));
492             assertTrue("expected eventual nack from " + leader, ackCollector.hasAckedUnsuccessfully(leader));
493         }
494     }
495     public void testAckListenerReceivesNacksIfLeaderStandsDown() {
496         try (Cluster cluster = new Cluster(3)) {
497             cluster.runRandomly();
498             cluster.stabilise();
499             final ClusterNode leader = cluster.getAnyLeader();
500             final ClusterNode follower0 = cluster.getAnyNodeExcept(leader);
501             final ClusterNode follower1 = cluster.getAnyNodeExcept(leader, follower0);
502             leader.blackhole();
503             follower0.onDisconnectEventFrom(leader);
504             follower1.onDisconnectEventFrom(leader);
505             cluster.runFor(DEFAULT_DELAY_VARIABILITY                 + DEFAULT_ELECTION_DELAY, "elect new leader");
506             leader.heal();
507             AckCollector ackCollector = leader.submitValue(randomLong());
508             cluster.stabilise();             assertTrue("expected nack from " + leader, ackCollector.hasAckedUnsuccessfully(leader));
509             assertTrue("expected nack from " + follower0, ackCollector.hasAckedUnsuccessfully(follower0));
510             assertTrue("expected nack from " + follower1, ackCollector.hasAckedUnsuccessfully(follower1));
511         }
512     }
513     public void testAckListenerReceivesNacksFromFollowerInHigherTerm() {
514 //
515     }
516     public void testSettingInitialConfigurationTriggersElection() {
517         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
518             cluster.runFor(defaultMillis(DISCOVERY_FIND_PEERS_INTERVAL_SETTING) * 2 + randomLongBetween(0, 60000),
519                 "initial discovery phase");
520             for (final ClusterNode clusterNode : cluster.clusterNodes) {
521                 final String nodeId = clusterNode.getId();
522                 assertThat(nodeId + " is CANDIDATE", clusterNode.coordinator.getMode(), is(CANDIDATE));
523                 assertThat(nodeId + " is in term 0", clusterNode.coordinator.getCurrentTerm(), is(0L));
524                 assertThat(nodeId + " last accepted in term 0", clusterNode.coordinator.getLastAcceptedState().term(), is(0L));
525                 assertThat(nodeId + " last accepted version 0", clusterNode.coordinator.getLastAcceptedState().version(), is(0L));
526                 assertFalse(nodeId + " has not received an initial configuration", clusterNode.coordinator.isInitialConfigurationSet());
527                 assertTrue(nodeId + " has an empty last-accepted configuration",
528                     clusterNode.coordinator.getLastAcceptedState().getLastAcceptedConfiguration().isEmpty());
529                 assertTrue(nodeId + " has an empty last-committed configuration",
530                     clusterNode.coordinator.getLastAcceptedState().getLastCommittedConfiguration().isEmpty());
531                 final Set&lt;DiscoveryNode&gt; foundPeers = new HashSet&lt;&gt;();
532                 clusterNode.coordinator.getFoundPeers().forEach(foundPeers::add);
533                 assertTrue(nodeId + " should not have discovered itself", foundPeers.add(clusterNode.getLocalNode()));
534                 assertThat(nodeId + " should have found all peers", foundPeers, hasSize(cluster.size()));
535             }
536             final ClusterNode bootstrapNode = cluster.getAnyBootstrappableNode();
537             bootstrapNode.applyInitialConfiguration();
538             assertTrue(bootstrapNode.getId() + " has been bootstrapped", bootstrapNode.coordinator.isInitialConfigurationSet());
539             cluster.stabilise(
540                 defaultMillis(ELECTION_INITIAL_TIMEOUT_SETTING)                     + 4 * DEFAULT_DELAY_VARIABILITY
541                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY
542                     + (cluster.size() - 1) * 2 * DEFAULT_CLUSTER_STATE_UPDATE_DELAY
543             );
544         }
545     }
546     public void testCannotSetInitialConfigurationTwice() {
547         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
548             cluster.runRandomly();
549             cluster.stabilise();
550             final Coordinator coordinator = cluster.getAnyNode().coordinator;
551             assertFalse(coordinator.setInitialConfiguration(coordinator.getLastAcceptedState().getLastCommittedConfiguration()));
552         }
553     }
554     public void testCannotSetInitialConfigurationWithoutQuorum() {
555         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
556             final Coordinator coordinator = cluster.getAnyNode().coordinator;
557             final VotingConfiguration unknownNodeConfiguration = new VotingConfiguration(
558                 Set.of(coordinator.getLocalNode().getId(), "unknown-node"));
559             final String exceptionMessage = expectThrows(CoordinationStateRejectedException.class,
560                 () -&gt; coordinator.setInitialConfiguration(unknownNodeConfiguration)).getMessage();
561             assertThat(exceptionMessage,
562                 startsWith("not enough nodes discovered to form a quorum in the initial configuration [knownNodes=["));
563             assertThat(exceptionMessage, containsString("unknown-node"));
564             assertThat(exceptionMessage, containsString(coordinator.getLocalNode().toString()));
565             assertTrue(coordinator.setInitialConfiguration(
566                 new VotingConfiguration(Collections.singleton(coordinator.getLocalNode().getId()))));
567             cluster.stabilise();
568         }
569     }
570     public void testCannotSetInitialConfigurationWithoutLocalNode() {
571         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
572             final Coordinator coordinator = cluster.getAnyNode().coordinator;
573             final VotingConfiguration unknownNodeConfiguration = new VotingConfiguration(Set.of("unknown-node"));
574             final String exceptionMessage = expectThrows(CoordinationStateRejectedException.class,
575                 () -&gt; coordinator.setInitialConfiguration(unknownNodeConfiguration)).getMessage();
576             assertThat(exceptionMessage,
577                 equalTo("local node is not part of initial configuration"));
578         }
579     }
580     public void testDiffBasedPublishing() {
581         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
582             cluster.runRandomly();
583             cluster.stabilise();
584             final ClusterNode leader = cluster.getAnyLeader();
585             final long finalValue = randomLong();
586             final Map&lt;ClusterNode, PublishClusterStateStats&gt; prePublishStats = cluster.clusterNodes.stream().collect(
587                 Collectors.toMap(Function.identity(), cn -&gt; cn.coordinator.stats().getPublishStats()));
588             logger.info("--&gt; submitting value [{}] to [{}]", finalValue, leader);
589             leader.submitValue(finalValue);
590             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
591             final Map&lt;ClusterNode, PublishClusterStateStats&gt; postPublishStats = cluster.clusterNodes.stream().collect(
592                 Collectors.toMap(Function.identity(), cn -&gt; cn.coordinator.stats().getPublishStats()));
593 <a name="0"></a>
594             for (ClusterNode cn : cluster.clusterNodes) {
595                 assertThat(value(cn.getLastAppliedClusterState()), is(finalValue));
596                 assertEquals(cn.toString(), <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>prePublishStats.get(cn).getFullClusterStateReceivedCount(),
597                     postPublishStats.get(cn).getFullClusterStateReceivedCount());
598                 assertEquals(cn.toString(), prePublishStats.get(cn).getCompatibleClusterStateDiffReceivedCount() + 1,
599                     postPublishStats.get(cn).getCompatibleClusterStateDiffReceivedCount());
600                 assertEquals(cn.toString(), prePublishStats.get(cn).getIncompatibleClusterStateDiffReceivedCount(),
601                     postPublishStats.get(cn).getIncompatibleClusterStateDiffReceivedCount());
602             }</b></font>
603         }
604     }
605     public void testJoiningNodeReceivesFullState() {
606         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
607             cluster.runRandomly();
608             cluster.stabilise();
609             cluster.addNodesAndStabilise(1);
610             final ClusterNode newNode = cluster.clusterNodes.get(cluster.clusterNodes.size() - 1);
611             final PublishClusterStateStats newNodePublishStats = newNode.coordinator.stats().getPublishStats();
612             assertEquals(1L, newNodePublishStats.getFullClusterStateReceivedCount());
613             assertEquals(cluster.size() % 2, newNodePublishStats.getCompatibleClusterStateDiffReceivedCount());
614             assertEquals(0L, newNodePublishStats.getIncompatibleClusterStateDiffReceivedCount());
615         }
616     }
617     public void testIncompatibleDiffResendsFullState() {
618         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
619             cluster.runRandomly();
620             cluster.stabilise();
621             final ClusterNode leader = cluster.getAnyLeader();
622             final ClusterNode follower = cluster.getAnyNodeExcept(leader);
623             logger.info("--&gt; blackholing {}", follower);
624             follower.blackhole();
625             final PublishClusterStateStats prePublishStats = follower.coordinator.stats().getPublishStats();
626             logger.info("--&gt; submitting first value to {}", leader);
627             leader.submitValue(randomLong());
628             cluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "publish first state");
629             logger.info("--&gt; healing {}", follower);
630             follower.heal();
631             logger.info("--&gt; submitting second value to {}", leader);
632             leader.submitValue(randomLong());
633             cluster.stabilise();
634             final PublishClusterStateStats postPublishStats = follower.coordinator.stats().getPublishStats();
635             assertEquals(prePublishStats.getFullClusterStateReceivedCount() + 1,
636                 postPublishStats.getFullClusterStateReceivedCount());
637             assertEquals(prePublishStats.getCompatibleClusterStateDiffReceivedCount(),
638                 postPublishStats.getCompatibleClusterStateDiffReceivedCount());
639             assertEquals(prePublishStats.getIncompatibleClusterStateDiffReceivedCount() + 1,
640                 postPublishStats.getIncompatibleClusterStateDiffReceivedCount());
641         }
642     }
643     public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {
644         try (Cluster cluster = new Cluster(2, false, Settings.EMPTY)) {
645             cluster.runRandomly();
646             cluster.stabilise();
647             final ClusterNode leader = cluster.getAnyLeader();
648             final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader);
649             nonLeader.onNode(() -&gt; {
650                 logger.debug("forcing {} to become candidate", nonLeader.getId());
651                 synchronized (nonLeader.coordinator.mutex) {
652                     nonLeader.coordinator.becomeCandidate("forced");
653                 }
654                 logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId());
655                 expectThrows(CoordinationStateRejectedException.class, () -&gt; nonLeader.coordinator.onFollowerCheckRequest(
656                     new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(), leader.getLocalNode())));
657                 assertThat(nonLeader.coordinator.getMode(), equalTo(CANDIDATE));
658             }).run();
659             cluster.stabilise();
660         }
661     }
662     public void testAppliesNoMasterBlockWritesByDefault() {
663         testAppliesNoMasterBlock(null, NO_MASTER_BLOCK_WRITES);
664     }
665     public void testAppliesNoMasterBlockWritesIfConfigured() {
666         testAppliesNoMasterBlock("write", NO_MASTER_BLOCK_WRITES);
667     }
668     public void testAppliesNoMasterBlockAllIfConfigured() {
669         testAppliesNoMasterBlock("all", NO_MASTER_BLOCK_ALL);
670     }
671     private void testAppliesNoMasterBlock(String noMasterBlockSetting, ClusterBlock expectedBlock) {
672         try (Cluster cluster = new Cluster(3)) {
673             cluster.runRandomly();
674             cluster.stabilise();
675             final ClusterNode leader = cluster.getAnyLeader();
676             leader.submitUpdateTask("update NO_MASTER_BLOCK_SETTING", cs -&gt; {
677                 final Builder settingsBuilder = Settings.builder().put(cs.metadata().persistentSettings());
678                 settingsBuilder.put(NO_MASTER_BLOCK_SETTING.getKey(), noMasterBlockSetting);
679                 return
680                     ClusterState.builder(cs).metadata(Metadata.builder(cs.metadata()).persistentSettings(settingsBuilder.build())).build();
681             }, (source, e) -&gt; {});
682             cluster.runFor(DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "committing setting update");
683             leader.disconnect();
684             cluster.runFor(defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING) + defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING)
685                 + DEFAULT_CLUSTER_STATE_UPDATE_DELAY, "detecting disconnection");
686             assertThat(leader.getLastAppliedClusterState().blocks().global(), hasItem(expectedBlock));
687         }
688     }
689     public void testNodeCannotJoinIfJoinValidationFailsOnMaster() {
690         try (Cluster cluster = new Cluster(randomIntBetween(1, 3))) {
691             cluster.runRandomly();
692             cluster.stabilise();
693             List&lt;ClusterNode&gt; addedNodes = cluster.addNodes(randomIntBetween(1, 2));
694             final Set&lt;DiscoveryNode&gt; validatedNodes = new HashSet&lt;&gt;();
695             cluster.getAnyLeader().extraJoinValidators.add((discoveryNode, clusterState) -&gt; {
696                 validatedNodes.add(discoveryNode);
697                 throw new IllegalArgumentException("join validation failed");
698             });
699             final long previousClusterStateVersion = cluster.getAnyLeader().getLastAppliedClusterState().version();
700             cluster.runFor(10000, "failing join validation");
701             assertEquals(validatedNodes, addedNodes.stream().map(ClusterNode::getLocalNode).collect(Collectors.toSet()));
702             assertTrue(addedNodes.stream().allMatch(ClusterNode::isCandidate));
703             final long newClusterStateVersion = cluster.getAnyLeader().getLastAppliedClusterState().version();
704             assertEquals(previousClusterStateVersion, newClusterStateVersion);
705             cluster.getAnyLeader().extraJoinValidators.clear();
706             cluster.stabilise();
707         }
708     }
709     public void testNodeCannotJoinIfJoinValidationFailsOnJoiningNode() {
710         try (Cluster cluster = new Cluster(randomIntBetween(1, 3))) {
711             cluster.runRandomly();
712             cluster.stabilise();
713             List&lt;ClusterNode&gt; addedNodes = cluster.addNodes(randomIntBetween(1, 2));
714             final Set&lt;DiscoveryNode&gt; validatedNodes = new HashSet&lt;&gt;();
715             addedNodes.forEach(cn -&gt; cn.extraJoinValidators.add((discoveryNode, clusterState) -&gt; {
716                 validatedNodes.add(discoveryNode);
717                 throw new IllegalArgumentException("join validation failed");
718             }));
719             final long previousClusterStateVersion = cluster.getAnyLeader().getLastAppliedClusterState().version();
720             cluster.runFor(10000, "failing join validation");
721             assertEquals(validatedNodes, addedNodes.stream().map(ClusterNode::getLocalNode).collect(Collectors.toSet()));
722             assertTrue(addedNodes.stream().allMatch(ClusterNode::isCandidate));
723             final long newClusterStateVersion = cluster.getAnyLeader().getLastAppliedClusterState().version();
724             assertEquals(previousClusterStateVersion, newClusterStateVersion);
725             addedNodes.forEach(cn -&gt; cn.extraJoinValidators.clear());
726             cluster.stabilise();
727         }
728     }
729     public void testClusterCannotFormWithFailingJoinValidation() {
730         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
731             randomValueOtherThanMany(nodes -&gt;
732                     cluster.initialConfiguration.hasQuorum(
733                         nodes.stream().map(ClusterNode::getLocalNode).map(DiscoveryNode::getId).collect(Collectors.toSet())) == false,
734                 () -&gt; randomSubsetOf(cluster.clusterNodes))
735                 .forEach(cn -&gt; cn.extraJoinValidators.add((discoveryNode, clusterState) -&gt; {
736                     throw new IllegalArgumentException("join validation failed");
737                 }));
738             cluster.bootstrapIfNecessary();
739             cluster.runFor(10000, "failing join validation");
740             assertTrue(cluster.clusterNodes.stream().allMatch(cn -&gt; cn.getLastAppliedClusterState().version() == 0));
741         }
742     }
743     public void testCannotJoinClusterWithDifferentUUID() throws IllegalAccessException {
744         try (Cluster cluster1 = new Cluster(randomIntBetween(1, 3))) {
745             cluster1.runRandomly();
746             cluster1.stabilise();
747             final ClusterNode nodeInOtherCluster;
748             try (Cluster cluster2 = new Cluster(3)) {
749                 cluster2.runRandomly();
750                 cluster2.stabilise();
751                 nodeInOtherCluster = randomFrom(cluster2.clusterNodes);
752             }
753             final ClusterNode newNode = cluster1.new ClusterNode(nextNodeIndex.getAndIncrement(),
754                 nodeInOtherCluster.getLocalNode(), n -&gt; cluster1.new MockPersistedState(n, nodeInOtherCluster.persistedState,
755                 Function.identity(), Function.identity()), nodeInOtherCluster.nodeSettings);
756             cluster1.clusterNodes.add(newNode);
757             MockLogAppender mockAppender = new MockLogAppender();
758             mockAppender.start();
759             mockAppender.addExpectation(
760                 new MockLogAppender.SeenEventExpectation(
761                     "test1",
762                     JoinHelper.class.getCanonicalName(),
763                     Level.INFO,
764                     "*failed to join*"));
765             Logger joinLogger = LogManager.getLogger(JoinHelper.class);
766             Loggers.addAppender(joinLogger, mockAppender);
767             cluster1.runFor(DEFAULT_STABILISATION_TIME, "failing join validation");
768             try {
769                 mockAppender.assertAllExpectationsMatched();
770             } finally {
771                 Loggers.removeAppender(joinLogger, mockAppender);
772                 mockAppender.stop();
773             }
774             assertEquals(0, newNode.getLastAppliedClusterState().version());
775             newNode.close();
776             final ClusterNode detachedNode = newNode.restartedNode(
777                 DetachClusterCommand::updateMetadata,
778                 term -&gt; DetachClusterCommand.updateCurrentTerm(), newNode.nodeSettings);
779             cluster1.clusterNodes.replaceAll(cn -&gt; cn == newNode ? detachedNode : cn);
780             cluster1.stabilise();
781         }
782     }
783     public void testDiscoveryUsesNodesFromLastClusterState() {
784         try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {
785             cluster.runRandomly();
786             cluster.stabilise();
787             final ClusterNode partitionedNode = cluster.getAnyNode();
788             if (randomBoolean()) {
789                 logger.info("--&gt; blackholing {}", partitionedNode);
790                 partitionedNode.blackhole();
791             } else {
792                 logger.info("--&gt; disconnecting {}", partitionedNode);
793                 partitionedNode.disconnect();
794             }
795             cluster.setEmptySeedHostsList();
796             cluster.stabilise();
797             partitionedNode.heal();
798             cluster.runRandomly(false);
799             cluster.stabilise();
800         }
801     }
802     public void testFollowerRemovedIfUnableToSendRequestsToMaster() {
803         try (Cluster cluster = new Cluster(3)) {
804             cluster.runRandomly();
805             cluster.stabilise();
806             final ClusterNode leader = cluster.getAnyLeader();
807             final ClusterNode otherNode = cluster.getAnyNodeExcept(leader);
808             cluster.blackholeConnectionsFrom(otherNode, leader);
809             cluster.runFor(
810                 (defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING) + defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING))
811                     * defaultInt(FOLLOWER_CHECK_RETRY_COUNT_SETTING)
812                     + (defaultMillis(LEADER_CHECK_INTERVAL_SETTING) + DEFAULT_DELAY_VARIABILITY)
813                     * defaultInt(LEADER_CHECK_RETRY_COUNT_SETTING)
814                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,
815                 "awaiting removal of asymmetrically-partitioned node");
816             assertThat(leader.getLastAppliedClusterState().nodes().toString(),
817                 leader.getLastAppliedClusterState().nodes().getSize(), equalTo(2));
818             cluster.clearBlackholedConnections();
819             cluster.stabilise(
820                 defaultMillis(DISCOVERY_FIND_PEERS_INTERVAL_SETTING) * 2
821                     + 4 * DEFAULT_DELAY_VARIABILITY
822                     + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
823         }
824     }
825     public void testSingleNodeDiscoveryWithoutQuorum() {
826         try (Cluster cluster = new Cluster(3)) {
827             cluster.runRandomly();
828             cluster.stabilise();
829             final ClusterNode clusterNode = cluster.getAnyNode();
830             logger.debug("rebooting [{}]", clusterNode.getId());
831             clusterNode.close();
832             cluster.clusterNodes.forEach(
833                 cn -&gt; cluster.deterministicTaskQueue.scheduleNow(cn.onNode(
834                     new Runnable() {
835                         @Override
836                         public void run() {
837                             cn.transportService.disconnectFromNode(clusterNode.getLocalNode());
838                         }
839                         @Override
840                         public String toString() {
841                             return "disconnect from " + clusterNode.getLocalNode() + " after shutdown";
842                         }
843                     })));
844             IllegalStateException ise = expectThrows(IllegalStateException.class,
845                 () -&gt; cluster.clusterNodes.replaceAll(cn -&gt; cn == clusterNode ?
846                     cn.restartedNode(Function.identity(), Function.identity(), Settings.builder()
847                         .put(DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey(), DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE).build()) :
848                     cn));
849             assertThat(ise.getMessage(), allOf(
850                 containsString("cannot start with [discovery.type] set to [single-node] when local node"),
851                 containsString("does not have quorum in voting configuration")));
852             cluster.clusterNodes.remove(clusterNode);         }
853     }
854     public void testSingleNodeDiscoveryWithQuorum() {
855         try (Cluster cluster = new Cluster(1, randomBoolean(), Settings.builder()
856             .put(DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey(), DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE).build())) {
857             cluster.runRandomly();
858             cluster.stabilise();
859         }
860     }
861     private static class BrokenCustom extends AbstractDiffable&lt;ClusterState.Custom&gt; implements ClusterState.Custom {
862         static final String EXCEPTION_MESSAGE = "simulated";
863         @Override
864         public String getWriteableName() {
865             return "broken";
866         }
867         @Override
868         public Version getMinimalSupportedVersion() {
869             return Version.V_EMPTY;
870         }
871         @Override
872         public void writeTo(StreamOutput out) throws IOException {
873             throw new ElasticsearchException(EXCEPTION_MESSAGE);
874         }
875         @Override
876         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
877             return builder;
878         }
879     }
880     public void testClusterRecoversAfterExceptionDuringSerialization() {
881         try (Cluster cluster = new Cluster(randomIntBetween(1, 5))) {
882             cluster.runRandomly();
883             cluster.stabilise();
884             final ClusterNode leader1 = cluster.getAnyLeader();
885             logger.info("--&gt; submitting broken task to [{}]", leader1);
886             final AtomicBoolean failed = new AtomicBoolean();
887             leader1.submitUpdateTask("broken-task",
888                 cs -&gt; ClusterState.builder(cs).putCustom("broken", new BrokenCustom()).build(),
889                 (source, e) -&gt; {
890                     assertThat(e.getCause(), instanceOf(ElasticsearchException.class));
891                     assertThat(e.getCause().getMessage(), equalTo(BrokenCustom.EXCEPTION_MESSAGE));
892                     failed.set(true);
893                 });
894             cluster.runFor(DEFAULT_DELAY_VARIABILITY + 1, "processing broken task");
895             assertTrue(failed.get());
896             cluster.stabilise();
897             final ClusterNode leader2 = cluster.getAnyLeader();
898             long finalValue = randomLong();
899             logger.info("--&gt; submitting value [{}] to [{}]", finalValue, leader2);
900             leader2.submitValue(finalValue);
901             cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);
902             for (final ClusterNode clusterNode : cluster.clusterNodes) {
903                 final String nodeId = clusterNode.getId();
904                 final ClusterState appliedState = clusterNode.getLastAppliedClusterState();
905                 assertThat(nodeId + " has the applied value", value(appliedState), is(finalValue));
906             }
907         }
908     }
909     public void testLogsWarningPeriodicallyIfClusterNotFormed() throws IllegalAccessException {
910         final long warningDelayMillis;
911         final Settings settings;
912         if (randomBoolean()) {
913             settings = Settings.EMPTY;
914             warningDelayMillis = ClusterFormationFailureHelper.DISCOVERY_CLUSTER_FORMATION_WARNING_TIMEOUT_SETTING.get(settings).millis();
915         } else {
916             warningDelayMillis = randomLongBetween(1, 100000);
917             settings = Settings.builder()
918                 .put(ClusterFormationFailureHelper.DISCOVERY_CLUSTER_FORMATION_WARNING_TIMEOUT_SETTING.getKey(), warningDelayMillis + "ms")
919                 .build();
920         }
921         logger.info("--&gt; emitting warnings every [{}ms]", warningDelayMillis);
922         try (Cluster cluster = new Cluster(3, true, settings)) {
923             cluster.runRandomly();
924             cluster.stabilise();
925             logger.info("--&gt; disconnecting all nodes");
926             for (final ClusterNode clusterNode : cluster.clusterNodes) {
927                 clusterNode.disconnect();
928             }
929             cluster.runFor(defaultMillis(LEADER_CHECK_TIMEOUT_SETTING)                     + defaultMillis(LEADER_CHECK_INTERVAL_SETTING)                     + 2 * DEFAULT_DELAY_VARIABILITY,                 "waiting for leader failure");
930             for (final ClusterNode clusterNode : cluster.clusterNodes) {
931                 assertThat(clusterNode.getId() + " is CANDIDATE", clusterNode.coordinator.getMode(), is(CANDIDATE));
932             }
933             for (int i = scaledRandomIntBetween(1, 10); i &gt;= 0; i--) {
934                 final MockLogAppender mockLogAppender = new MockLogAppender();
935                 try {
936                     mockLogAppender.start();
937                     Loggers.addAppender(LogManager.getLogger(ClusterFormationFailureHelper.class), mockLogAppender);
938                     mockLogAppender.addExpectation(new MockLogAppender.LoggingExpectation() {
939                         final Set&lt;DiscoveryNode&gt; nodesLogged = new HashSet&lt;&gt;();
940 <a name="2"></a>
941                         @Override
942                         public void match(LogEvent event) {
943                             final String message = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>event.getMessage().getFormattedMessage();
944                             assertThat(message,
945                                 startsWith("master not discovered or elected yet, an election requires at least 2 nodes with ids from ["));
946                             final List&lt;ClusterNode&gt; matchingNodes = cluster.clusterNodes.stream()
947                                 .filter(n -&gt; event.getContextData</b></font>().&lt;String&gt;getValue(NODE_ID_LOG_CONTEXT_KEY)
948                                     .equals(getNodeIdForLogContext(n.getLocalNode()))).collect(Collectors.toList());
949                             assertThat(matchingNodes, hasSize(1));
950                             assertTrue(Regex.simpleMatch(
951                                 "*have discovered *" + matchingNodes.get(0).toString() + "*discovery will continue*",
952                                 message));
953                             nodesLogged.add(matchingNodes.get(0).getLocalNode());
954                         }
955                         @Override
956                         public void assertMatched() {
957                             assertThat(nodesLogged + " vs " + cluster.clusterNodes, nodesLogged,
958                                 equalTo(cluster.clusterNodes.stream().map(ClusterNode::getLocalNode).collect(Collectors.toSet())));
959                         }
960                     });
961                     cluster.runFor(warningDelayMillis + DEFAULT_DELAY_VARIABILITY, "waiting for warning to be emitted");
962                     mockLogAppender.assertAllExpectationsMatched();
963                 } finally {
964                     Loggers.removeAppender(LogManager.getLogger(ClusterFormationFailureHelper.class), mockLogAppender);
965                     mockLogAppender.stop();
966                 }
967             }
968         }
969     }
970     public void testLogsMessagesIfPublicationDelayed() throws IllegalAccessException {
971         try (Cluster cluster = new Cluster(between(3, 5))) {
972             cluster.runRandomly();
973             cluster.stabilise();
974             final ClusterNode brokenNode = cluster.getAnyNodeExcept(cluster.getAnyLeader());
975             final MockLogAppender mockLogAppender = new MockLogAppender();
976             try {
977                 mockLogAppender.start();
978                 Loggers.addAppender(LogManager.getLogger(Coordinator.CoordinatorPublication.class), mockLogAppender);
979                 Loggers.addAppender(LogManager.getLogger(LagDetector.class), mockLogAppender);
980                 mockLogAppender.addExpectation(new MockLogAppender.SeenEventExpectation("publication info message",
981                     Coordinator.CoordinatorPublication.class.getCanonicalName(), Level.INFO,
982                     "after [*] publication of cluster state version [*] is still waiting for " + brokenNode.getLocalNode() + " ["
983                         + Publication.PublicationTargetState.SENT_PUBLISH_REQUEST + ']'));
984                 mockLogAppender.addExpectation(new MockLogAppender.SeenEventExpectation("publication warning",
985                     Coordinator.CoordinatorPublication.class.getCanonicalName(), Level.WARN,
986                     "after [*] publication of cluster state version [*] is still waiting for " + brokenNode.getLocalNode() + " ["
987                         + Publication.PublicationTargetState.SENT_PUBLISH_REQUEST + ']'));
988                 mockLogAppender.addExpectation(new MockLogAppender.SeenEventExpectation("lag warning",
989                     LagDetector.class.getCanonicalName(), Level.WARN,
990                     "node [" + brokenNode + "] is lagging at cluster state version [*], " +
991                         "although publication of cluster state version [*] completed [*] ago"));
992                 brokenNode.blackhole();
993                 cluster.deterministicTaskQueue.scheduleAt(
994                     cluster.deterministicTaskQueue.getCurrentTimeMillis() + DEFAULT_CLUSTER_STATE_UPDATE_DELAY,
995                     new Runnable() {
996                         @Override
997                         public void run() {
998                             brokenNode.heal();
999                         }
1000                         @Override
1001                         public String toString() {
1002                             return "healing " + brokenNode;
1003                         }
1004                     });
1005                 cluster.getAnyLeader().submitValue(randomLong());
1006                 cluster.runFor(defaultMillis(PUBLISH_TIMEOUT_SETTING) + 2 * DEFAULT_DELAY_VARIABILITY
1007                         + defaultMillis(LagDetector.CLUSTER_FOLLOWER_LAG_TIMEOUT_SETTING),
1008                     "waiting for messages to be emitted");
1009                 mockLogAppender.assertAllExpectationsMatched();
1010             } finally {
1011                 Loggers.removeAppender(LogManager.getLogger(Coordinator.CoordinatorPublication.class), mockLogAppender);
1012                 Loggers.removeAppender(LogManager.getLogger(LagDetector.class), mockLogAppender);
1013                 mockLogAppender.stop();
1014             }
1015         }
1016     }
1017     public void testReconfiguresToExcludeMasterIneligibleNodesInVotingConfig() {
1018         try (Cluster cluster = new Cluster(3)) {
1019             cluster.runRandomly();
1020             cluster.stabilise();
1021             final ClusterNode chosenNode = cluster.getAnyNode();
1022             assertThat(cluster.getAnyLeader().getLastAppliedClusterState().getLastCommittedConfiguration().getNodeIds(),
1023                 hasItem(chosenNode.getId()));
1024             assertThat(cluster.getAnyLeader().getLastAppliedClusterState().getLastAcceptedConfiguration().getNodeIds(),
1025                 hasItem(chosenNode.getId()));
1026             final boolean chosenNodeIsLeader = chosenNode == cluster.getAnyLeader();
1027             final long termBeforeRestart = cluster.getAnyNode().coordinator.getCurrentTerm();
1028             logger.info("--&gt; restarting [{}] as a master-ineligible node", chosenNode);
1029             chosenNode.close();
1030             cluster.clusterNodes.replaceAll(cn -&gt; cn == chosenNode ? cn.restartedNode(Function.identity(), Function.identity(),
1031                 Settings.builder().put(Node.NODE_MASTER_SETTING.getKey(), false).build()) : cn);
1032             cluster.stabilise();
1033             if (chosenNodeIsLeader == false) {
1034                 assertThat("term did not change", cluster.getAnyNode().coordinator.getCurrentTerm(), is(termBeforeRestart));
1035             }
1036             assertThat(cluster.getAnyLeader().getLastAppliedClusterState().getLastCommittedConfiguration().getNodeIds(),
1037                 not(hasItem(chosenNode.getId())));
1038             assertThat(cluster.getAnyLeader().getLastAppliedClusterState().getLastAcceptedConfiguration().getNodeIds(),
1039                 not(hasItem(chosenNode.getId())));
1040         }
1041     }
1042     public void testDoesNotPerformElectionWhenRestartingFollower() {
1043         try (Cluster cluster = new Cluster(randomIntBetween(2, 5), false, Settings.EMPTY)) {
1044             cluster.runRandomly();
1045             cluster.stabilise();
1046             final ClusterNode leader = cluster.getAnyLeader();
1047             final long expectedTerm = leader.coordinator.getCurrentTerm();
1048             if (cluster.clusterNodes.stream().filter(n -&gt; n.getLocalNode().isMasterEligibleNode()).count() == 2) {
1049                 leader.submitSetAutoShrinkVotingConfiguration(true);
1050                 cluster.stabilise(2 * DEFAULT_CLUSTER_STATE_UPDATE_DELAY);             }
1051             for (final ClusterNode clusterNode : cluster.getAllNodesExcept(leader)) {
1052                 logger.info("--&gt; restarting {}", clusterNode);
1053                 clusterNode.close();
1054                 cluster.clusterNodes.replaceAll(cn -&gt;
1055                     cn == clusterNode ? cn.restartedNode(Function.identity(), Function.identity(), Settings.EMPTY) : cn);
1056                 cluster.stabilise();
1057                 assertThat("term should not change", cluster.getAnyNode().coordinator.getCurrentTerm(), is(expectedTerm));
1058             }
1059         }
1060     }
1061 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
