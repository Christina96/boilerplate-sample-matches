<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for AbstractBiMap_1.java & ForwardingValueGraph_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for AbstractBiMap_1.java & ForwardingValueGraph_1.java
      </h3>
      <h1 align="center">
        13.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>AbstractBiMap_1.java (8.296296%)<TH>ForwardingValueGraph_1.java (31.638418%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match458109-0.html#0',2,'match458109-1.html#0',3)" NAME="0">(443-449)<TD><A HREF="javascript:ZweiFrames('match458109-0.html#0',2,'match458109-1.html#0',3)" NAME="0">(64-71)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match458109-0.html#1',2,'match458109-1.html#1',3)" NAME="1">(292-299)<TD><A HREF="javascript:ZweiFrames('match458109-0.html#1',2,'match458109-1.html#1',3)" NAME="1">(38-49)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match458109-0.html#2',2,'match458109-1.html#2',3)" NAME="2">(502-508)<TD><A HREF="javascript:ZweiFrames('match458109-0.html#2',2,'match458109-1.html#2',3)" NAME="2">(51-57)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match458109-0.html#3',2,'match458109-1.html#3',3)" NAME="3">(454-459)<TD><A HREF="javascript:ZweiFrames('match458109-0.html#3',2,'match458109-1.html#3',3)" NAME="3">(76-81)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match458109-0.html#4',2,'match458109-1.html#4',3)" NAME="4">(259-264)<TD><A HREF="javascript:ZweiFrames('match458109-0.html#4',2,'match458109-1.html#4',3)" NAME="4">(71-76)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractBiMap_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Objects;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.j2objc.annotations.RetainedWith;
import com.google.j2objc.annotations.WeakOuter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.function.BiFunction;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A general-purpose bimap implementation using any two backing {@code Map} instances.
 *
 * &lt;p&gt;Note that this class contains {@code equals()} calls that keep it from supporting {@code
 * IdentityHashMap} backing maps.
 *
 * @author Kevin Bourrillion
 * @author Mike Bostock
 */
@GwtCompatible(emulated = true)
@ElementTypesAreNonnullByDefault
abstract class AbstractBiMap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
    extends ForwardingMap&lt;K, V&gt; implements BiMap&lt;K, V&gt;, Serializable {

  private transient Map&lt;K, V&gt; delegate;
  @RetainedWith transient AbstractBiMap&lt;V, K&gt; inverse;

  /** Package-private constructor for creating a map-backed bimap. */
  AbstractBiMap(Map&lt;K, V&gt; forward, Map&lt;V, K&gt; backward) {
    setDelegates(forward, backward);
  }

  /** Private constructor for inverse bimap. */
  private AbstractBiMap(Map&lt;K, V&gt; backward, AbstractBiMap&lt;V, K&gt; forward) {
    delegate = backward;
    inverse = forward;
  }

  @Override
  protected Map&lt;K, V&gt; delegate() {
    return delegate;
  }

  /** Returns its input, or throws an exception if this is not a valid key. */
  @CanIgnoreReturnValue
  @ParametricNullness
  K checkKey(@ParametricNullness K key) {
    return key;
  }

  /** Returns its input, or throws an exception if this is not a valid value. */
  @CanIgnoreReturnValue
  @ParametricNullness
  V checkValue(@ParametricNullness V value) {
    return value;
  }

  /**
   * Specifies the delegate maps going in each direction. Called by the constructor and by
   * subclasses during deserialization.
   */
  void setDelegates(Map&lt;K, V&gt; forward, Map&lt;V, K&gt; backward) {
    checkState(delegate == null);
    checkState(inverse == null);
    checkArgument(forward.isEmpty());
    checkArgument(backward.isEmpty());
    checkArgument(forward != backward);
    delegate = forward;
    inverse = makeInverse(backward);
  }

  AbstractBiMap&lt;V, K&gt; makeInverse(Map&lt;V, K&gt; backward) {
    return new Inverse&lt;&gt;(backward, this);
  }

  void setInverse(AbstractBiMap&lt;V, K&gt; inverse) {
    this.inverse = inverse;
  }

  // Query Operations (optimizations)

  @Override
  public boolean containsValue(@CheckForNull Object value) {
    return inverse.containsKey(value);
  }

  // Modification Operations

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public V put(@ParametricNullness K key, @ParametricNullness V value) {
    return putInBothMaps(key, value, false);
  }

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
    return putInBothMaps(key, value, true);
  }

  @CheckForNull
  private V putInBothMaps(@ParametricNullness K key, @ParametricNullness V value, boolean force) {
    checkKey(key);
    checkValue(value);
    boolean containedKey = containsKey(key);
    if (containedKey &amp;&amp; Objects.equal(value, get(key))) {
      return value;
    }
    if (force) {
      inverse().remove(value);
    } else {
      checkArgument(!containsValue(value), &quot;value already present: %s&quot;, value);
    }
    V oldValue = delegate.put(key, value);
    updateInverseMap(key, containedKey, oldValue, value);
    return oldValue;
  }

  private void updateInverseMap(
      @ParametricNullness K key,
      boolean containedKey,
      @CheckForNull V oldValue,
      @ParametricNullness V newValue) {
    if (containedKey) {
      // The cast is safe because of the containedKey check.
      removeFromInverseMap(uncheckedCastNullableTToT(oldValue));
    }
    inverse.delegate.put(newValue, key);
  }

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public V remove(@CheckForNull Object key) {
    return containsKey(key) ? removeFromBothMaps(key) : null;
  }

  @CanIgnoreReturnValue
  @ParametricNullness
  private V removeFromBothMaps(@CheckForNull Object key) {
    // The cast is safe because the callers of this method first check that the key is present.
    V oldValue = uncheckedCastNullableTToT(delegate.remove(key));
    removeFromInverseMap(oldValue);
    return oldValue;
  }

  private void removeFromInverseMap(@ParametricNullness V oldValue) {
    inverse.delegate.remove(oldValue);
  }

  // Bulk Operations

  @Override
  public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
    for (Entry&lt;? extends K, ? extends V&gt; entry : map.entrySet()) {
      put(entry.getKey(), entry.getValue());
    }
  }

  @Override
  public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
    this.delegate.replaceAll(function);
    inverse.delegate.clear();
    Entry&lt;K, V&gt; broken = null;
    Iterator&lt;Entry&lt;K, V&gt;&gt; itr = this.delegate.entrySet().iterator();
    while (itr.hasNext()) {
      Entry&lt;K, V&gt; entry = itr.next();
      K k = entry.getKey();
      V v = entry.getValue();
      K conflict = inverse.delegate.putIfAbsent(v, k);
      if (conflict != null) {
        broken = entry;
        // We're definitely going to throw, but we'll try to keep the BiMap in an internally
        // consistent state by removing the bad entry.
        itr.remove();
      }
    }
    if (broken != null) {
      throw new IllegalArgumentException(&quot;value already present: &quot; + broken.getValue());
    }
  }

  @Override
  public void clear() {
    delegate.clear();
    inverse.delegate.clear();
  }

  // Views

  @Override
  public BiMap&lt;V, K&gt; inverse() {
    return inverse;
  }

  @CheckForNull private transient Set&lt;K&gt; keySet;

  @Override
  public Set&lt;K&gt; keySet() {
    Set&lt;K&gt; result = keySet;
    return (result == null) ? keySet = new KeySet() : result;
  }

  @WeakOuter
  private class KeySet extends ForwardingSet&lt;K&gt; {
    @Override
    protected Set&lt;K&gt; delegate() {
      return delegate.keySet();
    }

    @Override
    public void clear() {
      AbstractBiMap.this.clear();
    }

    @Override
    public boolean remove(@CheckForNull Object key) {
      if (!contains(key)) {
        return false;
      }
      removeFromBothMaps(key);
      return true;
    }
<A NAME="4"></A>
    @Override
    public boolean removeAll(Collection&lt;?&gt; keysToRemove) {
      return <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match458109-1.html#4',3,'match458109-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>standardRemoveAll(keysToRemove);
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; keysToRetain) {
      return standardRetainAll</B></FONT>(keysToRetain);
    }

    @Override
    public Iterator&lt;K&gt; iterator() {
      return Maps.keyIterator(entrySet().iterator());
    }
  }

  @CheckForNull private transient Set&lt;V&gt; valueSet;

  @Override
  public Set&lt;V&gt; values() {
    /*
     * We can almost reuse the inverse's keySet, except we have to fix the
     * iteration order so that it is consistent with the forward map.
     */
    Set&lt;V&gt; result = valueSet;
    return (result == null) ? valueSet = new ValueSet() : result;
  }

  @WeakOuter
  private class ValueSet extends ForwardingSet&lt;V&gt; {
    final Set&lt;V&gt; valuesDelegate = inverse.keySet();

<A NAME="1"></A>    @Override
    protected Set&lt;V&gt; delegate() {
      return valuesDelegate;
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match458109-1.html#1',3,'match458109-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public Iterator&lt;V&gt; iterator() {
      return Maps.valueIterator(entrySet().iterator());
    }

    @</B></FONT>Override
    public @Nullable Object[] toArray() {
      return standardToArray();
    }

    @Override
    @SuppressWarnings(&quot;nullness&quot;) // bug in our checker's handling of toArray signatures
    public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
      return standardToArray(array);
    }

    @Override
    public String toString() {
      return standardToString();
    }
  }

  @CheckForNull private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;

  @Override
  public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
    Set&lt;Entry&lt;K, V&gt;&gt; result = entrySet;
    return (result == null) ? entrySet = new EntrySet() : result;
  }

  class BiMapEntry extends ForwardingMapEntry&lt;K, V&gt; {
    private final Entry&lt;K, V&gt; delegate;

    BiMapEntry(Entry&lt;K, V&gt; delegate) {
      this.delegate = delegate;
    }

    @Override
    protected Entry&lt;K, V&gt; delegate() {
      return delegate;
    }

    @Override
    public V setValue(V value) {
      checkValue(value);
      // Preconditions keep the map and inverse consistent.
      checkState(entrySet().contains(this), &quot;entry no longer in map&quot;);
      // similar to putInBothMaps, but set via entry
      if (Objects.equal(value, getValue())) {
        return value;
      }
      checkArgument(!containsValue(value), &quot;value already present: %s&quot;, value);
      V oldValue = delegate.setValue(value);
      checkState(Objects.equal(value, get(getKey())), &quot;entry no longer in map&quot;);
      updateInverseMap(getKey(), true, oldValue, value);
      return oldValue;
    }
  }

  Iterator&lt;Entry&lt;K, V&gt;&gt; entrySetIterator() {
    final Iterator&lt;Entry&lt;K, V&gt;&gt; iterator = delegate.entrySet().iterator();
    return new Iterator&lt;Entry&lt;K, V&gt;&gt;() {
      @CheckForNull Entry&lt;K, V&gt; entry;

      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }

      @Override
      public Entry&lt;K, V&gt; next() {
        entry = iterator.next();
        return new BiMapEntry(entry);
      }

      @Override
      public void remove() {
        if (entry == null) {
          throw new IllegalStateException(&quot;no calls to next() since the last call to remove()&quot;);
        }
        V value = entry.getValue();
        iterator.remove();
        removeFromInverseMap(value);
        entry = null;
      }
    };
  }

  @WeakOuter
  private class EntrySet extends ForwardingSet&lt;Entry&lt;K, V&gt;&gt; {
    final Set&lt;Entry&lt;K, V&gt;&gt; esDelegate = delegate.entrySet();

    @Override
    protected Set&lt;Entry&lt;K, V&gt;&gt; delegate() {
      return esDelegate;
    }

    @Override
    public void clear() {
      AbstractBiMap.this.clear();
    }

    @Override
    public boolean remove(@CheckForNull Object object) {
      /*
       * `o instanceof Entry` is guaranteed by `contains`, but we check it here to satisfy our
       * nullness checker.
       */
      if (!esDelegate.contains(object) || !(object instanceof Entry)) {
        return false;
      }

      Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) object;
      inverse.delegate.remove(entry.getValue());
      /*
       * Remove the mapping in inverse before removing from esDelegate because
       * if entry is part of esDelegate, entry might be invalidated after the
       * mapping is removed from esDelegate.
       */
      esDelegate.remove(entry);
      return true;
    }

    @Override
    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
      return entrySetIterator();
    }

    // See java.util.Collections.CheckedEntrySet for details on attacks.

    @Override
    public Object[] toArray() {
      /*
       * standardToArray returns `@Nullable Object[]` rather than `Object[]` but only because it can
       * be used with collections that may contain null. This collection never contains nulls, so we
       * can treat it as a plain `Object[]`.
       */
      @SuppressWarnings(&quot;nullness&quot;)
      Object[] result = standardToArray();
      return result;
    }

    @Override
    @SuppressWarnings(&quot;nullness&quot;) // bug in our checker's handling of toArray signatures
    public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
      return standardToArray(array);
<A NAME="0"></A>    }

    @Override
    public boolean contains(<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match458109-1.html#0',3,'match458109-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@CheckForNull Object o) {
      return Maps.containsEntryImpl(delegate(), o);
    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; c) {
      return standardContainsAll</B></FONT>(c);
    }
<A NAME="3"></A>
    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
      return <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match458109-1.html#3',3,'match458109-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>standardRemoveAll(c);
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {
      return standardRetainAll</B></FONT>(c);
    }
  }

  /** The inverse of any other {@code AbstractBiMap} subclass. */
  static class Inverse&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      extends AbstractBiMap&lt;K, V&gt; {
    Inverse(Map&lt;K, V&gt; backward, AbstractBiMap&lt;V, K&gt; forward) {
      super(backward, forward);
    }

    /*
     * Serialization stores the forward bimap, the inverse of this inverse.
     * Deserialization calls inverse() on the forward bimap and returns that
     * inverse.
     *
     * If a bimap and its inverse are serialized together, the deserialized
     * instances have inverse() methods that return the other.
     */

    @Override
    @ParametricNullness
    K checkKey(@ParametricNullness K key) {
      return inverse.checkValue(key);
    }

    @Override
    @ParametricNullness
    V checkValue(@ParametricNullness V value) {
      return inverse.checkKey(value);
    }

    /** @serialData the forward bimap */
    @GwtIncompatible // java.io.ObjectOutputStream
    private void writeObject(ObjectOutputStream stream) throws IOException {
      stream.defaultWriteObject();
      stream.writeObject(inverse());
    }

    @GwtIncompatible // java.io.ObjectInputStream
<A NAME="2"></A>    @SuppressWarnings(&quot;unchecked&quot;) // reading data stored by writeObject
    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
      stream.defaultReadObject();
      <FONT color="#980517"><A HREF="javascript:ZweiFrames('match458109-1.html#2',3,'match458109-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>setInverse((AbstractBiMap&lt;V, K&gt;) stream.readObject());
    }

    @GwtIncompatible // Not needed in the emulated source.
    Object readResolve() {
      return inverse().inverse();
    }</B></FONT>

    @GwtIncompatible // Not needed in emulated source.
    private static final long serialVersionUID = 0;
  }

  @GwtIncompatible // Not needed in emulated source.
  private static final long serialVersionUID = 0;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingValueGraph_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.graph;

import java.util.Optional;
import java.util.Set;
import javax.annotation.CheckForNull;

/**
 * A class to allow {@link ValueGraph} implementations to be backed by a provided delegate. This is
 * not currently planned to be released as a general-purpose forwarding class.
 *
 * @author James Sexton
 * @author Joshua O'Madadhain
 */
@ElementTypesAreNonnullByDefault
abstract class ForwardingValueGraph&lt;N, V&gt; extends AbstractValueGraph&lt;N, V&gt; {

  abstract ValueGraph&lt;N, V&gt; delegate();

<A NAME="1"></A>  @Override
  public Set&lt;N&gt; nodes() {
    return delegate().nodes();
  <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match458109-0.html#1',2,'match458109-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  /**
   * Defer to {@link AbstractValueGraph#edges()} (based on {@link #successors(Object)}) for full
   * edges() implementation.
   */
  @Override
  protected long edgeCount() {
    return delegate().edges().size();
  }
<A NAME="2"></A>
  @</B></FONT>Override
  public boolean isDirected() {
    return <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match458109-0.html#2',2,'match458109-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>delegate().isDirected();
  }

  @Override
  public boolean allowsSelfLoops() {
    return delegate().allowsSelfLoops();
  }</B></FONT>

  @Override
  public ElementOrder&lt;N&gt; nodeOrder() {
<A NAME="0"></A>    return delegate().nodeOrder();
  }

  <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match458109-0.html#0',2,'match458109-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
  public ElementOrder&lt;N&gt; incidentEdgeOrder() {
    return delegate().incidentEdgeOrder();
  }
<A NAME="4"></A>
  @Override
  public Set&lt;N&gt; adjacentNodes(N node) {
    return <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match458109-0.html#4',2,'match458109-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>delegate().adjacentNodes</B></FONT>(node);
  }
<A NAME="3"></A>
  @Override
  public Set&lt;N&gt; predecessors(N node) {
    return <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match458109-0.html#3',2,'match458109-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>delegate().predecessors</B></FONT>(node);
  }

  @Override
  public Set&lt;N&gt; successors(N node) {
    return delegate().successors</B></FONT>(node);
  }

  @Override
  public int degree(N node) {
    return delegate().degree(node);
  }

  @Override
  public int inDegree(N node) {
    return delegate().inDegree(node);
  }

  @Override
  public int outDegree(N node) {
    return delegate().outDegree(node);
  }

  @Override
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
    return delegate().hasEdgeConnecting(nodeU, nodeV);
  }

  @Override
  public boolean hasEdgeConnecting(EndpointPair&lt;N&gt; endpoints) {
    return delegate().hasEdgeConnecting(endpoints);
  }

  @Override
  public Optional&lt;V&gt; edgeValue(N nodeU, N nodeV) {
    return delegate().edgeValue(nodeU, nodeV);
  }

  @Override
  public Optional&lt;V&gt; edgeValue(EndpointPair&lt;N&gt; endpoints) {
    return delegate().edgeValue(endpoints);
  }

  @Override
  @CheckForNull
  public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
    return delegate().edgeValueOrDefault(nodeU, nodeV, defaultValue);
  }

  @Override
  @CheckForNull
  public V edgeValueOrDefault(EndpointPair&lt;N&gt; endpoints, @CheckForNull V defaultValue) {
    return delegate().edgeValueOrDefault(endpoints, defaultValue);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
