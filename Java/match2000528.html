<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FsDirectoryFactory.java &amp; ExplainPlan.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FsDirectoryFactory.java &amp; ExplainPlan.java
      </h3>
<h1 align="center">
        10.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FsDirectoryFactory.java (13.571428%)<th>ExplainPlan.java (9.090909%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-48)<td><a href="#" name="0">(22-48)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(69-74)<td><a href="#" name="1">(276-282)</a><td align="center"><font color="#750000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FsDirectoryFactory.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.index.store;
2 import java.io.IOException;
3 import java.nio.file.Files;
4 import java.nio.file.Path;
5 import java.util.HashSet;
6 import java.util.Set;
7 import org.apache.lucene.store.Directory;
8 import org.apache.lucene.store.FSDirectory;
9 import org.apache.lucene.store.FileSwitchDirectory;
10 import org.apache.lucene.store.FilterDirectory;
11 import org.apache.lucene.store.IOContext;
12 import org.apache.lucene.store.IndexInput;
13 import org.apache.lucene.store.LockFactory;
14 import org.apache.lucene.store.MMapDirectory;
15 import org.apache.lucene.store.NIOFSDirectory;
16 import org.apache.lucene.store.NativeFSLockFactory;
17 import org.apache.lucene.store.SimpleFSDirectory;
18 import org.apache.lucene.store.SimpleFSLockFactory;
19 import org.elasticsearch.common.settings.Setting;
20 import org.elasticsearch.common.settings.Setting.Property;
21 import org.elasticsearch.index.IndexModule;
22 import org.elasticsearch.index.IndexSettings;
23 import org.elasticsearch.index.shard.ShardPath;
24 import org.elasticsearch.plugins.IndexStorePlugin;
25 import io.crate.common.io.IOUtils;
26 import</b></font> io.crate.types.DataTypes;
27 public class FsDirectoryFactory implements IndexStorePlugin.DirectoryFactory {
28     public static final Setting&lt;LockFactory&gt; INDEX_LOCK_FACTOR_SETTING = new Setting&lt;&gt;("index.store.fs.fs_lock", "native", (s) -&gt; {
29         switch (s) {
30             case "native":
31                 return NativeFSLockFactory.INSTANCE;
32             case "simple":
33                 return SimpleFSLockFactory.INSTANCE;
34             default:
35                 throw new IllegalArgumentException("unrecognized [index.store.fs.fs_lock] \"" + s + "\": must be native or simple");
36         }     }, DataTypes.STRING, Property.IndexScope, Property.NodeScope);
37     @Override
38     public Directory newDirectory(IndexSettings indexSettings, ShardPath path) throws IOException {
39 <a name="1"></a>        final Path location = path.resolveIndex();
40         final LockFactory lockFactory = indexSettings.getValue(INDEX_LOCK_FACTOR_SETTING);
41         Files.createDirectories(location);
42         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return newFSDirectory(location, lockFactory, indexSettings);
43     }
44     protected Directory newFSDirectory(Path location, LockFactory lockFactory, IndexSettings indexSettings) throws IOException {
45         final String storeType = indexSettings.getSettings</b></font>()
46             .get(IndexModule.INDEX_STORE_TYPE_SETTING.getKey(), IndexModule.Type.FS.getSettingsKey());
47         IndexModule.Type type;
48         if (IndexModule.Type.FS.match(storeType)) {
49             type = IndexModule.defaultStoreType(
50                 IndexModule.NODE_STORE_ALLOW_MMAP.getWithFallback(indexSettings.getNodeSettings()));
51         } else {
52             type = IndexModule.Type.fromSettingsKey(storeType);
53         }
54         Set&lt;String&gt; preLoadExtensions = new HashSet&lt;&gt;(indexSettings.getValue(IndexModule.INDEX_STORE_PRE_LOAD_SETTING));
55         switch (type) {
56             case HYBRIDFS:
57                 final FSDirectory primaryDirectory = FSDirectory.open(location, lockFactory);
58                 if (primaryDirectory instanceof MMapDirectory) {
59                     MMapDirectory mMapDirectory = (MMapDirectory) primaryDirectory;
60                     return new HybridDirectory(lockFactory, setPreload(mMapDirectory, lockFactory, preLoadExtensions));
61                 } else {
62                     return primaryDirectory;
63                 }
64             case MMAPFS:
65                 return setPreload(new MMapDirectory(location, lockFactory), lockFactory, preLoadExtensions);
66             case SIMPLEFS:
67                 return new SimpleFSDirectory(location, lockFactory);
68             case NIOFS:
69                 return new NIOFSDirectory(location, lockFactory);
70             default:
71                 throw new AssertionError("unexpected built-in store type [" + type + "]");
72         }
73     }
74     public static MMapDirectory setPreload(MMapDirectory mMapDirectory,
75                                            LockFactory lockFactory,
76                                            Set&lt;String&gt; preLoadExtensions) throws IOException {
77         assert mMapDirectory.getPreload() == false;
78         if (preLoadExtensions.isEmpty() == false) {
79             if (preLoadExtensions.contains("*")) {
80                 mMapDirectory.setPreload(true);
81             } else {
82                 return new PreLoadMMapDirectory(mMapDirectory, lockFactory, preLoadExtensions);
83             }
84         }
85         return mMapDirectory;
86     }
87     public static boolean isHybridFs(Directory directory) {
88         Directory unwrap = FilterDirectory.unwrap(directory);
89         return unwrap instanceof HybridDirectory;
90     }
91     static final class HybridDirectory extends NIOFSDirectory {
92         private final MMapDirectory delegate;
93         HybridDirectory(LockFactory lockFactory, MMapDirectory delegate) throws IOException {
94             super(delegate.getDirectory(), lockFactory);
95             this.delegate = delegate;
96         }
97         @Override
98         public IndexInput openInput(String name, IOContext context) throws IOException {
99             if (useDelegate(name)) {
100                 ensureOpen();
101                 ensureCanRead(name);
102                 return delegate.openInput(name, context);
103             } else {
104                 return super.openInput(name, context);
105             }
106         }
107         @Override
108         public void close() throws IOException {
109             IOUtils.close(super::close, delegate);
110         }
111         boolean useDelegate(String name) {
112             String extension = FileSwitchDirectory.getExtension(name);
113             switch (extension) {
114                 case "nvd":
115                 case "dvd":
116                 case "tim":
117                 case "tip":
118                 case "dim":
119                 case "kdd":
120                 case "kdi":
121                 case "cfs":
122                 case "doc":
123                     return true;
124                 default:
125                     return false;
126             }
127         }
128         MMapDirectory getDelegate() {
129             return delegate;
130         }
131     }
132     static final class PreLoadMMapDirectory extends MMapDirectory {
133         private final MMapDirectory delegate;
134         private final Set&lt;String&gt; preloadExtensions;
135         PreLoadMMapDirectory(MMapDirectory delegate, LockFactory lockFactory, Set&lt;String&gt; preload) throws IOException {
136             super(delegate.getDirectory(), lockFactory);
137             super.setPreload(false);
138             this.delegate = delegate;
139             this.delegate.setPreload(true);
140             this.preloadExtensions = preload;
141             assert getPreload() == false;
142         }
143         @Override
144         public void setPreload(boolean preload) {
145             throw new IllegalArgumentException("can't set preload on a preload-wrapper");
146         }
147         @Override
148         public IndexInput openInput(String name, IOContext context) throws IOException {
149             if (useDelegate(name)) {
150                 ensureOpen();
151                 ensureCanRead(name);
152                 return delegate.openInput(name, context);
153             }
154             return super.openInput(name, context);
155         }
156         @Override
157         public synchronized void close() throws IOException {
158             IOUtils.close(super::close, delegate);
159         }
160         boolean useDelegate(String name) {
161             final String extension = FileSwitchDirectory.getExtension(name);
162             return preloadExtensions.contains(extension);
163         }
164         MMapDirectory getDelegate() {
165             return delegate;
166         }
167     }
168 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ExplainPlan.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.planner.node.management;
2 import io.crate.action.sql.BaseResultReceiver;
3 import io.crate.action.sql.RowConsumerToResultReceiver;
4 import io.crate.common.annotations.VisibleForTesting;
5 import io.crate.common.collections.MapBuilder;
6 import io.crate.data.InMemoryBatchIterator;
7 import io.crate.data.Row;
8 import io.crate.data.Row1;
9 import io.crate.data.RowConsumer;
10 import io.crate.execution.dsl.phases.ExecutionPhase;
11 import io.crate.execution.dsl.phases.NodeOperation;
12 import io.crate.execution.dsl.phases.NodeOperationGrouper;
13 import io.crate.execution.dsl.phases.NodeOperationTree;
14 import io.crate.execution.engine.profile.TransportCollectProfileNodeAction;
15 import io.crate.execution.engine.profile.TransportCollectProfileOperation;
16 import io.crate.execution.support.OneRowActionListener;
17 import io.crate.planner.DependencyCarrier;
18 import io.crate.planner.ExecutionPlan;
19 import io.crate.planner.Plan;
20 import io.crate.planner.PlanPrinter;
21 import io.crate.planner.PlannerContext;
22 import io.crate.planner.operators.LogicalPlan;
23 import io.crate.planner.operators.LogicalPlanner;
24 import io.crate.planner.operators.PrintContext;
25 import io.crate.planner.operators.SubQueryResults;
26 import</b></font> io.crate.planner.statement.CopyFromPlan;
27 import io.crate.profile.ProfilingContext;
28 import io.crate.profile.Timer;
29 import io.crate.types.DataTypes;
30 import javax.annotation.Nullable;
31 import java.util.Collection;
32 import java.util.Collections;
33 import java.util.HashMap;
34 import java.util.Map;
35 import java.util.Set;
36 import java.util.TreeMap;
37 import java.util.UUID;
38 import java.util.concurrent.CompletableFuture;
39 import java.util.concurrent.ConcurrentHashMap;
40 import java.util.concurrent.atomic.AtomicInteger;
41 import java.util.function.BiConsumer;
42 import static io.crate.data.SentinelRow.SENTINEL;
43 public class ExplainPlan implements Plan {
44     public enum Phase {
45         Analyze,
46         Plan,
47         Execute
48     }
49     private final Plan subPlan;
50     @Nullable
51     private final ProfilingContext context;
52     public ExplainPlan(Plan subExecutionPlan, @Nullable ProfilingContext context) {
53         this.subPlan = subExecutionPlan;
54         this.context = context;
55     }
56     public Plan subPlan() {
57         return subPlan;
58     }
59     @Override
60     public StatementType type() {
61         return StatementType.MANAGEMENT;
62     }
63     @Override
64     public void executeOrFail(DependencyCarrier dependencies,
65                               PlannerContext plannerContext,
66                               RowConsumer consumer,
67                               Row params,
68                               SubQueryResults subQueryResults) {
69         if (context != null) {
70             assert subPlan instanceof LogicalPlan : "subPlan must be a LogicalPlan";
71             LogicalPlan plan = (LogicalPlan) subPlan;
72             if (plan.dependencies().isEmpty()) {
73                 UUID jobId = plannerContext.jobId();
74                 BaseResultReceiver resultReceiver = new BaseResultReceiver();
75                 RowConsumer noopRowConsumer = new RowConsumerToResultReceiver(resultReceiver, 0, t -&gt; {});
76                 Timer timer = context.createTimer(Phase.Execute.name());
77                 timer.start();
78                 NodeOperationTree operationTree = LogicalPlanner.getNodeOperationTree(
79                     plan, dependencies, plannerContext, params, subQueryResults);
80                 resultReceiver.completionFuture()
81                     .whenComplete(createResultConsumer(dependencies, consumer, jobId, timer, operationTree));
82                 LogicalPlanner.executeNodeOpTree(
83                     dependencies,
84                     plannerContext.transactionContext(),
85                     jobId,
86                     noopRowConsumer,
87                     true,
88                     operationTree
89                 );
90             } else {
91                 consumer.accept(null,
92                     new UnsupportedOperationException("EXPLAIN ANALYZE does not support profiling multi-phase plans, " +
93                                                       "such as queries with scalar subselects."));
94             }
95         } else {
96             if (subPlan instanceof LogicalPlan) {
97                 PrintContext printContext = new PrintContext();
98                 ((LogicalPlan) subPlan).print(printContext);
99                 consumer.accept(InMemoryBatchIterator.of(new Row1(printContext.toString()), SENTINEL), null);
100             } else if (subPlan instanceof CopyFromPlan) {
101                 ExecutionPlan executionPlan = CopyFromPlan.planCopyFromExecution(
102                         ((CopyFromPlan) subPlan).copyFrom(),
103                         dependencies.clusterService().state().nodes(),
104                         plannerContext,
105                         params,
106                         subQueryResults
107                     );
108                 String planAsJson = DataTypes.STRING.implicitCast(PlanPrinter.objectMap(executionPlan));
109                 consumer.accept(InMemoryBatchIterator.of(new Row1(planAsJson), SENTINEL), null);
110             } else {
111                 consumer.accept(InMemoryBatchIterator.of(
112                     new Row1("EXPLAIN not supported for " + subPlan.getClass().getSimpleName()), SENTINEL), null);
113             }
114         }
115     }
116     private BiConsumer&lt;Void, Throwable&gt; createResultConsumer(DependencyCarrier executor,
117                                                              RowConsumer consumer,
118                                                              UUID jobId,
119                                                              Timer timer,
120                                                              NodeOperationTree operationTree) {
121         assert context != null : "profilingContext must be available if createResultconsumer is used";
122         return (ignored, t) -&gt; {
123             context.stopTimerAndStoreDuration(timer);
124             if (t == null) {
125                 OneRowActionListener&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt; actionListener =
126                     new OneRowActionListener&lt;&gt;(consumer,
127                         resp -&gt; buildResponse(context.getDurationInMSByTimer(), resp, operationTree));
128                 collectTimingResults(jobId, executor, operationTree.nodeOperations())
129                     .whenComplete(actionListener);
130             } else {
131                 consumer.accept(null, t);
132             }
133         };
134     }
135     private TransportCollectProfileOperation getRemoteCollectOperation(DependencyCarrier executor, UUID jobId) {
136         TransportCollectProfileNodeAction nodeAction = executor.transportActionProvider()
137             .transportCollectProfileNodeAction();
138         return new TransportCollectProfileOperation(nodeAction, jobId);
139     }
140     private Row buildResponse(Map&lt;String, Object&gt; apeTimings,
141                               Map&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId,
142                               NodeOperationTree operationTree) {
143         MapBuilder&lt;String, Object&gt; mapBuilder = MapBuilder.newMapBuilder();
144         apeTimings.forEach(mapBuilder::put);
145         //
146         //
147         Map&lt;String, Object&gt; phasesTimings = extractPhasesTimingsFrom(timingsByNodeId, operationTree);
148         Map&lt;String, Map&lt;String, Object&gt;&gt; resultNodeTimings = getNodeTimingsWithoutPhases(phasesTimings.keySet(), timingsByNodeId);
149         MapBuilder&lt;String, Object&gt; executionTimingsMap = MapBuilder.newMapBuilder();
150         executionTimingsMap.put("Phases", phasesTimings);
151         resultNodeTimings.forEach(executionTimingsMap::put);
152         executionTimingsMap.put("Total", apeTimings.get(Phase.Execute.name()));
153         mapBuilder.put(Phase.Execute.name(), executionTimingsMap.immutableMap());
154         return new Row1(mapBuilder.immutableMap());
155     }
156     private static Map&lt;String, Object&gt; extractPhasesTimingsFrom(Map&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId,
157                                                                 NodeOperationTree operationTree) {
158         Map&lt;String, Object&gt; allPhases = new TreeMap&lt;&gt;();
159         for (NodeOperation operation : operationTree.nodeOperations()) {
160             ExecutionPhase phase = operation.executionPhase();
161             getPhaseTimingsAndAddThemToPhasesMap(phase, timingsByNodeId, allPhases);
162         }
163         ExecutionPhase leafExecutionPhase = operationTree.leaf();
164         getPhaseTimingsAndAddThemToPhasesMap(leafExecutionPhase, timingsByNodeId, allPhases);
165         return allPhases;
166     }
167     private static void getPhaseTimingsAndAddThemToPhasesMap(ExecutionPhase leafExecutionPhase,
168                                                              Map&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId,
169                                                              Map&lt;String, Object&gt; allPhases) {
170         String phaseName = ProfilingContext.generateProfilingKey(leafExecutionPhase.phaseId(), leafExecutionPhase.name());
171         Map&lt;String, Object&gt; phaseTimingsAcrossNodes = getPhaseTimingsAcrossNodes(phaseName, timingsByNodeId);
172         if (!phaseTimingsAcrossNodes.isEmpty()) {
173             allPhases.put(phaseName, Map.of("nodes", phaseTimingsAcrossNodes));
174         }
175     }
176     private static Map&lt;String, Object&gt; getPhaseTimingsAcrossNodes(String phaseName,
177                                                                   Map&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId) {
178         Map&lt;String, Object&gt; timingsForPhaseAcrossNodes = new HashMap&lt;&gt;();
179         for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; nodeToTimingsEntry : timingsByNodeId.entrySet()) {
180             Map&lt;String, Object&gt; timingsForNode = nodeToTimingsEntry.getValue();
181             if (timingsForNode != null) {
182                 Object phaseTiming = timingsForNode.get(phaseName);
183                 if (phaseTiming != null) {
184                     String node = nodeToTimingsEntry.getKey();
185                     timingsForPhaseAcrossNodes.put(node, phaseTiming);
186                 }
187             }
188         }
189         return Collections.unmodifiableMap(timingsForPhaseAcrossNodes);
190     }
191     private static Map&lt;String, Map&lt;String, Object&gt;&gt; getNodeTimingsWithoutPhases(Set&lt;String&gt; phasesNames,
192                                                                                 Map&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId) {
193         Map&lt;String, Map&lt;String, Object&gt;&gt; nodeTimingsWithoutPhases = new HashMap&lt;&gt;(timingsByNodeId.size());
194         for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; nodeToTimingsEntry : timingsByNodeId.entrySet()) {
195             nodeTimingsWithoutPhases.put(nodeToTimingsEntry.getKey(), new HashMap&lt;&gt;(nodeToTimingsEntry.getValue()));
196         }
197         for (Map&lt;String, Object&gt; timings : nodeTimingsWithoutPhases.values()) {
198             for (String phaseToRemove : phasesNames) {
199                 timings.remove(phaseToRemove);
200 <a name="1"></a>            }
201         }
202         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return Collections.unmodifiableMap(nodeTimingsWithoutPhases);
203     }
204     private CompletableFuture&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt; collectTimingResults(UUID jobId,
205                                                                                      DependencyCarrier executor,
206                                                                                      Collection&lt;NodeOperation&gt; nodeOperations) {
207         Set&lt;String&gt; nodeIds = NodeOperationGrouper.groupByServer</b></font>(nodeOperations).keySet();
208         CompletableFuture&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt; resultFuture = new CompletableFuture&lt;&gt;();
209         TransportCollectProfileOperation remoteCollectOperation = getRemoteCollectOperation(executor, jobId);
210         ConcurrentHashMap&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId = new ConcurrentHashMap&lt;&gt;(nodeIds.size());
211         boolean needsCollectLocal = !nodeIds.contains(executor.localNodeId());
212         AtomicInteger remainingCollectOps = new AtomicInteger(nodeIds.size());
213         if (needsCollectLocal) {
214             remainingCollectOps.incrementAndGet();
215         }
216         for (String nodeId : nodeIds) {
217             remoteCollectOperation.collect(nodeId)
218                 .whenComplete(mergeResultsAndCompleteFuture(resultFuture, timingsByNodeId, remainingCollectOps, nodeId));
219         }
220         if (needsCollectLocal) {
221             executor
222                 .transportActionProvider()
223                 .transportCollectProfileNodeAction()
224                 .collectExecutionTimesAndFinishContext(jobId)
225                 .whenComplete(mergeResultsAndCompleteFuture(resultFuture, timingsByNodeId, remainingCollectOps, executor.localNodeId()));
226         }
227         return resultFuture;
228     }
229     private static BiConsumer&lt;Map&lt;String, Object&gt;, Throwable&gt; mergeResultsAndCompleteFuture(CompletableFuture&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt; resultFuture,
230                                                                                             ConcurrentHashMap&lt;String, Map&lt;String, Object&gt;&gt; timingsByNodeId,
231                                                                                             AtomicInteger remainingOperations,
232                                                                                             String nodeId) {
233         return (map, throwable) -&gt; {
234             if (throwable == null) {
235                 timingsByNodeId.put(nodeId, map);
236                 if (remainingOperations.decrementAndGet() == 0) {
237                     resultFuture.complete(timingsByNodeId);
238                 }
239             } else {
240                 resultFuture.completeExceptionally(throwable);
241             }
242         };
243     }
244     @VisibleForTesting
245     public boolean doAnalyze() {
246         return context != null;
247     }
248 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
