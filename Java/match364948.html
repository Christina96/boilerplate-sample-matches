<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ConcurrentHashMultisetBenchmark_1.java &amp; MoreFiles.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ConcurrentHashMultisetBenchmark_1.java &amp; MoreFiles.java
      </h3>
<h1 align="center">
        15.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ConcurrentHashMultisetBenchmark_1.java (17.271408%)<th>MoreFiles.java (13.325868%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-40)<td><a href="#" name="0">(17-40)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(455-465)<td><a href="#" name="1">(215-225)</a><td align="center"><font color="#b90000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(536-546)<td><a href="#" name="2">(184-202)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(87-94)<td><a href="#" name="3">(330-339)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(76-83)<td><a href="#" name="4">(357-371)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(487-494)<td><a href="#" name="5">(112-119)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(431-434)<td><a href="#" name="6">(307-310)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(339-353)<td><a href="#" name="7">(759-767)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(304-309)<td><a href="#" name="8">(720-734)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(125-131)<td><a href="#" name="9">(425-433)</a><td align="center"><font color="#680000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConcurrentHashMultisetBenchmark_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
4 import com.google.caliper.BeforeExperiment;
5 import com.google.caliper.Benchmark;
6 import com.google.caliper.Param;
7 import com.google.common.annotations.VisibleForTesting;
8 import com.google.common.primitives.Ints;
9 import com.google.common.util.concurrent.ThreadFactoryBuilder;
10 import java.util.Iterator;
11 import java.util.List;
12 import java.util.Map;
13 import java.util.Random;
14 import java.util.Set;
15 import java.util.concurrent.Callable;
16 import java.util.concurrent.ConcurrentHashMap;
17 import java.util.concurrent.ConcurrentMap;
18 import java.util.concurrent.ExecutionException;
19 import java.util.concurrent.ExecutorService;
20 import java.util.concurrent.Executors;
21 import java.util.concurrent.Future;
22 import</b></font> javax.annotation.CheckForNull;
23 public class ConcurrentHashMultisetBenchmark {
24   @Param({"1", "2", "4", "8"})
25   int threads;
26   @Param({"3", "30", "300"})
27   int size;
28   @Param MultisetSupplier implSupplier;
29   private Multiset&lt;Integer&gt; multiset;
30   private ImmutableList&lt;Integer&gt; keys;
31   private ExecutorService threadPool;
32   @BeforeExperiment
33   void setUp() throws Exception {
34     multiset = implSupplier.get();
35     ImmutableList.Builder&lt;Integer&gt; builder = ImmutableList.builder();
36     for (int i = 0; i &lt; size; i++) {
37       builder.add(i);
38     }
39     keys = builder.build();
40     threadPool =
41         Executors.newFixedThreadPool(threads, new ThreadFactoryBuilder().setDaemon(true).build());
42   }
43   @Benchmark
44 <a name="4"></a>  long add(final int reps) throws ExecutionException, InterruptedException {
45     return doMultithreadedLoop(
46         new Callable&lt;Long&gt;() {
47           <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
48           public Long call() {
49             return runAddSingleThread(reps);
50           }
51         });
52   }
53   @Benchmar</b></font>k
54 <a name="3"></a>  long addRemove(final int reps) throws ExecutionException, InterruptedException {
55     return doMultithreadedLoop(
56         new Callable&lt;Long&gt;() {
57           <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
58           public Long call() {
59             return runAddRemoveSingleThread(reps);
60           }
61         });
62   }
63   private long doMultithreadedLoop(Callable&lt;Long&gt; task</b></font>)
64       throws InterruptedException, ExecutionException {
65     List&lt;Future&lt;Long&gt;&gt; futures = Lists.newArrayListWithCapacity(threads);
66     for (int i = 0; i &lt; threads; i++) {
67       futures.add(threadPool.submit(task));
68     }
69     long total = 0;
70     for (Future&lt;Long&gt; future : futures) {
71       total += future.get();
72     }
73     return total;
74   }
75   private long runAddSingleThread(int reps) {
76     Random random = new Random();
77     int nKeys = keys.size();
78     long blah = 0;
79     for (int i = 0; i &lt; reps; i++) {
80       Integer key = keys.get(random.nextInt(nKeys));
81       int delta = random.nextInt(5);
82       blah += delta;
83       multiset.add(key, delta);
84     }
85     return blah;
86   }
87   private long runAddRemoveSingleThread(int reps) {
88 <a name="9"></a>    Random random = new Random();
89     int nKeys = keys.size();
90     long blah = 0;
91     for (<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int i = 0; i &lt; reps; i++) {
92       Integer key = keys.get(random.nextInt(nKeys));
93       int delta = random.nextInt(10) - 5;
94       blah += delta;
95       if (delta &gt;= 0) {</b></font>
96         multiset.add(key, delta);
97       } else {
98         multiset.remove(key, -delta);
99       }
100     }
101     return blah;
102   }
103   private enum MultisetSupplier {
104     CONCURRENT_HASH_MULTISET() {
105       @Override
106       Multiset&lt;Integer&gt; get() {
107         return ConcurrentHashMultiset.create();
108       }
109     },
110     BOXED_ATOMIC_REPLACE() {
111       @Override
112       Multiset&lt;Integer&gt; get() {
113         return OldConcurrentHashMultiset.create();
114       }
115     },
116     SYNCHRONIZED_MULTISET() {
117       @Override
118       Multiset&lt;Integer&gt; get() {
119         return Synchronized.multiset(HashMultiset.&lt;Integer&gt;create(), null);
120       }
121     },
122     ;
123     abstract Multiset&lt;Integer&gt; get();
124   }
125   private static final class OldConcurrentHashMultiset&lt;E&gt; extends AbstractMultiset&lt;E&gt; {
126     private final transient ConcurrentMap&lt;E, Integer&gt; countMap;
127     public static &lt;E&gt; OldConcurrentHashMultiset&lt;E&gt; create() {
128       return new OldConcurrentHashMultiset&lt;E&gt;(new ConcurrentHashMap&lt;E, Integer&gt;());
129     }
130     @VisibleForTesting
131     OldConcurrentHashMultiset(ConcurrentMap&lt;E, Integer&gt; countMap) {
132       checkArgument(countMap.isEmpty());
133       this.countMap = countMap;
134     }
135     @Override
136     public int count(@CheckForNull Object element) {
137       try {
138         return unbox(countMap.get(element));
139       } catch (NullPointerException | ClassCastException e) {
140         return 0;
141       }
142     }
143     @Override
144     public int size() {
145       long sum = 0L;
146       for (Integer value : countMap.values()) {
147         sum += value;
148       }
149       return Ints.saturatedCast(sum);
150     }
151     @Override
152     public Object[] toArray() {
153       return snapshot().toArray();
154     }
155     @Override
156     public &lt;T&gt; T[] toArray(T[] array) {
157       return snapshot().toArray(array);
158     }
159     private List&lt;E&gt; snapshot() {
160       List&lt;E&gt; list = Lists.newArrayListWithExpectedSize(size());
161       for (Multiset.Entry&lt;E&gt; entry : entrySet()) {
162         E element = entry.getElement();
163         for (int i = entry.getCount(); i &gt; 0; i--) {
164           list.add(element);
165         }
166       }
167       return list;
168     }
169     @Override
170     public int add(E element, int occurrences) {
171       if (occurrences == 0) {
172         return count(element);
173       }
174       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
175       while (true) {
176         int current = count(element);
177         if (current == 0) {
178           if (countMap.putIfAbsent(element, occurrences) == null) {
179             return 0;
180           }
181         } else {
182           checkArgument(
183               occurrences &lt;= Integer.MAX_VALUE - current,
184               "Overflow adding %s occurrences to a count of %s",
185               occurrences,
186               current);
187           int next = current + occurrences;
188           if (countMap.replace(element, current, next)) {
189             return current;
190           }
191         }
192       }
193     }
194     @Override
195     public int remove(@CheckForNull Object element, int occurrences) {
196       if (occurrences == 0) {
197         return count(element);
198 <a name="8"></a>      }
199       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
200       while (true) <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
201         int current = count(element);
202         if (current == 0) {
203           return 0;
204         }
205         if</b></font> (occurrences &gt;= current) {
206           if (countMap.remove(element, current)) {
207             return current;
208           }
209         } else {
210           @SuppressWarnings("unchecked")
211           E casted = (E) element;
212           if (countMap.replace(casted, current, current - occurrences)) {
213             return current;
214           }
215         }
216       }
217     }
218     private int removeAllOccurrences(@CheckForNull Object element) {
219       try {
220         return unbox(countMap.remove(element));
221 <a name="7"></a>      } catch (NullPointerException | ClassCastException e) {
222         return 0;
223       }
224     <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
225     public boolean removeExactly(@CheckForNull Object element, int occurrences) {
226       if (occurrences == 0) {</b></font>
227         return true;
228       }
229       checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
230       while (true) {
231         int current = count(element);
232         if (occurrences &gt; current) {
233           return false;
234         }
235         if (occurrences == current) {
236           if (countMap.remove(element, occurrences)) {
237             return true;
238           }
239         } else {
240           @SuppressWarnings("unchecked")           E casted = (E) element;
241           if (countMap.replace(casted, current, current - occurrences)) {
242             return true;
243           }
244         }
245       }
246     }
247     @Override
248     public int setCount(E element, int count) {
249       checkNonnegative(count, "count");
250       return (count == 0) ? removeAllOccurrences(element) : unbox(countMap.put(element, count));
251     }
252     @Override
253     public boolean setCount(E element, int oldCount, int newCount) {
254       checkNonnegative(oldCount, "oldCount");
255       checkNonnegative(newCount, "newCount");
256       if (newCount == 0) {
257         if (oldCount == 0) {
258           return !countMap.containsKey(element);
259         } else {
260           return countMap.remove(element, oldCount);
261         }
262       }
263       if (oldCount == 0) {
264         return countMap.putIfAbsent(element, newCount) == null;
265       }
266       return countMap.replace(element, oldCount, newCount);
267     }
268     @Override
269     Set&lt;E&gt; createElementSet() {
270       final Set&lt;E&gt; delegate = countMap.keySet();
271       return new ForwardingSet&lt;E&gt;() {
272         @Override
273         protected Set&lt;E&gt; delegate() {
274           return delegate;
275 <a name="6"></a>        }
276         @Override
277         public boolean remove(Object object) <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
278           try {
279             return delegate.remove(object);
280           } catch (NullPointerException | ClassCastException e) {</b></font>
281             return false;
282           }
283         }
284       };
285     }
286     @Override
287     Iterator&lt;E&gt; elementIterator() {
288       throw new AssertionError("should never be called");
289     }
290     private transient EntrySet entrySet;
291     @Override
292     public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
293       EntrySet result = entrySet;
294       if (result == null) {
295 <a name="1"></a>        entrySet = result = new EntrySet();
296       }
297       return result;
298     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
299     @Override
300     int distinctElements() {
301       return countMap.size();
302     }
303     @Override
304     public boolean isEmpty() {
305       return countMap.isEmpty();
306     }</b></font>
307     @Override
308     Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
309       final Iterator&lt;Map.Entry&lt;E, Integer&gt;&gt; backingIterator = countMap.entrySet().iterator();
310       return new Iterator&lt;Entry&lt;E&gt;&gt;() {
311         @Override
312         public boolean hasNext() {
313           return backingIterator.hasNext();
314         }
315         @Override
316         public Multiset.Entry&lt;E&gt; next() {
317           Map.Entry&lt;E, Integer&gt; backingEntry = backingIterator.next();
318           return Multisets.immutableEntry(backingEntry.getKey(), backingEntry.getValue());
319         }
320         @Override
321         public void remove() {
322 <a name="5"></a>          backingIterator.remove();
323         }
324       };
325     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
326     @Override
327     public Iterator&lt;E&gt; iterator() {
328       return Multisets.iteratorImpl(this);
329     }
330     @Over</b></font>ride
331     public void clear() {
332       countMap.clear();
333     }
334     private class EntrySet extends AbstractMultiset&lt;E&gt;.EntrySet {
335       @Override
336       Multiset&lt;E&gt; multiset() {
337         return OldConcurrentHashMultiset.this;
338       }
339       @Override
340       public Object[] toArray() {
341         return snapshot().toArray();
342       }
343       @Override
344       public &lt;T&gt; T[] toArray(T[] array) {
345         return snapshot().toArray(array);
346       }
347       private List&lt;Multiset.Entry&lt;E&gt;&gt; snapshot() {
348         List&lt;Multiset.Entry&lt;E&gt;&gt; list = Lists.newArrayListWithExpectedSize(size());
349         Iterators.addAll(list, iterator());
350         return list;
351       }
352       @Override
353       public boolean remove(Object object) {
354         if (object instanceof Multiset.Entry) {
355           Multiset.Entry&lt;?&gt; entry = (Multiset.Entry&lt;?&gt;) object;
356           Object element = entry.getElement();
357           int entryCount = entry.getCount();
358 <a name="2"></a>          return countMap.remove(element, entryCount);
359         }
360         return false;
361       <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
362       @Override
363       public int hashCode() {
364         return countMap.hashCode();
365       }
366     }
367     private static int unbox(@CheckForNull Integer i</b></font>) {
368       return (i == null) ? 0 : i;
369     }
370   }
371 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreFiles.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.io;
2 import static com.google.common.base.Preconditions.checkNotNull;
3 import static com.google.common.collect.Iterables.getOnlyElement;
4 import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
5 import static java.util.Objects.requireNonNull;
6 import com.google.common.annotations.Beta;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.base.Optional;
9 import com.google.common.base.Predicate;
10 import com.google.common.collect.ImmutableList;
11 import com.google.common.graph.SuccessorsFunction;
12 import com.google.common.graph.Traverser;
13 import com.google.j2objc.annotations.J2ObjCIncompatible;
14 import java.io.IOException;
15 import java.io.InputStream;
16 import java.io.OutputStream;
17 import java.nio.channels.Channels;
18 import java.nio.channels.SeekableByteChannel;
19 import java.nio.charset.Charset;
20 import java.nio.file.DirectoryIteratorException;
21 import java.nio.file.DirectoryStream;
22 import</b></font> java.nio.file.FileAlreadyExistsException;
23 import java.nio.file.FileSystemException;
24 import java.nio.file.Files;
25 import java.nio.file.LinkOption;
26 import java.nio.file.NoSuchFileException;
27 import java.nio.file.NotDirectoryException;
28 import java.nio.file.OpenOption;
29 import java.nio.file.Path;
30 import java.nio.file.SecureDirectoryStream;
31 import java.nio.file.StandardOpenOption;
32 import java.nio.file.attribute.BasicFileAttributeView;
33 import java.nio.file.attribute.BasicFileAttributes;
34 import java.nio.file.attribute.FileAttribute;
35 import java.nio.file.attribute.FileTime;
36 import java.util.ArrayList;
37 import java.util.Arrays;
38 import java.util.Collection;
39 import java.util.stream.Stream;
40 import javax.annotation.CheckForNull;
41 @Beta
42 @GwtIncompatible
43 @J2ObjCIncompatible @ElementTypesAreNonnullByDefault
44 public final class MoreFiles {
45   private MoreFiles() {}
46   public static ByteSource asByteSource(Path path, OpenOption... options) {
47     return new PathByteSource(path, options);
48   }
49   private static final class PathByteSource extends ByteSource {
50     private static final LinkOption[] FOLLOW_LINKS = {};
51     private final Path path;
52     private final OpenOption[] options;
53     private final boolean followLinks;
54     private PathByteSource(Path path, OpenOption... options) {
55       this.path = checkNotNull(path);
56       this.options = options.clone();
57       this.followLinks = followLinks(this.options);
58     }
59     private static boolean followLinks(OpenOption[] options) {
60       for (OpenOption option : options) {
61         if (option == NOFOLLOW_LINKS) {
62           return false;
63 <a name="5"></a>        }
64       }
65       return true;
66     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
67     @Override
68     public InputStream openStream() throws IOException {
69       return Files.newInputStream(path, options);
70     }
71     private BasicF</b></font>ileAttributes readAttributes() throws IOException {
72       return Files.readAttributes(
73           path,
74           BasicFileAttributes.class,
75           followLinks ? FOLLOW_LINKS : new LinkOption[] {NOFOLLOW_LINKS});
76     }
77     @Override
78     public Optional&lt;Long&gt; sizeIfKnown() {
79       BasicFileAttributes attrs;
80       try {
81         attrs = readAttributes();
82       } catch (IOException e) {
83         return Optional.absent();
84       }
85       if (attrs.isDirectory() || attrs.isSymbolicLink()) {
86         return Optional.absent();
87       }
88       return Optional.of(attrs.size());
89     }
90     @Override
91     public long size() throws IOException {
92       BasicFileAttributes attrs = readAttributes();
93       if (attrs.isDirectory()) {
94         throw new IOException("can't read: is a directory");
95       } else if (attrs.isSymbolicLink()) {
96         throw new IOException("can't read: is a symbolic link");
97       }
98       return attrs.size();
99     }
100     @Override
101     public byte[] read() throws IOException {
102       try (SeekableByteChannel channel = Files.newByteChannel(path, options)) {
103         return ByteStreams.toByteArray(Channels.newInputStream(channel), channel.size());
104       }
105     }
106     @Override
107     public CharSource asCharSource(Charset charset) {
108       if (options.length == 0) {
109         return new AsCharSource(charset) {
110           @SuppressWarnings("FilesLinesLeak")           @Override
111           public Stream&lt;String&gt; lines() throws IOException {
112             return Files.lines(path, charset);
113           }
114         };
115 <a name="2"></a>      }
116       return super.asCharSource(charset);
117     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
118     @Override
119     public String toString() {
120       return "MoreFiles.asByteSource(" + path + ", " + Arrays.toString(options) + ")";
121     }
122   }
123   public static ByteSink asByteSink(Path path</b></font>, OpenOption... options) {
124     return new PathByteSink(path, options);
125   }
126   private static final class PathByteSink extends ByteSink {
127     private final Path path;
128     private final OpenOption[] options;
129     private PathByteSink(Path path, OpenOption... options) {
130 <a name="1"></a>      this.path = checkNotNull(path);
131       this.options = options.clone();
132     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
133     @Override
134     public OutputStream openStream() throws IOException {
135       return Files.newOutputStream(path, options);
136     }
137     @Override
138     public String toString() {
139       return "MoreFiles.asByteSink(" + path + ", " + Arrays.toString(options) + ")";
140     }</b></font>
141   }
142   public static CharSource asCharSource(Path path, Charset charset, OpenOption... options) {
143     return asByteSource(path, options).asCharSource(charset);
144   }
145   public static CharSink asCharSink(Path path, Charset charset, OpenOption... options) {
146     return asByteSink(path, options).asCharSink(charset);
147   }
148   public static ImmutableList&lt;Path&gt; listFiles(Path dir) throws IOException {
149     try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) {
150       return ImmutableList.copyOf(stream);
151     } catch (DirectoryIteratorException e) {
152       throw e.getCause();
153     }
154   }
155   public static Traverser&lt;Path&gt; fileTraverser() {
156     return Traverser.forTree(FILE_TREE);
157   }
158   private static final SuccessorsFunction&lt;Path&gt; FILE_TREE =
159       new SuccessorsFunction&lt;Path&gt;() {
160         @Override
161         public Iterable&lt;Path&gt; successors(Path path) {
162           return fileTreeChildren(path);
163         }
164 <a name="6"></a>      };
165   private static Iterable&lt;Path&gt; fileTreeChildren(Path dir) {
166     if (Files.isDirectory(dir, NOFOLLOW_LINKS)) <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
167       try {
168         return listFiles(dir);
169       } catch (IOException e) {</b></font>
170         throw new DirectoryIteratorException(e);
171       }
172     }
173     return ImmutableList.of();
174   }
175   public static Predicate&lt;Path&gt; isDirectory(LinkOption... options) {
176     final LinkOption[] optionsCopy = options.clone();
177     return new Predicate&lt;Path&gt;() {
178       @Override
179       public boolean apply(Path input) {
180 <a name="3"></a>        return Files.isDirectory(input, optionsCopy);
181       }
182       <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
183       public String toString() {
184         return "MoreFiles.isDirectory(" + Arrays.toString(optionsCopy) + ")";
185       }
186     };
187   }
188   private static boolean isDirectory(
189       SecureDirectoryStream&lt;Path&gt; dir</b></font>, Path name, LinkOption... options) throws IOException {
190     return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)
191         .readAttributes()
192         .isDirectory();
193   }
194   public static Predicate&lt;Path&gt; isRegularFile(LinkOption... options) {
195     final LinkOption[] optionsCopy = options.clone();
196     return new Predicate&lt;Path&gt;() {
197       @Override
198       public boolean apply(Path input) {
199 <a name="4"></a>        return Files.isRegularFile(input, optionsCopy);
200       }
201       <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
202       public String toString() {
203         return "MoreFiles.isRegularFile(" + Arrays.toString(optionsCopy) + ")";
204       }
205     };
206   }
207   publi</b></font>c static boolean equal(Path path1, Path path2) throws IOException {
208     checkNotNull(path1);
209     checkNotNull(path2);
210     if (Files.isSameFile(path1, path2)) {
211       return true;
212     }
213     ByteSource source1 = asByteSource(path1);
214     ByteSource source2 = asByteSource(path2);
215     long len1 = source1.sizeIfKnown().or(0L);
216     long len2 = source2.sizeIfKnown().or(0L);
217     if (len1 != 0 &amp;&amp; len2 != 0 &amp;&amp; len1 != len2) {
218       return false;
219     }
220     return source1.contentEquals(source2);
221   }
222   @SuppressWarnings("GoodTime")   public static void touch(Path path) throws IOException {
223     checkNotNull(path);
224     try {
225       Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));
226     } catch (NoSuchFileException e) {
227       try {
228         Files.createFile(path);
229       } catch (FileAlreadyExistsException ignore) {
230       }
231     }
232   }
233   public static void createParentDirectories(Path path, <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>FileAttribute&lt;?&gt;... attrs)
234       throws IOException {
235     Path normalizedAbsolutePath = path.toAbsolutePath().normalize();
236     Path parent = normalizedAbsolutePath.getParent();
237     if (parent == null) {</b></font>
238       return;
239     }
240     if (!Files.isDirectory(parent)) {
241       Files.createDirectories(parent, attrs);
242       if (!Files.isDirectory(parent)) {
243         throw new IOException("Unable to create parent directories of " + path);
244       }
245     }
246   }
247   public static String getFileExtension(Path path) {
248     Path name = path.getFileName();
249     if (name == null) {
250       return "";
251     }
252     String fileName = name.toString();
253     int dotIndex = fileName.lastIndexOf('.');
254     return dotIndex == -1 ? "" : fileName.substring(dotIndex + 1);
255   }
256   public static String getNameWithoutExtension(Path path) {
257     Path name = path.getFileName();
258     if (name == null) {
259       return "";
260     }
261     String fileName = name.toString();
262     int dotIndex = fileName.lastIndexOf('.');
263     return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);
264   }
265   public static void deleteRecursively(Path path, RecursiveDeleteOption... options)
266       throws IOException {
267     Path parentPath = getParentPath(path);
268     if (parentPath == null) {
269       throw new FileSystemException(path.toString(), null, "can't delete recursively");
270     }
271     Collection&lt;IOException&gt; exceptions = null;     try {
272       boolean sdsSupported = false;
273       try (DirectoryStream&lt;Path&gt; parent = Files.newDirectoryStream(parentPath)) {
274         if (parent instanceof SecureDirectoryStream) {
275           sdsSupported = true;
276           exceptions =
277               deleteRecursivelySecure(
278                   (SecureDirectoryStream&lt;Path&gt;) parent,
279                   requireNonNull(path.getFileName()));
280         }
281       }
282       if (!sdsSupported) {
283         checkAllowsInsecure(path, options);
284         exceptions = deleteRecursivelyInsecure(path);
285       }
286     } catch (IOException e) {
287       if (exceptions == null) {
288         throw e;
289       } else {
290         exceptions.add(e);
291       }
292     }
293     if (exceptions != null) {
294       throwDeleteFailed(path, exceptions);
295     }
296   }
297   public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... options)
298       throws IOException {
299     Collection&lt;IOException&gt; exceptions = null;     try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
300       if (stream instanceof SecureDirectoryStream) {
301         SecureDirectoryStream&lt;Path&gt; sds = (SecureDirectoryStream&lt;Path&gt;) stream;
302         exceptions = deleteDirectoryContentsSecure(sds);
303       } else {
304         checkAllowsInsecure(path, options);
305         exceptions = deleteDirectoryContentsInsecure(stream);
306       }
307     } catch (IOException e) {
308       if (exceptions == null) {
309         throw e;
310       } else {
311         exceptions.add(e);
312       }
313     }
314     if (exceptions != null) {
315       throwDeleteFailed(path, exceptions);
316     }
317   }
318   @CheckForNull
319   private static Collection&lt;IOException&gt; deleteRecursivelySecure(
320       SecureDirectoryStream&lt;Path&gt; dir, Path path) {
321     Collection&lt;IOException&gt; exceptions = null;
322     try {
323       if (isDirectory(dir, path, NOFOLLOW_LINKS)) {
324         try (SecureDirectoryStream&lt;Path&gt; childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {
325           exceptions = deleteDirectoryContentsSecure(childDir);
326         }
327         if (exceptions == null) {
328           dir.deleteDirectory(path);
329         }
330       } else {
331         dir.deleteFile(path);
332       }
333       return exceptions;
334     } catch (IOException e) {
335       return addException(exceptions, e);
336     }
337   }
338   @CheckForNull
339   private static Collection&lt;IOException&gt; deleteDirectoryContentsSecure(
340       SecureDirectoryStream&lt;Path&gt; dir) {
341     Collection&lt;IOException&gt; exceptions = null;
342     try {
343       for (Path path : dir) {
344         exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));
345       }
346       return exceptions;
347     } catch (DirectoryIteratorException e) {
348       return addException(exceptions, e.getCause());
349     }
350   }
351   @CheckForNull
352   private static Collection&lt;IOException&gt; deleteRecursivelyInsecure(Path path) {
353     Collection&lt;IOException&gt; exceptions = null;
354     try {
355       if (Files.isDirectory(path, NOFOLLOW_LINKS)) {
356         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
357           exceptions = deleteDirectoryContentsInsecure(stream);
358         }
359       }
360       if (exceptions == null) {
361         Files.delete(path);
362       }
363       return exceptions;
364     } catch (IOException e) {
365       return addException(exceptions, e);
366     }
367   }
368   @CheckForNull
369   private static Collection&lt;IOException&gt; deleteDirectoryContentsInsecure(
370       DirectoryStream&lt;Path&gt; dir) {
371     Collection&lt;IOException&gt; exceptions = null;
372     try {
373       for (Path entry : dir) {
374         exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));
375       }
376       return exceptions;
377     } catch (DirectoryIteratorException e) {
378       return addException(exceptions, e.getCause());
379     }
380   }
381   @CheckForNull
382   private static Path getParentPath(Path path) <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
383     Path parent = path.getParent();
384     if (parent != null) {
385       return parent;
386     }
387     if</b></font> (path.getNameCount() == 0) {
388       //
389       return null;
390     } else {
391       return path.getFileSystem().getPath(".");
392     }
393   }
394   private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] options)
395       throws InsecureRecursiveDeleteException {
396 <a name="7"></a>    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {
397       throw new InsecureRecursiveDeleteException(path.toString());
398     }
399   <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
400   private static Collection&lt;IOException&gt; addException(
401       @CheckForNull Collection&lt;IOException&gt; exceptions, IOException e) {
402     if (exceptions == null) {</b></font>
403       exceptions = new ArrayList&lt;&gt;();     }
404     exceptions.add(e);
405     return exceptions;
406   }
407   @CheckForNull
408   private static Collection&lt;IOException&gt; concat(
409       @CheckForNull Collection&lt;IOException&gt; exceptions,
410       @CheckForNull Collection&lt;IOException&gt; other) {
411     if (exceptions == null) {
412       return other;
413     } else if (other != null) {
414       exceptions.addAll(other);
415     }
416     return exceptions;
417   }
418   private static void throwDeleteFailed(Path path, Collection&lt;IOException&gt; exceptions)
419       throws FileSystemException {
420     NoSuchFileException pathNotFound = pathNotFound(path, exceptions);
421     if (pathNotFound != null) {
422       throw pathNotFound;
423     }
424     FileSystemException deleteFailed =
425         new FileSystemException(
426             path.toString(),
427             null,
428             "failed to delete one or more files; see suppressed exceptions for details");
429     for (IOException e : exceptions) {
430       deleteFailed.addSuppressed(e);
431     }
432     throw deleteFailed;
433   }
434   @CheckForNull
435   private static NoSuchFileException pathNotFound(Path path, Collection&lt;IOException&gt; exceptions) {
436     if (exceptions.size() != 1) {
437       return null;
438     }
439     IOException exception = getOnlyElement(exceptions);
440     if (!(exception instanceof NoSuchFileException)) {
441       return null;
442     }
443     NoSuchFileException noSuchFileException = (NoSuchFileException) exception;
444     String exceptionFile = noSuchFileException.getFile();
445     if (exceptionFile == null) {
446       /*
447        * It's not clear whether this happens in practice, especially with the filesystem
448        * implementations that are built into java.nio.
449        */
450       return null;
451     }
452     Path parentPath = getParentPath(path);
453     if (parentPath == null) {
454       /*
455        * This is probably impossible:
456        *
457        * - In deleteRecursively, we require the path argument to have a parent.
458        *
459        * - In deleteDirectoryContents, the path argument may have no parent. Fortunately, all the
460        *   *other* paths we process will be descendants of that. That leaves only the original path
461        *   argument for us to consider. And the only place we call pathNotFound is from
462        *   throwDeleteFailed, and the other place that we call throwDeleteFailed inside
463        *   deleteDirectoryContents is when an exception is thrown during the recursive steps. Any
464        *   failure during the initial lookup of the path argument itself is rethrown directly. So
465        *   any exception that we're seeing here is from a descendant, which naturally has a parent.
466        *   I think.
467        *
468        * Still, if this can happen somehow (a weird filesystem implementation that lets callers
469        * change its working directly concurrently with a call to deleteDirectoryContents?), it makes
470        * more sense for us to fall back to a generic FileSystemException (by returning null here)
471        * than to dereference parentPath and end up producing NullPointerException.
472        */
473       return null;
474     }
475     Path pathResolvedFromParent = parentPath.resolve(requireNonNull(path.getFileName()));
476     if (exceptionFile.equals(pathResolvedFromParent.toString())) {
477       return noSuchFileException;
478     }
479     return null;
480   }
481 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
