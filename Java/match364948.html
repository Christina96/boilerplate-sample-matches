<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ConcurrentHashMultisetBenchmark_1.java &amp; MoreFiles.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ConcurrentHashMultisetBenchmark_1.java &amp; MoreFiles.java
      </h3>
<h1 align="center">
        15.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ConcurrentHashMultisetBenchmark_1.java (17.271408%)<th>MoreFiles.java (13.325868%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-40)<td><a href="#" name="0">(17-40)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(455-465)<td><a href="#" name="1">(215-225)</a><td align="center"><font color="#b90000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(536-546)<td><a href="#" name="2">(184-202)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(87-94)<td><a href="#" name="3">(330-339)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(76-83)<td><a href="#" name="4">(357-371)</a><td align="center"><font color="#7f0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(487-494)<td><a href="#" name="5">(112-119)</a><td align="center"><font color="#730000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(431-434)<td><a href="#" name="6">(307-310)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(339-353)<td><a href="#" name="7">(759-767)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(304-309)<td><a href="#" name="8">(720-734)</a><td align="center"><font color="#680000">9</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(125-131)<td><a href="#" name="9">(425-433)</a><td align="center"><font color="#680000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConcurrentHashMultisetBenchmark_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import com.google.caliper.BeforeExperiment;
import com.google.caliper.Benchmark;
import com.google.caliper.Param;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import</b></font> javax.annotation.CheckForNull;
public class ConcurrentHashMultisetBenchmark {
  @Param({"1", "2", "4", "8"})
  int threads;
  @Param({"3", "30", "300"})
  int size;
  @Param MultisetSupplier implSupplier;
  private Multiset&lt;Integer&gt; multiset;
  private ImmutableList&lt;Integer&gt; keys;
  private ExecutorService threadPool;
  @BeforeExperiment
  void setUp() throws Exception {
    multiset = implSupplier.get();
    ImmutableList.Builder&lt;Integer&gt; builder = ImmutableList.builder();
    for (int i = 0; i &lt; size; i++) {
      builder.add(i);
    }
    keys = builder.build();
    threadPool =
        Executors.newFixedThreadPool(threads, new ThreadFactoryBuilder().setDaemon(true).build());
  }
  @Benchmark
<a name="4"></a>  long add(final int reps) throws ExecutionException, InterruptedException {
    return doMultithreadedLoop(
        new Callable&lt;Long&gt;() {
          <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
          public Long call() {
            return runAddSingleThread(reps);
          }
        });
  }
  @Benchmar</b></font>k
<a name="3"></a>  long addRemove(final int reps) throws ExecutionException, InterruptedException {
    return doMultithreadedLoop(
        new Callable&lt;Long&gt;() {
          <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
          public Long call() {
            return runAddRemoveSingleThread(reps);
          }
        });
  }
  private long doMultithreadedLoop(Callable&lt;Long&gt; task</b></font>)
      throws InterruptedException, ExecutionException {
    List&lt;Future&lt;Long&gt;&gt; futures = Lists.newArrayListWithCapacity(threads);
    for (int i = 0; i &lt; threads; i++) {
      futures.add(threadPool.submit(task));
    }
    long total = 0;
    for (Future&lt;Long&gt; future : futures) {
      total += future.get();
    }
    return total;
  }
  private long runAddSingleThread(int reps) {
    Random random = new Random();
    int nKeys = keys.size();
    long blah = 0;
    for (int i = 0; i &lt; reps; i++) {
      Integer key = keys.get(random.nextInt(nKeys));
      int delta = random.nextInt(5);
      blah += delta;
      multiset.add(key, delta);
    }
    return blah;
  }
  private long runAddRemoveSingleThread(int reps) {
<a name="9"></a>    Random random = new Random();
    int nKeys = keys.size();
    long blah = 0;
    for (<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int i = 0; i &lt; reps; i++) {
      Integer key = keys.get(random.nextInt(nKeys));
      int delta = random.nextInt(10) - 5;
      blah += delta;
      if (delta &gt;= 0) {</b></font>
        multiset.add(key, delta);
      } else {
        multiset.remove(key, -delta);
      }
    }
    return blah;
  }
  private enum MultisetSupplier {
    CONCURRENT_HASH_MULTISET() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return ConcurrentHashMultiset.create();
      }
    },
    BOXED_ATOMIC_REPLACE() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return OldConcurrentHashMultiset.create();
      }
    },
    SYNCHRONIZED_MULTISET() {
      @Override
      Multiset&lt;Integer&gt; get() {
        return Synchronized.multiset(HashMultiset.&lt;Integer&gt;create(), null);
      }
    },
    ;
    abstract Multiset&lt;Integer&gt; get();
  }
  private static final class OldConcurrentHashMultiset&lt;E&gt; extends AbstractMultiset&lt;E&gt; {
    private final transient ConcurrentMap&lt;E, Integer&gt; countMap;
    public static &lt;E&gt; OldConcurrentHashMultiset&lt;E&gt; create() {
      return new OldConcurrentHashMultiset&lt;E&gt;(new ConcurrentHashMap&lt;E, Integer&gt;());
    }
    @VisibleForTesting
    OldConcurrentHashMultiset(ConcurrentMap&lt;E, Integer&gt; countMap) {
      checkArgument(countMap.isEmpty());
      this.countMap = countMap;
    }
    @Override
    public int count(@CheckForNull Object element) {
      try {
        return unbox(countMap.get(element));
      } catch (NullPointerException | ClassCastException e) {
        return 0;
      }
    }
    @Override
    public int size() {
      long sum = 0L;
      for (Integer value : countMap.values()) {
        sum += value;
      }
      return Ints.saturatedCast(sum);
    }
    @Override
    public Object[] toArray() {
      return snapshot().toArray();
    }
    @Override
    public &lt;T&gt; T[] toArray(T[] array) {
      return snapshot().toArray(array);
    }
    private List&lt;E&gt; snapshot() {
      List&lt;E&gt; list = Lists.newArrayListWithExpectedSize(size());
      for (Multiset.Entry&lt;E&gt; entry : entrySet()) {
        E element = entry.getElement();
        for (int i = entry.getCount(); i &gt; 0; i--) {
          list.add(element);
        }
      }
      return list;
    }
    @Override
    public int add(E element, int occurrences) {
      if (occurrences == 0) {
        return count(element);
      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) {
        int current = count(element);
        if (current == 0) {
          if (countMap.putIfAbsent(element, occurrences) == null) {
            return 0;
          }
        } else {
          checkArgument(
              occurrences &lt;= Integer.MAX_VALUE - current,
              "Overflow adding %s occurrences to a count of %s",
              occurrences,
              current);
          int next = current + occurrences;
          if (countMap.replace(element, current, next)) {
            return current;
          }
        }
      }
    }
    @Override
    public int remove(@CheckForNull Object element, int occurrences) {
      if (occurrences == 0) {
        return count(element);
<a name="8"></a>      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
        int current = count(element);
        if (current == 0) {
          return 0;
        }
        if</b></font> (occurrences &gt;= current) {
          if (countMap.remove(element, current)) {
            return current;
          }
        } else {
          @SuppressWarnings("unchecked")
          E casted = (E) element;
          if (countMap.replace(casted, current, current - occurrences)) {
            return current;
          }
        }
      }
    }
    private int removeAllOccurrences(@CheckForNull Object element) {
      try {
        return unbox(countMap.remove(element));
<a name="7"></a>      } catch (NullPointerException | ClassCastException e) {
        return 0;
      }
    <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    public boolean removeExactly(@CheckForNull Object element, int occurrences) {
      if (occurrences == 0) {</b></font>
        return true;
      }
      checkArgument(occurrences &gt; 0, "Invalid occurrences: %s", occurrences);
      while (true) {
        int current = count(element);
        if (occurrences &gt; current) {
          return false;
        }
        if (occurrences == current) {
          if (countMap.remove(element, occurrences)) {
            return true;
          }
        } else {
          @SuppressWarnings("unchecked")           E casted = (E) element;
          if (countMap.replace(casted, current, current - occurrences)) {
            return true;
          }
        }
      }
    }
    @Override
    public int setCount(E element, int count) {
      checkNonnegative(count, "count");
      return (count == 0) ? removeAllOccurrences(element) : unbox(countMap.put(element, count));
    }
    @Override
    public boolean setCount(E element, int oldCount, int newCount) {
      checkNonnegative(oldCount, "oldCount");
      checkNonnegative(newCount, "newCount");
      if (newCount == 0) {
        if (oldCount == 0) {
          return !countMap.containsKey(element);
        } else {
          return countMap.remove(element, oldCount);
        }
      }
      if (oldCount == 0) {
        return countMap.putIfAbsent(element, newCount) == null;
      }
      return countMap.replace(element, oldCount, newCount);
    }
    @Override
    Set&lt;E&gt; createElementSet() {
      final Set&lt;E&gt; delegate = countMap.keySet();
      return new ForwardingSet&lt;E&gt;() {
        @Override
        protected Set&lt;E&gt; delegate() {
          return delegate;
<a name="6"></a>        }
        @Override
        public boolean remove(Object object) <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
          try {
            return delegate.remove(object);
          } catch (NullPointerException | ClassCastException e) {</b></font>
            return false;
          }
        }
      };
    }
    @Override
    Iterator&lt;E&gt; elementIterator() {
      throw new AssertionError("should never be called");
    }
    private transient EntrySet entrySet;
    @Override
    public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
      EntrySet result = entrySet;
      if (result == null) {
<a name="1"></a>        entrySet = result = new EntrySet();
      }
      return result;
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    int distinctElements() {
      return countMap.size();
    }
    @Override
    public boolean isEmpty() {
      return countMap.isEmpty();
    }</b></font>
    @Override
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
      final Iterator&lt;Map.Entry&lt;E, Integer&gt;&gt; backingIterator = countMap.entrySet().iterator();
      return new Iterator&lt;Entry&lt;E&gt;&gt;() {
        @Override
        public boolean hasNext() {
          return backingIterator.hasNext();
        }
        @Override
        public Multiset.Entry&lt;E&gt; next() {
          Map.Entry&lt;E, Integer&gt; backingEntry = backingIterator.next();
          return Multisets.immutableEntry(backingEntry.getKey(), backingEntry.getValue());
        }
        @Override
        public void remove() {
<a name="5"></a>          backingIterator.remove();
        }
      };
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    public Iterator&lt;E&gt; iterator() {
      return Multisets.iteratorImpl(this);
    }
    @Over</b></font>ride
    public void clear() {
      countMap.clear();
    }
    private class EntrySet extends AbstractMultiset&lt;E&gt;.EntrySet {
      @Override
      Multiset&lt;E&gt; multiset() {
        return OldConcurrentHashMultiset.this;
      }
      @Override
      public Object[] toArray() {
        return snapshot().toArray();
      }
      @Override
      public &lt;T&gt; T[] toArray(T[] array) {
        return snapshot().toArray(array);
      }
      private List&lt;Multiset.Entry&lt;E&gt;&gt; snapshot() {
        List&lt;Multiset.Entry&lt;E&gt;&gt; list = Lists.newArrayListWithExpectedSize(size());
        Iterators.addAll(list, iterator());
        return list;
      }
      @Override
      public boolean remove(Object object) {
        if (object instanceof Multiset.Entry) {
          Multiset.Entry&lt;?&gt; entry = (Multiset.Entry&lt;?&gt;) object;
          Object element = entry.getElement();
          int entryCount = entry.getCount();
<a name="2"></a>          return countMap.remove(element, entryCount);
        }
        return false;
      <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
      @Override
      public int hashCode() {
        return countMap.hashCode();
      }
    }
    private static int unbox(@CheckForNull Integer i</b></font>) {
      return (i == null) ? 0 : i;
    }
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoreFiles.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.io;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Iterables.getOnlyElement;
import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
import static java.util.Objects.requireNonNull;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableList;
import com.google.common.graph.SuccessorsFunction;
import com.google.common.graph.Traverser;
import com.google.j2objc.annotations.J2ObjCIncompatible;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.channels.Channels;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.Charset;
import java.nio.file.DirectoryIteratorException;
import java.nio.file.DirectoryStream;
import</b></font> java.nio.file.FileAlreadyExistsException;
import java.nio.file.FileSystemException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.NoSuchFileException;
import java.nio.file.NotDirectoryException;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.SecureDirectoryStream;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
@Beta
@GwtIncompatible
@J2ObjCIncompatible @ElementTypesAreNonnullByDefault
public final class MoreFiles {
  private MoreFiles() {}
  public static ByteSource asByteSource(Path path, OpenOption... options) {
    return new PathByteSource(path, options);
  }
  private static final class PathByteSource extends ByteSource {
    private static final LinkOption[] FOLLOW_LINKS = {};
    private final Path path;
    private final OpenOption[] options;
    private final boolean followLinks;
    private PathByteSource(Path path, OpenOption... options) {
      this.path = checkNotNull(path);
      this.options = options.clone();
      this.followLinks = followLinks(this.options);
    }
    private static boolean followLinks(OpenOption[] options) {
      for (OpenOption option : options) {
        if (option == NOFOLLOW_LINKS) {
          return false;
<a name="5"></a>        }
      }
      return true;
    <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Override
    public InputStream openStream() throws IOException {
      return Files.newInputStream(path, options);
    }
    private BasicF</b></font>ileAttributes readAttributes() throws IOException {
      return Files.readAttributes(
          path,
          BasicFileAttributes.class,
          followLinks ? FOLLOW_LINKS : new LinkOption[] {NOFOLLOW_LINKS});
    }
    @Override
    public Optional&lt;Long&gt; sizeIfKnown() {
      BasicFileAttributes attrs;
      try {
        attrs = readAttributes();
      } catch (IOException e) {
        return Optional.absent();
      }
      if (attrs.isDirectory() || attrs.isSymbolicLink()) {
        return Optional.absent();
      }
      return Optional.of(attrs.size());
    }
    @Override
    public long size() throws IOException {
      BasicFileAttributes attrs = readAttributes();
      if (attrs.isDirectory()) {
        throw new IOException("can't read: is a directory");
      } else if (attrs.isSymbolicLink()) {
        throw new IOException("can't read: is a symbolic link");
      }
      return attrs.size();
    }
    @Override
    public byte[] read() throws IOException {
      try (SeekableByteChannel channel = Files.newByteChannel(path, options)) {
        return ByteStreams.toByteArray(Channels.newInputStream(channel), channel.size());
      }
    }
    @Override
    public CharSource asCharSource(Charset charset) {
      if (options.length == 0) {
        return new AsCharSource(charset) {
          @SuppressWarnings("FilesLinesLeak")           @Override
          public Stream&lt;String&gt; lines() throws IOException {
            return Files.lines(path, charset);
          }
        };
<a name="2"></a>      }
      return super.asCharSource(charset);
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Override
    public String toString() {
      return "MoreFiles.asByteSource(" + path + ", " + Arrays.toString(options) + ")";
    }
  }
  public static ByteSink asByteSink(Path path</b></font>, OpenOption... options) {
    return new PathByteSink(path, options);
  }
  private static final class PathByteSink extends ByteSink {
    private final Path path;
    private final OpenOption[] options;
    private PathByteSink(Path path, OpenOption... options) {
<a name="1"></a>      this.path = checkNotNull(path);
      this.options = options.clone();
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Override
    public OutputStream openStream() throws IOException {
      return Files.newOutputStream(path, options);
    }
    @Override
    public String toString() {
      return "MoreFiles.asByteSink(" + path + ", " + Arrays.toString(options) + ")";
    }</b></font>
  }
  public static CharSource asCharSource(Path path, Charset charset, OpenOption... options) {
    return asByteSource(path, options).asCharSource(charset);
  }
  public static CharSink asCharSink(Path path, Charset charset, OpenOption... options) {
    return asByteSink(path, options).asCharSink(charset);
  }
  public static ImmutableList&lt;Path&gt; listFiles(Path dir) throws IOException {
    try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) {
      return ImmutableList.copyOf(stream);
    } catch (DirectoryIteratorException e) {
      throw e.getCause();
    }
  }
  public static Traverser&lt;Path&gt; fileTraverser() {
    return Traverser.forTree(FILE_TREE);
  }
  private static final SuccessorsFunction&lt;Path&gt; FILE_TREE =
      new SuccessorsFunction&lt;Path&gt;() {
        @Override
        public Iterable&lt;Path&gt; successors(Path path) {
          return fileTreeChildren(path);
        }
<a name="6"></a>      };
  private static Iterable&lt;Path&gt; fileTreeChildren(Path dir) {
    if (Files.isDirectory(dir, NOFOLLOW_LINKS)) <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
      try {
        return listFiles(dir);
      } catch (IOException e) {</b></font>
        throw new DirectoryIteratorException(e);
      }
    }
    return ImmutableList.of();
  }
  public static Predicate&lt;Path&gt; isDirectory(LinkOption... options) {
    final LinkOption[] optionsCopy = options.clone();
    return new Predicate&lt;Path&gt;() {
      @Override
      public boolean apply(Path input) {
<a name="3"></a>        return Files.isDirectory(input, optionsCopy);
      }
      <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public String toString() {
        return "MoreFiles.isDirectory(" + Arrays.toString(optionsCopy) + ")";
      }
    };
  }
  private static boolean isDirectory(
      SecureDirectoryStream&lt;Path&gt; dir</b></font>, Path name, LinkOption... options) throws IOException {
    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)
        .readAttributes()
        .isDirectory();
  }
  public static Predicate&lt;Path&gt; isRegularFile(LinkOption... options) {
    final LinkOption[] optionsCopy = options.clone();
    return new Predicate&lt;Path&gt;() {
      @Override
      public boolean apply(Path input) {
<a name="4"></a>        return Files.isRegularFile(input, optionsCopy);
      }
      <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public String toString() {
        return "MoreFiles.isRegularFile(" + Arrays.toString(optionsCopy) + ")";
      }
    };
  }
  publi</b></font>c static boolean equal(Path path1, Path path2) throws IOException {
    checkNotNull(path1);
    checkNotNull(path2);
    if (Files.isSameFile(path1, path2)) {
      return true;
    }
    ByteSource source1 = asByteSource(path1);
    ByteSource source2 = asByteSource(path2);
    long len1 = source1.sizeIfKnown().or(0L);
    long len2 = source2.sizeIfKnown().or(0L);
    if (len1 != 0 &amp;&amp; len2 != 0 &amp;&amp; len1 != len2) {
      return false;
    }
    return source1.contentEquals(source2);
  }
  @SuppressWarnings("GoodTime")   public static void touch(Path path) throws IOException {
    checkNotNull(path);
    try {
      Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));
    } catch (NoSuchFileException e) {
      try {
        Files.createFile(path);
      } catch (FileAlreadyExistsException ignore) {
      }
    }
  }
  public static void createParentDirectories(Path path, <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>FileAttribute&lt;?&gt;... attrs)
      throws IOException {
    Path normalizedAbsolutePath = path.toAbsolutePath().normalize();
    Path parent = normalizedAbsolutePath.getParent();
    if (parent == null) {</b></font>
      return;
    }
    if (!Files.isDirectory(parent)) {
      Files.createDirectories(parent, attrs);
      if (!Files.isDirectory(parent)) {
        throw new IOException("Unable to create parent directories of " + path);
      }
    }
  }
  public static String getFileExtension(Path path) {
    Path name = path.getFileName();
    if (name == null) {
      return "";
    }
    String fileName = name.toString();
    int dotIndex = fileName.lastIndexOf('.');
    return dotIndex == -1 ? "" : fileName.substring(dotIndex + 1);
  }
  public static String getNameWithoutExtension(Path path) {
    Path name = path.getFileName();
    if (name == null) {
      return "";
    }
    String fileName = name.toString();
    int dotIndex = fileName.lastIndexOf('.');
    return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);
  }
  public static void deleteRecursively(Path path, RecursiveDeleteOption... options)
      throws IOException {
    Path parentPath = getParentPath(path);
    if (parentPath == null) {
      throw new FileSystemException(path.toString(), null, "can't delete recursively");
    }
    Collection&lt;IOException&gt; exceptions = null;     try {
      boolean sdsSupported = false;
      try (DirectoryStream&lt;Path&gt; parent = Files.newDirectoryStream(parentPath)) {
        if (parent instanceof SecureDirectoryStream) {
          sdsSupported = true;
          exceptions =
              deleteRecursivelySecure(
                  (SecureDirectoryStream&lt;Path&gt;) parent,
                  requireNonNull(path.getFileName()));
        }
      }
      if (!sdsSupported) {
        checkAllowsInsecure(path, options);
        exceptions = deleteRecursivelyInsecure(path);
      }
    } catch (IOException e) {
      if (exceptions == null) {
        throw e;
      } else {
        exceptions.add(e);
      }
    }
    if (exceptions != null) {
      throwDeleteFailed(path, exceptions);
    }
  }
  public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... options)
      throws IOException {
    Collection&lt;IOException&gt; exceptions = null;     try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
      if (stream instanceof SecureDirectoryStream) {
        SecureDirectoryStream&lt;Path&gt; sds = (SecureDirectoryStream&lt;Path&gt;) stream;
        exceptions = deleteDirectoryContentsSecure(sds);
      } else {
        checkAllowsInsecure(path, options);
        exceptions = deleteDirectoryContentsInsecure(stream);
      }
    } catch (IOException e) {
      if (exceptions == null) {
        throw e;
      } else {
        exceptions.add(e);
      }
    }
    if (exceptions != null) {
      throwDeleteFailed(path, exceptions);
    }
  }
  @CheckForNull
  private static Collection&lt;IOException&gt; deleteRecursivelySecure(
      SecureDirectoryStream&lt;Path&gt; dir, Path path) {
    Collection&lt;IOException&gt; exceptions = null;
    try {
      if (isDirectory(dir, path, NOFOLLOW_LINKS)) {
        try (SecureDirectoryStream&lt;Path&gt; childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {
          exceptions = deleteDirectoryContentsSecure(childDir);
        }
        if (exceptions == null) {
          dir.deleteDirectory(path);
        }
      } else {
        dir.deleteFile(path);
      }
      return exceptions;
    } catch (IOException e) {
      return addException(exceptions, e);
    }
  }
  @CheckForNull
  private static Collection&lt;IOException&gt; deleteDirectoryContentsSecure(
      SecureDirectoryStream&lt;Path&gt; dir) {
    Collection&lt;IOException&gt; exceptions = null;
    try {
      for (Path path : dir) {
        exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));
      }
      return exceptions;
    } catch (DirectoryIteratorException e) {
      return addException(exceptions, e.getCause());
    }
  }
  @CheckForNull
  private static Collection&lt;IOException&gt; deleteRecursivelyInsecure(Path path) {
    Collection&lt;IOException&gt; exceptions = null;
    try {
      if (Files.isDirectory(path, NOFOLLOW_LINKS)) {
        try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
          exceptions = deleteDirectoryContentsInsecure(stream);
        }
      }
      if (exceptions == null) {
        Files.delete(path);
      }
      return exceptions;
    } catch (IOException e) {
      return addException(exceptions, e);
    }
  }
  @CheckForNull
  private static Collection&lt;IOException&gt; deleteDirectoryContentsInsecure(
      DirectoryStream&lt;Path&gt; dir) {
    Collection&lt;IOException&gt; exceptions = null;
    try {
      for (Path entry : dir) {
        exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));
      }
      return exceptions;
    } catch (DirectoryIteratorException e) {
      return addException(exceptions, e.getCause());
    }
  }
  @CheckForNull
  private static Path getParentPath(Path path) <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
    Path parent = path.getParent();
    if (parent != null) {
      return parent;
    }
    if</b></font> (path.getNameCount() == 0) {
      //
      return null;
    } else {
      return path.getFileSystem().getPath(".");
    }
  }
  private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] options)
      throws InsecureRecursiveDeleteException {
<a name="7"></a>    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {
      throw new InsecureRecursiveDeleteException(path.toString());
    }
  <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
  private static Collection&lt;IOException&gt; addException(
      @CheckForNull Collection&lt;IOException&gt; exceptions, IOException e) {
    if (exceptions == null) {</b></font>
      exceptions = new ArrayList&lt;&gt;();     }
    exceptions.add(e);
    return exceptions;
  }
  @CheckForNull
  private static Collection&lt;IOException&gt; concat(
      @CheckForNull Collection&lt;IOException&gt; exceptions,
      @CheckForNull Collection&lt;IOException&gt; other) {
    if (exceptions == null) {
      return other;
    } else if (other != null) {
      exceptions.addAll(other);
    }
    return exceptions;
  }
  private static void throwDeleteFailed(Path path, Collection&lt;IOException&gt; exceptions)
      throws FileSystemException {
    NoSuchFileException pathNotFound = pathNotFound(path, exceptions);
    if (pathNotFound != null) {
      throw pathNotFound;
    }
    FileSystemException deleteFailed =
        new FileSystemException(
            path.toString(),
            null,
            "failed to delete one or more files; see suppressed exceptions for details");
    for (IOException e : exceptions) {
      deleteFailed.addSuppressed(e);
    }
    throw deleteFailed;
  }
  @CheckForNull
  private static NoSuchFileException pathNotFound(Path path, Collection&lt;IOException&gt; exceptions) {
    if (exceptions.size() != 1) {
      return null;
    }
    IOException exception = getOnlyElement(exceptions);
    if (!(exception instanceof NoSuchFileException)) {
      return null;
    }
    NoSuchFileException noSuchFileException = (NoSuchFileException) exception;
    String exceptionFile = noSuchFileException.getFile();
    if (exceptionFile == null) {
      /*
       * It's not clear whether this happens in practice, especially with the filesystem
       * implementations that are built into java.nio.
       */
      return null;
    }
    Path parentPath = getParentPath(path);
    if (parentPath == null) {
      /*
       * This is probably impossible:
       *
       * - In deleteRecursively, we require the path argument to have a parent.
       *
       * - In deleteDirectoryContents, the path argument may have no parent. Fortunately, all the
       *   *other* paths we process will be descendants of that. That leaves only the original path
       *   argument for us to consider. And the only place we call pathNotFound is from
       *   throwDeleteFailed, and the other place that we call throwDeleteFailed inside
       *   deleteDirectoryContents is when an exception is thrown during the recursive steps. Any
       *   failure during the initial lookup of the path argument itself is rethrown directly. So
       *   any exception that we're seeing here is from a descendant, which naturally has a parent.
       *   I think.
       *
       * Still, if this can happen somehow (a weird filesystem implementation that lets callers
       * change its working directly concurrently with a call to deleteDirectoryContents?), it makes
       * more sense for us to fall back to a generic FileSystemException (by returning null here)
       * than to dereference parentPath and end up producing NullPointerException.
       */
      return null;
    }
    Path pathResolvedFromParent = parentPath.resolve(requireNonNull(path.getFileName()));
    if (exceptionFile.equals(pathResolvedFromParent.toString())) {
      return noSuchFileException;
    }
    return null;
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
