
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.8972198820556025%, Tokens: 21</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistryTest.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.weibomesh;
2  import com.weibo.api.motan.common.URLParamType;
3  import com.weibo.api.motan.exception.MotanFrameworkException;
<span onclick='openModal()' class='match'>4  import com.weibo.api.motan.registry.NotifyListener;
5  import com.weibo.api.motan.registry.Registry;
6  import com.weibo.api.motan.rpc.Request;
7  import com.weibo.api.motan.rpc.Response;
8  import com.weibo.api.motan.rpc.URL;
9  import com.weibo.api.motan.transport.Channel;
10  import com.weibo.api.motan.transport.MessageHandler;
11  import com.weibo.api.motan.transport.netty4.NettyServer;
12  import com.weibo.api.motan.transport.support.DefaultRpcHeartbeatFactory;
13  import com.weibo.api.motan.util.MotanSwitcherUtil;
14  import com.weibo.api.motan.util.UrlUtils;
15  import org.apache.commons.lang3.tuple.MutablePair;
16  import org.apache.commons.lang3.tuple.Pair;
17  import org.junit.Before;
18  import org.junit.Test;
19  import java.lang.reflect.Field;
20  import java.lang.reflect.Method;
21  import java.util.*;
22  import static org.junit.Assert.*;
23  public class MeshRegistryTest {
24      URL registryUrl;
</span>25      MeshRegistry registry;
26      URL subUrl;
27      MockRegistry mockProxyRegistry;
28      int copy;
29      int requestTimeout;
30      MockMessageHandler handler;
31      @Before
32      public void setUp() throws Exception {
33          copy = 3; 
34          requestTimeout = 100;
35          URL agentMockUrl = new URL("motan2", "localhost", 0, "testpath", new HashMap<>());
36          agentMockUrl.addParameter(URLParamType.codec.getName(), "motan2");
37          handler = new MockMessageHandler();
38          NettyServer mockAgent = new NettyServer(agentMockUrl, handler);
39          mockAgent.open();
40          int agentPort = agentMockUrl.getPort();
41          registryUrl = new URL("weibomesh", "localhost", agentPort, "", new HashMap<>());
42          registryUrl.addParameter(MeshRegistry.MESH_PARAM_COPY, String.valueOf(copy));
43          registryUrl.addParameter(URLParamType.requestTimeout.getName(), String.valueOf(requestTimeout));
44          registryUrl.addParameter(URLParamType.registrySessionTimeout.getName(), String.valueOf(requestTimeout));
45          subUrl = new URL("motan2", "localhost", 0, "com.weibo.test.TestService");
46          registry = new MeshRegistry(registryUrl, new MockMeshTransport());
47          List<URL> notifyUrls = new ArrayList();
48          notifyUrls.add(new URL("motan2", "127.0.0.1", 8999, "testService"));
49          Map<URL, List<URL>> nodesMap = new HashMap();
50          nodesMap.put(subUrl, notifyUrls);
51          mockProxyRegistry = new MockRegistry(nodesMap);
52          registry.setProxyRegistry(mockProxyRegistry);
53          registry.initHealthCheck();
54          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_SWITCHER_NAME, true);
55          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true);
56      }
57      @Test
58      public void testRegister() throws Exception {
59          registry.register(subUrl);
60          assertTrue(registry.getRegisteredServiceUrls().contains(subUrl));
61          assertFalse(mockProxyRegistry.getRegisteredServiceUrls().contains(subUrl));
62          registry.unregister(subUrl);
63          assertFalse(registry.getRegisteredServiceUrls().contains(subUrl));
64          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_SWITCHER_NAME, false);
65          registry.register(subUrl);
66          assertTrue(registry.getRegisteredServiceUrls().contains(subUrl));
67          assertTrue(mockProxyRegistry.getRegisteredServiceUrls().contains(subUrl));
68          registry.unregister(subUrl);
69          assertFalse(registry.getRegisteredServiceUrls().contains(subUrl));
70          assertFalse(mockProxyRegistry.getRegisteredServiceUrls().contains(subUrl));
71      }
72      @Test
73      public void testDoSubscribe() throws Exception {
74          TestNotifyListener notifyListener = new TestNotifyListener();
75          registry.doSubscribe(subUrl, notifyListener);
76          assertEquals(notifyListener.urls.size(), copy);
77          assertTrue(isAgentUrl(notifyListener.urls.get(0)));
78          assertEquals(notifyListener.urls.get(0).getPath(), subUrl.getPath());
79          assertEquals(notifyListener.urls.get(0).getGroup(), subUrl.getGroup());
80          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_SWITCHER_NAME, false);
81          Thread.sleep(50l);
82          assertEquals(notifyListener.urls, mockProxyRegistry.discover(subUrl));
83          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_SWITCHER_NAME, true);
84          Thread.sleep(50l);
85          assertEquals(notifyListener.urls.size(), copy);
86          handler.enableHeartbeat = false;
87          Thread.sleep(5 * requestTimeout);
88          assertEquals(notifyListener.urls, mockProxyRegistry.discover(subUrl));
89          handler.enableHeartbeat = true;
90          Thread.sleep(5 * requestTimeout);
91          assertEquals(notifyListener.urls.size(), copy);
92          handler.enableHeartbeat = false;
93          Thread.sleep(5 * requestTimeout);
94          assertEquals(notifyListener.urls, mockProxyRegistry.discover(subUrl));
95          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, false);
96          Thread.sleep(50);
97          assertEquals(notifyListener.urls.size(), copy);
98          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true);
99          Thread.sleep(5 * requestTimeout);
100          assertEquals(notifyListener.urls, mockProxyRegistry.discover(subUrl));
101          handler.enableHeartbeat = true;
102          Thread.sleep(5 * requestTimeout);
103          assertEquals(notifyListener.urls.size(), copy);
104      }
105      @Test
106      public void testDoUnsubscribe() throws Exception {
107          TestNotifyListener notifyListener = new TestNotifyListener();
108          registry.doSubscribe(subUrl, notifyListener);
109          int count = notifyListener.count.get();
110          assertEquals(1, count);
111          registry.doUnsubscribe(subUrl, notifyListener);
112          MotanSwitcherUtil.setSwitcherValue(MeshRegistry.MESH_REGISTRY_SWITCHER_NAME, false);
113          Thread.sleep(50l);
114          assertEquals(count, notifyListener.count.get());
115      }
116      @Test
117      public void testDoDiscover() throws Exception {
118          List<URL> result = registry.discover(subUrl);
119          assertEquals(copy, result.size());
120          registry.setUseMesh(false);
121          result = registry.doDiscover(subUrl);
122          assertEquals(copy, result.size());
123          TestNotifyListener notifyListener = new TestNotifyListener();
124          registry.doSubscribe(subUrl, notifyListener);
125          Thread.sleep(50l);
126          result = registry.doDiscover(subUrl);
127          assertEquals(mockProxyRegistry.discover(subUrl), result);
128      }
129      @Test
130      public void testProxyRegistry() {
131          String proxyRegistryString = "direct%3A%2F%2Flocalhost%3A9982%2Fcom.weibo.api.motan.registry.RegistryService%3Fpath%3Dcom.weibo.api.motan.registry.RegistryService%26protocol%3Ddirect%26address%3Dlocalhost%253A9982%26name%3Dregistry%26dynamic%3Dfalse%26id%3Dregistry%26refreshTimestamp%3D1628763334951%26";
132          registryUrl.addParameter(URLParamType.proxyRegistryUrlString.getName(), proxyRegistryString);
133          registry = new MeshRegistry(registryUrl, new MockMeshTransport());
134          Registry proxyRegistry = registry.getProxyRegistry();
135          assertNotNull(proxyRegistry);
136          List<URL> urls = UrlUtils.stringToURLs(proxyRegistryString);
137          assertEquals(urls.get(0), proxyRegistry.getUrl());
138      }
139      @Test
140      public void testDynamic() throws Exception {
141          String mport = "8888";
142          MockMeshTransport transport = new MockMeshTransport();
143          registryUrl.addParameter(URLParamType.dynamic.getName(), "true");
144          registryUrl.addParameter(URLParamType.meshMPort.getName(), mport);
145          registry = new MeshRegistry(registryUrl, transport);
146          registry.doRegister(subUrl);
147          Thread.sleep(300l);
148          assertEquals(1, transport.records.size());
149          assertEquals("http:&bsol;&bsol;" + registryUrl.getHost() + ":" + mport + MeshRegistry.MESH_REGISTER_URL, transport.records.get(0).getLeft());
150          assertEquals(Util.UrlToJson(subUrl), transport.records.get(0).getRight());
151          registry.doSubscribe(subUrl, new TestNotifyListener());
152          Thread.sleep(300l);
153          assertEquals(2, transport.records.size());
154          assertEquals("http:&bsol;&bsol;" + registryUrl.getHost() + ":" + mport + MeshRegistry.MESH_SUBSCRIBE_URL, transport.records.get(1).getLeft());
155          assertEquals(Util.UrlToJson(subUrl), transport.records.get(1).getRight());
156      }
157      @Test
158      public void testEnvDefault() throws Exception {
159          assertEquals(9981, MeshRegistry.DEFAULT_MESH_PORT);
160          assertEquals(8002, MeshRegistry.DEFAULT_MESH_MANAGE_PORT);
161          getModifiableEnvironment().put(MeshRegistry.MESH_MPORT_ENV_NAME, "8018");
162          assertEquals(8018, MeshRegistry.getIntFromEnv(MeshRegistry.MESH_MPORT_ENV_NAME, 0));
163          getModifiableEnvironment().put(MeshRegistry.MESH_PORT_ENV_NAME, "9918");
164          assertEquals(9918, MeshRegistry.getIntFromEnv(MeshRegistry.MESH_PORT_ENV_NAME, 0));
165      }
166      private boolean isAgentUrl(URL url) {
167          return registry.getUrl().getHost().equals(url.getHost()) && (registry.getUrl().getPort().equals(url.getPort()));
168      }
169      private static Map<String, String> getModifiableEnvironment() throws Exception {
170          Class<?> pe = Class.forName("java.lang.ProcessEnvironment");
171          Method getenv = pe.getDeclaredMethod("getenv");
172          getenv.setAccessible(true);
173          Object unmodifiableEnvironment = getenv.invoke(null);
174          Class<?> map = Class.forName("java.util.Collections$UnmodifiableMap");
175          Field m = map.getDeclaredField("m");
176          m.setAccessible(true);
177          return (Map<String, String>) m.get(unmodifiableEnvironment);
178      }
179      class MockMeshTransport implements MeshTransport {
180          public int code = 200;
181          List<Pair<String, String>> records = new ArrayList();
182          @Override
183          public ManageResponse getManageRequest(String url) throws MotanFrameworkException {
184              throw new RuntimeException("not implement");
185          }
186          @Override
187          public ManageResponse postManageRequest(String url, Map<String, String> params) throws MotanFrameworkException {
188              throw new RuntimeException("not implement");
189          }
190          @Override
191          public ManageResponse postManageRequest(String url, String content) throws MotanFrameworkException {
192              records.add(new MutablePair(url, content));
193              return new ManageResponse(code, "");
194          }
195      }
196      class MockRegistry implements Registry {
197          URL registryUrl = new URL("mock", "localhost", 0, "mockpath");
198          Map<URL, List<URL>> nodesMap;
199          Map<URL, NotifyListener> listenerMap = new HashMap();
200          Set<URL> registedUrls = new HashSet();
201          public void setNodesMap(Map<URL, List<URL>> nodesMap) {
202              this.nodesMap = nodesMap;
203          }
204          public MockRegistry(Map<URL, List<URL>> nodesMap) {
205              this.nodesMap = nodesMap;
206          }
207          @Override
208          public void subscribe(URL url, NotifyListener listener) {
209              listenerMap.put(url, listener);
210              listener.notify(registryUrl, discover(url));
211          }
212          @Override
213          public void unsubscribe(URL url, NotifyListener listener) {
214              listenerMap.remove(url);
215          }
216          @Override
217          public List<URL> discover(URL url) {
218              return nodesMap.get(url);
219          }
220          @Override
221          public void register(URL url) {
222              registedUrls.add(url);
223          }
224          @Override
225          public void unregister(URL url) {
226              registedUrls.remove(url);
227          }
228          @Override
229          public void available(URL url) {
230          }
231          @Override
232          public void unavailable(URL url) {
233          }
234          @Override
235          public Collection<URL> getRegisteredServiceUrls() {
236              return registedUrls;
237          }
238          @Override
239          public URL getUrl() {
240              return null;
241          }
242          public Map<URL, NotifyListener> getListenerMap() {
243              return listenerMap;
244          }
245      }
246      class MockMessageHandler implements MessageHandler {
247          public boolean enableHeartbeat = true;
248          public int heartbeatCount;
249          @Override
250          public Object handle(Channel channel, Object message) {
251              if (enableHeartbeat && DefaultRpcHeartbeatFactory.isHeartbeatRequest(message)) {
252                  Response response = DefaultRpcHeartbeatFactory.getDefaultHeartbeatResponse(((Request) message).getRequestId());
253                  response.setRpcProtocolVersion(((Request) message).getRpcProtocolVersion());
254                  heartbeatCount++;
255                  return response;
256              }
257              try { 
258                  Thread.sleep(3000l);
259              } catch (InterruptedException e) {
260                  e.printStackTrace();
261              }
262              return null;
263          }
264      }
265  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager.dataholder.worlds;
<span onclick='openModal()' class='match'>2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.IOException;
5  import java.io.InputStream;
6  import java.util.ArrayList;
7  import java.util.HashMap;
8  import java.util.HashSet;
9  import java.util.List;
10  import java.util.Map;
11  import java.util.Properties;
12  import java.util.logging.Level;
13  import java.util.logging.Logger;
14  import org.anjocaido.groupmanager.GroupManager;
15  import org.anjocaido.groupmanager.dataholder.WorldDataHolder;
16  import org.anjocaido.groupmanager.dataholder.OverloadedWorldHolder;
17  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.bukkit.World;
20  import org.bukkit.entity.Player;
21  public class WorldsHolder {
22  	private Map<String, OverloadedWorldHolder> worldsData = new HashMap<String, OverloadedWorldHolder>();
</span>23  	private Map<String, String> mirrorsGroup = new HashMap<String, String>();
24  	private Map<String, String> mirrorsUser = new HashMap<String, String>();
25  	private String serverDefaultWorldName;
26  	private GroupManager plugin;
27  	private File worldsFolder;
28  	public WorldsHolder(GroupManager plugin) {
29  		this.plugin = plugin;
30  		resetWorldsHolder();
31  	}
32  	public Map<String, String> getMirrorsGroup() {
33  		return mirrorsGroup;
34  	}
35  	public Map<String, String> getMirrorsUser() {
36  		return mirrorsUser;
37  	}
38  	public boolean isWorldKnown(String name) {
39  		return worldsData.containsKey(name.toLowerCase());
40  	}
41  	public void resetWorldsHolder() {
42  		worldsData = new HashMap<String, OverloadedWorldHolder>();
43  		mirrorsGroup = new HashMap<String, String>();
44  		mirrorsUser = new HashMap<String, String>();
45  		verifyFirstRun();
46  		initialLoad();
47  		if (serverDefaultWorldName == null)
48  			throw new IllegalStateException("There is no default group! OMG!");
49  	}
50  	private void initialLoad() {
51  		initialWorldLoading();
52  		mirrorSetUp();
53  		loadAllSearchedWorlds();
54  	}
55  	private void initialWorldLoading() {
56  		loadWorld(serverDefaultWorldName);
57  	}
58  	private void loadAllSearchedWorlds() {
59  		for (World world : plugin.getServer().getWorlds()) {
60  			GroupManager.logger.log(Level.FINE, "Checking data for " + world.getName() + ".");
61  			if ((!worldsData.containsKey(world.getName().toLowerCase())) && ((!mirrorsGroup.containsKey(world.getName().toLowerCase())) || (!mirrorsUser.containsKey(world.getName().toLowerCase())))) {
62  				if (worldsData.containsKey("all_unnamed_worlds")) {
63  					String usersMirror = mirrorsUser.get("all_unnamed_worlds");
64  					String groupsMirror = mirrorsGroup.get("all_unnamed_worlds");
65  					if (usersMirror != null)
66  						mirrorsUser.put(world.getName().toLowerCase(), usersMirror);
67  					if (groupsMirror != null)
68  						mirrorsGroup.put(world.getName().toLowerCase(), groupsMirror);
69  				}
70  				GroupManager.logger.log(Level.FINE, "Creating folders for " + world.getName() + ".");
71  				setupWorldFolder(world.getName());
72  			}
73  		}
74  		for (File folder : worldsFolder.listFiles()) {
75  			if (folder.isDirectory() && !folder.getName().startsWith(".")) {
76  				GroupManager.logger.info("World Found: " + folder.getName());
77  				if (!worldsData.containsKey(folder.getName().toLowerCase()) && ((!mirrorsGroup.containsKey(folder.getName().toLowerCase())) || (!mirrorsUser.containsKey(folder.getName().toLowerCase())))) {
78  					setupWorldFolder(folder.getName());
79  					loadWorld(folder.getName().toLowerCase());
80  				}
81  			}
82  		}
83  	}
84  	@SuppressWarnings("rawtypes")
85  	public void mirrorSetUp() {
86  		mirrorsGroup.clear();
87  		mirrorsUser.clear();
88  		Map<String, Object> mirrorsMap = plugin.getGMConfig().getMirrorsMap();
89  		HashSet<String> mirroredWorlds = new HashSet<String>();
90  		if (mirrorsMap != null) {
91  			for (String source : mirrorsMap.keySet()) {
92  				setupWorldFolder(source);
93  				if (!worldsData.containsKey(source.toLowerCase()))
94  					loadWorld(source);
95  				if (mirrorsMap.get(source) instanceof ArrayList) {
96  					ArrayList mirrorList = (ArrayList) mirrorsMap.get(source);
97  					for (Object o : mirrorList) {
98  						String world = o.toString().toLowerCase();
99  						if (!world.equalsIgnoreCase(serverDefaultWorldName)) {
100  							try {
101  								mirrorsGroup.remove(world);
102  								mirrorsUser.remove(world);
103  							} catch (Exception e) {
104  							}
105  							mirrorsGroup.put(world, getWorldData(source).getName());
106  							mirrorsUser.put(world, getWorldData(source).getName());
107  							mirroredWorlds.add(o.toString());
108  						} else
109  							GroupManager.logger.log(Level.WARNING, "Mirroring error with " + o.toString() + ". Recursive loop detected!");
110  					}
111  				} else if (mirrorsMap.get(source) instanceof Map) {
112  					Map subSection = (Map) mirrorsMap.get(source);
113  					for (Object key : subSection.keySet()) {
114  						if (!((String)key).equalsIgnoreCase(serverDefaultWorldName)) {
115  							if (subSection.get(key) instanceof ArrayList) {
116  								ArrayList mirrorList = (ArrayList) subSection.get(key);
117  								for (Object o : mirrorList) {
118  									String type = o.toString().toLowerCase();
119  									try {
120  										if (type.equals("groups"))
121  											mirrorsGroup.remove(((String)key).toLowerCase());
122  										if (type.equals("users"))
123  											mirrorsUser.remove(((String)key).toLowerCase());
124  									} catch (Exception e) {
125  									}
126  									if (type.equals("groups")) {
127  										mirrorsGroup.put(((String)key).toLowerCase(), getWorldData(source).getName());
128  										GroupManager.logger.log(Level.FINE, "Adding groups mirror for " + key + ".");
129  									}
130  									if (type.equals("users")) {
131  										mirrorsUser.put(((String)key).toLowerCase(), getWorldData(source).getName());
132  										GroupManager.logger.log(Level.FINE, "Adding users mirror for " + key + ".");
133  									}
134  								}
135  								mirroredWorlds.add((String)key);
136  							} else
137  								throw new IllegalStateException("Unknown mirroring format for " + (String)key);
138  						} else {
139  							GroupManager.logger.log(Level.WARNING, "Mirroring error with " + (String)key + ". Recursive loop detected!");
140  						}
141  					}
142  				}
143  			}
144  			for (String world : mirroredWorlds) {
145  				if (!worldsData.containsKey(world.toLowerCase())) {
146  					GroupManager.logger.log(Level.FINE, "No data for " + world + ".");
147  					setupWorldFolder(world);
148  					loadWorld(world, true);
149  				}
150  			}
151  		}
152  	}
153  	public void reloadAll() {
154  		GroupManager.getGlobalGroups().load();
155  		ArrayList<WorldDataHolder> alreadyDone = new ArrayList<WorldDataHolder>();
156  		for (WorldDataHolder w : worldsData.values()) {
157  			if (alreadyDone.contains(w)) {
158  				continue;
159  			}
160  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
161  				w.reloadGroups();
162  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
163  				w.reloadUsers();
164  			alreadyDone.add(w);
165  		}
166  	}
167  	public void reloadWorld(String worldName) {
168  		if (!mirrorsGroup.containsKey(worldName.toLowerCase()))
169  			getWorldData(worldName).reloadGroups();
170  		if (!mirrorsUser.containsKey(worldName.toLowerCase()))
171  			getWorldData(worldName).reloadUsers();
172  	}
173  	public void saveChanges() {
174  		saveChanges(true);
175  	}
176  	public boolean saveChanges(boolean overwrite) {
177  		boolean changed = false;
178  		ArrayList<WorldDataHolder> alreadyDone = new ArrayList<WorldDataHolder>();
179  		Tasks.removeOldFiles(plugin, plugin.getBackupFolder());
180  		if (GroupManager.getGlobalGroups().haveGroupsChanged()) {
181  			GroupManager.getGlobalGroups().writeGroups(overwrite);
182  		} else {
183  			if (GroupManager.getGlobalGroups().getTimeStampGroups() < GroupManager.getGlobalGroups().getGlobalGroupsFile().lastModified()) {
184  				System.out.print("Newer GlobalGroups file found (Loading changes)!");
185  				GroupManager.getGlobalGroups().load();
186  			}
187  		}
188  		for (OverloadedWorldHolder w : worldsData.values()) {
189  			if (alreadyDone.contains(w)) {
190  				continue;
191  			}
192  			if (w == null) {
193  				GroupManager.logger.severe("WHAT HAPPENED?");
194  				continue;
195  			}
196  			if (!mirrorsGroup.containsKey(w.getName().toLowerCase()))
197  				if (w.haveGroupsChanged()) {
198  					if (overwrite || (!overwrite && (w.getTimeStampGroups() >= w.getGroupsFile().lastModified()))) {
199  						backupFile(w, true);
200  						WorldDataHolder.writeGroups(w, w.getGroupsFile());
201  						changed = true;
202  					} else {
203  						GroupManager.logger.log(Level.WARNING, "Newer Groups file found for " + w.getName() + ", but we have local changes!");
204  						throw new IllegalStateException("Unable to save unless you issue a '/mansave force'");
205  					}
206  				} else {
207  					if (w.getTimeStampGroups() < w.getGroupsFile().lastModified()) {
208  						System.out.print("Newer Groups file found (Loading changes)!");
209  						backupFile(w, true);
210  						w.reloadGroups();
211  						changed = true;
212  					}
213  				}
214  			if (!mirrorsUser.containsKey(w.getName().toLowerCase()))
215  				if (w.haveUsersChanged()) {
216  					if (overwrite || (!overwrite && (w.getTimeStampUsers() >= w.getUsersFile().lastModified()))) {
217  						backupFile(w, false);
218  						WorldDataHolder.writeUsers(w, w.getUsersFile());
219  						changed = true;
220  					} else {
221  						GroupManager.logger.log(Level.WARNING, "Newer Users file found for " + w.getName() + ", but we have local changes!");
222  						throw new IllegalStateException("Unable to save unless you issue a '/mansave force'");
223  					}
224  				} else {
225  					if (w.getTimeStampUsers() < w.getUsersFile().lastModified()) {
226  						System.out.print("Newer Users file found (Loading changes)!");
227  						backupFile(w, false);
228  						w.reloadUsers();
229  						changed = true;
230  					}
231  				}
232  			alreadyDone.add(w);
233  		}
234  		return changed;
235  	}
236  	private void backupFile(OverloadedWorldHolder w, Boolean groups) {
237  		File backupFile = new File(plugin.getBackupFolder(), "bkp_" + w.getName() + (groups ? "_g_" : "_u_") + Tasks.getDateString() + ".yml");
238  		try {
239  			Tasks.copy((groups ? w.getGroupsFile() : w.getUsersFile()), backupFile);
240  		} catch (IOException ex) {
241  			GroupManager.logger.log(Level.SEVERE, null, ex);
242  		}
243  	}
244  	public OverloadedWorldHolder getWorldData(String worldName) {
245  		String worldNameLowered = worldName.toLowerCase();
246  		if (worldsData.containsKey(worldNameLowered))
247  			return getUpdatedWorldData(worldNameLowered);
248  		if (worldsData.containsKey("all_unnamed_worlds")) {
249  			GroupManager.logger.finest("Requested world " + worldName + " not found or badly mirrored. Returning all_unnamed_worlds world...");
250  			return getUpdatedWorldData("all_unnamed_worlds");
251  		}
252  		GroupManager.logger.finest("Requested world " + worldName + " not found or badly mirrored. Returning default world...");
253  		return getDefaultWorld();
254  	}
255  	private OverloadedWorldHolder getUpdatedWorldData(String worldName) {
256  		String worldNameLowered = worldName.toLowerCase();
257  		if (worldsData.containsKey(worldNameLowered)) {
258  			OverloadedWorldHolder data = worldsData.get(worldNameLowered);
259  			data.updateDataSource();
260  			return data;
261  		}
262  		return null;
263  	}
264  	public OverloadedWorldHolder getWorldDataByPlayerName(String playerName) {
265  		List<Player> matchPlayer = plugin.getServer().matchPlayer(playerName);
266  		if (matchPlayer.size() == 1) {
267  			return getWorldData(matchPlayer.get(0));
268  		}
269  		return null;
270  	}
271  	public OverloadedWorldHolder getWorldData(Player player) {
272  		return getWorldData(player.getWorld().getName());
273  	}
274  	public AnjoPermissionsHandler getWorldPermissions(String worldName) {
275  		return getWorldData(worldName).getPermissionsHandler();
276  	}
277  	public AnjoPermissionsHandler getWorldPermissions(Player player) {
278  		return getWorldData(player).getPermissionsHandler();
279  	}
280  	public AnjoPermissionsHandler getWorldPermissionsByPlayerName(String playerName) {
281  		WorldDataHolder dh = getWorldDataByPlayerName(playerName);
282  		if (dh != null) {
283  			return dh.getPermissionsHandler();
284  		}
285  		return null;
286  	}
287  	private void verifyFirstRun() {
288  		if (plugin.getServer().getName().equalsIgnoreCase("BukkitForge")) {
289  			serverDefaultWorldName = "overworld";
290  		} else {
291  			Properties server = new Properties();
292  			try {
293  				server.load(new FileInputStream(new File("server.properties")));
294  				serverDefaultWorldName = server.getProperty("level-name").toLowerCase();
295  			} catch (IOException ex) {
296  				GroupManager.logger.log(Level.SEVERE, null, ex);
297  			}
298  		}
299  		setupWorldFolder(serverDefaultWorldName);
300  	}
301  	public void setupWorldFolder(String worldName) {
302  		String worldNameLowered = worldName.toLowerCase();
303  		worldsFolder = new File(plugin.getDataFolder(), "worlds");
304  		if (!worldsFolder.exists()) {
305  			worldsFolder.mkdirs();
306  		}
307  		File defaultWorldFolder = new File(worldsFolder, worldNameLowered);
308  		if ((!defaultWorldFolder.exists()) && ((!mirrorsGroup.containsKey(worldNameLowered))) || (!mirrorsUser.containsKey(worldNameLowered))) {
309  			File casedWorldFolder = new File(worldsFolder, worldName);
310  			if ((casedWorldFolder.exists()) && (casedWorldFolder.getName().toLowerCase().equals(worldNameLowered))) {
311  				casedWorldFolder.renameTo(new File(worldsFolder, worldNameLowered));
312  			} else {
313  				defaultWorldFolder.mkdirs();
314  			}
315  		}
316  		if (defaultWorldFolder.exists()) {
317  			if (!mirrorsGroup.containsKey(worldNameLowered)) {
318  				File groupsFile = new File(defaultWorldFolder, "groups.yml");
319  				if (!groupsFile.exists() || groupsFile.length() == 0) {
320  					InputStream template = plugin.getResourceAsStream("groups.yml");
321  					try {
322  						Tasks.copy(template, groupsFile);
323  					} catch (IOException ex) {
324  						GroupManager.logger.log(Level.SEVERE, null, ex);
325  					}
326  				}
327  			}
328  			if (!mirrorsUser.containsKey(worldNameLowered)) {
329  				File usersFile = new File(defaultWorldFolder, "users.yml");
330  				if (!usersFile.exists() || usersFile.length() == 0) {
331  					InputStream template = plugin.getResourceAsStream("users.yml");
332  					try {
333  						Tasks.copy(template, usersFile);
334  					} catch (IOException ex) {
335  						GroupManager.logger.log(Level.SEVERE, null, ex);
336  					}
337  				}
338  			}
339  		}
340  	}
341  	public boolean cloneWorld(String fromWorld, String toWorld) {
342  		File fromWorldFolder = new File(worldsFolder, fromWorld.toLowerCase());
343  		File toWorldFolder = new File(worldsFolder, toWorld.toLowerCase());
344  		if (toWorldFolder.exists() || !fromWorldFolder.exists()) {
345  			return false;
346  		}
347  		File fromWorldGroups = new File(fromWorldFolder, "groups.yml");
348  		File fromWorldUsers = new File(fromWorldFolder, "users.yml");
349  		if (!fromWorldGroups.exists() || !fromWorldUsers.exists()) {
350  			return false;
351  		}
352  		File toWorldGroups = new File(toWorldFolder, "groups.yml");
353  		File toWorldUsers = new File(toWorldFolder, "users.yml");
354  		toWorldFolder.mkdirs();
355  		try {
356  			Tasks.copy(fromWorldGroups, toWorldGroups);
357  			Tasks.copy(fromWorldUsers, toWorldUsers);
358  		} catch (IOException ex) {
359  			Logger.getLogger(WorldsHolder.class.getName()).log(Level.SEVERE, null, ex);
360  			return false;
361  		}
362  		return true;
363  	}
364  	public void loadWorld(String worldName) {
365  		loadWorld(worldName, false);
366  	}
367  	public void loadWorld(String worldName, Boolean isMirror) {
368  		String worldNameLowered = worldName.toLowerCase();
369  		if (worldsData.containsKey(worldNameLowered)) {
370  			worldsData.get(worldNameLowered).reload();
371  			return;
372  		}
373  		GroupManager.logger.finest("Trying to load world " + worldName + "...");
374  		File thisWorldFolder = new File(worldsFolder, worldNameLowered);
375  		if ((isMirror) || (thisWorldFolder.exists() && thisWorldFolder.isDirectory())) {
376  			File groupsFile = (mirrorsGroup.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, "groups.yml");
377  			File usersFile = (mirrorsUser.containsKey(worldNameLowered)) ? null : new File(thisWorldFolder, "users.yml");
378  			if ((groupsFile != null) && (!groupsFile.exists())) {
379  				throw new IllegalArgumentException("Groups file for world '" + worldName + "' doesnt exist: " + groupsFile.getPath());
380  			}
381  			if ((usersFile != null) && (!usersFile.exists())) {
382  				throw new IllegalArgumentException("Users file for world '" + worldName + "' doesnt exist: " + usersFile.getPath());
383  			}
384  			WorldDataHolder tempHolder = new WorldDataHolder(worldNameLowered);
385  			if (mirrorsGroup.containsKey(worldNameLowered))
386  				tempHolder.setGroupsObject(this.getWorldData(mirrorsGroup.get(worldNameLowered)).getGroupsObject());
387  			else
388  				tempHolder.loadGroups(groupsFile);
389  			if (mirrorsUser.containsKey(worldNameLowered))
390  				tempHolder.setUsersObject(this.getWorldData(mirrorsUser.get(worldNameLowered)).getUsersObject());
391  			else
392  				tempHolder.loadUsers(usersFile);
393  			OverloadedWorldHolder thisWorldData = new OverloadedWorldHolder(tempHolder);
394  			tempHolder = null;
395  			thisWorldData.setTimeStamps();
396  			if (thisWorldData != null) {
397  				GroupManager.logger.finest("Successful load of world " + worldName + "...");
398  				worldsData.put(worldNameLowered, thisWorldData);
399  				return;
400  			}
401  		}
402  	}
403  	public boolean isInList(String worldName) {
404  		if (worldsData.containsKey(worldName.toLowerCase()) || mirrorsGroup.containsKey(worldName.toLowerCase()) || mirrorsUser.containsKey(worldName.toLowerCase())) {
405  			return true;
406  		}
407  		return false;
408  	}
409  	public boolean hasOwnData(String worldName) {
410  		if (worldsData.containsKey(worldName.toLowerCase()) && (!mirrorsGroup.containsKey(worldName.toLowerCase()) || !mirrorsUser.containsKey(worldName.toLowerCase()))) {
411  			return true;
412  		}
413  		return false;
414  	}
415  	public OverloadedWorldHolder getDefaultWorld() {
416  		return getUpdatedWorldData(serverDefaultWorldName);
417  	}
418  	public ArrayList<OverloadedWorldHolder> allWorldsDataList() {
419  		ArrayList<OverloadedWorldHolder> list = new ArrayList<OverloadedWorldHolder>();
420  		for (String world : worldsData.keySet()) {
421  			if (!world.equalsIgnoreCase("all_unnamed_worlds")) {
422  				OverloadedWorldHolder data = getWorldData(world);
423  				if (!list.contains(data)) {
424  					String worldNameLowered = data.getName().toLowerCase();
425  					String usersMirror = mirrorsUser.get(worldNameLowered);
426  					String groupsMirror = mirrorsGroup.get(worldNameLowered);
427  					if (usersMirror != null) {
428  						if (groupsMirror != null) {
429  							if (usersMirror == groupsMirror) {
430  								data = getWorldData(usersMirror.toLowerCase());
431  								if (!list.contains(data))
432  									list.add(data);
433  								continue;
434  							}
435  						}
436  					}
437  					list.add(data);
438  				}
439  			}
440  		}
441  		return list;
442  	}
443  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistryTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldsHolder.java</div>
                </div>
                <div class="column column_space"><pre><code>4  import com.weibo.api.motan.registry.NotifyListener;
5  import com.weibo.api.motan.registry.Registry;
6  import com.weibo.api.motan.rpc.Request;
7  import com.weibo.api.motan.rpc.Response;
8  import com.weibo.api.motan.rpc.URL;
9  import com.weibo.api.motan.transport.Channel;
10  import com.weibo.api.motan.transport.MessageHandler;
11  import com.weibo.api.motan.transport.netty4.NettyServer;
12  import com.weibo.api.motan.transport.support.DefaultRpcHeartbeatFactory;
13  import com.weibo.api.motan.util.MotanSwitcherUtil;
14  import com.weibo.api.motan.util.UrlUtils;
15  import org.apache.commons.lang3.tuple.MutablePair;
16  import org.apache.commons.lang3.tuple.Pair;
17  import org.junit.Before;
18  import org.junit.Test;
19  import java.lang.reflect.Field;
20  import java.lang.reflect.Method;
21  import java.util.*;
22  import static org.junit.Assert.*;
23  public class MeshRegistryTest {
24      URL registryUrl;
</pre></code></div>
                <div class="column column_space"><pre><code>2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.IOException;
5  import java.io.InputStream;
6  import java.util.ArrayList;
7  import java.util.HashMap;
8  import java.util.HashSet;
9  import java.util.List;
10  import java.util.Map;
11  import java.util.Properties;
12  import java.util.logging.Level;
13  import java.util.logging.Logger;
14  import org.anjocaido.groupmanager.GroupManager;
15  import org.anjocaido.groupmanager.dataholder.WorldDataHolder;
16  import org.anjocaido.groupmanager.dataholder.OverloadedWorldHolder;
17  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
18  import org.anjocaido.groupmanager.utils.Tasks;
19  import org.bukkit.World;
20  import org.bukkit.entity.Player;
21  public class WorldsHolder {
22  	private Map<String, OverloadedWorldHolder> worldsData = new HashMap<String, OverloadedWorldHolder>();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    