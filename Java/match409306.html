<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for KQueueEventLoop.java &amp; UnsafeByteBufUtil.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for KQueueEventLoop.java &amp; UnsafeByteBufUtil.java
      </h3>
<h1 align="center">
        9.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>KQueueEventLoop.java (15.524194%)<th>UnsafeByteBufUtil.java (6.80212%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(29-47)<td><a href="#" name="0">(18-36)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(323-327)<td><a href="#" name="1">(38-42)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(209-213)<td><a href="#" name="2">(471-474)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(183-187)<td><a href="#" name="3">(451-455)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(172-176)<td><a href="#" name="4">(230-234)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(109-112)<td><a href="#" name="5">(431-434)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(94-99)<td><a href="#" name="6">(56-60)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(74-77)<td><a href="#" name="7">(464-466)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KQueueEventLoop.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.channel.kqueue;
2 import io.netty.channel.EventLoop;
3 import io.netty.channel.EventLoopGroup;
4 import io.netty.channel.EventLoopTaskQueueFactory;
5 import io.netty.channel.SelectStrategy;
6 import io.netty.channel.SingleThreadEventLoop;
7 import io.netty.channel.kqueue.AbstractKQueueChannel.AbstractKQueueUnsafe;
8 import io.netty.channel.unix.FileDescriptor;
9 import io.netty.channel.unix.IovArray;
10 <a name="0"></a>import io.netty.util.IntSupplier;
11 import io.netty.util.collection.IntObjectHashMap;
12 import io.netty.util.collection.IntObjectMap;
13 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.util.concurrent.RejectedExecutionHandler;
14 import io.netty.util.internal.ObjectUtil;
15 import io.netty.util.internal.PlatformDependent;
16 import io.netty.util.internal.logging.InternalLogger;
17 import io.netty.util.internal.logging.InternalLoggerFactory;
18 import java.io.IOException;
19 import java.util.Queue;
20 import java.util.concurrent.Executor;
21 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
22 import static java.lang.Math.min;
23 final class KQueueEventLoop extends SingleThreadEventLoop {
24     private static final InternalLogger logger = InternalLoggerFactory.getInstance(KQueueEventLoop.class);
25     private static final AtomicIntegerFieldUpdater&lt;KQueueEventLoop&gt; WAKEN_UP_UPDATER =</b></font>
26             AtomicIntegerFieldUpdater.newUpdater(KQueueEventLoop.class, "wakenUp");
27     private static final int KQUEUE_WAKE_UP_IDENT = 0;
28     static {
29         KQueue.ensureAvailability();
30     }
31     private final boolean allowGrowing;
32     private final FileDescriptor kqueueFd;
33     private final KQueueEventArray changeList;
34     private final KQueueEventArray eventList;
35     private final SelectStrategy selectStrategy;
36     private final IovArray iovArray = new IovArray();
37     private final IntSupplier selectNowSupplier = new IntSupplier() {
38         @Override
39         public int get() throws Exception {
40             return kqueueWaitNow();
41         }
42     };
43     private final IntObjectMap&lt;AbstractKQueueChannel&gt; channels = new IntObjectHashMap&lt;AbstractKQueueChannel&gt;(4096);
44 <a name="7"></a>    private volatile int wakenUp;
45     private volatile int ioRatio = 50;
46     KQueueEventLoop(EventLoopGroup parent, <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Executor executor, int maxEvents,
47                     SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,
48                     EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) {
49         super(parent, executor, false, newTaskQueue</b></font>(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),
50                 rejectedExecutionHandler);
51         this.selectStrategy = ObjectUtil.checkNotNull(strategy, "strategy");
52         this.kqueueFd = Native.newKQueue();
53         if (maxEvents == 0) {
54             allowGrowing = true;
55             maxEvents = 4096;
56         } else {
57             allowGrowing = false;
58         }
59         this.changeList = new KQueueEventArray(maxEvents);
60         this.eventList = new KQueueEventArray(maxEvents);
61         int result = Native.keventAddUserEvent(kqueueFd.intValue(), KQUEUE_WAKE_UP_IDENT);
62         if (result &lt; 0) {
63 <a name="6"></a>            cleanup();
64             throw new IllegalStateException("kevent failed to add user event with errno: " + (-result));
65         }
66     <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
67     private static Queue&lt;Runnable&gt; newTaskQueue(
68             EventLoopTaskQueueFactory queueFactory) {
69         if (queueFactory == null) {
70             return newTaskQueue0</b></font>(DEFAULT_MAX_PENDING_TASKS);
71         }
72         return queueFactory.newTaskQueue(DEFAULT_MAX_PENDING_TASKS);
73     }
74     void add(AbstractKQueueChannel ch) {
75         assert inEventLoop();
76 <a name="5"></a>        AbstractKQueueChannel old = channels.put(ch.fd().intValue(), ch);
77         assert old == null || !<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>old.isOpen();
78     }
79     void evSet(AbstractKQueueChannel ch, short filter, short flags, int fflags) {</b></font>
80         assert inEventLoop();
81         changeList.evSet(ch, filter, flags, fflags);
82     }
83     void remove(AbstractKQueueChannel ch) throws Exception {
84         assert inEventLoop();
85         int fd = ch.fd().intValue();
86         AbstractKQueueChannel old = channels.remove(fd);
87         if (old != null &amp;&amp; old != ch) {
88             channels.put(fd, old);
89             assert !ch.isOpen();
90         } else if (ch.isOpen()) {
91             //
92             ch.unregisterFilters();
93         }
94     }
95     IovArray cleanArray() {
96         iovArray.clear();
97         return iovArray;
98     }
99     @Override
100     protected void wakeup(boolean inEventLoop) {
101         if (!inEventLoop &amp;&amp; WAKEN_UP_UPDATER.compareAndSet(this, 0, 1)) {
102             wakeup();
103         }
104     }
105     private void wakeup() {
106         Native.keventTriggerUserEvent(kqueueFd.intValue(), KQUEUE_WAKE_UP_IDENT);
107     }
108     private int kqueueWait(boolean oldWakeup) throws IOException {
109         if (oldWakeup &amp;&amp; hasTasks()) {
110             return kqueueWaitNow();
111         }
112         long totalDelay = delayNanos(System.nanoTime());
113         int delaySeconds = (int) min(totalDelay / 1000000000L, Integer.MAX_VALUE);
114 <a name="4"></a>        return kqueueWait(delaySeconds, (int) min(totalDelay - delaySeconds * 1000000000L, Integer.MAX_VALUE));
115     }
116     private int kqueueWaitNow() throws IOException <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
117         return kqueueWait(0, 0);
118     }
119     private int kqueueWait(int timeoutSec, int timeoutNs) throws IOException {</b></font>
120         int numEvents = Native.keventWait(kqueueFd.intValue(), changeList, eventList, timeoutSec, timeoutNs);
121         changeList.clear();
122         return numEvents;
123 <a name="3"></a>    }
124     private void processReady(int ready) {
125         for (int i = 0; i &lt; ready; ++i) <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
126             final short filter = eventList.filter(i);
127             final short flags = eventList.flags(i);
128             final int fd = eventList.fd(i);
129             if (filter == Native.EVFILT_USER || (flags &amp; Native.EV_ERROR) != 0) {</b></font>
130                 assert filter != Native.EVFILT_USER ||
131                         (filter == Native.EVFILT_USER &amp;&amp; fd == KQUEUE_WAKE_UP_IDENT);
132                 continue;
133             }
134             AbstractKQueueChannel channel = channels.get(fd);
135             if (channel == null) {
136                 logger.warn("events[{}]=[{}, {}] had no channel!", i, eventList.fd(i), filter);
137                 continue;
138             }
139             AbstractKQueueUnsafe unsafe = (AbstractKQueueUnsafe) channel.unsafe();
140 <a name="2"></a>                        if (filter == Native.EVFILT_WRITE) {
141                 unsafe.writeReady();
142             } else if (filter == Native.EVFILT_READ) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
143                 unsafe.readReady(eventList.data(i));
144             } else if (filter == Native.EVFILT_SOCK &amp;&amp; (eventList.fflags(i) &amp; Native.NOTE_RDHUP) != 0) {
145                 unsafe.readEOF</b></font>();
146             }
147             if ((flags &amp; Native.EV_EOF) != 0) {
148                 unsafe.readEOF();
149             }
150         }
151     }
152     @Override
153     protected void run() {
154         for (;;) {
155             try {
156                 int strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
157                 switch (strategy) {
158                     case SelectStrategy.CONTINUE:
159                         continue;
160                     case SelectStrategy.BUSY_WAIT:
161                     case SelectStrategy.SELECT:
162                         strategy = kqueueWait(WAKEN_UP_UPDATER.getAndSet(this, 0) == 1);
163                         //
164                         //
165                         //
166                         //
167                         if (wakenUp == 1) {
168                             wakeup();
169                         }
170                     default:
171                 }
172                 final int ioRatio = this.ioRatio;
173                 if (ioRatio == 100) {
174                     try {
175                         if (strategy &gt; 0) {
176                             processReady(strategy);
177                         }
178                     } finally {
179                         runAllTasks();
180                     }
181                 } else {
182                     final long ioStartTime = System.nanoTime();
183                     try {
184                         if (strategy &gt; 0) {
185                             processReady(strategy);
186                         }
187                     } finally {
188                         final long ioTime = System.nanoTime() - ioStartTime;
189                         runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
190                     }
191                 }
192                 if (allowGrowing &amp;&amp; strategy == eventList.capacity()) {
193                     //increase the size of the array as we needed the whole space for the events
194                     eventList.realloc(false);
195                 }
196             } catch (Error e) {
197                 throw e;
198             } catch (Throwable t) {
199                 handleLoopException(t);
200             } finally {
201                 try {
202                     if (isShuttingDown()) {
203                         closeAll();
204                         if (confirmShutdown()) {
205                             break;
206                         }
207                     }
208                 } catch (Error e) {
209                     throw e;
210                 } catch (Throwable t) {
211                     handleLoopException(t);
212                 }
213             }
214         }
215 <a name="1"></a>    }
216     @Override
217     protected Queue&lt;Runnable&gt; newTaskQueue(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int maxPendingTasks) {
218         return newTaskQueue0(maxPendingTasks);
219     }
220     private static Queue&lt;Runnable&gt; newTaskQueue0(int maxPendingTasks) {</b></font>
221         return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.&lt;Runnable&gt;newMpscQueue()
222                 : PlatformDependent.&lt;Runnable&gt;newMpscQueue(maxPendingTasks);
223     }
224     public int getIoRatio() {
225         return ioRatio;
226     }
227     public void setIoRatio(int ioRatio) {
228         if (ioRatio &lt;= 0 || ioRatio &gt; 100) {
229             throw new IllegalArgumentException("ioRatio: " + ioRatio + " (expected: 0 &lt; ioRatio &lt;= 100)");
230         }
231         this.ioRatio = ioRatio;
232     }
233     @Override
234     public int registeredChannels() {
235         return channels.size();
236     }
237     @Override
238     protected void cleanup() {
239         try {
240             try {
241                 kqueueFd.close();
242             } catch (IOException e) {
243                 logger.warn("Failed to close the kqueue fd.", e);
244             }
245         } finally {
246             changeList.free();
247             eventList.free();
248         }
249     }
250     private void closeAll() {
251         try {
252             kqueueWaitNow();
253         } catch (IOException e) {
254         }
255         AbstractKQueueChannel[] localChannels = channels.values().toArray(new AbstractKQueueChannel[0]);
256         for (AbstractKQueueChannel ch: localChannels) {
257             ch.unsafe().close(ch.unsafe().voidPromise());
258         }
259     }
260     private static void handleLoopException(Throwable t) {
261         logger.warn("Unexpected exception in the selector loop.", t);
262         try {
263             Thread.sleep(1000);
264         } catch (InterruptedException e) {
265         }
266     }
267 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>UnsafeByteBufUtil.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.buffer;
2 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io.netty.util.internal.PlatformDependent;
3 import java.io.IOException;
4 import java.io.InputStream;
5 import java.io.OutputStream;
6 import java.nio.ByteBuffer;
7 import java.nio.ByteOrder;
8 import java.nio.ReadOnlyBufferException;
9 import static io.netty.util.internal.MathUtil.isOutOfBounds;
10 import static io.netty.util.internal.ObjectUtil.checkNotNull;
11 import static io.netty.util.internal.PlatformDependent.BIG_ENDIAN_NATIVE_ORDER;
12 final class UnsafeByteBufUtil {
13 <a name="1"></a>    private static final boolean UNALIGNED = PlatformDependent.isUnaligned();
14     private static final byte ZERO = 0</b></font>;
15     static byte getByte(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>long address) {
16         return PlatformDependent.getByte(address);
17     }
18     static short getShort(long address) {</b></font>
19         if (UNALIGNED) {
20             short v = PlatformDependent.getShort(address);
21             return BIG_ENDIAN_NATIVE_ORDER ? v : Short.reverseBytes(v);
22         }
23         return (short) (PlatformDependent.getByte(address) &lt;&lt; 8 | PlatformDependent.getByte(address + 1) &amp; 0xff);
24     }
25     static short getShortLE(long address) {
26         if (UNALIGNED) {
27             short v = PlatformDependent.getShort(address);
28 <a name="6"></a>            return BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes(v) : v;
29         }
30         return (short) (PlatformDependent.getByte(address) &amp; 0xff | PlatformDependent.getByte(address + 1) &lt;&lt; 8);
31     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
32     static int getUnsignedMedium(long address) {
33         if (UNALIGNED) {
34             return (PlatformDependent.getByte</b></font>(address) &amp; 0xff) &lt;&lt; 16 |
35                     (BIG_ENDIAN_NATIVE_ORDER ? PlatformDependent.getShort(address + 1)
36                                              : Short.reverseBytes(PlatformDependent.getShort(address + 1))) &amp; 0xffff;
37         }
38         return (PlatformDependent.getByte(address)     &amp; 0xff) &lt;&lt; 16 |
39                (PlatformDependent.getByte(address + 1) &amp; 0xff) &lt;&lt; 8  |
40                PlatformDependent.getByte(address + 2)  &amp; 0xff;
41     }
42     static int getUnsignedMediumLE(long address) {
43         if (UNALIGNED) {
44             return (PlatformDependent.getByte(address) &amp; 0xff) |
45                     ((BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes(PlatformDependent.getShort(address + 1))
46                                               : PlatformDependent.getShort(address + 1)) &amp; 0xffff) &lt;&lt; 8;
47         }
48         return PlatformDependent.getByte(address)      &amp; 0xff        |
49                (PlatformDependent.getByte(address + 1) &amp; 0xff) &lt;&lt; 8  |
50                (PlatformDependent.getByte(address + 2) &amp; 0xff) &lt;&lt; 16;
51     }
52     static int getInt(long address) {
53         if (UNALIGNED) {
54             int v = PlatformDependent.getInt(address);
55             return BIG_ENDIAN_NATIVE_ORDER ? v : Integer.reverseBytes(v);
56         }
57         return PlatformDependent.getByte(address) &lt;&lt; 24 |
58                (PlatformDependent.getByte(address + 1) &amp; 0xff) &lt;&lt; 16 |
59                (PlatformDependent.getByte(address + 2) &amp; 0xff) &lt;&lt;  8 |
60                PlatformDependent.getByte(address + 3)  &amp; 0xff;
61     }
62     static int getIntLE(long address) {
63         if (UNALIGNED) {
64             int v = PlatformDependent.getInt(address);
65             return BIG_ENDIAN_NATIVE_ORDER ? Integer.reverseBytes(v) : v;
66         }
67         return PlatformDependent.getByte(address) &amp; 0xff |
68                (PlatformDependent.getByte(address + 1) &amp; 0xff) &lt;&lt;  8 |
69                (PlatformDependent.getByte(address + 2) &amp; 0xff) &lt;&lt; 16 |
70                PlatformDependent.getByte(address + 3) &lt;&lt; 24;
71     }
72     static long getLong(long address) {
73         if (UNALIGNED) {
74             long v = PlatformDependent.getLong(address);
75             return BIG_ENDIAN_NATIVE_ORDER ? v : Long.reverseBytes(v);
76         }
77         return ((long) PlatformDependent.getByte(address)) &lt;&lt; 56 |
78                (PlatformDependent.getByte(address + 1) &amp; 0xffL) &lt;&lt; 48 |
79                (PlatformDependent.getByte(address + 2) &amp; 0xffL) &lt;&lt; 40 |
80                (PlatformDependent.getByte(address + 3) &amp; 0xffL) &lt;&lt; 32 |
81                (PlatformDependent.getByte(address + 4) &amp; 0xffL) &lt;&lt; 24 |
82                (PlatformDependent.getByte(address + 5) &amp; 0xffL) &lt;&lt; 16 |
83                (PlatformDependent.getByte(address + 6) &amp; 0xffL) &lt;&lt;  8 |
84                (PlatformDependent.getByte(address + 7)) &amp; 0xffL;
85     }
86     static long getLongLE(long address) {
87         if (UNALIGNED) {
88             long v = PlatformDependent.getLong(address);
89             return BIG_ENDIAN_NATIVE_ORDER ? Long.reverseBytes(v) : v;
90         }
91         return (PlatformDependent.getByte(address))    &amp; 0xffL        |
92                (PlatformDependent.getByte(address + 1) &amp; 0xffL) &lt;&lt;  8 |
93                (PlatformDependent.getByte(address + 2) &amp; 0xffL) &lt;&lt; 16 |
94                (PlatformDependent.getByte(address + 3) &amp; 0xffL) &lt;&lt; 24 |
95                (PlatformDependent.getByte(address + 4) &amp; 0xffL) &lt;&lt; 32 |
96                (PlatformDependent.getByte(address + 5) &amp; 0xffL) &lt;&lt; 40 |
97                (PlatformDependent.getByte(address + 6) &amp; 0xffL) &lt;&lt; 48 |
98                ((long) PlatformDependent.getByte(address + 7))  &lt;&lt; 56;
99     }
100     static void setByte(long address, int value) {
101         PlatformDependent.putByte(address, (byte) value);
102     }
103     static void setShort(long address, int value) {
104         if (UNALIGNED) {
105             PlatformDependent.putShort(
106                     address, BIG_ENDIAN_NATIVE_ORDER ? (short) value : Short.reverseBytes((short) value));
107         } else {
108             PlatformDependent.putByte(address, (byte) (value &gt;&gt;&gt; 8));
109             PlatformDependent.putByte(address + 1, (byte) value);
110         }
111     }
112     static void setShortLE(long address, int value) {
113         if (UNALIGNED) {
114             PlatformDependent.putShort(
115                 address, BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes((short) value) : (short) value);
116         } else {
117             PlatformDependent.putByte(address, (byte) value);
118             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 8));
119         }
120     }
121     static void setMedium(long address, int value) {
122         PlatformDependent.putByte(address, (byte) (value &gt;&gt;&gt; 16));
123         if (UNALIGNED) {
124             PlatformDependent.putShort(address + 1, BIG_ENDIAN_NATIVE_ORDER ? (short) value
125                                                                             : Short.reverseBytes((short) value));
126         } else {
127             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 8));
128             PlatformDependent.putByte(address + 2, (byte) value);
129         }
130     }
131     static void setMediumLE(long address, int value) {
132         PlatformDependent.putByte(address, (byte) value);
133         if (UNALIGNED) {
134             PlatformDependent.putShort(address + 1, BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes((short) (value &gt;&gt;&gt; 8))
135                                                                             : (short) (value &gt;&gt;&gt; 8));
136         } else {
137             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 8));
138             PlatformDependent.putByte(address + 2, (byte) (value &gt;&gt;&gt; 16));
139         }
140     }
141     static void setInt(long address, int value) {
142         if (UNALIGNED) {
143             PlatformDependent.putInt(address, BIG_ENDIAN_NATIVE_ORDER ? value : Integer.reverseBytes(value));
144         } else {
145             PlatformDependent.putByte(address, (byte) (value &gt;&gt;&gt; 24));
146             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 16));
147             PlatformDependent.putByte(address + 2, (byte) (value &gt;&gt;&gt; 8));
148             PlatformDependent.putByte(address + 3, (byte) value);
149         }
150     }
151     static void setIntLE(long address, int value) {
152         if (UNALIGNED) {
153             PlatformDependent.putInt(address, BIG_ENDIAN_NATIVE_ORDER ? Integer.reverseBytes(value) : value);
154         } else {
155             PlatformDependent.putByte(address, (byte) value);
156             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 8));
157             PlatformDependent.putByte(address + 2, (byte) (value &gt;&gt;&gt; 16));
158             PlatformDependent.putByte(address + 3, (byte) (value &gt;&gt;&gt; 24));
159         }
160     }
161     static void setLong(long address, long value) {
162         if (UNALIGNED) {
163             PlatformDependent.putLong(address, BIG_ENDIAN_NATIVE_ORDER ? value : Long.reverseBytes(value));
164         } else {
165             PlatformDependent.putByte(address, (byte) (value &gt;&gt;&gt; 56));
166             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 48));
167             PlatformDependent.putByte(address + 2, (byte) (value &gt;&gt;&gt; 40));
168             PlatformDependent.putByte(address + 3, (byte) (value &gt;&gt;&gt; 32));
169             PlatformDependent.putByte(address + 4, (byte) (value &gt;&gt;&gt; 24));
170             PlatformDependent.putByte(address + 5, (byte) (value &gt;&gt;&gt; 16));
171             PlatformDependent.putByte(address + 6, (byte) (value &gt;&gt;&gt; 8));
172             PlatformDependent.putByte(address + 7, (byte) value);
173         }
174     }
175     static void setLongLE(long address, long value) {
176         if (UNALIGNED) {
177             PlatformDependent.putLong(address, BIG_ENDIAN_NATIVE_ORDER ? Long.reverseBytes(value) : value);
178         } else {
179             PlatformDependent.putByte(address, (byte) value);
180             PlatformDependent.putByte(address + 1, (byte) (value &gt;&gt;&gt; 8));
181             PlatformDependent.putByte(address + 2, (byte) (value &gt;&gt;&gt; 16));
182             PlatformDependent.putByte(address + 3, (byte) (value &gt;&gt;&gt; 24));
183             PlatformDependent.putByte(address + 4, (byte) (value &gt;&gt;&gt; 32));
184             PlatformDependent.putByte(address + 5, (byte) (value &gt;&gt;&gt; 40));
185             PlatformDependent.putByte(address + 6, (byte) (value &gt;&gt;&gt; 48));
186             PlatformDependent.putByte(address + 7, (byte) (value &gt;&gt;&gt; 56));
187 <a name="4"></a>        }
188     }
189     static byte getByte(byte[] array, int index) <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
190         return PlatformDependent.getByte(array, index);
191     }
192     static short getShort(byte[] array, int index) {</b></font>
193         if (UNALIGNED) {
194             short v = PlatformDependent.getShort(array, index);
195             return BIG_ENDIAN_NATIVE_ORDER ? v : Short.reverseBytes(v);
196         }
197         return (short) (PlatformDependent.getByte(array, index) &lt;&lt; 8 |
198                        PlatformDependent.getByte(array, index + 1) &amp; 0xff);
199     }
200     static short getShortLE(byte[] array, int index) {
201         if (UNALIGNED) {
202             short v = PlatformDependent.getShort(array, index);
203             return BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes(v) : v;
204         }
205         return (short) (PlatformDependent.getByte(array, index) &amp; 0xff |
206                        PlatformDependent.getByte(array, index + 1) &lt;&lt; 8);
207     }
208     static int getUnsignedMedium(byte[] array, int index) {
209         if (UNALIGNED) {
210             return (PlatformDependent.getByte(array, index) &amp; 0xff) &lt;&lt; 16 |
211                     (BIG_ENDIAN_NATIVE_ORDER ? PlatformDependent.getShort(array, index + 1)
212                                              : Short.reverseBytes(PlatformDependent.getShort(array, index + 1)))
213                             &amp; 0xffff;
214         }
215         return (PlatformDependent.getByte(array, index) &amp; 0xff) &lt;&lt; 16 |
216                (PlatformDependent.getByte(array, index + 1) &amp; 0xff) &lt;&lt;  8 |
217                PlatformDependent.getByte(array, index + 2) &amp; 0xff;
218     }
219     static int getUnsignedMediumLE(byte[] array, int index) {
220         if (UNALIGNED) {
221             return (PlatformDependent.getByte(array, index) &amp; 0xff) |
222                     ((BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes(PlatformDependent.getShort(array, index + 1))
223                                               : PlatformDependent.getShort(array, index + 1)) &amp; 0xffff) &lt;&lt; 8;
224         }
225         return PlatformDependent.getByte(array, index) &amp; 0xff |
226                (PlatformDependent.getByte(array, index + 1) &amp; 0xff) &lt;&lt;  8 |
227                (PlatformDependent.getByte(array, index + 2) &amp; 0xff) &lt;&lt; 16;
228     }
229     static int getInt(byte[] array, int index) {
230         if (UNALIGNED) {
231             int v = PlatformDependent.getInt(array, index);
232             return BIG_ENDIAN_NATIVE_ORDER ? v : Integer.reverseBytes(v);
233         }
234         return PlatformDependent.getByte(array, index) &lt;&lt; 24 |
235                (PlatformDependent.getByte(array, index + 1) &amp; 0xff) &lt;&lt; 16 |
236                (PlatformDependent.getByte(array, index + 2) &amp; 0xff) &lt;&lt;  8 |
237                PlatformDependent.getByte(array, index + 3) &amp; 0xff;
238     }
239     static int getIntLE(byte[] array, int index) {
240         if (UNALIGNED) {
241             int v = PlatformDependent.getInt(array, index);
242             return BIG_ENDIAN_NATIVE_ORDER ? Integer.reverseBytes(v) : v;
243         }
244         return PlatformDependent.getByte(array, index)      &amp; 0xff        |
245                (PlatformDependent.getByte(array, index + 1) &amp; 0xff) &lt;&lt;  8 |
246                (PlatformDependent.getByte(array, index + 2) &amp; 0xff) &lt;&lt; 16 |
247                PlatformDependent.getByte(array,  index + 3) &lt;&lt; 24;
248     }
249     static long getLong(byte[] array, int index) {
250         if (UNALIGNED) {
251             long v = PlatformDependent.getLong(array, index);
252             return BIG_ENDIAN_NATIVE_ORDER ? v : Long.reverseBytes(v);
253         }
254         return ((long) PlatformDependent.getByte(array, index)) &lt;&lt; 56 |
255                (PlatformDependent.getByte(array, index + 1) &amp; 0xffL) &lt;&lt; 48 |
256                (PlatformDependent.getByte(array, index + 2) &amp; 0xffL) &lt;&lt; 40 |
257                (PlatformDependent.getByte(array, index + 3) &amp; 0xffL) &lt;&lt; 32 |
258                (PlatformDependent.getByte(array, index + 4) &amp; 0xffL) &lt;&lt; 24 |
259                (PlatformDependent.getByte(array, index + 5) &amp; 0xffL) &lt;&lt; 16 |
260                (PlatformDependent.getByte(array, index + 6) &amp; 0xffL) &lt;&lt;  8 |
261                (PlatformDependent.getByte(array, index + 7)) &amp; 0xffL;
262     }
263     static long getLongLE(byte[] array, int index) {
264         if (UNALIGNED) {
265             long v = PlatformDependent.getLong(array, index);
266             return BIG_ENDIAN_NATIVE_ORDER ? Long.reverseBytes(v) : v;
267         }
268         return PlatformDependent.getByte(array, index)      &amp; 0xffL        |
269                (PlatformDependent.getByte(array, index + 1) &amp; 0xffL) &lt;&lt;  8 |
270                (PlatformDependent.getByte(array, index + 2) &amp; 0xffL) &lt;&lt; 16 |
271                (PlatformDependent.getByte(array, index + 3) &amp; 0xffL) &lt;&lt; 24 |
272                (PlatformDependent.getByte(array, index + 4) &amp; 0xffL) &lt;&lt; 32 |
273                (PlatformDependent.getByte(array, index + 5) &amp; 0xffL) &lt;&lt; 40 |
274                (PlatformDependent.getByte(array, index + 6) &amp; 0xffL) &lt;&lt; 48 |
275                ((long) PlatformDependent.getByte(array,  index + 7)) &lt;&lt; 56;
276     }
277     static void setByte(byte[] array, int index, int value) {
278         PlatformDependent.putByte(array, index, (byte) value);
279     }
280     static void setShort(byte[] array, int index, int value) {
281         if (UNALIGNED) {
282             PlatformDependent.putShort(array, index,
283                                        BIG_ENDIAN_NATIVE_ORDER ? (short) value : Short.reverseBytes((short) value));
284         } else {
285             PlatformDependent.putByte(array, index, (byte) (value &gt;&gt;&gt; 8));
286             PlatformDependent.putByte(array, index + 1, (byte) value);
287         }
288     }
289     static void setShortLE(byte[] array, int index, int value) {
290         if (UNALIGNED) {
291             PlatformDependent.putShort(array, index,
292                                        BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes((short) value) : (short) value);
293         } else {
294             PlatformDependent.putByte(array, index, (byte) value);
295             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 8));
296         }
297     }
298     static void setMedium(byte[] array, int index, int value) {
299         PlatformDependent.putByte(array, index, (byte) (value &gt;&gt;&gt; 16));
300         if (UNALIGNED) {
301                 PlatformDependent.putShort(array, index + 1,
302                                            BIG_ENDIAN_NATIVE_ORDER ? (short) value
303                                                                    : Short.reverseBytes((short) value));
304         } else {
305             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 8));
306             PlatformDependent.putByte(array, index + 2, (byte) value);
307         }
308     }
309     static void setMediumLE(byte[] array, int index, int value) {
310         PlatformDependent.putByte(array, index, (byte) value);
311         if (UNALIGNED) {
312             PlatformDependent.putShort(array, index + 1,
313                                        BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes((short) (value &gt;&gt;&gt; 8))
314                                                                : (short) (value &gt;&gt;&gt; 8));
315         } else {
316             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 8));
317             PlatformDependent.putByte(array, index + 2, (byte) (value &gt;&gt;&gt; 16));
318         }
319     }
320     static void setInt(byte[] array, int index, int value) {
321         if (UNALIGNED) {
322             PlatformDependent.putInt(array, index, BIG_ENDIAN_NATIVE_ORDER ? value : Integer.reverseBytes(value));
323         } else {
324             PlatformDependent.putByte(array, index, (byte) (value &gt;&gt;&gt; 24));
325             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 16));
326             PlatformDependent.putByte(array, index + 2, (byte) (value &gt;&gt;&gt; 8));
327             PlatformDependent.putByte(array, index + 3, (byte) value);
328         }
329     }
330     static void setIntLE(byte[] array, int index, int value) {
331         if (UNALIGNED) {
332             PlatformDependent.putInt(array, index, BIG_ENDIAN_NATIVE_ORDER ? Integer.reverseBytes(value) : value);
333         } else {
334             PlatformDependent.putByte(array, index, (byte) value);
335             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 8));
336             PlatformDependent.putByte(array, index + 2, (byte) (value &gt;&gt;&gt; 16));
337             PlatformDependent.putByte(array, index + 3, (byte) (value &gt;&gt;&gt; 24));
338         }
339     }
340     static void setLong(byte[] array, int index, long value) {
341         if (UNALIGNED) {
342             PlatformDependent.putLong(array, index, BIG_ENDIAN_NATIVE_ORDER ? value : Long.reverseBytes(value));
343         } else {
344             PlatformDependent.putByte(array, index, (byte) (value &gt;&gt;&gt; 56));
345             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 48));
346             PlatformDependent.putByte(array, index + 2, (byte) (value &gt;&gt;&gt; 40));
347             PlatformDependent.putByte(array, index + 3, (byte) (value &gt;&gt;&gt; 32));
348             PlatformDependent.putByte(array, index + 4, (byte) (value &gt;&gt;&gt; 24));
349             PlatformDependent.putByte(array, index + 5, (byte) (value &gt;&gt;&gt; 16));
350             PlatformDependent.putByte(array, index + 6, (byte) (value &gt;&gt;&gt; 8));
351             PlatformDependent.putByte(array, index + 7, (byte) value);
352         }
353     }
354     static void setLongLE(byte[] array, int index, long value) {
355         if (UNALIGNED) {
356             PlatformDependent.putLong(array, index, BIG_ENDIAN_NATIVE_ORDER ? Long.reverseBytes(value) : value);
357         } else {
358             PlatformDependent.putByte(array, index, (byte) value);
359             PlatformDependent.putByte(array, index + 1, (byte) (value &gt;&gt;&gt; 8));
360             PlatformDependent.putByte(array, index + 2, (byte) (value &gt;&gt;&gt; 16));
361             PlatformDependent.putByte(array, index + 3, (byte) (value &gt;&gt;&gt; 24));
362             PlatformDependent.putByte(array, index + 4, (byte) (value &gt;&gt;&gt; 32));
363             PlatformDependent.putByte(array, index + 5, (byte) (value &gt;&gt;&gt; 40));
364             PlatformDependent.putByte(array, index + 6, (byte) (value &gt;&gt;&gt; 48));
365             PlatformDependent.putByte(array, index + 7, (byte) (value &gt;&gt;&gt; 56));
366         }
367     }
368     static void setZero(byte[] array, int index, int length) {
369 <a name="5"></a>        if (length == 0) {
370             return;
371         }
372         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>PlatformDependent.setMemory(array, index, length, ZERO);
373     }
374     static ByteBuf copy(AbstractByteBuf buf, long addr, int index, int length) {</b></font>
375         buf.checkIndex(index, length);
376         ByteBuf copy = buf.alloc().directBuffer(length, buf.maxCapacity());
377         if (length != 0) {
378             if (copy.hasMemoryAddress()) {
379                 PlatformDependent.copyMemory(addr, copy.memoryAddress(), length);
380                 copy.setIndex(0, length);
381             } else {
382                 copy.writeBytes(buf, index, length);
383             }
384         }
385         return copy;
386     }
387 <a name="3"></a>    static int setBytes(AbstractByteBuf buf, long addr, int index, InputStream in, int length) throws IOException {
388         buf.checkIndex(index, length);
389         ByteBuf tmpBuf = buf.alloc().heapBuffer(length);
390         try <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
391             byte[] tmp = tmpBuf.array();
392             int offset = tmpBuf.arrayOffset();
393             int readBytes = in.read(tmp, offset, length);
394             if (readBytes &gt; 0) {</b></font>
395                 PlatformDependent.copyMemory(tmp, offset, addr, readBytes);
396             }
397             return readBytes;
398         } finally {
399             tmpBuf.release();
400 <a name="7"></a>        }
401     }
402     static void getBytes(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>AbstractByteBuf buf, long addr, int index, ByteBuf dst, int dstIndex, int length) {
403         buf.checkIndex(index, length);
404         checkNotNull</b></font>(dst, "dst");
405         if (isOutOfBounds(dstIndex, length, dst.capacity())) {
406 <a name="2"></a>            throw new IndexOutOfBoundsException("dstIndex: " + dstIndex);
407         }
408         if (dst.hasMemoryAddress()) <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
409             PlatformDependent.copyMemory(addr, dst.memoryAddress() + dstIndex, length);
410         } else if (dst.hasArray()) {
411             PlatformDependent.copyMemory</b></font>(addr, dst.array(), dst.arrayOffset() + dstIndex, length);
412         } else {
413             dst.setBytes(dstIndex, buf, index, length);
414         }
415     }
416     static void getBytes(AbstractByteBuf buf, long addr, int index, byte[] dst, int dstIndex, int length) {
417         buf.checkIndex(index, length);
418         checkNotNull(dst, "dst");
419         if (isOutOfBounds(dstIndex, length, dst.length)) {
420             throw new IndexOutOfBoundsException("dstIndex: " + dstIndex);
421         }
422         if (length != 0) {
423             PlatformDependent.copyMemory(addr, dst, dstIndex, length);
424         }
425     }
426     static void getBytes(AbstractByteBuf buf, long addr, int index, ByteBuffer dst) {
427         buf.checkIndex(index, dst.remaining());
428         if (dst.remaining() == 0) {
429             return;
430         }
431         if (dst.isDirect()) {
432             if (dst.isReadOnly()) {
433                 throw new ReadOnlyBufferException();
434             }
435             long dstAddress = PlatformDependent.directBufferAddress(dst);
436             PlatformDependent.copyMemory(addr, dstAddress + dst.position(), dst.remaining());
437             dst.position(dst.position() + dst.remaining());
438         } else if (dst.hasArray()) {
439             PlatformDependent.copyMemory(addr, dst.array(), dst.arrayOffset() + dst.position(), dst.remaining());
440             dst.position(dst.position() + dst.remaining());
441         } else  {
442             dst.put(buf.nioBuffer());
443         }
444     }
445     static void setBytes(AbstractByteBuf buf, long addr, int index, ByteBuf src, int srcIndex, int length) {
446         buf.checkIndex(index, length);
447         checkNotNull(src, "src");
448         if (isOutOfBounds(srcIndex, length, src.capacity())) {
449             throw new IndexOutOfBoundsException("srcIndex: " + srcIndex);
450         }
451         if (length != 0) {
452             if (src.hasMemoryAddress()) {
453                 PlatformDependent.copyMemory(src.memoryAddress() + srcIndex, addr, length);
454             } else if (src.hasArray()) {
455                 PlatformDependent.copyMemory(src.array(), src.arrayOffset() + srcIndex, addr, length);
456             } else {
457                 src.getBytes(srcIndex, buf, index, length);
458             }
459         }
460     }
461     static void setBytes(AbstractByteBuf buf, long addr, int index, byte[] src, int srcIndex, int length) {
462         buf.checkIndex(index, length);
463         checkNotNull(src, "src");
464         if (isOutOfBounds(srcIndex, length, src.length)) {
465             throw new IndexOutOfBoundsException("srcIndex: " + srcIndex);
466         }
467         if (length != 0) {
468             PlatformDependent.copyMemory(src, srcIndex, addr, length);
469         }
470     }
471     static void setBytes(AbstractByteBuf buf, long addr, int index, ByteBuffer src) {
472         final int length = src.remaining();
473         if (length == 0) {
474             return;
475         }
476         if (src.isDirect()) {
477             buf.checkIndex(index, length);
478             long srcAddress = PlatformDependent.directBufferAddress(src);
479             PlatformDependent.copyMemory(srcAddress + src.position(), addr, length);
480             src.position(src.position() + length);
481         } else if (src.hasArray()) {
482             buf.checkIndex(index, length);
483             PlatformDependent.copyMemory(src.array(), src.arrayOffset() + src.position(), addr, length);
484             src.position(src.position() + length);
485         } else {
486             if (length &lt; 8) {
487                 setSingleBytes(buf, addr, index, src, length);
488             } else {
489                 //no need to checkIndex: internalNioBuffer is already taking care of it
490                 assert buf.nioBufferCount() == 1;
491                 final ByteBuffer internalBuffer = buf.internalNioBuffer(index, length);
492                 internalBuffer.put(src);
493             }
494         }
495     }
496     private static void setSingleBytes(final AbstractByteBuf buf, final long addr, final int index,
497                                        final ByteBuffer src, final int length) {
498         buf.checkIndex(index, length);
499         final int srcPosition = src.position();
500         final int srcLimit = src.limit();
501         long dstAddr = addr;
502         for (int srcIndex = srcPosition; srcIndex &lt; srcLimit; srcIndex++) {
503             final byte value = src.get(srcIndex);
504             PlatformDependent.putByte(dstAddr, value);
505             dstAddr++;
506         }
507         src.position(srcLimit);
508     }
509     static void getBytes(AbstractByteBuf buf, long addr, int index, OutputStream out, int length) throws IOException {
510         buf.checkIndex(index, length);
511         if (length != 0) {
512             int len = Math.min(length, ByteBufUtil.WRITE_CHUNK_SIZE);
513             if (len &lt;= ByteBufUtil.MAX_TL_ARRAY_LEN || !buf.alloc().isDirectBufferPooled()) {
514                 getBytes(addr, ByteBufUtil.threadLocalTempArray(len), 0, len, out, length);
515             } else {
516                 ByteBuf tmpBuf = buf.alloc().heapBuffer(len);
517                 try {
518                     byte[] tmp = tmpBuf.array();
519                     int offset = tmpBuf.arrayOffset();
520                     getBytes(addr, tmp, offset, len, out, length);
521                 } finally {
522                     tmpBuf.release();
523                 }
524             }
525         }
526     }
527     private static void getBytes(long inAddr, byte[] in, int inOffset, int inLen, OutputStream out, int outLen)
528             throws IOException {
529         do {
530             int len = Math.min(inLen, outLen);
531             PlatformDependent.copyMemory(inAddr, in, inOffset, len);
532             out.write(in, inOffset, len);
533             outLen -= len;
534             inAddr += len;
535         } while (outLen &gt; 0);
536     }
537     static void setZero(long addr, int length) {
538         if (length == 0) {
539             return;
540         }
541         PlatformDependent.setMemory(addr, length, ZERO);
542     }
543     static UnpooledUnsafeDirectByteBuf newUnsafeDirectByteBuf(
544             ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
545         if (PlatformDependent.useDirectBufferNoCleaner()) {
546             return new UnpooledUnsafeNoCleanerDirectByteBuf(alloc, initialCapacity, maxCapacity);
547         }
548         return new UnpooledUnsafeDirectByteBuf(alloc, initialCapacity, maxCapacity);
549     }
550     private UnsafeByteBufUtil() { }
551 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
