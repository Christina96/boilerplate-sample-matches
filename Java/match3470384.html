<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for AliasOrIndex.java & ObjectMapper.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for AliasOrIndex.java & ObjectMapper.java
      </h3>
      <h1 align="center">
        6.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>AliasOrIndex.java (11.917098%)<TH>ObjectMapper.java (4.028021%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3470384-0.html#0',2,'match3470384-1.html#0',3)" NAME="0">(99-110)<TD><A HREF="javascript:ZweiFrames('match3470384-0.html#0',2,'match3470384-1.html#0',3)" NAME="0">(275-285)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match3470384-0.html#1',2,'match3470384-1.html#1',3)" NAME="1">(20-31)<TD><A HREF="javascript:ZweiFrames('match3470384-0.html#1',2,'match3470384-1.html#1',3)" NAME="1">(20-31)</A><TD ALIGN=center><FONT COLOR="#c40000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AliasOrIndex.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="1"></A> * under the License.
 */

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match3470384-1.html#1',3,'match3470384-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.cluster.metadata;

import org.apache.lucene.util.SetOnce;
import javax.annotation.Nullable;
import org.elasticsearch.common.Strings;
import io.crate.common.collections.Tuple;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import</B></FONT> java.util.stream.Collectors;

/**
 * Encapsulates the  {@link IndexMetadata} instances of a concrete index or indices an alias is pointing to.
 */
public interface AliasOrIndex {

    /**
     * @return whether this an alias or concrete index
     */
    boolean isAlias();

    /**
     * @return All {@link IndexMetadata} of all concrete indices this alias is referring to or if this is a concrete index its {@link IndexMetadata}
     */
    List&lt;IndexMetadata&gt; getIndices();

    /**
     * Represents an concrete index and encapsulates its {@link IndexMetadata}
     */
    class Index implements AliasOrIndex {

        private final IndexMetadata concreteIndex;

        public Index(IndexMetadata indexMetadata) {
            this.concreteIndex = indexMetadata;
        }

        @Override
        public boolean isAlias() {
            return false;
        }

        @Override
        public List&lt;IndexMetadata&gt; getIndices() {
            return Collections.singletonList(concreteIndex);
        }

        /**
         * @return If this is an concrete index, its {@link IndexMetadata}
         */
        public IndexMetadata getIndex() {
            return concreteIndex;
        }

    }

    /**
     * Represents an alias and groups all {@link IndexMetadata} instances sharing the same alias name together.
     */
    class Alias implements AliasOrIndex {

        private final String aliasName;
        private final List&lt;IndexMetadata&gt; referenceIndexMetadatas;
        private SetOnce&lt;IndexMetadata&gt; writeIndex = new SetOnce&lt;&gt;();

        public Alias(AliasMetadata aliasMetadata, IndexMetadata indexMetadata) {
            this.aliasName = aliasMetadata.getAlias();
            this.referenceIndexMetadatas = new ArrayList&lt;&gt;();
            this.referenceIndexMetadatas.add(indexMetadata);
        }

        @Override
        public boolean isAlias() {
            return true;
<A NAME="0"></A>        }

        public String getAliasName() {
            <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3470384-1.html#0',3,'match3470384-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return aliasName;
        }

        @Override
        public List&lt;IndexMetadata&gt; getIndices() {
            return referenceIndexMetadatas;
        }


        @Nullable
        public IndexMetadata getWriteIndex() {
            return</B></FONT> writeIndex.get();
        }

        /**
         * Returns the unique alias metadata per concrete index.
         *
         * (note that although alias can point to the same concrete indices, each alias reference may have its own routing
         * and filters)
         */
        public Iterable&lt;Tuple&lt;String, AliasMetadata&gt;&gt; getConcreteIndexAndAliasMetadatas() {
            return new Iterable&lt;Tuple&lt;String, AliasMetadata&gt;&gt;() {
                @Override
                public Iterator&lt;Tuple&lt;String, AliasMetadata&gt;&gt; iterator() {
                    return new Iterator&lt;Tuple&lt;String, AliasMetadata&gt;&gt;() {

                        int index = 0;

                        @Override
                        public boolean hasNext() {
                            return index &lt; referenceIndexMetadatas.size();
                        }

                        @Override
                        public Tuple&lt;String, AliasMetadata&gt; next() {
                            IndexMetadata indexMetadata = referenceIndexMetadatas.get(index++);
                            return new Tuple&lt;&gt;(indexMetadata.getIndex().getName(), indexMetadata.getAliases().get(aliasName));
                        }

                        @Override
                        public void remove() {
                            throw new UnsupportedOperationException();
                        }

                    };
                }
            };
        }

        public AliasMetadata getFirstAliasMetadata() {
            return referenceIndexMetadatas.get(0).getAliases().get(aliasName);
        }

        void addIndex(IndexMetadata indexMetadata) {
            this.referenceIndexMetadatas.add(indexMetadata);
        }

        public void computeAndValidateWriteIndex() {
            List&lt;IndexMetadata&gt; writeIndices = referenceIndexMetadatas.stream()
                .filter(idxMeta -&gt; Boolean.TRUE.equals(idxMeta.getAliases().get(aliasName).writeIndex()))
                .collect(Collectors.toList());

            if (writeIndices.isEmpty() &amp;&amp; referenceIndexMetadatas.size() == 1
                    &amp;&amp; referenceIndexMetadatas.get(0).getAliases().get(aliasName).writeIndex() == null) {
                writeIndices.add(referenceIndexMetadatas.get(0));
            }

            if (writeIndices.size() == 1) {
                writeIndex.set(writeIndices.get(0));
            } else if (writeIndices.size() &gt; 1) {
                List&lt;String&gt; writeIndicesStrings = writeIndices.stream()
                    .map(i -&gt; i.getIndex().getName()).collect(Collectors.toList());
                throw new IllegalStateException(&quot;alias [&quot; + aliasName + &quot;] has more than one write index [&quot; +
                    Strings.collectionToCommaDelimitedString(writeIndicesStrings) + &quot;]&quot;);
            }
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="1"></A> * under the License.
 */

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3470384-0.html#1',2,'match3470384-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.index.mapper;

import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;
import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeIntegerValue;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import</B></FONT> java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;

import org.elasticsearch.ElasticsearchParseException;
import org.elasticsearch.common.collect.CopyOnWriteHashMap;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.time.IsoLocale;
import org.elasticsearch.common.xcontent.ToXContent;
import org.elasticsearch.common.xcontent.XContentBuilder;


public class ObjectMapper extends Mapper implements Cloneable {

    public static final String CONTENT_TYPE = &quot;object&quot;;

    public static class Defaults {
        public static final Dynamic DYNAMIC = null; // not set, inherited from root
    }

    public enum Dynamic {
        TRUE,
        FALSE,
        STRICT
    }

    public static class Builder&lt;T extends Builder&gt; extends Mapper.Builder&lt;T&gt; {

        protected Dynamic dynamic = Defaults.DYNAMIC;

        protected final List&lt;Mapper.Builder&gt; mappersBuilders = new ArrayList&lt;&gt;();
        private Integer position;

        @SuppressWarnings(&quot;unchecked&quot;)
        public Builder(String name) {
            super(name);
            this.builder = (T) this;
        }

        public T dynamic(Dynamic dynamic) {
            this.dynamic = dynamic;
            return builder;
        }

        public T add(Mapper.Builder builder) {
            mappersBuilders.add(builder);
            return this.builder;
        }

        @Override
        public ObjectMapper build(BuilderContext context) {
            context.path().add(name);

            Map&lt;String, Mapper&gt; mappers = new HashMap&lt;&gt;();
            for (Mapper.Builder builder : mappersBuilders) {
                Mapper mapper = builder.build(context);
                Mapper existing = mappers.get(mapper.simpleName());
                if (existing != null) {
                    mapper = existing.merge(mapper);
                }
                mappers.put(mapper.simpleName(), mapper);
            }
            context.path().remove();

            return createMapper(
                name,
                position,
                context.path().pathAsText(name),
                dynamic,
                mappers,
                context.indexSettings()
            );
        }

        protected ObjectMapper createMapper(String name,
                                            Integer position,
                                            String fullPath,
                                            Dynamic dynamic,
                                            Map&lt;String, Mapper&gt; mappers,
                                            @Nullable Settings settings) {
            return new ObjectMapper(name, position, fullPath, dynamic, mappers, settings);
        }

        public T position(int position) {
            this.position = position;
            return this.builder;
        }
    }

    public static class TypeParser implements Mapper.TypeParser {
        @Override
        @SuppressWarnings(&quot;rawtypes&quot;)
        public Mapper.Builder parse(String name, Map&lt;String, Object&gt; node, ParserContext parserContext) throws MapperParsingException {
            ObjectMapper.Builder builder = new Builder(name);
            for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = node.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry&lt;String, Object&gt; entry = iterator.next();
                String fieldName = entry.getKey();
                Object fieldNode = entry.getValue();
                if (parseObjectOrDocumentTypeProperties(fieldName, fieldNode, parserContext, builder)) {
                    iterator.remove();
                }
            }
            return builder;
        }

        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
        protected static boolean parseObjectOrDocumentTypeProperties(String fieldName, Object fieldNode, ParserContext parserContext, ObjectMapper.Builder builder) {
            if (fieldName.equals(&quot;position&quot;)) {
                builder.position(nodeIntegerValue(fieldNode));
                return true;
            } else if (fieldName.equals(&quot;dynamic&quot;)) {
                String value = fieldNode.toString();
                if (value.equalsIgnoreCase(&quot;strict&quot;)) {
                    builder.dynamic(Dynamic.STRICT);
                } else {
                    boolean dynamic = nodeBooleanValue(fieldNode, fieldName + &quot;.dynamic&quot;);
                    builder.dynamic(dynamic ? Dynamic.TRUE : Dynamic.FALSE);
                }
                return true;
            } else if (fieldName.equals(&quot;properties&quot;)) {
                if (fieldNode instanceof Collection &amp;&amp; ((Collection) fieldNode).isEmpty()) {
                    // nothing to do here, empty (to support &quot;properties: []&quot; case)
                } else if (!(fieldNode instanceof Map)) {
                    throw new ElasticsearchParseException(&quot;properties must be a map type&quot;);
                } else {
                    parseProperties(builder, (Map&lt;String, Object&gt;) fieldNode, parserContext);
                }
                return true;
            }
            return false;
        }

        @SuppressWarnings(&quot;rawtypes&quot;)
        protected static void parseProperties(ObjectMapper.Builder objBuilder, Map&lt;String, Object&gt; propsNode, ParserContext parserContext) {
            Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = propsNode.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry&lt;String, Object&gt; entry = iterator.next();
                String fieldName = entry.getKey();
                // Should accept empty arrays, as a work around for when the
                // user can't provide an empty Map. (PHP for example)
                boolean isEmptyList = entry.getValue() instanceof List &amp;&amp; ((List&lt;?&gt;) entry.getValue()).isEmpty();

                if (entry.getValue() instanceof Map) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Map&lt;String, Object&gt; propNode = (Map&lt;String, Object&gt;) entry.getValue();
                    String type;
                    Object typeNode = propNode.get(&quot;type&quot;);
                    if (typeNode != null) {
                        type = typeNode.toString();
                    } else {
                        // lets see if we can derive this...
                        if (propNode.get(&quot;properties&quot;) != null) {
                            type = ObjectMapper.CONTENT_TYPE;
                        } else if (propNode.size() == 1 &amp;&amp; propNode.get(&quot;enabled&quot;) != null) {
                            // if there is a single property with the enabled
                            // flag on it, make it an object
                            // (usually, setting enabled to false to not index
                            // any type, including core values, which
                            type = ObjectMapper.CONTENT_TYPE;
                        } else {
                            throw new MapperParsingException(&quot;No type specified for field [&quot; + fieldName + &quot;]&quot;);
                        }
                    }

                    Mapper.TypeParser typeParser = parserContext.typeParser(type);
                    if (typeParser == null) {
                        throw new MapperParsingException(&quot;No handler for type [&quot; + type + &quot;] declared on field [&quot; + fieldName + &quot;]&quot;);
                    }
                    String[] fieldNameParts = fieldName.split(&quot;\\.&quot;);
                    String realFieldName = fieldNameParts[fieldNameParts.length - 1];
                    Mapper.Builder&lt;?&gt; fieldBuilder = typeParser.parse(realFieldName, propNode, parserContext);
                    for (int i = fieldNameParts.length - 2; i &gt;= 0; --i) {
                        ObjectMapper.Builder&lt;?&gt; intermediate = new ObjectMapper.Builder&lt;&gt;(fieldNameParts[i]);
                        intermediate.add(fieldBuilder);
                        fieldBuilder = intermediate;
                    }
                    objBuilder.add(fieldBuilder);
                    propNode.remove(&quot;type&quot;);
                    DocumentMapperParser.checkNoRemainingFields(fieldName, propNode, parserContext.indexVersionCreated());
                    iterator.remove();
                } else if (isEmptyList) {
                    iterator.remove();
                } else {
                    throw new MapperParsingException(&quot;Expected map for property [fields] on field [&quot; + fieldName + &quot;] but got a &quot;
                            + fieldName.getClass());
                }
            }

            DocumentMapperParser.checkNoRemainingFields(propsNode, parserContext.indexVersionCreated(),
                    &quot;DocType mapping definition has unsupported parameters: &quot;);

        }

    }

    private final Integer position;

    private final String fullPath;

    private volatile Dynamic dynamic;

    private volatile CopyOnWriteHashMap&lt;String, Mapper&gt; mappers;

    ObjectMapper(String name, Integer position,
                 String fullPath,
                 Dynamic dynamic,
                 Map&lt;String, Mapper&gt; mappers,
                 Settings settings) {
        super(name);
        assert settings != null;
        if (name.isEmpty()) {
            throw new IllegalArgumentException(&quot;name cannot be empty string&quot;);
        }
        this.fullPath = fullPath;
        this.position = position;
        this.dynamic = dynamic;
        if (mappers == null) {
            this.mappers = new CopyOnWriteHashMap&lt;&gt;();
        } else {
            this.mappers = CopyOnWriteHashMap.copyOf(mappers);
        }
    }

    @Override
    protected ObjectMapper clone() {
        ObjectMapper clone;
        try {
            clone = (ObjectMapper) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        return clone;
    }

    /**
     * Build a mapping update with the provided sub mapping update.
     */
    public ObjectMapper mappingUpdate(Mapper mapper) {
        ObjectMapper mappingUpdate = clone();
<A NAME="0"></A>        // reset the sub mappers
        mappingUpdate.mappers = new CopyOnWriteHashMap&lt;&gt;();
        mappingUpdate.putMapper(mapper);
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3470384-0.html#0',2,'match3470384-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return mappingUpdate;
    }

    @Override
    public String name() {
        return this.fullPath;
    }

    @Override
    public String typeName() {
        return</B></FONT> CONTENT_TYPE;
    }

    public Mapper getMapper(String field) {
        return mappers.get(field);
    }

    protected void putMapper(Mapper mapper) {
        mappers = mappers.copyAndPut(mapper.simpleName(), mapper);
    }

    @Override
    public Iterator&lt;Mapper&gt; iterator() {
        return mappers.values().iterator();
    }

    public String fullPath() {
        return this.fullPath;
    }

    public final Dynamic dynamic() {
        return dynamic;
    }

    @Override
    public ObjectMapper merge(Mapper mergeWith) {
        if (!(mergeWith instanceof ObjectMapper)) {
            throw new IllegalArgumentException(&quot;Can't merge a non object mapping [&quot; + mergeWith.name() + &quot;] with an object mapping [&quot; + name() + &quot;]&quot;);
        }
        ObjectMapper mergeWithObject = (ObjectMapper) mergeWith;
        ObjectMapper merged = clone();
        merged.doMerge(mergeWithObject);
        return merged;
    }

    protected void doMerge(final ObjectMapper mergeWith) {
        if (mergeWith.dynamic != null) {
            this.dynamic = mergeWith.dynamic;
        }

        for (Mapper mergeWithMapper : mergeWith) {
            Mapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());

            Mapper merged;
            if (mergeIntoMapper == null) {
                // no mapping, simply add it
                merged = mergeWithMapper;
            } else {
                // root mappers can only exist here for backcompat, and are merged in Mapping
                merged = mergeIntoMapper.merge(mergeWithMapper);
            }
            putMapper(merged);
        }
    }

    protected Integer position() {
        return position;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        toXContent(builder, params, null);
        return builder;
    }

    public void toXContent(XContentBuilder builder, Params params, ToXContent custom) throws IOException {
        builder.startObject(simpleName());
        if (mappers.isEmpty() &amp;&amp; custom == null) { // only write the object content type if there are no properties, otherwise, it is automatically detected
            builder.field(&quot;type&quot;, CONTENT_TYPE);
        }
        if (position != null) {
            builder.field(&quot;position&quot;, position);
        }
        if (dynamic != null) {
            builder.field(&quot;dynamic&quot;, dynamic.name().toLowerCase(IsoLocale.ROOT));
        }
        if (custom != null) {
            custom.toXContent(builder, params);
        }

        // sort the mappers so we get consistent serialization format
        Mapper[] sortedMappers = mappers.values().stream().toArray(size -&gt; new Mapper[size]);
        Arrays.sort(sortedMappers, new Comparator&lt;Mapper&gt;() {
            @Override
            public int compare(Mapper o1, Mapper o2) {
                return o1.name().compareTo(o2.name());
            }
        });

        int count = 0;
        for (Mapper mapper : sortedMappers) {
            if (!(mapper instanceof MetadataFieldMapper)) {
                if (count++ == 0) {
                    builder.startObject(&quot;properties&quot;);
                }
                mapper.toXContent(builder, params);
            }
        }
        if (count &gt; 0) {
            builder.endObject();
        }
        builder.endObject();
    }
}
</PRE>
</div>
  </div>
</body>
</html>
