<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AliasOrIndex.java &amp; ObjectMapper.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AliasOrIndex.java &amp; ObjectMapper.java
      </h3>
<h1 align="center">
        6.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AliasOrIndex.java (11.917098%)<th>ObjectMapper.java (4.028021%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(99-110)<td><a href="#" name="0">(275-285)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(20-31)<td><a href="#" name="1">(20-31)</a><td align="center"><font color="#c40000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AliasOrIndex.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.cluster.metadata;
2 import org.apache.lucene.util.SetOnce;
3 import javax.annotation.Nullable;
4 import org.elasticsearch.common.Strings;
5 import io.crate.common.collections.Tuple;
6 import java.util.ArrayList;
7 import java.util.Collections;
8 import java.util.Iterator;
9 import java.util.List;
10 import</b></font> java.util.stream.Collectors;
11 public interface AliasOrIndex {
12     boolean isAlias();
13     List&lt;IndexMetadata&gt; getIndices();
14     class Index implements AliasOrIndex {
15         private final IndexMetadata concreteIndex;
16         public Index(IndexMetadata indexMetadata) {
17             this.concreteIndex = indexMetadata;
18         }
19         @Override
20         public boolean isAlias() {
21             return false;
22         }
23         @Override
24         public List&lt;IndexMetadata&gt; getIndices() {
25             return Collections.singletonList(concreteIndex);
26         }
27         public IndexMetadata getIndex() {
28             return concreteIndex;
29         }
30     }
31     class Alias implements AliasOrIndex {
32         private final String aliasName;
33         private final List&lt;IndexMetadata&gt; referenceIndexMetadatas;
34         private SetOnce&lt;IndexMetadata&gt; writeIndex = new SetOnce&lt;&gt;();
35         public Alias(AliasMetadata aliasMetadata, IndexMetadata indexMetadata) {
36             this.aliasName = aliasMetadata.getAlias();
37             this.referenceIndexMetadatas = new ArrayList&lt;&gt;();
38             this.referenceIndexMetadatas.add(indexMetadata);
39         }
40         @Override
41         public boolean isAlias() {
42             return true;
43 <a name="0"></a>        }
44         public String getAliasName() {
45             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return aliasName;
46         }
47         @Override
48         public List&lt;IndexMetadata&gt; getIndices() {
49             return referenceIndexMetadatas;
50         }
51         @Nullable
52         public IndexMetadata getWriteIndex() {
53             return</b></font> writeIndex.get();
54         }
55         public Iterable&lt;Tuple&lt;String, AliasMetadata&gt;&gt; getConcreteIndexAndAliasMetadatas() {
56             return new Iterable&lt;Tuple&lt;String, AliasMetadata&gt;&gt;() {
57                 @Override
58                 public Iterator&lt;Tuple&lt;String, AliasMetadata&gt;&gt; iterator() {
59                     return new Iterator&lt;Tuple&lt;String, AliasMetadata&gt;&gt;() {
60                         int index = 0;
61                         @Override
62                         public boolean hasNext() {
63                             return index &lt; referenceIndexMetadatas.size();
64                         }
65                         @Override
66                         public Tuple&lt;String, AliasMetadata&gt; next() {
67                             IndexMetadata indexMetadata = referenceIndexMetadatas.get(index++);
68                             return new Tuple&lt;&gt;(indexMetadata.getIndex().getName(), indexMetadata.getAliases().get(aliasName));
69                         }
70                         @Override
71                         public void remove() {
72                             throw new UnsupportedOperationException();
73                         }
74                     };
75                 }
76             };
77         }
78         public AliasMetadata getFirstAliasMetadata() {
79             return referenceIndexMetadatas.get(0).getAliases().get(aliasName);
80         }
81         void addIndex(IndexMetadata indexMetadata) {
82             this.referenceIndexMetadatas.add(indexMetadata);
83         }
84         public void computeAndValidateWriteIndex() {
85             List&lt;IndexMetadata&gt; writeIndices = referenceIndexMetadatas.stream()
86                 .filter(idxMeta -&gt; Boolean.TRUE.equals(idxMeta.getAliases().get(aliasName).writeIndex()))
87                 .collect(Collectors.toList());
88             if (writeIndices.isEmpty() &amp;&amp; referenceIndexMetadatas.size() == 1
89                     &amp;&amp; referenceIndexMetadatas.get(0).getAliases().get(aliasName).writeIndex() == null) {
90                 writeIndices.add(referenceIndexMetadatas.get(0));
91             }
92             if (writeIndices.size() == 1) {
93                 writeIndex.set(writeIndices.get(0));
94             } else if (writeIndices.size() &gt; 1) {
95                 List&lt;String&gt; writeIndicesStrings = writeIndices.stream()
96                     .map(i -&gt; i.getIndex().getName()).collect(Collectors.toList());
97                 throw new IllegalStateException("alias [" + aliasName + "] has more than one write index [" +
98                     Strings.collectionToCommaDelimitedString(writeIndicesStrings) + "]");
99             }
100         }
101     }
102 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.index.mapper;
2 import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;
3 import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeIntegerValue;
4 import java.io.IOException;
5 import java.util.ArrayList;
6 import java.util.Arrays;
7 import java.util.Collection;
8 import java.util.Comparator;
9 import java.util.HashMap;
10 import</b></font> java.util.Iterator;
11 import java.util.List;
12 import java.util.Map;
13 import javax.annotation.Nullable;
14 import org.elasticsearch.ElasticsearchParseException;
15 import org.elasticsearch.common.collect.CopyOnWriteHashMap;
16 import org.elasticsearch.common.settings.Settings;
17 import org.elasticsearch.common.time.IsoLocale;
18 import org.elasticsearch.common.xcontent.ToXContent;
19 import org.elasticsearch.common.xcontent.XContentBuilder;
20 public class ObjectMapper extends Mapper implements Cloneable {
21     public static final String CONTENT_TYPE = "object";
22     public static class Defaults {
23         public static final Dynamic DYNAMIC = null;     }
24     public enum Dynamic {
25         TRUE,
26         FALSE,
27         STRICT
28     }
29     public static class Builder&lt;T extends Builder&gt; extends Mapper.Builder&lt;T&gt; {
30         protected Dynamic dynamic = Defaults.DYNAMIC;
31         protected final List&lt;Mapper.Builder&gt; mappersBuilders = new ArrayList&lt;&gt;();
32         private Integer position;
33         @SuppressWarnings("unchecked")
34         public Builder(String name) {
35             super(name);
36             this.builder = (T) this;
37         }
38         public T dynamic(Dynamic dynamic) {
39             this.dynamic = dynamic;
40             return builder;
41         }
42         public T add(Mapper.Builder builder) {
43             mappersBuilders.add(builder);
44             return this.builder;
45         }
46         @Override
47         public ObjectMapper build(BuilderContext context) {
48             context.path().add(name);
49             Map&lt;String, Mapper&gt; mappers = new HashMap&lt;&gt;();
50             for (Mapper.Builder builder : mappersBuilders) {
51                 Mapper mapper = builder.build(context);
52                 Mapper existing = mappers.get(mapper.simpleName());
53                 if (existing != null) {
54                     mapper = existing.merge(mapper);
55                 }
56                 mappers.put(mapper.simpleName(), mapper);
57             }
58             context.path().remove();
59             return createMapper(
60                 name,
61                 position,
62                 context.path().pathAsText(name),
63                 dynamic,
64                 mappers,
65                 context.indexSettings()
66             );
67         }
68         protected ObjectMapper createMapper(String name,
69                                             Integer position,
70                                             String fullPath,
71                                             Dynamic dynamic,
72                                             Map&lt;String, Mapper&gt; mappers,
73                                             @Nullable Settings settings) {
74             return new ObjectMapper(name, position, fullPath, dynamic, mappers, settings);
75         }
76         public T position(int position) {
77             this.position = position;
78             return this.builder;
79         }
80     }
81     public static class TypeParser implements Mapper.TypeParser {
82         @Override
83         @SuppressWarnings("rawtypes")
84         public Mapper.Builder parse(String name, Map&lt;String, Object&gt; node, ParserContext parserContext) throws MapperParsingException {
85             ObjectMapper.Builder builder = new Builder(name);
86             for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = node.entrySet().iterator(); iterator.hasNext();) {
87                 Map.Entry&lt;String, Object&gt; entry = iterator.next();
88                 String fieldName = entry.getKey();
89                 Object fieldNode = entry.getValue();
90                 if (parseObjectOrDocumentTypeProperties(fieldName, fieldNode, parserContext, builder)) {
91                     iterator.remove();
92                 }
93             }
94             return builder;
95         }
96         @SuppressWarnings({"unchecked", "rawtypes"})
97         protected static boolean parseObjectOrDocumentTypeProperties(String fieldName, Object fieldNode, ParserContext parserContext, ObjectMapper.Builder builder) {
98             if (fieldName.equals("position")) {
99                 builder.position(nodeIntegerValue(fieldNode));
100                 return true;
101             } else if (fieldName.equals("dynamic")) {
102                 String value = fieldNode.toString();
103                 if (value.equalsIgnoreCase("strict")) {
104                     builder.dynamic(Dynamic.STRICT);
105                 } else {
106                     boolean dynamic = nodeBooleanValue(fieldNode, fieldName + ".dynamic");
107                     builder.dynamic(dynamic ? Dynamic.TRUE : Dynamic.FALSE);
108                 }
109                 return true;
110             } else if (fieldName.equals("properties")) {
111                 if (fieldNode instanceof Collection &amp;&amp; ((Collection) fieldNode).isEmpty()) {
112                 } else if (!(fieldNode instanceof Map)) {
113                     throw new ElasticsearchParseException("properties must be a map type");
114                 } else {
115                     parseProperties(builder, (Map&lt;String, Object&gt;) fieldNode, parserContext);
116                 }
117                 return true;
118             }
119             return false;
120         }
121         @SuppressWarnings("rawtypes")
122         protected static void parseProperties(ObjectMapper.Builder objBuilder, Map&lt;String, Object&gt; propsNode, ParserContext parserContext) {
123             Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = propsNode.entrySet().iterator();
124             while (iterator.hasNext()) {
125                 Map.Entry&lt;String, Object&gt; entry = iterator.next();
126                 String fieldName = entry.getKey();
127                 boolean isEmptyList = entry.getValue() instanceof List &amp;&amp; ((List&lt;?&gt;) entry.getValue()).isEmpty();
128                 if (entry.getValue() instanceof Map) {
129                     @SuppressWarnings("unchecked")
130                     Map&lt;String, Object&gt; propNode = (Map&lt;String, Object&gt;) entry.getValue();
131                     String type;
132                     Object typeNode = propNode.get("type");
133                     if (typeNode != null) {
134                         type = typeNode.toString();
135                     } else {
136                         if (propNode.get("properties") != null) {
137                             type = ObjectMapper.CONTENT_TYPE;
138                         } else if (propNode.size() == 1 &amp;&amp; propNode.get("enabled") != null) {
139                             type = ObjectMapper.CONTENT_TYPE;
140                         } else {
141                             throw new MapperParsingException("No type specified for field [" + fieldName + "]");
142                         }
143                     }
144                     Mapper.TypeParser typeParser = parserContext.typeParser(type);
145                     if (typeParser == null) {
146                         throw new MapperParsingException("No handler for type [" + type + "] declared on field [" + fieldName + "]");
147                     }
148                     String[] fieldNameParts = fieldName.split("\\.");
149                     String realFieldName = fieldNameParts[fieldNameParts.length - 1];
150                     Mapper.Builder&lt;?&gt; fieldBuilder = typeParser.parse(realFieldName, propNode, parserContext);
151                     for (int i = fieldNameParts.length - 2; i &gt;= 0; --i) {
152                         ObjectMapper.Builder&lt;?&gt; intermediate = new ObjectMapper.Builder&lt;&gt;(fieldNameParts[i]);
153                         intermediate.add(fieldBuilder);
154                         fieldBuilder = intermediate;
155                     }
156                     objBuilder.add(fieldBuilder);
157                     propNode.remove("type");
158                     DocumentMapperParser.checkNoRemainingFields(fieldName, propNode, parserContext.indexVersionCreated());
159                     iterator.remove();
160                 } else if (isEmptyList) {
161                     iterator.remove();
162                 } else {
163                     throw new MapperParsingException("Expected map for property [fields] on field [" + fieldName + "] but got a "
164                             + fieldName.getClass());
165                 }
166             }
167             DocumentMapperParser.checkNoRemainingFields(propsNode, parserContext.indexVersionCreated(),
168                     "DocType mapping definition has unsupported parameters: ");
169         }
170     }
171     private final Integer position;
172     private final String fullPath;
173     private volatile Dynamic dynamic;
174     private volatile CopyOnWriteHashMap&lt;String, Mapper&gt; mappers;
175     ObjectMapper(String name, Integer position,
176                  String fullPath,
177                  Dynamic dynamic,
178                  Map&lt;String, Mapper&gt; mappers,
179                  Settings settings) {
180         super(name);
181         assert settings != null;
182         if (name.isEmpty()) {
183             throw new IllegalArgumentException("name cannot be empty string");
184         }
185         this.fullPath = fullPath;
186         this.position = position;
187         this.dynamic = dynamic;
188         if (mappers == null) {
189             this.mappers = new CopyOnWriteHashMap&lt;&gt;();
190         } else {
191             this.mappers = CopyOnWriteHashMap.copyOf(mappers);
192         }
193     }
194     @Override
195     protected ObjectMapper clone() {
196         ObjectMapper clone;
197         try {
198             clone = (ObjectMapper) super.clone();
199         } catch (CloneNotSupportedException e) {
200             throw new RuntimeException(e);
201         }
202         return clone;
203     }
204     public ObjectMapper mappingUpdate(Mapper mapper) {
205         ObjectMapper mappingUpdate = clone();
206 <a name="0"></a>                mappingUpdate.mappers = new CopyOnWriteHashMap&lt;&gt;();
207         mappingUpdate.putMapper(mapper);
208         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return mappingUpdate;
209     }
210     @Override
211     public String name() {
212         return this.fullPath;
213     }
214     @Override
215     public String typeName() {
216         return</b></font> CONTENT_TYPE;
217     }
218     public Mapper getMapper(String field) {
219         return mappers.get(field);
220     }
221     protected void putMapper(Mapper mapper) {
222         mappers = mappers.copyAndPut(mapper.simpleName(), mapper);
223     }
224     @Override
225     public Iterator&lt;Mapper&gt; iterator() {
226         return mappers.values().iterator();
227     }
228     public String fullPath() {
229         return this.fullPath;
230     }
231     public final Dynamic dynamic() {
232         return dynamic;
233     }
234     @Override
235     public ObjectMapper merge(Mapper mergeWith) {
236         if (!(mergeWith instanceof ObjectMapper)) {
237             throw new IllegalArgumentException("Can't merge a non object mapping [" + mergeWith.name() + "] with an object mapping [" + name() + "]");
238         }
239         ObjectMapper mergeWithObject = (ObjectMapper) mergeWith;
240         ObjectMapper merged = clone();
241         merged.doMerge(mergeWithObject);
242         return merged;
243     }
244     protected void doMerge(final ObjectMapper mergeWith) {
245         if (mergeWith.dynamic != null) {
246             this.dynamic = mergeWith.dynamic;
247         }
248         for (Mapper mergeWithMapper : mergeWith) {
249             Mapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());
250             Mapper merged;
251             if (mergeIntoMapper == null) {
252                 merged = mergeWithMapper;
253             } else {
254                 merged = mergeIntoMapper.merge(mergeWithMapper);
255             }
256             putMapper(merged);
257         }
258     }
259     protected Integer position() {
260         return position;
261     }
262     @Override
263     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
264         toXContent(builder, params, null);
265         return builder;
266     }
267     public void toXContent(XContentBuilder builder, Params params, ToXContent custom) throws IOException {
268         builder.startObject(simpleName());
269         if (mappers.isEmpty() &amp;&amp; custom == null) {             builder.field("type", CONTENT_TYPE);
270         }
271         if (position != null) {
272             builder.field("position", position);
273         }
274         if (dynamic != null) {
275             builder.field("dynamic", dynamic.name().toLowerCase(IsoLocale.ROOT));
276         }
277         if (custom != null) {
278             custom.toXContent(builder, params);
279         }
280         Mapper[] sortedMappers = mappers.values().stream().toArray(size -&gt; new Mapper[size]);
281         Arrays.sort(sortedMappers, new Comparator&lt;Mapper&gt;() {
282             @Override
283             public int compare(Mapper o1, Mapper o2) {
284                 return o1.name().compareTo(o2.name());
285             }
286         });
287         int count = 0;
288         for (Mapper mapper : sortedMappers) {
289             if (!(mapper instanceof MetadataFieldMapper)) {
290                 if (count++ == 0) {
291                     builder.startObject("properties");
292                 }
293                 mapper.toXContent(builder, params);
294             }
295         }
296         if (count &gt; 0) {
297             builder.endObject();
298         }
299         builder.endObject();
300     }
301 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
