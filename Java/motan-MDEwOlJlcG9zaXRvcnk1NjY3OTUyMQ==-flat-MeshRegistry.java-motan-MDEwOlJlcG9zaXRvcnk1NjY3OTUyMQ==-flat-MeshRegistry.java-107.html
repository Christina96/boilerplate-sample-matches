
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistry.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.weibomesh;
2  import com.weibo.api.motan.closable.ShutDownHook;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.DefaultThreadFactory;
6  import com.weibo.api.motan.core.StandardThreadExecutor;
7  import com.weibo.api.motan.core.extension.ExtensionLoader;
8  import com.weibo.api.motan.registry.NotifyListener;
9  import com.weibo.api.motan.registry.Registry;
10  import com.weibo.api.motan.registry.RegistryFactory;
11  import com.weibo.api.motan.registry.support.AbstractRegistry;
12  import com.weibo.api.motan.rpc.URL;
13  import com.weibo.api.motan.transport.Client;
14  import com.weibo.api.motan.transport.EndpointFactory;
15  import com.weibo.api.motan.transport.HeartbeatFactory;
16  import com.weibo.api.motan.util.CollectionUtil;
17  import com.weibo.api.motan.util.LoggerUtil;
18  import com.weibo.api.motan.util.MotanSwitcherUtil;
19  import com.weibo.api.motan.util.UrlUtils;
20  import org.apache.commons.lang3.StringUtils;
21  import java.util.HashMap;
22  import java.util.List;
23  import java.util.Map;
24  import java.util.concurrent.ConcurrentHashMap;
25  import java.util.concurrent.Executors;
26  import java.util.concurrent.ScheduledExecutorService;
27  import java.util.concurrent.TimeUnit;
28  public class MeshRegistry extends AbstractRegistry {
29      public static final String MESH_MPORT_ENV_NAME = &quot;MESH_MPORT&quot;; 
30      public static final String MESH_PORT_ENV_NAME = &quot;MESH_PORT&quot;; 
31      public static final int DEFAULT_MESH_PORT = getIntFromEnv(MESH_PORT_ENV_NAME, 9981);
32      public static final int DEFAULT_MESH_MANAGE_PORT = getIntFromEnv(MESH_MPORT_ENV_NAME, 8002);
33      public static final int DEFAULT_HEALTH_CHECK_RETRY = 2;
34      public static final String MESH_REGISTRY_SWITCHER_NAME = &quot;motan.weibomesh.registry.enable&quot;;
35      public static final String MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME = &quot;motan.weibomesh.registry.healthcheck.enable&quot;;
36      public static final String MESH_PARAM_COPY = &quot;copy&quot;;
37      public static final String MESH_REGISTER_URL = &quot;/registry/register&quot;;
38      public static final String MESH_UNREGISTER_URL = &quot;/registry/unregister&quot;;
39      public static final String MESH_SUBSCRIBE_URL = &quot;/registry/subscribe&quot;;
40      public static final String MESH_PROXY_REGISTRY_KEY = &quot;proxyRegistry&quot;;
41      private static final String DEFAULT_HEALTH_CHECK_TIMEOUT = &quot;3000&quot;;
42      protected static final long DEFAULT_CHECK_PERIOD_MILLISECONDS = 5000;
43      protected static StandardThreadExecutor executor = new StandardThreadExecutor(5, 30, 500,
44              new DefaultThreadFactory(&quot;MeshRegistry&quot;, true));
45      private int meshMPort; 
46      private boolean canBackup = false; 
47      private boolean dynamic = false; 
48      private MeshTransport meshTransport; 
49      private Client heartbeatClient; 
50      private HeartbeatFactory heartbeatFactory;
51      private transient boolean meshAvailable = true;
52      private transient boolean useMesh = true; 
53      private ScheduledExecutorService healthCheckExecutor = Executors.newScheduledThreadPool(1);
54      public void setProxyRegistry(Registry proxyRegistry) {
55          this.proxyRegistry = proxyRegistry;
56          if (this.proxyRegistry != null) {
57              canBackup = true;
58          }
59      }
60      public Registry getProxyRegistry() {
61          return proxyRegistry;
62      }
63      private Registry proxyRegistry;
64      private ConcurrentHashMap&lt;URL, MeshRegistryListener&gt; subscribeUrlMap = new ConcurrentHashMap&lt;&gt;();
65      static {
<span onclick='openModal()' class='match'>66          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_SWITCHER_NAME, true));
67          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true));
</span>68      }
69      public MeshRegistry(URL url, MeshTransport meshTransport) {
70          super(url);
71          this.meshTransport = meshTransport;
72          initMeshInfo();
73          initProxyRegistry();
74          initSwitcher();
75          initHealthCheck(); 
76      }
77      @Override
78      protected void doRegister(URL url) {
79          if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; canBackup) {
80              proxyRegistry.register(url);
81          }
82          executor.execute(() -&gt; {
83              doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_REGISTER_URL, url, 2);
84          });
85      }
86      @Override
87      protected void doUnregister(URL url) {
88          if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; canBackup) {
89              proxyRegistry.unregister(url);
90          }
91          executor.execute(() -&gt; {
92              doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_UNREGISTER_URL, url, 2);
93          });
94      }
95      @Override
96      protected void doSubscribe(URL url, NotifyListener listener) {
97          MeshRegistryListener meshListener = subscribeUrlMap.get(url);
98          if (meshListener == null) {
99              meshListener = subscribeUrlMap.putIfAbsent(url, new MeshRegistryListener(this, url));
100              if (meshListener == null) {
101                  meshListener = subscribeUrlMap.get(url);
102                  MeshRegistryListener finalMeshListener = meshListener;
103                  executor.execute(() -&gt; {
104                      doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_SUBSCRIBE_URL, url, 2);
105                      if (canBackup) {
106                          proxyRegistry.subscribe(url, finalMeshListener);
107                      }
108                  });
109              }
110          }
111          meshListener.addListener(listener);
112          List&lt;URL&gt; urls = doDiscover(url);
113          if (urls != null &amp;&amp; urls.size() &gt; 0) {
114              listener.notify(getUrl(), urls); 
115          }
116      }
117      @Override
118      protected void doUnsubscribe(URL url, NotifyListener listener) {
119          MeshRegistryListener meshListener = subscribeUrlMap.get(url);
120          if (meshListener != null) {
121              meshListener.removeListener(listener);
122          }
123      }
124      @Override
125      protected List&lt;URL&gt; doDiscover(URL url) {
126          MeshRegistryListener listener = subscribeUrlMap.get(url);
127          if (listener == null) {
128              listener = new MeshRegistryListener(this, url);
129          }
130          return listener.getUrls();
131      }
132      @Override
133      protected void doAvailable(URL url) {
134      }
135      @Override
136      protected void doUnavailable(URL url) {
137      }
138      protected void doManageRequestToMesh(String manageUrl, URL url, int retry) {
139          if (meshTransport == null) {
140              LoggerUtil.info(&quot;mesh transport is null in mesh registry: &quot; + getUrl().toSimpleString());
141              return;
142          }
143          if (!dynamic) {
144              LoggerUtil.info(&quot;mesh registry dynamic is close. registry:&quot; + getUrl().toSimpleString());
145              return;
146          }
147          int count = 0;
148          while (count &lt;= retry) {
149              try {
150                  URL toMeshUrl = url.createCopy();
151                  addRegistryParams(toMeshUrl.getParameters(), true, &quot;filter&quot;); 
152                  addRegistryParams(toMeshUrl.getParameters(), false, URLParamType.proxyRegistryUrlString.getName()); 
153                  String meshRegistryName = toMeshUrl.getParameter(URLParamType.meshRegistryName.getName());
154                  if (StringUtils.isNotBlank(meshRegistryName)) { 
155                      toMeshUrl.addParameter(MESH_PROXY_REGISTRY_KEY, meshRegistryName);
156                  }
157                  MeshTransport.ManageResponse response = meshTransport.postManageRequest(manageUrl, Util.UrlToJson(toMeshUrl));
158                  if (response.getStatusCode() == 200) {
159                      return;
160                  }
161                  Thread.sleep(300l);
162              } catch (Exception e) {
163                  LoggerUtil.warn(&quot;doManageRequestToMesh fail. manageUrl:&quot; + manageUrl + &quot;, url:&quot; + url.toSimpleString(), e);
164              }
165              count++;
166          }
167      }
168      private void addRegistryParams(Map&lt;String, String&gt; params, boolean force, String... keys) {
169          for (String key : keys) {
170              String value = getUrl().getParameter(key);
171              if (StringUtils.isNotBlank(value)) {
172                  if (force || StringUtils.isEmpty(params.get(key))) { 
173                      params.put(key, value);
174                  }
175              }
176          }
177      }
178      protected void initMeshInfo() {
179          if (getUrl().getPort() == null || getUrl().getPort() == 0) {
180              getUrl().setPort(DEFAULT_MESH_PORT);
181          }
182          meshMPort = getUrl().getIntParameter(URLParamType.meshMPort.getName(), DEFAULT_MESH_MANAGE_PORT);
183          dynamic = getUrl().getBooleanParameter(URLParamType.dynamic.getName(), false);
184      }
185      protected void initProxyRegistry() {
186          String proxyRegistryString = getUrl().getParameter(URLParamType.proxyRegistryUrlString.getName());
187          if (StringUtils.isNotBlank(proxyRegistryString)) {
188              List&lt;URL&gt; urls = UrlUtils.stringToURLs(proxyRegistryString);
189              if (!CollectionUtil.isEmpty(urls)) {
190                  URL proxyUrl = urls.get(0); 
191                  RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(proxyUrl.getProtocol(), false);
192                  if (registryFactory == null) {
193                      LoggerUtil.warn(&quot;mesh registry can not find proxy registry. proxy registry url:&quot; + proxyUrl.toSimpleString());
194                      return;
195                  }
196                  try {
197                      Registry registry = registryFactory.getRegistry(proxyUrl);
198                      if (registry != null) {
199                          this.proxyRegistry = registry;
200                          canBackup = true;
201                          LoggerUtil.info(&quot;mesh registry add proxy registry. url:&quot; + getUrl().toFullStr());
202                      }
203                  } catch (Exception e) {
204                      LoggerUtil.warn(&quot;mesh registry can not init proxy registry. proxy registry url:&quot; + proxyUrl.toSimpleString());
205                  }
206              }
207          }
208      }
209      protected synchronized void enableMesh(boolean enable) {
210          if (useMesh != enable) {
211              try {
212                  boolean needChange = false;
213                  if (enable &amp;&amp; MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; meshAvailable) {
214                      needChange = true;
215                  } else if (!enable &amp;&amp; (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) || !meshAvailable)) {
216                      needChange = true;
217                  }
218                  if (needChange) {
219                      notifyAll(enable);
220                      useMesh = enable; 
221                      LoggerUtil.info(&quot;mesh registry change useMesh to &quot; + enable + &quot;, registry:&quot; + getUrl().toSimpleString());
222                  }
223              } catch (Exception e) {
224                  LoggerUtil.error(&quot;enable mesh fail. enable:&quot; + enable, e);
225              }
226          }
227      }
228      protected synchronized void enableMeshService(boolean enable) {
229          try {
230              if (enable) { 
231                  for (URL url : getRegisteredServiceUrls()) {
232                      proxyRegistry.unregister(url);
233                  }
234              } else { 
235                  for (URL url : getRegisteredServiceUrls()) {
236                      proxyRegistry.register(url);
237                  }
238              }
239          } catch (Exception e) {
240              LoggerUtil.error(&quot;enable mesh service fail. enable:&quot; + enable, e);
241          }
242      }
243      public boolean isUseMesh() {
244          return useMesh;
245      }
246      public void setUseMesh(boolean value) {
247          useMesh = value;
248      }
249      private void notifyAll(boolean useMesh) {
250          LoggerUtil.info(&quot;MeshRegistry will notify，useMesh:&quot; + useMesh
251                  + &quot;, mesh switcher:&quot; + MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME)
252                  + &quot;, mesh available:&quot; + meshAvailable);
253          for (MeshRegistryListener listener : subscribeUrlMap.values()) {
254              listener.doNotify(useMesh);
255          }
256      }
257      protected void initSwitcher() {
258          MotanSwitcherUtil.registerSwitcherListener(MESH_REGISTRY_SWITCHER_NAME, (key, value) -&gt; {
259              if (!canBackup) { 
260                  LoggerUtil.warn(&quot;mesh registry can not backup, ignore switcher value：&quot; + value + &quot;, url:&quot; + getUrl().toSimpleString());
261                  return;
262              }
263              if (value != null) {
264                  enableMesh(value);
265                  enableMeshService(value);
266              }
267          });
268          MotanSwitcherUtil.registerSwitcherListener(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, (key, value) -&gt; {
269              if (value != null &amp;&amp; !value) { 
270                  meshAvailable = true;
271                  enableMesh(meshAvailable);
272              }
273          });
274      }
275      protected void initHealthCheck() {
276          if (canBackup) {
277              EndpointFactory endpointFactory =
278                      ExtensionLoader.getExtensionLoader(EndpointFactory.class).getExtension(
279                              getUrl().getParameter(URLParamType.endpointFactory.getName(), URLParamType.endpointFactory.getValue()));
280              Map&lt;String, String&gt; meshParams = new HashMap();
281              meshParams.put(URLParamType.codec.getName(), &quot;motan2&quot;);
282              meshParams.put(URLParamType.fusingThreshold.getName(), String.valueOf(Integer.MAX_VALUE));
283              meshParams.put(URLParamType.requestTimeout.getName(), getUrl().getParameter(URLParamType.requestTimeout.getName(), DEFAULT_HEALTH_CHECK_TIMEOUT));
284              URL meshUrl = new URL(MotanConstants.PROTOCOL_MOTAN2, getUrl().getHost(), getUrl().getPort(), &quot;healthCheck&quot;, meshParams);
285              heartbeatClient = endpointFactory.createClient(meshUrl);
286              heartbeatClient.open();
287              heartbeatFactory = ExtensionLoader.getExtensionLoader(HeartbeatFactory.class).getExtension(URLParamType.heartbeatFactory.getValue());
288              long period = getUrl().getLongParameter(URLParamType.registrySessionTimeout.name(), DEFAULT_CHECK_PERIOD_MILLISECONDS);
289              healthCheckExecutor.scheduleWithFixedDelay(this::healthCheck, period, period, TimeUnit.MILLISECONDS);
290              ShutDownHook.registerShutdownHook(() -&gt; {
291                  if (!healthCheckExecutor.isShutdown()) {
292                      healthCheckExecutor.shutdown();
293                  }
294              });
295          }
296      }
297      protected void healthCheck() {
298          if (MotanSwitcherUtil.isOpen(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME)) {
299              boolean health = false;
300              int retry = 0; 
301              if (!meshAvailable) { 
302                  retry = DEFAULT_HEALTH_CHECK_RETRY;
303              }
304              while (!health &amp;&amp; retry &lt;= DEFAULT_HEALTH_CHECK_RETRY) {
305                  try {
306                      heartbeatClient.request(heartbeatFactory.createRequest());
307                      health = true; 
308                  } catch (Exception e) {
309                      LoggerUtil.warn(&quot;mesh health check fail. e:&quot; + e.getMessage());
310                      retry++;
311                  }
312              }
313              meshAvailable = health;
314              if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME)) {
315                  meshAvailable = true;
316              }
317              enableMesh(meshAvailable);
318          }
319      }
320      private static boolean getDefaultSwitcherValue(String name, boolean defaultValue) {
321          boolean value = defaultValue;
322          String envValue = System.getenv(name);
323          if (StringUtils.isNotBlank(envValue)) {
324              value = Boolean.parseBoolean(envValue);
325              LoggerUtil.info(&quot;mesh registry switcher:&quot; + name + &quot; default value will be &quot; + value + &quot;, env value:&quot; + envValue);
326          }
327          return value;
328      }
329      static int getIntFromEnv(String key, int defaultValue) {
330          if (StringUtils.isNotBlank(System.getenv(key))) {
331              try {
332                  int value = Integer.parseInt(System.getenv(key).trim());
333                  if (value &gt; 0) {
334                      LoggerUtil.info(&quot;get value from env. &quot; + key + &quot;:&quot; + value);
335                      return value;
336                  }
337              } catch (NumberFormatException e) {
338                  LoggerUtil.warn(&quot;parse int from env fail. env &quot; + key + &quot;:&quot; + System.getenv(key));
339              }
340          }
341          return defaultValue;
342      }
343  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistry.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.weibomesh;
2  import com.weibo.api.motan.closable.ShutDownHook;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.DefaultThreadFactory;
6  import com.weibo.api.motan.core.StandardThreadExecutor;
7  import com.weibo.api.motan.core.extension.ExtensionLoader;
8  import com.weibo.api.motan.registry.NotifyListener;
9  import com.weibo.api.motan.registry.Registry;
10  import com.weibo.api.motan.registry.RegistryFactory;
11  import com.weibo.api.motan.registry.support.AbstractRegistry;
12  import com.weibo.api.motan.rpc.URL;
13  import com.weibo.api.motan.transport.Client;
14  import com.weibo.api.motan.transport.EndpointFactory;
15  import com.weibo.api.motan.transport.HeartbeatFactory;
16  import com.weibo.api.motan.util.CollectionUtil;
17  import com.weibo.api.motan.util.LoggerUtil;
18  import com.weibo.api.motan.util.MotanSwitcherUtil;
19  import com.weibo.api.motan.util.UrlUtils;
20  import org.apache.commons.lang3.StringUtils;
21  import java.util.HashMap;
22  import java.util.List;
23  import java.util.Map;
24  import java.util.concurrent.ConcurrentHashMap;
25  import java.util.concurrent.Executors;
26  import java.util.concurrent.ScheduledExecutorService;
27  import java.util.concurrent.TimeUnit;
28  public class MeshRegistry extends AbstractRegistry {
29      public static final String MESH_MPORT_ENV_NAME = &quot;MESH_MPORT&quot;; 
30      public static final String MESH_PORT_ENV_NAME = &quot;MESH_PORT&quot;; 
31      public static final int DEFAULT_MESH_PORT = getIntFromEnv(MESH_PORT_ENV_NAME, 9981);
32      public static final int DEFAULT_MESH_MANAGE_PORT = getIntFromEnv(MESH_MPORT_ENV_NAME, 8002);
33      public static final int DEFAULT_HEALTH_CHECK_RETRY = 2;
34      public static final String MESH_REGISTRY_SWITCHER_NAME = &quot;motan.weibomesh.registry.enable&quot;;
35      public static final String MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME = &quot;motan.weibomesh.registry.healthcheck.enable&quot;;
36      public static final String MESH_PARAM_COPY = &quot;copy&quot;;
37      public static final String MESH_REGISTER_URL = &quot;/registry/register&quot;;
38      public static final String MESH_UNREGISTER_URL = &quot;/registry/unregister&quot;;
39      public static final String MESH_SUBSCRIBE_URL = &quot;/registry/subscribe&quot;;
40      public static final String MESH_PROXY_REGISTRY_KEY = &quot;proxyRegistry&quot;;
41      private static final String DEFAULT_HEALTH_CHECK_TIMEOUT = &quot;3000&quot;;
42      protected static final long DEFAULT_CHECK_PERIOD_MILLISECONDS = 5000;
43      protected static StandardThreadExecutor executor = new StandardThreadExecutor(5, 30, 500,
44              new DefaultThreadFactory(&quot;MeshRegistry&quot;, true));
45      private int meshMPort; 
46      private boolean canBackup = false; 
47      private boolean dynamic = false; 
48      private MeshTransport meshTransport; 
49      private Client heartbeatClient; 
50      private HeartbeatFactory heartbeatFactory;
51      private transient boolean meshAvailable = true;
52      private transient boolean useMesh = true; 
53      private ScheduledExecutorService healthCheckExecutor = Executors.newScheduledThreadPool(1);
54      public void setProxyRegistry(Registry proxyRegistry) {
55          this.proxyRegistry = proxyRegistry;
56          if (this.proxyRegistry != null) {
57              canBackup = true;
58          }
59      }
60      public Registry getProxyRegistry() {
61          return proxyRegistry;
62      }
63      private Registry proxyRegistry;
64      private ConcurrentHashMap&lt;URL, MeshRegistryListener&gt; subscribeUrlMap = new ConcurrentHashMap&lt;&gt;();
65      static {
66          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_SWITCHER_NAME, true));
<span onclick='openModal()' class='match'>67          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true));
68      }
</span>69      public MeshRegistry(URL url, MeshTransport meshTransport) {
70          super(url);
71          this.meshTransport = meshTransport;
72          initMeshInfo();
73          initProxyRegistry();
74          initSwitcher();
75          initHealthCheck(); 
76      }
77      @Override
78      protected void doRegister(URL url) {
79          if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; canBackup) {
80              proxyRegistry.register(url);
81          }
82          executor.execute(() -&gt; {
83              doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_REGISTER_URL, url, 2);
84          });
85      }
86      @Override
87      protected void doUnregister(URL url) {
88          if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; canBackup) {
89              proxyRegistry.unregister(url);
90          }
91          executor.execute(() -&gt; {
92              doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_UNREGISTER_URL, url, 2);
93          });
94      }
95      @Override
96      protected void doSubscribe(URL url, NotifyListener listener) {
97          MeshRegistryListener meshListener = subscribeUrlMap.get(url);
98          if (meshListener == null) {
99              meshListener = subscribeUrlMap.putIfAbsent(url, new MeshRegistryListener(this, url));
100              if (meshListener == null) {
101                  meshListener = subscribeUrlMap.get(url);
102                  MeshRegistryListener finalMeshListener = meshListener;
103                  executor.execute(() -&gt; {
104                      doManageRequestToMesh(&quot;http:&amp;bsol;&amp;bsol;&quot; + getUrl().getHost() + &quot;:&quot; + meshMPort + MESH_SUBSCRIBE_URL, url, 2);
105                      if (canBackup) {
106                          proxyRegistry.subscribe(url, finalMeshListener);
107                      }
108                  });
109              }
110          }
111          meshListener.addListener(listener);
112          List&lt;URL&gt; urls = doDiscover(url);
113          if (urls != null &amp;&amp; urls.size() &gt; 0) {
114              listener.notify(getUrl(), urls); 
115          }
116      }
117      @Override
118      protected void doUnsubscribe(URL url, NotifyListener listener) {
119          MeshRegistryListener meshListener = subscribeUrlMap.get(url);
120          if (meshListener != null) {
121              meshListener.removeListener(listener);
122          }
123      }
124      @Override
125      protected List&lt;URL&gt; doDiscover(URL url) {
126          MeshRegistryListener listener = subscribeUrlMap.get(url);
127          if (listener == null) {
128              listener = new MeshRegistryListener(this, url);
129          }
130          return listener.getUrls();
131      }
132      @Override
133      protected void doAvailable(URL url) {
134      }
135      @Override
136      protected void doUnavailable(URL url) {
137      }
138      protected void doManageRequestToMesh(String manageUrl, URL url, int retry) {
139          if (meshTransport == null) {
140              LoggerUtil.info(&quot;mesh transport is null in mesh registry: &quot; + getUrl().toSimpleString());
141              return;
142          }
143          if (!dynamic) {
144              LoggerUtil.info(&quot;mesh registry dynamic is close. registry:&quot; + getUrl().toSimpleString());
145              return;
146          }
147          int count = 0;
148          while (count &lt;= retry) {
149              try {
150                  URL toMeshUrl = url.createCopy();
151                  addRegistryParams(toMeshUrl.getParameters(), true, &quot;filter&quot;); 
152                  addRegistryParams(toMeshUrl.getParameters(), false, URLParamType.proxyRegistryUrlString.getName()); 
153                  String meshRegistryName = toMeshUrl.getParameter(URLParamType.meshRegistryName.getName());
154                  if (StringUtils.isNotBlank(meshRegistryName)) { 
155                      toMeshUrl.addParameter(MESH_PROXY_REGISTRY_KEY, meshRegistryName);
156                  }
157                  MeshTransport.ManageResponse response = meshTransport.postManageRequest(manageUrl, Util.UrlToJson(toMeshUrl));
158                  if (response.getStatusCode() == 200) {
159                      return;
160                  }
161                  Thread.sleep(300l);
162              } catch (Exception e) {
163                  LoggerUtil.warn(&quot;doManageRequestToMesh fail. manageUrl:&quot; + manageUrl + &quot;, url:&quot; + url.toSimpleString(), e);
164              }
165              count++;
166          }
167      }
168      private void addRegistryParams(Map&lt;String, String&gt; params, boolean force, String... keys) {
169          for (String key : keys) {
170              String value = getUrl().getParameter(key);
171              if (StringUtils.isNotBlank(value)) {
172                  if (force || StringUtils.isEmpty(params.get(key))) { 
173                      params.put(key, value);
174                  }
175              }
176          }
177      }
178      protected void initMeshInfo() {
179          if (getUrl().getPort() == null || getUrl().getPort() == 0) {
180              getUrl().setPort(DEFAULT_MESH_PORT);
181          }
182          meshMPort = getUrl().getIntParameter(URLParamType.meshMPort.getName(), DEFAULT_MESH_MANAGE_PORT);
183          dynamic = getUrl().getBooleanParameter(URLParamType.dynamic.getName(), false);
184      }
185      protected void initProxyRegistry() {
186          String proxyRegistryString = getUrl().getParameter(URLParamType.proxyRegistryUrlString.getName());
187          if (StringUtils.isNotBlank(proxyRegistryString)) {
188              List&lt;URL&gt; urls = UrlUtils.stringToURLs(proxyRegistryString);
189              if (!CollectionUtil.isEmpty(urls)) {
190                  URL proxyUrl = urls.get(0); 
191                  RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(proxyUrl.getProtocol(), false);
192                  if (registryFactory == null) {
193                      LoggerUtil.warn(&quot;mesh registry can not find proxy registry. proxy registry url:&quot; + proxyUrl.toSimpleString());
194                      return;
195                  }
196                  try {
197                      Registry registry = registryFactory.getRegistry(proxyUrl);
198                      if (registry != null) {
199                          this.proxyRegistry = registry;
200                          canBackup = true;
201                          LoggerUtil.info(&quot;mesh registry add proxy registry. url:&quot; + getUrl().toFullStr());
202                      }
203                  } catch (Exception e) {
204                      LoggerUtil.warn(&quot;mesh registry can not init proxy registry. proxy registry url:&quot; + proxyUrl.toSimpleString());
205                  }
206              }
207          }
208      }
209      protected synchronized void enableMesh(boolean enable) {
210          if (useMesh != enable) {
211              try {
212                  boolean needChange = false;
213                  if (enable &amp;&amp; MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) &amp;&amp; meshAvailable) {
214                      needChange = true;
215                  } else if (!enable &amp;&amp; (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME) || !meshAvailable)) {
216                      needChange = true;
217                  }
218                  if (needChange) {
219                      notifyAll(enable);
220                      useMesh = enable; 
221                      LoggerUtil.info(&quot;mesh registry change useMesh to &quot; + enable + &quot;, registry:&quot; + getUrl().toSimpleString());
222                  }
223              } catch (Exception e) {
224                  LoggerUtil.error(&quot;enable mesh fail. enable:&quot; + enable, e);
225              }
226          }
227      }
228      protected synchronized void enableMeshService(boolean enable) {
229          try {
230              if (enable) { 
231                  for (URL url : getRegisteredServiceUrls()) {
232                      proxyRegistry.unregister(url);
233                  }
234              } else { 
235                  for (URL url : getRegisteredServiceUrls()) {
236                      proxyRegistry.register(url);
237                  }
238              }
239          } catch (Exception e) {
240              LoggerUtil.error(&quot;enable mesh service fail. enable:&quot; + enable, e);
241          }
242      }
243      public boolean isUseMesh() {
244          return useMesh;
245      }
246      public void setUseMesh(boolean value) {
247          useMesh = value;
248      }
249      private void notifyAll(boolean useMesh) {
250          LoggerUtil.info(&quot;MeshRegistry will notify，useMesh:&quot; + useMesh
251                  + &quot;, mesh switcher:&quot; + MotanSwitcherUtil.isOpen(MESH_REGISTRY_SWITCHER_NAME)
252                  + &quot;, mesh available:&quot; + meshAvailable);
253          for (MeshRegistryListener listener : subscribeUrlMap.values()) {
254              listener.doNotify(useMesh);
255          }
256      }
257      protected void initSwitcher() {
258          MotanSwitcherUtil.registerSwitcherListener(MESH_REGISTRY_SWITCHER_NAME, (key, value) -&gt; {
259              if (!canBackup) { 
260                  LoggerUtil.warn(&quot;mesh registry can not backup, ignore switcher value：&quot; + value + &quot;, url:&quot; + getUrl().toSimpleString());
261                  return;
262              }
263              if (value != null) {
264                  enableMesh(value);
265                  enableMeshService(value);
266              }
267          });
268          MotanSwitcherUtil.registerSwitcherListener(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, (key, value) -&gt; {
269              if (value != null &amp;&amp; !value) { 
270                  meshAvailable = true;
271                  enableMesh(meshAvailable);
272              }
273          });
274      }
275      protected void initHealthCheck() {
276          if (canBackup) {
277              EndpointFactory endpointFactory =
278                      ExtensionLoader.getExtensionLoader(EndpointFactory.class).getExtension(
279                              getUrl().getParameter(URLParamType.endpointFactory.getName(), URLParamType.endpointFactory.getValue()));
280              Map&lt;String, String&gt; meshParams = new HashMap();
281              meshParams.put(URLParamType.codec.getName(), &quot;motan2&quot;);
282              meshParams.put(URLParamType.fusingThreshold.getName(), String.valueOf(Integer.MAX_VALUE));
283              meshParams.put(URLParamType.requestTimeout.getName(), getUrl().getParameter(URLParamType.requestTimeout.getName(), DEFAULT_HEALTH_CHECK_TIMEOUT));
284              URL meshUrl = new URL(MotanConstants.PROTOCOL_MOTAN2, getUrl().getHost(), getUrl().getPort(), &quot;healthCheck&quot;, meshParams);
285              heartbeatClient = endpointFactory.createClient(meshUrl);
286              heartbeatClient.open();
287              heartbeatFactory = ExtensionLoader.getExtensionLoader(HeartbeatFactory.class).getExtension(URLParamType.heartbeatFactory.getValue());
288              long period = getUrl().getLongParameter(URLParamType.registrySessionTimeout.name(), DEFAULT_CHECK_PERIOD_MILLISECONDS);
289              healthCheckExecutor.scheduleWithFixedDelay(this::healthCheck, period, period, TimeUnit.MILLISECONDS);
290              ShutDownHook.registerShutdownHook(() -&gt; {
291                  if (!healthCheckExecutor.isShutdown()) {
292                      healthCheckExecutor.shutdown();
293                  }
294              });
295          }
296      }
297      protected void healthCheck() {
298          if (MotanSwitcherUtil.isOpen(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME)) {
299              boolean health = false;
300              int retry = 0; 
301              if (!meshAvailable) { 
302                  retry = DEFAULT_HEALTH_CHECK_RETRY;
303              }
304              while (!health &amp;&amp; retry &lt;= DEFAULT_HEALTH_CHECK_RETRY) {
305                  try {
306                      heartbeatClient.request(heartbeatFactory.createRequest());
307                      health = true; 
308                  } catch (Exception e) {
309                      LoggerUtil.warn(&quot;mesh health check fail. e:&quot; + e.getMessage());
310                      retry++;
311                  }
312              }
313              meshAvailable = health;
314              if (!MotanSwitcherUtil.isOpen(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME)) {
315                  meshAvailable = true;
316              }
317              enableMesh(meshAvailable);
318          }
319      }
320      private static boolean getDefaultSwitcherValue(String name, boolean defaultValue) {
321          boolean value = defaultValue;
322          String envValue = System.getenv(name);
323          if (StringUtils.isNotBlank(envValue)) {
324              value = Boolean.parseBoolean(envValue);
325              LoggerUtil.info(&quot;mesh registry switcher:&quot; + name + &quot; default value will be &quot; + value + &quot;, env value:&quot; + envValue);
326          }
327          return value;
328      }
329      static int getIntFromEnv(String key, int defaultValue) {
330          if (StringUtils.isNotBlank(System.getenv(key))) {
331              try {
332                  int value = Integer.parseInt(System.getenv(key).trim());
333                  if (value &gt; 0) {
334                      LoggerUtil.info(&quot;get value from env. &quot; + key + &quot;:&quot; + value);
335                      return value;
336                  }
337              } catch (NumberFormatException e) {
338                  LoggerUtil.warn(&quot;parse int from env fail. env &quot; + key + &quot;:&quot; + System.getenv(key));
339              }
340          }
341          return defaultValue;
342      }
343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistry.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MeshRegistry.java</div>
                </div>
                <div class="column column_space"><pre><code>66          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_SWITCHER_NAME, true));
67          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true));
</pre></code></div>
                <div class="column column_space"><pre><code>67          MotanSwitcherUtil.switcherIsOpenWithDefault(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, getDefaultSwitcherValue(MESH_REGISTRY_HEALTH_CHECK_SWITCHER_NAME, true));
68      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    