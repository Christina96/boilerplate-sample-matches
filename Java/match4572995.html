<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for PgProcTable.java &amp; InternalEngineTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for PgProcTable.java &amp; InternalEngineTests.java
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>PgProcTable.java (34.25926%)<th>InternalEngineTests.java (0.6405263%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(59-60)<td><a href="#" name="0">(371-383)</a><td align="center"><font color="#ff0000">35</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(24-54)<td><a href="#" name="1">(180-209)</a><td align="center"><font color="#c40000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(144-149)<td><a href="#" name="2">(3888-3893)</a><td align="center"><font color="#570000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>PgProcTable.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="1"></a>
2 package io.crate.metadata.pgcatalog;
3 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.common.collections.Lists2;
4 import io.crate.metadata.FunctionName;
5 import io.crate.metadata.RelationName;
6 import io.crate.metadata.SystemTable;
7 import io.crate.metadata.functions.Signature;
8 import io.crate.protocols.postgres.types.AnyType;
9 import io.crate.protocols.postgres.types.PGArray;
10 import io.crate.protocols.postgres.types.PGTypes;
11 import io.crate.types.ArrayType;
12 import io.crate.types.DataTypes;
13 import io.crate.types.RowType;
14 import io.crate.types.TypeSignature;
15 import java.util.ArrayList;
16 import java.util.Set;
17 import static io.crate.metadata.FunctionType.AGGREGATE;
18 import static io.crate.metadata.FunctionType.WINDOW;
19 import static io.crate.metadata.pgcatalog.PgProcTable.Entry.pgTypeIdFrom;
20 import static io.crate.types.DataTypes.BOOLEAN;
21 import static io.crate.types.DataTypes.FLOAT;
22 import static io.crate.types.DataTypes.INTEGER;
23 import static io.crate.types.DataTypes.INTEGER_ARRAY;
24 import static io.crate.types.DataTypes.REGPROC;
25 import static io.crate.types.DataTypes.SHORT;
26 import static io.crate.types.DataTypes.STRING;
27 import static io.crate.types.DataTypes.STRING_ARRAY;
28 public class PgProcTable {
29     public static final RelationName IDENT = new RelationName(</b></font>
30         PgCatalogSchemaInfo.NAME,
31 <a name="0"></a>        "pg_proc");
32     public static SystemTable&lt;Entry&gt; create() {
33         return <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>SystemTable.&lt;Entry&gt;builder(IDENT)
34             .add("oid", INTEGER, x -&gt; OidHash.functionOid</b></font>(x.signature))
35             .add("proname", STRING, x -&gt; x.signature.getName().name())
36             .add("pronamespace", INTEGER, x -&gt; OidHash.schemaOid(x.functionName.schema()))
37             .add("proowner", INTEGER, x -&gt; null)
38             .add("prolang", INTEGER, x -&gt; null)
39             .add("procost", FLOAT, x -&gt; null)
40             .add("prorows", FLOAT, x -&gt; !x.returnSetType ? 0f : 1000f)
41             .add("provariadic", INTEGER, x -&gt; {
42                 if (x.signature.getBindingInfo().isVariableArity()) {
43                     var args = x.signature.getArgumentTypes();
44                     return pgTypeIdFrom(args.get(args.size() - 1));
45                 } else {
46                     return 0;
47                 }
48             })
49             .add("protransform", REGPROC, x -&gt; null)
50             .add("proisagg", BOOLEAN, x -&gt; x.signature.getKind() == AGGREGATE)
51             .add("proiswindow", BOOLEAN, x -&gt; x.signature.getKind() == WINDOW)
52             .add("prosecdef", BOOLEAN, x -&gt; null)
53             .add("proleakproof", BOOLEAN, x -&gt; null)
54             .add("proisstrict", BOOLEAN, x -&gt; null)
55             .add("proretset", BOOLEAN, x -&gt; x.returnSetType)
56             .add("provolatile", STRING, x -&gt; null)
57             .add("proparallel", STRING, x -&gt; null)
58             .add("pronargs", SHORT, x -&gt; (short) x.signature.getArgumentTypes().size())
59             .add("pronargdefaults", SHORT, x -&gt; null)
60             .add("prorettype", INTEGER, x -&gt; x.returnTypeId)
61             .add("proargtypes", DataTypes.OIDVECTOR, x -&gt;
62                 Lists2.map(x.signature.getArgumentTypes(), Entry::pgTypeIdFrom))
63             .add("proallargtypes", INTEGER_ARRAY, x -&gt; null)
64             .add("proargmodes", STRING_ARRAY, x -&gt; {
65                 if (!x.signature.getBindingInfo().isVariableArity()) {
66                     return null;
67                 } else {
68                     int numOfArgs = x.signature.getArgumentTypes().size();
69                     var modes = new ArrayList&lt;String&gt;(numOfArgs);
70                     for (int i = 0; i &lt; numOfArgs - 1; i++) {
71                         modes.add("i");
72                     }
73                     modes.add("v");
74                     return modes;
75                 }
76             })
77             .add("proargnames", STRING_ARRAY, x -&gt; null)
78             .startObjectArray("proargdefaults", x -&gt; null).endObjectArray()
79             .add("protrftypes", INTEGER_ARRAY, x -&gt; null)
80             .add("prosrc", STRING, x -&gt; x.functionName.name())
81             .add("probin", STRING, x -&gt; null)
82             .add("proconfig", STRING_ARRAY, x -&gt; null)
83             .add("proacl", STRING_ARRAY, x -&gt; null)
84             .build();
85     }
86     public static final class Entry {
87         private static final Set&lt;String&gt; SET_TYPES = Set.of(
88             ArrayType.NAME, RowType.NAME);
89         public static Entry of(Signature signature) {
90             return new Entry(
91                 signature.getName(),
92                 signature
93             );
94         }
95         final Signature signature;
96         final FunctionName functionName;
97         final int returnTypeId;
98         final boolean returnSetType;
99         private Entry(FunctionName functionName, Signature signature) {
100             this.signature = signature;
101             this.functionName = functionName;
102             var returnTypeSignature = signature.getReturnType();
103             this.returnTypeId = pgTypeIdFrom(returnTypeSignature);
104             this.returnSetType = SET_TYPES.contains(returnTypeSignature.getBaseTypeName());
105         }
106 <a name="2"></a>        static int pgTypeIdFrom(TypeSignature typeSignature) {
107             var crateDataType = DataTypes.ofNameOrNull(typeSignature.getBaseTypeName());
108             if (crateDataType == null) {
109                 if (ArrayType.NAME.equalsIgnoreCase(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typeSignature.getBaseTypeName())) {
110                     return PGArray.ANY_ARRAY.oid();
111                 } else {
112                     return AnyType.INSTANCE.oid();
113                 }
114             }</b></font> else {
115                 return PGTypes.get(crateDataType).oid();
116             }
117         }
118     }
119 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>InternalEngineTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.index.engine;
2 import static java.util.Collections.shuffle;
3 import static org.elasticsearch.index.engine.Engine.Operation.Origin.LOCAL_RESET;
4 import static org.elasticsearch.index.engine.Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY;
5 import static org.elasticsearch.index.engine.Engine.Operation.Origin.PEER_RECOVERY;
6 import static org.elasticsearch.index.engine.Engine.Operation.Origin.PRIMARY;
7 import static org.elasticsearch.index.engine.Engine.Operation.Origin.REPLICA;
8 import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;
9 import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_PRIMARY_TERM;
10 import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_SEQ_NO;
11 import static org.elasticsearch.index.translog.TranslogDeletionPolicies.createTranslogDeletionPolicy;
12 import static org.hamcrest.CoreMatchers.instanceOf;
13 import static org.hamcrest.CoreMatchers.is;
14 import static org.hamcrest.Matchers.contains;
15 import static org.hamcrest.Matchers.containsInAnyOrder;
16 import static org.hamcrest.Matchers.containsString;
17 import static org.hamcrest.Matchers.empty;
18 import static org.hamcrest.Matchers.equalTo;
19 import static org.hamcrest.Matchers.greaterThan;
20 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
21 import static org.hamcrest.Matchers.hasItem;
22 import static org.hamcrest.Matchers.hasKey;
23 import static org.hamcrest.Matchers.hasSize;
24 import static org.hamcrest.Matchers.isIn;
25 import static org.hamcrest.Matchers.lessThanOrEqualTo;
26 import static org.hamcrest.Matchers.not;
27 import static org.hamcrest.Matchers.notNullValue;
28 import static org.hamcrest.Matchers.nullValue;
29 import static org.hamcrest.Matchers.sameInstance;
30 import static org.mockito.Mockito.spy;
31 import static org.mockito.Mockito.when;
32 import java.io.Closeable;
33 import java.io.IOException;
34 import java.io.UncheckedIOException;
35 import java.nio.charset.Charset;
36 import java.nio.file.Files;
37 import java.nio.file.Path;
38 import java.util.ArrayList;
39 import java.util.Arrays;
40 import java.util.Base64;
41 import java.util.Collections;
42 import java.util.Comparator;
43 import java.util.HashMap;
44 import java.util.HashSet;
45 import java.util.Iterator;
46 import java.util.LinkedHashMap;
47 import java.util.List;
48 import java.util.Map;
49 import java.util.Queue;
50 import java.util.Set;
51 import java.util.concurrent.BrokenBarrierException;
52 import java.util.concurrent.CountDownLatch;
53 import java.util.concurrent.CyclicBarrier;
54 import java.util.concurrent.Phaser;
55 import java.util.concurrent.TimeUnit;
56 import java.util.concurrent.atomic.AtomicBoolean;
57 import java.util.concurrent.atomic.AtomicInteger;
58 import java.util.concurrent.atomic.AtomicLong;
59 import java.util.concurrent.atomic.AtomicReference;
60 import java.util.function.BiFunction;
61 import java.util.function.Function;
62 import java.util.function.IntSupplier;
63 import java.util.function.LongSupplier;
64 import java.util.function.Supplier;
65 import java.util.function.ToLongBiFunction;
66 import java.util.stream.Collectors;
67 import java.util.stream.LongStream;
68 import com.carrotsearch.randomizedtesting.generators.RandomNumbers;
69 import org.apache.logging.log4j.Level;
70 import org.apache.logging.log4j.LogManager;
71 import org.apache.logging.log4j.Logger;
72 import org.apache.logging.log4j.core.LogEvent;
73 import org.apache.logging.log4j.core.appender.AbstractAppender;
74 import org.apache.logging.log4j.core.filter.RegexFilter;
75 import org.apache.lucene.codecs.lucene87.Lucene87StoredFieldsFormat;
76 import org.apache.lucene.document.Field;
77 import org.apache.lucene.document.LongPoint;
78 import org.apache.lucene.document.NumericDocValuesField;
79 import org.apache.lucene.document.StoredField;
80 import org.apache.lucene.document.TextField;
81 import org.apache.lucene.index.DirectoryReader;
82 import org.apache.lucene.index.IndexCommit;
83 import org.apache.lucene.index.IndexReader;
84 import org.apache.lucene.index.IndexWriter;
85 import org.apache.lucene.index.IndexWriterConfig;
86 import org.apache.lucene.index.IndexableField;
87 import org.apache.lucene.index.LeafReader;
88 import org.apache.lucene.index.LeafReaderContext;
89 import org.apache.lucene.index.LiveIndexWriterConfig;
90 import org.apache.lucene.index.LogByteSizeMergePolicy;
91 import org.apache.lucene.index.LogDocMergePolicy;
92 import org.apache.lucene.index.MergePolicy;
93 import org.apache.lucene.index.NoMergePolicy;
94 import org.apache.lucene.index.NumericDocValues;
95 import org.apache.lucene.index.PointValues;
96 import org.apache.lucene.index.SegmentInfos;
97 import org.apache.lucene.index.SoftDeletesRetentionMergePolicy;
98 import org.apache.lucene.index.Term;
99 import org.apache.lucene.index.Terms;
100 import org.apache.lucene.index.TermsEnum;
101 import org.apache.lucene.index.TieredMergePolicy;
102 import org.apache.lucene.search.IndexSearcher;
103 import org.apache.lucene.search.MatchAllDocsQuery;
104 import org.apache.lucene.search.ReferenceManager;
105 import org.apache.lucene.search.TermQuery;
106 import org.apache.lucene.search.TopDocs;
107 import org.apache.lucene.search.TotalHitCountCollector;
108 import org.apache.lucene.store.AlreadyClosedException;
109 import org.apache.lucene.store.Directory;
110 import org.apache.lucene.store.Lock;
111 import org.apache.lucene.store.MockDirectoryWrapper;
112 import org.apache.lucene.util.Bits;
113 import org.apache.lucene.util.BytesRef;
114 import org.apache.lucene.util.FixedBitSet;
115 import org.elasticsearch.ElasticsearchException;
116 import org.elasticsearch.Version;
117 import org.elasticsearch.action.ActionListener;
118 import org.elasticsearch.action.support.TransportActions;
119 import org.elasticsearch.cluster.metadata.IndexMetadata;
120 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
121 import org.elasticsearch.cluster.routing.ShardRouting;
122 import org.elasticsearch.cluster.routing.ShardRoutingState;
123 import org.elasticsearch.cluster.routing.TestShardRouting;
124 import org.elasticsearch.common.CheckedBiConsumer;
125 import org.elasticsearch.common.CheckedRunnable;
126 import org.elasticsearch.common.Randomness;
127 import org.elasticsearch.common.Strings;
128 import org.elasticsearch.common.TriFunction;
129 import org.elasticsearch.common.UUIDs;
130 import org.elasticsearch.common.bytes.BytesArray;
131 import org.elasticsearch.common.bytes.BytesReference;
132 import org.elasticsearch.common.logging.Loggers;
133 import org.elasticsearch.common.lucene.Lucene;
134 import org.elasticsearch.common.lucene.index.ElasticsearchDirectoryReader;
135 import org.elasticsearch.common.lucene.index.SequentialStoredFieldsLeafReader;
136 import org.elasticsearch.common.lucene.uid.Versions;
137 import org.elasticsearch.common.lucene.uid.VersionsAndSeqNoResolver;
138 import org.elasticsearch.common.lucene.uid.VersionsAndSeqNoResolver.DocIdAndSeqNo;
139 import org.elasticsearch.common.settings.Settings;
140 import org.elasticsearch.common.unit.ByteSizeValue;
141 import org.elasticsearch.common.util.BigArrays;
142 import org.elasticsearch.common.util.concurrent.AbstractRunnable;
143 import org.elasticsearch.common.util.concurrent.ConcurrentCollections;
144 import org.elasticsearch.index.IndexSettings;
145 import org.elasticsearch.index.VersionType;
146 import org.elasticsearch.index.codec.CodecService;
147 import org.elasticsearch.index.engine.Engine.Searcher;
148 import org.elasticsearch.index.fieldvisitor.FieldsVisitor;
149 import org.elasticsearch.index.mapper.IdFieldMapper;
150 import org.elasticsearch.index.mapper.MapperService;
151 import org.elasticsearch.index.mapper.ParseContext;
152 import org.elasticsearch.index.mapper.ParseContext.Document;
153 import org.elasticsearch.index.mapper.ParsedDocument;
154 <a name="1"></a>import org.elasticsearch.index.mapper.SeqNoFieldMapper;
155 import org.elasticsearch.index.mapper.SourceFieldMapper;
156 import org.elasticsearch.index.mapper.Uid;
157 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.index.mapper.VersionFieldMapper;
158 import org.elasticsearch.index.seqno.LocalCheckpointTracker;
159 import org.elasticsearch.index.seqno.ReplicationTracker;
160 import org.elasticsearch.index.seqno.RetentionLease;
161 import org.elasticsearch.index.seqno.RetentionLeases;
162 import org.elasticsearch.index.seqno.SeqNoStats;
163 import org.elasticsearch.index.seqno.SequenceNumbers;
164 import org.elasticsearch.index.shard.ShardId;
165 import org.elasticsearch.index.shard.ShardUtils;
166 import org.elasticsearch.index.store.Store;
167 import org.elasticsearch.index.translog.SnapshotMatchers;
168 import org.elasticsearch.index.translog.TestTranslog;
169 import org.elasticsearch.index.translog.Translog;
170 import org.elasticsearch.index.translog.TranslogConfig;
171 import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
172 import org.elasticsearch.test.IndexSettingsModule;
173 import org.elasticsearch.test.VersionUtils;
174 import org.elasticsearch.threadpool.ThreadPool;
175 import org.hamcrest.Matcher;
176 import org.hamcrest.MatcherAssert;
177 import org.hamcrest.Matchers;
178 import org.junit.Test;
179 import io.crate.common.collections.Tuple;
180 import io.crate.common.io.IOUtils;
181 import io.crate.common.unit.TimeValue;
182 public class InternalEngineTests extends EngineTestCase {
183     static final long UNSET_AUTO_GENERATED_TIMESTAMP = -1L</b></font>;
184     @Test
185     public void testVersionMapAfterAutoIDDocument() throws IOException {
186         engine.refresh("warm_up");
187         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField("test"),
188                                                 new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
189         Engine.Index operation = randomBoolean() ?
190             appendOnlyPrimary(doc, false, 1)
191             : appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
192         engine.index(operation);
193         assertFalse(engine.isSafeAccessRequired());
194         doc = testParsedDocument("1", null, testDocumentWithTextField("updated"),
195                                  new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
196         Engine.Index update = indexForDoc(doc);
197         engine.index(update);
198         assertTrue(engine.isSafeAccessRequired());
199         assertThat(engine.getVersionMap().values(), hasSize(1));
200         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
201             assertEquals(0, searcher.getIndexReader().numDocs());
202         }
203         try (Engine.Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
204             assertEquals(1, searcher.getIndexReader().numDocs());
205             TopDocs search = searcher.search(new MatchAllDocsQuery(), 1);
206             org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[0].doc);
207             assertEquals("test", luceneDoc.get("value"));
208         }
209         engine.refresh("test");
210         if (randomBoolean()) {             engine.refresh("test");
211         }
212         assertTrue("safe access should be required we carried it over", engine.isSafeAccessRequired());
213         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
214             assertEquals(1, searcher.getIndexReader().numDocs());
215             TopDocs search = searcher.search(new MatchAllDocsQuery(), 1);
216             org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[0].doc);
217             assertEquals("updated", luceneDoc.get("value"));
218         }
219         doc = testParsedDocument("2", null, testDocumentWithTextField("test"),
220                                  new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
221         operation = randomBoolean() ?
222             appendOnlyPrimary(doc, false, 1)
223             : appendOnlyReplica(doc, false, 1, generateNewSeqNo(engine));
224         engine.index(operation);
225         assertTrue("safe access should be required", engine.isSafeAccessRequired());
226         assertThat(engine.getVersionMap().values(), hasSize(1));         engine.refresh("test");
227         if (randomBoolean()) {             engine.refresh("test");
228         }
229         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
230             assertEquals(2, searcher.getIndexReader().numDocs());
231         }
232         if (operation.origin() == PRIMARY) {
233             assertFalse("safe access should NOT be required last indexing round was only append only", engine.isSafeAccessRequired());
234         }
235         engine.delete(new Engine.Delete(
236             operation.id(),
237             operation.uid(),
238             UNASSIGNED_SEQ_NO,
239             primaryTerm.get(),
240             Versions.MATCH_ANY,
241             VersionType.INTERNAL,
242             Engine.Operation.Origin.PRIMARY,
243             System.nanoTime(),
244             UNASSIGNED_SEQ_NO,
245             0
246         ));
247         assertTrue("safe access should be required", engine.isSafeAccessRequired());
248         engine.refresh("test");
249         assertTrue("safe access should be required", engine.isSafeAccessRequired());
250         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
251             assertEquals(1, searcher.getIndexReader().numDocs());
252         }
253     }
254     @Test
255     public void testSegmentsWithoutSoftDeletes() throws Exception {
256         Settings settings = Settings.builder()
257             .put(defaultSettings.getSettings())
258             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false).build();
259         IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
260             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
261         try (Store store = createStore();
262              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
263             List&lt;Segment&gt; segments = engine.segments(false);
264             assertThat(segments.isEmpty(), equalTo(true));
265             ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
266             Engine.Index first = indexForDoc(doc);
267             Engine.IndexResult firstResult = engine.index(first);
268             ParsedDocument doc2 = testParsedDocument("2", null, testDocumentWithTextField(), B_2, null);
269             Engine.Index second = indexForDoc(doc2);
270             Engine.IndexResult secondResult = engine.index(second);
271             assertThat(secondResult.getTranslogLocation(), greaterThan(firstResult.getTranslogLocation()));
272             engine.refresh("test");
273             segments = engine.segments(false);
274             assertThat(segments.size(), equalTo(1));
275             assertThat(segments.get(0).isCommitted(), equalTo(false));
276             assertThat(segments.get(0).isSearch(), equalTo(true));
277             assertThat(segments.get(0).getNumDocs(), equalTo(2));
278             assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
279             assertThat(segments.get(0).isCompound(), equalTo(true));
280             assertThat(segments.get(0).ramTree, nullValue());
281             assertThat(segments.get(0).getAttributes().keySet(), Matchers.contains(Lucene87StoredFieldsFormat.MODE_KEY));
282             engine.flush();
283             segments = engine.segments(false);
284             assertThat(segments.size(), equalTo(1));
285             assertThat(segments.get(0).isCommitted(), equalTo(true));
286             assertThat(segments.get(0).isSearch(), equalTo(true));
287             assertThat(segments.get(0).getNumDocs(), equalTo(2));
288             assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
289             assertThat(segments.get(0).isCompound(), equalTo(true));
290             ParsedDocument doc3 = testParsedDocument("3", null, testDocumentWithTextField(), B_3, null);
291             engine.index(indexForDoc(doc3));
292             engine.refresh("test");
293             segments = engine.segments(false);
294             assertThat(segments.size(), equalTo(2));
295             assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
296             assertThat(segments.get(0).isCommitted(), equalTo(true));
297             assertThat(segments.get(0).isSearch(), equalTo(true));
298             assertThat(segments.get(0).getNumDocs(), equalTo(2));
299             assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
300             assertThat(segments.get(0).isCompound(), equalTo(true));
301             assertThat(segments.get(1).isCommitted(), equalTo(false));
302             assertThat(segments.get(1).isSearch(), equalTo(true));
303             assertThat(segments.get(1).getNumDocs(), equalTo(1));
304             assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
305             assertThat(segments.get(1).isCompound(), equalTo(true));
306             engine.delete(new Engine.Delete(
307                 "1",
308                 newUid(doc),
309                 UNASSIGNED_SEQ_NO,
310                 primaryTerm.get(),
311                 Versions.MATCH_ANY,
312                 VersionType.INTERNAL,
313                 Engine.Operation.Origin.PRIMARY,
314                 System.nanoTime(),
315                 UNASSIGNED_SEQ_NO,
316                 0
317             ));
318             engine.refresh("test");
319             segments = engine.segments(false);
320             assertThat(segments.size(), equalTo(2));
321 <a name="0"></a>            assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
322             assertThat(segments.get(0).isCommitted(), equalTo(true));
323             assertThat(segments.get(0).isSearch(), equalTo(true));
324             assertThat(segments.get(0).getNumDocs(), <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>equalTo(1));
325             assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
326             assertThat(segments.get(0).isCompound(), equalTo(true));
327             assertThat(segments.get(1).isCommitted(), equalTo(false));
328             assertThat(segments.get(1).isSearch(), equalTo(true));
329             assertThat(segments.get(1).getNumDocs(), equalTo(1));
330             assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
331             assertThat(segments.get(1).isCompound(), equalTo(true));
332             engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
333                                      indexSettings.getSoftDeleteRetentionOperations());
334             ParsedDocument doc4 = testParsedDocument</b></font>("4", null, testDocumentWithTextField(), B_3, null);
335             engine.index(indexForDoc(doc4));
336             engine.refresh("test");
337             segments = engine.segments(false);
338             assertThat(segments.size(), equalTo(3));
339             assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
340             assertThat(segments.get(0).isCommitted(), equalTo(true));
341             assertThat(segments.get(0).isSearch(), equalTo(true));
342             assertThat(segments.get(0).getNumDocs(), equalTo(1));
343             assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
344             assertThat(segments.get(0).isCompound(), equalTo(true));
345             assertThat(segments.get(1).isCommitted(), equalTo(false));
346             assertThat(segments.get(1).isSearch(), equalTo(true));
347             assertThat(segments.get(1).getNumDocs(), equalTo(1));
348             assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
349             assertThat(segments.get(1).isCompound(), equalTo(true));
350             assertThat(segments.get(2).isCommitted(), equalTo(false));
351             assertThat(segments.get(2).isSearch(), equalTo(true));
352             assertThat(segments.get(2).getNumDocs(), equalTo(1));
353             assertThat(segments.get(2).getDeletedDocs(), equalTo(0));
354             assertThat(segments.get(2).isCompound(), equalTo(true));
355             ParsedDocument doc5 = testParsedDocument("5", null, testDocumentWithTextField(), B_3, null);
356             engine.index(indexForDoc(doc5));
357             engine.refresh("test", Engine.SearcherScope.INTERNAL, true);
358             segments = engine.segments(false);
359             assertThat(segments.size(), equalTo(4));
360             assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
361             assertThat(segments.get(0).isCommitted(), equalTo(true));
362             assertThat(segments.get(0).isSearch(), equalTo(true));
363             assertThat(segments.get(0).getNumDocs(), equalTo(1));
364             assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
365             assertThat(segments.get(0).isCompound(), equalTo(true));
366             assertThat(segments.get(1).isCommitted(), equalTo(false));
367             assertThat(segments.get(1).isSearch(), equalTo(true));
368             assertThat(segments.get(1).getNumDocs(), equalTo(1));
369             assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
370             assertThat(segments.get(1).isCompound(), equalTo(true));
371             assertThat(segments.get(2).isCommitted(), equalTo(false));
372             assertThat(segments.get(2).isSearch(), equalTo(true));
373             assertThat(segments.get(2).getNumDocs(), equalTo(1));
374             assertThat(segments.get(2).getDeletedDocs(), equalTo(0));
375             assertThat(segments.get(2).isCompound(), equalTo(true));
376             assertThat(segments.get(3).isCommitted(), equalTo(false));
377             assertThat(segments.get(3).isSearch(), equalTo(false));
378             assertThat(segments.get(3).getNumDocs(), equalTo(1));
379             assertThat(segments.get(3).getDeletedDocs(), equalTo(0));
380             assertThat(segments.get(3).isCompound(), equalTo(true));
381             engine.refresh("test");
382             segments = engine.segments(false);
383             assertThat(segments.size(), equalTo(4));
384             assertThat(segments.get(0).getGeneration() &lt; segments.get(1).getGeneration(), equalTo(true));
385             assertThat(segments.get(0).isCommitted(), equalTo(true));
386             assertThat(segments.get(0).isSearch(), equalTo(true));
387             assertThat(segments.get(0).getNumDocs(), equalTo(1));
388             assertThat(segments.get(0).getDeletedDocs(), equalTo(1));
389             assertThat(segments.get(0).isCompound(), equalTo(true));
390             assertThat(segments.get(1).isCommitted(), equalTo(false));
391             assertThat(segments.get(1).isSearch(), equalTo(true));
392             assertThat(segments.get(1).getNumDocs(), equalTo(1));
393             assertThat(segments.get(1).getDeletedDocs(), equalTo(0));
394             assertThat(segments.get(1).isCompound(), equalTo(true));
395             assertThat(segments.get(2).isCommitted(), equalTo(false));
396             assertThat(segments.get(2).isSearch(), equalTo(true));
397             assertThat(segments.get(2).getNumDocs(), equalTo(1));
398             assertThat(segments.get(2).getDeletedDocs(), equalTo(0));
399             assertThat(segments.get(2).isCompound(), equalTo(true));
400             assertThat(segments.get(3).isCommitted(), equalTo(false));
401             assertThat(segments.get(3).isSearch(), equalTo(true));
402             assertThat(segments.get(3).getNumDocs(), equalTo(1));
403             assertThat(segments.get(3).getDeletedDocs(), equalTo(0));
404             assertThat(segments.get(3).isCompound(), equalTo(true));
405         }
406     }
407     @Test
408     public void testVerboseSegments() throws Exception {
409         try (Store store = createStore();
410              Engine engine = createEngine(defaultSettings, store, createTempDir(), NoMergePolicy.INSTANCE)) {
411             List&lt;Segment&gt; segments = engine.segments(true);
412             assertThat(segments.isEmpty(), equalTo(true));
413             ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
414             engine.index(indexForDoc(doc));
415             engine.refresh("test");
416             segments = engine.segments(true);
417             assertThat(segments.size(), equalTo(1));
418             assertThat(segments.get(0).ramTree, notNullValue());
419             ParsedDocument doc2 = testParsedDocument("2", null, testDocumentWithTextField(), B_2, null);
420             engine.index(indexForDoc(doc2));
421             engine.refresh("test");
422             ParsedDocument doc3 = testParsedDocument("3", null, testDocumentWithTextField(), B_3, null);
423             engine.index(indexForDoc(doc3));
424             engine.refresh("test");
425             segments = engine.segments(true);
426             assertThat(segments.size(), equalTo(3));
427             assertThat(segments.get(0).ramTree, notNullValue());
428             assertThat(segments.get(1).ramTree, notNullValue());
429             assertThat(segments.get(2).ramTree, notNullValue());
430         }
431     }
432     @Test
433     public void testSegmentsWithMergeFlag() throws Exception {
434         try (Store store = createStore();
435              Engine engine = createEngine(defaultSettings, store, createTempDir(), new TieredMergePolicy())) {
436             ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
437             Engine.Index index = indexForDoc(doc);
438             engine.index(index);
439             engine.flush();
440             assertThat(engine.segments(false).size(), equalTo(1));
441             index = indexForDoc(testParsedDocument("2", null, testDocument(), B_1, null));
442             engine.index(index);
443             engine.flush();
444             List&lt;Segment&gt; segments = engine.segments(false);
445             assertThat(segments.size(), equalTo(2));
446             for (Segment segment : segments) {
447                 assertThat(segment.getMergeId(), nullValue());
448             }
449             index = indexForDoc(testParsedDocument("3", null, testDocument(), B_1, null));
450             engine.index(index);
451             engine.flush();
452             segments = engine.segments(false);
453             assertThat(segments.size(), equalTo(3));
454             for (Segment segment : segments) {
455                 assertThat(segment.getMergeId(), nullValue());
456             }
457             index = indexForDoc(doc);
458             engine.index(index);
459             engine.flush();
460             final long gen1 = store.readLastCommittedSegmentsInfo().getGeneration();
461             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
462             for (Segment segment : engine.segments(false)) {
463                 assertThat(segment.getMergeId(), nullValue());
464             }
465             assertTrue(store.readLastCommittedSegmentsInfo().getGeneration() &gt; gen1);
466             final boolean flush = randomBoolean();
467             final long gen2 = store.readLastCommittedSegmentsInfo().getGeneration();
468             engine.forceMerge(flush, 1, false, false, false, UUIDs.randomBase64UUID());
469             for (Segment segment : engine.segments(false)) {
470                 assertThat(segment.getMergeId(), nullValue());
471             }
472             if (flush) {
473                 assertEquals(gen2, store.readLastCommittedSegmentsInfo().getLastGeneration());
474             }
475         }
476     }
477     @Test
478     public void testSegmentsWithSoftDeletes() throws Exception {
479         Settings.Builder settings = Settings.builder()
480             .put(defaultSettings.getSettings())
481             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true);
482         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
483         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
484         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
485         try (Store store = createStore();
486              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null,
487                                                          null, globalCheckpoint::get))) {
488             assertThat(engine.segments(false), empty());
489             int numDocsFirstSegment = randomIntBetween(5, 50);
490             Set&lt;String&gt; liveDocsFirstSegment = new HashSet&lt;&gt;();
491             for (int i = 0; i &lt; numDocsFirstSegment; i++) {
492                 String id = Integer.toString(i);
493                 ParsedDocument doc = testParsedDocument(id, null, testDocument(), B_1, null);
494                 engine.index(indexForDoc(doc));
495                 liveDocsFirstSegment.add(id);
496             }
497             engine.refresh("test");
498             List&lt;Segment&gt; segments = engine.segments(randomBoolean());
499             assertThat(segments, hasSize(1));
500             assertThat(segments.get(0).getNumDocs(), equalTo(liveDocsFirstSegment.size()));
501             assertThat(segments.get(0).getDeletedDocs(), equalTo(0));
502             assertFalse(segments.get(0).committed);
503             int deletes = 0;
504             int updates = 0;
505             int appends = 0;
506             int iterations = scaledRandomIntBetween(1, 50);
507             for (int i = 0; i &lt; iterations &amp;&amp; liveDocsFirstSegment.isEmpty() == false; i++) {
508                 String idToUpdate = randomFrom(liveDocsFirstSegment);
509                 liveDocsFirstSegment.remove(idToUpdate);
510                 ParsedDocument doc = testParsedDocument(idToUpdate, null, testDocument(), B_1, null);
511                 if (randomBoolean()) {
512                     engine.delete(new Engine.Delete(doc.id(), newUid(doc), primaryTerm.get()));
513                     deletes++;
514                 } else {
515                     engine.index(indexForDoc(doc));
516                     updates++;
517                 }
518                 if (randomBoolean()) {
519                     engine.index(indexForDoc(testParsedDocument(UUIDs.randomBase64UUID(), null, testDocument(), B_1, null)));
520                     appends++;
521                 }
522             }
523             boolean committed = randomBoolean();
524             if (committed) {
525                 engine.flush();
526             }
527             engine.refresh("test");
528             segments = engine.segments(randomBoolean());
529             assertThat(segments, hasSize(2));
530             assertThat(segments.get(0).getNumDocs(), equalTo(liveDocsFirstSegment.size()));
531             assertThat(segments.get(0).getDeletedDocs(), equalTo(updates + deletes));
532             assertThat(segments.get(0).committed, equalTo(committed));
533             assertThat(segments.get(1).getNumDocs(), equalTo(updates + appends));
534             assertThat(segments.get(1).getDeletedDocs(), equalTo(deletes));             assertThat(segments.get(1).committed, equalTo(committed));
535         }
536     }
537     @Test
538     public void testCommitStats() throws IOException {
539         final AtomicLong maxSeqNo = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
540         final AtomicLong localCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
541         final AtomicLong globalCheckpoint = new AtomicLong(UNASSIGNED_SEQ_NO);
542         try (
543             Store store = createStore();
544             InternalEngine engine = createEngine(store, createTempDir(), (maxSeq, localCP) -&gt; new LocalCheckpointTracker(
545                                                      maxSeq,
546                                                      localCP) {
547                                                      @Override
548                                                      public long getMaxSeqNo() {
549                                                          return maxSeqNo.get();
550                                                      }
551                                                      @Override
552                                                      public long getProcessedCheckpoint() {
553                                                          return localCheckpoint.get();
554                                                      }
555                     }
556             )) {
557             CommitStats stats1 = engine.commitStats();
558             assertThat(stats1.getGeneration(), greaterThan(0L));
559             assertThat(stats1.getId(), notNullValue());
560             assertThat(stats1.getUserData(), hasKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
561             assertThat(
562                 Long.parseLong(stats1.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
563                 equalTo(SequenceNumbers.NO_OPS_PERFORMED));
564             assertThat(stats1.getUserData(), hasKey(SequenceNumbers.MAX_SEQ_NO));
565             assertThat(
566                 Long.parseLong(stats1.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
567                 equalTo(SequenceNumbers.NO_OPS_PERFORMED));
568             maxSeqNo.set(rarely() ? SequenceNumbers.NO_OPS_PERFORMED : randomIntBetween(0, 1024));
569             localCheckpoint.set(
570                 rarely() || maxSeqNo.get() == SequenceNumbers.NO_OPS_PERFORMED ?
571                     SequenceNumbers.NO_OPS_PERFORMED : randomIntBetween(0, 1024));
572             globalCheckpoint.set(rarely() || localCheckpoint.get() == SequenceNumbers.NO_OPS_PERFORMED ?
573                                      UNASSIGNED_SEQ_NO : randomIntBetween(0, (int) localCheckpoint.get()));
574             final Engine.CommitId commitId = engine.flush(true, true);
575             CommitStats stats2 = engine.commitStats();
576             assertThat(stats2.getRawCommitId(), equalTo(commitId));
577             assertThat(stats2.getGeneration(), greaterThan(stats1.getGeneration()));
578             assertThat(stats2.getId(), notNullValue());
579             assertThat(stats2.getId(), not(equalTo(stats1.getId())));
580             assertThat(stats2.getUserData(), hasKey(Translog.TRANSLOG_UUID_KEY));
581             assertThat(stats2.getUserData().get(Translog.TRANSLOG_UUID_KEY),
582                        equalTo(stats1.getUserData().get(Translog.TRANSLOG_UUID_KEY)));
583             assertThat(Long.parseLong(stats2.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)), equalTo(localCheckpoint.get()));
584             assertThat(stats2.getUserData(), hasKey(SequenceNumbers.MAX_SEQ_NO));
585             assertThat(Long.parseLong(stats2.getUserData().get(SequenceNumbers.MAX_SEQ_NO)), equalTo(maxSeqNo.get()));
586         }
587     }
588     @Test
589     public void testFlushIsDisabledDuringTranslogRecovery() throws IOException {
590         engine.ensureCanFlush();         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);
591         engine.index(indexForDoc(doc));
592         engine.close();
593         engine = new InternalEngine(engine.config());
594         expectThrows(IllegalStateException.class, engine::ensureCanFlush);
595         expectThrows(IllegalStateException.class, () -&gt; engine.flush(true, true));
596         if (randomBoolean()) {
597             engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
598         } else {
599             engine.skipTranslogRecovery();
600         }
601         engine.ensureCanFlush(); 
602         doc = testParsedDocument("2", null, testDocumentWithTextField(), SOURCE, null);
603         engine.index(indexForDoc(doc));
604         engine.flush();
605     }
606     @Test
607     public void testTranslogMultipleOperationsSameDocument() throws IOException {
608         final int ops = randomIntBetween(1, 32);
609         Engine initialEngine;
610         final List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;();
611         try {
612             initialEngine = engine;
613             for (int i = 0; i &lt; ops; i++) {
614                 final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);
615                 if (randomBoolean()) {
616                         final Engine.Index operation = new Engine.Index(
617                             newUid(doc),
618                             doc,
619                             UNASSIGNED_SEQ_NO,
620                             0,
621                             i,
622                             VersionType.EXTERNAL,
623                             Engine.Operation.Origin.PRIMARY,
624                             System.nanoTime(),
625                             -1,
626                             false,
627                             UNASSIGNED_SEQ_NO,
628                             0
629                         );
630                     operations.add(operation);
631                     initialEngine.index(operation);
632                 } else {
633                     final Engine.Delete operation = new Engine.Delete(
634                         "1",
635                         newUid(doc),
636                         UNASSIGNED_SEQ_NO,
637                         0,
638                         i,
639                         VersionType.EXTERNAL,
640                         Engine.Operation.Origin.PRIMARY,
641                         System.nanoTime(),
642                         UNASSIGNED_SEQ_NO,
643                         0
644                     );
645                     operations.add(operation);
646                     initialEngine.delete(operation);
647                 }
648             }
649         } finally {
650             IOUtils.close(engine);
651         }
652         try (Engine recoveringEngine = new InternalEngine(engine.config())) {
653             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
654             recoveringEngine.refresh("test");
655             try (Engine.Searcher searcher = recoveringEngine.acquireSearcher("test")) {
656                 final TotalHitCountCollector collector = new TotalHitCountCollector();
657                 searcher.search(new MatchAllDocsQuery(), collector);
658                 assertThat(collector.getTotalHits(), equalTo(operations.get(operations.size() - 1) instanceof Engine.Delete ? 0 : 1));
659             }
660         }
661     }
662     @Test
663     public void testTranslogRecoveryDoesNotReplayIntoTranslog() throws IOException {
664         final int docs = randomIntBetween(1, 32);
665         Engine initialEngine = null;
666         try {
667             initialEngine = engine;
668             for (int i = 0; i &lt; docs; i++) {
669                 final String id = Integer.toString(i);
670                 final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
671                 initialEngine.index(indexForDoc(doc));
672             }
673         } finally {
674             IOUtils.close(initialEngine);
675         }
676         Engine recoveringEngine = null;
677         try {
678             final AtomicBoolean committed = new AtomicBoolean();
679             recoveringEngine = new InternalEngine(initialEngine.config()) {
680                 @Override
681                 protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
682                     committed.set(true);
683                     super.commitIndexWriter(writer, translog, syncId);
684                 }
685             };
686             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
687             assertTrue(committed.get());
688         } finally {
689             IOUtils.close(recoveringEngine);
690         }
691     }
692     @Test
693     public void testTranslogRecoveryWithMultipleGenerations() throws IOException {
694         final int docs = randomIntBetween(1, 4096);
695         final List&lt;Long&gt; seqNos = LongStream.range(0, docs).boxed().collect(Collectors.toList());
696         Randomness.shuffle(seqNos);
697         Engine initialEngine = null;
698         Engine recoveringEngine = null;
699         Store store = createStore();
700         final AtomicInteger counter = new AtomicInteger();
701         try {
702             initialEngine = createEngine(
703                 store,
704                 createTempDir(),
705                 LocalCheckpointTracker::new,
706                 (engine, operation) -&gt; seqNos.get(counter.getAndIncrement()));
707             for (int i = 0; i &lt; docs; i++) {
708                 final String id = Integer.toString(i);
709                 final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
710                 initialEngine.index(indexForDoc(doc));
711                 if (rarely()) {
712                     getTranslog(initialEngine).rollGeneration();
713                 } else if (rarely()) {
714                     initialEngine.flush();
715                 }
716             }
717             initialEngine.close();
718             recoveringEngine = new InternalEngine(initialEngine.config());
719             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
720             recoveringEngine.refresh("test");
721             try (Engine.Searcher searcher = recoveringEngine.acquireSearcher("test")) {
722                 TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), docs);
723                 assertEquals(docs, topDocs.totalHits.value);
724             }
725         } finally {
726             IOUtils.close(initialEngine, recoveringEngine, store);
727         }
728     }
729     @Test
730     public void testRecoveryFromTranslogUpToSeqNo() throws IOException {
731         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
732         try (Store store = createStore()) {
733             EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(),
734                                          null, null, globalCheckpoint::get);
735             final long maxSeqNo;
736             try (InternalEngine engine = createEngine(config)) {
737                 final int docs = randomIntBetween(1, 100);
738                 for (int i = 0; i &lt; docs; i++) {
739                     final String id = Integer.toString(i);
740                     final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(),
741                                                                   SOURCE, null);
742                     engine.index(indexForDoc(doc));
743                     if (rarely()) {
744                         engine.rollTranslogGeneration();
745                     } else if (rarely()) {
746                         engine.flush(randomBoolean(), true);
747                     }
748                 }
749                 maxSeqNo = engine.getLocalCheckpointTracker().getMaxSeqNo();
750                 globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getProcessedLocalCheckpoint()));
751                 engine.syncTranslog();
752             }
753             try (InternalEngine engine = new InternalEngine(config)) {
754                 engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
755                 assertThat(engine.getProcessedLocalCheckpoint(), equalTo(maxSeqNo));
756                 assertThat(engine.getLocalCheckpointTracker().getMaxSeqNo(), equalTo(maxSeqNo));
757             }
758             try (InternalEngine engine = new InternalEngine(config)) {
759                 long upToSeqNo = randomLongBetween(globalCheckpoint.get(), maxSeqNo);
760                 engine.recoverFromTranslog(translogHandler, upToSeqNo);
761                 assertThat(engine.getProcessedLocalCheckpoint(), equalTo(upToSeqNo));
762                 assertThat(engine.getLocalCheckpointTracker().getMaxSeqNo(), equalTo(upToSeqNo));
763             }
764         }
765     }
766     @Test
767     public void testConcurrentGetAndFlush() throws Exception {
768         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
769         engine.index(indexForDoc(doc));
770         final AtomicReference&lt;Engine.GetResult&gt; latestGetResult = new AtomicReference&lt;&gt;();
771         final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
772         latestGetResult.set(engine.get(newGet(doc), searcherFactory));
773         final AtomicBoolean flushFinished = new AtomicBoolean(false);
774         final CyclicBarrier barrier = new CyclicBarrier(2);
775         Thread getThread = new Thread(() -&gt; {
776             try {
777                 barrier.await();
778             } catch (InterruptedException | BrokenBarrierException e) {
779                 throw new RuntimeException(e);
780             }
781             while (flushFinished.get() == false) {
782                 Engine.GetResult previousGetResult = latestGetResult.get();
783                 if (previousGetResult != null) {
784                     previousGetResult.close();
785                 }
786                 latestGetResult.set(engine.get(newGet(doc), searcherFactory));
787                 if (latestGetResult.get().docIdAndVersion() == null) {
788                     break;
789                 }
790             }
791         });
792         getThread.start();
793         barrier.await();
794         engine.flush();
795         flushFinished.set(true);
796         getThread.join();
797         assertThat(latestGetResult.get().docIdAndVersion(), is(notNullValue()));
798         latestGetResult.get().close();
799     }
800     @Test
801     public void testSimpleOperations() throws Exception {
802         engine.refresh("warm_up");
803         Engine.Searcher searchResult = engine.acquireSearcher("test");
804         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
805         searchResult.close();
806         final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
807         Document document = testDocumentWithTextField();
808         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
809         ParsedDocument doc = testParsedDocument("1", null, document, B_1, null);
810         engine.index(indexForDoc(doc));
811         searchResult = engine.acquireSearcher("test");
812         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
813         MatcherAssert.assertThat(searchResult,
814                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
815         searchResult.close();
816         try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
817             assertThat(getResult.docIdAndVersion(), is(notNullValue()));
818         }
819         engine.refresh("test");
820         searchResult = engine.acquireSearcher("test");
821         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
822         MatcherAssert.assertThat(searchResult,
823                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
824         searchResult.close();
825         document = testDocument();
826         document.add(new TextField("value", "test1", Field.Store.YES));
827         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_2), SourceFieldMapper.Defaults.FIELD_TYPE));
828         doc = testParsedDocument("1", null, document, B_2, null);
829         engine.index(indexForDoc(doc));
830         searchResult = engine.acquireSearcher("test");
831         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
832         MatcherAssert.assertThat(searchResult,
833                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
834         MatcherAssert.assertThat(searchResult,
835                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 0));
836         searchResult.close();
837         try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
838             assertThat(getResult.docIdAndVersion(), is(notNullValue()));
839         }
840         engine.refresh("test");
841         searchResult = engine.acquireSearcher("test");
842         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
843         MatcherAssert.assertThat(searchResult,
844                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
845         MatcherAssert.assertThat(searchResult,
846                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 1));
847         searchResult.close();
848         engine.delete(new Engine.Delete(
849             "1",
850             newUid(doc),
851             UNASSIGNED_SEQ_NO,
852             primaryTerm.get(),
853             Versions.MATCH_ANY,
854             VersionType.INTERNAL,
855             Engine.Operation.Origin.PRIMARY,
856             System.nanoTime(),
857             UNASSIGNED_SEQ_NO,
858             0
859         ));
860         searchResult = engine.acquireSearcher("test");
861         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
862         MatcherAssert.assertThat(searchResult,
863                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
864         MatcherAssert.assertThat(searchResult,
865                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 1));
866         searchResult.close();
867         try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
868             assertThat(getResult.docIdAndVersion(), is(nullValue()));
869         }
870         engine.refresh("test");
871         searchResult = engine.acquireSearcher("test");
872         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
873         MatcherAssert.assertThat(searchResult,
874                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
875         MatcherAssert.assertThat(searchResult,
876                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 0));
877         searchResult.close();
878         document = testDocumentWithTextField();
879         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
880         doc = testParsedDocument("1", null, document, B_1, null);
881         engine.index(new Engine.Index(
882             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
883             Versions.MATCH_DELETED, VersionType.INTERNAL,
884             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));
885         searchResult = engine.acquireSearcher("test");
886         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
887         MatcherAssert.assertThat(searchResult,
888                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
889         MatcherAssert.assertThat(searchResult,
890                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 0));
891         searchResult.close();
892         engine.refresh("test");
893         searchResult = engine.acquireSearcher("test");
894         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
895         MatcherAssert.assertThat(searchResult,
896                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
897         MatcherAssert.assertThat(searchResult,
898                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 0));
899         searchResult.close();
900         engine.flush();
901         try (Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory)) {
902             assertThat(getResult.docIdAndVersion(), is(notNullValue()));
903         }
904         document = testDocument();
905         document.add(new TextField("value", "test1", Field.Store.YES));
906         doc = testParsedDocument("1", null, document, B_1, null);
907         engine.index(indexForDoc(doc));
908         searchResult = engine.acquireSearcher("test");
909         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
910         MatcherAssert.assertThat(searchResult,
911                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
912         MatcherAssert.assertThat(searchResult,
913                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 0));
914         searchResult.close();
915         engine.refresh("test");
916         searchResult = engine.acquireSearcher("test");
917         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
918         MatcherAssert.assertThat(searchResult,
919                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
920         MatcherAssert.assertThat(searchResult,
921                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test1")), 1));
922         searchResult.close();
923     }
924     public void testSearchResultRelease() throws Exception {
925         engine.refresh("warm_up");
926         Engine.Searcher searchResult = engine.acquireSearcher("test");
927         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
928         searchResult.close();
929         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
930         engine.index(indexForDoc(doc));
931         searchResult = engine.acquireSearcher("test");
932         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
933         MatcherAssert.assertThat(searchResult,
934                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 0));
935         searchResult.close();
936         engine.refresh("test");
937         searchResult = engine.acquireSearcher("test");
938         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
939         MatcherAssert.assertThat(searchResult,
940                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
941         engine.delete(new Engine.Delete(
942             "1",
943             newUid(doc),
944             UNASSIGNED_SEQ_NO,
945             primaryTerm.get(),
946             Versions.MATCH_ANY,
947             VersionType.INTERNAL,
948             Engine.Operation.Origin.PRIMARY,
949             System.nanoTime(),
950             UNASSIGNED_SEQ_NO,
951             0
952         ));
953         engine.refresh("test");
954         Engine.Searcher updateSearchResult = engine.acquireSearcher("test");
955         MatcherAssert.assertThat(updateSearchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(0));
956         updateSearchResult.close();
957         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
958         MatcherAssert.assertThat(searchResult,
959                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(new TermQuery(new Term("value", "test")), 1));
960         searchResult.close();
961     }
962     @Test
963     public void testCommitAdvancesMinTranslogForRecovery() throws IOException {
964         IOUtils.close(engine, store);
965         final Path translogPath = createTempDir();
966         store = createStore();
967         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
968         final LongSupplier globalCheckpointSupplier = () -&gt; globalCheckpoint.get();
969         engine = createEngine(config(defaultSettings, store, translogPath, newMergePolicy(), null, null,
970             globalCheckpointSupplier));
971         engine.onSettingsChanged(TimeValue.MINUS_ONE, ByteSizeValue.ZERO, randomNonNegativeLong());
972         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
973         engine.index(indexForDoc(doc));
974         boolean inSync = randomBoolean();
975         if (inSync) {
976             engine.syncTranslog();             globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
977         }
978         engine.flush();
979         assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
980         assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));
981         engine.flush();
982         assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
983         assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));
984         engine.flush(true, true);
985         assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
986         assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(inSync ? 3L : 2L));
987         globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
988         engine.flush(true, true);
989         assertThat(engine.getTranslog().currentFileGeneration(), equalTo(3L));
990         assertThat(engine.getTranslog().getMinFileGeneration(), equalTo(3L));
991     }
992     @Test
993     public void testSyncedFlush() throws IOException {
994         try (Store store = createStore();
995              Engine engine = createEngine(defaultSettings, store, createTempDir(), new LogByteSizeMergePolicy(), null)) {
996             final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
997             ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
998             engine.index(indexForDoc(doc));
999             Engine.CommitId commitID = engine.flush();
1000             assertThat(commitID, equalTo(new Engine.CommitId(store.readLastCommittedSegmentsInfo().getId())));
1001             byte[] wrongBytes = Base64.getDecoder().decode(commitID.toString());
1002             wrongBytes[0] = (byte) ~wrongBytes[0];
1003             Engine.CommitId wrongId = new Engine.CommitId(wrongBytes);
1004             assertEquals("should fail to sync flush with wrong id (but no docs)", engine.syncFlush(syncId + "1", wrongId),
1005                          Engine.SyncedFlushResult.COMMIT_MISMATCH);
1006             engine.index(indexForDoc(doc));
1007             assertEquals("should fail to sync flush with right id but pending doc",
1008                          engine.syncFlush(syncId + "2", commitID), Engine.SyncedFlushResult.PENDING_OPERATIONS);
1009             commitID = engine.flush();
1010             assertEquals("should succeed to flush commit with right id and no pending doc", engine.syncFlush(syncId, commitID),
1011                          Engine.SyncedFlushResult.SUCCESS);
1012             assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1013             assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1014         }
1015     }
1016     @Test
1017     public void testRenewSyncFlush() throws Exception {
1018         final int iters = randomIntBetween(2, 5);         for (int i = 0; i &lt; iters; i++) {
1019             try (Store store = createStore();
1020                  InternalEngine engine =
1021                      createEngine(config(defaultSettings, store, createTempDir(), new LogDocMergePolicy(), null))) {
1022                 final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
1023                 Engine.Index doc1 =
1024                     indexForDoc(testParsedDocument("1", null, testDocumentWithTextField(), B_1, null));
1025                 engine.index(doc1);
1026                 assertEquals(engine.getLastWriteNanos(), doc1.startTime());
1027                 engine.flush();
1028                 Engine.Index doc2 =
1029                     indexForDoc(testParsedDocument("2", null, testDocumentWithTextField(), B_1, null));
1030                 engine.index(doc2);
1031                 assertEquals(engine.getLastWriteNanos(), doc2.startTime());
1032                 engine.flush();
1033                 final boolean forceMergeFlushes = randomBoolean();
1034                 final ParsedDocument parsedDoc3 =
1035                     testParsedDocument("3", null, testDocumentWithTextField(), B_1, null);
1036                 if (forceMergeFlushes) {
1037                     engine.index(new Engine.Index(newUid(parsedDoc3), parsedDoc3, UNASSIGNED_SEQ_NO, 0,
1038                                                   Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY,
1039                                                   System.nanoTime() - engine.engineConfig.getFlushMergesAfter().nanos(),
1040                                                   -1, false, UNASSIGNED_SEQ_NO, 0));
1041                 } else {
1042                     engine.index(indexForDoc(parsedDoc3));
1043                 }
1044                 Engine.CommitId commitID = engine.flush();
1045                 assertEquals("should succeed to flush commit with right id and no pending doc", engine.syncFlush(syncId, commitID),
1046                              Engine.SyncedFlushResult.SUCCESS);
1047                 assertEquals(3, engine.segments(false).size());
1048                 engine.forceMerge(forceMergeFlushes, 1, false, false, false, UUIDs.randomBase64UUID());
1049                 if (forceMergeFlushes == false) {
1050                     engine.refresh("make all segments visible");
1051                     assertEquals(4, engine.segments(false).size());
1052                     assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1053                     assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1054                     assertTrue(engine.tryRenewSyncCommit());
1055                     assertEquals(1, engine.segments(false).size());
1056                 } else {
1057                     engine.refresh("test");
1058                     assertBusy(() -&gt; assertEquals(1, engine.segments(false).size()));
1059                 }
1060                 assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1061                 assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1062                 if (randomBoolean()) {
1063                     Engine.Index doc4 =
1064                         indexForDoc(testParsedDocument("4", null, testDocumentWithTextField(), B_1, null));
1065                     engine.index(doc4);
1066                     assertEquals(engine.getLastWriteNanos(), doc4.startTime());
1067                 } else {
1068                     Engine.Delete delete = new Engine.Delete(
1069                         doc1.id(),
1070                         doc1.uid(),
1071                         UNASSIGNED_SEQ_NO,
1072                         primaryTerm.get(),
1073                         Versions.MATCH_ANY,
1074                         VersionType.INTERNAL,
1075                         Engine.Operation.Origin.PRIMARY,
1076                         System.nanoTime(),
1077                         UNASSIGNED_SEQ_NO,
1078                         0
1079                     );
1080                     engine.delete(delete);
1081                     assertEquals(engine.getLastWriteNanos(), delete.startTime());
1082                 }
1083                 assertFalse(engine.tryRenewSyncCommit());
1084                 engine.flush(false, true);
1085                 assertNull(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID));
1086                 assertNull(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID));
1087             }
1088         }
1089     }
1090     @Test
1091     public void testSyncedFlushSurvivesEngineRestart() throws IOException {
1092         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
1093         IOUtils.close(store, engine);
1094         store = createStore();
1095         engine = createEngine(store, primaryTranslogDir, globalCheckpoint::get);
1096         final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
1097         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
1098                                                 new BytesArray("{}"), null);
1099         engine.index(indexForDoc(doc));
1100         globalCheckpoint.set(0L);
1101         final Engine.CommitId commitID = engine.flush();
1102         assertEquals("should succeed to flush commit with right id and no pending doc", engine.syncFlush(syncId, commitID),
1103                      Engine.SyncedFlushResult.SUCCESS);
1104         assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1105         assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1106         EngineConfig config = engine.config();
1107         if (randomBoolean()) {
1108             engine.close();
1109         } else {
1110             engine.flushAndClose();
1111         }
1112         if (randomBoolean()) {
1113             final String translogUUID = Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
1114                                                                      UNASSIGNED_SEQ_NO, shardId, primaryTerm.get());
1115             store.associateIndexWithNewTranslog(translogUUID);
1116         }
1117         engine = new InternalEngine(config);
1118         engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
1119         assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1120     }
1121     @Test
1122     public void testSyncedFlushVanishesOnReplay() throws IOException {
1123         final String syncId = randomUnicodeOfCodepointLengthBetween(10, 20);
1124         ParsedDocument doc = testParsedDocument("1", null,
1125                                                 testDocumentWithTextField(), new BytesArray("{}"), null);
1126         engine.index(indexForDoc(doc));
1127         final Engine.CommitId commitID = engine.flush();
1128         assertEquals("should succeed to flush commit with right id and no pending doc", engine.syncFlush(syncId, commitID),
1129                      Engine.SyncedFlushResult.SUCCESS);
1130         assertEquals(store.readLastCommittedSegmentsInfo().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1131         assertEquals(engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID), syncId);
1132         doc = testParsedDocument("2", null, testDocumentWithTextField(), new BytesArray("{}"), null);
1133         engine.index(indexForDoc(doc));
1134         EngineConfig config = engine.config();
1135         engine.close();
1136         engine = new InternalEngine(config);
1137         engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
1138         assertNull("Sync ID must be gone since we have a document to replay",
1139                    engine.getLastCommittedSegmentInfos().getUserData().get(Engine.SYNC_COMMIT_ID));
1140     }
1141     @Test
1142     public void testVersioningNewCreate() throws IOException {
1143         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
1144         Engine.Index create = new Engine.Index(
1145             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1146             Versions.MATCH_DELETED, VersionType.INTERNAL,
1147             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1148         Engine.IndexResult indexResult = engine.index(create);
1149         assertThat(indexResult.getVersion(), equalTo(1L));
1150         create = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), create.primaryTerm(), indexResult.getVersion(),
1151                                   null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1152         indexResult = replicaEngine.index(create);
1153         assertThat(indexResult.getVersion(), equalTo(1L));
1154     }
1155     @Test
1156     public void testReplicatedVersioningWithFlush() throws IOException {
1157         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
1158         Engine.Index create = new Engine.Index(
1159             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1160             Versions.MATCH_DELETED, VersionType.INTERNAL,
1161             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1162         Engine.IndexResult indexResult = engine.index(create);
1163         assertThat(indexResult.getVersion(), equalTo(1L));
1164         assertTrue(indexResult.isCreated());
1165         create = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), create.primaryTerm(), indexResult.getVersion(),
1166                                   null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1167         indexResult = replicaEngine.index(create);
1168         assertThat(indexResult.getVersion(), equalTo(1L));
1169         assertTrue(indexResult.isCreated());
1170         if (randomBoolean()) {
1171             engine.flush();
1172         }
1173         if (randomBoolean()) {
1174             replicaEngine.flush();
1175         }
1176         Engine.Index update = new Engine.Index(
1177             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1178             1, VersionType.INTERNAL,
1179             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1180         Engine.IndexResult updateResult = engine.index(update);
1181         assertThat(updateResult.getVersion(), equalTo(2L));
1182         assertFalse(updateResult.isCreated());
1183         update = new Engine.Index(newUid(doc), doc, updateResult.getSeqNo(), update.primaryTerm(), updateResult.getVersion(),
1184                                   null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1185         updateResult = replicaEngine.index(update);
1186         assertThat(updateResult.getVersion(), equalTo(2L));
1187         assertFalse(updateResult.isCreated());
1188         replicaEngine.refresh("test");
1189         try (Searcher searcher = replicaEngine.acquireSearcher("test")) {
1190             assertEquals(1, searcher.getDirectoryReader().numDocs());
1191         }
1192         engine.refresh("test");
1193         try (Searcher searcher = engine.acquireSearcher("test")) {
1194             assertEquals(1, searcher.getDirectoryReader().numDocs());
1195         }
1196     }
1197     @Test
1198     public void testVersionedUpdate() throws IOException {
1199         final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
1200         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
1201         Engine.Index create = new Engine.Index(
1202             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1203             Versions.MATCH_DELETED, VersionType.INTERNAL,
1204             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1205         Engine.IndexResult indexResult = engine.index(create);
1206         assertThat(indexResult.getVersion(), equalTo(1L));
1207         try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
1208             assertEquals(1, get.docIdAndVersion().version);
1209         }
1210         Engine.Index update_1 = new Engine.Index(
1211             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1212             1, VersionType.INTERNAL,
1213             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1214         Engine.IndexResult update_1_result = engine.index(update_1);
1215         assertThat(update_1_result.getVersion(), equalTo(2L));
1216         try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
1217             assertEquals(2, get.docIdAndVersion().version);
1218         }
1219         Engine.Index update_2 = new Engine.Index(
1220             newUid(doc), doc, UNASSIGNED_SEQ_NO, primaryTerm.get(),
1221             2, VersionType.INTERNAL,
1222             Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
1223         Engine.IndexResult update_2_result = engine.index(update_2);
1224         assertThat(update_2_result.getVersion(), equalTo(3L));
1225         try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), create.uid()), searcherFactory)) {
1226             assertEquals(3, get.docIdAndVersion().version);
1227         }
1228     }
1229     @Test
1230     public void testVersioningNewIndex() throws IOException {
1231         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
1232         Engine.Index index = indexForDoc(doc);
1233         Engine.IndexResult indexResult = engine.index(index);
1234         assertThat(indexResult.getVersion(), equalTo(1L));
1235         index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
1236                                  null, REPLICA, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1237         indexResult = replicaEngine.index(index);
1238         assertThat(indexResult.getVersion(), equalTo(1L));
1239     }
1240     @Test
1241     public void testLookupVersionWithPrunedAwayIds() throws IOException {
1242         try (Directory dir = newDirectory()) {
1243             IndexWriterConfig indexWriterConfig = new IndexWriterConfig(Lucene.STANDARD_ANALYZER);
1244             indexWriterConfig.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD);
1245             try (IndexWriter writer = new IndexWriter(dir,
1246                                                       indexWriterConfig.setMergePolicy(new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD,
1247                                                                                                                            MatchAllDocsQuery::new, new PrunePostingsMergePolicy(indexWriterConfig.getMergePolicy(), "_id"))))) {
1248                 org.apache.lucene.document.Document doc = new org.apache.lucene.document.Document();
1249                 doc.add(new Field(IdFieldMapper.NAME, "1", IdFieldMapper.Defaults.FIELD_TYPE));
1250                 doc.add(new NumericDocValuesField(VersionFieldMapper.NAME, -1));
1251                 doc.add(new NumericDocValuesField(SeqNoFieldMapper.NAME, 1));
1252                 doc.add(new NumericDocValuesField(SeqNoFieldMapper.PRIMARY_TERM_NAME, 1));
1253                 writer.addDocument(doc);
1254                 writer.flush();
1255                 writer.softUpdateDocument(new Term(IdFieldMapper.NAME, "1"), doc, new NumericDocValuesField(Lucene.SOFT_DELETES_FIELD, 1));
1256                 writer.updateNumericDocValue(new Term(IdFieldMapper.NAME, "1"), Lucene.SOFT_DELETES_FIELD, 1);
1257                 writer.forceMerge(1);
1258                 try (DirectoryReader reader = DirectoryReader.open(writer)) {
1259                     assertEquals(1, reader.leaves().size());
1260                     assertNull(VersionsAndSeqNoResolver.loadDocIdAndVersion(reader, new Term(IdFieldMapper.NAME, "1"), false));
1261                 }
1262             }
1263         }
1264     }
1265     @Test
1266     public void testUpdateWithFullyDeletedSegments() throws IOException {
1267         Settings.Builder settings = Settings.builder()
1268             .put(defaultSettings.getSettings())
1269             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
1270             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), Integer.MAX_VALUE);
1271         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
1272         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
1273         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
1274         final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
1275         try (Store store = createStore();
1276              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
1277                                                          null, globalCheckpoint::get))) {
1278             int numDocs = scaledRandomIntBetween(10, 100);
1279             for (int i = 0; i &lt; numDocs; i++) {
1280                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
1281                 engine.index(indexForDoc(doc));
1282                 liveDocs.add(doc.id());
1283             }
1284             for (int i = 0; i &lt; numDocs; i++) {
1285                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
1286                 engine.index(indexForDoc(doc));
1287                 liveDocs.add(doc.id());
1288             }
1289         }
1290     }
1291     @Test
1292     public void testForceMergeWithSoftDeletesRetention() throws Exception {
1293         final long retainedExtraOps = randomLongBetween(0, 10);
1294         Settings.Builder settings = Settings.builder()
1295             .put(defaultSettings.getSettings())
1296             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
1297             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), retainedExtraOps);
1298         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
1299         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
1300         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
1301         final MapperService mapperService = createMapperService("test");
1302         final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
1303         try (Store store = createStore();
1304              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
1305                                                          null, globalCheckpoint::get))) {
1306             int numDocs = scaledRandomIntBetween(10, 100);
1307             for (int i = 0; i &lt; numDocs; i++) {
1308                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
1309                 engine.index(indexForDoc(doc));
1310                 liveDocs.add(doc.id());
1311             }
1312             for (int i = 0; i &lt; numDocs; i++) {
1313                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null);
1314                 if (randomBoolean()) {
1315                     engine.delete(new Engine.Delete(doc.id(), newUid(doc.id()), primaryTerm.get()));
1316                     liveDocs.remove(doc.id());
1317                 }
1318                 if (randomBoolean()) {
1319                     engine.index(indexForDoc(doc));
1320                     liveDocs.add(doc.id());
1321                 }
1322                 if (randomBoolean()) {
1323                     engine.flush(randomBoolean(), true);
1324                 }
1325             }
1326             engine.flush();
1327             long localCheckpoint = engine.getProcessedLocalCheckpoint();
1328             globalCheckpoint.set(randomLongBetween(0, localCheckpoint));
1329             engine.syncTranslog();
1330             final long safeCommitCheckpoint;
1331             try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {
1332                 safeCommitCheckpoint = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
1333             }
1334             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
1335             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
1336             Map&lt;Long, Translog.Operation&gt; ops = readAllOperationsInLucene(engine, mapperService)
1337                 .stream().collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()));
1338             for (long seqno = 0; seqno &lt;= localCheckpoint; seqno++) {
1339                 long minSeqNoToRetain = Math.min(globalCheckpoint.get() + 1 - retainedExtraOps,
1340                                                  safeCommitCheckpoint + 1);
1341                 String msg = "seq# [" + seqno + "], global checkpoint [" + globalCheckpoint + "], retained-ops [" +
1342                              retainedExtraOps + "]";
1343                 if (seqno &lt; minSeqNoToRetain) {
1344                     Translog.Operation op = ops.get(seqno);
1345                     if (op != null) {
1346                         assertThat(op, instanceOf(Translog.Index.class));
1347                         assertThat(msg, ((Translog.Index) op).id(), isIn(liveDocs));
1348                         assertEquals(msg, ((Translog.Index) op).source(), B_1);
1349                     }
1350                 } else {
1351                     assertThat(msg, ops.get(seqno), notNullValue());
1352                 }
1353             }
1354             settings.put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0);
1355             indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(
1356                 settings).build());
1357             engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
1358                                      indexSettings.getSoftDeleteRetentionOperations());
1359             globalCheckpoint.set(localCheckpoint);
1360             engine.syncTranslog();
1361             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
1362             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
1363             assertThat(readAllOperationsInLucene(engine, mapperService), hasSize(liveDocs.size()));
1364         }
1365     }
1366     @Test
1367     public void testForceMergeWithSoftDeletesRetentionAndRecoverySource() throws Exception {
1368         final long retainedExtraOps = randomLongBetween(0, 10);
1369         Settings.Builder settings = Settings.builder()
1370             .put(defaultSettings.getSettings())
1371             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
1372             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), retainedExtraOps);
1373         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
1374         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
1375         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
1376         final MapperService mapperService = createMapperService("test");
1377         final boolean omitSourceAllTheTime = randomBoolean();
1378         final Set&lt;String&gt; liveDocs = new HashSet&lt;&gt;();
1379         final Set&lt;String&gt; liveDocsWithSource = new HashSet&lt;&gt;();
1380         try (Store store = createStore();
1381              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null,
1382                                                          null,
1383                                                          globalCheckpoint::get))) {
1384             int numDocs = scaledRandomIntBetween(10, 100);
1385             for (int i = 0; i &lt; numDocs; i++) {
1386                 boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
1387                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null,
1388                                                         useRecoverySource);
1389                 engine.index(indexForDoc(doc));
1390                 liveDocs.add(doc.id());
1391                 if (useRecoverySource == false) {
1392                     liveDocsWithSource.add(Integer.toString(i));
1393                 }
1394             }
1395             for (int i = 0; i &lt; numDocs; i++) {
1396                 boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
1397                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1, null,
1398                                                         useRecoverySource);
1399                 if (randomBoolean()) {
1400                     engine.delete(new Engine.Delete(doc.id(), newUid(doc.id()), primaryTerm.get()));
1401                     liveDocs.remove(doc.id());
1402                     liveDocsWithSource.remove(doc.id());
1403                 }
1404                 if (randomBoolean()) {
1405                     engine.index(indexForDoc(doc));
1406                     liveDocs.add(doc.id());
1407                     if (useRecoverySource == false) {
1408                         liveDocsWithSource.add(doc.id());
1409                     } else {
1410                         liveDocsWithSource.remove(doc.id());
1411                     }
1412                 }
1413                 if (randomBoolean()) {
1414                     engine.flush(randomBoolean(), true);
1415                 }
1416             }
1417             engine.flush();
1418             globalCheckpoint.set(randomLongBetween(0, engine.getPersistedLocalCheckpoint()));
1419             engine.syncTranslog();
1420             final long minSeqNoToRetain;
1421             try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {
1422                 long safeCommitLocalCheckpoint = Long.parseLong(
1423                     safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
1424                 minSeqNoToRetain = Math.min(globalCheckpoint.get() + 1 - retainedExtraOps,
1425                                             safeCommitLocalCheckpoint + 1);
1426             }
1427             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
1428             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
1429             Map&lt;Long, Translog.Operation&gt; ops = readAllOperationsInLucene(engine, mapperService)
1430                 .stream().collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()));
1431             for (long seqno = 0; seqno &lt;= engine.getPersistedLocalCheckpoint(); seqno++) {
1432                 String msg = "seq# [" + seqno + "], global checkpoint [" + globalCheckpoint + "], retained-ops [" +
1433                              retainedExtraOps + "]";
1434                 if (seqno &lt; minSeqNoToRetain) {
1435                     Translog.Operation op = ops.get(seqno);
1436                     if (op != null) {
1437                         assertThat(op, instanceOf(Translog.Index.class));
1438                         assertThat(msg, ((Translog.Index) op).id(), isIn(liveDocs));
1439                     }
1440                 } else {
1441                     Translog.Operation op = ops.get(seqno);
1442                     assertThat(msg, op, notNullValue());
1443                     if (op instanceof Translog.Index) {
1444                         assertEquals(msg, ((Translog.Index) op).source(), B_1);
1445                     }
1446                 }
1447             }
1448             settings.put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 0);
1449             indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(
1450                 settings).build());
1451             engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
1452                                      indexSettings.getSoftDeleteRetentionOperations());
1453             final int numSegments;
1454             try (Engine.Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
1455                 numSegments = searcher.getDirectoryReader().leaves().size();
1456             }
1457             if (numSegments == 1) {
1458                 boolean useRecoverySource = randomBoolean() || omitSourceAllTheTime;
1459                 ParsedDocument doc = testParsedDocument("dummy", null, testDocument(), B_1, null, useRecoverySource);
1460                 engine.index(indexForDoc(doc));
1461                 if (useRecoverySource == false) {
1462                     liveDocsWithSource.add(doc.id());
1463                 }
1464                 engine.syncTranslog();
1465                 globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
1466                 engine.flush(randomBoolean(), true);
1467             } else {
1468                 globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
1469                 engine.syncTranslog();
1470             }
1471             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
1472             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
1473             assertThat(readAllOperationsInLucene(engine, mapperService), hasSize(liveDocsWithSource.size()));
1474         }
1475     }
1476     @Test
1477     public void testForceMergeAndClose() throws IOException, InterruptedException {
1478         int numIters = randomIntBetween(2, 10);
1479         for (int j = 0; j &lt; numIters; j++) {
1480             try (Store store = createStore()) {
1481                 final InternalEngine engine = createEngine(store, createTempDir());
1482                 final CountDownLatch startGun = new CountDownLatch(1);
1483                 final CountDownLatch indexed = new CountDownLatch(1);
1484                 Thread thread = new Thread() {
1485                     @Override
1486                     public void run() {
1487                         try {
1488                             try {
1489                                 startGun.await();
1490                             } catch (InterruptedException e) {
1491                                 throw new RuntimeException(e);
1492                             }
1493                             int i = 0;
1494                             while (true) {
1495                                 int numDocs = randomIntBetween(1, 20);
1496                                 for (int j = 0; j &lt; numDocs; j++) {
1497                                     i++;
1498                                     ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), B_1,
1499                                                                             null);
1500                                     Engine.Index index = indexForDoc(doc);
1501                                     engine.index(index);
1502                                 }
1503                                 engine.refresh("test");
1504                                 indexed.countDown();
1505                                 try {
1506                                     engine.forceMerge(
1507                                         randomBoolean(),
1508                                         1,
1509                                         false,
1510                                         randomBoolean(),
1511                                         randomBoolean(),
1512                                         UUIDs.randomBase64UUID()
1513                                     );
1514                                 } catch (IOException e) {
1515                                     return;
1516                                 }
1517                             }
1518                         } catch (AlreadyClosedException ex) {
1519                         } catch (IOException e) {
1520                             throw new AssertionError(e);
1521                         }
1522                     }
1523                 };
1524                 thread.start();
1525                 startGun.countDown();
1526                 int someIters = randomIntBetween(1, 10);
1527                 for (int i = 0; i &lt; someIters; i++) {
1528                     engine.forceMerge(randomBoolean(), 1, false, randomBoolean(), randomBoolean(), UUIDs.randomBase64UUID());
1529                 }
1530                 indexed.await();
1531                 IOUtils.close(engine);
1532                 thread.join();
1533             }
1534         }
1535     }
1536     @Test
1537     public void testVersioningCreateExistsException() throws IOException {
1538         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
1539         Engine.Index create = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
1540                                                Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1541         Engine.IndexResult indexResult = engine.index(create);
1542         assertThat(indexResult.getVersion(), equalTo(1L));
1543         create = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, Versions.MATCH_DELETED,
1544                                   VersionType.INTERNAL, PRIMARY, 0, -1, false, UNASSIGNED_SEQ_NO, 0);
1545         indexResult = engine.index(create);
1546         assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
1547         assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));
1548     }
1549     @Test
1550     public void testOutOfOrderDocsOnReplica() throws IOException {
1551         final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
1552             true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL, VersionType.EXTERNAL_GTE),
1553             2, 2, 20, "1");
1554         assertOpsOnReplica(ops, replicaEngine, true, logger);
1555     }
1556     @Test
1557     public void testConcurrentOutOfOrderDocsOnReplica() throws IOException, InterruptedException {
1558         final List&lt;Engine.Operation&gt; opsDoc1 = generateSingleDocHistory(
1559             true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, "1");
1560         final Engine.Operation lastOpDoc1 = opsDoc1.get(opsDoc1.size() - 1);
1561         final String lastFieldValueDoc1;
1562         if (lastOpDoc1 instanceof Engine.Index) {
1563             Engine.Index index = (Engine.Index) lastOpDoc1;
1564             lastFieldValueDoc1 = index.docs().get(0).get("value");
1565         } else {
1566             lastFieldValueDoc1 = null;
1567         }
1568         final List&lt;Engine.Operation&gt; opsDoc2 =
1569             generateSingleDocHistory(
1570                 true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, "2");
1571         final Engine.Operation lastOpDoc2 = opsDoc2.get(opsDoc2.size() - 1);
1572         final String lastFieldValueDoc2;
1573         if (lastOpDoc2 instanceof Engine.Index) {
1574             Engine.Index index = (Engine.Index) lastOpDoc2;
1575             lastFieldValueDoc2 = index.docs().get(0).get("value");
1576         } else {
1577             lastFieldValueDoc2 = null;
1578         }
1579         final AtomicLong seqNoGenerator = new AtomicLong();
1580         BiFunction&lt;Engine.Operation, Long, Engine.Operation&gt; seqNoUpdater = (operation, newSeqNo) -&gt; {
1581             if (operation instanceof Engine.Index) {
1582                 Engine.Index index = (Engine.Index) operation;
1583                 Document doc = testDocumentWithTextField(index.docs().get(0).get("value"));
1584                 ParsedDocument parsedDocument = testParsedDocument(index.id(), index.routing(), doc, index.source(), null);
1585                 return new Engine.Index(index.uid(), parsedDocument, newSeqNo, index.primaryTerm(), index.version(),
1586                                         index.versionType(), index.origin(), index.startTime(), index.getAutoGeneratedIdTimestamp(), index.isRetry(),
1587                                         UNASSIGNED_SEQ_NO, 0);
1588             } else {
1589                 Engine.Delete delete = (Engine.Delete) operation;
1590                 return new Engine.Delete(
1591                     delete.id(),
1592                     delete.uid(),
1593                     newSeqNo,
1594                     delete.primaryTerm(),
1595                     delete.version(),
1596                     delete.versionType(),
1597                     delete.origin(),
1598                     delete.startTime(),
1599                     UNASSIGNED_SEQ_NO,
1600                     0
1601                 );
1602             }
1603         };
1604         final List&lt;Engine.Operation&gt; allOps = new ArrayList&lt;&gt;();
1605         Iterator&lt;Engine.Operation&gt; iter1 = opsDoc1.iterator();
1606         Iterator&lt;Engine.Operation&gt; iter2 = opsDoc2.iterator();
1607         while (iter1.hasNext() &amp;&amp; iter2.hasNext()) {
1608             final Engine.Operation next = randomBoolean() ? iter1.next() : iter2.next();
1609             allOps.add(seqNoUpdater.apply(next, seqNoGenerator.getAndIncrement()));
1610         }
1611         iter1.forEachRemaining(o -&gt; allOps.add(seqNoUpdater.apply(o, seqNoGenerator.getAndIncrement())));
1612         iter2.forEachRemaining(o -&gt; allOps.add(seqNoUpdater.apply(o, seqNoGenerator.getAndIncrement())));
1613         randomSubsetOf(allOps).forEach(op -&gt; allOps.add(seqNoUpdater.apply(op, op.seqNo())));
1614         shuffle(allOps, random());
1615         concurrentlyApplyOps(allOps, engine);
1616         engine.refresh("test");
1617         if (lastFieldValueDoc1 != null) {
1618             try (Searcher searcher = engine.acquireSearcher("test")) {
1619                 final TotalHitCountCollector collector = new TotalHitCountCollector();
1620                 searcher.search(new TermQuery(new Term("value", lastFieldValueDoc1)), collector);
1621                 assertThat(collector.getTotalHits(), equalTo(1));
1622             }
1623         }
1624         if (lastFieldValueDoc2 != null) {
1625             try (Searcher searcher = engine.acquireSearcher("test")) {
1626                 final TotalHitCountCollector collector = new TotalHitCountCollector();
1627                 searcher.search(new TermQuery(new Term("value", lastFieldValueDoc2)), collector);
1628                 assertThat(collector.getTotalHits(), equalTo(1));
1629             }
1630         }
1631         int totalExpectedOps = 0;
1632         if (lastFieldValueDoc1 != null) {
1633             totalExpectedOps++;
1634         }
1635         if (lastFieldValueDoc2 != null) {
1636             totalExpectedOps++;
1637         }
1638         assertVisibleCount(engine, totalExpectedOps);
1639     }
1640     @Test
1641     public void testInternalVersioningOnPrimary() throws IOException {
1642         final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
1643             false, VersionType.INTERNAL, 2, 2, 20, "1");
1644         assertOpsOnPrimary(ops, Versions.NOT_FOUND, true, engine);
1645     }
1646     @Test
1647     public void testVersionOnPrimaryWithConcurrentRefresh() throws Exception {
1648         List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
1649             false, VersionType.INTERNAL, 2, 10, 100, "1");
1650         CountDownLatch latch = new CountDownLatch(1);
1651         AtomicBoolean running = new AtomicBoolean(true);
1652         Thread refreshThread = new Thread(() -&gt; {
1653             latch.countDown();
1654             while (running.get()) {
1655                 engine.refresh("test");
1656             }
1657         });
1658         refreshThread.start();
1659         try {
1660             latch.await();
1661             assertOpsOnPrimary(ops, Versions.NOT_FOUND, true, engine);
1662         } finally {
1663             running.set(false);
1664             refreshThread.join();
1665         }
1666     }
1667     private int assertOpsOnPrimary(List&lt;Engine.Operation&gt; ops,
1668                                    long currentOpVersion,
1669                                    boolean docDeleted,
1670                                    InternalEngine engine)
1671         throws IOException {
1672         String lastFieldValue = null;
1673         int opsPerformed = 0;
1674         long lastOpVersion = currentOpVersion;
1675         long lastOpSeqNo = UNASSIGNED_SEQ_NO;
1676         long lastOpTerm = UNASSIGNED_PRIMARY_TERM;
1677         PrimaryTermSupplier currentTerm = (PrimaryTermSupplier) engine.engineConfig.getPrimaryTermSupplier();
1678         BiFunction&lt;Long, Engine.Index, Engine.Index&gt; indexWithVersion = (version, index) -&gt; new Engine.Index(
1679             index.uid(),
1680             index.parsedDoc(),
1681             UNASSIGNED_SEQ_NO,
1682             currentTerm.get(),
1683             version,
1684             index.versionType(),
1685             index.origin(),
1686             index.startTime(),
1687             index.getAutoGeneratedIdTimestamp(),
1688             index.isRetry(),
1689             UNASSIGNED_SEQ_NO,
1690             0);
1691         BiFunction&lt;Long, Engine.Delete, Engine.Delete&gt; delWithVersion = (version, delete) -&gt; new Engine.Delete(
1692             delete.id(),
1693             delete.uid(),
1694             UNASSIGNED_SEQ_NO,
1695             currentTerm.get(),
1696             version,
1697             delete.versionType(),
1698             delete.origin(),
1699             delete.startTime(),
1700             UNASSIGNED_SEQ_NO,
1701             0);
1702         TriFunction&lt;Long, Long, Engine.Index, Engine.Index&gt; indexWithSeq = (seqNo, term, index) -&gt; new Engine.Index(
1703             index.uid(),
1704             index.parsedDoc(),
1705             UNASSIGNED_SEQ_NO,
1706             currentTerm.get(),
1707             index.version(),
1708             index.versionType(),
1709             index.origin(),
1710             index.startTime(),
1711             index.getAutoGeneratedIdTimestamp(),
1712             index.isRetry(),
1713             seqNo,
1714             term);
1715         TriFunction&lt;Long, Long, Engine.Delete, Engine.Delete&gt; delWithSeq = (seqNo, term, delete) -&gt; new Engine.Delete(
1716             delete.id(),
1717             delete.uid(),
1718             UNASSIGNED_SEQ_NO,
1719             currentTerm.get(),
1720             delete.version(),
1721             delete.versionType(),
1722             delete.origin(),
1723             delete.startTime(),
1724             seqNo,
1725             term);
1726         Function&lt;Engine.Index, Engine.Index&gt; indexWithCurrentTerm = index -&gt; new Engine.Index(
1727             index.uid(),
1728             index.parsedDoc(),
1729             UNASSIGNED_SEQ_NO,
1730             currentTerm.get(),
1731             index.version(),
1732             index.versionType(),
1733             index.origin(),
1734             index.startTime(),
1735             index.getAutoGeneratedIdTimestamp(),
1736             index.isRetry(),
1737             index.getIfSeqNo(),
1738             index.getIfPrimaryTerm());
1739         Function&lt;Engine.Delete, Engine.Delete&gt; deleteWithCurrentTerm = delete -&gt; new Engine.Delete(
1740             delete.id(),
1741             delete.uid(),
1742             UNASSIGNED_SEQ_NO,
1743             currentTerm.get(),
1744             delete.version(),
1745             delete.versionType(),
1746             delete.origin(),
1747             delete.startTime(),
1748             delete.getIfSeqNo(),
1749             delete.getIfPrimaryTerm());
1750         for (Engine.Operation op : ops) {
1751             final boolean versionConflict = rarely();
1752             final boolean versionedOp = versionConflict || randomBoolean();
1753             final long conflictingVersion = docDeleted || randomBoolean() ?
1754                 lastOpVersion + (randomBoolean() ? 1 : -1) :
1755                 Versions.MATCH_DELETED;
1756             final long conflictingSeqNo = lastOpSeqNo == UNASSIGNED_SEQ_NO  || randomBoolean() ?
1757                 lastOpSeqNo + 5 :                 lastOpSeqNo;
1758             final long conflictingTerm = conflictingSeqNo == lastOpSeqNo || randomBoolean() ? lastOpTerm + 1 : lastOpTerm;
1759             if (rarely()) {
1760                 currentTerm.set(currentTerm.get() + 1L);
1761                 engine.rollTranslogGeneration();
1762             }
1763             final long correctVersion = docDeleted ? Versions.MATCH_DELETED : lastOpVersion;
1764             logger.info("performing [{}]{}{}",
1765                         op.operationType().name().charAt(0),
1766                         versionConflict ? " (conflict " + conflictingVersion + ")" : "",
1767                         versionedOp ? " (versioned " + correctVersion + ", seqNo " + lastOpSeqNo + ", term " + lastOpTerm + " )" : "");
1768             if (op instanceof Engine.Index) {
1769                 final Engine.Index index = (Engine.Index) op;
1770                 if (versionConflict) {
1771                     final Engine.IndexResult result;
1772                     if (randomBoolean()) {
1773                         result = engine.index(indexWithSeq.apply(conflictingSeqNo, conflictingTerm, index));
1774                     } else {
1775                         result = engine.index(indexWithVersion.apply(conflictingVersion, index));
1776                     }
1777                     assertThat(result.isCreated(), equalTo(false));
1778                     assertThat(result.getVersion(), equalTo(lastOpVersion));
1779                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
1780                     assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
1781                 } else {
1782                     final Engine.IndexResult result;
1783                     if (versionedOp) {
1784                         if (randomBoolean() &amp;&amp; lastOpSeqNo != SequenceNumbers.UNASSIGNED_SEQ_NO &amp;&amp; docDeleted == false) {
1785                             result = engine.index(indexWithSeq.apply(lastOpSeqNo, lastOpTerm, index));
1786                         } else {
1787                             result = engine.index(indexWithVersion.apply(correctVersion, index));
1788                         }
1789                     } else {
1790                         result = engine.index(indexWithCurrentTerm.apply(index));
1791                     }
1792                     assertThat(result.isCreated(), equalTo(docDeleted));
1793                     assertThat(result.getVersion(), equalTo(Math.max(lastOpVersion + 1, 1)));
1794                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
1795                     assertThat(result.getFailure(), nullValue());
1796                     lastFieldValue = index.docs().get(0).get("value");
1797                     assert lastFieldValue != null : "lastFieldValue is null after getting it from index docs";
1798                     docDeleted = false;
1799                     lastOpVersion = result.getVersion();
1800                     lastOpSeqNo = result.getSeqNo();
1801                     lastOpTerm = result.getTerm();
1802                     opsPerformed++;
1803                 }
1804             } else {
1805                 final Engine.Delete delete = (Engine.Delete) op;
1806                 if (versionConflict) {
1807                     Engine.DeleteResult result;
1808                     if (randomBoolean()) {
1809                         result = engine.delete(delWithSeq.apply(conflictingSeqNo, conflictingTerm, delete));
1810                     } else {
1811                         result = engine.delete(delWithVersion.apply(conflictingVersion, delete));
1812                     }
1813                     assertThat(result.isFound(), equalTo(docDeleted == false));
1814                     assertThat(result.getVersion(), equalTo(lastOpVersion));
1815                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
1816                     assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
1817                 } else {
1818                     final Engine.DeleteResult result;
1819                     long correctSeqNo = docDeleted ? UNASSIGNED_SEQ_NO : lastOpSeqNo;
1820                     if (versionedOp &amp;&amp; lastOpSeqNo != UNASSIGNED_SEQ_NO &amp;&amp; randomBoolean()) {
1821                         result = engine.delete(delWithSeq.apply(correctSeqNo, lastOpTerm, delete));
1822                     } else if (versionedOp) {
1823                         result = engine.delete(delWithVersion.apply(correctVersion, delete));
1824                     } else {
1825                         result = engine.delete(deleteWithCurrentTerm.apply(delete));
1826                     }
1827                     assertThat(result.isFound(), equalTo(docDeleted == false));
1828                     assertThat(result.getVersion(), equalTo(Math.max(lastOpVersion + 1, 1)));
1829                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
1830                     assertThat(result.getFailure(), nullValue());
1831                     docDeleted = true;
1832                     lastOpVersion = result.getVersion();
1833                     lastOpSeqNo = result.getSeqNo();
1834                     lastOpTerm = result.getTerm();
1835                     opsPerformed++;
1836                 }
1837             }
1838             if (randomBoolean()) {
1839                 assertVisibleCount(engine, docDeleted ? 0 : 1);
1840                 if (docDeleted == false &amp;&amp; lastFieldValue != null) {
1841                     try (Searcher searcher = engine.acquireSearcher("test")) {
1842                         final TotalHitCountCollector collector = new TotalHitCountCollector();
1843                         searcher.search(new TermQuery(new Term("value", lastFieldValue)), collector);
1844                         assertThat(collector.getTotalHits(), equalTo(1));
1845                     }
1846                 }
1847             }
1848             if (randomBoolean()) {
1849                 engine.flush();
1850                 engine.refresh("test");
1851             }
1852             if (rarely()) {
1853                 engine.refresh("gc_simulation", Engine.SearcherScope.INTERNAL, true);
1854                 engine.clearDeletedTombstones();
1855                 if (docDeleted) {
1856                     lastOpVersion = Versions.NOT_FOUND;
1857                     lastOpSeqNo = UNASSIGNED_SEQ_NO;
1858                     lastOpTerm = UNASSIGNED_PRIMARY_TERM;
1859                 }
1860             }
1861         }
1862         assertVisibleCount(engine, docDeleted ? 0 : 1);
1863         if (docDeleted == false) {
1864             try (Searcher searcher = engine.acquireSearcher("test")) {
1865                 final TotalHitCountCollector collector = new TotalHitCountCollector();
1866                 if (lastFieldValue != null) {
1867                     searcher.search(new TermQuery(new Term("value", lastFieldValue)), collector);
1868                     assertThat(collector.getTotalHits(), equalTo(1));
1869                 }
1870             }
1871         }
1872         return opsPerformed;
1873     }
1874     @Test
1875     public void testNonInternalVersioningOnPrimary() throws IOException {
1876         final Set&lt;VersionType&gt; nonInternalVersioning = new HashSet&lt;&gt;(Arrays.asList(VersionType.values()));
1877         nonInternalVersioning.remove(VersionType.INTERNAL);
1878         final VersionType versionType = randomFrom(nonInternalVersioning);
1879         final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
1880             false, versionType, 2, 2, 20, "1");
1881         final Engine.Operation lastOp = ops.get(ops.size() - 1);
1882         final String lastFieldValue;
1883         if (lastOp instanceof Engine.Index) {
1884             Engine.Index index = (Engine.Index) lastOp;
1885             lastFieldValue = index.docs().get(0).get("value");
1886         } else {
1887             lastFieldValue = null;
1888         }
1889         if (versionType == VersionType.EXTERNAL) {
1890             shuffle(ops, random());
1891         }
1892         long highestOpVersion = Versions.NOT_FOUND;
1893         long seqNo = -1;
1894         boolean docDeleted = true;
1895         for (Engine.Operation op : ops) {
1896             logger.info("performing [{}], v [{}], seq# [{}], term [{}]",
1897                         op.operationType().name().charAt(0), op.version(), op.seqNo(), op.primaryTerm());
1898             if (op instanceof Engine.Index) {
1899                 final Engine.Index index = (Engine.Index) op;
1900                 Engine.IndexResult result = engine.index(index);
1901                 if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {
1902                     seqNo++;
1903                     assertThat(result.getSeqNo(), equalTo(seqNo));
1904                     assertThat(result.isCreated(), equalTo(docDeleted));
1905                     assertThat(result.getVersion(), equalTo(op.version()));
1906                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
1907                     assertThat(result.getFailure(), nullValue());
1908                     docDeleted = false;
1909                     highestOpVersion = op.version();
1910                 } else {
1911                     assertThat(result.isCreated(), equalTo(false));
1912                     assertThat(result.getVersion(), equalTo(highestOpVersion));
1913                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
1914                     assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
1915                 }
1916             } else {
1917                 final Engine.Delete delete = (Engine.Delete) op;
1918                 Engine.DeleteResult result = engine.delete(delete);
1919                 if (op.versionType().isVersionConflictForWrites(highestOpVersion, op.version(), docDeleted) == false) {
1920                     seqNo++;
1921                     assertThat(result.getSeqNo(), equalTo(seqNo));
1922                     assertThat(result.isFound(), equalTo(docDeleted == false));
1923                     assertThat(result.getVersion(), equalTo(op.version()));
1924                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
1925                     assertThat(result.getFailure(), nullValue());
1926                     docDeleted = true;
1927                     highestOpVersion = op.version();
1928                 } else {
1929                     assertThat(result.isFound(), equalTo(docDeleted == false));
1930                     assertThat(result.getVersion(), equalTo(highestOpVersion));
1931                     assertThat(result.getResultType(), equalTo(Engine.Result.Type.FAILURE));
1932                     assertThat(result.getFailure(), instanceOf(VersionConflictEngineException.class));
1933                 }
1934             }
1935             if (randomBoolean()) {
1936                 engine.refresh("test");
1937             }
1938             if (randomBoolean()) {
1939                 engine.flush();
1940                 engine.refresh("test");
1941             }
1942         }
1943         assertVisibleCount(engine, docDeleted ? 0 : 1);
1944         if (docDeleted == false) {
1945             logger.info("searching for [{}]", lastFieldValue);
1946             try (Searcher searcher = engine.acquireSearcher("test")) {
1947                 final TotalHitCountCollector collector = new TotalHitCountCollector();
1948                 searcher.search(new TermQuery(new Term("value", lastFieldValue)), collector);
1949                 assertThat(collector.getTotalHits(), equalTo(1));
1950             }
1951         }
1952     }
1953     @Test
1954     public void testVersioningPromotedReplica() throws IOException {
1955         final List&lt;Engine.Operation&gt; replicaOps = generateSingleDocHistory(
1956             true, VersionType.INTERNAL, 1, 2, 20, "1");
1957         List&lt;Engine.Operation&gt; primaryOps = generateSingleDocHistory(
1958             false, VersionType.INTERNAL, 2, 2, 20, "1");
1959         Engine.Operation lastReplicaOp = replicaOps.get(replicaOps.size() - 1);
1960         final boolean deletedOnReplica = lastReplicaOp instanceof Engine.Delete;
1961         final long finalReplicaVersion = lastReplicaOp.version();
1962         final long finalReplicaSeqNo = lastReplicaOp.seqNo();
1963         assertOpsOnReplica(replicaOps, replicaEngine, true, logger);
1964         final int opsOnPrimary = assertOpsOnPrimary(primaryOps, finalReplicaVersion, deletedOnReplica, replicaEngine);
1965         final long currentSeqNo = getSequenceID(
1966             replicaEngine,
1967             new Engine.Get(lastReplicaOp.uid().text(), lastReplicaOp.uid())).v1();
1968         try (Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
1969             final TotalHitCountCollector collector = new TotalHitCountCollector();
1970             searcher.search(new MatchAllDocsQuery(), collector);
1971             if (collector.getTotalHits() &gt; 0) {
1972                 assertThat(currentSeqNo, equalTo(finalReplicaSeqNo + opsOnPrimary));
1973             }
1974         }
1975     }
1976     @Test
1977     public void testConcurrentExternalVersioningOnPrimary() throws IOException, InterruptedException {
1978         final List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
1979             false, VersionType.EXTERNAL, 2, 100, 300, "1");
1980         final Engine.Operation lastOp = ops.get(ops.size() - 1);
1981         final String lastFieldValue;
1982         if (lastOp instanceof Engine.Index) {
1983             Engine.Index index = (Engine.Index) lastOp;
1984             lastFieldValue = index.docs().get(0).get("value");
1985         } else {
1986             lastFieldValue = null;
1987         }
1988         shuffle(ops, random());
1989         concurrentlyApplyOps(ops, engine);
1990         assertVisibleCount(engine, lastFieldValue == null ? 0 : 1);
1991         if (lastFieldValue != null) {
1992             try (Searcher searcher = engine.acquireSearcher("test")) {
1993                 final TotalHitCountCollector collector = new TotalHitCountCollector();
1994                 searcher.search(new TermQuery(new Term("value", lastFieldValue)), collector);
1995                 assertThat(collector.getTotalHits(), equalTo(1));
1996             }
1997         }
1998     }
1999     @Test
2000     public void testConcurrentGetAndSetOnPrimary() throws IOException, InterruptedException {
2001         Thread[] thread = new Thread[randomIntBetween(3, 5)];
2002         CountDownLatch startGun = new CountDownLatch(thread.length);
2003         final int opsPerThread = randomIntBetween(10, 20);
2004         class OpAndVersion {
2005             final long version;
2006             final String removed;
2007             final String added;
2008             OpAndVersion(long version, String removed, String added) {
2009                 this.version = version;
2010                 this.removed = removed;
2011                 this.added = added;
2012             }
2013         }
2014         final AtomicInteger idGenerator = new AtomicInteger();
2015         final Queue&lt;OpAndVersion&gt; history = ConcurrentCollections.newQueue();
2016         ParsedDocument doc = testParsedDocument("1", null, testDocument(), bytesArray(""), null);
2017         final Term uidTerm = newUid(doc);
2018         engine.index(indexForDoc(doc));
2019         final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
2020         for (int i = 0; i &lt; thread.length; i++) {
2021             thread[i] = new Thread(() -&gt; {
2022                 startGun.countDown();
2023                 try {
2024                     startGun.await();
2025                 } catch (InterruptedException e) {
2026                     throw new AssertionError(e);
2027                 }
2028                 for (int op = 0; op &lt; opsPerThread; op++) {
2029                     try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), uidTerm), searcherFactory)) {
2030                         FieldsVisitor visitor = new FieldsVisitor(true);
2031                         get.docIdAndVersion().reader.document(get.docIdAndVersion().docId, visitor);
2032                         List&lt;String&gt; values = new ArrayList&lt;&gt;(Strings.commaDelimitedListToSet(visitor.source().utf8ToString()));
2033                         String removed = op % 3 == 0 &amp;&amp; values.size() &gt; 0 ? values.remove(0) : null;
2034                         String added = "v_" + idGenerator.incrementAndGet();
2035                         values.add(added);
2036                         Engine.Index index = new Engine.Index(uidTerm,
2037                                                               testParsedDocument("1", null, testDocument(),
2038                                                                                  bytesArray(Strings.collectionToCommaDelimitedString(values)), null),
2039                                                               UNASSIGNED_SEQ_NO, 2,
2040                                                               get.docIdAndVersion().version, VersionType.INTERNAL,
2041                                                               PRIMARY, System.currentTimeMillis(), -1, false, UNASSIGNED_SEQ_NO, 0);
2042                         Engine.IndexResult indexResult = engine.index(index);
2043                         if (indexResult.getResultType() == Engine.Result.Type.SUCCESS) {
2044                             history.add(new OpAndVersion(indexResult.getVersion(), removed, added));
2045                         }
2046                     } catch (IOException e) {
2047                         throw new AssertionError(e);
2048                     }
2049                 }
2050             });
2051             thread[i].start();
2052         }
2053         for (int i = 0; i &lt; thread.length; i++) {
2054             thread[i].join();
2055         }
2056         List&lt;OpAndVersion&gt; sortedHistory = new ArrayList&lt;&gt;(history);
2057         sortedHistory.sort(Comparator.comparing(o -&gt; o.version));
2058         Set&lt;String&gt; currentValues = new HashSet&lt;&gt;();
2059         for (int i = 0; i &lt; sortedHistory.size(); i++) {
2060             OpAndVersion op = sortedHistory.get(i);
2061             if (i &gt; 0) {
2062                 assertThat("duplicate version", op.version, not(equalTo(sortedHistory.get(i - 1).version)));
2063             }
2064             boolean exists = op.removed == null ? true : currentValues.remove(op.removed);
2065             assertTrue(op.removed + " should exist", exists);
2066             exists = currentValues.add(op.added);
2067             assertTrue(op.added + " should not exist", exists);
2068         }
2069         try (Engine.GetResult get = engine.get(new Engine.Get(doc.id(), uidTerm), searcherFactory)) {
2070             FieldsVisitor visitor = new FieldsVisitor(true);
2071             get.docIdAndVersion().reader.document(get.docIdAndVersion().docId, visitor);
2072             List&lt;String&gt; values = Arrays.asList(Strings.commaDelimitedListToStringArray(visitor.source().utf8ToString()));
2073             assertThat(currentValues, equalTo(new HashSet&lt;&gt;(values)));
2074         }
2075     }
2076     @Test
2077     public void testBasicCreatedFlag() throws IOException {
2078         ParsedDocument doc = testParsedDocument("1", null, testDocument(), B_1, null);
2079         Engine.Index index = indexForDoc(doc);
2080         Engine.IndexResult indexResult = engine.index(index);
2081         assertTrue(indexResult.isCreated());
2082         index = indexForDoc(doc);
2083         indexResult = engine.index(index);
2084         assertFalse(indexResult.isCreated());
2085         engine.delete(new Engine.Delete(
2086             "1",
2087             newUid(doc),
2088             UNASSIGNED_SEQ_NO,
2089             primaryTerm.get(),
2090             Versions.MATCH_ANY,
2091             VersionType.INTERNAL,
2092             Engine.Operation.Origin.PRIMARY,
2093             System.nanoTime(),
2094             UNASSIGNED_SEQ_NO,
2095             0
2096         ));
2097         index = indexForDoc(doc);
2098         indexResult = engine.index(index);
2099         assertTrue(indexResult.isCreated());
2100     }
2101     private static class MockAppender extends AbstractAppender {
2102         public boolean sawIndexWriterMessage;
2103         public boolean sawIndexWriterIFDMessage;
2104         MockAppender(final String name) throws IllegalAccessException {
2105             super(name, RegexFilter.createFilter(".*(\n.*)*", new String[0],
2106                                                  false, null, null), null);
2107         }
2108         @Override
2109         public void append(LogEvent event) {
2110             final String formattedMessage = event.getMessage().getFormattedMessage();
2111             if (event.getLevel() == Level.TRACE &amp;&amp; event.getMarker().getName().contains("[index][0]")) {
2112                 if (event.getLoggerName().endsWith(".IW") &amp;&amp;
2113                     formattedMessage.contains("IW: now apply all deletes")) {
2114                     sawIndexWriterMessage = true;
2115                 }
2116                 if (event.getLoggerName().endsWith(".IFD")) {
2117                     sawIndexWriterIFDMessage = true;
2118                 }
2119             }
2120         }
2121     }
2122     @Test
2123     public void testIndexWriterInfoStream() throws IllegalAccessException, IOException {
2124         assumeFalse("who tests the tester?", VERBOSE);
2125         MockAppender mockAppender = new MockAppender("testIndexWriterInfoStream");
2126         mockAppender.start();
2127         Logger rootLogger = LogManager.getRootLogger();
2128         Level savedLevel = rootLogger.getLevel();
2129         Loggers.addAppender(rootLogger, mockAppender);
2130         Loggers.setLevel(rootLogger, Level.DEBUG);
2131         rootLogger = LogManager.getRootLogger();
2132         try {
2133             ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
2134             engine.index(indexForDoc(doc));
2135             engine.flush();
2136             assertFalse(mockAppender.sawIndexWriterMessage);
2137             Loggers.setLevel(rootLogger, Level.TRACE);
2138             engine.index(indexForDoc(doc));
2139             engine.flush();
2140             assertTrue(mockAppender.sawIndexWriterMessage);
2141         } finally {
2142             Loggers.removeAppender(rootLogger, mockAppender);
2143             mockAppender.stop();
2144             Loggers.setLevel(rootLogger, savedLevel);
2145         }
2146     }
2147     @Test
2148     public void testSeqNoAndCheckpoints() throws IOException, InterruptedException {
2149         final int opCount = randomIntBetween(1, 256);
2150         long primarySeqNo = SequenceNumbers.NO_OPS_PERFORMED;
2151         final String[] ids = new String[]{"1", "2", "3"};
2152         final Set&lt;String&gt; indexedIds = new HashSet&lt;&gt;();
2153         long localCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
2154         long replicaLocalCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
2155         final long globalCheckpoint;
2156         long maxSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
2157         IOUtils.close(store, engine);
2158         store = createStore();
2159         InternalEngine initialEngine = null;
2160         try {
2161             initialEngine = createEngine(defaultSettings, store, createTempDir(), newLogMergePolicy(), null);
2162             final ShardRouting primary = TestShardRouting.newShardRouting("test",
2163                                                                           shardId.id(), "node1", null, true,
2164                                                                           ShardRoutingState.STARTED, allocationId);
2165             final ShardRouting initializingReplica =
2166                 TestShardRouting.newShardRouting(shardId, "node2", false, ShardRoutingState.INITIALIZING);
2167             ReplicationTracker gcpTracker = (ReplicationTracker) initialEngine.config().getGlobalCheckpointSupplier();
2168             gcpTracker.updateFromMaster(1L, new HashSet&lt;&gt;(Collections.singletonList(primary.allocationId().getId())),
2169                 new IndexShardRoutingTable.Builder(shardId).addShard(primary).build());
2170             gcpTracker.activatePrimaryMode(primarySeqNo);
2171             if (defaultSettings.isSoftDeleteEnabled()) {
2172                 final CountDownLatch countDownLatch = new CountDownLatch(1);
2173                 gcpTracker.addPeerRecoveryRetentionLease(initializingReplica.currentNodeId(),
2174                     SequenceNumbers.NO_OPS_PERFORMED, ActionListener.wrap(countDownLatch::countDown));
2175                 countDownLatch.await(5, TimeUnit.SECONDS);
2176             }
2177             gcpTracker.updateFromMaster(2L, new HashSet&lt;&gt;(Collections.singletonList(primary.allocationId().getId())),
2178                 new IndexShardRoutingTable.Builder(shardId).addShard(primary).addShard(initializingReplica).build());
2179             gcpTracker.initiateTracking(initializingReplica.allocationId().getId());
2180             gcpTracker.markAllocationIdAsInSync(initializingReplica.allocationId().getId(), replicaLocalCheckpoint);
2181             final ShardRouting replica = initializingReplica.moveToStarted();
2182             gcpTracker.updateFromMaster(3L, new HashSet&lt;&gt;(Arrays.asList(primary.allocationId().getId(), replica.allocationId().getId())),
2183                 new IndexShardRoutingTable.Builder(shardId).addShard(primary).addShard(replica).build());
2184             for (int op = 0; op &lt; opCount; op++) {
2185                 final String id;
2186                 if (rarely() &amp;&amp; indexedIds.isEmpty() == false) {
2187                     id = randomFrom(indexedIds);
2188                     final Engine.Delete delete = new Engine.Delete(
2189                         id,
2190                         newUid(id),
2191                         UNASSIGNED_SEQ_NO,
2192                         primaryTerm.get(),
2193                         rarely() ? 100 : Versions.MATCH_ANY,
2194                         VersionType.INTERNAL,
2195                         PRIMARY,
2196                         System.nanoTime(),
2197                         UNASSIGNED_SEQ_NO,
2198                         0
2199                     );
2200                     final Engine.DeleteResult result = initialEngine.delete(delete);
2201                     if (result.getResultType() == Engine.Result.Type.SUCCESS) {
2202                         assertThat(result.getSeqNo(), equalTo(primarySeqNo + 1));
2203                         assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo + 1));
2204                         indexedIds.remove(id);
2205                         primarySeqNo++;
2206                     } else {
2207                         assertThat(result.getSeqNo(), equalTo(UNASSIGNED_SEQ_NO));
2208                         assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
2209                     }
2210                 } else {
2211                     id = randomFrom(ids);
2212                     ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
2213                     final Engine.Index index = new Engine.Index(newUid(doc), doc,
2214                                                                 UNASSIGNED_SEQ_NO, primaryTerm.get(),
2215                                                                 rarely() ? 100 : Versions.MATCH_ANY, VersionType.INTERNAL,
2216                                                                 PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2217                     final Engine.IndexResult result = initialEngine.index(index);
2218                     if (result.getResultType() == Engine.Result.Type.SUCCESS) {
2219                         assertThat(result.getSeqNo(), equalTo(primarySeqNo + 1));
2220                         assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo + 1));
2221                         indexedIds.add(id);
2222                         primarySeqNo++;
2223                     } else {
2224                         assertThat(result.getSeqNo(), equalTo(UNASSIGNED_SEQ_NO));
2225                         assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
2226                     }
2227                 }
2228                 initialEngine.syncTranslog(); 
2229                 if (randomInt(10) &lt; 3) {
2230                     replicaLocalCheckpoint = randomIntBetween(Math.toIntExact(replicaLocalCheckpoint), Math.toIntExact(primarySeqNo));
2231                 }
2232                 gcpTracker.updateLocalCheckpoint(primary.allocationId().getId(),
2233                     initialEngine.getPersistedLocalCheckpoint());
2234                 gcpTracker.updateLocalCheckpoint(initializingReplica.allocationId().getId(), replicaLocalCheckpoint);
2235                 if (rarely()) {
2236                     localCheckpoint = primarySeqNo;
2237                     maxSeqNo = primarySeqNo;
2238                     initialEngine.flush(true, true);
2239                 }
2240             }
2241             logger.info("localcheckpoint {}, global {}", replicaLocalCheckpoint, primarySeqNo);
2242             globalCheckpoint = gcpTracker.getGlobalCheckpoint();
2243             assertEquals(primarySeqNo, initialEngine.getSeqNoStats(-1).getMaxSeqNo());
2244             assertEquals(primarySeqNo, initialEngine.getPersistedLocalCheckpoint());
2245             assertThat(globalCheckpoint, equalTo(replicaLocalCheckpoint));
2246             assertThat(
2247                 Long.parseLong(initialEngine.commitStats().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
2248                 equalTo(localCheckpoint));
2249             initialEngine.getTranslog().sync();             assertThat(
2250                 initialEngine.getTranslog().getLastSyncedGlobalCheckpoint(),
2251                 equalTo(globalCheckpoint));
2252             assertThat(
2253                 Long.parseLong(initialEngine.commitStats().getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
2254                 equalTo(maxSeqNo));
2255         } finally {
2256             IOUtils.close(initialEngine);
2257         }
2258         try (InternalEngine recoveringEngine = new InternalEngine(initialEngine.config())) {
2259             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2260             assertEquals(primarySeqNo, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
2261             assertThat(
2262                 Long.parseLong(recoveringEngine.commitStats().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)),
2263                 equalTo(primarySeqNo));
2264             assertThat(
2265                 recoveringEngine.getTranslog().getLastSyncedGlobalCheckpoint(),
2266                 equalTo(globalCheckpoint));
2267             assertThat(
2268                 Long.parseLong(recoveringEngine.commitStats().getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
2269                 equalTo(primarySeqNo));
2270             assertThat(recoveringEngine.getProcessedLocalCheckpoint(), equalTo(primarySeqNo));
2271             assertThat(recoveringEngine.getPersistedLocalCheckpoint(), equalTo(primarySeqNo));
2272             assertThat(recoveringEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo(primarySeqNo));
2273             assertThat(generateNewSeqNo(recoveringEngine), equalTo(primarySeqNo + 1));
2274         }
2275     }
2276     @Test
2277     public void testConcurrentWritesAndCommits() throws Exception {
2278         List&lt;Engine.IndexCommitRef&gt; commits = new ArrayList&lt;&gt;();
2279         try (Store store = createStore();
2280              InternalEngine engine = createEngine(config(defaultSettings, store, createTempDir(), newMergePolicy(), null))) {
2281             final int numIndexingThreads = scaledRandomIntBetween(2, 4);
2282             final int numDocsPerThread = randomIntBetween(500, 1000);
2283             final CyclicBarrier barrier = new CyclicBarrier(numIndexingThreads + 1);
2284             final List&lt;Thread&gt; indexingThreads = new ArrayList&lt;&gt;();
2285             final CountDownLatch doneLatch = new CountDownLatch(numIndexingThreads);
2286             for (int threadNum = 0; threadNum &lt; numIndexingThreads; threadNum++) {
2287                 final int threadIdx = threadNum;
2288                 Thread indexingThread = new Thread(() -&gt; {
2289                     try {
2290                         barrier.await();                         for (int i = 0; i &lt; numDocsPerThread; i++) {
2291                             final String id = "thread" + threadIdx + "#" + i;
2292                             ParsedDocument doc = testParsedDocument(id, null, testDocument(), B_1, null);
2293                             engine.index(indexForDoc(doc));
2294                         }
2295                     } catch (Exception e) {
2296                         throw new RuntimeException(e);
2297                     } finally {
2298                         doneLatch.countDown();
2299                     }
2300                 });
2301                 indexingThreads.add(indexingThread);
2302             }
2303             for (Thread thread : indexingThreads) {
2304                 thread.start();
2305             }
2306             barrier.await();             int commitLimit = randomIntBetween(10, 20);
2307             long sleepTime = 1;
2308             boolean doneIndexing;
2309             do {
2310                 doneIndexing = doneLatch.await(sleepTime, TimeUnit.MILLISECONDS);
2311                 commits.add(engine.acquireLastIndexCommit(true));
2312                 if (commits.size() &gt; commitLimit) {                     IOUtils.close(commits.remove(randomIntBetween(0, commits.size()-1)));
2313                     sleepTime = sleepTime * 2;
2314                 }
2315             } while (doneIndexing == false);
2316             long prevLocalCheckpoint = SequenceNumbers.NO_OPS_PERFORMED;
2317             long prevMaxSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
2318             for (Engine.IndexCommitRef commitRef : commits) {
2319                 final IndexCommit commit = commitRef.getIndexCommit();
2320                 Map&lt;String, String&gt; userData = commit.getUserData();
2321                 long localCheckpoint = userData.containsKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY) ?
2322                     Long.parseLong(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) :
2323                     SequenceNumbers.NO_OPS_PERFORMED;
2324                 long maxSeqNo = userData.containsKey(SequenceNumbers.MAX_SEQ_NO) ?
2325                     Long.parseLong(userData.get(SequenceNumbers.MAX_SEQ_NO)) :
2326                     UNASSIGNED_SEQ_NO;
2327                 assertThat(localCheckpoint, greaterThanOrEqualTo(prevLocalCheckpoint));
2328                 assertThat(maxSeqNo, greaterThanOrEqualTo(prevMaxSeqNo));
2329                 try (IndexReader reader = DirectoryReader.open(commit)) {
2330                     Long highest = getHighestSeqNo(reader);
2331                     final long highestSeqNo;
2332                     if (highest != null) {
2333                         highestSeqNo = highest.longValue();
2334                     } else {
2335                         highestSeqNo = SequenceNumbers.NO_OPS_PERFORMED;
2336                     }
2337                     assertThat(highestSeqNo, greaterThanOrEqualTo(localCheckpoint));
2338                     assertThat(highestSeqNo, lessThanOrEqualTo(maxSeqNo));
2339                     FixedBitSet seqNosBitSet = getSeqNosSet(reader, highestSeqNo);
2340                     for (int i = 0; i &lt;= localCheckpoint; i++) {
2341                         assertTrue("local checkpoint [" + localCheckpoint + "], _seq_no [" + i + "] should be indexed",
2342                                    seqNosBitSet.get(i));
2343                     }
2344                 }
2345                 prevLocalCheckpoint = localCheckpoint;
2346                 prevMaxSeqNo = maxSeqNo;
2347             }
2348         }
2349     }
2350     private static Long getHighestSeqNo(final IndexReader reader) throws IOException {
2351         final String fieldName = SeqNoFieldMapper.NAME;
2352         long size = PointValues.size(reader, fieldName);
2353         if (size == 0) {
2354             return null;
2355         }
2356         byte[] max = PointValues.getMaxPackedValue(reader, fieldName);
2357         return LongPoint.decodeDimension(max, 0);
2358     }
2359     private static FixedBitSet getSeqNosSet(final IndexReader reader, final long highestSeqNo) throws IOException {
2360         final FixedBitSet bitSet = new FixedBitSet((int) highestSeqNo + 1);
2361         final List&lt;LeafReaderContext&gt; leaves = reader.leaves();
2362         if (leaves.isEmpty()) {
2363             return bitSet;
2364         }
2365         for (int i = 0; i &lt; leaves.size(); i++) {
2366             final LeafReader leaf = leaves.get(i).reader();
2367             final NumericDocValues values = leaf.getNumericDocValues(SeqNoFieldMapper.NAME);
2368             if (values == null) {
2369                 continue;
2370             }
2371             final Bits bits = leaf.getLiveDocs();
2372             for (int docID = 0; docID &lt; leaf.maxDoc(); docID++) {
2373                 if (bits == null || bits.get(docID)) {
2374                     if (values.advanceExact(docID) == false) {
2375                         throw new AssertionError("Document does not have a seq number: " + docID);
2376                     }
2377                     final long seqNo = values.longValue();
2378                     assertFalse("should not have more than one document with the same seq_no[" +
2379                                 seqNo + "]", bitSet.get((int) seqNo));
2380                     bitSet.set((int) seqNo);
2381                 }
2382             }
2383         }
2384         return bitSet;
2385     }
2386     @Test
2387     public void testIndexWriterIFDInfoStream() throws IllegalAccessException, IOException {
2388         assumeFalse("who tests the tester?", VERBOSE);
2389         MockAppender mockAppender = new MockAppender("testIndexWriterIFDInfoStream");
2390         mockAppender.start();
2391         final Logger iwIFDLogger = LogManager.getLogger("org.elasticsearch.index.engine.Engine.IFD");
2392         Loggers.addAppender(iwIFDLogger, mockAppender);
2393         Loggers.setLevel(iwIFDLogger, Level.DEBUG);
2394         try {
2395             ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
2396             engine.index(indexForDoc(doc));
2397             engine.flush();
2398             assertFalse(mockAppender.sawIndexWriterMessage);
2399             assertFalse(mockAppender.sawIndexWriterIFDMessage);
2400             Loggers.setLevel(iwIFDLogger, Level.TRACE);
2401             engine.index(indexForDoc(doc));
2402             engine.flush();
2403             assertFalse(mockAppender.sawIndexWriterMessage);
2404             assertTrue(mockAppender.sawIndexWriterIFDMessage);
2405         } finally {
2406             Loggers.removeAppender(iwIFDLogger, mockAppender);
2407             mockAppender.stop();
2408             Loggers.setLevel(iwIFDLogger, (Level) null);
2409         }
2410     }
2411     @Test
2412     public void testEnableGcDeletes() throws Exception {
2413         try (Store store = createStore();
2414              Engine engine = createEngine(config(defaultSettings, store, createTempDir(), newMergePolicy(), null))) {
2415             engine.config().setEnableGcDeletes(false);
2416             final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
2417             Document document = testDocument();
2418             document.add(new TextField("value", "test1", Field.Store.YES));
2419             ParsedDocument doc = testParsedDocument("1", null, document, B_2, null);
2420             engine.index(new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 1,
2421                                           VersionType.EXTERNAL,
2422                                           Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));
2423             engine.delete(new Engine.Delete(
2424                 "1",
2425                 newUid(doc),
2426                 UNASSIGNED_SEQ_NO,
2427                 0,
2428                 10,
2429                 VersionType.EXTERNAL,
2430                 Engine.Operation.Origin.PRIMARY,
2431                 System.nanoTime(),
2432                 UNASSIGNED_SEQ_NO,
2433                 0
2434             ));
2435             Engine.GetResult getResult = engine.get(newGet(doc), searcherFactory);
2436             assertThat(getResult.docIdAndVersion(), is(nullValue()));
2437             Thread.sleep(1000);
2438             if (randomBoolean()) {
2439                 engine.refresh("test");
2440             }
2441             engine.delete(new Engine.Delete(
2442                 "2",
2443                 newUid("2"),
2444                 UNASSIGNED_SEQ_NO,
2445                 0,
2446                 10,
2447                 VersionType.EXTERNAL,
2448                 Engine.Operation.Origin.PRIMARY,
2449                 System.nanoTime(),
2450                 UNASSIGNED_SEQ_NO,
2451                 0
2452             ));
2453             getResult = engine.get(new Engine.Get("2", newUid("2")), searcherFactory);
2454             assertThat(getResult.docIdAndVersion(), is(nullValue()));
2455             Engine.Index index = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 2,
2456                                                   VersionType.EXTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2457             Engine.IndexResult indexResult = engine.index(index);
2458             assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
2459             assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));
2460             getResult = engine.get(newGet(doc), searcherFactory);
2461             assertThat(getResult.docIdAndVersion(), is(nullValue()));
2462             Engine.Index index1 = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0, 2,
2463                                                    VersionType.EXTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2464             indexResult = engine.index(index1);
2465             assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.FAILURE));
2466             assertThat(indexResult.getFailure(), instanceOf(VersionConflictEngineException.class));
2467             getResult = engine.get(newGet(doc), searcherFactory);
2468             assertThat(getResult.docIdAndVersion(), is(nullValue()));
2469         }
2470     }
2471     @Test
2472     public void testExtractShardId() {
2473         try (Engine.Searcher test = this.engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
2474             ShardId shardId = ShardUtils.extractShardId(test.getDirectoryReader());
2475             assertNotNull(shardId);
2476             assertEquals(shardId, engine.config().getShardId());
2477         }
2478     }
2479     @Test
2480     public void testFailStart() throws IOException {
2481         final int iters = scaledRandomIntBetween(10, 100);
2482         for (int i = 0; i &lt; iters; i++) {
2483             MockDirectoryWrapper wrapper = newMockDirectory();
2484             wrapper.setFailOnOpenInput(randomBoolean());
2485             wrapper.setAllowRandomFileNotFoundException(randomBoolean());
2486             wrapper.setRandomIOExceptionRate(randomDouble());
2487             wrapper.setRandomIOExceptionRateOnOpen(randomDouble());
2488             final Path translogPath = createTempDir("testFailStart");
2489             try (Store store = createStore(wrapper)) {
2490                 int refCount = store.refCount();
2491                 assertTrue("refCount: " + store.refCount(), store.refCount() &gt; 0);
2492                 InternalEngine holder;
2493                 try {
2494                     holder = createEngine(store, translogPath);
2495                 } catch (EngineCreationFailureException | IOException ex) {
2496                     assertEquals(store.refCount(), refCount);
2497                     continue;
2498                 }
2499                 assertEquals(store.refCount(), refCount + 1);
2500                 final int numStarts = scaledRandomIntBetween(1, 5);
2501                 for (int j = 0; j &lt; numStarts; j++) {
2502                     try {
2503                         assertEquals(store.refCount(), refCount + 1);
2504                         holder.close();
2505                         holder = createEngine(store, translogPath);
2506                         assertEquals(store.refCount(), refCount + 1);
2507                     } catch (EngineCreationFailureException ex) {
2508                         assertEquals(store.refCount(), refCount);
2509                         break;
2510                     }
2511                 }
2512                 holder.close();
2513                 assertEquals(store.refCount(), refCount);
2514             }
2515         }
2516     }
2517     @Test
2518     public void testSettings() {
2519         CodecService codecService = new CodecService(null, logger);
2520         LiveIndexWriterConfig currentIndexWriterConfig = engine.getCurrentIndexWriterConfig();
2521         assertEquals(engine.config().getCodec().getName(), codecService.codec(codecName).getName());
2522         assertEquals(currentIndexWriterConfig.getCodec().getName(), codecService.codec(codecName).getName());
2523     }
2524     @Test
2525     public void testCurrentTranslogIDisCommitted() throws IOException {
2526         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
2527         try (Store store = createStore()) {
2528             EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null,
2529                                          globalCheckpoint::get);
2530             {
2531                 store.createEmpty(Version.CURRENT.luceneVersion);
2532                 final String translogUUID =
2533                     Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
2534                                                  SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
2535                 store.associateIndexWithNewTranslog(translogUUID);
2536                 ParsedDocument doc = testParsedDocument(Integer.toString(0), null, testDocument(),
2537                                                         new BytesArray("{}"), null);
2538                 Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
2539                                                                   Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2540                 try (InternalEngine engine = createEngine(config)) {
2541                     engine.index(firstIndexRequest);
2542                     engine.syncTranslog();                     assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
2543                     globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
2544                     expectThrows(IllegalStateException.class, () -&gt; engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE));
2545                     Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
2546                     assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2547                 }
2548             }
2549             {
2550                 for (int i = 0; i &lt; 2; i++) {
2551                     try (InternalEngine engine = new InternalEngine(config)) {
2552                         expectThrows(IllegalStateException.class, engine::ensureCanFlush);
2553                         Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
2554                         assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2555                         engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2556                         userData = engine.getLastCommittedSegmentInfos().getUserData();
2557                         assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2558                     }
2559                 }
2560             }
2561             {
2562                 final String translogUUID =
2563                     Translog.createEmptyTranslog(config.getTranslogConfig().getTranslogPath(),
2564                                                  SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
2565                 store.associateIndexWithNewTranslog(translogUUID);
2566                 try (InternalEngine engine = new InternalEngine(config)) {
2567                     Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
2568                     assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2569                     engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2570                     assertEquals(2, engine.getTranslog().currentFileGeneration());
2571                 }
2572             }
2573             {
2574                 for (int i = 0; i &lt; 2; i++) {
2575                     try (InternalEngine engine = new InternalEngine(config)) {
2576                         Map&lt;String, String&gt; userData = engine.getLastCommittedSegmentInfos().getUserData();
2577                         assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2578                         engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2579                         userData = engine.getLastCommittedSegmentInfos().getUserData();
2580                         assertEquals(engine.getTranslog().getTranslogUUID(), userData.get(Translog.TRANSLOG_UUID_KEY));
2581                     }
2582                 }
2583             }
2584         }
2585     }
2586     @Test
2587     public void testMissingTranslog() throws IOException {
2588         engine.close();
2589         final long newPrimaryTerm = randomLongBetween(0L, primaryTerm.get());
2590         final Translog translog = createTranslog(() -&gt; newPrimaryTerm);
2591         long id = translog.currentFileGeneration();
2592         translog.close();
2593         IOUtils.rm(translog.location().resolve(Translog.getFilename(id)));
2594         expectThrows(EngineCreationFailureException.class, "engine shouldn't start without a valid translog id",
2595             () -&gt; createEngine(store, primaryTranslogDir));
2596         final String translogUUID = Translog.createEmptyTranslog(primaryTranslogDir, UNASSIGNED_SEQ_NO, shardId, newPrimaryTerm);
2597         store.associateIndexWithNewTranslog(translogUUID);
2598         EngineConfig config = config(defaultSettings, store, primaryTranslogDir, newMergePolicy(), null);
2599         engine = new InternalEngine(config);
2600     }
2601     @Test
2602     public void testTranslogReplayWithFailure() throws IOException {
2603         final MockDirectoryWrapper directory = newMockDirectory();
2604         final Path translogPath = createTempDir("testTranslogReplayWithFailure");
2605         try (Store store = createStore(directory)) {
2606             final int numDocs = randomIntBetween(1, 10);
2607             try (InternalEngine engine = createEngine(store, translogPath)) {
2608                 for (int i = 0; i &lt; numDocs; i++) {
2609                     ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null);
2610                     Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
2611                                                                       Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2612                     Engine.IndexResult indexResult = engine.index(firstIndexRequest);
2613                     assertThat(indexResult.getVersion(), equalTo(1L));
2614                 }
2615                 assertVisibleCount(engine, numDocs);
2616             }
2617             final int numIters = randomIntBetween(3, 5);
2618             for (int i = 0; i &lt; numIters; i++) {
2619                 directory.setRandomIOExceptionRateOnOpen(randomDouble());
2620                 directory.setRandomIOExceptionRate(randomDouble());
2621                 directory.setFailOnOpenInput(randomBoolean());
2622                 directory.setAllowRandomFileNotFoundException(randomBoolean());
2623                 boolean started = false;
2624                 InternalEngine engine = null;
2625                 try {
2626                     engine = createEngine(store, translogPath);
2627                     started = true;
2628                 } catch (EngineException | IOException e) {
2629                     logger.trace("exception on open", e);
2630                 }
2631                 directory.setRandomIOExceptionRateOnOpen(0.0);
2632                 directory.setRandomIOExceptionRate(0.0);
2633                 directory.setFailOnOpenInput(false);
2634                 directory.setAllowRandomFileNotFoundException(false);
2635                 if (started) {
2636                     engine.refresh("warm_up");
2637                     assertVisibleCount(engine, numDocs, false);
2638                     engine.close();
2639                 }
2640             }
2641         }
2642     }
2643     @Test
2644     public void testTranslogCleanUpPostCommitCrash() throws Exception {
2645         IndexSettings indexSettings = new IndexSettings(defaultSettings.getIndexMetadata(), defaultSettings.getNodeSettings(),
2646                                                         defaultSettings.getScopedSettings());
2647         IndexMetadata.Builder builder = IndexMetadata.builder(indexSettings.getIndexMetadata());
2648         builder.settings(Settings.builder().put(indexSettings.getSettings())
2649                              .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), "-1")
2650                              .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), "-1")
2651         );
2652         indexSettings.updateIndexMetadata(builder.build());
2653         try (Store store = createStore()) {
2654             AtomicBoolean throwErrorOnCommit = new AtomicBoolean();
2655             final Path translogPath = createTempDir();
2656             final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
2657             final LongSupplier globalCheckpointSupplier = globalCheckpoint::get;
2658             store.createEmpty(Version.CURRENT.luceneVersion);
2659             final String translogUUID = Translog.createEmptyTranslog(translogPath, globalCheckpoint.get(), shardId, primaryTerm.get());
2660             store.associateIndexWithNewTranslog(translogUUID);
2661             try (InternalEngine engine =
2662                      new InternalEngine(config(indexSettings, store, translogPath, newMergePolicy(), null, null,
2663                                                globalCheckpointSupplier)) {
2664                          @Override
2665                          protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
2666                              super.commitIndexWriter(writer, translog, syncId);
2667                              if (throwErrorOnCommit.get()) {
2668                                  throw new RuntimeException("power's out");
2669                              }
2670                          }
2671                      }) {
2672                 engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2673                 final ParsedDocument doc1 = testParsedDocument("1", null,
2674                                                                testDocumentWithTextField(), SOURCE, null);
2675                 engine.index(indexForDoc(doc1));
2676                 engine.syncTranslog();                 assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
2677                 globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
2678                 throwErrorOnCommit.set(true);
2679                 FlushFailedEngineException e = expectThrows(FlushFailedEngineException.class, engine::flush);
2680                 assertThat(e.getCause().getMessage(), equalTo("power's out"));
2681             }
2682             try (InternalEngine engine =
2683                      new InternalEngine(config(indexSettings, store, translogPath, newMergePolicy(), null, null,
2684                                                globalCheckpointSupplier))) {
2685                 engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2686                 assertVisibleCount(engine, 1);
2687                 final long localCheckpoint = Long.parseLong(
2688                     engine.getLastCommittedSegmentInfos().userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
2689                 final long committedGen = engine.getTranslog().getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration;
2690                 for (int gen = 1; gen &lt; committedGen; gen++) {
2691                     final Path genFile = translogPath.resolve(Translog.getFilename(gen));
2692                     assertFalse(genFile + " wasn't cleaned up", Files.exists(genFile));
2693                 }
2694             }
2695         }
2696     }
2697     @Test
2698     public void testSkipTranslogReplay() throws IOException {
2699         final int numDocs = randomIntBetween(1, 10);
2700         for (int i = 0; i &lt; numDocs; i++) {
2701             ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null);
2702             Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 0,
2703                                                               Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2704             Engine.IndexResult indexResult = engine.index(firstIndexRequest);
2705             assertThat(indexResult.getVersion(), equalTo(1L));
2706         }
2707         EngineConfig config = engine.config();
2708         assertVisibleCount(engine, numDocs);
2709         engine.close();
2710         try (InternalEngine engine = new InternalEngine(config)) {
2711             engine.skipTranslogRecovery();
2712             try (Engine.Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
2713                 TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), randomIntBetween(numDocs, numDocs + 10));
2714                 assertThat(topDocs.totalHits.value, equalTo(0L));
2715             }
2716         }
2717     }
2718     @Test
2719     public void testTranslogReplay() throws IOException {
2720         final LongSupplier inSyncGlobalCheckpointSupplier = () -&gt; this.engine.getProcessedLocalCheckpoint();
2721         final int numDocs = randomIntBetween(1, 10);
2722         for (int i = 0; i &lt; numDocs; i++) {
2723             ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null);
2724             Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
2725                                                               Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2726             Engine.IndexResult indexResult = engine.index(firstIndexRequest);
2727             assertThat(indexResult.getVersion(), equalTo(1L));
2728         }
2729         assertVisibleCount(engine, numDocs);
2730         translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());
2731         engine.close();
2732         engine = new InternalEngine(copy(engine.config(), inSyncGlobalCheckpointSupplier));
2733         engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
2734         engine.refresh("warm_up");
2735         assertVisibleCount(engine, numDocs, false);
2736         engine.close();
2737         translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());
2738         engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
2739         engine.refresh("warm_up");
2740         assertVisibleCount(engine, numDocs, false);
2741         final boolean flush = randomBoolean();
2742         int randomId = randomIntBetween(numDocs + 1, numDocs + 10);
2743         ParsedDocument doc = testParsedDocument(Integer.toString(randomId), null, testDocument(), new BytesArray("{}"), null);
2744         Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, 1,
2745                                                           VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2746         Engine.IndexResult indexResult = engine.index(firstIndexRequest);
2747         assertThat(indexResult.getVersion(), equalTo(1L));
2748         if (flush) {
2749             engine.flush();
2750             engine.refresh("test");
2751         }
2752         doc = testParsedDocument(Integer.toString(randomId), null, testDocument(), new BytesArray("{}"), null);
2753         Engine.Index idxRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, 2,
2754                                                    VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2755         Engine.IndexResult result = engine.index(idxRequest);
2756         engine.refresh("test");
2757         assertThat(result.getVersion(), equalTo(2L));
2758         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
2759             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs + 1);
2760             assertThat(topDocs.totalHits.value, equalTo(numDocs + 1L));
2761         }
2762         engine.close();
2763         translogHandler = createTranslogHandler(engine.engineConfig.getIndexSettings());
2764         engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
2765         engine.refresh("warm_up");
2766         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
2767             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs + 1);
2768             assertThat(topDocs.totalHits.value, equalTo(numDocs + 1L));
2769         }
2770         engine.delete(new Engine.Delete(
2771             Integer.toString(randomId),
2772             newUid(doc),
2773             UNASSIGNED_SEQ_NO,
2774             primaryTerm.get(),
2775             Versions.MATCH_ANY,
2776             VersionType.INTERNAL,
2777             Engine.Operation.Origin.PRIMARY,
2778             System.nanoTime(),
2779             UNASSIGNED_SEQ_NO,
2780             0
2781         ));
2782         if (randomBoolean()) {
2783             engine.close();
2784             engine = createEngine(store, primaryTranslogDir, inSyncGlobalCheckpointSupplier);
2785         }
2786         engine.refresh("test");
2787         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
2788             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), numDocs);
2789             assertThat(topDocs.totalHits.value, equalTo((long) numDocs));
2790         }
2791     }
2792     @Test
2793     public void testRecoverFromForeignTranslog() throws IOException {
2794         final int numDocs = randomIntBetween(1, 10);
2795         for (int i = 0; i &lt; numDocs; i++) {
2796             ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null);
2797             Engine.Index firstIndexRequest = new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1,
2798                                                               Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
2799             Engine.IndexResult index = engine.index(firstIndexRequest);
2800             assertThat(index.getVersion(), equalTo(1L));
2801         }
2802         assertVisibleCount(engine, numDocs);
2803         Translog.TranslogGeneration generation = engine.getTranslog().getGeneration();
2804         engine.close();
2805         final Path badTranslogLog = createTempDir();
2806         final String badUUID = Translog.createEmptyTranslog(badTranslogLog, SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get());
2807         Translog translog = new Translog(
2808             new TranslogConfig(shardId, badTranslogLog, INDEX_SETTINGS, BigArrays.NON_RECYCLING_INSTANCE),
2809             badUUID, createTranslogDeletionPolicy(INDEX_SETTINGS), () -&gt; SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, seqNo -&gt; {});
2810         translog.add(new Translog.Index(
2811             "SomeBogusId",
2812             0,
2813             primaryTerm.get(),
2814             "{}".getBytes(Charset.forName("UTF-8"))));
2815         assertEquals(generation.translogFileGeneration, translog.currentFileGeneration());
2816         translog.close();
2817         EngineConfig config = engine.config();
2818         TranslogConfig translogConfig = new TranslogConfig(shardId, translog.location(), config.getIndexSettings(),
2819                                                            BigArrays.NON_RECYCLING_INSTANCE);
2820         EngineConfig brokenConfig = new EngineConfig(
2821             shardId,
2822             allocationId.getId(),
2823             threadPool,
2824             config.getIndexSettings(),
2825             store,
2826             newMergePolicy(),
2827             config.getAnalyzer(),
2828             new CodecService(null, logger),
2829             config.getEventListener(),
2830             IndexSearcher.getDefaultQueryCache(),
2831             IndexSearcher.getDefaultQueryCachingPolicy(),
2832             translogConfig,
2833             TimeValue.timeValueMinutes(5),
2834             config.getExternalRefreshListener(),
2835             config.getInternalRefreshListener(),
2836             new NoneCircuitBreakerService(),
2837             () -&gt; UNASSIGNED_SEQ_NO,
2838             () -&gt; RetentionLeases.EMPTY,
2839             primaryTerm::get,
2840             tombstoneDocSupplier()
2841         );
2842         expectThrows(EngineCreationFailureException.class, () -&gt; new InternalEngine(brokenConfig));
2843         engine = createEngine(store, primaryTranslogDir);         assertVisibleCount(engine, numDocs, true);
2844     }
2845     @Test
2846     public void testShardNotAvailableExceptionWhenEngineClosedConcurrently() throws IOException, InterruptedException {
2847         AtomicReference&lt;Exception&gt; exception = new AtomicReference&lt;&gt;();
2848         String operation = randomFrom("optimize", "refresh", "flush");
2849         Thread mergeThread = new Thread() {
2850             @Override
2851             public void run() {
2852                 boolean stop = false;
2853                 logger.info("try with {}", operation);
2854                 while (stop == false) {
2855                     try {
2856                         switch (operation) {
2857                             case "optimize": {
2858                                 engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
2859                                 break;
2860                             }
2861                             case "refresh": {
2862                                 engine.refresh("test refresh");
2863                                 break;
2864                             }
2865                             case "flush": {
2866                                 engine.flush(true, false);
2867                                 break;
2868                             }
2869                         }
2870                     } catch (Exception e) {
2871                         exception.set(e);
2872                         stop = true;
2873                     }
2874                 }
2875             }
2876         };
2877         mergeThread.start();
2878         engine.close();
2879         mergeThread.join();
2880         logger.info("exception caught: ", exception.get());
2881         assertTrue("expected an Exception that signals shard is not available",
2882                    TransportActions.isShardNotAvailableException(exception.get()));
2883     }
2884     @Test
2885     public void testConcurrentEngineClosed() throws BrokenBarrierException, InterruptedException {
2886         Thread[] closingThreads = new Thread[3];
2887         CyclicBarrier barrier = new CyclicBarrier(1 + closingThreads.length + 1);
2888         Thread failEngine = new Thread(new AbstractRunnable() {
2889             @Override
2890             public void onFailure(Exception e) {
2891                 throw new AssertionError(e);
2892             }
2893             @Override
2894             protected void doRun() throws Exception {
2895                 barrier.await();
2896                 engine.failEngine("test", new RuntimeException("test"));
2897             }
2898         });
2899         failEngine.start();
2900         for (int i = 0;i &lt; closingThreads.length ; i++) {
2901             boolean flushAndClose = randomBoolean();
2902             closingThreads[i] = new Thread(new AbstractRunnable() {
2903                 @Override
2904                 public void onFailure(Exception e) {
2905                     throw new AssertionError(e);
2906                 }
2907                 @Override
2908                 protected void doRun() throws Exception {
2909                     barrier.await();
2910                     if (flushAndClose) {
2911                         engine.flushAndClose();
2912                     } else {
2913                         engine.close();
2914                     }
2915                     synchronized (closingThreads) {
2916                         try (Lock ignored = store.directory().obtainLock(IndexWriter.WRITE_LOCK_NAME)) {
2917                         }
2918                     }
2919                 }
2920             });
2921             closingThreads[i].setName("closingThread_" + i);
2922             closingThreads[i].start();
2923         }
2924         barrier.await();
2925         failEngine.join();
2926         for (Thread t : closingThreads) {
2927             t.join();
2928         }
2929     }
2930     private static class ThrowingIndexWriter extends IndexWriter {
2931         private AtomicReference&lt;Supplier&lt;Exception&gt;&gt; failureToThrow = new AtomicReference&lt;&gt;();
2932         ThrowingIndexWriter(Directory d, IndexWriterConfig conf) throws IOException {
2933             super(d, conf);
2934         }
2935         @Override
2936         public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) throws IOException {
2937             maybeThrowFailure();
2938             return super.addDocument(doc);
2939         }
2940         private void maybeThrowFailure() throws IOException {
2941             if (failureToThrow.get() != null) {
2942                 Exception failure = failureToThrow.get().get();
2943                 clearFailure();                 if (failure instanceof RuntimeException) {
2944                     throw (RuntimeException) failure;
2945                 } else if (failure instanceof IOException) {
2946                     throw (IOException) failure;
2947                 } else {
2948                     assert false: "unsupported failure class: " + failure.getClass().getCanonicalName();
2949                 }
2950             }
2951         }
2952         @Override
2953         public long softUpdateDocument(Term term, Iterable&lt;? extends IndexableField&gt; doc, Field... softDeletes) throws IOException {
2954             maybeThrowFailure();
2955             return super.softUpdateDocument(term, doc, softDeletes);
2956         }
2957         @Override
2958         public long deleteDocuments(Term... terms) throws IOException {
2959             maybeThrowFailure();
2960             return super.deleteDocuments(terms);
2961         }
2962         public void setThrowFailure(Supplier&lt;Exception&gt; failureSupplier) {
2963             failureToThrow.set(failureSupplier);
2964         }
2965         public void clearFailure() {
2966             failureToThrow.set(null);
2967         }
2968     }
2969     @Test
2970     public void testHandleDocumentFailure() throws Exception {
2971         try (Store store = createStore()) {
2972             final ParsedDocument doc1 = testParsedDocument("1", null, testDocumentWithTextField(), B_1, null);
2973             final ParsedDocument doc2 = testParsedDocument("2", null, testDocumentWithTextField(), B_1, null);
2974             final ParsedDocument doc3 = testParsedDocument("3", null, testDocumentWithTextField(), B_1, null);
2975             AtomicReference&lt;ThrowingIndexWriter&gt; throwingIndexWriter = new AtomicReference&lt;&gt;();
2976             try (InternalEngine engine = createEngine(
2977                 defaultSettings,
2978                 store,
2979                 createTempDir(),
2980                 NoMergePolicy.INSTANCE,
2981                 (directory, iwc) -&gt; {
2982                     throwingIndexWriter.set(new ThrowingIndexWriter(directory, iwc));
2983                     return throwingIndexWriter.get();
2984                 })
2985             ) {
2986                 if (randomBoolean()) {
2987                     throwingIndexWriter.get().setThrowFailure(() -&gt; new IOException("simulated"));
2988                 } else {
2989                     throwingIndexWriter.get().setThrowFailure(() -&gt; new IllegalArgumentException("simulated max token length"));
2990                 }
2991                 Engine.IndexResult indexResult = engine.index(indexForDoc(doc1));
2992                 assertNotNull(indexResult.getFailure());
2993                 assertThat(indexResult.getSeqNo(), equalTo(0L));
2994                 assertThat(indexResult.getVersion(), equalTo(Versions.MATCH_ANY));
2995                 assertNotNull(indexResult.getTranslogLocation());
2996                 throwingIndexWriter.get().clearFailure();
2997                 indexResult = engine.index(indexForDoc(doc1));
2998                 assertThat(indexResult.getSeqNo(), equalTo(1L));
2999                 assertThat(indexResult.getVersion(), equalTo(1L));
3000                 assertNull(indexResult.getFailure());
3001                 assertNotNull(indexResult.getTranslogLocation());
3002                 engine.index(indexForDoc(doc2));
3003                 if (randomBoolean()) {
3004                     throwingIndexWriter.get().setThrowFailure(null);
3005                     UncheckedIOException uncheckedIOException = expectThrows(UncheckedIOException.class, () -&gt; {
3006                         Engine.Index index = indexForDoc(doc3);
3007                         index.parsedDoc().rootDoc().add(new StoredField("foo", "bar") {
3008                             @Override
3009                             public BytesRef binaryValue() {
3010                                 throw new UncheckedIOException(new MockDirectoryWrapper.FakeIOException());
3011                             }
3012                         });
3013                         engine.index(index);
3014                     });
3015                     assertTrue(uncheckedIOException.getCause() instanceof MockDirectoryWrapper.FakeIOException);
3016                 } else {
3017                     engine.close();
3018                 }
3019                 expectThrows(AlreadyClosedException.class, () -&gt; engine.index(indexForDoc(doc1)));
3020                 expectThrows(AlreadyClosedException.class,
3021                              () -&gt; engine.delete(new Engine.Delete(
3022                                  "1",
3023                                  newUid(doc1),
3024                                  UNASSIGNED_SEQ_NO,
3025                                  primaryTerm.get(),
3026                                  Versions.MATCH_ANY,
3027                                  VersionType.INTERNAL,
3028                                  Engine.Operation.Origin.PRIMARY,
3029                                  System.nanoTime(),
3030                                  UNASSIGNED_SEQ_NO,
3031                                  0)));
3032                 expectThrows(AlreadyClosedException.class,
3033                              () -&gt; engine.noOp(
3034                                  new Engine.NoOp(engine.getLocalCheckpointTracker().generateSeqNo(),
3035                                                  engine.config().getPrimaryTermSupplier().getAsLong(),
3036                                                  randomFrom(Engine.Operation.Origin.values()),
3037                                                  randomNonNegativeLong(),
3038                                                  "test")));
3039             }
3040         }
3041     }
3042     @Test
3043     public void testDeleteWithFatalError() throws Exception {
3044         final IllegalStateException tragicException = new IllegalStateException("fail to store tombstone");
3045         try (Store store = createStore()) {
3046             EngineConfig.TombstoneDocSupplier tombstoneDocSupplier = new EngineConfig.TombstoneDocSupplier() {
3047                 @Override
3048                 public ParsedDocument newDeleteTombstoneDoc(String id) {
3049                     ParsedDocument parsedDocument = tombstoneDocSupplier().newDeleteTombstoneDoc(id);
3050                     parsedDocument.rootDoc().add(new StoredField("foo", "bar") {
3051                         @Override
3052                         public BytesRef binaryValue() {
3053                             throw tragicException;
3054                         }
3055                     });
3056                     return parsedDocument;
3057                 }
3058                 @Override
3059                 public ParsedDocument newNoopTombstoneDoc(String reason) {
3060                     return tombstoneDocSupplier().newNoopTombstoneDoc(reason);
3061                 }
3062             };
3063             EngineConfig config = config(this.engine.config(), store, createTempDir(), tombstoneDocSupplier);
3064             try (InternalEngine engine = createEngine(config)) {
3065                 final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);
3066                 engine.index(indexForDoc(doc));
3067                 expectThrows(IllegalStateException.class, () -&gt; engine.delete(
3068                     new Engine.Delete(
3069                         "1",
3070                         newUid(doc),
3071                         UNASSIGNED_SEQ_NO,
3072                         primaryTerm.get(),
3073                         Versions.MATCH_ANY,
3074                         VersionType.INTERNAL,
3075                         Engine.Operation.Origin.PRIMARY,
3076                         System.nanoTime(),
3077                         UNASSIGNED_SEQ_NO,
3078                         0
3079                     )));
3080                 assertTrue(engine.isClosed.get());
3081                 assertSame(tragicException, engine.failedEngine.get());
3082             }
3083         }
3084     }
3085     @Test
3086     public void testDoubleDeliveryPrimary() throws IOException {
3087         final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
3088             new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3089         final boolean create = randomBoolean();
3090         Engine.Index operation = appendOnlyPrimary(doc, false, 1, create);
3091         Engine.Index retry = appendOnlyPrimary(doc, true, 1, create);
3092         if (randomBoolean()) {
3093             Engine.IndexResult indexResult = engine.index(operation);
3094             assertLuceneOperations(engine, 1, 0, 0);
3095             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3096             assertNotNull(indexResult.getTranslogLocation());
3097             Engine.IndexResult retryResult = engine.index(retry);
3098             assertLuceneOperations(engine, 1, create ? 0 : 1, 0);
3099             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
3100             if (create) {
3101                 assertNull(retryResult.getTranslogLocation());
3102             } else {
3103                 assertNotNull(retryResult.getTranslogLocation());
3104             }
3105         } else {
3106             Engine.IndexResult retryResult = engine.index(retry);
3107             assertLuceneOperations(engine, 1, 0, 0);
3108             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
3109             assertNotNull(retryResult.getTranslogLocation());
3110             Engine.IndexResult indexResult = engine.index(operation);
3111             assertLuceneOperations(engine, 1, create ? 0 : 1, 0);
3112             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(2L));
3113             assertNotNull(retryResult.getTranslogLocation());
3114             if (create) {
3115                 assertNull(indexResult.getTranslogLocation());
3116             } else {
3117                 assertNotNull(indexResult.getTranslogLocation());
3118             }
3119         }
3120         engine.refresh("test");
3121         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3122             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3123             assertEquals(1, topDocs.totalHits.value);
3124         }
3125         operation = appendOnlyPrimary(doc, false, 1, create);
3126         retry = appendOnlyPrimary(doc, true, 1, create);
3127         if (randomBoolean()) {
3128             Engine.IndexResult indexResult = engine.index(operation);
3129             if (create) {
3130                 assertNull(indexResult.getTranslogLocation());
3131             } else {
3132                 assertNotNull(indexResult.getTranslogLocation());
3133             }
3134             Engine.IndexResult retryResult = engine.index(retry);
3135             if (create) {
3136                 assertNull(retryResult.getTranslogLocation());
3137             } else {
3138                 assertNotNull(retryResult.getTranslogLocation());
3139             }
3140         } else {
3141             Engine.IndexResult retryResult = engine.index(retry);
3142             if (create) {
3143                 assertNull(retryResult.getTranslogLocation());
3144             } else {
3145                 assertNotNull(retryResult.getTranslogLocation());
3146             }
3147             Engine.IndexResult indexResult = engine.index(operation);
3148             if (create) {
3149                 assertNull(indexResult.getTranslogLocation());
3150             } else {
3151                 assertNotNull(indexResult.getTranslogLocation());
3152             }
3153         }
3154         engine.refresh("test");
3155         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3156             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3157             assertEquals(1, topDocs.totalHits.value);
3158         }
3159     }
3160     @Test
3161     public void testDoubleDeliveryReplicaAppendingAndDeleteOnly() throws IOException {
3162         final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
3163                                                       new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3164         Engine.Index operation = appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
3165         Engine.Index retry = appendOnlyReplica(doc, true, 1, randomIntBetween(0, 5));
3166         Engine.Delete delete = new Engine.Delete(
3167             operation.id(),
3168             operation.uid(),
3169             Math.max(retry.seqNo(), operation.seqNo()) + 1,
3170             operation.primaryTerm(),
3171             operation.version() + 1,
3172             operation.versionType(),
3173             REPLICA,
3174             operation.startTime() + 1,
3175             UNASSIGNED_SEQ_NO,
3176             0
3177         );
3178         final boolean sameSeqNo = operation.seqNo() == retry.seqNo();
3179         if (randomBoolean()) {
3180             Engine.IndexResult indexResult = engine.index(operation);
3181             assertLuceneOperations(engine, 1, 0, 0);
3182             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3183             assertNotNull(indexResult.getTranslogLocation());
3184             engine.delete(delete);
3185             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
3186             assertLuceneOperations(engine, 1, 0, 1);
3187             Engine.IndexResult retryResult = engine.index(retry);
3188             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(sameSeqNo ? 1L : 2L));
3189             assertNotNull(retryResult.getTranslogLocation());
3190             assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &gt; 0);
3191         } else {
3192             Engine.IndexResult retryResult = engine.index(retry);
3193             assertLuceneOperations(engine, 1, 0, 0);
3194             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3195             assertNotNull(retryResult.getTranslogLocation());
3196             engine.delete(delete);
3197             assertLuceneOperations(engine, 1, 0, 1);
3198             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(1L));
3199             Engine.IndexResult indexResult = engine.index(operation);
3200             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(sameSeqNo ? 1L : 2L));
3201             assertNotNull(retryResult.getTranslogLocation());
3202             assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &lt; 0);
3203         }
3204         engine.refresh("test");
3205         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3206             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3207             assertEquals(0, topDocs.totalHits.value);
3208         }
3209     }
3210     @Test
3211     public void testDoubleDeliveryReplicaAppendingOnly() throws IOException {
3212         final Supplier&lt;ParsedDocument&gt; doc = () -&gt; testParsedDocument("1", null, testDocumentWithTextField(),
3213             new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3214         boolean replicaOperationIsRetry = randomBoolean();
3215         Engine.Index operation = appendOnlyReplica(doc.get(), replicaOperationIsRetry, 1, randomIntBetween(0, 5));
3216         Engine.IndexResult result = engine.index(operation);
3217         assertLuceneOperations(engine, 1, 0, 0);
3218         assertEquals(0, engine.getNumVersionLookups());
3219         assertNotNull(result.getTranslogLocation());
3220         engine.refresh("test");
3221         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3222             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3223             assertEquals(1, topDocs.totalHits.value);
3224         }
3225         final boolean create = randomBoolean();
3226         operation = appendOnlyPrimary(doc.get(), false, 1, create);
3227         Engine.Index retry = appendOnlyPrimary(doc.get(), true, 1, create);
3228         if (randomBoolean()) {
3229             if (replicaOperationIsRetry) {
3230                 Engine.IndexResult indexResult = engine.index(operation);
3231                 if (create) {
3232                     assertNull(indexResult.getTranslogLocation());
3233                 } else {
3234                     assertNotNull(indexResult.getTranslogLocation());
3235                 }
3236             }
3237             Engine.IndexResult retryResult = engine.index(retry);
3238             if (create) {
3239                 assertNull(retryResult.getTranslogLocation());
3240             } else {
3241                 assertNotNull(retryResult.getTranslogLocation());
3242             }
3243         } else {
3244             Engine.IndexResult retryResult = engine.index(retry);
3245             if (create) {
3246                 assertNull(retryResult.getTranslogLocation());
3247             } else {
3248                 assertNotNull(retryResult.getTranslogLocation());
3249             }
3250             Engine.IndexResult indexResult = engine.index(operation);
3251             if (create) {
3252                 assertNull(indexResult.getTranslogLocation());
3253             } else {
3254                 assertNotNull(indexResult.getTranslogLocation());
3255             }
3256         }
3257         engine.refresh("test");
3258         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3259             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3260             assertEquals(1, topDocs.totalHits.value);
3261         }
3262     }
3263     @Test
3264     public void testDoubleDeliveryReplica() throws IOException {
3265         final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
3266                                                       new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3267         Engine.Index operation = replicaIndexForDoc(doc, 1, 20, false);
3268         Engine.Index duplicate = replicaIndexForDoc(doc, 1, 20, true);
3269         if (randomBoolean()) {
3270             Engine.IndexResult indexResult = engine.index(operation);
3271             assertLuceneOperations(engine, 1, 0, 0);
3272             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3273             assertNotNull(indexResult.getTranslogLocation());
3274             if (randomBoolean()) {
3275                 engine.refresh("test");
3276             }
3277             Engine.IndexResult retryResult = engine.index(duplicate);
3278             assertLuceneOperations(engine, 1, 0, 0);
3279             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3280             assertNotNull(retryResult.getTranslogLocation());
3281             assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &gt; 0);
3282         } else {
3283             Engine.IndexResult retryResult = engine.index(duplicate);
3284             assertLuceneOperations(engine, 1, 0, 0);
3285             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3286             assertNotNull(retryResult.getTranslogLocation());
3287             if (randomBoolean()) {
3288                 engine.refresh("test");
3289             }
3290             Engine.IndexResult indexResult = engine.index(operation);
3291             assertLuceneOperations(engine, 1, 0, 0);
3292             assertThatIfAssertionEnabled(engine.getNumVersionLookups(), is(0L));
3293             assertNotNull(retryResult.getTranslogLocation());
3294             assertTrue(retryResult.getTranslogLocation().compareTo(indexResult.getTranslogLocation()) &lt; 0);
3295         }
3296         engine.refresh("test");
3297         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3298             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3299             assertEquals(1, topDocs.totalHits.value);
3300         }
3301         engine.refresh("test");
3302         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3303             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3304             assertEquals(1, topDocs.totalHits.value);
3305         }
3306         if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
3307             List&lt;Translog.Operation&gt; ops = readAllOperationsInLucene(engine, createMapperService("test"));
3308             assertThat(ops.stream().map(o -&gt; o.seqNo()).collect(Collectors.toList()), hasItem(20L));
3309         }
3310     }
3311     @Test
3312     public void testRetryWithAutogeneratedIdWorksAndNoDuplicateDocs() throws IOException {
3313         final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
3314                                                       new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3315         boolean isRetry = false;
3316         long autoGeneratedIdTimestamp = 0;
3317         Engine.Index index = new Engine.Index(
3318             newUid(doc),
3319             doc,
3320             UNASSIGNED_SEQ_NO,
3321             1,
3322             randomBoolean() ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
3323             VersionType.INTERNAL,
3324             PRIMARY,
3325             System.nanoTime(),
3326             autoGeneratedIdTimestamp,
3327             isRetry,
3328             UNASSIGNED_SEQ_NO,
3329             0
3330         );
3331         Engine.IndexResult indexResult = engine.index(index);
3332         assertThat(indexResult.getVersion(), equalTo(1L));
3333         index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
3334                                  null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
3335         indexResult = replicaEngine.index(index);
3336         assertThat(indexResult.getVersion(), equalTo(1L));
3337         isRetry = true;
3338         index = new Engine.Index(
3339             newUid(doc),
3340             doc,
3341             UNASSIGNED_SEQ_NO,
3342             1,
3343             Versions.MATCH_ANY,
3344             VersionType.INTERNAL,
3345             PRIMARY,
3346             System.nanoTime(),
3347             autoGeneratedIdTimestamp,
3348             isRetry,
3349             UNASSIGNED_SEQ_NO,
3350             0
3351         );
3352         indexResult = engine.index(index);
3353         assertThat(indexResult.getVersion(), equalTo(1L));
3354         assertNotEquals(indexResult.getSeqNo(), UNASSIGNED_SEQ_NO);
3355         engine.refresh("test");
3356         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3357             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3358             assertEquals(1, topDocs.totalHits.value);
3359         }
3360         index = new Engine.Index(newUid(doc), doc, indexResult.getSeqNo(), index.primaryTerm(), indexResult.getVersion(),
3361                                  null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
3362         indexResult = replicaEngine.index(index);
3363         assertThat(indexResult.getResultType(), equalTo(Engine.Result.Type.SUCCESS));
3364         replicaEngine.refresh("test");
3365         try (Engine.Searcher searcher = replicaEngine.acquireSearcher("test")) {
3366             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3367             assertEquals(1, topDocs.totalHits.value);
3368         }
3369     }
3370     @Test
3371     public void testRetryWithAutogeneratedIdsAndWrongOrderWorksAndNoDuplicateDocs() throws IOException {
3372         final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(),
3373                                                       new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3374         boolean isRetry = true;
3375         long autoGeneratedIdTimestamp = 0;
3376         Engine.Index firstIndexRequest = new Engine.Index(
3377             newUid(doc),
3378             doc,
3379             UNASSIGNED_SEQ_NO,
3380             1,
3381             randomBoolean() ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
3382             VersionType.INTERNAL,
3383             PRIMARY,
3384             System.nanoTime(),
3385             autoGeneratedIdTimestamp,
3386             isRetry,
3387             UNASSIGNED_SEQ_NO,
3388             0
3389         );
3390         Engine.IndexResult result = engine.index(firstIndexRequest);
3391         assertThat(result.getVersion(), equalTo(1L));
3392         Engine.Index firstIndexRequestReplica = new Engine.Index(newUid(doc), doc, result.getSeqNo(), firstIndexRequest.primaryTerm(),
3393                                                                  result.getVersion(), null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
3394         Engine.IndexResult indexReplicaResult = replicaEngine.index(firstIndexRequestReplica);
3395         assertThat(indexReplicaResult.getVersion(), equalTo(1L));
3396         isRetry = false;
3397         Engine.Index secondIndexRequest = new Engine.Index(
3398             newUid(doc),
3399             doc,
3400             UNASSIGNED_SEQ_NO,
3401             1,
3402             Versions.MATCH_DELETED,
3403             VersionType.INTERNAL,
3404             PRIMARY,
3405             System.nanoTime(),
3406             autoGeneratedIdTimestamp,
3407             isRetry,
3408             UNASSIGNED_SEQ_NO,
3409             0);
3410         Engine.IndexResult indexResult = engine.index(secondIndexRequest);
3411         assertFalse(indexResult.isCreated());
3412         engine.refresh("test");
3413         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3414             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3415             assertEquals(1, topDocs.totalHits.value);
3416         }
3417         Engine.Index secondIndexRequestReplica = new Engine.Index(newUid(doc), doc, result.getSeqNo(), secondIndexRequest.primaryTerm(),
3418                                                                   result.getVersion(), null, REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry, UNASSIGNED_SEQ_NO, 0);
3419         replicaEngine.index(secondIndexRequestReplica);
3420         replicaEngine.refresh("test");
3421         try (Engine.Searcher searcher = replicaEngine.acquireSearcher("test")) {
3422             TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), 10);
3423             assertEquals(1, topDocs.totalHits.value);
3424         }
3425 <a name="2"></a>    }
3426     public Engine.Index randomAppendOnly(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp) {
3427         if (<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>randomBoolean()) {
3428             return appendOnlyPrimary(doc, retry, autoGeneratedIdTimestamp);
3429         } else {
3430             return appendOnlyReplica(doc, retry, autoGeneratedIdTimestamp, 0);
3431         }
3432     }</b></font>
3433     public Engine.Index appendOnlyPrimary(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp, boolean create) {
3434         return new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 1, create ? Versions.MATCH_DELETED : Versions.MATCH_ANY,
3435             VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(), autoGeneratedIdTimestamp, retry,
3436             UNASSIGNED_SEQ_NO, 0);
3437     }
3438     public Engine.Index appendOnlyPrimary(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp) {
3439         return appendOnlyPrimary(doc, retry, autoGeneratedIdTimestamp, randomBoolean());
3440     }
3441     public Engine.Index appendOnlyReplica(ParsedDocument doc, boolean retry, final long autoGeneratedIdTimestamp, final long seqNo) {
3442         return new Engine.Index(newUid(doc), doc, seqNo, 2, 1, null,
3443                                 Engine.Operation.Origin.REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, retry, UNASSIGNED_SEQ_NO, 0);
3444     }
3445     @Test
3446     public void testAppendConcurrently() throws InterruptedException, IOException {
3447         Thread[] thread = new Thread[randomIntBetween(3, 5)];
3448         int numDocs = randomIntBetween(1000, 10000);
3449         assertEquals(0, engine.getNumVersionLookups());
3450         assertEquals(0, engine.getNumIndexVersionsLookups());
3451         boolean primary = randomBoolean();
3452         List&lt;Engine.Index&gt; docs = new ArrayList&lt;&gt;();
3453         for (int i = 0; i &lt; numDocs; i++) {
3454             final ParsedDocument doc = testParsedDocument(Integer.toString(i), null,
3455                 testDocumentWithTextField(), new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3456             Engine.Index index = primary ? appendOnlyPrimary(doc, false, i) : appendOnlyReplica(doc, false, i, i);
3457             docs.add(index);
3458         }
3459         Collections.shuffle(docs, random());
3460         CountDownLatch startGun = new CountDownLatch(thread.length);
3461         AtomicInteger offset = new AtomicInteger(-1);
3462         for (int i = 0; i &lt; thread.length; i++) {
3463             thread[i] = new Thread() {
3464                 @Override
3465                 public void run() {
3466                     startGun.countDown();
3467                     try {
3468                         startGun.await();
3469                     } catch (InterruptedException e) {
3470                         throw new AssertionError(e);
3471                     }
3472                     assertThat(engine.getVersionMap().values(), empty());
3473                     int docOffset;
3474                     while ((docOffset = offset.incrementAndGet()) &lt; docs.size()) {
3475                         try {
3476                             engine.index(docs.get(docOffset));
3477                         } catch (IOException e) {
3478                             throw new AssertionError(e);
3479                         }
3480                     }
3481                 }
3482             };
3483             thread[i].start();
3484         }
3485         try (Engine.Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
3486             assertEquals("unexpected refresh", 0, searcher.getIndexReader().maxDoc());
3487         }
3488         for (int i = 0; i &lt; thread.length; i++) {
3489             thread[i].join();
3490         }
3491         engine.refresh("test");
3492         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
3493             int count = searcher.count(new MatchAllDocsQuery());
3494             assertEquals(docs.size(), count);
3495         }
3496         assertEquals(0, engine.getNumVersionLookups());
3497         assertEquals(0, engine.getNumIndexVersionsLookups());
3498         assertThat(engine.getMaxSeenAutoIdTimestamp(),
3499             equalTo(docs.stream().mapToLong(Engine.Index::getAutoGeneratedIdTimestamp).max().getAsLong()));
3500         assertLuceneOperations(engine, numDocs, 0, 0);
3501     }
3502     public static long getNumVersionLookups(InternalEngine engine) {         return engine.getNumVersionLookups();
3503     }
3504     public static long getNumIndexVersionsLookups(InternalEngine engine) {         return engine.getNumIndexVersionsLookups();
3505     }
3506     @Test
3507     public void testFailEngineOnRandomIO() throws IOException, InterruptedException {
3508         MockDirectoryWrapper wrapper = newMockDirectory();
3509         final Path translogPath = createTempDir("testFailEngineOnRandomIO");
3510         try (Store store = createStore(wrapper)) {
3511             CyclicBarrier join = new CyclicBarrier(2);
3512             CountDownLatch start = new CountDownLatch(1);
3513             AtomicInteger controller = new AtomicInteger(0);
3514             EngineConfig config = config(defaultSettings, store, translogPath, newMergePolicy(), new ReferenceManager.RefreshListener() {
3515                     @Override
3516                     public void beforeRefresh() throws IOException {
3517                     }
3518                     @Override
3519                     public void afterRefresh(boolean didRefresh) throws IOException {
3520                         int i = controller.incrementAndGet();
3521                         if (i == 1) {
3522                             throw new MockDirectoryWrapper.FakeIOException();
3523                         } else if (i == 2) {
3524                             try {
3525                                 start.await();
3526                             } catch (InterruptedException e) {
3527                                 throw new AssertionError(e);
3528                             }
3529                             throw new ElasticsearchException("something completely different");
3530                         }
3531                     }
3532                 });
3533             InternalEngine internalEngine = createEngine(config);
3534             int docId = 0;
3535             final ParsedDocument doc = testParsedDocument(Integer.toString(docId), null,
3536                                                           testDocumentWithTextField(), new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3537             Engine.Index index = randomBoolean() ? indexForDoc(doc) : randomAppendOnly(doc, false, docId);
3538             internalEngine.index(index);
3539             Runnable r = () -&gt;  {
3540                 try {
3541                     join.await();
3542                 } catch (Exception e) {
3543                     throw new AssertionError(e);
3544                 }
3545                 try {
3546                     internalEngine.refresh("test");
3547                     fail();
3548                 } catch (AlreadyClosedException ex) {
3549                     if (ex.getCause() != null) {
3550                         assertTrue(ex.toString(), ex.getCause() instanceof MockDirectoryWrapper.FakeIOException);
3551                     }
3552                 } catch (RefreshFailedEngineException ex) {
3553                 } finally {
3554                     start.countDown();
3555                 }
3556             };
3557             Thread t = new Thread(r);
3558             Thread t1 = new Thread(r);
3559             t.start();
3560             t1.start();
3561             t.join();
3562             t1.join();
3563             assertTrue(internalEngine.isClosed.get());
3564             assertTrue(internalEngine.failedEngine.get() instanceof MockDirectoryWrapper.FakeIOException);
3565         }
3566     }
3567     @Test
3568     public void testSequenceIDs() throws Exception {
3569         Tuple&lt;Long, Long&gt; seqID = getSequenceID(engine, new Engine.Get("type", newUid("1")));
3570         assertThat(seqID.v1(), equalTo(UNASSIGNED_SEQ_NO));
3571         assertThat(seqID.v2(), equalTo(0L));
3572         Document document = testDocumentWithTextField();
3573         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
3574         ParsedDocument doc = testParsedDocument("1", null, document, B_1, null);
3575         engine.index(indexForDoc(doc));
3576         engine.refresh("test");
3577         seqID = getSequenceID(engine, newGet(doc));
3578         logger.info("--&gt; got seqID: {}", seqID);
3579         assertThat(seqID.v1(), equalTo(0L));
3580         assertThat(seqID.v2(), equalTo(primaryTerm.get()));
3581         document = testDocumentWithTextField();
3582         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
3583         doc = testParsedDocument("1", null, document, B_1, null);
3584         engine.index(indexForDoc(doc));
3585         engine.refresh("test");
3586         seqID = getSequenceID(engine, newGet(doc));
3587         logger.info("--&gt; got seqID: {}", seqID);
3588         assertThat(seqID.v1(), equalTo(1L));
3589         assertThat(seqID.v2(), equalTo(primaryTerm.get()));
3590         document = testDocumentWithTextField();
3591         document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
3592         doc = testParsedDocument("1", null, document, B_1, null);
3593         engine.index(new Engine.Index(newUid(doc), doc, UNASSIGNED_SEQ_NO, 3,
3594                                       Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY,
3595                                       System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));
3596         engine.refresh("test");
3597         seqID = getSequenceID(engine, newGet(doc));
3598         logger.info("--&gt; got seqID: {}", seqID);
3599         assertThat(seqID.v1(), equalTo(2L));
3600         assertThat(seqID.v2(), equalTo(3L));
3601         Engine.Searcher searchResult = engine.acquireSearcher("test");
3602         MatcherAssert.assertThat(searchResult, EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(1));
3603         MatcherAssert.assertThat(searchResult,
3604                                  EngineSearcherTotalHitsMatcher.engineSearcherTotalHits(LongPoint.newExactQuery("_seq_no", 2), 1));
3605         searchResult.close();
3606     }
3607     @Test
3608     public void testLookupSeqNoByIdInLucene() throws Exception {
3609         int numOps = between(10, 100);
3610         long seqNo = 0;
3611         List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;(numOps);
3612         for (int i = 0; i &lt; numOps; i++) {
3613             String id = Integer.toString(between(1, 50));
3614             boolean isIndexing = randomBoolean();
3615             int copies = frequently() ? 1 : between(2, 4);
3616             for (int c = 0; c &lt; copies; c++) {
3617                 final ParsedDocument doc = EngineTestCase.createParsedDoc(id, null);
3618                 if (isIndexing) {
3619                     operations.add(new Engine.Index(EngineTestCase.newUid(doc), doc, seqNo, primaryTerm.get(),
3620                                                     i, null, Engine.Operation.Origin.REPLICA, threadPool.relativeTimeInMillis(), -1, true,  UNASSIGNED_SEQ_NO, 0L));
3621                 } else {
3622                     operations.add(new Engine.Delete(
3623                         doc.id(),
3624                         EngineTestCase.newUid(doc),
3625                         seqNo,
3626                         primaryTerm.get(),
3627                         i,
3628                         null,
3629                         Engine.Operation.Origin.REPLICA,
3630                         threadPool.relativeTimeInMillis(),
3631                         UNASSIGNED_SEQ_NO,
3632                         0L
3633                     ));
3634                 }
3635             }
3636             seqNo++;
3637             if (rarely()) {
3638                 seqNo++;
3639             }
3640         }
3641         Randomness.shuffle(operations);
3642         Settings.Builder settings = Settings.builder()
3643             .put(defaultSettings.getSettings())
3644             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true);
3645         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
3646         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
3647         Map&lt;String, Engine.Operation&gt; latestOps = new HashMap&lt;&gt;();         try (Store store = createStore();
3648              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null))) {
3649             CheckedRunnable&lt;IOException&gt; lookupAndCheck = () -&gt; {
3650                 try (Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
3651                     Map&lt;String, Long&gt; liveOps = latestOps.entrySet().stream()
3652                         .filter(e -&gt; e.getValue().operationType() == Engine.Operation.TYPE.INDEX)
3653                         .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue().seqNo()));
3654                     assertThat(getDocIds(engine, true).stream().collect(Collectors.toMap(e -&gt; e.getId(), e -&gt; e.getSeqNo())),
3655                                equalTo(liveOps));
3656                     for (String id : latestOps.keySet()) {
3657                         String msg = "latestOps=" + latestOps + " op=" + id;
3658                         DocIdAndSeqNo docIdAndSeqNo = VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), newUid(id));
3659                         if (liveOps.containsKey(id) == false) {
3660                             assertNull(msg, docIdAndSeqNo);
3661                         } else {
3662                             assertNotNull(msg, docIdAndSeqNo);
3663                             assertThat(msg, docIdAndSeqNo.seqNo, equalTo(latestOps.get(id).seqNo()));
3664                         }
3665                     }
3666                     String notFoundId = randomValueOtherThanMany(liveOps::containsKey, () -&gt; Long.toString(randomNonNegativeLong()));
3667                     assertNull(VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), newUid(notFoundId)));
3668                 }
3669             };
3670             for (Engine.Operation op : operations) {
3671                 if (op instanceof Engine.Index) {
3672                     engine.index((Engine.Index) op);
3673                     if (latestOps.containsKey(op.id()) == false || latestOps.get(op.id()).seqNo() &lt; op.seqNo()) {
3674                         latestOps.put(op.id(), op);
3675                     }
3676                 } else if (op instanceof Engine.Delete) {
3677                     engine.delete((Engine.Delete) op);
3678                     if (latestOps.containsKey(op.id()) == false || latestOps.get(op.id()).seqNo() &lt; op.seqNo()) {
3679                         latestOps.put(op.id(), op);
3680                     }
3681                 }
3682                 if (randomInt(100) &lt; 10) {
3683                     engine.refresh("test");
3684                     lookupAndCheck.run();
3685                 }
3686                 if (rarely()) {
3687                     engine.flush(false, true);
3688                     lookupAndCheck.run();
3689                 }
3690             }
3691             engine.refresh("test");
3692             lookupAndCheck.run();
3693         }
3694     }
3695     private ToLongBiFunction&lt;Engine, Engine.Operation&gt; getStallingSeqNoGenerator(
3696         final AtomicReference&lt;CountDownLatch&gt; latchReference,
3697         final CyclicBarrier barrier,
3698         final AtomicBoolean stall,
3699         final AtomicLong expectedLocalCheckpoint) {
3700         return (engine, operation) -&gt; {
3701             final long seqNo = generateNewSeqNo(engine);
3702             final CountDownLatch latch = latchReference.get();
3703             if (stall.get()) {
3704                 try {
3705                     barrier.await();
3706                     latch.await();
3707                 } catch (BrokenBarrierException | InterruptedException e) {
3708                     throw new RuntimeException(e);
3709                 }
3710             } else {
3711                 if (expectedLocalCheckpoint.get() + 1 == seqNo) {
3712                     expectedLocalCheckpoint.set(seqNo);
3713                 }
3714             }
3715             return seqNo;
3716         };
3717     }
3718     @Test
3719     public void testSequenceNumberAdvancesToMaxSeqOnEngineOpenOnPrimary() throws BrokenBarrierException, InterruptedException, IOException {
3720         engine.close();
3721         final int docs = randomIntBetween(1, 32);
3722         InternalEngine initialEngine = null;
3723         try {
3724             final AtomicReference&lt;CountDownLatch&gt; latchReference = new AtomicReference&lt;&gt;(new CountDownLatch(1));
3725             final CyclicBarrier barrier = new CyclicBarrier(2);
3726             final AtomicBoolean stall = new AtomicBoolean();
3727             final AtomicLong expectedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
3728             final List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
3729             initialEngine =
3730                 createEngine(defaultSettings, store, primaryTranslogDir,
3731                              newMergePolicy(), null, LocalCheckpointTracker::new, null,
3732                              getStallingSeqNoGenerator(latchReference, barrier, stall, expectedLocalCheckpoint));
3733             final InternalEngine finalInitialEngine = initialEngine;
3734             for (int i = 0; i &lt; docs; i++) {
3735                 final String id = Integer.toString(i);
3736                 final ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
3737                 stall.set(randomBoolean());
3738                 final Thread thread = new Thread(() -&gt; {
3739                     try {
3740                         finalInitialEngine.index(indexForDoc(doc));
3741                     } catch (IOException e) {
3742                         throw new AssertionError(e);
3743                     }
3744                 });
3745                 thread.start();
3746                 if (stall.get()) {
3747                     threads.add(thread);
3748                     barrier.await();
3749                 } else {
3750                     thread.join();
3751                 }
3752             }
3753             assertThat(initialEngine.getProcessedLocalCheckpoint(), equalTo(expectedLocalCheckpoint.get()));
3754             assertThat(initialEngine.getSeqNoStats(-1).getMaxSeqNo(), equalTo((long) (docs - 1)));
3755             initialEngine.flush(true, true);
3756             assertEquals(initialEngine.getProcessedLocalCheckpoint(), initialEngine.getPersistedLocalCheckpoint());
3757             latchReference.get().countDown();
3758             for (final Thread thread : threads) {
3759                 thread.join();
3760             }
3761         } finally {
3762             IOUtils.close(initialEngine);
3763         }
3764         try (var recoveringEngine = new InternalEngine(initialEngine.config())) {
3765             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
3766             recoveringEngine.fillSeqNoGaps(2);
3767             assertEquals(recoveringEngine.getProcessedLocalCheckpoint(), recoveringEngine.getPersistedLocalCheckpoint());
3768             assertThat(recoveringEngine.getProcessedLocalCheckpoint(), greaterThanOrEqualTo((long) (docs - 1)));
3769         }
3770     }
3771     @Test
3772     public void testOutOfOrderSequenceNumbersWithVersionConflict() throws IOException {
3773         final List&lt;Engine.Operation&gt; operations = new ArrayList&lt;&gt;();
3774         final int numberOfOperations = randomIntBetween(16, 32);
3775         final AtomicLong sequenceNumber = new AtomicLong();
3776         final Engine.Operation.Origin origin = randomFrom(LOCAL_TRANSLOG_RECOVERY, PEER_RECOVERY, PRIMARY, REPLICA);
3777         final LongSupplier sequenceNumberSupplier =
3778             origin == PRIMARY ? () -&gt; UNASSIGNED_SEQ_NO : sequenceNumber::getAndIncrement;
3779         final Supplier&lt;ParsedDocument&gt; doc = () -&gt; {
3780             final Document document = testDocumentWithTextField();
3781             document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
3782             return testParsedDocument("1", null, document, B_1, null);
3783         };
3784         final Term uid = newUid("1");
3785         final BiFunction&lt;String, Engine.SearcherScope, Searcher&gt; searcherFactory = engine::acquireSearcher;
3786         for (int i = 0; i &lt; numberOfOperations; i++) {
3787             if (randomBoolean()) {
3788                 final Engine.Index index = new Engine.Index(
3789                     uid,
3790                     doc.get(),
3791                     sequenceNumberSupplier.getAsLong(),
3792                     1,
3793                     i,
3794                     origin == PRIMARY ? VersionType.EXTERNAL : null,
3795                     origin,
3796                     System.nanoTime(),
3797                     Translog.UNSET_AUTO_GENERATED_TIMESTAMP,
3798                     false, UNASSIGNED_SEQ_NO, 0);
3799                 operations.add(index);
3800             } else {
3801                 final Engine.Delete delete = new Engine.Delete(
3802                     "1",
3803                     uid,
3804                     sequenceNumberSupplier.getAsLong(),
3805                     1,
3806                     i,
3807                     origin == PRIMARY ? VersionType.EXTERNAL : null,
3808                     origin,
3809                     System.nanoTime(), UNASSIGNED_SEQ_NO, 0);
3810                 operations.add(delete);
3811             }
3812         }
3813         final boolean exists = operations.get(operations.size() - 1) instanceof Engine.Index;
3814         Randomness.shuffle(operations);
3815         for (final Engine.Operation operation : operations) {
3816             if (operation instanceof Engine.Index) {
3817                 engine.index((Engine.Index) operation);
3818             } else {
3819                 engine.delete((Engine.Delete) operation);
3820             }
3821         }
3822         final long expectedLocalCheckpoint;
3823         if (origin == PRIMARY) {
3824             int count = 0;
3825             long version = -1;
3826             for (int i = 0; i &lt; numberOfOperations; i++) {
3827                 if (operations.get(i).version() &gt;= version) {
3828                     count++;
3829                     version = operations.get(i).version();
3830                 }
3831             }
3832             expectedLocalCheckpoint = count - 1;
3833         } else {
3834             expectedLocalCheckpoint = numberOfOperations - 1;
3835         }
3836         assertThat(engine.getProcessedLocalCheckpoint(), equalTo(expectedLocalCheckpoint));
3837         try (Engine.GetResult result = engine.get(new Engine.Get("2", uid), searcherFactory)) {
3838             assertThat(result.docIdAndVersion() != null, equalTo(exists));
3839         }
3840     }
3841     public void testVersionConflictIgnoreDeletedDoc() throws IOException {
3842         ParsedDocument doc = testParsedDocument("1", null, testDocument(),
3843             new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
3844         engine.delete(new Engine.Delete("1", newUid("1"), 1));
3845         for (long seqNo : new long[]{0, 1, randomNonNegativeLong()}) {
3846             assertDeletedVersionConflict(engine.index(new Engine.Index(newUid("1"), doc, UNASSIGNED_SEQ_NO, 1,
3847                     Versions.MATCH_ANY, VersionType.INTERNAL,
3848                     PRIMARY, randomNonNegativeLong(), UNSET_AUTO_GENERATED_TIMESTAMP, false, seqNo, 1)),
3849                 "update: " + seqNo);
3850             assertDeletedVersionConflict(engine.delete(new Engine.Delete("1", newUid("1"), UNASSIGNED_SEQ_NO, 1,
3851                     Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, randomNonNegativeLong(), seqNo, 1)),
3852                 "delete: " + seqNo);
3853         }
3854     }
3855     private void assertDeletedVersionConflict(Engine.Result result, String operation) {
3856         assertNotNull("Must have failure for " + operation, result.getFailure());
3857         assertThat(operation, result.getFailure(), Matchers.instanceOf(VersionConflictEngineException.class));
3858         VersionConflictEngineException exception = (VersionConflictEngineException) result.getFailure();
3859         assertThat(operation, exception.getMessage(), containsString("but no document was found"));
3860     }
3861     @Test
3862     public void testNoOps() throws IOException {
3863         engine.close();
3864         InternalEngine noOpEngine = null;
3865         final int maxSeqNo = randomIntBetween(0, 128);
3866         final int localCheckpoint = randomIntBetween(0, maxSeqNo);
3867         try {
3868             final BiFunction&lt;Long, Long, LocalCheckpointTracker&gt; supplier = (ms, lcp) -&gt; new LocalCheckpointTracker(
3869                 maxSeqNo,
3870                 localCheckpoint);
3871             EngineConfig noopEngineConfig = copy(engine.config(), new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD,
3872                                                                                                       () -&gt; new MatchAllDocsQuery(), engine.config().getMergePolicy()));
3873             noOpEngine = new InternalEngine(noopEngineConfig, supplier) {
3874                 @Override
3875                 protected long doGenerateSeqNoForOperation(Operation operation) {
3876                     throw new UnsupportedOperationException();
3877                 }
3878             };
3879             noOpEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
3880             final int gapsFilled = noOpEngine.fillSeqNoGaps(primaryTerm.get());
3881             final String reason = "filling gaps";
3882             noOpEngine.noOp(new Engine.NoOp(maxSeqNo + 1, primaryTerm.get(), LOCAL_TRANSLOG_RECOVERY, System.nanoTime(), reason));
3883             assertThat(noOpEngine.getProcessedLocalCheckpoint(), equalTo((long) (maxSeqNo + 1)));
3884             assertThat(noOpEngine.getTranslog().stats().getUncommittedOperations(), equalTo(gapsFilled));
3885             noOpEngine.noOp(
3886                 new Engine.NoOp(maxSeqNo + 2, primaryTerm.get(),
3887                     randomFrom(PRIMARY, REPLICA, PEER_RECOVERY), System.nanoTime(), reason));
3888             assertThat(noOpEngine.getProcessedLocalCheckpoint(), equalTo((long) (maxSeqNo + 2)));
3889             assertThat(noOpEngine.getTranslog().stats().getUncommittedOperations(), equalTo(gapsFilled + 1));
3890             Translog.Operation op;
3891             Translog.Operation last = null;
3892             try (Translog.Snapshot snapshot = noOpEngine.getTranslog().newSnapshot()) {
3893                 while ((op = snapshot.next()) != null) {
3894                     last = op;
3895                 }
3896             }
3897             assertNotNull(last);
3898             assertThat(last, instanceOf(Translog.NoOp.class));
3899             final Translog.NoOp noOp = (Translog.NoOp) last;
3900             assertThat(noOp.seqNo(), equalTo((long) (maxSeqNo + 2)));
3901             assertThat(noOp.primaryTerm(), equalTo(primaryTerm.get()));
3902             assertThat(noOp.reason(), equalTo(reason));
3903             if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
3904                 MapperService mapperService = createMapperService("test");
3905                 List&lt;Translog.Operation&gt; operationsFromLucene = readAllOperationsInLucene(noOpEngine, mapperService);
3906                 assertThat(operationsFromLucene, hasSize(maxSeqNo + 2 - localCheckpoint));                 for (int i = 0; i &lt; operationsFromLucene.size(); i++) {
3907                     assertThat(operationsFromLucene.get(i),
3908                                equalTo(new Translog.NoOp(localCheckpoint + 1 + i, primaryTerm.get(), "filling gaps")));
3909                 }
3910                 assertConsistentHistoryBetweenTranslogAndLuceneIndex(noOpEngine, mapperService);
3911             }
3912         } finally {
3913             IOUtils.close(noOpEngine);
3914         }
3915     }
3916     @Test
3917     public void testSegmentContainsOnlyNoOps() throws Exception {
3918         Engine.NoOpResult noOpResult = engine.noOp(new Engine.NoOp(1, primaryTerm.get(),
3919                                                                    randomFrom(Engine.Operation.Origin.values()), randomNonNegativeLong(), "test"));
3920         assertThat(noOpResult.getFailure(), nullValue());
3921         engine.refresh("test");
3922         Engine.DeleteResult deleteResult = engine.delete(replicaDeleteForDoc("id", 1, 2, randomNonNegativeLong()));
3923         assertThat(deleteResult.getFailure(), nullValue());
3924         engine.refresh("test");
3925     }
3926     @Test
3927     public void testRandomOperations() throws Exception {
3928         int numOps = between(10, 100);
3929         for (int i = 0; i &lt; numOps; i++) {
3930             String id = Integer.toString(randomIntBetween(1, 10));
3931             ParsedDocument doc = createParsedDoc(id, null);
3932             Engine.Operation.TYPE type = randomFrom(Engine.Operation.TYPE.values());
3933             switch (type) {
3934                 case INDEX:
3935                     Engine.IndexResult index = engine.index(replicaIndexForDoc(doc, between(1, 100), i, randomBoolean()));
3936                     assertThat(index.getFailure(), nullValue());
3937                     break;
3938                 case DELETE:
3939                     Engine.DeleteResult delete = engine.delete(replicaDeleteForDoc(doc.id(), between(1, 100), i, randomNonNegativeLong()));
3940                     assertThat(delete.getFailure(), nullValue());
3941                     break;
3942                 case NO_OP:
3943                     Engine.NoOpResult noOp = engine.noOp(new Engine.NoOp(i, primaryTerm.get(),
3944                                                                          randomFrom(Engine.Operation.Origin.values()), randomNonNegativeLong(), ""));
3945                     assertThat(noOp.getFailure(), nullValue());
3946                     break;
3947                 default:
3948                     throw new IllegalStateException("Invalid op [" + type + "]");
3949             }
3950             if (randomBoolean()) {
3951                 engine.refresh("test");
3952             }
3953             if (randomBoolean()) {
3954                 engine.flush();
3955             }
3956             if (randomBoolean()) {
3957                 engine.forceMerge(randomBoolean(), between(1, 10), randomBoolean(), false, false, UUIDs.randomBase64UUID());
3958             }
3959         }
3960         if (engine.engineConfig.getIndexSettings().isSoftDeleteEnabled()) {
3961             List&lt;Translog.Operation&gt; operations = readAllOperationsInLucene(engine, createMapperService("test"));
3962             assertThat(operations, hasSize(numOps));
3963         }
3964     }
3965     @Test
3966     public void testMinGenerationForSeqNo() throws IOException, BrokenBarrierException, InterruptedException {
3967         engine.close();
3968         final int numberOfTriplets = randomIntBetween(1, 32);
3969         InternalEngine actualEngine = null;
3970         try {
3971             final AtomicReference&lt;CountDownLatch&gt; latchReference = new AtomicReference&lt;&gt;();
3972             final CyclicBarrier barrier = new CyclicBarrier(2);
3973             final AtomicBoolean stall = new AtomicBoolean();
3974             final AtomicLong expectedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
3975             final Map&lt;Thread, CountDownLatch&gt; threads = new LinkedHashMap&lt;&gt;();
3976             actualEngine =
3977                 createEngine(defaultSettings, store, primaryTranslogDir,
3978                              newMergePolicy(), null, LocalCheckpointTracker::new, null,
3979                              getStallingSeqNoGenerator(latchReference, barrier, stall, expectedLocalCheckpoint));
3980             final InternalEngine finalActualEngine = actualEngine;
3981             final Translog translog = finalActualEngine.getTranslog();
3982             final long generation = finalActualEngine.getTranslog().currentFileGeneration();
3983             for (int i = 0; i &lt; numberOfTriplets; i++) {
3984                 stall.set(false);
3985                 index(finalActualEngine, 3 * i);
3986                 final CountDownLatch latch = new CountDownLatch(1);
3987                 latchReference.set(latch);
3988                 final int skipId = 3 * i + 1;
3989                 stall.set(true);
3990                 final Thread thread = new Thread(() -&gt; {
3991                     try {
3992                         index(finalActualEngine, skipId);
3993                     } catch (IOException e) {
3994                         throw new AssertionError(e);
3995                     }
3996                 });
3997                 thread.start();
3998                 threads.put(thread, latch);
3999                 barrier.await();
4000                 stall.set(false);
4001                 index(finalActualEngine, 3 * i + 2);
4002                 finalActualEngine.flush();
4003                 assertThat(translog.getMinGenerationForSeqNo(3 * i + 1).translogFileGeneration, equalTo(i + generation));
4004             }
4005             int i = 0;
4006             for (final Map.Entry&lt;Thread, CountDownLatch&gt; entry : threads.entrySet()) {
4007                 final Map&lt;String, String&gt; userData = finalActualEngine.commitStats().getUserData();
4008                 assertThat(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY), equalTo(Long.toString(3 * i)));
4009                 entry.getValue().countDown();
4010                 entry.getKey().join();
4011                 finalActualEngine.flush();
4012                 i++;
4013             }
4014         } finally {
4015             IOUtils.close(actualEngine);
4016         }
4017     }
4018     private void index(final InternalEngine engine, final int id) throws IOException {
4019         final String docId = Integer.toString(id);
4020         final ParsedDocument doc =
4021             testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
4022         engine.index(indexForDoc(doc));
4023     }
4024     private Tuple&lt;Long, Long&gt; getSequenceID(Engine engine, Engine.Get get) throws EngineException {
4025         try (Searcher searcher = engine.acquireSearcher("get", Engine.SearcherScope.INTERNAL)) {
4026             final long primaryTerm;
4027             final long seqNo;
4028             DocIdAndSeqNo docIdAndSeqNo = VersionsAndSeqNoResolver.loadDocIdAndSeqNo(searcher.getIndexReader(), get.uid());
4029             if (docIdAndSeqNo == null) {
4030                 primaryTerm = 0;
4031                 seqNo = UNASSIGNED_SEQ_NO;
4032             } else {
4033                 seqNo = docIdAndSeqNo.seqNo;
4034                 NumericDocValues primaryTerms = docIdAndSeqNo.context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);
4035                 if (primaryTerms == null || primaryTerms.advanceExact(docIdAndSeqNo.docId) == false) {
4036                     throw new AssertionError("document does not have primary term [" + docIdAndSeqNo.docId + "]");
4037                 }
4038                 primaryTerm = primaryTerms.longValue();
4039             }
4040             return new Tuple&lt;&gt;(seqNo, primaryTerm);
4041         } catch (Exception e) {
4042             throw new EngineException(shardId, "unable to retrieve sequence id", e);
4043         }
4044     }
4045     @Test
4046     public void testRestoreLocalHistoryFromTranslog() throws IOException {
4047         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4048         try (Store store = createStore()) {
4049             final ArrayList&lt;Long&gt; seqNos = new ArrayList&lt;&gt;();
4050             final int numOps = randomIntBetween(0, 1024);
4051             for (int i = 0; i &lt; numOps; i++) {
4052                 if (rarely()) {
4053                     continue;
4054                 }
4055                 seqNos.add((long) i);
4056             }
4057             Randomness.shuffle(seqNos);
4058             final EngineConfig engineConfig;
4059             final SeqNoStats prevSeqNoStats;
4060             final List&lt;DocIdSeqNoAndSource&gt; prevDocs;
4061             try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
4062                 engineConfig = engine.config();
4063                 for (final long seqNo : seqNos) {
4064                     final String id = Long.toString(seqNo);
4065                     final ParsedDocument doc = testParsedDocument(id, null,
4066                                                                   testDocumentWithTextField(), SOURCE, null);
4067                     engine.index(replicaIndexForDoc(doc, 1, seqNo, false));
4068                     if (rarely()) {
4069                         engine.rollTranslogGeneration();
4070                     }
4071                     if (rarely()) {
4072                         engine.flush();
4073                     }
4074                 }
4075                 globalCheckpoint.set(randomLongBetween(SequenceNumbers.NO_OPS_PERFORMED, engine.getPersistedLocalCheckpoint()));
4076                 engine.syncTranslog();
4077                 prevSeqNoStats = engine.getSeqNoStats(globalCheckpoint.get());
4078                 prevDocs = getDocIds(engine, true);
4079             }
4080             try (InternalEngine engine = new InternalEngine(engineConfig)) {
4081                 final long currentTranslogGeneration = engine.getTranslog().currentFileGeneration();
4082                 engine.recoverFromTranslog(translogHandler, globalCheckpoint.get());
4083                 engine.restoreLocalHistoryFromTranslog(translogHandler);
4084                 assertThat(getDocIds(engine, true), equalTo(prevDocs));
4085                 SeqNoStats seqNoStats = engine.getSeqNoStats(globalCheckpoint.get());
4086                 assertThat(seqNoStats.getLocalCheckpoint(), equalTo(prevSeqNoStats.getLocalCheckpoint()));
4087                 assertThat(seqNoStats.getMaxSeqNo(), equalTo(prevSeqNoStats.getMaxSeqNo()));
4088                 assertThat("restore from local translog must not add operations to translog",
4089                            engine.getTranslog().totalOperationsByMinGen(currentTranslogGeneration), equalTo(0));
4090             }
4091             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, createMapperService("test"));
4092         }
4093     }
4094     @Test
4095     public void testFillUpSequenceIdGapsOnRecovery() throws IOException {
4096         final int docs = randomIntBetween(1, 32);
4097         int numDocsOnReplica = 0;
4098         long maxSeqIDOnReplica = -1;
4099         long checkpointOnReplica;
4100         try {
4101             for (int i = 0; i &lt; docs; i++) {
4102                 final String docId = Integer.toString(i);
4103                 final ParsedDocument doc =
4104                     testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
4105                 Engine.Index primaryResponse = indexForDoc(doc);
4106                 Engine.IndexResult indexResult = engine.index(primaryResponse);
4107                 if (randomBoolean()) {
4108                     numDocsOnReplica++;
4109                     maxSeqIDOnReplica = indexResult.getSeqNo();
4110                     replicaEngine.index(replicaIndexForDoc(doc, 1, indexResult.getSeqNo(), false));
4111                 }
4112             }
4113             engine.syncTranslog();             replicaEngine.syncTranslog();             checkpointOnReplica = replicaEngine.getProcessedLocalCheckpoint();
4114         } finally {
4115             IOUtils.close(replicaEngine);
4116         }
4117         boolean flushed = false;
4118         AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4119         InternalEngine recoveringEngine = null;
4120         try {
4121             assertEquals(docs - 1, engine.getSeqNoStats(-1).getMaxSeqNo());
4122             assertEquals(docs - 1, engine.getProcessedLocalCheckpoint());
4123             assertEquals(maxSeqIDOnReplica, replicaEngine.getSeqNoStats(-1).getMaxSeqNo());
4124             assertEquals(checkpointOnReplica, replicaEngine.getProcessedLocalCheckpoint());
4125             recoveringEngine = new InternalEngine(copy(replicaEngine.config(), globalCheckpoint::get));
4126             assertEquals(numDocsOnReplica, getTranslog(recoveringEngine).stats().getUncommittedOperations());
4127             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
4128             assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
4129             assertEquals(checkpointOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
4130             assertEquals((maxSeqIDOnReplica + 1) - numDocsOnReplica, recoveringEngine.fillSeqNoGaps(2));
4131             try (Translog.Snapshot snapshot = getTranslog(recoveringEngine).newSnapshot()) {
4132                 assertTrue((maxSeqIDOnReplica + 1) - numDocsOnReplica &lt;= snapshot.totalOperations());
4133                 Translog.Operation operation;
4134                 while ((operation = snapshot.next()) != null) {
4135                     if (operation.opType() == Translog.Operation.Type.NO_OP) {
4136                         assertEquals(2, operation.primaryTerm());
4137                     } else {
4138                         assertEquals(primaryTerm.get(), operation.primaryTerm());
4139                     }
4140                 }
4141                 assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
4142                 assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
4143                 if ((flushed = randomBoolean())) {
4144                     globalCheckpoint.set(recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
4145                     getTranslog(recoveringEngine).sync();
4146                     recoveringEngine.flush(true, true);
4147                 }
4148             }
4149         } finally {
4150             IOUtils.close(recoveringEngine);
4151         }
4152         try {
4153             recoveringEngine = new InternalEngine(copy(replicaEngine.config(), globalCheckpoint::get));
4154             if (flushed) {
4155                 assertThat(recoveringEngine.getTranslogStats().getUncommittedOperations(), equalTo(0));
4156             }
4157             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
4158             assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
4159             assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
4160             assertEquals(0, recoveringEngine.fillSeqNoGaps(3));
4161             assertEquals(maxSeqIDOnReplica, recoveringEngine.getSeqNoStats(-1).getMaxSeqNo());
4162             assertEquals(maxSeqIDOnReplica, recoveringEngine.getProcessedLocalCheckpoint());
4163         } finally {
4164             IOUtils.close(recoveringEngine);
4165         }
4166     }
4167     public void assertSameReader(Searcher left, Searcher right) {
4168         List&lt;LeafReaderContext&gt; leftLeaves = ElasticsearchDirectoryReader.unwrap(left.getDirectoryReader()).leaves();
4169         List&lt;LeafReaderContext&gt; rightLeaves = ElasticsearchDirectoryReader.unwrap(right.getDirectoryReader()).leaves();
4170         assertEquals(rightLeaves.size(), leftLeaves.size());
4171         for (int i = 0; i &lt; leftLeaves.size(); i++) {
4172             assertSame(leftLeaves.get(i).reader(), rightLeaves.get(i).reader());
4173         }
4174     }
4175     public void assertNotSameReader(Searcher left, Searcher right) {
4176         List&lt;LeafReaderContext&gt; leftLeaves = ElasticsearchDirectoryReader.unwrap(left.getDirectoryReader()).leaves();
4177         List&lt;LeafReaderContext&gt; rightLeaves = ElasticsearchDirectoryReader.unwrap(right.getDirectoryReader()).leaves();
4178         if (rightLeaves.size() == leftLeaves.size()) {
4179             for (int i = 0; i &lt; leftLeaves.size(); i++) {
4180                 if (leftLeaves.get(i).reader() != rightLeaves.get(i).reader()) {
4181                     return;                 }
4182             }
4183             fail("readers are same");
4184         }
4185     }
4186     @Test
4187     public void testRefreshScopedSearcher() throws IOException {
4188         try (Store store = createStore();
4189              InternalEngine engine =
4190                  createEngine(defaultSettings, store, createTempDir(), NoMergePolicy.INSTANCE)) {
4191             engine.refresh("warm_up");
4192             try (Searcher getSearcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL);
4193                  Searcher searchSearcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4194                 assertSameReader(getSearcher, searchSearcher);
4195             }
4196             for (int i = 0; i &lt; 10; i++) {
4197                 final String docId = Integer.toString(i);
4198                 final ParsedDocument doc =
4199                     testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
4200                 Engine.Index primaryResponse = indexForDoc(doc);
4201                 engine.index(primaryResponse);
4202             }
4203             assertTrue(engine.refreshNeeded());
4204             engine.refresh("test", Engine.SearcherScope.INTERNAL, true);
4205             try (Searcher getSearcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL);
4206                  Searcher searchSearcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4207                 assertEquals(10, getSearcher.getIndexReader().numDocs());
4208                 assertEquals(0, searchSearcher.getIndexReader().numDocs());
4209                 assertNotSameReader(getSearcher, searchSearcher);
4210             }
4211             engine.refresh("test", Engine.SearcherScope.EXTERNAL, true);
4212             try (Searcher getSearcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL);
4213                  Searcher searchSearcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4214                 assertEquals(10, getSearcher.getIndexReader().numDocs());
4215                 assertEquals(10, searchSearcher.getIndexReader().numDocs());
4216                 assertSameReader(getSearcher, searchSearcher);
4217             }
4218             final String docId = Integer.toString(10);
4219             final ParsedDocument doc =
4220                 testParsedDocument(docId, null, testDocumentWithTextField(), SOURCE, null);
4221             Engine.Index primaryResponse = indexForDoc(doc);
4222             engine.index(primaryResponse);
4223             engine.refresh("test", Engine.SearcherScope.EXTERNAL, true);
4224             try (Searcher getSearcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL);
4225                  Searcher searchSearcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4226                 assertEquals(11, getSearcher.getIndexReader().numDocs());
4227                 assertEquals(11, searchSearcher.getIndexReader().numDocs());
4228                 assertSameReader(getSearcher, searchSearcher);
4229             }
4230             try (Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
4231                 engine.refresh("test", Engine.SearcherScope.INTERNAL, true);
4232                 try (Searcher nextSearcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
4233                     assertSame(searcher.getIndexReader(), nextSearcher.getIndexReader());
4234                 }
4235             }
4236             try (Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4237                 engine.refresh("test", Engine.SearcherScope.EXTERNAL, true);
4238                 try (Searcher nextSearcher = engine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL)) {
4239                     assertSame(searcher.getIndexReader(), nextSearcher.getIndexReader());
4240                 }
4241             }
4242         }
4243     }
4244     @Test
4245     public void testSeqNoGenerator() throws IOException {
4246         engine.close();
4247         final long seqNo = randomIntBetween(Math.toIntExact(SequenceNumbers.NO_OPS_PERFORMED), Integer.MAX_VALUE);
4248         final BiFunction&lt;Long, Long, LocalCheckpointTracker&gt; localCheckpointTrackerSupplier = (ms, lcp) -&gt; new LocalCheckpointTracker(
4249             SequenceNumbers.NO_OPS_PERFORMED,
4250             SequenceNumbers.NO_OPS_PERFORMED);
4251         final AtomicLong seqNoGenerator = new AtomicLong(seqNo);
4252         try (Engine e = createEngine(defaultSettings, store, primaryTranslogDir,
4253                                      newMergePolicy(), null, localCheckpointTrackerSupplier,
4254                                      null, (engine, operation) -&gt; seqNoGenerator.getAndIncrement())) {
4255             final String id = "id";
4256             final Field uidField = new Field("_id", id, IdFieldMapper.Defaults.FIELD_TYPE);
4257             final Field versionField = new NumericDocValuesField("_version", 0);
4258             final SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID();
4259             final ParseContext.Document document = new ParseContext.Document();
4260             document.add(uidField);
4261             document.add(versionField);
4262             document.add(seqID.seqNo);
4263             document.add(seqID.seqNoDocValue);
4264             document.add(seqID.primaryTerm);
4265             final BytesReference source = new BytesArray(new byte[]{1});
4266             final ParsedDocument parsedDocument = new ParsedDocument(
4267                 versionField,
4268                 seqID,
4269                 id,
4270                 "routing",
4271                 Collections.singletonList(document),
4272                 source,
4273                 null);
4274             final Engine.Index index = new Engine.Index(
4275                 new Term("_id", parsedDocument.id()),
4276                 parsedDocument,
4277                 UNASSIGNED_SEQ_NO,
4278                 randomIntBetween(1, 8),
4279                 Versions.NOT_FOUND,
4280                 VersionType.INTERNAL,
4281                 Engine.Operation.Origin.PRIMARY,
4282                 System.nanoTime(),
4283                 -1,
4284                 randomBoolean(),
4285                 UNASSIGNED_SEQ_NO,
4286                 0);
4287             final Engine.IndexResult indexResult = e.index(index);
4288             assertThat(indexResult.getSeqNo(), equalTo(seqNo));
4289             assertThat(seqNoGenerator.get(), equalTo(seqNo + 1));
4290             final Engine.Delete delete = new Engine.Delete(
4291                 id,
4292                 new Term("_id", parsedDocument.id()),
4293                 UNASSIGNED_SEQ_NO,
4294                 randomIntBetween(1, 8),
4295                 Versions.MATCH_ANY,
4296                 VersionType.INTERNAL,
4297                 Engine.Operation.Origin.PRIMARY,
4298                 System.nanoTime(),
4299                 UNASSIGNED_SEQ_NO,
4300                 0);
4301             final Engine.DeleteResult deleteResult = e.delete(delete);
4302             assertThat(deleteResult.getSeqNo(), equalTo(seqNo + 1));
4303             assertThat(seqNoGenerator.get(), equalTo(seqNo + 2));
4304         }
4305     }
4306     @Test
4307     public void testKeepTranslogAfterGlobalCheckpoint() throws Exception {
4308         IOUtils.close(engine, store);
4309         final IndexSettings indexSettings = new IndexSettings(defaultSettings.getIndexMetadata(), defaultSettings.getNodeSettings(),
4310                                                               defaultSettings.getScopedSettings());
4311         IndexMetadata.Builder builder = IndexMetadata.builder(indexSettings.getIndexMetadata())
4312             .settings(Settings.builder().put(indexSettings.getSettings())
4313                           .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), randomFrom("-1", "100micros", "30m"))
4314                           .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), randomFrom("-1", "512b", "1gb")));
4315         indexSettings.updateIndexMetadata(builder.build());
4316         final Path translogPath = createTempDir();
4317         store = createStore();
4318         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4319         store.createEmpty(Version.CURRENT.luceneVersion);
4320         final String translogUUID = Translog.createEmptyTranslog(translogPath, globalCheckpoint.get(), shardId, primaryTerm.get());
4321         store.associateIndexWithNewTranslog(translogUUID);
4322         final EngineConfig engineConfig = config(indexSettings, store, translogPath,
4323                                                  NoMergePolicy.INSTANCE, null, null, () -&gt; globalCheckpoint.get());
4324         final AtomicLong lastSyncedGlobalCheckpointBeforeCommit = new AtomicLong(Translog.readGlobalCheckpoint(translogPath, translogUUID));
4325         try (InternalEngine engine = new InternalEngine(engineConfig) {
4326             @Override
4327             protected void commitIndexWriter(IndexWriter writer, Translog translog, String syncId) throws IOException {
4328                 lastSyncedGlobalCheckpointBeforeCommit.set(Translog.readGlobalCheckpoint(translogPath, translogUUID));
4329                 if (rarely()) {
4330                     globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), getPersistedLocalCheckpoint()));
4331                 }
4332                 super.commitIndexWriter(writer, translog, syncId);
4333             }
4334         }) {
4335             engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
4336             int numDocs = scaledRandomIntBetween(10, 100);
4337             for (int docId = 0; docId &lt; numDocs; docId++) {
4338                 ParseContext.Document document = testDocumentWithTextField();
4339                 document.add(new Field(SourceFieldMapper.NAME, BytesReference.toBytes(B_1), SourceFieldMapper.Defaults.FIELD_TYPE));
4340                 engine.index(indexForDoc(testParsedDocument(Integer.toString(docId), null, document, B_1, null)));
4341                 if (frequently()) {
4342                     globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
4343                     engine.syncTranslog();
4344                 }
4345                 if (frequently()) {
4346                     engine.flush(randomBoolean(), true);
4347                     final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
4348                     final IndexCommit safeCommit = commits.get(0);
4349                     if (lastSyncedGlobalCheckpointBeforeCommit.get() == UNASSIGNED_SEQ_NO) {
4350                         assertThat(Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
4351                                    equalTo(SequenceNumbers.NO_OPS_PERFORMED));
4352                     } else {
4353                         assertThat(Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
4354                                    lessThanOrEqualTo(lastSyncedGlobalCheckpointBeforeCommit.get()));
4355                     }
4356                     for (int i = 1; i &lt; commits.size(); i++) {
4357                         assertThat(Long.parseLong(commits.get(i).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
4358                                    greaterThan(lastSyncedGlobalCheckpointBeforeCommit.get()));
4359                     }
4360                     long localCheckpointFromSafeCommit = Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
4361                     try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
4362                         assertThat(snapshot, SnapshotMatchers.containsSeqNoRange(localCheckpointFromSafeCommit + 1, docId));
4363                     }
4364                 }
4365             }
4366         }
4367     }
4368     @Test
4369     public void testConcurrentAppendUpdateAndRefresh() throws InterruptedException, IOException {
4370         int numDocs = scaledRandomIntBetween(100, 1000);
4371         CountDownLatch latch = new CountDownLatch(2);
4372         AtomicBoolean done = new AtomicBoolean(false);
4373         AtomicInteger numDeletes = new AtomicInteger();
4374         Thread thread = new Thread(() -&gt; {
4375             try {
4376                 latch.countDown();
4377                 latch.await();
4378                 for (int j = 0; j &lt; numDocs; j++) {
4379                     String docID = Integer.toString(j);
4380                     ParsedDocument doc = testParsedDocument(docID, null, testDocumentWithTextField(),
4381                                                             new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
4382                     Engine.Index operation = appendOnlyPrimary(doc, false, 1);
4383                     engine.index(operation);
4384                     if (rarely()) {
4385                         engine.delete(new Engine.Delete(
4386                             operation.id(),
4387                             operation.uid(),
4388                             UNASSIGNED_SEQ_NO,
4389                             primaryTerm.get(),
4390                             Versions.MATCH_ANY,
4391                             VersionType.INTERNAL,
4392                             Engine.Operation.Origin.PRIMARY,
4393                             System.nanoTime(),
4394                             UNASSIGNED_SEQ_NO,
4395                             0
4396                         ));
4397                         numDeletes.incrementAndGet();
4398                     } else {
4399                         doc = testParsedDocument(docID, null, testDocumentWithTextField("updated"),
4400                                                  new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
4401                         Engine.Index update = indexForDoc(doc);
4402                         engine.index(update);
4403                     }
4404                 }
4405             } catch (Exception e) {
4406                 throw new AssertionError(e);
4407             } finally {
4408                 done.set(true);
4409             }
4410         });
4411         thread.start();
4412         latch.countDown();
4413         latch.await();
4414         while (done.get() == false) {
4415             engine.refresh("test", Engine.SearcherScope.INTERNAL, true);
4416         }
4417         thread.join();
4418         engine.refresh("test", Engine.SearcherScope.INTERNAL, true);
4419         try (Engine.Searcher searcher = engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL)) {
4420             TopDocs search = searcher.search(new MatchAllDocsQuery(), searcher.getIndexReader().numDocs());
4421             for (int i = 0; i &lt; search.scoreDocs.length; i++) {
4422                 org.apache.lucene.document.Document luceneDoc = searcher.doc(search.scoreDocs[i].doc);
4423                 assertEquals("updated", luceneDoc.get("value"));
4424             }
4425             int totalNumDocs = numDocs - numDeletes.get();
4426             assertEquals(totalNumDocs, searcher.getIndexReader().numDocs());
4427         }
4428     }
4429     @Test
4430     public void testAcquireIndexCommit() throws Exception {
4431         IOUtils.close(engine, store);
4432         store = createStore();
4433         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4434         try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
4435             int numDocs = between(1, 20);
4436             for (int i = 0; i &lt; numDocs; i++) {
4437                 index(engine, i);
4438             }
4439             if (randomBoolean()) {
4440                 globalCheckpoint.set(numDocs - 1);
4441             }
4442             final boolean flushFirst = randomBoolean();
4443             final boolean safeCommit = randomBoolean();
4444             final Engine.IndexCommitRef snapshot;
4445             if (safeCommit) {
4446                 snapshot = engine.acquireSafeIndexCommit();
4447             } else {
4448                 snapshot = engine.acquireLastIndexCommit(flushFirst);
4449             }
4450             int moreDocs = between(1, 20);
4451             for (int i = 0; i &lt; moreDocs; i++) {
4452                 index(engine, numDocs + i);
4453             }
4454             globalCheckpoint.set(numDocs + moreDocs - 1);
4455             engine.flush();
4456             try (IndexReader reader = DirectoryReader.open(snapshot.getIndexCommit())) {
4457                 assertThat(reader.numDocs(), equalTo(flushFirst &amp;&amp; safeCommit == false ? numDocs : 0));
4458             }
4459             assertThat(DirectoryReader.listCommits(engine.store.directory()), hasSize(2));
4460             snapshot.close();
4461             engine.flush(true, true);
4462             assertThat(DirectoryReader.listCommits(engine.store.directory()), hasSize(1));
4463         }
4464     }
4465     @Test
4466     public void testCleanUpCommitsWhenGlobalCheckpointAdvanced() throws Exception {
4467         IOUtils.close(engine, store);
4468         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings("test",
4469                                                                                  Settings.builder().put(defaultSettings.getSettings())
4470                                                                                      .put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), -1)
4471                                                                                      .put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), -1).build());
4472         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4473         try (Store store = createStore();
4474              InternalEngine engine =
4475                  createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(),
4476                                      null, null, globalCheckpoint::get))) {
4477             final int numDocs = scaledRandomIntBetween(10, 100);
4478             for (int docId = 0; docId &lt; numDocs; docId++) {
4479                 index(engine, docId);
4480                 if (rarely()) {
4481                     engine.flush(randomBoolean(), true);
4482                 }
4483             }
4484             engine.flush(false, randomBoolean());
4485             globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
4486             engine.syncTranslog();
4487             List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
4488             assertThat(Long.parseLong(commits.get(0).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
4489                 lessThanOrEqualTo(globalCheckpoint.get()));
4490             for (int i = 1; i &lt; commits.size(); i++) {
4491                 assertThat(Long.parseLong(commits.get(i).getUserData().get(SequenceNumbers.MAX_SEQ_NO)),
4492                     greaterThan(globalCheckpoint.get()));
4493             }
4494             globalCheckpoint.set(randomLongBetween(engine.getPersistedLocalCheckpoint(), Long.MAX_VALUE));
4495             engine.syncTranslog();
4496             assertThat(DirectoryReader.listCommits(store.directory()), contains(commits.get(commits.size() - 1)));
4497             assertThat(engine.getTranslog().totalOperations(), equalTo(0));
4498         }
4499     }
4500     @Test
4501     public void testCleanupCommitsWhenReleaseSnapshot() throws Exception {
4502         IOUtils.close(engine, store);
4503         store = createStore();
4504         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4505         try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {
4506             final int numDocs = scaledRandomIntBetween(10, 100);
4507             for (int docId = 0; docId &lt; numDocs; docId++) {
4508                 index(engine, docId);
4509                 if (frequently()) {
4510                     engine.flush(randomBoolean(), true);
4511                 }
4512             }
4513             engine.flush(false, randomBoolean());
4514             int numSnapshots = between(1, 10);
4515             final List&lt;Engine.IndexCommitRef&gt; snapshots = new ArrayList&lt;&gt;();
4516             for (int i = 0; i &lt; numSnapshots; i++) {
4517                 snapshots.add(engine.acquireSafeIndexCommit());             }
4518             globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
4519             engine.syncTranslog();
4520             final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
4521             for (int i = 0; i &lt; numSnapshots - 1; i++) {
4522                 snapshots.get(i).close();
4523                 assertThat(DirectoryReader.listCommits(store.directory()), equalTo(commits));
4524             }
4525             snapshots.get(numSnapshots - 1).close();             assertThat(DirectoryReader.listCommits(store.directory()), hasSize(1));
4526         }
4527     }
4528     @Test
4529     public void testShouldPeriodicallyFlush() throws Exception {
4530         assertThat("Empty engine does not need flushing", engine.shouldPeriodicallyFlush(), equalTo(false));
4531         final Translog translog = engine.getTranslog();
4532         final IntSupplier uncommittedTranslogOperationsSinceLastCommit = () -&gt; {
4533             long localCheckpoint = Long.parseLong(engine.getLastCommittedSegmentInfos().userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
4534             return translog.totalOperationsByMinGen(translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration);
4535         };
4536         final long extraTranslogSizeInNewEngine =
4537             engine.getTranslog().stats().getUncommittedSizeInBytes() - Translog.DEFAULT_HEADER_SIZE_IN_BYTES;
4538         int numDocs = between(10, 100);
4539         for (int id = 0; id &lt; numDocs; id++) {
4540             final ParsedDocument doc =
4541                 testParsedDocument(Integer.toString(id), null, testDocumentWithTextField(), SOURCE, null);
4542             engine.index(indexForDoc(doc));
4543         }
4544         assertThat("Not exceeded translog flush threshold yet", engine.shouldPeriodicallyFlush(), equalTo(false));
4545         long flushThreshold = RandomNumbers.randomLongBetween(random(), 120,
4546             engine.getTranslog().stats().getUncommittedSizeInBytes()- extraTranslogSizeInNewEngine);
4547         final IndexSettings indexSettings = engine.config().getIndexSettings();
4548         final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
4549             .settings(Settings.builder().put(indexSettings.getSettings())
4550                 .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")).build();
4551         indexSettings.updateIndexMetadata(indexMetadata);
4552         engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
4553             indexSettings.getSoftDeleteRetentionOperations());
4554         assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(numDocs));
4555         assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
4556         engine.flush();
4557         assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt(), equalTo(0));
4558         for (int id = 0; id &lt; numDocs; id++) {
4559             final ParsedDocument doc =
4560                 testParsedDocument(Integer.toString(id), null, testDocumentWithTextField(), SOURCE, null);
4561             final Engine.IndexResult result = engine.index(replicaIndexForDoc(doc, 1L, id, false));
4562             assertThat(result.isCreated(), equalTo(false));
4563         }
4564         SegmentInfos lastCommitInfo = engine.getLastCommittedSegmentInfos();
4565         assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt(), equalTo(numDocs));
4566         assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
4567         engine.flush(false, false);
4568         assertThat(engine.getLastCommittedSegmentInfos(), not(sameInstance(lastCommitInfo)));
4569         assertThat(uncommittedTranslogOperationsSinceLastCommit.getAsInt(), equalTo(0));
4570         generateNewSeqNo(engine);         for (int id = 0; id &lt; numDocs; id++) {
4571             if (randomBoolean()) {
4572                 translog.rollGeneration();
4573             }
4574             final ParsedDocument doc =
4575                 testParsedDocument("new" + id, null, testDocumentWithTextField(), SOURCE, null);
4576             engine.index(replicaIndexForDoc(doc, 2L, generateNewSeqNo(engine), false));
4577             if (engine.shouldPeriodicallyFlush()) {
4578                 engine.flush();
4579                 assertThat(engine.getLastCommittedSegmentInfos(), not(sameInstance(lastCommitInfo)));
4580                 assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
4581             }
4582         }
4583     }
4584     @Test
4585     public void testShouldPeriodicallyFlushAfterMerge() throws Exception {
4586         assertThat("Empty engine does not need flushing", engine.shouldPeriodicallyFlush(), equalTo(false));
4587         ParsedDocument doc =
4588             testParsedDocument(Integer.toString(0), null, testDocumentWithTextField(), SOURCE, null);
4589         engine.index(indexForDoc(doc));
4590         engine.refresh("test");
4591         assertThat("Not exceeded translog flush threshold yet", engine.shouldPeriodicallyFlush(), equalTo(false));
4592         final IndexSettings indexSettings = engine.config().getIndexSettings();
4593         final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
4594             .settings(Settings.builder().put(indexSettings.getSettings())
4595                           .put(IndexSettings.INDEX_FLUSH_AFTER_MERGE_THRESHOLD_SIZE_SETTING.getKey(),  "0b")).build();
4596         indexSettings.updateIndexMetadata(indexMetadata);
4597         engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
4598                                  indexSettings.getSoftDeleteRetentionOperations());
4599         assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(1));
4600         assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
4601         doc = testParsedDocument(Integer.toString(1), null, testDocumentWithTextField(), SOURCE, null);
4602         engine.index(indexForDoc(doc));
4603         assertThat(engine.getTranslog().stats().getUncommittedOperations(), equalTo(2));
4604         engine.refresh("test");
4605         engine.forceMerge(false, 1, false, false, false, UUIDs.randomBase64UUID());
4606         assertBusy(() -&gt; {
4607             assertThat(engine.shouldPeriodicallyFlush(), equalTo(true));
4608         });
4609         engine.flush();
4610         assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
4611     }
4612     @Test
4613     public void testStressShouldPeriodicallyFlush() throws Exception {
4614         final long flushThreshold = randomLongBetween(120, 5000);
4615         final long generationThreshold = randomLongBetween(1000, 5000);
4616         final IndexSettings indexSettings = engine.config().getIndexSettings();
4617         final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
4618             .settings(Settings.builder().put(indexSettings.getSettings())
4619                           .put(IndexSettings.INDEX_TRANSLOG_GENERATION_THRESHOLD_SIZE_SETTING.getKey(), generationThreshold + "b")
4620                           .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")).build();
4621         indexSettings.updateIndexMetadata(indexMetadata);
4622         engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
4623             indexSettings.getSoftDeleteRetentionOperations());
4624         final int numOps = scaledRandomIntBetween(100, 10_000);
4625         for (int i = 0; i &lt; numOps; i++) {
4626             final long localCheckPoint = engine.getProcessedLocalCheckpoint();
4627             final long seqno = randomLongBetween(Math.max(0, localCheckPoint), localCheckPoint + 5);
4628             final ParsedDocument doc =
4629                 testParsedDocument(Long.toString(seqno), null, testDocumentWithTextField(), SOURCE, null);
4630             engine.index(replicaIndexForDoc(doc, 1L, seqno, false));
4631             if (rarely() &amp;&amp; engine.getTranslog().shouldRollGeneration()) {
4632                 engine.rollTranslogGeneration();
4633             }
4634             if (rarely() || engine.shouldPeriodicallyFlush()) {
4635                 engine.flush();
4636                 assertThat(engine.shouldPeriodicallyFlush(), equalTo(false));
4637             }
4638         }
4639     }
4640     @Test
4641     public void testStressUpdateSameDocWhileGettingIt() throws IOException, InterruptedException {
4642         final int iters = randomIntBetween(1, 15);
4643         for (int i = 0; i &lt; iters; i++) {
4644             try (Store store = createStore(); InternalEngine engine = createEngine(store, createTempDir())) {
4645                 final IndexSettings indexSettings = engine.config().getIndexSettings();
4646                 final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
4647                     .settings(Settings.builder().put(indexSettings.getSettings())
4648                                   .put(IndexSettings.INDEX_GC_DELETES_SETTING.getKey(), TimeValue.timeValueMillis(1))).build();
4649                 engine.engineConfig.getIndexSettings().updateIndexMetadata(indexMetadata);
4650                 engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
4651                     indexSettings.getSoftDeleteRetentionOperations());
4652                 ParsedDocument document = testParsedDocument(Integer.toString(0), null, testDocumentWithTextField(), SOURCE, null);
4653                 final Engine.Index doc = new Engine.Index(newUid(document), document, UNASSIGNED_SEQ_NO, 0,
4654                     Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(),
4655                     -1, false, UNASSIGNED_SEQ_NO, 0);
4656                 engine.index(doc);
4657                 engine.delete(new Engine.Delete(
4658                     doc.id(),
4659                     doc.uid(),
4660                     UNASSIGNED_SEQ_NO,
4661                     primaryTerm.get(),
4662                     Versions.MATCH_ANY,
4663                     VersionType.INTERNAL,
4664                     Engine.Operation.Origin.PRIMARY,
4665                     System.nanoTime(),
4666                     UNASSIGNED_SEQ_NO,
4667                     0
4668                 ));
4669                 ParsedDocument document1 = testParsedDocument(Integer.toString(1), null, testDocumentWithTextField(), SOURCE, null);
4670                 engine.index(new Engine.Index(newUid(document1), document1, UNASSIGNED_SEQ_NO, 0, Versions.MATCH_ANY, VersionType.INTERNAL,
4671                     Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false,
4672                     UNASSIGNED_SEQ_NO, 0));
4673                 engine.refresh("test");
4674                 ParsedDocument document2 = testParsedDocument(Integer.toString(2), null, testDocumentWithTextField(), SOURCE, null);
4675                 engine.index(new Engine.Index(newUid(document2), document2, UNASSIGNED_SEQ_NO, 0, Versions.MATCH_ANY, VersionType.INTERNAL,
4676                     Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false,
4677                     UNASSIGNED_SEQ_NO, 0));
4678                 engine.refresh("test");
4679                 ParsedDocument document3 = testParsedDocument(Integer.toString(3), null, testDocumentWithTextField(), SOURCE, null);
4680                 final Engine.Index doc3 = new Engine.Index(newUid(document3), document3, UNASSIGNED_SEQ_NO, 0,
4681                     Versions.MATCH_ANY, VersionType.INTERNAL, Engine.Operation.Origin.PRIMARY, System.nanoTime(),
4682                     -1, false, UNASSIGNED_SEQ_NO, 0);
4683                 engine.index(doc3);
4684                 engine.engineConfig.setEnableGcDeletes(true);
4685                 CountDownLatch awaitStarted = new CountDownLatch(1);
4686                 Thread thread = new Thread(() -&gt; {
4687                     awaitStarted.countDown();
4688                     try (Engine.GetResult getResult = engine.get(new Engine.Get(
4689                         doc3.id(), doc3.uid()), engine::acquireSearcher)) {
4690                         assertThat(getResult.docIdAndVersion(), is(notNullValue()));
4691                     }
4692                 });
4693                 thread.start();
4694                 awaitStarted.await();
4695                 try (Engine.GetResult getResult = engine.get(
4696                     new Engine.Get(doc.id(), doc.uid()),
4697                     engine::acquireSearcher)) {
4698                     assertThat(getResult.docIdAndVersion(), is(nullValue()));
4699                 }
4700                 thread.join();
4701             }
4702         }
4703     }
4704     @Test
4705     public void testPruneOnlyDeletesAtMostLocalCheckpoint() throws Exception {
4706         final AtomicLong clock = new AtomicLong(0);
4707         threadPool = spy(threadPool);
4708         when(threadPool.relativeTimeInMillis()).thenAnswer(invocation -&gt; clock.get());
4709         final long gcInterval = randomIntBetween(0, 10);
4710         final IndexSettings indexSettings = engine.config().getIndexSettings();
4711         final IndexMetadata indexMetadata = IndexMetadata.builder(indexSettings.getIndexMetadata())
4712             .settings(Settings.builder().put(indexSettings.getSettings())
4713                           .put(IndexSettings.INDEX_GC_DELETES_SETTING.getKey(), TimeValue.timeValueMillis(gcInterval).getStringRep())).build();
4714         indexSettings.updateIndexMetadata(indexMetadata);
4715         try (Store store = createStore();
4716              InternalEngine engine = createEngine(store, createTempDir())) {
4717             engine.config().setEnableGcDeletes(false);
4718             for (int i = 0, docs = scaledRandomIntBetween(0, 10); i &lt; docs; i++) {
4719                 index(engine, i);
4720             }
4721             final long deleteBatch = between(10, 20);
4722             final long gapSeqNo = randomLongBetween(
4723                 engine.getSeqNoStats(-1).getMaxSeqNo() + 1, engine.getSeqNoStats(-1).getMaxSeqNo() + deleteBatch);
4724             for (int i = 0; i &lt; deleteBatch; i++) {
4725                 final long seqno = generateNewSeqNo(engine);
4726                 if (seqno != gapSeqNo) {
4727                     if (randomBoolean()) {
4728                         clock.incrementAndGet();
4729                     }
4730                     engine.delete(replicaDeleteForDoc(UUIDs.randomBase64UUID(), 1, seqno, threadPool.relativeTimeInMillis()));
4731                 }
4732             }
4733             List&lt;DeleteVersionValue&gt; tombstones = new ArrayList&lt;&gt;(tombstonesInVersionMap(engine).values());
4734             engine.config().setEnableGcDeletes(true);
4735             clock.set(randomLongBetween(gcInterval, deleteBatch + gcInterval));
4736             engine.refresh("test");
4737             tombstones.removeIf(v -&gt; v.seqNo &lt; gapSeqNo &amp;&amp; v.time &lt; clock.get() - gcInterval);
4738             assertThat(tombstonesInVersionMap(engine).values(), containsInAnyOrder(tombstones.toArray()));
4739             clock.set(randomLongBetween(deleteBatch + gcInterval * 4/3, 100));             engine.refresh("test");
4740             tombstones.removeIf(v -&gt; v.seqNo &lt; gapSeqNo);
4741             assertThat(tombstonesInVersionMap(engine).values(), containsInAnyOrder(tombstones.toArray()));
4742             clock.set(between(0, 100));
4743             if (randomBoolean()) {
4744                 engine.index(replicaIndexForDoc(testParsedDocument("d", null, testDocumentWithTextField(),
4745                                                                    SOURCE, null), 1, gapSeqNo, false));
4746             } else {
4747                 engine.delete(replicaDeleteForDoc(UUIDs.randomBase64UUID(), Versions.MATCH_ANY,
4748                                                   gapSeqNo, threadPool.relativeTimeInMillis()));
4749             }
4750             clock.set(randomLongBetween(100 + gcInterval * 4/3, Long.MAX_VALUE));             engine.refresh("test");
4751             assertThat(tombstonesInVersionMap(engine).values(), empty());
4752         }
4753     }
4754     @Test
4755     public void testTrimUnsafeCommits() throws Exception {
4756         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4757         final int maxSeqNo = 40;
4758         final List&lt;Long&gt; seqNos = LongStream.rangeClosed(0, maxSeqNo).boxed().collect(Collectors.toList());
4759         Collections.shuffle(seqNos, random());
4760         try (Store store = createStore()) {
4761             EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(),
4762                                          null, null, globalCheckpoint::get);
4763             final List&lt;Long&gt; commitMaxSeqNo = new ArrayList&lt;&gt;();
4764             final long minTranslogGen;
4765             try (InternalEngine engine = createEngine(config)) {
4766                 for (int i = 0; i &lt; seqNos.size(); i++) {
4767                     ParsedDocument doc = testParsedDocument(Long.toString(seqNos.get(i)), null, testDocument(),
4768                                                             new BytesArray("{}"), null);
4769                     Engine.Index index = new Engine.Index(newUid(doc), doc, seqNos.get(i), 0,
4770                                                           1, null, REPLICA, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0);
4771                     engine.index(index);
4772                     if (randomBoolean()) {
4773                         engine.flush();
4774                         final Long maxSeqNoInCommit = seqNos.subList(0, i + 1).stream().max(Long::compareTo).orElse(-1L);
4775                         commitMaxSeqNo.add(maxSeqNoInCommit);
4776                     }
4777                 }
4778                 globalCheckpoint.set(randomInt(maxSeqNo));
4779                 engine.syncTranslog();
4780                 minTranslogGen = engine.getTranslog().getMinFileGeneration();
4781             }
4782             store.trimUnsafeCommits(globalCheckpoint.get(), minTranslogGen,config.getIndexSettings().getIndexVersionCreated());
4783             long safeMaxSeqNo =
4784                 commitMaxSeqNo.stream().filter(s -&gt; s &lt;= globalCheckpoint.get())
4785                     .reduce((s1, s2) -&gt; s2)                     .orElse(SequenceNumbers.NO_OPS_PERFORMED);
4786             final List&lt;IndexCommit&gt; commits = DirectoryReader.listCommits(store.directory());
4787             assertThat(commits, hasSize(1));
4788             assertThat(commits.get(0).getUserData().get(SequenceNumbers.MAX_SEQ_NO), equalTo(Long.toString(safeMaxSeqNo)));
4789             try (IndexReader reader = DirectoryReader.open(commits.get(0))) {
4790                 for (LeafReaderContext context: reader.leaves()) {
4791                     final NumericDocValues values = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);
4792                     if (values != null) {
4793                         for (int docID = 0; docID &lt; context.reader().maxDoc(); docID++) {
4794                             if (values.advanceExact(docID) == false) {
4795                                 throw new AssertionError("Document does not have a seq number: " + docID);
4796                             }
4797                             assertThat(values.longValue(), lessThanOrEqualTo(globalCheckpoint.get()));
4798                         }
4799                     }
4800                 }
4801             }
4802         }
4803     }
4804     @Test
4805     public void testLuceneHistoryOnPrimary() throws Exception {
4806         final List&lt;Engine.Operation&gt; operations = generateSingleDocHistory(
4807             false, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, "1");
4808         assertOperationHistoryInLucene(operations);
4809     }
4810     @Test
4811     public void testLuceneHistoryOnReplica() throws Exception {
4812         final List&lt;Engine.Operation&gt; operations = generateSingleDocHistory(
4813             true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, "2");
4814         Randomness.shuffle(operations);
4815         assertOperationHistoryInLucene(operations);
4816     }
4817     private void assertOperationHistoryInLucene(List&lt;Engine.Operation&gt; operations) throws IOException {
4818         final MergePolicy keepSoftDeleteDocsMP = new SoftDeletesRetentionMergePolicy(
4819             Lucene.SOFT_DELETES_FIELD, MatchAllDocsQuery::new, engine.config().getMergePolicy());
4820         Settings.Builder settings = Settings.builder()
4821             .put(defaultSettings.getSettings())
4822             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
4823             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
4824         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
4825         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
4826         Set&lt;Long&gt; expectedSeqNos = new HashSet&lt;&gt;();
4827         try (Store store = createStore();
4828              Engine engine = createEngine(config(indexSettings, store, createTempDir(), keepSoftDeleteDocsMP, null))) {
4829             for (Engine.Operation op : operations) {
4830                 if (op instanceof Engine.Index) {
4831                     Engine.IndexResult indexResult = engine.index((Engine.Index) op);
4832                     assertThat(indexResult.getFailure(), nullValue());
4833                     expectedSeqNos.add(indexResult.getSeqNo());
4834                 } else {
4835                     Engine.DeleteResult deleteResult = engine.delete((Engine.Delete) op);
4836                     assertThat(deleteResult.getFailure(), nullValue());
4837                     expectedSeqNos.add(deleteResult.getSeqNo());
4838                 }
4839                 if (rarely()) {
4840                     engine.refresh("test");
4841                 }
4842                 if (rarely()) {
4843                     engine.flush();
4844                 }
4845                 if (rarely()) {
4846                     engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
4847                 }
4848             }
4849             MapperService mapperService = createMapperService("test");
4850             List&lt;Translog.Operation&gt; actualOps = readAllOperationsInLucene(engine, mapperService);
4851             assertThat(actualOps.stream().map(o -&gt; o.seqNo()).collect(Collectors.toList()), containsInAnyOrder(expectedSeqNos.toArray()));
4852             assertConsistentHistoryBetweenTranslogAndLuceneIndex(engine, mapperService);
4853         }
4854     }
4855     @Test
4856     public void testKeepMinRetainedSeqNoByMergePolicy() throws IOException {
4857         IOUtils.close(engine, store);
4858         Settings.Builder settings = Settings.builder()
4859             .put(defaultSettings.getSettings())
4860             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)
4861             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
4862         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
4863         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
4864         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
4865         final long primaryTerm = randomLongBetween(1, Long.MAX_VALUE);
4866         final AtomicLong retentionLeasesVersion = new AtomicLong();
4867         final AtomicReference&lt;RetentionLeases&gt; retentionLeasesHolder = new AtomicReference&lt;&gt;(
4868             new RetentionLeases(primaryTerm, retentionLeasesVersion.get(), Collections.emptyList()));
4869         final List&lt;Engine.Operation&gt; operations = generateSingleDocHistory(
4870             true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 10, 300, "2");
4871         Randomness.shuffle(operations);
4872         Set&lt;Long&gt; existingSeqNos = new HashSet&lt;&gt;();
4873         store = createStore();
4874         engine = createEngine(config(
4875             indexSettings,
4876             store,
4877             createTempDir(),
4878             newMergePolicy(),
4879             null,
4880             null,
4881             globalCheckpoint::get,
4882             retentionLeasesHolder::get
4883         ));
4884         assertThat(engine.getMinRetainedSeqNo(), equalTo(0L));
4885         long lastMinRetainedSeqNo = engine.getMinRetainedSeqNo();
4886         for (Engine.Operation op : operations) {
4887             final Engine.Result result;
4888             if (op instanceof Engine.Index) {
4889                 result = engine.index((Engine.Index) op);
4890             } else {
4891                 result = engine.delete((Engine.Delete) op);
4892             }
4893             existingSeqNos.add(result.getSeqNo());
4894             if (randomBoolean()) {
4895                 engine.syncTranslog();                 assertEquals(engine.getProcessedLocalCheckpoint(), engine.getPersistedLocalCheckpoint());
4896                 globalCheckpoint.set(
4897                     randomLongBetween(globalCheckpoint.get(), engine.getLocalCheckpointTracker().getPersistedCheckpoint()));
4898             }
4899             if (randomBoolean()) {
4900                 retentionLeasesVersion.incrementAndGet();
4901                 final int length = randomIntBetween(0, 8);
4902                 final List&lt;RetentionLease&gt; leases = new ArrayList&lt;&gt;(length);
4903                 for (int i = 0; i &lt; length; i++) {
4904                     final String id = randomAlphaOfLength(8);
4905                     final long retainingSequenceNumber = randomLongBetween(0, Math.max(0, globalCheckpoint.get()));
4906                     final long timestamp = randomLongBetween(0L, Long.MAX_VALUE);
4907                     final String source = randomAlphaOfLength(8);
4908                     leases.add(new RetentionLease(id, retainingSequenceNumber, timestamp, source));
4909                 }
4910                 retentionLeasesHolder.set(new RetentionLeases(primaryTerm, retentionLeasesVersion.get(), leases));
4911             }
4912             if (rarely()) {
4913                 settings.put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomLongBetween(0, 10));
4914                 indexSettings.updateIndexMetadata(IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
4915                 engine.onSettingsChanged(indexSettings.getTranslogRetentionAge(), indexSettings.getTranslogRetentionSize(),
4916                     indexSettings.getSoftDeleteRetentionOperations());
4917             }
4918             if (rarely()) {
4919                 engine.refresh("test");
4920             }
4921             if (rarely()) {
4922                 engine.flush(true, true);
4923                 assertThat(Long.parseLong(engine.getLastCommittedSegmentInfos().userData.get(Engine.MIN_RETAINED_SEQNO)),
4924                            equalTo(engine.getMinRetainedSeqNo()));
4925             }
4926             if (rarely()) {
4927                 engine.forceMerge(randomBoolean(), 1, false, false, false, UUIDs.randomBase64UUID());
4928             }
4929             try (Closeable ignored = engine.acquireHistoryRetentionLock(Engine.HistorySource.INDEX)) {
4930                 long minRetainSeqNos = engine.getMinRetainedSeqNo();
4931                 assertThat(minRetainSeqNos, lessThanOrEqualTo(globalCheckpoint.get() + 1));
4932                 Long[] expectedOps = existingSeqNos.stream().filter(seqno -&gt; seqno &gt;= minRetainSeqNos).toArray(Long[]::new);
4933                 Set&lt;Long&gt; actualOps = readAllOperationsInLucene(engine, createMapperService("test")).stream()
4934                     .map(Translog.Operation::seqNo).collect(Collectors.toSet());
4935                 assertThat(actualOps, containsInAnyOrder(expectedOps));
4936             }
4937             try (Engine.IndexCommitRef commitRef = engine.acquireSafeIndexCommit()) {
4938                 IndexCommit safeCommit = commitRef.getIndexCommit();
4939                 if (safeCommit.getUserData().containsKey(Engine.MIN_RETAINED_SEQNO)) {
4940                     lastMinRetainedSeqNo = Long.parseLong(safeCommit.getUserData().get(Engine.MIN_RETAINED_SEQNO));
4941                 }
4942             }
4943         }
4944         if (randomBoolean()) {
4945             engine.close();
4946         } else {
4947             engine.flushAndClose();
4948         }
4949         try (InternalEngine recoveringEngine = new InternalEngine(engine.config())) {
4950             assertThat(recoveringEngine.getMinRetainedSeqNo(), equalTo(lastMinRetainedSeqNo));
4951         }
4952     }
4953     @Test
4954     public void testLastRefreshCheckpoint() throws Exception {
4955         AtomicBoolean done = new AtomicBoolean();
4956         Thread[] refreshThreads = new Thread[between(1, 8)];
4957         CountDownLatch latch = new CountDownLatch(refreshThreads.length);
4958         for (int i = 0; i &lt; refreshThreads.length; i++) {
4959             latch.countDown();
4960             refreshThreads[i] = new Thread(() -&gt; {
4961                 while (done.get() == false) {
4962                     long checkPointBeforeRefresh = engine.getProcessedLocalCheckpoint();
4963                     engine.refresh("test", randomFrom(Engine.SearcherScope.values()), true);
4964                     assertThat(engine.lastRefreshedCheckpoint(), greaterThanOrEqualTo(checkPointBeforeRefresh));
4965                 }
4966             });
4967             refreshThreads[i].start();
4968         }
4969         latch.await();
4970         List&lt;Engine.Operation&gt; ops = generateSingleDocHistory(
4971             true, VersionType.EXTERNAL, 1, 10, 1000, "1");
4972         concurrentlyApplyOps(ops, engine);
4973         done.set(true);
4974         for (Thread thread : refreshThreads) {
4975             thread.join();
4976         }
4977         engine.refresh("test");
4978         assertThat(engine.lastRefreshedCheckpoint(), equalTo(engine.getProcessedLocalCheckpoint()));
4979     }
4980     @Test
4981     public void testLuceneSnapshotRefreshesOnlyOnce() throws Exception {
4982         final MapperService mapperService = createMapperService("test");
4983         final long maxSeqNo = randomLongBetween(10, 50);
4984         final AtomicLong refreshCounter = new AtomicLong();
4985         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
4986             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(Settings.builder().
4987                 put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)).build());
4988         try (Store store = createStore();
4989              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(),
4990                                                          null,
4991                                                          new ReferenceManager.RefreshListener() {
4992                                                              @Override
4993                                                              public void beforeRefresh() {
4994                                                                  refreshCounter.incrementAndGet();
4995                                                              }
4996                                                              @Override
4997                                                              public void afterRefresh(boolean didRefresh) {
4998                                                              }
4999                                                          }, () -&gt; SequenceNumbers.NO_OPS_PERFORMED))) {
5000             for (long seqNo = 0; seqNo &lt;= maxSeqNo; seqNo++) {
5001                 final ParsedDocument doc = testParsedDocument("id_" + seqNo, null, testDocumentWithTextField("test"),
5002                                                               new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
5003                 engine.index(replicaIndexForDoc(doc, 1, seqNo, randomBoolean()));
5004             }
5005             final long initialRefreshCount = refreshCounter.get();
5006             final Thread[] snapshotThreads = new Thread[between(1, 3)];
5007             CountDownLatch latch = new CountDownLatch(1);
5008             for (int i = 0; i &lt; snapshotThreads.length; i++) {
5009                 final long min = randomLongBetween(0, maxSeqNo - 5);
5010                 final long max = randomLongBetween(min, maxSeqNo);
5011                 snapshotThreads[i] = new Thread(new AbstractRunnable() {
5012                     @Override
5013                     public void onFailure(Exception e) {
5014                         throw new AssertionError(e);
5015                     }
5016                     @Override
5017                     protected void doRun() throws Exception {
5018                         latch.await();
5019                         Translog.Snapshot changes = engine.newChangesSnapshot("test", mapperService, min, max, true);
5020                         changes.close();
5021                     }
5022                 });
5023                 snapshotThreads[i].start();
5024             }
5025             latch.countDown();
5026             for (Thread thread : snapshotThreads) {
5027                 thread.join();
5028             }
5029             assertThat(refreshCounter.get(), equalTo(initialRefreshCount + 1L));
5030             assertThat(engine.lastRefreshedCheckpoint(), equalTo(maxSeqNo));
5031         }
5032     }
5033     @Test
5034     public void testAcquireSearcherOnClosingEngine() throws Exception {
5035         engine.close();
5036         expectThrows(AlreadyClosedException.class, () -&gt; engine.acquireSearcher("test", Engine.SearcherScope.INTERNAL));
5037     }
5038     @Test
5039     public void testNoOpOnClosingEngine() throws Exception {
5040         engine.close();
5041         Settings settings = Settings.builder()
5042             .put(defaultSettings.getSettings())
5043             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
5044         IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5045             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5046         assertTrue(indexSettings.isSoftDeleteEnabled());
5047         try (Store store = createStore();
5048              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
5049             engine.close();
5050             expectThrows(AlreadyClosedException.class, () -&gt; engine.noOp(
5051                 new Engine.NoOp(2, primaryTerm.get(), LOCAL_TRANSLOG_RECOVERY, System.nanoTime(), "reason")));
5052         }
5053     }
5054     @Test
5055     public void testSoftDeleteOnClosingEngine() throws Exception {
5056         engine.close();
5057         Settings settings = Settings.builder()
5058             .put(defaultSettings.getSettings())
5059             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
5060         IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5061             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5062         assertTrue(indexSettings.isSoftDeleteEnabled());
5063         try (Store store = createStore();
5064              InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
5065             engine.close();
5066             expectThrows(AlreadyClosedException.class, () -&gt; engine.delete(replicaDeleteForDoc("test", 42, 7, System.nanoTime())));
5067         }
5068     }
5069     @Test
5070     public void testTrackMaxSeqNoOfUpdatesOrDeletesOnPrimary() throws Exception {
5071         engine.close();
5072         Set&lt;String&gt; liveDocIds = new HashSet&lt;&gt;();
5073         engine = new InternalEngine(engine.config());
5074         assertThat(engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(-1L));
5075         int numOps = between(1, 500);
5076         for (int i = 0; i &lt; numOps; i++) {
5077             long currentMaxSeqNoOfUpdates = engine.getMaxSeqNoOfUpdatesOrDeletes();
5078             ParsedDocument doc = createParsedDoc(Integer.toString(between(1, 100)), null);
5079             if (randomBoolean()) {
5080                 Engine.IndexResult result = engine.index(indexForDoc(doc));
5081                 if (liveDocIds.add(doc.id()) == false) {
5082                     assertThat("update operations on primary must advance max_seq_no_of_updates",
5083                                engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(Math.max(currentMaxSeqNoOfUpdates, result.getSeqNo())));
5084                 } else {
5085                     assertThat("append operations should not advance max_seq_no_of_updates",
5086                                engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(currentMaxSeqNoOfUpdates));
5087                 }
5088             } else {
5089                 Engine.DeleteResult result = engine.delete(new Engine.Delete(
5090                     doc.id(),
5091                     newUid(doc.id()),
5092                     UNASSIGNED_SEQ_NO,
5093                     primaryTerm.get(),
5094                     Versions.MATCH_ANY,
5095                     VersionType.INTERNAL,
5096                     Engine.Operation.Origin.PRIMARY,
5097                     System.nanoTime(),
5098                     UNASSIGNED_SEQ_NO,
5099                     0
5100                 ));
5101                 liveDocIds.remove(doc.id());
5102                 assertThat("delete operations on primary must advance max_seq_no_of_updates",
5103                            engine.getMaxSeqNoOfUpdatesOrDeletes(), equalTo(Math.max(currentMaxSeqNoOfUpdates, result.getSeqNo())));
5104             }
5105         }
5106     }
5107     @Test
5108     public void testRebuildLocalCheckpointTrackerAndVersionMap() throws Exception {
5109         Settings.Builder settings = Settings.builder()
5110             .put(defaultSettings.getSettings())
5111             .put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), 10000)
5112             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true);
5113         final IndexMetadata indexMetadata = IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build();
5114         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(indexMetadata);
5115         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
5116         Path translogPath = createTempDir();
5117         List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 500), randomBoolean(), randomBoolean());
5118         List&lt;List&lt;Engine.Operation&gt;&gt; commits = new ArrayList&lt;&gt;();
5119         commits.add(new ArrayList&lt;&gt;());
5120         try (Store store = createStore()) {
5121             EngineConfig config = config(indexSettings, store, translogPath, NoMergePolicy.INSTANCE, null, null, globalCheckpoint::get);
5122             final List&lt;DocIdSeqNoAndSource&gt; docs;
5123             try (InternalEngine engine = createEngine(config)) {
5124                 List&lt;Engine.Operation&gt; flushedOperations = new ArrayList&lt;&gt;();
5125                 for (Engine.Operation op : operations) {
5126                     flushedOperations.add(op);
5127                     applyOperation(engine, op);
5128                     if (randomBoolean()) {
5129                         engine.syncTranslog();
5130                         globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
5131                     }
5132                     if (randomInt(100) &lt; 10) {
5133                         engine.refresh("test");
5134                     }
5135                     if (randomInt(100) &lt; 5) {
5136                         engine.flush(true, true);
5137                         flushedOperations.sort(Comparator.comparing(Engine.Operation::seqNo));
5138                         commits.add(new ArrayList&lt;&gt;(flushedOperations));
5139                     }
5140                 }
5141                 docs = getDocIds(engine, true);
5142             }
5143             List&lt;Engine.Operation&gt; operationsInSafeCommit = null;
5144             for (int i = commits.size() - 1; i &gt;= 0; i--) {
5145                 if (commits.get(i).stream().allMatch(op -&gt; op.seqNo() &lt;= globalCheckpoint.get())) {
5146                     operationsInSafeCommit = commits.get(i);
5147                     break;
5148                 }
5149             }
5150             assertThat(operationsInSafeCommit, notNullValue());
5151             try (InternalEngine engine = new InternalEngine(config)) {                 final Map&lt;BytesRef, Engine.Operation&gt; deletesAfterCheckpoint = new HashMap&lt;&gt;();
5152                 for (Engine.Operation op : operationsInSafeCommit) {
5153                     if (op instanceof Engine.NoOp == false &amp;&amp; op.seqNo() &gt; engine.getPersistedLocalCheckpoint()) {
5154                         deletesAfterCheckpoint.put(new Term(IdFieldMapper.NAME, Uid.encodeId(op.id())).bytes(), op);
5155                     }
5156                 }
5157                 deletesAfterCheckpoint.values().removeIf(o -&gt; o instanceof Engine.Delete == false);
5158                 final Map&lt;BytesRef, VersionValue&gt; versionMap = engine.getVersionMap();
5159                 for (BytesRef uid : deletesAfterCheckpoint.keySet()) {
5160                     final VersionValue versionValue = versionMap.get(uid);
5161                     final Engine.Operation op = deletesAfterCheckpoint.get(uid);
5162                     final String msg = versionValue + " vs " +
5163                         "op[" + op.operationType() + "id=" + op.id() + " seqno=" + op.seqNo() + " term=" + op.primaryTerm() + "]";
5164                     assertThat(versionValue, instanceOf(DeleteVersionValue.class));
5165                     assertThat(msg, versionValue.seqNo, equalTo(op.seqNo()));
5166                     assertThat(msg, versionValue.term, equalTo(op.primaryTerm()));
5167                     assertThat(msg, versionValue.version, equalTo(op.version()));
5168                 }
5169                 assertThat(versionMap.keySet(), equalTo(deletesAfterCheckpoint.keySet()));
5170                 final LocalCheckpointTracker tracker = engine.getLocalCheckpointTracker();
5171                 final Set&lt;Long&gt; seqNosInSafeCommit = operationsInSafeCommit.stream().map(op -&gt; op.seqNo()).collect(Collectors.toSet());
5172                 for (Engine.Operation op : operations) {
5173                     assertThat(
5174                         "seq_no=" + op.seqNo() + " max_seq_no=" + tracker.getMaxSeqNo() + " checkpoint=" + tracker.getProcessedCheckpoint(),
5175                         tracker.hasProcessed(op.seqNo()), equalTo(seqNosInSafeCommit.contains(op.seqNo())));
5176                 }
5177                 engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
5178                 assertThat(getDocIds(engine, true), equalTo(docs));
5179             }
5180         }
5181     }
5182     @Test
5183     public void testRequireSoftDeletesWhenAccessingChangesSnapshot() throws Exception {
5184         try (Store store = createStore()) {
5185             final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5186                 IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(Settings.builder().
5187                     put(defaultSettings.getSettings()).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false)).build());
5188             try (InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), newMergePolicy(), null))) {
5189                 AssertionError error = expectThrows(AssertionError.class,
5190                                                     () -&gt; engine.newChangesSnapshot("test", createMapperService("test"), 0, randomNonNegativeLong(), randomBoolean()));
5191                 assertThat(error.getMessage(), containsString("does not have soft-deletes enabled"));
5192             }
5193         }
5194     }
5195     private void assertLuceneOperations(InternalEngine engine,
5196                                         long expectedAppends,
5197                                         long expectedUpdates,
5198                                         long expectedDeletes) {
5199         String message = "Lucene operations mismatched;" +
5200                          " appends [actual:" + engine.getNumDocAppends() + ", expected:" + expectedAppends + "]," +
5201                          " updates [actual:" + engine.getNumDocUpdates() + ", expected:" + expectedUpdates + "]," +
5202                          " deletes [actual:" + engine.getNumDocDeletes() + ", expected:" + expectedDeletes + "]";
5203         assertThat(message, engine.getNumDocAppends(), equalTo(expectedAppends));
5204         assertThat(message, engine.getNumDocUpdates(), equalTo(expectedUpdates));
5205         assertThat(message, engine.getNumDocDeletes(), equalTo(expectedDeletes));
5206     }
5207     @Test
5208     public void testStoreHonorsLuceneVersion() throws IOException {
5209         for (Version createdVersion : Arrays.asList(
5210                 Version.CURRENT, VersionUtils.getPreviousMinorVersion(), VersionUtils.getFirstVersion())) {
5211             Settings settings = Settings.builder()
5212                     .put(indexSettings())
5213                     .put(IndexMetadata.SETTING_VERSION_CREATED, createdVersion).build();
5214             IndexSettings indexSettings = IndexSettingsModule.newIndexSettings("test", settings);
5215             try (Store store = createStore();
5216                     InternalEngine engine = createEngine(config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
5217                 ParsedDocument doc = testParsedDocument("1", null, new Document(),
5218                         new BytesArray("{}".getBytes("UTF-8")), null);
5219                 engine.index(appendOnlyPrimary(doc, false, 1));
5220                 engine.refresh("test");
5221                 try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
5222                     LeafReader leafReader = getOnlyLeafReader(searcher.getIndexReader());
5223                     assertEquals(createdVersion.luceneVersion.major, leafReader.getMetaData().getCreatedVersionMajor());
5224                 }
5225             }
5226         }
5227     }
5228     @Test
5229     public void testMaxSeqNoInCommitUserData() throws Exception {
5230         AtomicBoolean running = new AtomicBoolean(true);
5231         Thread rollTranslog = new Thread(() -&gt; {
5232             while (running.get() &amp;&amp; engine.getTranslog().currentFileGeneration() &lt; 500) {
5233                 engine.rollTranslogGeneration();             }
5234         });
5235         rollTranslog.start();
5236         Thread indexing = new Thread(() -&gt; {
5237             long seqNo = 0;
5238             while (running.get() &amp;&amp; seqNo &lt;= 1000) {
5239                 try {
5240                     String id = Long.toString(between(1, 50));
5241                     if (randomBoolean()) {
5242                         ParsedDocument doc = testParsedDocument(id, null, testDocumentWithTextField(), SOURCE, null);
5243                         engine.index(replicaIndexForDoc(doc, 1L, seqNo, false));
5244                     } else {
5245                         engine.delete(replicaDeleteForDoc(id, 1L, seqNo, 0L));
5246                     }
5247                     seqNo++;
5248                 } catch (IOException e) {
5249                     throw new AssertionError(e);
5250                 }
5251             }
5252         });
5253         indexing.start();
5254         int numCommits = between(5, 20);
5255         for (int i = 0; i &lt; numCommits; i++) {
5256             engine.flush(false, true);
5257         }
5258         running.set(false);
5259         indexing.join();
5260         rollTranslog.join();
5261         assertMaxSeqNoInCommitUserData(engine);
5262     }
5263     @Test
5264     public void testPruneAwayDeletedButRetainedIds() throws Exception {
5265         IOUtils.close(engine, store);
5266         Settings settings = Settings.builder()
5267             .put(defaultSettings.getSettings())
5268             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
5269         IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5270             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5271         store = createStore(indexSettings, newDirectory());
5272         LogDocMergePolicy policy = new LogDocMergePolicy();
5273         policy.setMinMergeDocs(10000);
5274         try (InternalEngine engine = createEngine(indexSettings, store, createTempDir(), policy)) {
5275             int numDocs = between(1, 20);
5276             logger.info("" + numDocs);
5277             for (int i = 0; i &lt; numDocs; i++) {
5278                 index(engine, i);
5279             }
5280             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
5281             engine.delete(new Engine.Delete("0", newUid("0"), primaryTerm.get()));
5282             engine.refresh("test");
5283             try (Searcher searcher = engine.acquireSearcher("test")) {
5284                 IndexReader reader = searcher.getIndexReader();
5285                 assertEquals(2, reader.leaves().size());
5286                 LeafReaderContext leafReaderContext = reader.leaves().get(0);
5287                 LeafReader leafReader = leafReaderContext.reader();
5288                 assertEquals("the delete and the tombstone", 1, leafReader.numDeletedDocs());
5289                 assertEquals(numDocs, leafReader.maxDoc());
5290                 Terms id = leafReader.terms("_id");
5291                 assertNotNull(id);
5292                 assertEquals("deleted IDs are NOT YET pruned away", reader.numDocs() + 1, id.size());
5293                 TermsEnum iterator = id.iterator();
5294                 assertTrue(iterator.seekExact(Uid.encodeId("0")));
5295             }
5296             engine.forceMerge(true, 1, false, false, false, UUIDs.randomBase64UUID());
5297             engine.refresh("test");
5298             try (Searcher searcher = engine.acquireSearcher("test")) {
5299                 IndexReader reader = searcher.getIndexReader();
5300                 assertEquals(1, reader.leaves().size());
5301                 LeafReaderContext leafReaderContext = reader.leaves().get(0);
5302                 LeafReader leafReader = leafReaderContext.reader();
5303                 assertEquals("the delete and the tombstone", 2, leafReader.numDeletedDocs());
5304                 assertEquals(numDocs + 1, leafReader.maxDoc());
5305                 Terms id = leafReader.terms("_id");
5306                 if (numDocs == 1) {
5307                     assertNull(id);                     assertEquals(0, leafReader.numDocs());
5308                 } else {
5309                     assertNotNull(id);
5310                     assertEquals("deleted IDs are pruned away", reader.numDocs(), id.size());
5311                     TermsEnum iterator = id.iterator();
5312                     assertFalse(iterator.seekExact(Uid.encodeId("0")));
5313                 }
5314              }
5315          }
5316     }
5317     @Test
5318     public void testRecoverFromLocalTranslog() throws Exception {
5319         final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);
5320         Path translogPath = createTempDir();
5321         List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 500), randomBoolean(), randomBoolean());
5322         try (Store store = createStore()) {
5323             EngineConfig config = config(defaultSettings, store, translogPath, newMergePolicy(), null, null, globalCheckpoint::get);
5324             final List&lt;DocIdSeqNoAndSource&gt; docs;
5325             try (InternalEngine engine = createEngine(config)) {
5326                 for (Engine.Operation op : operations) {
5327                     applyOperation(engine, op);
5328                     if (randomBoolean()) {
5329                         engine.syncTranslog();
5330                         globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getPersistedLocalCheckpoint()));
5331                     }
5332                     if (randomInt(100) &lt; 10) {
5333                         engine.refresh("test");
5334                     }
5335                     if (randomInt(100) &lt; 5) {
5336                         engine.flush();
5337                     }
5338                     if (randomInt(100) &lt; 5) {
5339                         engine.forceMerge(randomBoolean(), 1, false, false, false, UUIDs.randomBase64UUID());
5340                     }
5341                 }
5342                 if (randomBoolean()) {
5343                     engine.syncTranslog();
5344                     globalCheckpoint.set(engine.getPersistedLocalCheckpoint());
5345                     engine.flush();
5346                 }
5347                 docs = getDocIds(engine, true);
5348             }
5349             try (InternalEngine engine = new InternalEngine(config)) {
5350                 engine.onSettingsChanged(TimeValue.MINUS_ONE, ByteSizeValue.ZERO, 0);
5351                 engine.recoverFromTranslog(translogHandler, Long.MAX_VALUE);
5352                 assertThat(getDocIds(engine, randomBoolean()), equalTo(docs));
5353                 if (engine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo() == globalCheckpoint.get()) {
5354                     assertThat("engine should trim all unreferenced translog after recovery",
5355                         engine.getTranslog().getMinFileGeneration(), equalTo(engine.getTranslog().currentFileGeneration()));
5356                 }
5357             }
5358         }
5359     }
5360     private Map&lt;BytesRef, DeleteVersionValue&gt; tombstonesInVersionMap(InternalEngine engine) {
5361         return engine.getVersionMap().entrySet().stream()
5362             .filter(e -&gt; e.getValue() instanceof DeleteVersionValue)
5363             .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; (DeleteVersionValue) e.getValue()));
5364     }
5365     @Test
5366     public void testTreatDocumentFailureAsFatalError() throws Exception {
5367         AtomicReference&lt;IOException&gt; addDocException = new AtomicReference&lt;&gt;();
5368         IndexWriterFactory indexWriterFactory = (dir, iwc) -&gt; new IndexWriter(dir, iwc) {
5369             @Override
5370             public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) throws IOException {
5371                 final IOException ex = addDocException.getAndSet(null);
5372                 if (ex != null) {
5373                     throw ex;
5374                 }
5375                 return super.addDocument(doc);
5376             }
5377         };
5378         try (Store store = createStore();
5379              InternalEngine engine = createEngine(defaultSettings,
5380                                                   store,
5381                                                   createTempDir(),
5382                                                   NoMergePolicy.INSTANCE,
5383                                                   indexWriterFactory)) {
5384             final ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField(), SOURCE, null);
5385             Engine.Operation.Origin origin = randomFrom(REPLICA, LOCAL_RESET, PEER_RECOVERY);
5386             Engine.Index index = new Engine.Index(
5387                 newUid(doc),
5388                 doc,
5389                 randomNonNegativeLong(),
5390                 primaryTerm.get(),
5391                 randomNonNegativeLong(),
5392                 null,
5393                 origin,
5394                 System.nanoTime(),
5395                 -1,
5396                 false,
5397                 UNASSIGNED_SEQ_NO,
5398                 UNASSIGNED_PRIMARY_TERM);
5399             addDocException.set(new IOException("simulated"));
5400             expectThrows(IOException.class, () -&gt; engine.index(index));
5401             assertTrue(engine.isClosed.get());
5402             assertNotNull(engine.failedEngine.get());
5403         }
5404     }
5405     @Test
5406     public void testAlwaysRecordReplicaOrPeerRecoveryOperationsToTranslog() throws Exception {
5407         List&lt;Engine.Operation&gt; operations = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean());
5408         applyOperations(engine, operations);
5409         Set&lt;Long&gt; seqNos = operations.stream().map(Engine.Operation::seqNo).collect(Collectors.toSet());
5410         try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
5411             assertThat(snapshot.totalOperations(), equalTo(operations.size()));
5412             assertThat(TestTranslog.drainSnapshot(snapshot, false).stream().map(Translog.Operation::seqNo).collect(Collectors.toSet()),
5413                 equalTo(seqNos));
5414         }
5415         primaryTerm.set(randomLongBetween(primaryTerm.get(), Long.MAX_VALUE));
5416         engine.rollTranslogGeneration();
5417         engine.trimOperationsFromTranslog(primaryTerm.get(), NO_OPS_PERFORMED);         try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
5418             assertThat(snapshot.totalOperations(), equalTo(0));
5419             assertNull(snapshot.next());
5420         }
5421         applyOperations(engine, operations);
5422         try (Translog.Snapshot snapshot = getTranslog(engine).newSnapshot()) {
5423             assertThat(snapshot.totalOperations(), equalTo(operations.size()));
5424             assertThat(TestTranslog.drainSnapshot(snapshot, false).stream().map(Translog.Operation::seqNo).collect(Collectors.toSet()),
5425                 equalTo(seqNos));
5426         }
5427     }
5428     @Test
5429     public void testNoOpFailure() throws IOException {
5430         engine.close();
5431         final Settings settings = Settings.builder()
5432             .put(defaultSettings.getSettings())
5433             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build();
5434         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5435             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5436         try (Store store = createStore();
5437              Engine engine = createEngine((dir, iwc) -&gt; new IndexWriter(dir, iwc) {
5438                  @Override
5439                  public long addDocument(Iterable&lt;? extends IndexableField&gt; doc) {
5440                      throw new IllegalArgumentException("fatal");
5441                  }
5442              }, null, null, config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
5443             final Engine.NoOp op = new Engine.NoOp(0, 0, PRIMARY, System.currentTimeMillis(), "test");
5444             final IllegalArgumentException e = expectThrows(IllegalArgumentException. class, () -&gt; engine.noOp(op));
5445             assertThat(e.getMessage(), equalTo("fatal"));
5446             assertTrue(engine.isClosed.get());
5447             assertThat(engine.failedEngine.get(), not(nullValue()));
5448             assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
5449             assertThat(engine.failedEngine.get().getMessage(), equalTo("fatal"));
5450         }
5451     }
5452     @Test
5453     public void testDeleteFailureSoftDeletesEnabledDocAlreadyDeleted() throws IOException {
5454         runTestDeleteFailure(true, InternalEngine::delete);
5455     }
5456     @Test
5457     public void testDeleteFailureSoftDeletesEnabled() throws IOException {
5458         runTestDeleteFailure(true, (engine, op) -&gt; {});
5459     }
5460     @Test
5461     public void testDeleteFailureSoftDeletesDisabled() throws IOException {
5462         runTestDeleteFailure(false, (engine, op) -&gt; {});
5463     }
5464     private void runTestDeleteFailure(
5465         final boolean softDeletesEnabled,
5466         final CheckedBiConsumer&lt;InternalEngine, Engine.Delete, IOException&gt; consumer) throws IOException {
5467         engine.close();
5468         final Settings settings = Settings.builder()
5469             .put(defaultSettings.getSettings())
5470             .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), softDeletesEnabled).build();
5471         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5472             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5473         final AtomicReference&lt;ThrowingIndexWriter&gt; iw = new AtomicReference&lt;&gt;();
5474         try (Store store = createStore();
5475              InternalEngine engine = createEngine(
5476                  (dir, iwc) -&gt; {
5477                      iw.set(new ThrowingIndexWriter(dir, iwc));
5478                      return iw.get();
5479                  },
5480                  null,
5481                  null,
5482                  config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null)
5483             )) {
5484             engine.index(new Engine.Index(newUid("0"), primaryTerm.get(), InternalEngineTests.createParsedDoc("0", null)));
5485             final Engine.Delete op = new Engine.Delete("0", newUid("0"), primaryTerm.get());
5486             consumer.accept(engine, op);
5487             iw.get().setThrowFailure(() -&gt; new IllegalArgumentException("fatal"));
5488             final IllegalArgumentException e = expectThrows(IllegalArgumentException. class, () -&gt; engine.delete(op));
5489             assertThat(e.getMessage(), equalTo("fatal"));
5490             assertTrue(engine.isClosed.get());
5491             assertThat(engine.failedEngine.get(), not(nullValue()));
5492             assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
5493             assertThat(engine.failedEngine.get().getMessage(), equalTo("fatal"));
5494         }
5495     }
5496     @Test
5497     public void testRealtimeGetOnlyRefreshIfNeeded() throws Exception {
5498         final AtomicInteger refreshCount = new AtomicInteger();
5499         final ReferenceManager.RefreshListener refreshListener = new ReferenceManager.RefreshListener() {
5500             @Override
5501             public void beforeRefresh() {
5502             }
5503             @Override
5504             public void afterRefresh(boolean didRefresh) {
5505                 if (didRefresh) {
5506                     refreshCount.incrementAndGet();
5507                 }
5508             }
5509         };
5510         try (Store store = createStore()) {
5511             final EngineConfig config = config(
5512                 defaultSettings,
5513                 store,
5514                 createTempDir(),
5515                 newMergePolicy(),
5516                 null,
5517                 refreshListener,
5518                 null,
5519                 null
5520             );
5521             try (InternalEngine engine = createEngine(config)) {
5522                 int numDocs = randomIntBetween(10, 100);
5523                 Set&lt;String&gt; ids = new HashSet&lt;&gt;();
5524                 for (int i = 0; i &lt; numDocs; i++) {
5525                     String id = Integer.toString(i);
5526                     engine.index(indexForDoc(createParsedDoc(id, null)));
5527                     ids.add(id);
5528                 }
5529                 final int refreshCountBeforeGet = refreshCount.get();
5530                 Thread[] getters = new Thread[randomIntBetween(1, 4)];
5531                 Phaser phaser = new Phaser(getters.length + 1);
5532                 for (int t = 0; t &lt; getters.length; t++) {
5533                     getters[t] = new Thread(() -&gt; {
5534                         phaser.arriveAndAwaitAdvance();
5535                         int iters = randomIntBetween(1, 10);
5536                         for (int i = 0; i &lt; iters; i++) {
5537                             ParsedDocument doc = createParsedDoc(randomFrom(ids), null);
5538                             try (Engine.GetResult getResult = engine.get(newGet(doc), engine::acquireSearcher)) {
5539                                 assertThat(getResult.docIdAndVersion(), notNullValue());
5540                             }
5541                         }
5542                     });
5543                     getters[t].start();
5544                 }
5545                 phaser.arriveAndAwaitAdvance();
5546                 for (int i = 0; i &lt; numDocs; i++) {
5547                     engine.index(indexForDoc(createParsedDoc("more-" + i, null)));
5548                 }
5549                 for (Thread getter : getters) {
5550                     getter.join();
5551                 }
5552                 assertThat(refreshCount.get(), lessThanOrEqualTo(refreshCountBeforeGet + 1));
5553             }
5554         }
5555     }
5556     @Test
5557     public void testRefreshDoesNotBlockClosing() throws Exception {
5558         final CountDownLatch refreshStarted = new CountDownLatch(1);
5559         final CountDownLatch engineClosed = new CountDownLatch(1);
5560         final ReferenceManager.RefreshListener refreshListener = new ReferenceManager.RefreshListener() {
5561             @Override
5562             public void beforeRefresh() {
5563                 refreshStarted.countDown();
5564                 try {
5565                     engineClosed.await();
5566                 } catch (InterruptedException e) {
5567                     throw new AssertionError(e);
5568                 }
5569             }
5570             @Override
5571             public void afterRefresh(boolean didRefresh) {
5572                 assertFalse(didRefresh);
5573             }
5574         };
5575         try (Store store = createStore()) {
5576             final EngineConfig config = config(
5577                 defaultSettings,
5578                 store,
5579                 createTempDir(),
5580                 newMergePolicy(),
5581                 null,
5582                 refreshListener,
5583                 null,
5584                 null
5585             );
5586             try (InternalEngine engine = createEngine(config)) {
5587                 if (randomBoolean()) {
5588                     engine.index(indexForDoc(createParsedDoc("id", null)));
5589                 }
5590                 threadPool.executor(ThreadPool.Names.REFRESH).execute(() -&gt;
5591                     expectThrows(AlreadyClosedException.class,
5592                         () -&gt; engine.refresh("test", randomFrom(Engine.SearcherScope.values()), true)));
5593                 refreshStarted.await();
5594                 engine.close();
5595                 engineClosed.countDown();
5596             }
5597         }
5598     }
5599     @Test
5600     public void testDeleteDocumentFailuresShouldFailEngine() throws IOException {
5601         engine.close();
5602         final Settings settings = Settings.builder()
5603             .put(defaultSettings.getSettings())
5604             .build();
5605         final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(
5606             IndexMetadata.builder(defaultSettings.getIndexMetadata()).settings(settings).build());
5607         final AtomicReference&lt;ThrowingIndexWriter&gt; iw = new AtomicReference&lt;&gt;();
5608         try (Store store = createStore();
5609              InternalEngine engine = createEngine(
5610                  (dir, iwc) -&gt; {
5611                      iw.set(new ThrowingIndexWriter(dir, iwc));
5612                      return iw.get();
5613                  },
5614                  null,
5615                  null,
5616                  config(indexSettings, store, createTempDir(), NoMergePolicy.INSTANCE, null))) {
5617             engine.index(new Engine.Index(
5618                 newUid("0"), InternalEngineTests.createParsedDoc("0", null), UNASSIGNED_SEQ_NO, primaryTerm.get(),
5619                 Versions.MATCH_DELETED, VersionType.INTERNAL,
5620                 Engine.Operation.Origin.PRIMARY, System.nanoTime(), -1, false, UNASSIGNED_SEQ_NO, 0));
5621             Engine.Delete op = new Engine.Delete(
5622                 "0",
5623                 newUid("0"),
5624                 UNASSIGNED_SEQ_NO,
5625                 primaryTerm.get(),
5626                 Versions.MATCH_ANY,
5627                 VersionType.INTERNAL,
5628                 Engine.Operation.Origin.PRIMARY,
5629                 System.nanoTime(),
5630                 UNASSIGNED_SEQ_NO,
5631                 0
5632             );
5633             iw.get().setThrowFailure(() -&gt; new IllegalArgumentException("fatal"));
5634             final IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -&gt; engine.delete(op));
5635             assertThat(e.getMessage(), equalTo("fatal"));
5636             assertThat(engine.isClosed.get(), is(true));
5637             assertThat(engine.failedEngine.get(), not(nullValue()));
5638             assertThat(engine.failedEngine.get(), instanceOf(IllegalArgumentException.class));
5639             assertThat(engine.failedEngine.get().getMessage(), equalTo("fatal"));
5640         }
5641     }
5642     public static &lt;T&gt; void assertThatIfAssertionEnabled(T actual, Matcher&lt;? super T&gt; matcher) {
5643         if (InternalEngineTests.class.desiredAssertionStatus()) {
5644             assertThat(actual, matcher);
5645         }
5646     }
5647     @Test
5648     public void testProducesStoredFieldsReader() throws Exception {
5649         ParsedDocument doc = testParsedDocument("1", null, testDocumentWithTextField("test"),
5650                                                 new BytesArray("{}".getBytes(Charset.defaultCharset())), null);
5651         Engine.Index operation = randomBoolean() ?
5652             appendOnlyPrimary(doc, false, 1)
5653             : appendOnlyReplica(doc, false, 1, randomIntBetween(0, 5));
5654         engine.index(operation);
5655         engine.refresh("test");
5656         try (Engine.Searcher searcher = engine.acquireSearcher("test")) {
5657             IndexReader reader = searcher.getIndexReader();
5658             assertThat(reader.leaves().size(), Matchers.greaterThanOrEqualTo(1));
5659             for (LeafReaderContext context: reader.leaves()) {
5660                 assertThat(context.reader(), Matchers.instanceOf(SequentialStoredFieldsLeafReader.class));
5661                 SequentialStoredFieldsLeafReader lf = (SequentialStoredFieldsLeafReader) context.reader();
5662                 assertNotNull(lf.getSequentialStoredFieldsReader());
5663             }
5664         }
5665     }
5666 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
