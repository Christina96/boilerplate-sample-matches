<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for MapsTransformValuesUnmodifiableIteratorTest.java &amp; TreeRangeSet_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MapsTransformValuesUnmodifiableIteratorTest.java &amp; TreeRangeSet_1.java
      </h3>
<h1 align="center">
        15.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MapsTransformValuesUnmodifiableIteratorTest.java (28.390596%)<th>TreeRangeSet_1.java (10.994398%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(46-59)<td><a href="#" name="0">(99-112)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-75)<td><a href="#" name="1">(917-924)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(19-36)<td><a href="#" name="2">(24-41)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(320-328)<td><a href="#" name="3">(577-585)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(182-186)<td><a href="#" name="4">(830-836)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(116-121)<td><a href="#" name="5">(496-501)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(102-109)<td><a href="#" name="6">(624-631)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(91-96)<td><a href="#" name="7">(325-330)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(77-83)<td><a href="#" name="8">(432-439)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(60-66)<td><a href="#" name="9">(505-511)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(363-367)<td><a href="#" name="10">(145-149)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(122-127)<td><a href="#" name="11">(671-676)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(110-115)<td><a href="#" name="12">(742-747)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(97-101)<td><a href="#" name="13">(153-157)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(85-90)<td><a href="#" name="14">(334-339)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapsTransformValuesUnmodifiableIteratorTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="2"></a>
package com.google.common.collect;

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.collect.testing.MapInterfaceTest;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Tests for {@link Maps#transformValues} when the backing map's views have iterators that don't
 * support {@code remove()}.
 *
 * @author Jared Levy
 */
@</b></font>GwtCompatible
public class MapsTransformValuesUnmodifiableIteratorTest extends MapInterfaceTest&lt;String, String&gt; {
  // TODO(jlevy): Move shared code of this class and MapsTransformValuesTest
  // to a superclass.

  public MapsTransformValuesUnmodifiableIteratorTest() {
    super(true, true, false /*supportsPut*/, true, true, false);
<a name="0"></a>  }

  private static class UnmodifiableIteratorMap&lt;K, V&gt; extends ForwardingMap&lt;K, V&gt; {
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final Map&lt;K, V&gt; delegate;

    UnmodifiableIteratorMap(Map&lt;K, V&gt; delegate) {
      this.delegate = delegate;
    }

    @Override
    protected Map&lt;K, V&gt; delegate() {
      return delegate;
    }

<a name="9"></a>    @Override
    public Set&lt;K&gt; keySet() {
      return</b></font> new ForwardingSet&lt;K&gt;() {
        <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
        protected Set&lt;K&gt; delegate() {
          return delegate.keySet();
        }

<a name="1"></a>        @Override
        public Iterator&lt;K&gt; iterator() {</b></font>
          return Iterators.unmodifiableIterator(delegate.keySet().iterator());
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
          return delegate.keySet().removeAll(c);
        }
<a name="8"></a>
        @</b></font>Override
        public boolean retainAll(Collection&lt;?&gt; c) {
          return <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.keySet().retainAll(c);
        }
      };
    }

<a name="14"></a>    @Override
    public Collection&lt;V&gt; values() {</b></font>
      return new ForwardingCollection&lt;V&gt;() {
        <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
        protected Collection&lt;V&gt; delegate() {
          return delegate.values();
<a name="7"></a>        }

        @</b></font>Override
        public Iterator&lt;V&gt; iterator() <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
          return Iterators.unmodifiableIterator(delegate.values().iterator());
        }
<a name="13"></a>
        @Override
        public boolean removeAll(Collection&lt;?&gt; c</b></font>) {
          <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return delegate.values().removeAll(c);
        }
<a name="6"></a>
        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {</b></font>
          return <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.values().retainAll(c);
        }
      };
    }

<a name="12"></a>    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
      return</b></font> new ForwardingSet&lt;Entry&lt;K, V&gt;&gt;() {
        <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
        protected Set&lt;Entry&lt;K, V&gt;&gt; delegate() {
          return delegate.entrySet();
<a name="5"></a>        }

        @</b></font>Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
          return Iterators.unmodifiableIterator(delegate.entrySet().iterator());
        }
<a name="11"></a>
        @Override
        public boolean removeAll(Collection&lt;?&gt; c</b></font>) {
          return <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.entrySet().removeAll(c);
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
          return delegate.entrySet().retainAll</b></font>(c);
        }
      };
    }
  }

  @Override
  protected Map&lt;String, String&gt; makeEmptyMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    return Maps.transformValues(
        new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
  }

  @Override
  protected Map&lt;String, String&gt; makePopulatedMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    return Maps.transformValues(
        new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
  }

  @Override
  protected String getKeyNotInPopulatedMap() throws UnsupportedOperationException {
    return "z";
  }

  @Override
  protected String getValueNotInPopulatedMap() throws UnsupportedOperationException {
    return "26";
  }

  /** Helper assertion comparing two maps */
  private void assertMapsEqual(Map&lt;?, ?&gt; expected, Map&lt;?, ?&gt; map) {
    assertEquals(expected, map);
    assertEquals(expected.hashCode(), map.hashCode());
    assertEquals(expected.entrySet(), map.entrySet());

    // Assert that expectedValues &gt; mapValues and that
    // mapValues &gt; expectedValues; i.e. that expectedValues == mapValues.
    Collection&lt;?&gt; expectedValues = expected.values();
    Collection&lt;?&gt; mapValues = map.values();
    assertEquals(expectedValues.size(), mapValues.size());
    assertTrue(expectedValues.containsAll(mapValues));
    assertTrue(mapValues.containsAll(expectedValues));
  }

  public void testTransformEmptyMapEquality() {
    Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.&lt;String, Integer&gt;of(), Functions.toStringFunction());
    assertMapsEqual(Maps.newHashMap(), map);
<a name="4"></a>  }

  public void testTransformSingletonMapEquality() {
    <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map&lt;String, String&gt; expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get</b></font>("a"));
  }

  public void testTransformIdentityFunctionEquality() {
    Map&lt;String, Integer&gt; underlying = ImmutableMap.of("a", 1);
    Map&lt;String, Integer&gt; map = Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());
    assertMapsEqual(underlying, map);
  }

  public void testTransformPutEntryIsUnsupported() {
    Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }

  public void testTransformRemoveEntry() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }

  public void testTransformEqualityOfMapsWithNullValues() {
    Map&lt;String, String&gt; underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map&lt;String, Boolean&gt; map =
        Maps.transformValues(
            underlying,
            new Function&lt;String, Boolean&gt;() {
              @Override
              public Boolean apply(@Nullable String from) {
                return from == null;
              }
            });
    Map&lt;String, Boolean&gt; expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }

  public void testTransformReflectsUnderlyingMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }

  public void testTransformChangesAreReflectedInUnderlyingMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newLinkedHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    underlying.put("d", 4);
    underlying.put("e", 5);
    underlying.put("f", 6);
    underlying.put("g", 7);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());

    map.remove("a");
    assertFalse(underlying.containsKey("a"));

    Set&lt;String&gt; keys = map.keySet();
    keys.remove("b");
    assertFalse(underlying.containsKey("b"));

    Iterator&lt;String&gt; keyIterator = keys.iterator();
    keyIterator.next();
    keyIterator.remove();
    assertFalse(underlying.containsKey("c"));

    Collection&lt;String&gt; values = map.values();
    values.remove("4");
    assertFalse(underlying.containsKey("d"));

    Iterator&lt;String&gt; valueIterator = values.iterator();
    valueIterator.next();
    valueIterator.remove();
    assertFalse(underlying.containsKey("e"));

    Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();
    Entry&lt;String, String&gt; firstEntry = entries.iterator().next();
    entries.remove(firstEntry);
    assertFalse(underlying.containsKey("f"));

    Iterator&lt;Entry&lt;String, String&gt;&gt; entryIterator = entries.iterator();
    entryIterator.next();
    entryIterator.remove();
    assertFalse(underlying.containsKey("g"));

    assertTrue(underlying.isEmpty());
    assertTrue(map.isEmpty());
    assertTrue(keys.isEmpty());
    assertTrue(values.isEmpty());
    assertTrue(entries.isEmpty());
  }
<a name="3"></a>
  public void testTransformEquals() {
    Map&lt;String, Integer&gt; underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map&lt;String, Integer&gt; expected = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());

    assertMapsEqual(expected, expected);

    Map&lt;String, Integer&gt; equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map&lt;String, Integer&gt; map =
        Maps.transformValues(equalToUnderlying, Functions.&lt;Integer&gt;identity());
    assertMapsEqual</b></font>(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function&lt;Integer, Integer&gt;() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }

  public void testTransformEntrySetContains() {
    Map&lt;String, Boolean&gt; underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map&lt;String, Boolean&gt; map =
        Maps.transformValues(
            underlying,
            new Function&lt;Boolean, Boolean&gt;() {
              @Override
              public Boolean apply(@Nullable Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set&lt;Entry&lt;String, Boolean&gt;&gt; entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
<a name="10"></a>    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }

  @</b></font>Override
  public void testKeySetRemoveAllNullFromEmpty() {
    try {
      super.testKeySetRemoveAllNullFromEmpty();
    } catch (RuntimeException tolerated) {
      // GWT's HashMap.keySet().removeAll(null) doesn't throws NPE.
    }
  }

  @Override
  public void testEntrySetRemoveAllNullFromEmpty() {
    try {
      super.testEntrySetRemoveAllNullFromEmpty();
    } catch (RuntimeException tolerated) {
      // GWT's HashMap.entrySet().removeAll(null) doesn't throws NPE.
    }
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeRangeSet_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.Beta;
<a name="2"></a>import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.Serializable;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeMap;
import javax.annotation.CheckForNull;

/**
 * An implementation of {@link RangeSet} backed by a {@link TreeMap}.
 *
 * @author Louis Wasserman
 * @since 14.0
 */
@</b></font>Beta
@GwtIncompatible // uses NavigableMap
@ElementTypesAreNonnullByDefault
public class TreeRangeSet&lt;C extends Comparable&lt;?&gt;&gt; extends AbstractRangeSet&lt;C&gt;
    implements Serializable {

  @VisibleForTesting final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;

  /** Creates an empty {@code TreeRangeSet} instance. */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create() {
    return new TreeRangeSet&lt;&gt;(new TreeMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;());
  }

  /** Returns a {@code TreeRangeSet} initialized with the ranges in the specified range set. */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(RangeSet&lt;C&gt; rangeSet) {
    TreeRangeSet&lt;C&gt; result = create();
    result.addAll(rangeSet);
    return result;
  }

  /**
   * Returns a {@code TreeRangeSet} representing the union of the specified ranges.
   *
   * &lt;p&gt;This is the smallest {@code RangeSet} which encloses each of the specified ranges. An
   * element will be contained in this {@code RangeSet} if and only if it is contained in at least
   * one {@code Range} in {@code ranges}.
   *
   * @since 21.0
   */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
    TreeRangeSet&lt;C&gt; result = create();
    result.addAll(ranges);
    return result;
  }

  private TreeRangeSet(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerCut) {
    this.rangesByLowerBound = rangesByLowerCut;
  }

  @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asRanges;
  @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges;

  @Override
  public Set&lt;Range&lt;C&gt;&gt; asRanges() {
    Set&lt;Range&lt;C&gt;&gt; result = asRanges;
    return (result == null) ? asRanges = new AsRanges(rangesByLowerBound.values()) : result;
  }

  @Override
  public Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges() {
    Set&lt;Range&lt;C&gt;&gt; result = asDescendingSetOfRanges;
    return (result == null)
        ? asDescendingSetOfRanges = new AsRanges(rangesByLowerBound.descendingMap().values())
        : result;
  }
<a name="0"></a>
  final class AsRanges extends ForwardingCollection&lt;Range&lt;C&gt;&gt; implements Set&lt;Range&lt;C&gt;&gt; {

    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Collection&lt;Range&lt;C&gt;&gt; delegate;

    AsRanges(Collection&lt;Range&lt;C&gt;&gt; delegate) {
      this.delegate = delegate;
    }

    @Override
    protected Collection&lt;Range&lt;C&gt;&gt; delegate() {
      return delegate;
    }

    @Override
    public int hashCode() {
      return</b></font> Sets.hashCodeImpl(this);
    }

    @Override
    public boolean equals(@CheckForNull Object o) {
      return Sets.equalsImpl(this, o);
    }
  }

  @Override
  @CheckForNull
  public Range&lt;C&gt; rangeContaining(C value) {
    checkNotNull(value);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
    if (floorEntry != null &amp;&amp; floorEntry.getValue().contains(value)) {
      return floorEntry.getValue();
    } else {
      // TODO(kevinb): revisit this design choice
      return null;
    }
  }

  @Override
  public boolean intersects(Range&lt;C&gt; range) {
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; ceilingEntry = rangesByLowerBound.ceilingEntry(range.lowerBound);
    if (ceilingEntry != null
        &amp;&amp; ceilingEntry.getValue().isConnected(range)
        &amp;&amp; !ceilingEntry.getValue().intersection(range).isEmpty()) {
      return true;
<a name="10"></a>    }
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; priorEntry = rangesByLowerBound.lowerEntry(range.lowerBound);
    return priorEntry != null
        &amp;&amp; <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>priorEntry.getValue().isConnected(range)
        &amp;&amp; !priorEntry.getValue().intersection(range).isEmpty();
  }

  @</b></font>Override
<a name="13"></a>  public boolean encloses(Range&lt;C&gt; range) {
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
    <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range);
  }

  @CheckForNull
  private Range&lt;C&gt; rangeEnclosing(Range&lt;C&gt; range) {</b></font>
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
    return (floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range))
        ? floorEntry.getValue()
        : null;
  }

  @Override
  public Range&lt;C&gt; span() {
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = rangesByLowerBound.firstEntry();
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lastEntry = rangesByLowerBound.lastEntry();
    if (firstEntry == null || lastEntry == null) {
      /*
       * Either both are null or neither is: Either the set is empty, or it's not. But we check both
       * to make the nullness checker happy.
       */
      throw new NoSuchElementException();
    }
    return Range.create(firstEntry.getValue().lowerBound, lastEntry.getValue().upperBound);
  }

  @Override
  public void add(Range&lt;C&gt; rangeToAdd) {
    checkNotNull(rangeToAdd);

    if (rangeToAdd.isEmpty()) {
      return;
    }

    // We will use { } to illustrate ranges currently in the range set, and &lt; &gt;
    // to illustrate rangeToAdd.
    Cut&lt;C&gt; lbToAdd = rangeToAdd.lowerBound;
    Cut&lt;C&gt; ubToAdd = rangeToAdd.upperBound;

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(lbToAdd);
    if (entryBelowLB != null) {
      // { &lt;
      Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
      if (rangeBelowLB.upperBound.compareTo(lbToAdd) &gt;= 0) {
        // { &lt; }, and we will need to coalesce
        if (rangeBelowLB.upperBound.compareTo(ubToAdd) &gt;= 0) {
          // { &lt; &gt; }
          ubToAdd = rangeBelowLB.upperBound;
          /*
           * TODO(cpovirk): can we just "return;" here? Or, can we remove this if() entirely? If
           * not, add tests to demonstrate the problem with each approach
           */
        }
        lbToAdd = rangeBelowLB.lowerBound;
      }
    }

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(ubToAdd);
    if (entryBelowUB != null) {
      // { &gt;
      Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
      if (rangeBelowUB.upperBound.compareTo(ubToAdd) &gt;= 0) {
        // { &gt; }, and we need to coalesce
        ubToAdd = rangeBelowUB.upperBound;
      }
    }

    // Remove ranges which are strictly enclosed.
    rangesByLowerBound.subMap(lbToAdd, ubToAdd).clear();

    replaceRangeWithSameLowerBound(Range.create(lbToAdd, ubToAdd));
  }

  @Override
  public void remove(Range&lt;C&gt; rangeToRemove) {
    checkNotNull(rangeToRemove);

    if (rangeToRemove.isEmpty()) {
      return;
    }

    // We will use { } to illustrate ranges currently in the range set, and &lt; &gt;
    // to illustrate rangeToRemove.

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(rangeToRemove.lowerBound);
    if (entryBelowLB != null) {
      // { &lt;
      Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
      if (rangeBelowLB.upperBound.compareTo(rangeToRemove.lowerBound) &gt;= 0) {
        // { &lt; }, and we will need to subdivide
        if (rangeToRemove.hasUpperBound()
            &amp;&amp; rangeBelowLB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
          // { &lt; &gt; }
          replaceRangeWithSameLowerBound(
              Range.create(rangeToRemove.upperBound, rangeBelowLB.upperBound));
        }
        replaceRangeWithSameLowerBound(
            Range.create(rangeBelowLB.lowerBound, rangeToRemove.lowerBound));
      }
    }

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(rangeToRemove.upperBound);
    if (entryBelowUB != null) {
      // { &gt;
      Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
      if (rangeToRemove.hasUpperBound()
          &amp;&amp; rangeBelowUB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
        // { &gt; }
        replaceRangeWithSameLowerBound(
            Range.create(rangeToRemove.upperBound, rangeBelowUB.upperBound));
      }
    }

    rangesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
  }

  private void replaceRangeWithSameLowerBound(Range&lt;C&gt; range) {
    if (range.isEmpty()) {
      rangesByLowerBound.remove(range.lowerBound);
    } else {
      rangesByLowerBound.put(range.lowerBound, range);
    }
  }

  @CheckForNull private transient RangeSet&lt;C&gt; complement;

  @Override
  public RangeSet&lt;C&gt; complement() {
    RangeSet&lt;C&gt; result = complement;
    return (result == null) ? complement = new Complement() : result;
  }

  @VisibleForTesting
  static final class RangesByUpperBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;

    /**
     * upperBoundWindow represents the headMap/subMap/tailMap view of the entire "ranges by upper
     * bound" map; it's a constraint on the *keys*, and does not affect the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow;

    RangesByUpperBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
      this.rangesByLowerBound = rangesByLowerBound;
      this.upperBoundWindow = Range.all();
    }

    private RangesByUpperBound(
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow) {
      this.rangesByLowerBound = rangesByLowerBound;
      this.upperBoundWindow = upperBoundWindow;
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
      if (window.isConnected(upperBoundWindow)) {
        return new RangesByUpperBound&lt;&gt;(rangesByLowerBound, window.intersection(upperBoundWindow));
      } else {
        return ImmutableSortedMap.of();
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
<a name="7"></a>    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</b></font>, boolean inclusive) {
<a name="14"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @</b></font>Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings("unchecked") // we catch CCEs
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          if (!upperBoundWindow.contains(cut)) {
            return null;
          }
          Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; candidate = rangesByLowerBound.lowerEntry(cut);
          if (candidate != null &amp;&amp; candidate.getValue().upperBound.equals(cut)) {
            return candidate.getValue();
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
      /*
       * We want to start the iteration at the first range where the upper bound is in
       * upperBoundWindow.
       */
      Iterator&lt;Range&lt;C&gt;&gt; backingItr;
      if (!upperBoundWindow.hasLowerBound()) {
        backingItr = rangesByLowerBound.values().iterator();
      } else {
        Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lowerEntry =
            rangesByLowerBound.lowerEntry(upperBoundWindow.lowerEndpoint());
        if (lowerEntry == null) {
          backingItr = rangesByLowerBound.values().iterator();
        } else if (upperBoundWindow.lowerBound.isLessThan(lowerEntry.getValue().upperBound)) {
          backingItr = rangesByLowerBound.tailMap(lowerEntry.getKey(), true).values().iterator();
        } else {
          backingItr =
              rangesByLowerBound
                  .tailMap(upperBoundWindow.lowerEndpoint(), true)
                  .values()
                  .iterator();
        }
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!backingItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; range = backingItr.next();
          if (upperBoundWindow.upperBound.isLessThan(range.upperBound)) {
            return endOfData();
          } else {
            return Maps.immutableEntry(range.upperBound, range);
          }
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
      Collection&lt;Range&lt;C&gt;&gt; candidates;
      if (upperBoundWindow.hasUpperBound()) {
        candidates =
            rangesByLowerBound
                .headMap(upperBoundWindow.upperEndpoint(), false)
                .descendingMap()
                .values();
      } else {
        candidates = rangesByLowerBound.descendingMap().values();
      }
      PeekingIterator&lt;Range&lt;C&gt;&gt; backingItr = Iterators.peekingIterator(candidates.iterator());
      if (backingItr.hasNext()
          &amp;&amp; upperBoundWindow.upperBound.isLessThan(backingItr.peek().upperBound)) {
        backingItr.next();
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!backingItr.hasNext()) {
            return endOfData();
<a name="8"></a>          }
          Range&lt;C&gt; range = backingItr.next();
          return upperBoundWindow.lowerBound.isLessThan(range.upperBound)
              ? <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Maps.immutableEntry(range.upperBound, range)
              : endOfData();
        }
      };
    }

    @Override
    public int size() {</b></font>
      if (upperBoundWindow.equals(Range.all())) {
        return rangesByLowerBound.size();
      }
      return Iterators.size(entryIterator());
    }

    @Override
    public boolean isEmpty() {
      return upperBoundWindow.equals(Range.all())
          ? rangesByLowerBound.isEmpty()
          : !entryIterator().hasNext();
    }
  }

  private static final class ComplementRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound;
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByUpperBound;

    /**
     * complementLowerBoundWindow represents the headMap/subMap/tailMap view of the entire
     * "complement ranges by lower bound" map; it's a constraint on the *keys*, and does not affect
     * the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; complementLowerBoundWindow;

    ComplementRangesByLowerBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound) {
      this(positiveRangesByLowerBound, Range.&lt;Cut&lt;C&gt;&gt;all());
    }

    private ComplementRangesByLowerBound(
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; window) {
      this.positiveRangesByLowerBound = positiveRangesByLowerBound;
      this.positiveRangesByUpperBound = new RangesByUpperBound&lt;&gt;(positiveRangesByLowerBound);
      this.complementLowerBoundWindow = window;
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; subWindow) {
      if (!complementLowerBoundWindow.isConnected(subWindow)) {
        return ImmutableSortedMap.of();
      } else {
        subWindow = subWindow.intersection(complementLowerBoundWindow);
        return new ComplementRangesByLowerBound&lt;&gt;(positiveRangesByLowerBound, subWindow);
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
<a name="5"></a>    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</b></font>, boolean inclusive) {
<a name="9"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {</b></font>
      /*
       * firstComplementRangeLowerBound is the first complement range lower bound inside
       * complementLowerBoundWindow. Complement range lower bounds are either positive range upper
       * bounds, or Cut.belowAll().
       *
       * positiveItr starts at the first positive range with lower bound greater than
       * firstComplementRangeLowerBound. (Positive range lower bounds correspond to complement range
       * upper bounds.)
       */
      Collection&lt;Range&lt;C&gt;&gt; positiveRanges;
      if (complementLowerBoundWindow.hasLowerBound()) {
        positiveRanges =
            positiveRangesByUpperBound
                .tailMap(
                    complementLowerBoundWindow.lowerEndpoint(),
                    complementLowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
                .values();
      } else {
        positiveRanges = positiveRangesByUpperBound.values();
      }
      PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr = Iterators.peekingIterator(positiveRanges.iterator());
      Cut&lt;C&gt; firstComplementRangeLowerBound;
      if (complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
          &amp;&amp; (!positiveItr.hasNext() || positiveItr.peek().lowerBound != Cut.&lt;C&gt;belowAll())) {
        firstComplementRangeLowerBound = Cut.belowAll();
      } else if (positiveItr.hasNext()) {
        firstComplementRangeLowerBound = positiveItr.next().upperBound;
      } else {
        return Iterators.emptyIterator();
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        Cut&lt;C&gt; nextComplementRangeLowerBound = firstComplementRangeLowerBound;

        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (complementLowerBoundWindow.upperBound.isLessThan(nextComplementRangeLowerBound)
              || nextComplementRangeLowerBound == Cut.&lt;C&gt;aboveAll()) {
            return endOfData();
          }
          Range&lt;C&gt; negativeRange;
          if (positiveItr.hasNext()) {
            Range&lt;C&gt; positiveRange = positiveItr.next();
            negativeRange = Range.create(nextComplementRangeLowerBound, positiveRange.lowerBound);
            nextComplementRangeLowerBound = positiveRange.upperBound;
          } else {
            negativeRange = Range.create(nextComplementRangeLowerBound, Cut.&lt;C&gt;aboveAll());
            nextComplementRangeLowerBound = Cut.aboveAll();
          }
          return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
      /*
       * firstComplementRangeUpperBound is the upper bound of the last complement range with lower
       * bound inside complementLowerBoundWindow.
       *
       * positiveItr starts at the first positive range with upper bound less than
       * firstComplementRangeUpperBound. (Positive range upper bounds correspond to complement range
<a name="3"></a>       * lower bounds.)
       */
      Cut&lt;C&gt; startingPoint =
          <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>complementLowerBoundWindow.hasUpperBound()
              ? complementLowerBoundWindow.upperEndpoint()
              : Cut.&lt;C&gt;aboveAll();
      boolean inclusive =
          complementLowerBoundWindow.hasUpperBound()
              &amp;&amp; complementLowerBoundWindow.upperBoundType() == BoundType.CLOSED;
      PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr =
          Iterators.peekingIterator(
              positiveRangesByUpperBound</b></font>
                  .headMap(startingPoint, inclusive)
                  .descendingMap()
                  .values()
                  .iterator());
      Cut&lt;C&gt; cut;
      if (positiveItr.hasNext()) {
        cut =
            (positiveItr.peek().upperBound == Cut.&lt;C&gt;aboveAll())
                ? positiveItr.next().lowerBound
                : positiveRangesByLowerBound.higherKey(positiveItr.peek().upperBound);
      } else if (!complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
          || positiveRangesByLowerBound.containsKey(Cut.belowAll())) {
        return Iterators.emptyIterator();
      } else {
        cut = positiveRangesByLowerBound.higherKey(Cut.&lt;C&gt;belowAll());
      }
      Cut&lt;C&gt; firstComplementRangeUpperBound = MoreObjects.firstNonNull(cut, Cut.&lt;C&gt;aboveAll());
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        Cut&lt;C&gt; nextComplementRangeUpperBound = firstComplementRangeUpperBound;

        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (nextComplementRangeUpperBound == Cut.&lt;C&gt;belowAll()) {
            return endOfData();
          } else if (positiveItr.hasNext()) {
            Range&lt;C&gt; positiveRange = positiveItr.next();
            Range&lt;C&gt; negativeRange =
                Range.create(positiveRange.upperBound, nextComplementRangeUpperBound);
            nextComplementRangeUpperBound = positiveRange.lowerBound;
            if (complementLowerBoundWindow.lowerBound.isLessThan(negativeRange.lowerBound)) {
              return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
            }
          } else if (complementLowerBoundWindow.lowerBound.isLessThan(Cut.&lt;C&gt;belowAll())) {
            Range&lt;C&gt; negativeRange = Range.create(Cut.&lt;C&gt;belowAll(), nextComplementRangeUpperBound);
<a name="6"></a>            nextComplementRangeUpperBound = Cut.belowAll();
            return Maps.immutableEntry(Cut.&lt;C&gt;belowAll(), negativeRange);
          }
          return <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>endOfData();
        }
      };
    }

    @Override
    public int size() {
      return</b></font> Iterators.size(entryIterator());
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings("unchecked")
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          // tailMap respects the current window
          Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = tailMap(cut, true).firstEntry();
          if (firstEntry != null &amp;&amp; firstEntry.getKey().equals(cut)) {
            return firstEntry.getValue();
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }
  }

  private final class Complement extends TreeRangeSet&lt;C&gt; {
    Complement() {
      super(new ComplementRangesByLowerBound&lt;C&gt;(TreeRangeSet.this.rangesByLowerBound));
    }

    @Override
    public void add(Range&lt;C&gt; rangeToAdd) {
      TreeRangeSet.this.remove(rangeToAdd);
    }
<a name="11"></a>
    @Override
    public void remove(Range&lt;C&gt; rangeToRemove) {
      <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>TreeRangeSet.this.add(rangeToRemove);
    }

    @Override
    public boolean contains(C value) {
      return !TreeRangeSet.this.contains</b></font>(value);
    }

    @Override
    public RangeSet&lt;C&gt; complement() {
      return TreeRangeSet.this;
    }
  }

  private static final class SubRangeSetRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    /**
     * lowerBoundWindow is the headMap/subMap/tailMap view; it only restricts the keys, and does not
     * affect the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow;

    /**
     * restriction is the subRangeSet view; ranges are truncated to their intersection with
     * restriction.
     */
    private final Range&lt;C&gt; restriction;

    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByUpperBound;

    private SubRangeSetRangesByLowerBound(
        Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow,
        Range&lt;C&gt; restriction,
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
      this.lowerBoundWindow = checkNotNull(lowerBoundWindow);
      this.restriction = checkNotNull(restriction);
      this.rangesByLowerBound = checkNotNull(rangesByLowerBound);
      this.rangesByUpperBound = new RangesByUpperBound&lt;&gt;(rangesByLowerBound);
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
      if (!window.isConnected(lowerBoundWindow)) {
        return ImmutableSortedMap.of();
      } else {
        return new SubRangeSetRangesByLowerBound&lt;&gt;(
            lowerBoundWindow.intersection(window), restriction, rangesByLowerBound);
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey,
              BoundType.forBoolean(fromInclusive),
              toKey,
              BoundType.forBoolean(toInclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) {
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey, boolean inclusive) {
<a name="12"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @</b></font>Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings("unchecked") // we catch CCE's
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          if (!lowerBoundWindow.contains(cut)
              || cut.compareTo(restriction.lowerBound) &lt; 0
              || cut.compareTo(restriction.upperBound) &gt;= 0) {
            return null;
          } else if (cut.equals(restriction.lowerBound)) {
            // it might be present, truncated on the left
            Range&lt;C&gt; candidate = Maps.valueOrNull(rangesByLowerBound.floorEntry(cut));
            if (candidate != null &amp;&amp; candidate.upperBound.compareTo(restriction.lowerBound) &gt; 0) {
              return candidate.intersection(restriction);
            }
          } else {
            Range&lt;C&gt; result = rangesByLowerBound.get(cut);
            if (result != null) {
              return result.intersection(restriction);
            }
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
      if (restriction.isEmpty()) {
        return Iterators.emptyIterator();
      }
      Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr;
      if (lowerBoundWindow.upperBound.isLessThan(restriction.lowerBound)) {
        return Iterators.emptyIterator();
      } else if (lowerBoundWindow.lowerBound.isLessThan(restriction.lowerBound)) {
        // starts at the first range with upper bound strictly greater than restriction.lowerBound
        completeRangeItr =
            rangesByUpperBound.tailMap(restriction.lowerBound, false).values().iterator();
      } else {
        // starts at the first range with lower bound above lowerBoundWindow.lowerBound
        completeRangeItr =
            rangesByLowerBound
                .tailMap(
                    lowerBoundWindow.lowerBound.endpoint(),
                    lowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
                .values()
                .iterator();
      }
      Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
          Ordering.natural()
              .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!completeRangeItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; nextRange = completeRangeItr.next();
          if (upperBoundOnLowerBounds.isLessThan(nextRange.lowerBound)) {
            return endOfData();
          } else {
            nextRange = nextRange.intersection(restriction);
            return Maps.immutableEntry(nextRange.lowerBound, nextRange);
          }
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
<a name="4"></a>      if (restriction.isEmpty()) {
        return Iterators.emptyIterator();
      }
      <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
          Ordering.natural()
              .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
      Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr =
          rangesByLowerBound
              .headMap(
                  upperBoundOnLowerBounds.endpoint</b></font>(),
                  upperBoundOnLowerBounds.typeAsUpperBound() == BoundType.CLOSED)
              .descendingMap()
              .values()
              .iterator();
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!completeRangeItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; nextRange = completeRangeItr.next();
          if (restriction.lowerBound.compareTo(nextRange.upperBound) &gt;= 0) {
            return endOfData();
          }
          nextRange = nextRange.intersection(restriction);
          if (lowerBoundWindow.contains(nextRange.lowerBound)) {
            return Maps.immutableEntry(nextRange.lowerBound, nextRange);
          } else {
            return endOfData();
          }
        }
      };
    }

    @Override
    public int size() {
      return Iterators.size(entryIterator());
    }
  }

  @Override
  public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
    return view.equals(Range.&lt;C&gt;all()) ? this : new SubRangeSet(view);
  }

  private final class SubRangeSet extends TreeRangeSet&lt;C&gt; {
    private final Range&lt;C&gt; restriction;

    SubRangeSet(Range&lt;C&gt; restriction) {
      super(
          new SubRangeSetRangesByLowerBound&lt;C&gt;(
              Range.&lt;Cut&lt;C&gt;&gt;all(), restriction, TreeRangeSet.this.rangesByLowerBound));
      this.restriction = restriction;
    }

    @Override
    public boolean encloses(Range&lt;C&gt; range) {
      if (!restriction.isEmpty() &amp;&amp; restriction.encloses(range)) {
        Range&lt;C&gt; enclosing = TreeRangeSet.this.rangeEnclosing(range);
        return enclosing != null &amp;&amp; !enclosing.intersection(restriction).isEmpty();
      }
      return false;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; rangeContaining(C value) {
      if (!restriction.contains(value)) {
        return null;
      }
      Range&lt;C&gt; result = TreeRangeSet.this.rangeContaining(value);
      return (result == null) ? null : result.intersection(restriction);
    }

    @Override
    public void add(Range&lt;C&gt; rangeToAdd) {
      checkArgument(
          restriction.encloses(rangeToAdd),
          "Cannot add range %s to subRangeSet(%s)",
          rangeToAdd,
          restriction);
      TreeRangeSet.this.add(rangeToAdd);
    }

    @Override
    public void remove(Range&lt;C&gt; rangeToRemove) {
<a name="1"></a>      if (rangeToRemove.isConnected(restriction)) {
        TreeRangeSet.this.remove(rangeToRemove.intersection(restriction));
      }
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public boolean contains(C value) {
      return restriction.contains(value) &amp;&amp; TreeRangeSet.this.contains(value);
    }

    @</b></font>Override
    public void clear() {
      TreeRangeSet.this.remove(restriction);
    }

    @Override
    public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
      if (view.encloses(restriction)) {
        return this;
      } else if (view.isConnected(restriction)) {
        return new SubRangeSet(restriction.intersection(view));
      } else {
        return ImmutableRangeSet.of();
      }
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
