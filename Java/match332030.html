<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MapsTransformValuesUnmodifiableIteratorTest.java &amp; TreeRangeSet_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MapsTransformValuesUnmodifiableIteratorTest.java &amp; TreeRangeSet_1.java
      </h3>
<h1 align="center">
        15.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MapsTransformValuesUnmodifiableIteratorTest.java (28.390596%)<th>TreeRangeSet_1.java (10.994398%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(46-59)<td><a href="#" name="0">(99-112)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-75)<td><a href="#" name="1">(917-924)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(19-36)<td><a href="#" name="2">(24-41)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(320-328)<td><a href="#" name="3">(577-585)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(182-186)<td><a href="#" name="4">(830-836)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(116-121)<td><a href="#" name="5">(496-501)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(102-109)<td><a href="#" name="6">(624-631)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(91-96)<td><a href="#" name="7">(325-330)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(77-83)<td><a href="#" name="8">(432-439)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(60-66)<td><a href="#" name="9">(505-511)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(363-367)<td><a href="#" name="10">(145-149)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(122-127)<td><a href="#" name="11">(671-676)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(110-115)<td><a href="#" name="12">(742-747)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(97-101)<td><a href="#" name="13">(153-157)</a><td align="center"><font color="#870000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(85-90)<td><a href="#" name="14">(334-339)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapsTransformValuesUnmodifiableIteratorTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="2"></a>
2 package com.google.common.collect;
3 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.annotations.GwtCompatible;
4 import com.google.common.base.Function;
5 import com.google.common.base.Functions;
6 import com.google.common.collect.testing.MapInterfaceTest;
7 import java.util.Collection;
8 import java.util.Iterator;
9 import java.util.Map;
10 import java.util.Map.Entry;
11 import java.util.Set;
12 import org.checkerframework.checker.nullness.qual.Nullable;
13 @</b></font>GwtCompatible
14 public class MapsTransformValuesUnmodifiableIteratorTest extends MapInterfaceTest&lt;String, String&gt; {
15   public MapsTransformValuesUnmodifiableIteratorTest() {
16 <a name="0"></a>  }
17   private static class UnmodifiableIteratorMap&lt;K, V&gt; extends ForwardingMap&lt;K, V&gt; {
18     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final Map&lt;K, V&gt; delegate;
19     UnmodifiableIteratorMap(Map&lt;K, V&gt; delegate) {
20       this.delegate = delegate;
21     }
22     @Override
23     protected Map&lt;K, V&gt; delegate() {
24       return delegate;
25     }
26 <a name="9"></a>    @Override
27     public Set&lt;K&gt; keySet() {
28       return</b></font> new ForwardingSet&lt;K&gt;() {
29         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
30         protected Set&lt;K&gt; delegate() {
31           return delegate.keySet();
32         }
33 <a name="1"></a>        @Override
34         public Iterator&lt;K&gt; iterator() {</b></font>
35           return Iterators.unmodifiableIterator(delegate.keySet().iterator());
36         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
37         @Override
38         public boolean removeAll(Collection&lt;?&gt; c) {
39           return delegate.keySet().removeAll(c);
40         }
41 <a name="8"></a>
42         @</b></font>Override
43         public boolean retainAll(Collection&lt;?&gt; c) {
44           return <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.keySet().retainAll(c);
45         }
46       };
47     }
48 <a name="14"></a>    @Override
49     public Collection&lt;V&gt; values() {</b></font>
50       return new ForwardingCollection&lt;V&gt;() {
51         <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
52         protected Collection&lt;V&gt; delegate() {
53           return delegate.values();
54 <a name="7"></a>        }
55         @</b></font>Override
56         public Iterator&lt;V&gt; iterator() <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
57           return Iterators.unmodifiableIterator(delegate.values().iterator());
58         }
59 <a name="13"></a>
60         @Override
61         public boolean removeAll(Collection&lt;?&gt; c</b></font>) {
62           <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return delegate.values().removeAll(c);
63         }
64 <a name="6"></a>
65         @Override
66         public boolean retainAll(Collection&lt;?&gt; c) {</b></font>
67           return <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.values().retainAll(c);
68         }
69       };
70     }
71 <a name="12"></a>    @Override
72     public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
73       return</b></font> new ForwardingSet&lt;Entry&lt;K, V&gt;&gt;() {
74         <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
75         protected Set&lt;Entry&lt;K, V&gt;&gt; delegate() {
76           return delegate.entrySet();
77 <a name="5"></a>        }
78         @</b></font>Override
79         public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
80           return Iterators.unmodifiableIterator(delegate.entrySet().iterator());
81         }
82 <a name="11"></a>
83         @Override
84         public boolean removeAll(Collection&lt;?&gt; c</b></font>) {
85           return <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.entrySet().removeAll(c);
86         }
87         @Override
88         public boolean retainAll(Collection&lt;?&gt; c) {
89           return delegate.entrySet().retainAll</b></font>(c);
90         }
91       };
92     }
93   }
94   @Override
95   protected Map&lt;String, String&gt; makeEmptyMap() {
96     Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
97     return Maps.transformValues(
98         new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
99   }
100   @Override
101   protected Map&lt;String, String&gt; makePopulatedMap() {
102     Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
103     underlying.put("a", 1);
104     underlying.put("b", 2);
105     underlying.put("c", 3);
106     return Maps.transformValues(
107         new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
108   }
109   @Override
110   protected String getKeyNotInPopulatedMap() throws UnsupportedOperationException {
111     return "z";
112   }
113   @Override
114   protected String getValueNotInPopulatedMap() throws UnsupportedOperationException {
115     return "26";
116   }
117   private void assertMapsEqual(Map&lt;?, ?&gt; expected, Map&lt;?, ?&gt; map) {
118     assertEquals(expected, map);
119     assertEquals(expected.hashCode(), map.hashCode());
120     assertEquals(expected.entrySet(), map.entrySet());
121     Collection&lt;?&gt; expectedValues = expected.values();
122     Collection&lt;?&gt; mapValues = map.values();
123     assertEquals(expectedValues.size(), mapValues.size());
124     assertTrue(expectedValues.containsAll(mapValues));
125     assertTrue(mapValues.containsAll(expectedValues));
126   }
127   public void testTransformEmptyMapEquality() {
128     Map&lt;String, String&gt; map =
129         Maps.transformValues(ImmutableMap.&lt;String, Integer&gt;of(), Functions.toStringFunction());
130     assertMapsEqual(Maps.newHashMap(), map);
131 <a name="4"></a>  }
132   public void testTransformSingletonMapEquality() {
133     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Map&lt;String, String&gt; map =
134         Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
135     Map&lt;String, String&gt; expected = ImmutableMap.of("a", "1");
136     assertMapsEqual(expected, map);
137     assertEquals(expected.get("a"), map.get</b></font>("a"));
138   }
139   public void testTransformIdentityFunctionEquality() {
140     Map&lt;String, Integer&gt; underlying = ImmutableMap.of("a", 1);
141     Map&lt;String, Integer&gt; map = Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());
142     assertMapsEqual(underlying, map);
143   }
144   public void testTransformPutEntryIsUnsupported() {
145     Map&lt;String, String&gt; map =
146         Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
147     try {
148       map.put("b", "2");
149       fail();
150     } catch (UnsupportedOperationException expected) {
151     }
152     try {
153       map.putAll(ImmutableMap.of("b", "2"));
154       fail();
155     } catch (UnsupportedOperationException expected) {
156     }
157     try {
158       map.entrySet().iterator().next().setValue("one");
159       fail();
160     } catch (UnsupportedOperationException expected) {
161     }
162   }
163   public void testTransformRemoveEntry() {
164     Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
165     underlying.put("a", 1);
166     Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
167     assertEquals("1", map.remove("a"));
168     assertNull(map.remove("b"));
169   }
170   public void testTransformEqualityOfMapsWithNullValues() {
171     Map&lt;String, String&gt; underlying = Maps.newHashMap();
172     underlying.put("a", null);
173     underlying.put("b", "");
174     Map&lt;String, Boolean&gt; map =
175         Maps.transformValues(
176             underlying,
177             new Function&lt;String, Boolean&gt;() {
178               @Override
179               public Boolean apply(@Nullable String from) {
180                 return from == null;
181               }
182             });
183     Map&lt;String, Boolean&gt; expected = ImmutableMap.of("a", true, "b", false);
184     assertMapsEqual(expected, map);
185     assertEquals(expected.get("a"), map.get("a"));
186     assertEquals(expected.containsKey("a"), map.containsKey("a"));
187     assertEquals(expected.get("b"), map.get("b"));
188     assertEquals(expected.containsKey("b"), map.containsKey("b"));
189     assertEquals(expected.get("c"), map.get("c"));
190     assertEquals(expected.containsKey("c"), map.containsKey("c"));
191   }
192   public void testTransformReflectsUnderlyingMap() {
193     Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
194     underlying.put("a", 1);
195     underlying.put("b", 2);
196     underlying.put("c", 3);
197     Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
198     assertEquals(underlying.size(), map.size());
199     underlying.put("d", 4);
200     assertEquals(underlying.size(), map.size());
201     assertEquals("4", map.get("d"));
202     underlying.remove("c");
203     assertEquals(underlying.size(), map.size());
204     assertFalse(map.containsKey("c"));
205     underlying.clear();
206     assertEquals(underlying.size(), map.size());
207   }
208   public void testTransformChangesAreReflectedInUnderlyingMap() {
209     Map&lt;String, Integer&gt; underlying = Maps.newLinkedHashMap();
210     underlying.put("a", 1);
211     underlying.put("b", 2);
212     underlying.put("c", 3);
213     underlying.put("d", 4);
214     underlying.put("e", 5);
215     underlying.put("f", 6);
216     underlying.put("g", 7);
217     Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
218     map.remove("a");
219     assertFalse(underlying.containsKey("a"));
220     Set&lt;String&gt; keys = map.keySet();
221     keys.remove("b");
222     assertFalse(underlying.containsKey("b"));
223     Iterator&lt;String&gt; keyIterator = keys.iterator();
224     keyIterator.next();
225     keyIterator.remove();
226     assertFalse(underlying.containsKey("c"));
227     Collection&lt;String&gt; values = map.values();
228     values.remove("4");
229     assertFalse(underlying.containsKey("d"));
230     Iterator&lt;String&gt; valueIterator = values.iterator();
231     valueIterator.next();
232     valueIterator.remove();
233     assertFalse(underlying.containsKey("e"));
234     Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();
235     Entry&lt;String, String&gt; firstEntry = entries.iterator().next();
236     entries.remove(firstEntry);
237     assertFalse(underlying.containsKey("f"));
238     Iterator&lt;Entry&lt;String, String&gt;&gt; entryIterator = entries.iterator();
239     entryIterator.next();
240     entryIterator.remove();
241     assertFalse(underlying.containsKey("g"));
242     assertTrue(underlying.isEmpty());
243     assertTrue(map.isEmpty());
244     assertTrue(keys.isEmpty());
245     assertTrue(values.isEmpty());
246     assertTrue(entries.isEmpty());
247   }
248 <a name="3"></a>
249   public void testTransformEquals() {
250     Map&lt;String, Integer&gt; underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
251     Map&lt;String, Integer&gt; expected = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());
252     assertMapsEqual(expected, expected);
253     Map&lt;String, Integer&gt; equalToUnderlying = Maps.newTreeMap();
254     equalToUnderlying.putAll(underlying);
255     Map&lt;String, Integer&gt; map =
256         Maps.transformValues(equalToUnderlying, Functions.&lt;Integer&gt;identity());
257     assertMapsEqual</b></font>(expected, map);
258     map =
259         Maps.transformValues(
260             ImmutableMap.of("a", 1, "b", 2, "c", 3),
261             new Function&lt;Integer, Integer&gt;() {
262               @Override
263               public Integer apply(Integer from) {
264                 return from - 1;
265               }
266             });
267     assertMapsEqual(expected, map);
268   }
269   public void testTransformEntrySetContains() {
270     Map&lt;String, Boolean&gt; underlying = Maps.newHashMap();
271     underlying.put("a", null);
272     underlying.put("b", true);
273     underlying.put(null, true);
274     Map&lt;String, Boolean&gt; map =
275         Maps.transformValues(
276             underlying,
277             new Function&lt;Boolean, Boolean&gt;() {
278               @Override
279               public Boolean apply(@Nullable Boolean from) {
280                 return (from == null) ? true : null;
281               }
282             });
283     Set&lt;Entry&lt;String, Boolean&gt;&gt; entries = map.entrySet();
284     assertTrue(entries.contains(Maps.immutableEntry("a", true)));
285 <a name="10"></a>    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
286     assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));
287     assertFalse(<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>entries.contains(Maps.immutableEntry("c", (Boolean) null)));
288     assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
289   }
290   @</b></font>Override
291   public void testKeySetRemoveAllNullFromEmpty() {
292     try {
293       super.testKeySetRemoveAllNullFromEmpty();
294     } catch (RuntimeException tolerated) {
295     }
296   }
297   @Override
298   public void testEntrySetRemoveAllNullFromEmpty() {
299     try {
300       super.testEntrySetRemoveAllNullFromEmpty();
301     } catch (RuntimeException tolerated) {
302     }
303   }
304 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeRangeSet_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import com.google.common.annotations.Beta;
5 <a name="2"></a>import com.google.common.annotations.GwtIncompatible;
6 import com.google.common.annotations.VisibleForTesting;
7 import com.google.common.base.MoreObjects;
8 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.io.Serializable;
9 import java.util.Collection;
10 import java.util.Comparator;
11 import java.util.Iterator;
12 import java.util.Map.Entry;
13 import java.util.NavigableMap;
14 import java.util.NoSuchElementException;
15 import java.util.Set;
16 import java.util.TreeMap;
17 import javax.annotation.CheckForNull;
18 @</b></font>Beta
19 @GwtIncompatible @ElementTypesAreNonnullByDefault
20 public class TreeRangeSet&lt;C extends Comparable&lt;?&gt;&gt; extends AbstractRangeSet&lt;C&gt;
21     implements Serializable {
22   @VisibleForTesting final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;
23   public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create() {
24     return new TreeRangeSet&lt;&gt;(new TreeMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;());
25   }
26   public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(RangeSet&lt;C&gt; rangeSet) {
27     TreeRangeSet&lt;C&gt; result = create();
28     result.addAll(rangeSet);
29     return result;
30   }
31   public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
32     TreeRangeSet&lt;C&gt; result = create();
33     result.addAll(ranges);
34     return result;
35   }
36   private TreeRangeSet(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerCut) {
37     this.rangesByLowerBound = rangesByLowerCut;
38   }
39   @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asRanges;
40   @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges;
41   @Override
42   public Set&lt;Range&lt;C&gt;&gt; asRanges() {
43     Set&lt;Range&lt;C&gt;&gt; result = asRanges;
44     return (result == null) ? asRanges = new AsRanges(rangesByLowerBound.values()) : result;
45   }
46   @Override
47   public Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges() {
48     Set&lt;Range&lt;C&gt;&gt; result = asDescendingSetOfRanges;
49     return (result == null)
50         ? asDescendingSetOfRanges = new AsRanges(rangesByLowerBound.descendingMap().values())
51         : result;
52   }
53 <a name="0"></a>
54   final class AsRanges extends ForwardingCollection&lt;Range&lt;C&gt;&gt; implements Set&lt;Range&lt;C&gt;&gt; {
55     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Collection&lt;Range&lt;C&gt;&gt; delegate;
56     AsRanges(Collection&lt;Range&lt;C&gt;&gt; delegate) {
57       this.delegate = delegate;
58     }
59     @Override
60     protected Collection&lt;Range&lt;C&gt;&gt; delegate() {
61       return delegate;
62     }
63     @Override
64     public int hashCode() {
65       return</b></font> Sets.hashCodeImpl(this);
66     }
67     @Override
68     public boolean equals(@CheckForNull Object o) {
69       return Sets.equalsImpl(this, o);
70     }
71   }
72   @Override
73   @CheckForNull
74   public Range&lt;C&gt; rangeContaining(C value) {
75     checkNotNull(value);
76     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
77     if (floorEntry != null &amp;&amp; floorEntry.getValue().contains(value)) {
78       return floorEntry.getValue();
79     } else {
80       return null;
81     }
82   }
83   @Override
84   public boolean intersects(Range&lt;C&gt; range) {
85     checkNotNull(range);
86     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; ceilingEntry = rangesByLowerBound.ceilingEntry(range.lowerBound);
87     if (ceilingEntry != null
88         &amp;&amp; ceilingEntry.getValue().isConnected(range)
89         &amp;&amp; !ceilingEntry.getValue().intersection(range).isEmpty()) {
90       return true;
91 <a name="10"></a>    }
92     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; priorEntry = rangesByLowerBound.lowerEntry(range.lowerBound);
93     return priorEntry != null
94         &amp;&amp; <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>priorEntry.getValue().isConnected(range)
95         &amp;&amp; !priorEntry.getValue().intersection(range).isEmpty();
96   }
97   @</b></font>Override
98 <a name="13"></a>  public boolean encloses(Range&lt;C&gt; range) {
99     checkNotNull(range);
100     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
101     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range);
102   }
103   @CheckForNull
104   private Range&lt;C&gt; rangeEnclosing(Range&lt;C&gt; range) {</b></font>
105     checkNotNull(range);
106     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
107     return (floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range))
108         ? floorEntry.getValue()
109         : null;
110   }
111   @Override
112   public Range&lt;C&gt; span() {
113     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = rangesByLowerBound.firstEntry();
114     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lastEntry = rangesByLowerBound.lastEntry();
115     if (firstEntry == null || lastEntry == null) {
116       throw new NoSuchElementException();
117     }
118     return Range.create(firstEntry.getValue().lowerBound, lastEntry.getValue().upperBound);
119   }
120   @Override
121   public void add(Range&lt;C&gt; rangeToAdd) {
122     checkNotNull(rangeToAdd);
123     if (rangeToAdd.isEmpty()) {
124       return;
125     }
126     Cut&lt;C&gt; lbToAdd = rangeToAdd.lowerBound;
127     Cut&lt;C&gt; ubToAdd = rangeToAdd.upperBound;
128     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(lbToAdd);
129     if (entryBelowLB != null) {
130       Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
131       if (rangeBelowLB.upperBound.compareTo(lbToAdd) &gt;= 0) {
132         if (rangeBelowLB.upperBound.compareTo(ubToAdd) &gt;= 0) {
133           ubToAdd = rangeBelowLB.upperBound;
134         }
135         lbToAdd = rangeBelowLB.lowerBound;
136       }
137     }
138     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(ubToAdd);
139     if (entryBelowUB != null) {
140       Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
141       if (rangeBelowUB.upperBound.compareTo(ubToAdd) &gt;= 0) {
142         ubToAdd = rangeBelowUB.upperBound;
143       }
144     }
145     rangesByLowerBound.subMap(lbToAdd, ubToAdd).clear();
146     replaceRangeWithSameLowerBound(Range.create(lbToAdd, ubToAdd));
147   }
148   @Override
149   public void remove(Range&lt;C&gt; rangeToRemove) {
150     checkNotNull(rangeToRemove);
151     if (rangeToRemove.isEmpty()) {
152       return;
153     }
154     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(rangeToRemove.lowerBound);
155     if (entryBelowLB != null) {
156       Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
157       if (rangeBelowLB.upperBound.compareTo(rangeToRemove.lowerBound) &gt;= 0) {
158         if (rangeToRemove.hasUpperBound()
159             &amp;&amp; rangeBelowLB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
160           replaceRangeWithSameLowerBound(
161               Range.create(rangeToRemove.upperBound, rangeBelowLB.upperBound));
162         }
163         replaceRangeWithSameLowerBound(
164             Range.create(rangeBelowLB.lowerBound, rangeToRemove.lowerBound));
165       }
166     }
167     Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(rangeToRemove.upperBound);
168     if (entryBelowUB != null) {
169       Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
170       if (rangeToRemove.hasUpperBound()
171           &amp;&amp; rangeBelowUB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
172         replaceRangeWithSameLowerBound(
173             Range.create(rangeToRemove.upperBound, rangeBelowUB.upperBound));
174       }
175     }
176     rangesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
177   }
178   private void replaceRangeWithSameLowerBound(Range&lt;C&gt; range) {
179     if (range.isEmpty()) {
180       rangesByLowerBound.remove(range.lowerBound);
181     } else {
182       rangesByLowerBound.put(range.lowerBound, range);
183     }
184   }
185   @CheckForNull private transient RangeSet&lt;C&gt; complement;
186   @Override
187   public RangeSet&lt;C&gt; complement() {
188     RangeSet&lt;C&gt; result = complement;
189     return (result == null) ? complement = new Complement() : result;
190   }
191   @VisibleForTesting
192   static final class RangesByUpperBound&lt;C extends Comparable&lt;?&gt;&gt;
193       extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
194     private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;
195     private final Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow;
196     RangesByUpperBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
197       this.rangesByLowerBound = rangesByLowerBound;
198       this.upperBoundWindow = Range.all();
199     }
200     private RangesByUpperBound(
201         NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow) {
202       this.rangesByLowerBound = rangesByLowerBound;
203       this.upperBoundWindow = upperBoundWindow;
204     }
205     private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
206       if (window.isConnected(upperBoundWindow)) {
207         return new RangesByUpperBound&lt;&gt;(rangesByLowerBound, window.intersection(upperBoundWindow));
208       } else {
209         return ImmutableSortedMap.of();
210       }
211     }
212     @Override
213     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
214         Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
215       return subMap(
216           Range.range(
217               fromKey, BoundType.forBoolean(fromInclusive),
218               toKey, BoundType.forBoolean(toInclusive)));
219 <a name="7"></a>    }
220     @Override
221     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
222       return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
223     }
224     @Override
225     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</b></font>, boolean inclusive) {
226 <a name="14"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
227     }
228     <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
229     public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
230       return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
231     }
232     @</b></font>Override
233     public boolean containsKey(@CheckForNull Object key) {
234       return get(key) != null;
235     }
236     @Override
237     @CheckForNull
238     public Range&lt;C&gt; get(@CheckForNull Object key) {
239       if (key instanceof Cut) {
240         try {
241           @SuppressWarnings("unchecked")           Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
242           if (!upperBoundWindow.contains(cut)) {
243             return null;
244           }
245           Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; candidate = rangesByLowerBound.lowerEntry(cut);
246           if (candidate != null &amp;&amp; candidate.getValue().upperBound.equals(cut)) {
247             return candidate.getValue();
248           }
249         } catch (ClassCastException e) {
250           return null;
251         }
252       }
253       return null;
254     }
255     @Override
256     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
257       Iterator&lt;Range&lt;C&gt;&gt; backingItr;
258       if (!upperBoundWindow.hasLowerBound()) {
259         backingItr = rangesByLowerBound.values().iterator();
260       } else {
261         Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lowerEntry =
262             rangesByLowerBound.lowerEntry(upperBoundWindow.lowerEndpoint());
263         if (lowerEntry == null) {
264           backingItr = rangesByLowerBound.values().iterator();
265         } else if (upperBoundWindow.lowerBound.isLessThan(lowerEntry.getValue().upperBound)) {
266           backingItr = rangesByLowerBound.tailMap(lowerEntry.getKey(), true).values().iterator();
267         } else {
268           backingItr =
269               rangesByLowerBound
270                   .tailMap(upperBoundWindow.lowerEndpoint(), true)
271                   .values()
272                   .iterator();
273         }
274       }
275       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
276         @Override
277         @CheckForNull
278         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
279           if (!backingItr.hasNext()) {
280             return endOfData();
281           }
282           Range&lt;C&gt; range = backingItr.next();
283           if (upperBoundWindow.upperBound.isLessThan(range.upperBound)) {
284             return endOfData();
285           } else {
286             return Maps.immutableEntry(range.upperBound, range);
287           }
288         }
289       };
290     }
291     @Override
292     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
293       Collection&lt;Range&lt;C&gt;&gt; candidates;
294       if (upperBoundWindow.hasUpperBound()) {
295         candidates =
296             rangesByLowerBound
297                 .headMap(upperBoundWindow.upperEndpoint(), false)
298                 .descendingMap()
299                 .values();
300       } else {
301         candidates = rangesByLowerBound.descendingMap().values();
302       }
303       PeekingIterator&lt;Range&lt;C&gt;&gt; backingItr = Iterators.peekingIterator(candidates.iterator());
304       if (backingItr.hasNext()
305           &amp;&amp; upperBoundWindow.upperBound.isLessThan(backingItr.peek().upperBound)) {
306         backingItr.next();
307       }
308       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
309         @Override
310         @CheckForNull
311         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
312           if (!backingItr.hasNext()) {
313             return endOfData();
314 <a name="8"></a>          }
315           Range&lt;C&gt; range = backingItr.next();
316           return upperBoundWindow.lowerBound.isLessThan(range.upperBound)
317               ? <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Maps.immutableEntry(range.upperBound, range)
318               : endOfData();
319         }
320       };
321     }
322     @Override
323     public int size() {</b></font>
324       if (upperBoundWindow.equals(Range.all())) {
325         return rangesByLowerBound.size();
326       }
327       return Iterators.size(entryIterator());
328     }
329     @Override
330     public boolean isEmpty() {
331       return upperBoundWindow.equals(Range.all())
332           ? rangesByLowerBound.isEmpty()
333           : !entryIterator().hasNext();
334     }
335   }
336   private static final class ComplementRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
337       extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
338     private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound;
339     private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByUpperBound;
340     private final Range&lt;Cut&lt;C&gt;&gt; complementLowerBoundWindow;
341     ComplementRangesByLowerBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound) {
342       this(positiveRangesByLowerBound, Range.&lt;Cut&lt;C&gt;&gt;all());
343     }
344     private ComplementRangesByLowerBound(
345         NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; window) {
346       this.positiveRangesByLowerBound = positiveRangesByLowerBound;
347       this.positiveRangesByUpperBound = new RangesByUpperBound&lt;&gt;(positiveRangesByLowerBound);
348       this.complementLowerBoundWindow = window;
349     }
350     private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; subWindow) {
351       if (!complementLowerBoundWindow.isConnected(subWindow)) {
352         return ImmutableSortedMap.of();
353       } else {
354         subWindow = subWindow.intersection(complementLowerBoundWindow);
355         return new ComplementRangesByLowerBound&lt;&gt;(positiveRangesByLowerBound, subWindow);
356       }
357     }
358     @Override
359     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
360         Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
361       return subMap(
362           Range.range(
363               fromKey, BoundType.forBoolean(fromInclusive),
364               toKey, BoundType.forBoolean(toInclusive)));
365 <a name="5"></a>    }
366     @Override
367     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
368       return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
369     }
370     @Override
371     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</b></font>, boolean inclusive) {
372 <a name="9"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
373     }
374     <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
375     public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
376       return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
377     }
378     @Override
379     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {</b></font>
380       Collection&lt;Range&lt;C&gt;&gt; positiveRanges;
381       if (complementLowerBoundWindow.hasLowerBound()) {
382         positiveRanges =
383             positiveRangesByUpperBound
384                 .tailMap(
385                     complementLowerBoundWindow.lowerEndpoint(),
386                     complementLowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
387                 .values();
388       } else {
389         positiveRanges = positiveRangesByUpperBound.values();
390       }
391       PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr = Iterators.peekingIterator(positiveRanges.iterator());
392       Cut&lt;C&gt; firstComplementRangeLowerBound;
393       if (complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
394           &amp;&amp; (!positiveItr.hasNext() || positiveItr.peek().lowerBound != Cut.&lt;C&gt;belowAll())) {
395         firstComplementRangeLowerBound = Cut.belowAll();
396       } else if (positiveItr.hasNext()) {
397         firstComplementRangeLowerBound = positiveItr.next().upperBound;
398       } else {
399         return Iterators.emptyIterator();
400       }
401       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
402         Cut&lt;C&gt; nextComplementRangeLowerBound = firstComplementRangeLowerBound;
403         @Override
404         @CheckForNull
405         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
406           if (complementLowerBoundWindow.upperBound.isLessThan(nextComplementRangeLowerBound)
407               || nextComplementRangeLowerBound == Cut.&lt;C&gt;aboveAll()) {
408             return endOfData();
409           }
410           Range&lt;C&gt; negativeRange;
411           if (positiveItr.hasNext()) {
412             Range&lt;C&gt; positiveRange = positiveItr.next();
413             negativeRange = Range.create(nextComplementRangeLowerBound, positiveRange.lowerBound);
414             nextComplementRangeLowerBound = positiveRange.upperBound;
415           } else {
416             negativeRange = Range.create(nextComplementRangeLowerBound, Cut.&lt;C&gt;aboveAll());
417             nextComplementRangeLowerBound = Cut.aboveAll();
418           }
419           return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
420         }
421       };
422     }
423     @Override
424     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
425       Cut&lt;C&gt; startingPoint =
426           <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>complementLowerBoundWindow.hasUpperBound()
427               ? complementLowerBoundWindow.upperEndpoint()
428               : Cut.&lt;C&gt;aboveAll();
429       boolean inclusive =
430           complementLowerBoundWindow.hasUpperBound()
431               &amp;&amp; complementLowerBoundWindow.upperBoundType() == BoundType.CLOSED;
432       PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr =
433           Iterators.peekingIterator(
434               positiveRangesByUpperBound</b></font>
435                   .headMap(startingPoint, inclusive)
436                   .descendingMap()
437                   .values()
438                   .iterator());
439       Cut&lt;C&gt; cut;
440       if (positiveItr.hasNext()) {
441         cut =
442             (positiveItr.peek().upperBound == Cut.&lt;C&gt;aboveAll())
443                 ? positiveItr.next().lowerBound
444                 : positiveRangesByLowerBound.higherKey(positiveItr.peek().upperBound);
445       } else if (!complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
446           || positiveRangesByLowerBound.containsKey(Cut.belowAll())) {
447         return Iterators.emptyIterator();
448       } else {
449         cut = positiveRangesByLowerBound.higherKey(Cut.&lt;C&gt;belowAll());
450       }
451       Cut&lt;C&gt; firstComplementRangeUpperBound = MoreObjects.firstNonNull(cut, Cut.&lt;C&gt;aboveAll());
452       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
453         Cut&lt;C&gt; nextComplementRangeUpperBound = firstComplementRangeUpperBound;
454         @Override
455         @CheckForNull
456         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
457           if (nextComplementRangeUpperBound == Cut.&lt;C&gt;belowAll()) {
458             return endOfData();
459           } else if (positiveItr.hasNext()) {
460             Range&lt;C&gt; positiveRange = positiveItr.next();
461             Range&lt;C&gt; negativeRange =
462                 Range.create(positiveRange.upperBound, nextComplementRangeUpperBound);
463             nextComplementRangeUpperBound = positiveRange.lowerBound;
464             if (complementLowerBoundWindow.lowerBound.isLessThan(negativeRange.lowerBound)) {
465               return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
466             }
467           } else if (complementLowerBoundWindow.lowerBound.isLessThan(Cut.&lt;C&gt;belowAll())) {
468             Range&lt;C&gt; negativeRange = Range.create(Cut.&lt;C&gt;belowAll(), nextComplementRangeUpperBound);
469 <a name="6"></a>            nextComplementRangeUpperBound = Cut.belowAll();
470             return Maps.immutableEntry(Cut.&lt;C&gt;belowAll(), negativeRange);
471           }
472           return <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>endOfData();
473         }
474       };
475     }
476     @Override
477     public int size() {
478       return</b></font> Iterators.size(entryIterator());
479     }
480     @Override
481     @CheckForNull
482     public Range&lt;C&gt; get(@CheckForNull Object key) {
483       if (key instanceof Cut) {
484         try {
485           @SuppressWarnings("unchecked")
486           Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
487           Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = tailMap(cut, true).firstEntry();
488           if (firstEntry != null &amp;&amp; firstEntry.getKey().equals(cut)) {
489             return firstEntry.getValue();
490           }
491         } catch (ClassCastException e) {
492           return null;
493         }
494       }
495       return null;
496     }
497     @Override
498     public boolean containsKey(@CheckForNull Object key) {
499       return get(key) != null;
500     }
501   }
502   private final class Complement extends TreeRangeSet&lt;C&gt; {
503     Complement() {
504       super(new ComplementRangesByLowerBound&lt;C&gt;(TreeRangeSet.this.rangesByLowerBound));
505     }
506     @Override
507     public void add(Range&lt;C&gt; rangeToAdd) {
508       TreeRangeSet.this.remove(rangeToAdd);
509     }
510 <a name="11"></a>
511     @Override
512     public void remove(Range&lt;C&gt; rangeToRemove) {
513       <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>TreeRangeSet.this.add(rangeToRemove);
514     }
515     @Override
516     public boolean contains(C value) {
517       return !TreeRangeSet.this.contains</b></font>(value);
518     }
519     @Override
520     public RangeSet&lt;C&gt; complement() {
521       return TreeRangeSet.this;
522     }
523   }
524   private static final class SubRangeSetRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
525       extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
526     private final Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow;
527     private final Range&lt;C&gt; restriction;
528     private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;
529     private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByUpperBound;
530     private SubRangeSetRangesByLowerBound(
531         Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow,
532         Range&lt;C&gt; restriction,
533         NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
534       this.lowerBoundWindow = checkNotNull(lowerBoundWindow);
535       this.restriction = checkNotNull(restriction);
536       this.rangesByLowerBound = checkNotNull(rangesByLowerBound);
537       this.rangesByUpperBound = new RangesByUpperBound&lt;&gt;(rangesByLowerBound);
538     }
539     private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
540       if (!window.isConnected(lowerBoundWindow)) {
541         return ImmutableSortedMap.of();
542       } else {
543         return new SubRangeSetRangesByLowerBound&lt;&gt;(
544             lowerBoundWindow.intersection(window), restriction, rangesByLowerBound);
545       }
546     }
547     @Override
548     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
549         Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
550       return subMap(
551           Range.range(
552               fromKey,
553               BoundType.forBoolean(fromInclusive),
554               toKey,
555               BoundType.forBoolean(toInclusive)));
556     }
557     @Override
558     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) {
559       return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
560     }
561     @Override
562     public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey, boolean inclusive) {
563 <a name="12"></a>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
564     }
565     <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
566     public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
567       return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
568     }
569     @</b></font>Override
570     public boolean containsKey(@CheckForNull Object key) {
571       return get(key) != null;
572     }
573     @Override
574     @CheckForNull
575     public Range&lt;C&gt; get(@CheckForNull Object key) {
576       if (key instanceof Cut) {
577         try {
578           @SuppressWarnings("unchecked")           Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
579           if (!lowerBoundWindow.contains(cut)
580               || cut.compareTo(restriction.lowerBound) &lt; 0
581               || cut.compareTo(restriction.upperBound) &gt;= 0) {
582             return null;
583           } else if (cut.equals(restriction.lowerBound)) {
584             Range&lt;C&gt; candidate = Maps.valueOrNull(rangesByLowerBound.floorEntry(cut));
585             if (candidate != null &amp;&amp; candidate.upperBound.compareTo(restriction.lowerBound) &gt; 0) {
586               return candidate.intersection(restriction);
587             }
588           } else {
589             Range&lt;C&gt; result = rangesByLowerBound.get(cut);
590             if (result != null) {
591               return result.intersection(restriction);
592             }
593           }
594         } catch (ClassCastException e) {
595           return null;
596         }
597       }
598       return null;
599     }
600     @Override
601     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
602       if (restriction.isEmpty()) {
603         return Iterators.emptyIterator();
604       }
605       Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr;
606       if (lowerBoundWindow.upperBound.isLessThan(restriction.lowerBound)) {
607         return Iterators.emptyIterator();
608       } else if (lowerBoundWindow.lowerBound.isLessThan(restriction.lowerBound)) {
609         completeRangeItr =
610             rangesByUpperBound.tailMap(restriction.lowerBound, false).values().iterator();
611       } else {
612         completeRangeItr =
613             rangesByLowerBound
614                 .tailMap(
615                     lowerBoundWindow.lowerBound.endpoint(),
616                     lowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
617                 .values()
618                 .iterator();
619       }
620       Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
621           Ordering.natural()
622               .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
623       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
624         @Override
625         @CheckForNull
626         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
627           if (!completeRangeItr.hasNext()) {
628             return endOfData();
629           }
630           Range&lt;C&gt; nextRange = completeRangeItr.next();
631           if (upperBoundOnLowerBounds.isLessThan(nextRange.lowerBound)) {
632             return endOfData();
633           } else {
634             nextRange = nextRange.intersection(restriction);
635             return Maps.immutableEntry(nextRange.lowerBound, nextRange);
636           }
637         }
638       };
639     }
640     @Override
641     Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
642 <a name="4"></a>      if (restriction.isEmpty()) {
643         return Iterators.emptyIterator();
644       }
645       <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
646           Ordering.natural()
647               .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
648       Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr =
649           rangesByLowerBound
650               .headMap(
651                   upperBoundOnLowerBounds.endpoint</b></font>(),
652                   upperBoundOnLowerBounds.typeAsUpperBound() == BoundType.CLOSED)
653               .descendingMap()
654               .values()
655               .iterator();
656       return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
657         @Override
658         @CheckForNull
659         protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
660           if (!completeRangeItr.hasNext()) {
661             return endOfData();
662           }
663           Range&lt;C&gt; nextRange = completeRangeItr.next();
664           if (restriction.lowerBound.compareTo(nextRange.upperBound) &gt;= 0) {
665             return endOfData();
666           }
667           nextRange = nextRange.intersection(restriction);
668           if (lowerBoundWindow.contains(nextRange.lowerBound)) {
669             return Maps.immutableEntry(nextRange.lowerBound, nextRange);
670           } else {
671             return endOfData();
672           }
673         }
674       };
675     }
676     @Override
677     public int size() {
678       return Iterators.size(entryIterator());
679     }
680   }
681   @Override
682   public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
683     return view.equals(Range.&lt;C&gt;all()) ? this : new SubRangeSet(view);
684   }
685   private final class SubRangeSet extends TreeRangeSet&lt;C&gt; {
686     private final Range&lt;C&gt; restriction;
687     SubRangeSet(Range&lt;C&gt; restriction) {
688       super(
689           new SubRangeSetRangesByLowerBound&lt;C&gt;(
690               Range.&lt;Cut&lt;C&gt;&gt;all(), restriction, TreeRangeSet.this.rangesByLowerBound));
691       this.restriction = restriction;
692     }
693     @Override
694     public boolean encloses(Range&lt;C&gt; range) {
695       if (!restriction.isEmpty() &amp;&amp; restriction.encloses(range)) {
696         Range&lt;C&gt; enclosing = TreeRangeSet.this.rangeEnclosing(range);
697         return enclosing != null &amp;&amp; !enclosing.intersection(restriction).isEmpty();
698       }
699       return false;
700     }
701     @Override
702     @CheckForNull
703     public Range&lt;C&gt; rangeContaining(C value) {
704       if (!restriction.contains(value)) {
705         return null;
706       }
707       Range&lt;C&gt; result = TreeRangeSet.this.rangeContaining(value);
708       return (result == null) ? null : result.intersection(restriction);
709     }
710     @Override
711     public void add(Range&lt;C&gt; rangeToAdd) {
712       checkArgument(
713           restriction.encloses(rangeToAdd),
714           "Cannot add range %s to subRangeSet(%s)",
715           rangeToAdd,
716           restriction);
717       TreeRangeSet.this.add(rangeToAdd);
718     }
719     @Override
720     public void remove(Range&lt;C&gt; rangeToRemove) {
721 <a name="1"></a>      if (rangeToRemove.isConnected(restriction)) {
722         TreeRangeSet.this.remove(rangeToRemove.intersection(restriction));
723       }
724     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
725     @Override
726     public boolean contains(C value) {
727       return restriction.contains(value) &amp;&amp; TreeRangeSet.this.contains(value);
728     }
729     @</b></font>Override
730     public void clear() {
731       TreeRangeSet.this.remove(restriction);
732     }
733     @Override
734     public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
735       if (view.encloses(restriction)) {
736         return this;
737       } else if (view.isConnected(restriction)) {
738         return new SubRangeSet(restriction.intersection(view));
739       } else {
740         return ImmutableRangeSet.of();
741       }
742     }
743   }
744 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
