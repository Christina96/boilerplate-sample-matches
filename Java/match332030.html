<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for MapsTransformValuesUnmodifiableIteratorTest.java & TreeRangeSet_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for MapsTransformValuesUnmodifiableIteratorTest.java & TreeRangeSet_1.java
      </h3>
      <h1 align="center">
        15.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>MapsTransformValuesUnmodifiableIteratorTest.java (28.390596%)<TH>TreeRangeSet_1.java (10.994398%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#0',2,'match332030-1.html#0',3)" NAME="0">(46-59)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#0',2,'match332030-1.html#0',3)" NAME="0">(99-112)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#1',2,'match332030-1.html#1',3)" NAME="1">(68-75)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#1',2,'match332030-1.html#1',3)" NAME="1">(917-924)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#2',2,'match332030-1.html#2',3)" NAME="2">(19-36)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#2',2,'match332030-1.html#2',3)" NAME="2">(24-41)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#3',2,'match332030-1.html#3',3)" NAME="3">(320-328)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#3',2,'match332030-1.html#3',3)" NAME="3">(577-585)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#4',2,'match332030-1.html#4',3)" NAME="4">(182-186)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#4',2,'match332030-1.html#4',3)" NAME="4">(830-836)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#5',2,'match332030-1.html#5',3)" NAME="5">(116-121)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#5',2,'match332030-1.html#5',3)" NAME="5">(496-501)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#6',2,'match332030-1.html#6',3)" NAME="6">(102-109)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#6',2,'match332030-1.html#6',3)" NAME="6">(624-631)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#7',2,'match332030-1.html#7',3)" NAME="7">(91-96)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#7',2,'match332030-1.html#7',3)" NAME="7">(325-330)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#8',2,'match332030-1.html#8',3)" NAME="8">(77-83)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#8',2,'match332030-1.html#8',3)" NAME="8">(432-439)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#9',2,'match332030-1.html#9',3)" NAME="9">(60-66)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#9',2,'match332030-1.html#9',3)" NAME="9">(505-511)</A><TD ALIGN=center><FONT COLOR="#960000">10</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#10',2,'match332030-1.html#10',3)" NAME="10">(363-367)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#10',2,'match332030-1.html#10',3)" NAME="10">(145-149)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#11',2,'match332030-1.html#11',3)" NAME="11">(122-127)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#11',2,'match332030-1.html#11',3)" NAME="11">(671-676)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#12',2,'match332030-1.html#12',3)" NAME="12">(110-115)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#12',2,'match332030-1.html#12',3)" NAME="12">(742-747)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#13',2,'match332030-1.html#13',3)" NAME="13">(97-101)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#13',2,'match332030-1.html#13',3)" NAME="13">(153-157)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match332030-0.html#14',2,'match332030-1.html#14',3)" NAME="14">(85-90)<TD><A HREF="javascript:ZweiFrames('match332030-0.html#14',2,'match332030-1.html#14',3)" NAME="14">(334-339)</A><TD ALIGN=center><FONT COLOR="#870000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapsTransformValuesUnmodifiableIteratorTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="2"></A>
package com.google.common.collect;

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match332030-1.html#2',3,'match332030-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.collect.testing.MapInterfaceTest;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Tests for {@link Maps#transformValues} when the backing map's views have iterators that don't
 * support {@code remove()}.
 *
 * @author Jared Levy
 */
@</B></FONT>GwtCompatible
public class MapsTransformValuesUnmodifiableIteratorTest extends MapInterfaceTest&lt;String, String&gt; {
  // TODO(jlevy): Move shared code of this class and MapsTransformValuesTest
  // to a superclass.

  public MapsTransformValuesUnmodifiableIteratorTest() {
    super(true, true, false /*supportsPut*/, true, true, false);
<A NAME="0"></A>  }

  private static class UnmodifiableIteratorMap&lt;K, V&gt; extends ForwardingMap&lt;K, V&gt; {
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match332030-1.html#0',3,'match332030-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final Map&lt;K, V&gt; delegate;

    UnmodifiableIteratorMap(Map&lt;K, V&gt; delegate) {
      this.delegate = delegate;
    }

    @Override
    protected Map&lt;K, V&gt; delegate() {
      return delegate;
    }

<A NAME="9"></A>    @Override
    public Set&lt;K&gt; keySet() {
      return</B></FONT> new ForwardingSet&lt;K&gt;() {
        <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match332030-1.html#9',3,'match332030-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
        protected Set&lt;K&gt; delegate() {
          return delegate.keySet();
        }

<A NAME="1"></A>        @Override
        public Iterator&lt;K&gt; iterator() {</B></FONT>
          return Iterators.unmodifiableIterator(delegate.keySet().iterator());
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match332030-1.html#1',3,'match332030-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
          return delegate.keySet().removeAll(c);
        }
<A NAME="8"></A>
        @</B></FONT>Override
        public boolean retainAll(Collection&lt;?&gt; c) {
          return <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match332030-1.html#8',3,'match332030-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.keySet().retainAll(c);
        }
      };
    }

<A NAME="14"></A>    @Override
    public Collection&lt;V&gt; values() {</B></FONT>
      return new ForwardingCollection&lt;V&gt;() {
        <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match332030-1.html#14',3,'match332030-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
        protected Collection&lt;V&gt; delegate() {
          return delegate.values();
<A NAME="7"></A>        }

        @</B></FONT>Override
        public Iterator&lt;V&gt; iterator() <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match332030-1.html#7',3,'match332030-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
          return Iterators.unmodifiableIterator(delegate.values().iterator());
        }
<A NAME="13"></A>
        @Override
        public boolean removeAll(Collection&lt;?&gt; c</B></FONT>) {
          <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match332030-1.html#13',3,'match332030-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return delegate.values().removeAll(c);
        }
<A NAME="6"></A>
        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {</B></FONT>
          return <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match332030-1.html#6',3,'match332030-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.values().retainAll(c);
        }
      };
    }

<A NAME="12"></A>    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
      return</B></FONT> new ForwardingSet&lt;Entry&lt;K, V&gt;&gt;() {
        <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match332030-1.html#12',3,'match332030-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
        protected Set&lt;Entry&lt;K, V&gt;&gt; delegate() {
          return delegate.entrySet();
<A NAME="5"></A>        }

        @</B></FONT>Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match332030-1.html#5',3,'match332030-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
          return Iterators.unmodifiableIterator(delegate.entrySet().iterator());
        }
<A NAME="11"></A>
        @Override
        public boolean removeAll(Collection&lt;?&gt; c</B></FONT>) {
          return <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match332030-1.html#11',3,'match332030-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.entrySet().removeAll(c);
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
          return delegate.entrySet().retainAll</B></FONT>(c);
        }
      };
    }
  }

  @Override
  protected Map&lt;String, String&gt; makeEmptyMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    return Maps.transformValues(
        new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
  }

  @Override
  protected Map&lt;String, String&gt; makePopulatedMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put(&quot;a&quot;, 1);
    underlying.put(&quot;b&quot;, 2);
    underlying.put(&quot;c&quot;, 3);
    return Maps.transformValues(
        new UnmodifiableIteratorMap&lt;String, Integer&gt;(underlying), Functions.toStringFunction());
  }

  @Override
  protected String getKeyNotInPopulatedMap() throws UnsupportedOperationException {
    return &quot;z&quot;;
  }

  @Override
  protected String getValueNotInPopulatedMap() throws UnsupportedOperationException {
    return &quot;26&quot;;
  }

  /** Helper assertion comparing two maps */
  private void assertMapsEqual(Map&lt;?, ?&gt; expected, Map&lt;?, ?&gt; map) {
    assertEquals(expected, map);
    assertEquals(expected.hashCode(), map.hashCode());
    assertEquals(expected.entrySet(), map.entrySet());

    // Assert that expectedValues &gt; mapValues and that
    // mapValues &gt; expectedValues; i.e. that expectedValues == mapValues.
    Collection&lt;?&gt; expectedValues = expected.values();
    Collection&lt;?&gt; mapValues = map.values();
    assertEquals(expectedValues.size(), mapValues.size());
    assertTrue(expectedValues.containsAll(mapValues));
    assertTrue(mapValues.containsAll(expectedValues));
  }

  public void testTransformEmptyMapEquality() {
    Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.&lt;String, Integer&gt;of(), Functions.toStringFunction());
    assertMapsEqual(Maps.newHashMap(), map);
<A NAME="4"></A>  }

  public void testTransformSingletonMapEquality() {
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match332030-1.html#4',3,'match332030-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.of(&quot;a&quot;, 1), Functions.toStringFunction());
    Map&lt;String, String&gt; expected = ImmutableMap.of(&quot;a&quot;, &quot;1&quot;);
    assertMapsEqual(expected, map);
    assertEquals(expected.get(&quot;a&quot;), map.get</B></FONT>(&quot;a&quot;));
  }

  public void testTransformIdentityFunctionEquality() {
    Map&lt;String, Integer&gt; underlying = ImmutableMap.of(&quot;a&quot;, 1);
    Map&lt;String, Integer&gt; map = Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());
    assertMapsEqual(underlying, map);
  }

  public void testTransformPutEntryIsUnsupported() {
    Map&lt;String, String&gt; map =
        Maps.transformValues(ImmutableMap.of(&quot;a&quot;, 1), Functions.toStringFunction());
    try {
      map.put(&quot;b&quot;, &quot;2&quot;);
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of(&quot;b&quot;, &quot;2&quot;));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue(&quot;one&quot;);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }

  public void testTransformRemoveEntry() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put(&quot;a&quot;, 1);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(&quot;1&quot;, map.remove(&quot;a&quot;));
    assertNull(map.remove(&quot;b&quot;));
  }

  public void testTransformEqualityOfMapsWithNullValues() {
    Map&lt;String, String&gt; underlying = Maps.newHashMap();
    underlying.put(&quot;a&quot;, null);
    underlying.put(&quot;b&quot;, &quot;&quot;);

    Map&lt;String, Boolean&gt; map =
        Maps.transformValues(
            underlying,
            new Function&lt;String, Boolean&gt;() {
              @Override
              public Boolean apply(@Nullable String from) {
                return from == null;
              }
            });
    Map&lt;String, Boolean&gt; expected = ImmutableMap.of(&quot;a&quot;, true, &quot;b&quot;, false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get(&quot;a&quot;), map.get(&quot;a&quot;));
    assertEquals(expected.containsKey(&quot;a&quot;), map.containsKey(&quot;a&quot;));
    assertEquals(expected.get(&quot;b&quot;), map.get(&quot;b&quot;));
    assertEquals(expected.containsKey(&quot;b&quot;), map.containsKey(&quot;b&quot;));
    assertEquals(expected.get(&quot;c&quot;), map.get(&quot;c&quot;));
    assertEquals(expected.containsKey(&quot;c&quot;), map.containsKey(&quot;c&quot;));
  }

  public void testTransformReflectsUnderlyingMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newHashMap();
    underlying.put(&quot;a&quot;, 1);
    underlying.put(&quot;b&quot;, 2);
    underlying.put(&quot;c&quot;, 3);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put(&quot;d&quot;, 4);
    assertEquals(underlying.size(), map.size());
    assertEquals(&quot;4&quot;, map.get(&quot;d&quot;));

    underlying.remove(&quot;c&quot;);
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey(&quot;c&quot;));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }

  public void testTransformChangesAreReflectedInUnderlyingMap() {
    Map&lt;String, Integer&gt; underlying = Maps.newLinkedHashMap();
    underlying.put(&quot;a&quot;, 1);
    underlying.put(&quot;b&quot;, 2);
    underlying.put(&quot;c&quot;, 3);
    underlying.put(&quot;d&quot;, 4);
    underlying.put(&quot;e&quot;, 5);
    underlying.put(&quot;f&quot;, 6);
    underlying.put(&quot;g&quot;, 7);
    Map&lt;String, String&gt; map = Maps.transformValues(underlying, Functions.toStringFunction());

    map.remove(&quot;a&quot;);
    assertFalse(underlying.containsKey(&quot;a&quot;));

    Set&lt;String&gt; keys = map.keySet();
    keys.remove(&quot;b&quot;);
    assertFalse(underlying.containsKey(&quot;b&quot;));

    Iterator&lt;String&gt; keyIterator = keys.iterator();
    keyIterator.next();
    keyIterator.remove();
    assertFalse(underlying.containsKey(&quot;c&quot;));

    Collection&lt;String&gt; values = map.values();
    values.remove(&quot;4&quot;);
    assertFalse(underlying.containsKey(&quot;d&quot;));

    Iterator&lt;String&gt; valueIterator = values.iterator();
    valueIterator.next();
    valueIterator.remove();
    assertFalse(underlying.containsKey(&quot;e&quot;));

    Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();
    Entry&lt;String, String&gt; firstEntry = entries.iterator().next();
    entries.remove(firstEntry);
    assertFalse(underlying.containsKey(&quot;f&quot;));

    Iterator&lt;Entry&lt;String, String&gt;&gt; entryIterator = entries.iterator();
    entryIterator.next();
    entryIterator.remove();
    assertFalse(underlying.containsKey(&quot;g&quot;));

    assertTrue(underlying.isEmpty());
    assertTrue(map.isEmpty());
    assertTrue(keys.isEmpty());
    assertTrue(values.isEmpty());
    assertTrue(entries.isEmpty());
  }
<A NAME="3"></A>
  public void testTransformEquals() {
    Map&lt;String, Integer&gt; underlying = ImmutableMap.of(&quot;a&quot;, 0, &quot;b&quot;, 1, &quot;c&quot;, 2);
    Map&lt;String, Integer&gt; expected = <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match332030-1.html#3',3,'match332030-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Maps.transformValues(underlying, Functions.&lt;Integer&gt;identity());

    assertMapsEqual(expected, expected);

    Map&lt;String, Integer&gt; equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map&lt;String, Integer&gt; map =
        Maps.transformValues(equalToUnderlying, Functions.&lt;Integer&gt;identity());
    assertMapsEqual</B></FONT>(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3),
            new Function&lt;Integer, Integer&gt;() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }

  public void testTransformEntrySetContains() {
    Map&lt;String, Boolean&gt; underlying = Maps.newHashMap();
    underlying.put(&quot;a&quot;, null);
    underlying.put(&quot;b&quot;, true);
    underlying.put(null, true);

    Map&lt;String, Boolean&gt; map =
        Maps.transformValues(
            underlying,
            new Function&lt;Boolean, Boolean&gt;() {
              @Override
              public Boolean apply(@Nullable Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set&lt;Entry&lt;String, Boolean&gt;&gt; entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry(&quot;a&quot;, true)));
<A NAME="10"></A>    assertTrue(entries.contains(Maps.immutableEntry(&quot;b&quot;, (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match332030-1.html#10',3,'match332030-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>entries.contains(Maps.immutableEntry(&quot;c&quot;, (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }

  @</B></FONT>Override
  public void testKeySetRemoveAllNullFromEmpty() {
    try {
      super.testKeySetRemoveAllNullFromEmpty();
    } catch (RuntimeException tolerated) {
      // GWT's HashMap.keySet().removeAll(null) doesn't throws NPE.
    }
  }

  @Override
  public void testEntrySetRemoveAllNullFromEmpty() {
    try {
      super.testEntrySetRemoveAllNullFromEmpty();
    } catch (RuntimeException tolerated) {
      // GWT's HashMap.entrySet().removeAll(null) doesn't throws NPE.
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeRangeSet_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.Beta;
<A NAME="2"></A>import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#2',2,'match332030-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.Serializable;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeMap;
import javax.annotation.CheckForNull;

/**
 * An implementation of {@link RangeSet} backed by a {@link TreeMap}.
 *
 * @author Louis Wasserman
 * @since 14.0
 */
@</B></FONT>Beta
@GwtIncompatible // uses NavigableMap
@ElementTypesAreNonnullByDefault
public class TreeRangeSet&lt;C extends Comparable&lt;?&gt;&gt; extends AbstractRangeSet&lt;C&gt;
    implements Serializable {

  @VisibleForTesting final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;

  /** Creates an empty {@code TreeRangeSet} instance. */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create() {
    return new TreeRangeSet&lt;&gt;(new TreeMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;());
  }

  /** Returns a {@code TreeRangeSet} initialized with the ranges in the specified range set. */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(RangeSet&lt;C&gt; rangeSet) {
    TreeRangeSet&lt;C&gt; result = create();
    result.addAll(rangeSet);
    return result;
  }

  /**
   * Returns a {@code TreeRangeSet} representing the union of the specified ranges.
   *
   * &lt;p&gt;This is the smallest {@code RangeSet} which encloses each of the specified ranges. An
   * element will be contained in this {@code RangeSet} if and only if it is contained in at least
   * one {@code Range} in {@code ranges}.
   *
   * @since 21.0
   */
  public static &lt;C extends Comparable&lt;?&gt;&gt; TreeRangeSet&lt;C&gt; create(Iterable&lt;Range&lt;C&gt;&gt; ranges) {
    TreeRangeSet&lt;C&gt; result = create();
    result.addAll(ranges);
    return result;
  }

  private TreeRangeSet(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerCut) {
    this.rangesByLowerBound = rangesByLowerCut;
  }

  @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asRanges;
  @CheckForNull private transient Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges;

  @Override
  public Set&lt;Range&lt;C&gt;&gt; asRanges() {
    Set&lt;Range&lt;C&gt;&gt; result = asRanges;
    return (result == null) ? asRanges = new AsRanges(rangesByLowerBound.values()) : result;
  }

  @Override
  public Set&lt;Range&lt;C&gt;&gt; asDescendingSetOfRanges() {
    Set&lt;Range&lt;C&gt;&gt; result = asDescendingSetOfRanges;
    return (result == null)
        ? asDescendingSetOfRanges = new AsRanges(rangesByLowerBound.descendingMap().values())
        : result;
  }
<A NAME="0"></A>
  final class AsRanges extends ForwardingCollection&lt;Range&lt;C&gt;&gt; implements Set&lt;Range&lt;C&gt;&gt; {

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#0',2,'match332030-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Collection&lt;Range&lt;C&gt;&gt; delegate;

    AsRanges(Collection&lt;Range&lt;C&gt;&gt; delegate) {
      this.delegate = delegate;
    }

    @Override
    protected Collection&lt;Range&lt;C&gt;&gt; delegate() {
      return delegate;
    }

    @Override
    public int hashCode() {
      return</B></FONT> Sets.hashCodeImpl(this);
    }

    @Override
    public boolean equals(@CheckForNull Object o) {
      return Sets.equalsImpl(this, o);
    }
  }

  @Override
  @CheckForNull
  public Range&lt;C&gt; rangeContaining(C value) {
    checkNotNull(value);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
    if (floorEntry != null &amp;&amp; floorEntry.getValue().contains(value)) {
      return floorEntry.getValue();
    } else {
      // TODO(kevinb): revisit this design choice
      return null;
    }
  }

  @Override
  public boolean intersects(Range&lt;C&gt; range) {
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; ceilingEntry = rangesByLowerBound.ceilingEntry(range.lowerBound);
    if (ceilingEntry != null
        &amp;&amp; ceilingEntry.getValue().isConnected(range)
        &amp;&amp; !ceilingEntry.getValue().intersection(range).isEmpty()) {
      return true;
<A NAME="10"></A>    }
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; priorEntry = rangesByLowerBound.lowerEntry(range.lowerBound);
    return priorEntry != null
        &amp;&amp; <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#10',2,'match332030-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>priorEntry.getValue().isConnected(range)
        &amp;&amp; !priorEntry.getValue().intersection(range).isEmpty();
  }

  @</B></FONT>Override
<A NAME="13"></A>  public boolean encloses(Range&lt;C&gt; range) {
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#13',2,'match332030-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range);
  }

  @CheckForNull
  private Range&lt;C&gt; rangeEnclosing(Range&lt;C&gt; range) {</B></FONT>
    checkNotNull(range);
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
    return (floorEntry != null &amp;&amp; floorEntry.getValue().encloses(range))
        ? floorEntry.getValue()
        : null;
  }

  @Override
  public Range&lt;C&gt; span() {
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = rangesByLowerBound.firstEntry();
    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lastEntry = rangesByLowerBound.lastEntry();
    if (firstEntry == null || lastEntry == null) {
      /*
       * Either both are null or neither is: Either the set is empty, or it's not. But we check both
       * to make the nullness checker happy.
       */
      throw new NoSuchElementException();
    }
    return Range.create(firstEntry.getValue().lowerBound, lastEntry.getValue().upperBound);
  }

  @Override
  public void add(Range&lt;C&gt; rangeToAdd) {
    checkNotNull(rangeToAdd);

    if (rangeToAdd.isEmpty()) {
      return;
    }

    // We will use { } to illustrate ranges currently in the range set, and &lt; &gt;
    // to illustrate rangeToAdd.
    Cut&lt;C&gt; lbToAdd = rangeToAdd.lowerBound;
    Cut&lt;C&gt; ubToAdd = rangeToAdd.upperBound;

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(lbToAdd);
    if (entryBelowLB != null) {
      // { &lt;
      Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
      if (rangeBelowLB.upperBound.compareTo(lbToAdd) &gt;= 0) {
        // { &lt; }, and we will need to coalesce
        if (rangeBelowLB.upperBound.compareTo(ubToAdd) &gt;= 0) {
          // { &lt; &gt; }
          ubToAdd = rangeBelowLB.upperBound;
          /*
           * TODO(cpovirk): can we just &quot;return;&quot; here? Or, can we remove this if() entirely? If
           * not, add tests to demonstrate the problem with each approach
           */
        }
        lbToAdd = rangeBelowLB.lowerBound;
      }
    }

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(ubToAdd);
    if (entryBelowUB != null) {
      // { &gt;
      Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
      if (rangeBelowUB.upperBound.compareTo(ubToAdd) &gt;= 0) {
        // { &gt; }, and we need to coalesce
        ubToAdd = rangeBelowUB.upperBound;
      }
    }

    // Remove ranges which are strictly enclosed.
    rangesByLowerBound.subMap(lbToAdd, ubToAdd).clear();

    replaceRangeWithSameLowerBound(Range.create(lbToAdd, ubToAdd));
  }

  @Override
  public void remove(Range&lt;C&gt; rangeToRemove) {
    checkNotNull(rangeToRemove);

    if (rangeToRemove.isEmpty()) {
      return;
    }

    // We will use { } to illustrate ranges currently in the range set, and &lt; &gt;
    // to illustrate rangeToRemove.

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowLB = rangesByLowerBound.lowerEntry(rangeToRemove.lowerBound);
    if (entryBelowLB != null) {
      // { &lt;
      Range&lt;C&gt; rangeBelowLB = entryBelowLB.getValue();
      if (rangeBelowLB.upperBound.compareTo(rangeToRemove.lowerBound) &gt;= 0) {
        // { &lt; }, and we will need to subdivide
        if (rangeToRemove.hasUpperBound()
            &amp;&amp; rangeBelowLB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
          // { &lt; &gt; }
          replaceRangeWithSameLowerBound(
              Range.create(rangeToRemove.upperBound, rangeBelowLB.upperBound));
        }
        replaceRangeWithSameLowerBound(
            Range.create(rangeBelowLB.lowerBound, rangeToRemove.lowerBound));
      }
    }

    Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; entryBelowUB = rangesByLowerBound.floorEntry(rangeToRemove.upperBound);
    if (entryBelowUB != null) {
      // { &gt;
      Range&lt;C&gt; rangeBelowUB = entryBelowUB.getValue();
      if (rangeToRemove.hasUpperBound()
          &amp;&amp; rangeBelowUB.upperBound.compareTo(rangeToRemove.upperBound) &gt;= 0) {
        // { &gt; }
        replaceRangeWithSameLowerBound(
            Range.create(rangeToRemove.upperBound, rangeBelowUB.upperBound));
      }
    }

    rangesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
  }

  private void replaceRangeWithSameLowerBound(Range&lt;C&gt; range) {
    if (range.isEmpty()) {
      rangesByLowerBound.remove(range.lowerBound);
    } else {
      rangesByLowerBound.put(range.lowerBound, range);
    }
  }

  @CheckForNull private transient RangeSet&lt;C&gt; complement;

  @Override
  public RangeSet&lt;C&gt; complement() {
    RangeSet&lt;C&gt; result = complement;
    return (result == null) ? complement = new Complement() : result;
  }

  @VisibleForTesting
  static final class RangesByUpperBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;

    /**
     * upperBoundWindow represents the headMap/subMap/tailMap view of the entire &quot;ranges by upper
     * bound&quot; map; it's a constraint on the *keys*, and does not affect the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow;

    RangesByUpperBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
      this.rangesByLowerBound = rangesByLowerBound;
      this.upperBoundWindow = Range.all();
    }

    private RangesByUpperBound(
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; upperBoundWindow) {
      this.rangesByLowerBound = rangesByLowerBound;
      this.upperBoundWindow = upperBoundWindow;
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
      if (window.isConnected(upperBoundWindow)) {
        return new RangesByUpperBound&lt;&gt;(rangesByLowerBound, window.intersection(upperBoundWindow));
      } else {
        return ImmutableSortedMap.of();
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
<A NAME="7"></A>    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#7',2,'match332030-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</B></FONT>, boolean inclusive) {
<A NAME="14"></A>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#14',2,'match332030-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @</B></FONT>Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings(&quot;unchecked&quot;) // we catch CCEs
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          if (!upperBoundWindow.contains(cut)) {
            return null;
          }
          Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; candidate = rangesByLowerBound.lowerEntry(cut);
          if (candidate != null &amp;&amp; candidate.getValue().upperBound.equals(cut)) {
            return candidate.getValue();
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
      /*
       * We want to start the iteration at the first range where the upper bound is in
       * upperBoundWindow.
       */
      Iterator&lt;Range&lt;C&gt;&gt; backingItr;
      if (!upperBoundWindow.hasLowerBound()) {
        backingItr = rangesByLowerBound.values().iterator();
      } else {
        Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; lowerEntry =
            rangesByLowerBound.lowerEntry(upperBoundWindow.lowerEndpoint());
        if (lowerEntry == null) {
          backingItr = rangesByLowerBound.values().iterator();
        } else if (upperBoundWindow.lowerBound.isLessThan(lowerEntry.getValue().upperBound)) {
          backingItr = rangesByLowerBound.tailMap(lowerEntry.getKey(), true).values().iterator();
        } else {
          backingItr =
              rangesByLowerBound
                  .tailMap(upperBoundWindow.lowerEndpoint(), true)
                  .values()
                  .iterator();
        }
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!backingItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; range = backingItr.next();
          if (upperBoundWindow.upperBound.isLessThan(range.upperBound)) {
            return endOfData();
          } else {
            return Maps.immutableEntry(range.upperBound, range);
          }
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
      Collection&lt;Range&lt;C&gt;&gt; candidates;
      if (upperBoundWindow.hasUpperBound()) {
        candidates =
            rangesByLowerBound
                .headMap(upperBoundWindow.upperEndpoint(), false)
                .descendingMap()
                .values();
      } else {
        candidates = rangesByLowerBound.descendingMap().values();
      }
      PeekingIterator&lt;Range&lt;C&gt;&gt; backingItr = Iterators.peekingIterator(candidates.iterator());
      if (backingItr.hasNext()
          &amp;&amp; upperBoundWindow.upperBound.isLessThan(backingItr.peek().upperBound)) {
        backingItr.next();
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!backingItr.hasNext()) {
            return endOfData();
<A NAME="8"></A>          }
          Range&lt;C&gt; range = backingItr.next();
          return upperBoundWindow.lowerBound.isLessThan(range.upperBound)
              ? <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#8',2,'match332030-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Maps.immutableEntry(range.upperBound, range)
              : endOfData();
        }
      };
    }

    @Override
    public int size() {</B></FONT>
      if (upperBoundWindow.equals(Range.all())) {
        return rangesByLowerBound.size();
      }
      return Iterators.size(entryIterator());
    }

    @Override
    public boolean isEmpty() {
      return upperBoundWindow.equals(Range.all())
          ? rangesByLowerBound.isEmpty()
          : !entryIterator().hasNext();
    }
  }

  private static final class ComplementRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound;
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByUpperBound;

    /**
     * complementLowerBoundWindow represents the headMap/subMap/tailMap view of the entire
     * &quot;complement ranges by lower bound&quot; map; it's a constraint on the *keys*, and does not affect
     * the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; complementLowerBoundWindow;

    ComplementRangesByLowerBound(NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound) {
      this(positiveRangesByLowerBound, Range.&lt;Cut&lt;C&gt;&gt;all());
    }

    private ComplementRangesByLowerBound(
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; positiveRangesByLowerBound, Range&lt;Cut&lt;C&gt;&gt; window) {
      this.positiveRangesByLowerBound = positiveRangesByLowerBound;
      this.positiveRangesByUpperBound = new RangesByUpperBound&lt;&gt;(positiveRangesByLowerBound);
      this.complementLowerBoundWindow = window;
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; subWindow) {
      if (!complementLowerBoundWindow.isConnected(subWindow)) {
        return ImmutableSortedMap.of();
      } else {
        subWindow = subWindow.intersection(complementLowerBoundWindow);
        return new ComplementRangesByLowerBound&lt;&gt;(positiveRangesByLowerBound, subWindow);
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
<A NAME="5"></A>    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#5',2,'match332030-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey</B></FONT>, boolean inclusive) {
<A NAME="9"></A>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#9',2,'match332030-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {</B></FONT>
      /*
       * firstComplementRangeLowerBound is the first complement range lower bound inside
       * complementLowerBoundWindow. Complement range lower bounds are either positive range upper
       * bounds, or Cut.belowAll().
       *
       * positiveItr starts at the first positive range with lower bound greater than
       * firstComplementRangeLowerBound. (Positive range lower bounds correspond to complement range
       * upper bounds.)
       */
      Collection&lt;Range&lt;C&gt;&gt; positiveRanges;
      if (complementLowerBoundWindow.hasLowerBound()) {
        positiveRanges =
            positiveRangesByUpperBound
                .tailMap(
                    complementLowerBoundWindow.lowerEndpoint(),
                    complementLowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
                .values();
      } else {
        positiveRanges = positiveRangesByUpperBound.values();
      }
      PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr = Iterators.peekingIterator(positiveRanges.iterator());
      Cut&lt;C&gt; firstComplementRangeLowerBound;
      if (complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
          &amp;&amp; (!positiveItr.hasNext() || positiveItr.peek().lowerBound != Cut.&lt;C&gt;belowAll())) {
        firstComplementRangeLowerBound = Cut.belowAll();
      } else if (positiveItr.hasNext()) {
        firstComplementRangeLowerBound = positiveItr.next().upperBound;
      } else {
        return Iterators.emptyIterator();
      }
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        Cut&lt;C&gt; nextComplementRangeLowerBound = firstComplementRangeLowerBound;

        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (complementLowerBoundWindow.upperBound.isLessThan(nextComplementRangeLowerBound)
              || nextComplementRangeLowerBound == Cut.&lt;C&gt;aboveAll()) {
            return endOfData();
          }
          Range&lt;C&gt; negativeRange;
          if (positiveItr.hasNext()) {
            Range&lt;C&gt; positiveRange = positiveItr.next();
            negativeRange = Range.create(nextComplementRangeLowerBound, positiveRange.lowerBound);
            nextComplementRangeLowerBound = positiveRange.upperBound;
          } else {
            negativeRange = Range.create(nextComplementRangeLowerBound, Cut.&lt;C&gt;aboveAll());
            nextComplementRangeLowerBound = Cut.aboveAll();
          }
          return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
      /*
       * firstComplementRangeUpperBound is the upper bound of the last complement range with lower
       * bound inside complementLowerBoundWindow.
       *
       * positiveItr starts at the first positive range with upper bound less than
       * firstComplementRangeUpperBound. (Positive range upper bounds correspond to complement range
<A NAME="3"></A>       * lower bounds.)
       */
      Cut&lt;C&gt; startingPoint =
          <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#3',2,'match332030-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>complementLowerBoundWindow.hasUpperBound()
              ? complementLowerBoundWindow.upperEndpoint()
              : Cut.&lt;C&gt;aboveAll();
      boolean inclusive =
          complementLowerBoundWindow.hasUpperBound()
              &amp;&amp; complementLowerBoundWindow.upperBoundType() == BoundType.CLOSED;
      PeekingIterator&lt;Range&lt;C&gt;&gt; positiveItr =
          Iterators.peekingIterator(
              positiveRangesByUpperBound</B></FONT>
                  .headMap(startingPoint, inclusive)
                  .descendingMap()
                  .values()
                  .iterator());
      Cut&lt;C&gt; cut;
      if (positiveItr.hasNext()) {
        cut =
            (positiveItr.peek().upperBound == Cut.&lt;C&gt;aboveAll())
                ? positiveItr.next().lowerBound
                : positiveRangesByLowerBound.higherKey(positiveItr.peek().upperBound);
      } else if (!complementLowerBoundWindow.contains(Cut.&lt;C&gt;belowAll())
          || positiveRangesByLowerBound.containsKey(Cut.belowAll())) {
        return Iterators.emptyIterator();
      } else {
        cut = positiveRangesByLowerBound.higherKey(Cut.&lt;C&gt;belowAll());
      }
      Cut&lt;C&gt; firstComplementRangeUpperBound = MoreObjects.firstNonNull(cut, Cut.&lt;C&gt;aboveAll());
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        Cut&lt;C&gt; nextComplementRangeUpperBound = firstComplementRangeUpperBound;

        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (nextComplementRangeUpperBound == Cut.&lt;C&gt;belowAll()) {
            return endOfData();
          } else if (positiveItr.hasNext()) {
            Range&lt;C&gt; positiveRange = positiveItr.next();
            Range&lt;C&gt; negativeRange =
                Range.create(positiveRange.upperBound, nextComplementRangeUpperBound);
            nextComplementRangeUpperBound = positiveRange.lowerBound;
            if (complementLowerBoundWindow.lowerBound.isLessThan(negativeRange.lowerBound)) {
              return Maps.immutableEntry(negativeRange.lowerBound, negativeRange);
            }
          } else if (complementLowerBoundWindow.lowerBound.isLessThan(Cut.&lt;C&gt;belowAll())) {
            Range&lt;C&gt; negativeRange = Range.create(Cut.&lt;C&gt;belowAll(), nextComplementRangeUpperBound);
<A NAME="6"></A>            nextComplementRangeUpperBound = Cut.belowAll();
            return Maps.immutableEntry(Cut.&lt;C&gt;belowAll(), negativeRange);
          }
          return <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#6',2,'match332030-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>endOfData();
        }
      };
    }

    @Override
    public int size() {
      return</B></FONT> Iterators.size(entryIterator());
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings(&quot;unchecked&quot;)
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          // tailMap respects the current window
          Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; firstEntry = tailMap(cut, true).firstEntry();
          if (firstEntry != null &amp;&amp; firstEntry.getKey().equals(cut)) {
            return firstEntry.getValue();
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }
  }

  private final class Complement extends TreeRangeSet&lt;C&gt; {
    Complement() {
      super(new ComplementRangesByLowerBound&lt;C&gt;(TreeRangeSet.this.rangesByLowerBound));
    }

    @Override
    public void add(Range&lt;C&gt; rangeToAdd) {
      TreeRangeSet.this.remove(rangeToAdd);
    }
<A NAME="11"></A>
    @Override
    public void remove(Range&lt;C&gt; rangeToRemove) {
      <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#11',2,'match332030-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TreeRangeSet.this.add(rangeToRemove);
    }

    @Override
    public boolean contains(C value) {
      return !TreeRangeSet.this.contains</B></FONT>(value);
    }

    @Override
    public RangeSet&lt;C&gt; complement() {
      return TreeRangeSet.this;
    }
  }

  private static final class SubRangeSetRangesByLowerBound&lt;C extends Comparable&lt;?&gt;&gt;
      extends AbstractNavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; {
    /**
     * lowerBoundWindow is the headMap/subMap/tailMap view; it only restricts the keys, and does not
     * affect the values.
     */
    private final Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow;

    /**
     * restriction is the subRangeSet view; ranges are truncated to their intersection with
     * restriction.
     */
    private final Range&lt;C&gt; restriction;

    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound;
    private final NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByUpperBound;

    private SubRangeSetRangesByLowerBound(
        Range&lt;Cut&lt;C&gt;&gt; lowerBoundWindow,
        Range&lt;C&gt; restriction,
        NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; rangesByLowerBound) {
      this.lowerBoundWindow = checkNotNull(lowerBoundWindow);
      this.restriction = checkNotNull(restriction);
      this.rangesByLowerBound = checkNotNull(rangesByLowerBound);
      this.rangesByUpperBound = new RangesByUpperBound&lt;&gt;(rangesByLowerBound);
    }

    private NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(Range&lt;Cut&lt;C&gt;&gt; window) {
      if (!window.isConnected(lowerBoundWindow)) {
        return ImmutableSortedMap.of();
      } else {
        return new SubRangeSetRangesByLowerBound&lt;&gt;(
            lowerBoundWindow.intersection(window), restriction, rangesByLowerBound);
      }
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; subMap(
        Cut&lt;C&gt; fromKey, boolean fromInclusive, Cut&lt;C&gt; toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey,
              BoundType.forBoolean(fromInclusive),
              toKey,
              BoundType.forBoolean(toInclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; headMap(Cut&lt;C&gt; toKey, boolean inclusive) {
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; tailMap(Cut&lt;C&gt; fromKey, boolean inclusive) {
<A NAME="12"></A>      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#12',2,'match332030-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public Comparator&lt;? super Cut&lt;C&gt;&gt; comparator() {
      return Ordering.&lt;Cut&lt;C&gt;&gt;natural();
    }

    @</B></FONT>Override
    public boolean containsKey(@CheckForNull Object key) {
      return get(key) != null;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; get(@CheckForNull Object key) {
      if (key instanceof Cut) {
        try {
          @SuppressWarnings(&quot;unchecked&quot;) // we catch CCE's
          Cut&lt;C&gt; cut = (Cut&lt;C&gt;) key;
          if (!lowerBoundWindow.contains(cut)
              || cut.compareTo(restriction.lowerBound) &lt; 0
              || cut.compareTo(restriction.upperBound) &gt;= 0) {
            return null;
          } else if (cut.equals(restriction.lowerBound)) {
            // it might be present, truncated on the left
            Range&lt;C&gt; candidate = Maps.valueOrNull(rangesByLowerBound.floorEntry(cut));
            if (candidate != null &amp;&amp; candidate.upperBound.compareTo(restriction.lowerBound) &gt; 0) {
              return candidate.intersection(restriction);
            }
          } else {
            Range&lt;C&gt; result = rangesByLowerBound.get(cut);
            if (result != null) {
              return result.intersection(restriction);
            }
          }
        } catch (ClassCastException e) {
          return null;
        }
      }
      return null;
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; entryIterator() {
      if (restriction.isEmpty()) {
        return Iterators.emptyIterator();
      }
      Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr;
      if (lowerBoundWindow.upperBound.isLessThan(restriction.lowerBound)) {
        return Iterators.emptyIterator();
      } else if (lowerBoundWindow.lowerBound.isLessThan(restriction.lowerBound)) {
        // starts at the first range with upper bound strictly greater than restriction.lowerBound
        completeRangeItr =
            rangesByUpperBound.tailMap(restriction.lowerBound, false).values().iterator();
      } else {
        // starts at the first range with lower bound above lowerBoundWindow.lowerBound
        completeRangeItr =
            rangesByLowerBound
                .tailMap(
                    lowerBoundWindow.lowerBound.endpoint(),
                    lowerBoundWindow.lowerBoundType() == BoundType.CLOSED)
                .values()
                .iterator();
      }
      Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
          Ordering.natural()
              .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!completeRangeItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; nextRange = completeRangeItr.next();
          if (upperBoundOnLowerBounds.isLessThan(nextRange.lowerBound)) {
            return endOfData();
          } else {
            nextRange = nextRange.intersection(restriction);
            return Maps.immutableEntry(nextRange.lowerBound, nextRange);
          }
        }
      };
    }

    @Override
    Iterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt; descendingEntryIterator() {
<A NAME="4"></A>      if (restriction.isEmpty()) {
        return Iterators.emptyIterator();
      }
      <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#4',2,'match332030-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Cut&lt;Cut&lt;C&gt;&gt; upperBoundOnLowerBounds =
          Ordering.natural()
              .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
      Iterator&lt;Range&lt;C&gt;&gt; completeRangeItr =
          rangesByLowerBound
              .headMap(
                  upperBoundOnLowerBounds.endpoint</B></FONT>(),
                  upperBoundOnLowerBounds.typeAsUpperBound() == BoundType.CLOSED)
              .descendingMap()
              .values()
              .iterator();
      return new AbstractIterator&lt;Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt;&gt;() {
        @Override
        @CheckForNull
        protected Entry&lt;Cut&lt;C&gt;, Range&lt;C&gt;&gt; computeNext() {
          if (!completeRangeItr.hasNext()) {
            return endOfData();
          }
          Range&lt;C&gt; nextRange = completeRangeItr.next();
          if (restriction.lowerBound.compareTo(nextRange.upperBound) &gt;= 0) {
            return endOfData();
          }
          nextRange = nextRange.intersection(restriction);
          if (lowerBoundWindow.contains(nextRange.lowerBound)) {
            return Maps.immutableEntry(nextRange.lowerBound, nextRange);
          } else {
            return endOfData();
          }
        }
      };
    }

    @Override
    public int size() {
      return Iterators.size(entryIterator());
    }
  }

  @Override
  public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
    return view.equals(Range.&lt;C&gt;all()) ? this : new SubRangeSet(view);
  }

  private final class SubRangeSet extends TreeRangeSet&lt;C&gt; {
    private final Range&lt;C&gt; restriction;

    SubRangeSet(Range&lt;C&gt; restriction) {
      super(
          new SubRangeSetRangesByLowerBound&lt;C&gt;(
              Range.&lt;Cut&lt;C&gt;&gt;all(), restriction, TreeRangeSet.this.rangesByLowerBound));
      this.restriction = restriction;
    }

    @Override
    public boolean encloses(Range&lt;C&gt; range) {
      if (!restriction.isEmpty() &amp;&amp; restriction.encloses(range)) {
        Range&lt;C&gt; enclosing = TreeRangeSet.this.rangeEnclosing(range);
        return enclosing != null &amp;&amp; !enclosing.intersection(restriction).isEmpty();
      }
      return false;
    }

    @Override
    @CheckForNull
    public Range&lt;C&gt; rangeContaining(C value) {
      if (!restriction.contains(value)) {
        return null;
      }
      Range&lt;C&gt; result = TreeRangeSet.this.rangeContaining(value);
      return (result == null) ? null : result.intersection(restriction);
    }

    @Override
    public void add(Range&lt;C&gt; rangeToAdd) {
      checkArgument(
          restriction.encloses(rangeToAdd),
          &quot;Cannot add range %s to subRangeSet(%s)&quot;,
          rangeToAdd,
          restriction);
      TreeRangeSet.this.add(rangeToAdd);
    }

    @Override
    public void remove(Range&lt;C&gt; rangeToRemove) {
<A NAME="1"></A>      if (rangeToRemove.isConnected(restriction)) {
        TreeRangeSet.this.remove(rangeToRemove.intersection(restriction));
      }
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match332030-0.html#1',2,'match332030-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public boolean contains(C value) {
      return restriction.contains(value) &amp;&amp; TreeRangeSet.this.contains(value);
    }

    @</B></FONT>Override
    public void clear() {
      TreeRangeSet.this.remove(restriction);
    }

    @Override
    public RangeSet&lt;C&gt; subRangeSet(Range&lt;C&gt; view) {
      if (view.encloses(restriction)) {
        return this;
      } else if (view.isConnected(restriction)) {
        return new SubRangeSet(restriction.intersection(view));
      } else {
        return ImmutableRangeSet.of();
      }
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
