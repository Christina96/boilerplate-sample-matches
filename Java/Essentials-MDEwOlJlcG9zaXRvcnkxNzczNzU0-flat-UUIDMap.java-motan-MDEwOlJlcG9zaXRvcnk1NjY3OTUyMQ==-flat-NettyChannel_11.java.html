
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.905930470347649%, Tokens: 10</h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-UUIDMap.java</h3>
            <pre><code>1  package com.earth2me.essentials;
2  import com.google.common.io.Files;
3  import java.io.BufferedReader;
4  import java.io.BufferedWriter;
5  import java.io.File;
6  import java.io.FileReader;
7  import java.io.FileWriter;
8  import java.io.IOException;
9  import java.util.ArrayList;
10  import java.util.Map;
11  import java.util.UUID;
12  import java.util.concurrent.ConcurrentSkipListMap;
13  import java.util.concurrent.ExecutionException;
14  import java.util.concurrent.ExecutorService;
15  import java.util.concurrent.Executors;
16  import java.util.concurrent.Future;
17  import java.util.concurrent.atomic.AtomicInteger;
18  import java.util.logging.Level;
19  import java.util.regex.Pattern;
20  import org.bukkit.Bukkit;
21  public class UUIDMap
22  {
23  	private final transient net.ess3.api.IEssentials ess;
24  	private File userList;
25  	private final transient Pattern splitPattern = Pattern.compile(",");
26  	private static final ExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadExecutor();
27  	private final AtomicInteger pendingDiskWrites = new AtomicInteger(0);
28  	public UUIDMap(final net.ess3.api.IEssentials ess)
29  	{
30  		this.ess = ess;
31  		userList = new File(ess.getDataFolder(), "usermap.csv");
32  	}
33  	public void loadAllUsers(final ConcurrentSkipListMap<String, UUID> names, final ConcurrentSkipListMap<UUID, ArrayList<String>> history)
34  	{
35  		try
36  		{
37  			if (!userList.exists())
38  			{
39  				userList.createNewFile();
40  			}
41  			synchronized (pendingDiskWrites)
42  			{
43  				if (ess.getSettings().isDebug())
44  				{
45  					ess.getLogger().log(Level.INFO, "Reading usermap from disk");
46  				}
47  				names.clear();
48  				history.clear();
49  				final BufferedReader reader = new BufferedReader(new FileReader(userList));
50  				try
51  				{
52  					while (true)
53  					{
54  						final String line = reader.readLine();
55  						if (line == null)
56  						{
57  							break;
58  						}
59  						else
60  						{
61  							final String[] values = splitPattern.split(line);
62  							if (values.length == 2)
63  							{
64  								final String name = values[0];
65  								final UUID uuid = UUID.fromString(values[1]);
66  								names.put(name, uuid);
67  								if (!history.containsKey(uuid))
68  								{
69  									final ArrayList<String> list = new ArrayList<String>();
70  									list.add(name);
71  									history.put(uuid, list);
72  								}
73  								else
74  								{
75  									final ArrayList<String> list = history.get(uuid);
76  									if (!list.contains(name))
77  									{
78  										list.add(name);
79  									}
80  								}
81  							}
82  						}
83  					}
84  				}
85  				finally
86  				{
87  					reader.close();
88  				}
89  			}
90  		}
91  		catch (IOException ex)
92  		{
93  			Bukkit.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
94  		}
95  	}
96  	public void writeUUIDMap()
97  	{
98  		_writeUUIDMap();
99  	}
100  	public void forceWriteUUIDMap()
101  	{
102  		if (ess.getSettings().isDebug())
103  		{
104  			ess.getLogger().log(Level.INFO, "Forcing usermap write to disk");
105  		}
106  		try
107  		{
108  			Future<?> future = _writeUUIDMap();;
<span onclick='openModal()' class='match'>109  			if (future != null)
110  			{
111  				future.get();
112  			}
113  		}
114  		catch (InterruptedException ex)
115  		{
116  			ess.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
117  		}
118  		catch (ExecutionException ex)
119  		{
120  			ess.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
121  		}
</span>122  	}
123  	public Future<?> _writeUUIDMap()
124  	{
125  		final ConcurrentSkipListMap<String, UUID> names = ess.getUserMap().getNames();
126  		if (names.size() < 1)
127  		{
128  			return null;
129  		}
130  		pendingDiskWrites.incrementAndGet();
131  		Future<?> future = EXECUTOR_SERVICE.submit(new WriteRunner(ess.getDataFolder(), userList, names, pendingDiskWrites));
132  		return future;
133  	}
134  	private static class WriteRunner implements Runnable
135  	{
136  		private final File location;
137  		private final File endFile;
138  		private final ConcurrentSkipListMap<String, UUID> names;
139  		private final AtomicInteger pendingDiskWrites;
140  		private WriteRunner(final File location, final File endFile, final ConcurrentSkipListMap<String, UUID> names, final AtomicInteger pendingDiskWrites)
141  		{
142  			this.location = location;
143  			this.endFile = endFile;
144  			this.names = names;
145  			this.pendingDiskWrites = pendingDiskWrites;
146  		}
147  		@Override
148  		public void run()
149  		{
150  			synchronized (pendingDiskWrites)
151  			{
152  				if (pendingDiskWrites.get() > 1)
153  				{
154  					pendingDiskWrites.decrementAndGet();
155  					return;
156  				}
157  				File configFile = null;
158  				try
159  				{
160  					configFile = File.createTempFile("usermap", ".tmp.csv", location);
161  					final BufferedWriter bWriter = new BufferedWriter(new FileWriter(configFile));
162  					for (Map.Entry<String, UUID> entry : names.entrySet())
163  					{
164  						bWriter.write(entry.getKey() + "," + entry.getValue().toString());
165  						bWriter.newLine();
166  					}
167  					bWriter.close();
168  					Files.move(configFile, endFile);
169  				}
170  				catch (IOException ex)
171  				{
172  					try
173  					{
174  						if (configFile != null && configFile.exists())
175  						{
176  							Files.move(configFile, new File(endFile.getParentFile(), "usermap.bak.csv"));
177  						}
178  					}
179  					catch (Exception ex2)
180  					{
181  						Bukkit.getLogger().log(Level.SEVERE, ex2.getMessage(), ex2);
182  					}
183  					Bukkit.getLogger().log(Level.WARNING, ex.getMessage(), ex);
184  				}
185  				finally
186  				{
187  					pendingDiskWrites.decrementAndGet();
188  				}
189  			}
190  		}
191  	}
192  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannel_11.java</h3>
            <pre><code>1  package com.weibo.api.motan.transport.netty4;
2  import com.weibo.api.motan.codec.Codec;
3  import com.weibo.api.motan.common.ChannelState;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.common.URLParamType;
6  import com.weibo.api.motan.core.extension.ExtensionLoader;
7  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
8  import com.weibo.api.motan.exception.MotanFrameworkException;
9  import com.weibo.api.motan.exception.MotanServiceException;
10  import com.weibo.api.motan.rpc.*;
11  import com.weibo.api.motan.transport.Channel;
12  import com.weibo.api.motan.transport.TransportException;
13  import com.weibo.api.motan.util.ExceptionUtil;
14  import com.weibo.api.motan.util.LoggerUtil;
15  import com.weibo.api.motan.util.MathUtil;
16  import com.weibo.api.motan.util.MotanFrameworkUtil;
17  import io.netty.channel.ChannelFuture;
18  import java.net.InetSocketAddress;
19  import java.util.concurrent.TimeUnit;
20  import java.util.concurrent.locks.ReentrantLock;
21  public class NettyChannel implements Channel {
22      private volatile ChannelState state = ChannelState.UNINIT;
23      private NettyClient nettyClient;
24      private io.netty.channel.Channel channel = null;
25      private InetSocketAddress remoteAddress = null;
26      private InetSocketAddress localAddress = null;
27      private ReentrantLock lock = new ReentrantLock();
28      private Codec codec;
29      public NettyChannel(NettyClient nettyClient) {
30          this.nettyClient = nettyClient;
31          this.remoteAddress = new InetSocketAddress(nettyClient.getUrl().getHost(), nettyClient.getUrl().getPort());
32          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(nettyClient.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
33      }
34      @Override
35      public InetSocketAddress getLocalAddress() {
36          return localAddress;
37      }
38      @Override
39      public InetSocketAddress getRemoteAddress() {
40          return remoteAddress;
41      }
42      @Override
43      public Response request(Request request) throws TransportException {
44          int timeout = 0;
45          if (request.getAttachments().get(MotanConstants.M2_TIMEOUT) != null) { 
46              timeout = MathUtil.parseInt(request.getAttachments().get(MotanConstants.M2_TIMEOUT), 0);
47          }
48          if (timeout == 0) { 
49              timeout = nettyClient.getUrl().getMethodParameter(request.getMethodName(), request.getParamtersDesc(), URLParamType.requestTimeout.getName(), URLParamType.requestTimeout.getIntValue());
50          }
51          if (timeout <= 0) {
52              throw new MotanFrameworkException("NettyClient init Error: timeout(" + timeout + ") <= 0 is forbid.", MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
53          }
54          ResponseFuture response = new DefaultResponseFuture(request, timeout, this.nettyClient.getUrl());
55          this.nettyClient.registerCallback(request.getRequestId(), response);
56          byte[] msg = CodecUtil.encodeObjectToBytes(this, codec, request);
57          ChannelFuture writeFuture = this.channel.writeAndFlush(msg);
58          request.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(msg.length));
59          boolean result = writeFuture.awaitUninterruptibly(timeout, TimeUnit.MILLISECONDS);
60          if (result && writeFuture.isSuccess()) {
61              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_CSEND, System.currentTimeMillis());
62              response.addListener(new FutureListener() {
63                  @Override
64                  public void operationComplete(Future future) throws Exception {
65                      if (future.isSuccess() || (future.isDone() && ExceptionUtil.isBizException(future.getException()))) {
66                          nettyClient.resetErrorCount();
67                      } else {
68                          nettyClient.incrErrorCount();
69                      }
70                  }
71              });
72              return response;
73          }
74          writeFuture.cancel(true);
75          response = this.nettyClient.removeCallback(request.getRequestId());
76          if (response != null) {
77              response.cancel();
78          }
79          nettyClient.incrErrorCount();
80          if (writeFuture.cause() != null) {
81              throw new MotanServiceException("NettyChannel send request to server Error: url="
82                      + nettyClient.getUrl().getUri() + " local=" + localAddress + " "
83                      + MotanFrameworkUtil.toString(request), writeFuture.cause());
84          } else {
85              throw new MotanServiceException("NettyChannel send request to server Timeout: url="
86                      + nettyClient.getUrl().getUri() + " local=" + localAddress + " "
87                      + MotanFrameworkUtil.toString(request), false);
88          }
89      }
90      @Override
91      public boolean open() {
92          if (isAvailable()) {
93              LoggerUtil.warn("the channel already open, local: " + localAddress + " remote: " + remoteAddress + " url: " + nettyClient.getUrl().getUri());
94              return true;
95          }
96          ChannelFuture channelFuture = null;
97          try {
98              synchronized (this) {
99                  long start = System.currentTimeMillis();
100                  channelFuture = nettyClient.getBootstrap().connect(remoteAddress);
101                  int timeout = nettyClient.getUrl().getIntParameter(URLParamType.connectTimeout.getName(), URLParamType.connectTimeout.getIntValue());
102                  if (timeout <= 0) {
103                      throw new MotanFrameworkException("NettyClient init Error: timeout(" + timeout + ") <= 0 is forbid.", MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
104                  }
105                  boolean result = channelFuture.awaitUninterruptibly(timeout, TimeUnit.MILLISECONDS);
106                  boolean success = channelFuture.isSuccess();
107                  if (result && success) {
108                      channel = channelFuture.channel();
109                      if (channel.localAddress() != null && channel.localAddress() instanceof InetSocketAddress) {
110                          localAddress = (InetSocketAddress) channel.localAddress();
111                      }
112                      state = ChannelState.ALIVE;
113                      return true;
114                  }
115                  boolean connected = false;
116                  if (channelFuture.channel() != null) {
117                      connected = channelFuture.channel().isActive();
118                  }
119                  if (channelFuture.cause() != null) {
120                      channelFuture.cancel(true);
121                      throw new MotanServiceException("NettyChannel failed to connect to server, url: " + nettyClient.getUrl().getUri() + ", result: " + result + ", success: " + success + ", connected: " + connected, channelFuture.cause());
122                  } else {
123                      channelFuture.cancel(true);
124                      throw new MotanServiceException("NettyChannel connect to server timeout url: " + nettyClient.getUrl().getUri() + ", cost: " + (System.currentTimeMillis() - start) + ", result: " + result + ", success: " + success + ", connected: " + connected, false);
125                  }
126              }
127          } catch (MotanServiceException e) {
128              throw e;
129          } catch (Exception e) {
130              if (channelFuture != null) {
131                  channelFuture.channel().close();
132              }
133              throw new MotanServiceException("NettyChannel failed to connect to server, url: " + nettyClient.getUrl().getUri(), e);
134          } finally {
135              if (!state.isAliveState()) {
136                  nettyClient.incrErrorCount(); 
137              }
138          }
139      }
140      @Override
141      public synchronized void close() {
142          close(0);
143      }
144      @Override
145      public synchronized void close(int timeout) {
146          try {
147              state = ChannelState.CLOSE;
<span onclick='openModal()' class='match'>148              if (channel != null) {
149                  channel.close();
150              }
151          } catch (Exception e) {
152              LoggerUtil.error("NettyChannel close Error: " + nettyClient.getUrl().getUri() + " local=" + localAddress, e);
153          }
</span>154      }
155      @Override
156      public boolean isClosed() {
157          return state.isCloseState();
158      }
159      @Override
160      public boolean isAvailable() {
161          return state.isAliveState() && channel != null && channel.isActive();
162      }
163      public void reconnect() {
164          state = ChannelState.INIT;
165      }
166      public boolean isReconnect() {
167          return state.isInitState();
168      }
169      @Override
170      public URL getUrl() {
171          return nettyClient.getUrl();
172      }
173      public ReentrantLock getLock() {
174          return lock;
175      }
176  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-UUIDMap.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannel_11.java</div>
                <div class="column column_space"><pre><code>109  			if (future != null)
110  			{
111  				future.get();
112  			}
113  		}
114  		catch (InterruptedException ex)
115  		{
116  			ess.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
117  		}
118  		catch (ExecutionException ex)
119  		{
120  			ess.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
121  		}
</pre></code></div>
                <div class="column column_space"><pre><code>148              if (channel != null) {
149                  channel.close();
150              }
151          } catch (Exception e) {
152              LoggerUtil.error("NettyChannel close Error: " + nettyClient.getUrl().getUri() + " local=" + localAddress, e);
153          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    