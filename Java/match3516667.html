<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ClientCertAuthTest.java &amp; Netty4Transport.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ClientCertAuthTest.java &amp; Netty4Transport.java
      </h3>
<h1 align="center">
        5.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ClientCertAuthTest.java (14.529915%)<th>Netty4Transport.java (3.6876357%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-44)<td><a href="#" name="0">(59-85)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ClientCertAuthTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.auth;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.user.User;
4 import io.crate.protocols.postgres.ConnectionProperties;
5 import org.elasticsearch.test.ESTestCase;
6 import io.netty.handler.ssl.util.SelfSignedCertificate;
7 import org.elasticsearch.common.network.InetAddresses;
8 import org.junit.Before;
9 import org.junit.BeforeClass;
10 import org.junit.Test;
11 import javax.net.ssl.SSLSession;
12 import java.security.cert.Certificate;
13 import java.util.Date;
14 import java.util.Locale;
15 import static org.hamcrest.Matchers.is;
16 import static org.mockito.Mockito.mock;
17 import static org.mockito.Mockito.when;
18 public class ClientCertAuthTest extends ESTestCase {
19     private ConnectionProperties sslConnWithCert</b></font>;
20     private User exampleUser = User.of("example.com");
21     private SSLSession sslSession;
22     @BeforeClass
23     public static void ensureEnglishLocale() {
24         Locale.setDefault(Locale.ENGLISH);
25     }
26     @Before
27     public void setUpSsl() throws Exception {
28         var notBefore = new Date(System.currentTimeMillis() - 86400000L * 365);
29         var notAfter = new Date(253402300799000L);
30         SelfSignedCertificate ssc = new SelfSignedCertificate(
31             "example.com", notBefore, notAfter, "RSA", 2048
32         );
33         sslSession = mock(SSLSession.class);
34         when(sslSession.getPeerCertificates()).thenReturn(new Certificate[] { ssc.cert() });
35         sslConnWithCert = new ConnectionProperties(InetAddresses.forString("127.0.0.1"), Protocol.POSTGRES, sslSession);
36     }
37     @Test
38     public void testLookupValidUserWithCert() throws Exception {
39         ClientCertAuth clientCertAuth = new ClientCertAuth(userName -&gt; exampleUser);
40         User user = clientCertAuth.authenticate("example.com", null, sslConnWithCert);
41         assertThat(user, is(exampleUser));
42     }
43     @Test
44     public void testLookupValidUserWithCertWithDifferentCN() throws Exception {
45         ClientCertAuth clientCertAuth = new ClientCertAuth(userName -&gt; User.of("arthur"));
46         expectedException.expectMessage("Common name \"example.com\" in client certificate doesn't match username \"arthur\"");
47         clientCertAuth.authenticate("arthur", null, sslConnWithCert);
48     }
49     @Test
50     public void testLookupUserWithMatchingCertThatDoesNotExist() throws Exception {
51         ClientCertAuth clientCertAuth = new ClientCertAuth(userName -&gt; null);
52         expectedException.expectMessage("Client certificate authentication failed for user \"example.com\"");
53         clientCertAuth.authenticate("example.com", null, sslConnWithCert);
54     }
55     @Test
56     public void testMissingClientCert() throws Exception {
57         SSLSession sslSession = mock(SSLSession.class);
58         when(sslSession.getPeerCertificates()).thenReturn(new Certificate[0]);
59         ConnectionProperties connectionProperties = new ConnectionProperties(
60             InetAddresses.forString("127.0.0.1"), Protocol.POSTGRES, sslSession);
61         ClientCertAuth clientCertAuth = new ClientCertAuth(userName -&gt; exampleUser);
62         expectedException.expectMessage("Client certificate authentication failed for user \"example.com\"");
63         clientCertAuth.authenticate("example.com", null, connectionProperties);
64     }
65     @Test
66     public void testHttpClientCertAuthFailsOnUserMissMatchWithCN() throws Exception {
67         ClientCertAuth clientCertAuth = new ClientCertAuth(userName -&gt; exampleUser);
68         ConnectionProperties conn = new ConnectionProperties(InetAddresses.forString("127.0.0.1"), Protocol.HTTP, sslSession);
69         expectedException.expectMessage("Common name \"example.com\" in client certificate doesn't match username \"arthur_is_wrong\"");
70         clientCertAuth.authenticate("arthur_is_wrong", null, conn);
71     }
72 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Netty4Transport.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.transport.netty4;
2 import io.crate.auth.AuthSettings;
3 import io.crate.auth.Authentication;
4 import io.crate.auth.Protocol;
5 import io.crate.common.SuppressForbidden;
6 import io.crate.common.collections.BorrowedItem;
7 import io.crate.netty.NettyBootstrap;
8 import io.crate.protocols.ssl.SslContextProvider;
9 import io.crate.protocols.ssl.SslSettings;
10 import io.crate.protocols.ssl.SslSettings.SSLMode;
11 import io.crate.types.DataTypes;
12 import io.netty.bootstrap.Bootstrap;
13 import io.netty.bootstrap.ServerBootstrap;
14 import io.netty.channel.AdaptiveRecvByteBufAllocator;
15 import io.netty.channel.Channel;
16 import io.netty.channel.ChannelFuture;
17 import io.netty.channel.ChannelHandler;
18 import io.netty.channel.ChannelHandlerAdapter;
19 import io.netty.channel.ChannelHandlerContext;
20 import io.netty.channel.ChannelInitializer;
21 import io.netty.channel.ChannelOption;
22 import io.netty.channel.EventLoopGroup;
23 import io.netty.channel.FixedRecvByteBufAllocator;
24 import io.netty.channel.RecvByteBufAllocator;
25 import io.netty.handler.logging.LogLevel;
26 import io.netty.handler.logging.LoggingHandler;
27 import io.netty.handler.ssl.SslContext;
28 import io.netty.handler.ssl.SslHandler;
29 import io.netty.util.AttributeKey;
30 import org.apache.logging.log4j.message.ParameterizedMessage;
31 import org.elasticsearch.ExceptionsHelper;
32 import org.elasticsearch.Version;
33 import org.elasticsearch.cluster.node.DiscoveryNode;
34 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
35 import org.elasticsearch.common.lease.Releasables;
36 <a name="0"></a>import org.elasticsearch.common.network.NetworkService;
37 import org.elasticsearch.common.settings.Setting;
38 import org.elasticsearch.common.settings.Setting.Property;
39 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.common.settings.Settings;
40 import org.elasticsearch.common.unit.ByteSizeUnit;
41 import org.elasticsearch.common.unit.ByteSizeValue;
42 import org.elasticsearch.common.util.PageCacheRecycler;
43 import org.elasticsearch.common.util.concurrent.EsExecutors;
44 import org.elasticsearch.indices.breaker.CircuitBreakerService;
45 import org.elasticsearch.threadpool.ThreadPool;
46 import org.elasticsearch.transport.TcpTransport;
47 import org.elasticsearch.transport.TransportSettings;
48 import java.io.IOException;
49 import java.net.InetSocketAddress;
50 import java.util.Map;
51 import static org.elasticsearch.common.settings.Setting.byteSizeSetting;
52 import static org.elasticsearch.common.settings.Setting.intSetting;
53 import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentMap;
54 public class Netty4Transport extends TcpTransport {
55     public static final Setting&lt;Integer&gt; WORKER_COUNT =</b></font>
56         new Setting&lt;&gt;("transport.netty.worker_count",
57             (s) -&gt; Integer.toString(EsExecutors.numberOfProcessors(s)),
58             (s) -&gt; Setting.parseInt(s, 1, "transport.netty.worker_count"), DataTypes.INTEGER, Property.NodeScope);
59     public static final Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_SIZE = Setting.byteSizeSetting(
60         "transport.netty.receive_predictor_size", new ByteSizeValue(64, ByteSizeUnit.KB), Property.NodeScope);
61     public static final Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_MIN =
62         byteSizeSetting("transport.netty.receive_predictor_min", NETTY_RECEIVE_PREDICTOR_SIZE, Property.NodeScope);
63     public static final Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_MAX =
64         byteSizeSetting("transport.netty.receive_predictor_max", NETTY_RECEIVE_PREDICTOR_SIZE, Property.NodeScope);
65     public static final Setting&lt;Integer&gt; NETTY_BOSS_COUNT =
66         intSetting("transport.netty.boss_count", 1, 1, Property.NodeScope);
67     private final RecvByteBufAllocator recvByteBufAllocator;
68     private final ByteSizeValue receivePredictorMin;
69     private final ByteSizeValue receivePredictorMax;
70     private volatile Bootstrap clientBootstrap;
71     private final Map&lt;String, ServerBootstrap&gt; serverBootstraps = newConcurrentMap();
72     private final NettyBootstrap nettyBootstrap;
73     private final SslContextProvider sslContextProvider;
74     private final Authentication authentication;
75     private BorrowedItem&lt;EventLoopGroup&gt; eventLoopGroup;
76     private final LoggingHandler loggingHandler = new LoggingHandler(LogLevel.TRACE);
77     public Netty4Transport(Settings settings,
78                            Version version,
79                            ThreadPool threadPool,
80                            NetworkService networkService,
81                            PageCacheRecycler pageCacheRecycler,
82                            NamedWriteableRegistry namedWriteableRegistry,
83                            CircuitBreakerService circuitBreakerService,
84                            NettyBootstrap nettyBootstrap,
85                            Authentication authentication,
86                            SslContextProvider sslContextProvider) {
87         super(settings, version, threadPool, pageCacheRecycler, circuitBreakerService, namedWriteableRegistry, networkService);
88         Netty4Utils.setAvailableProcessors(EsExecutors.PROCESSORS_SETTING.get(settings));
89         this.authentication = authentication;
90         this.nettyBootstrap = nettyBootstrap;
91         this.sslContextProvider = sslContextProvider;
92         this.receivePredictorMin = NETTY_RECEIVE_PREDICTOR_MIN.get(settings);
93         this.receivePredictorMax = NETTY_RECEIVE_PREDICTOR_MAX.get(settings);
94         if (receivePredictorMax.getBytes() == receivePredictorMin.getBytes()) {
95             recvByteBufAllocator = new FixedRecvByteBufAllocator((int) receivePredictorMax.getBytes());
96         } else {
97             recvByteBufAllocator = new AdaptiveRecvByteBufAllocator((int) receivePredictorMin.getBytes(),
98                 (int) receivePredictorMin.getBytes(), (int) receivePredictorMax.getBytes());
99         }
100     }
101     @Override
102     protected void doStart() {
103         boolean success = false;
104         try {
105             eventLoopGroup = nettyBootstrap.getSharedEventLoopGroup(settings);
106             clientBootstrap = createClientBootstrap(eventLoopGroup.item());
107             if (NetworkService.NETWORK_SERVER.get(settings)) {
108                 for (ProfileSettings profileSettings : profileSettings) {
109                     createServerBootstrap(profileSettings, eventLoopGroup.item());
110                     bindServer(profileSettings);
111                 }
112             }
113             super.doStart();
114             success = true;
115         } finally {
116             if (success == false) {
117                 doStop();
118             }
119         }
120     }
121     private Bootstrap createClientBootstrap(EventLoopGroup eventLoopGroup) {
122         final Bootstrap bootstrap = new Bootstrap();
123         bootstrap.group(eventLoopGroup);
124         bootstrap.channel(NettyBootstrap.clientChannel());
125         bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));
126         bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));
127         final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);
128         if (tcpSendBufferSize.getBytes() &gt; 0) {
129             bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));
130         }
131         final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);
132         if (tcpReceiveBufferSize.getBytes() &gt; 0) {
133             bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));
134         }
135         bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);
136         final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings);
137         bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);
138         return bootstrap;
139     }
140     private void createServerBootstrap(ProfileSettings profileSettings, EventLoopGroup eventLoopGroup) {
141         String name = profileSettings.profileName;
142         if (logger.isDebugEnabled()) {
143             logger.debug("using profile[{}], port[{}], bind_host[{}], publish_host[{}], "
144                     + "receive_predictor[{}-&gt;{}]",
145                 name, profileSettings.portOrRange, profileSettings.bindHosts, profileSettings.publishHosts,
146                 receivePredictorMin, receivePredictorMax);
147         }
148         final ServerBootstrap serverBootstrap = new ServerBootstrap();
149         serverBootstrap.group(eventLoopGroup);
150         serverBootstrap.channel(NettyBootstrap.serverChannel());
151         serverBootstrap.childHandler(new ServerChannelInitializer(name));
152         serverBootstrap.handler(new ServerChannelExceptionHandler());
153         serverBootstrap.childOption(ChannelOption.TCP_NODELAY, profileSettings.tcpNoDelay);
154         serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, profileSettings.tcpKeepAlive);
155         if (profileSettings.sendBufferSize.getBytes() != -1) {
156             serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(profileSettings.sendBufferSize.getBytes()));
157         }
158         if (profileSettings.receiveBufferSize.getBytes() != -1) {
159             serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(profileSettings.receiveBufferSize.bytesAsInt()));
160         }
161         serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);
162         serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);
163         serverBootstrap.option(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress);
164         serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress);
165         serverBootstrap.validate();
166         serverBootstraps.put(name, serverBootstrap);
167     }
168     static final AttributeKey&lt;Netty4TcpChannel&gt; CHANNEL_KEY = AttributeKey.newInstance("es-channel");
169     static final AttributeKey&lt;Netty4TcpServerChannel&gt; SERVER_CHANNEL_KEY = AttributeKey.newInstance("es-server-channel");
170     @Override
171     protected Netty4TcpChannel initiateChannel(DiscoveryNode node) throws IOException {
172         InetSocketAddress address = node.getAddress().address();
173         Bootstrap bootstrapWithHandler = clientBootstrap.clone();
174         bootstrapWithHandler.handler(new ClientChannelInitializer());
175         bootstrapWithHandler.remoteAddress(address);
176         ChannelFuture connectFuture = bootstrapWithHandler.connect();
177         Channel channel = connectFuture.channel();
178         if (channel == null) {
179             ExceptionsHelper.maybeDieOnAnotherThread(connectFuture.cause());
180             throw new IOException(connectFuture.cause());
181         }
182         addClosedExceptionLogger(channel);
183         Netty4TcpChannel nettyChannel = new Netty4TcpChannel(channel, false, "default", connectFuture);
184         channel.attr(CHANNEL_KEY).set(nettyChannel);
185         return nettyChannel;
186     }
187     @Override
188     protected Netty4TcpServerChannel bind(String name, InetSocketAddress address) {
189         Channel channel = serverBootstraps.get(name).bind(address).syncUninterruptibly().channel();
190         Netty4TcpServerChannel esChannel = new Netty4TcpServerChannel(channel, name);
191         channel.attr(SERVER_CHANNEL_KEY).set(esChannel);
192         return esChannel;
193     }
194     @Override
195     @SuppressForbidden(reason = "debug")
196     protected void stopInternal() {
197         Releasables.close(() -&gt; {
198             if (eventLoopGroup != null) {
199                 eventLoopGroup.close();
200                 eventLoopGroup = null;
201             }
202             serverBootstraps.clear();
203             clientBootstrap = null;
204         });
205     }
206     protected class ClientChannelInitializer extends ChannelInitializer&lt;Channel&gt; {
207         @Override
208         protected void initChannel(Channel ch) throws Exception {
209             maybeInjectSSL(ch);
210             ch.pipeline().addLast("logging", loggingHandler);
211             ch.pipeline().addLast("dispatcher", new Netty4MessageChannelHandler(pageCacheRecycler, Netty4Transport.this));
212         }
213         @Override
214         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
215             ExceptionsHelper.maybeDieOnAnotherThread(cause);
216             super.exceptionCaught(ctx, cause);
217         }
218         private void maybeInjectSSL(Channel ch) throws Exception, AssertionError {
219             SSLMode sslMode = SslSettings.SSL_TRANSPORT_MODE.get(settings);
220             if (sslMode == SSLMode.ON) {
221                 SslContext sslContext = sslContextProvider.clientContext();
222                 SslHandler sslHandler = sslContext.newHandler(ch.alloc());
223                 sslHandler.engine().setUseClientMode(true);
224                 ch.pipeline().addLast(sslHandler);
225             }
226         }
227     }
228     protected class ServerChannelInitializer extends ChannelInitializer&lt;Channel&gt; {
229         protected final String name;
230         protected ServerChannelInitializer(String name) {
231             this.name = name;
232         }
233         @Override
234         protected void initChannel(Channel ch) throws Exception {
235             SSLMode sslMode = SslSettings.SSL_TRANSPORT_MODE.get(settings);
236             if (sslMode == SSLMode.ON) {
237                 SslContext sslContext = sslContextProvider.getServerContext(Protocol.TRANSPORT);
238                 SslHandler sslHandler = sslContext.newHandler(ch.alloc());
239                 ch.pipeline().addLast(sslHandler);
240             }
241             if (AuthSettings.AUTH_HOST_BASED_ENABLED_SETTING.get(settings) &amp;&amp; sslMode != SSLMode.LEGACY) {
242                 ch.pipeline().addLast("hba", new HostBasedAuthHandler(authentication));
243             }
244             addClosedExceptionLogger(ch);
245             Netty4TcpChannel nettyTcpChannel = new Netty4TcpChannel(ch, true, name, ch.newSucceededFuture());
246             ch.attr(CHANNEL_KEY).set(nettyTcpChannel);
247             serverAcceptedChannel(nettyTcpChannel);
248             ch.pipeline().addLast("logging", loggingHandler);
249             ch.pipeline().addLast("dispatcher", new Netty4MessageChannelHandler(pageCacheRecycler, Netty4Transport.this));
250         }
251         @Override
252         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
253             ExceptionsHelper.maybeDieOnAnotherThread(cause);
254             super.exceptionCaught(ctx, cause);
255         }
256     }
257     private void addClosedExceptionLogger(Channel channel) {
258         channel.closeFuture().addListener(f -&gt; {
259             if (f.isSuccess() == false) {
260                 logger.debug(() -&gt; new ParameterizedMessage("exception while closing channel: {}", channel), f.cause());
261             }
262         });
263     }
264     @ChannelHandler.Sharable
265     private class ServerChannelExceptionHandler extends ChannelHandlerAdapter {
266         @Override
267         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
268             ExceptionsHelper.maybeDieOnAnotherThread(cause);
269             Netty4TcpServerChannel serverChannel = ctx.channel().attr(SERVER_CHANNEL_KEY).get();
270             if (cause instanceof Error) {
271                 onServerException(serverChannel, new Exception(cause));
272             } else {
273                 onServerException(serverChannel, (Exception) cause);
274             }
275         }
276     }
277 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
