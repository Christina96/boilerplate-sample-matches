<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for UpdateIntegrationTest.java &amp; InternalTestCluster.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for UpdateIntegrationTest.java &amp; InternalTestCluster.java
      </h3>
<h1 align="center">
        7.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>UpdateIntegrationTest.java (14.670897%)<th>InternalTestCluster.java (5.4588375%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-50)<td><a href="#" name="0">(129-165)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1006-1016)<td><a href="#" name="1">(337-342)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(587-598)<td><a href="#" name="2">(1062-1067)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1042-1046)<td><a href="#" name="3">(1228-1233)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(338-347)<td><a href="#" name="4">(1503-1504)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(97-106)<td><a href="#" name="5">(1904-1910)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(77-89)<td><a href="#" name="6">(439-443)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(54-65)<td><a href="#" name="7">(473-476)</a><td align="center"><font color="#790000">11</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(734-738)<td><a href="#" name="8">(1387-1389)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(66-73)<td><a href="#" name="9">(1084-1098)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1039-1042)<td><a href="#" name="10">(1068-1071)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1031-1037)<td><a href="#" name="11">(719-722)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1020-1022)<td><a href="#" name="12">(549-552)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(167-175)<td><a href="#" name="13">(1710-1711)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(154-158)<td><a href="#" name="14">(1005-1008)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(133-139)<td><a href="#" name="15">(1391-1396)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(114-121)<td><a href="#" name="16">(989-993)</a><td align="center"><font color="#630000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UpdateIntegrationTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.integrationtests;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.exceptions.VersioningValidationException;
4 import io.crate.testing.TestingHelpers;
5 import io.crate.testing.UseJdbc;
6 import io.crate.common.collections.MapBuilder;
7 import org.hamcrest.Matchers;
8 import org.hamcrest.core.IsNull;
9 import org.junit.Test;
10 import java.util.ArrayList;
11 import java.util.HashMap;
12 import java.util.Map;
13 import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
14 import static com.carrotsearch.randomizedtesting.RandomizedTest.$$;
15 import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;
16 import static io.crate.testing.Asserts.assertThrowsMatches;
17 import static io.crate.testing.SQLErrorMatcher.isSQLError;
18 import static io.crate.testing.TestingHelpers.mapToSortedString;
19 import static io.crate.testing.TestingHelpers.printedTable;
20 import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
21 import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;
22 import static org.hamcrest.core.Is.is;
23 import static org.hamcrest.core.IsNot.not;
24 public class UpdateIntegrationTest extends SQLIntegrationTestCase {
25     private Setup setup = new Setup(sqlExecutor)</b></font>;
26 <a name="7"></a>
27     @Test
28     public void testUpdate() throws Exception {
29         <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("create table test (message string) clustered into 2 shards");
30         execute("insert into test values('hello'),('again'),('hello'),('hello')");
31         assertEquals(4, response.rowCount());
32         refresh();
33         execute("update test set message='b' where message = 'hello'");
34         assertEquals(3, response.rowCount());
35         refresh();
36 <a name="9"></a>
37         execute("select message from test where message='b'");
38         assertEquals</b></font>(3, response.rowCount());
39         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("b", response.rows()[0][0]);
40     }
41     @Test
42     public void testUpdateByPrimaryKeyUnknownDocument() {
43         execute("create table test (id int primary key, message string)");
44         execute("update test set message='b' where id = 1");
45         assertEquals</b></font>(0, response.rowCount());
46 <a name="6"></a>    }
47     @Test
48     public void testUpdateNotNullColumn() <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
49         execute("create table test (id int primary key, message string not null)");
50         execute("insert into test (id, message) values(1, 'Ford'),(2, 'Arthur')");
51         assertEquals(2, response.rowCount());
52         refresh();
53         assertThrowsMatches(() -&gt; execute(
54             "update test set message=null where id=1"),
55                      isSQLError(Matchers.is("\"message\" must not be null"),
56                                 INTERNAL_ERROR,
57                                 BAD_REQUEST,
58                                 4000));
59     }</b></font>
60     @Test
61     public void testUpdateWithNotNull1LevelNestedColumn() {
62         execute("create table test (" +
63 <a name="5"></a>                "stuff object(dynamic) AS (" +
64                 "  level1 string not null" +
65                 ") not null)");
66         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("insert into test (stuff) values('{\"level1\":\"value\"}')");
67         assertEquals(1, response.rowCount());
68         refresh();
69         assertThrowsMatches(() -&gt; execute(
70             "update test set stuff['level1']=null"),
71                      isSQLError(Matchers.is("\"stuff['level1']\" must not be null"), INTERNAL_ERROR, BAD_REQUEST, 4000));
72     }
73     @Test</b></font>
74     public void testUpdateWithNotNull2LevelsNestedColumn() {
75         execute("create table test (" +
76                 "stuff object(dynamic) AS (" +
77                 "  level1 object(dynamic) AS (" +
78 <a name="16"></a>                "    level2 string not null" +
79                 "  ) not null" +
80                 ") not null)");
81         <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("insert into test (stuff) values('{\"level1\":{\"level2\":\"value\"}}')");
82         assertEquals(1, response.rowCount());
83         refresh();
84         assertThrowsMatches(() -&gt; execute(
85             "update test set stuff['level1']['level2']=null"),
86                      isSQLError(Matchers.is("\"stuff['level1']['level2']\" must not be null"), INTERNAL_ERROR, BAD_REQUEST, 4000));
87     }</b></font>
88     @Test
89     public void testUpdateNullDynamicColumn() {
90         execute("create table test (id int primary key) with (column_policy = 'dynamic')");
91 <a name="15"></a>        execute("insert into test (id) values (1)");
92         refresh();
93         <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("update test set dynamic_col=null");
94         refresh();
95         assertEquals(1, response.rowCount());
96     }
97     @Test
98     public void testUpdateWithExpression() throws Exception {</b></font>
99         execute("create table test (id integer, other_id long, name string)");
100         execute("insert into test (id, other_id, name) values(1, 10, 'Ford'),(2, 20, 'Arthur')");
101         assertEquals(2, response.rowCount());
102         refresh();
103         execute("update test set id=(id+10)*cast(other_id as integer)");
104         assertEquals(2, response.rowCount());
105         refresh();
106         execute("select id, other_id, name from test order by id");
107 <a name="14"></a>        assertEquals(2, response.rowCount());
108         assertEquals(110, response.rows()[0][0]);
109         assertEquals(10L, response.rows()[0][1]);
110         <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("Ford", response.rows()[0][2]);
111         assertEquals(240, response.rows()[1][0]);
112         assertEquals(20L, response.rows()[1][1]);
113         assertEquals("Arthur", response.rows()[1][2]);
114     }</b></font>
115     @Test
116     public void testUpdateWithExpressionReferenceUpdated() throws Exception {
117 <a name="13"></a>        execute("create table test (dividend integer, divisor integer, quotient integer)");
118         execute("insert into test (dividend, divisor, quotient) values(10, 2, 5)");
119         assertEquals(1, response.rowCount());
120         <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>refresh();
121         execute("update test set dividend = 30, quotient = dividend/divisor");
122         assertEquals(1, response.rowCount());
123         refresh();
124         execute("select quotient name from test");
125         assertEquals(5, response.rows()[0][0]);
126     }</b></font>
127     @Test
128     public void testUpdateByPrimaryKeyWithExpression() throws Exception {
129         execute("create table test (id integer primary key, other_id long)");
130         execute("insert into test (id, other_id) values(1, 10),(2, 20)");
131         assertEquals(2, response.rowCount());
132         refresh();
133         execute("update test set other_id=(id+10)*id where id = 2");
134         assertEquals(1, response.rowCount());
135         refresh();
136         execute("select other_id from test order by id");
137         assertEquals(2, response.rowCount());
138         assertEquals(10L, response.rows()[0][0]);
139         assertEquals(24L, response.rows()[1][0]);
140     }
141     @Test
142     public void testUpdateMultipleDocuments() throws Exception {
143         execute("create table test (message string)");
144         execute("insert into test values('hello'),('again'),('hello')");
145         assertEquals(3, response.rowCount());
146         refresh();
147         execute("update test set message='b' where message = 'hello'");
148         assertEquals(2, response.rowCount());
149         refresh();
150         execute("select message from test where message='b'");
151         assertEquals(2, response.rowCount());
152         assertEquals("b", response.rows()[0][0]);
153     }
154     @Test
155     public void testTwoColumnUpdate() throws Exception {
156         execute("create table test (col1 string, col2 string)");
157         execute("insert into test values('hello', 'hallo'), ('again', 'nochmal')");
158         assertEquals(2, response.rowCount());
159         refresh();
160         execute("update test set col1='b' where col1 = 'hello'");
161         assertEquals(1, response.rowCount());
162         refresh();
163         execute("select col1, col2 from test where col1='b'");
164         assertEquals(1, response.rowCount());
165         assertEquals("b", response.rows()[0][0]);
166         assertEquals("hallo", response.rows()[0][1]);
167     }
168     @Test
169     public void testUpdateWithArgs() throws Exception {
170         execute("create table test (" +
171                 "  coolness float, " +
172                 "  details array(object)" +
173                 ")");
174         execute("insert into test values(1.1, ?),(2.2, ?)", new Object[]{new Object[0],
175             new Object[]{
176                 new HashMap&lt;String, Object&gt;(),
177                 new HashMap&lt;String, Object&gt;() {{
178                     put("hello", "world");
179                 }}
180             }
181         });
182         assertEquals(2, response.rowCount());
183         refresh();
184         execute("update test set coolness=3.3, details=? where coolness = ?", new Object[]{new Object[0], 2.2});
185         assertEquals(1, response.rowCount());
186         refresh();
187         execute("select coolness from test where coolness=3.3");
188         assertEquals(1, response.rowCount());
189         assertEquals(3.3f, response.rows()[0][0]);
190     }
191     @Test
192     public void testUpdateNestedObjectWithoutDetailedSchema() throws Exception {
193         execute("create table test (coolness object)");
194         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
195         map.put("x", "1");
196         map.put("y", 2);
197         Object[] args = new Object[]{map};
198         execute("insert into test values (?)", args);
199         assertEquals(1, response.rowCount());
200         refresh();
201         execute("update test set coolness['x'] = '3'");
202         assertEquals(1, response.rowCount());
203         refresh();
204         waitForMappingUpdateOnAll("test", "coolness.x");
205         execute("select coolness['x'], coolness['y'] from test");
206         assertEquals(1, response.rowCount());
207         assertEquals("3", response.rows()[0][0]);
208         assertEquals(2L, response.rows()[0][1]);
209     }
210     @Test
211     public void testUpdateWithFunctionWhereArgumentIsInIntegerRangeInsteadOfLong() {
212         execute(
213             "create table t (" +
214             "   ts timestamp with time zone," +
215             "   day int" +
216             ") with (number_of_replicas = 0)");
217         execute("insert into t (ts, day) values (0, 1)");
218         execute("refresh table t");
219         execute("update t set day = extract(day from ts)");
220         assertThat(response.rowCount(), is(1L));
221     }
222     @Test
223     public void testInsertIntoWithOnConflictKeyWithFunctionWhereArgumentIsInIntegerRangeInsteadOfLong() {
224         execute(
225             "create table t (" +
226             "   id int primary key," +
227             "   ts timestamp with time zone, day int" +
228             ") with (number_of_replicas = 0)");
229         execute("insert into t (id, ts, day) values (1, 0, 0)");
230         execute("refresh table t");
231         execute("insert into t (id, ts, day) (select id, ts, day from t) " +
232                 "on conflict (id) do update set day = extract(day from ts)");
233         assertThat(response.rowCount(), is(1L));
234     }
235     @Test
236     public void testUpdateNestedNestedObject() throws Exception {
237         execute("create table test (" +
238                 "coolness object as (x object as (y object as (z int), a string, b string))," +
239                 "a object as (x string, y int)," +
240                 "firstcol int, othercol int" +
241                 ") with (number_of_replicas=0)");
242         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
243         map.put("x", "1");
244         map.put("y", 2);
245         Object[] args = new Object[]{map};
246         execute("insert into test (a) values (?)", args);
247         refresh();
248         execute("update test set coolness['x']['y']['z'] = 3");
249         assertEquals(1, response.rowCount());
250         refresh();
251         execute("select coolness['x'], a from test");
252         assertEquals(1, response.rowCount());
253 <a name="4"></a>        assertEquals("{y={z=3}}", response.rows()[0][0].toString());
254         assertEquals(map, response.rows()[0][1]);
255         <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("update test set firstcol = 1, coolness['x']['a'] = 'a', coolness['x']['b'] = 'b', othercol = 2");
256         assertEquals(1, response.rowCount());
257         refresh();
258         waitNoPendingTasksOnAll();
259         execute("select coolness['x']['b'], coolness['x']['a'], coolness['x']['y']['z'], " +
260                 "firstcol, othercol from test");
261         assertEquals(1, response.rowCount());
262         Object[] firstRow = response.rows()[0];
263         assertEquals</b></font>("b", firstRow[0]);
264         assertEquals("a", firstRow[1]);
265         assertEquals(3, firstRow[2]);
266         assertEquals(1, firstRow[3]);
267         assertEquals(2, firstRow[4]);
268     }
269     @Test
270     public void testUpdateNestedObjectDeleteWithArgs() throws Exception {
271         execute("create table test (a object as (x object as (y int, z int))) with (number_of_replicas=0)");
272         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
273         Map&lt;String, Object&gt; nestedMap = new HashMap&lt;&gt;();
274         nestedMap.put("y", 2);
275         nestedMap.put("z", 3);
276         map.put("x", nestedMap);
277         Object[] args = new Object[]{map};
278         execute("insert into test (a) values (?)", args);
279         assertEquals(1, response.rowCount());
280         refresh();
281         execute("update test set a['x']['z'] = ?", new Object[]{null});
282         assertEquals(1, response.rowCount());
283         refresh();
284         execute("select a['x']['y'], a['x']['z'] from test");
285         assertEquals(1, response.rowCount());
286         assertEquals(2, response.rows()[0][0]);
287         assertNull(response.rows()[0][1]);
288     }
289     @Test
290     public void testUpdateNestedObjectDeleteWithoutArgs() throws Exception {
291         execute("create table test (a object as (x object as (y int, z int))) with (number_of_replicas=0)");
292         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
293         Map&lt;String, Object&gt; nestedMap = new HashMap&lt;&gt;();
294         nestedMap.put("y", 2);
295         nestedMap.put("z", 3);
296         map.put("x", nestedMap);
297         Object[] args = new Object[]{map};
298         execute("insert into test (a) values (?)", args);
299         assertEquals(1, response.rowCount());
300         refresh();
301         execute("update test set a['x']['z'] = null");
302         assertEquals(1, response.rowCount());
303         refresh();
304         execute("select a['x']['z'], a['x']['y'] from test");
305         assertEquals(1, response.rowCount());
306         assertNull(response.rows()[0][0]);
307         assertEquals(2, response.rows()[0][1]);
308     }
309     @Test
310     public void testUpdateNestedObjectWithDetailedSchema() throws Exception {
311         execute("create table test (coolness object as (x string, y string))");
312         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
313         map.put("x", "1");
314         map.put("y", "2");
315         Object[] args = new Object[]{map};
316         execute("insert into test values (?)", args);
317         assertEquals(1, response.rowCount());
318         refresh();
319         execute("update test set coolness['x'] = '3'");
320         assertEquals(1, response.rowCount());
321         refresh();
322         execute("select coolness from test");
323         assertEquals(1, response.rowCount());
324         //noinspection unchecked
325         assertEquals("x=3, y=2", mapToSortedString((Map&lt;String, Object&gt;) response.rows()[0][0]));
326     }
327     @UseJdbc(0)
328     @Test
329     public void testUpdateResetNestedObject() throws Exception {
330         execute("create table test (coolness object)");
331         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
332         map.put("x", "1");
333         map.put("y", 2);
334         Object[] args = new Object[]{map};
335         execute("insert into test values (?)", args);
336         assertEquals(1, response.rowCount());
337         refresh();
338         Map&lt;String, Object&gt; new_map = new HashMap&lt;&gt;();
339         new_map.put("z", 1L);
340         execute("update test set coolness = ?", new Object[]{new_map});
341         assertEquals(1, response.rowCount());
342         refresh();
343         execute("select coolness from test");
344         assertEquals(1, response.rowCount());
345         assertEquals(new_map, response.rows()[0][0]);
346         Map&lt;String, Object&gt; empty_map = new HashMap&lt;&gt;();
347         execute("update test set coolness = ?", new Object[]{empty_map});
348         assertEquals(1, response.rowCount());
349         refresh();
350         execute("select coolness from test");
351         assertEquals(1, response.rowCount());
352         assertEquals(empty_map, response.rows()[0][0]);
353     }
354     @Test
355     public void testUpdateResetNestedObjectUsingUpdateRequest() throws Exception {
356         execute("create table test (id string, data object(ignored))");
357         Map&lt;String, Object&gt; data = new HashMap&lt;&gt;() {{
358             put("foo", "bar");
359             put("days", new ArrayList&lt;String&gt;() {{
360                 add("Mon");
361                 add("Tue");
362                 add("Wen");
363             }});
364         }};
365         execute("insert into test (id, data) values (?, ?)", new Object[]{"1", data});
366         refresh();
367         execute("select data from test where id = ?", new Object[]{"1"});
368         assertEquals(data, response.rows()[0][0]);
369         Map&lt;String, Object&gt; new_data = new HashMap&lt;String, Object&gt;() {{
370             put("days", new ArrayList&lt;String&gt;() {{
371                 add("Mon");
372                 add("Wen");
373             }});
374         }};
375         execute("update test set data = ? where id = ?", new Object[]{new_data, "1"});
376         assertEquals(1, response.rowCount());
377         refresh();
378         execute("select data from test where id = ?", new Object[]{"1"});
379         assertEquals(new_data, response.rows()[0][0]);
380     }
381     @UseJdbc(0)
382     @Test
383     public void testUpdateResetNestedNestedObject() throws Exception {
384         execute("create table test (coolness object)");
385         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;() {{
386             put("x", "1");
387             put("y", new HashMap&lt;String, Object&gt;() {{
388                 put("z", 3);
389             }});
390         }};
391         execute("insert into test values (?)", new Object[]{map});
392         assertEquals(1, response.rowCount());
393         refresh();
394         Map&lt;String, Object&gt; new_map = new HashMap&lt;&gt;();
395         new_map.put("a", 1L);
396         execute("update test set coolness['y'] = ?", new Object[]{new_map});
397         assertEquals(1, response.rowCount());
398         refresh();
399         waitForMappingUpdateOnAll("test", "coolness.x");
400         execute("select coolness['y'], coolness['x'] from test");
401         assertEquals(1, response.rowCount());
402         assertEquals(new_map, response.rows()[0][0]);
403         assertEquals("1", response.rows()[0][1]);
404     }
405     @Test
406     public void testUpdateToUpdateRequestByPlanner() throws Exception {
407         this.setup.createTestTableWithPrimaryKey();
408         execute("insert into test (pk_col, message) values ('123', 'bar')");
409         assertEquals(1, response.rowCount());
410         waitNoPendingTasksOnAll();         refresh();
411         execute("update test set message='bar1' where pk_col='123'");
412         assertEquals(1, response.rowCount());
413         refresh();
414         execute("select message from test where pk_col='123'");
415         assertEquals(1, response.rowCount());
416         assertEquals("bar1", response.rows()[0][0]);
417     }
418     @Test
419     public void testUpdateByIdWithMultiplePrimaryKeyAndClusteredBy() throws Exception {
420         execute("create table quotes (id integer primary key, author string primary key, " +
421                 "quote string) clustered by(author) with (number_of_replicas=0)");
422         execute("insert into quotes (id, author, quote) values(?, ?, ?)",
423             new Object[]{1, "Ford", "I'd far rather be happy than right any day."});
424         assertEquals(1L, response.rowCount());
425         execute("update quotes set quote=? where id=1 and author='Ford'",
426             new Object[]{"Don't panic"});
427         assertEquals(1L, response.rowCount());
428         refresh();
429         execute("select quote from quotes where id=1 and author='Ford'");
430         assertEquals(1L, response.rowCount());
431         assertThat((String) response.rows()[0][0], is("Don't panic"));
432     }
433     @Test
434     public void testUpdateByQueryWithMultiplePrimaryKeyAndClusteredBy() throws Exception {
435         execute("create table quotes (id integer primary key, author string primary key, " +
436                 "quote string) clustered by(author) with (number_of_replicas=0)");
437         execute("insert into quotes (id, author, quote) values(?, ?, ?)",
438             new Object[]{1, "Ford", "I'd far rather be happy than right any day."});
439         assertEquals(1L, response.rowCount());
440         refresh();
441         execute("update quotes set quote=? where id=1",
442             new Object[]{"Don't panic"});
443         assertEquals(1L, response.rowCount());
444         refresh();
445         execute("select quote from quotes where id=1 and author='Ford'");
446         assertEquals(1L, response.rowCount());
447         assertThat((String) response.rows()[0][0], is("Don't panic"));
448     }
449 <a name="2"></a>    @Test
450     public void testUpdateVersionHandling() throws Exception {
451         execute("create table test (id int primary key, c int) with (number_of_replicas=0, refresh_interval=0)");
452         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("insert into test (id, c) values (1, 1)");
453         execute("refresh table test");
454         execute("select _version, c from test");
455         long version = (Long) response.rows()[0][0];
456         assertThat(version, is(1L));
457         execute("update test set c = 2 where id = 1 and _version = 1");         assertThat(response.rowCount(), is(1L));
458         execute</b></font>("update test set c = 3 where id = 1 and _version = 1");         assertThat(response.rowCount(), is(0L));
459         execute("refresh table test");
460         execute("select _version, c from test");
461         assertThat((Long) response.rows()[0][0], is(2L));
462         assertThat((Integer) response.rows()[0][1], is(2));
463     }
464     @Test
465     public void testMultiUpdateWithSequenceConflict() {
466         execute("create table test (id int primary key, c int)");
467         execute("insert into test (id, c) values (1, 1), (2, 1)");
468         refresh();
469         execute("select id, _seq_no, _primary_term from test order by id");
470         long wrongSeqNoForSecondRow = (long) response.rows()[1][1] - 1;
471         execute(
472             "update test set c = 3 where (id = ? and _seq_no = ? and _primary_term = ?) or (id = ? and _seq_no = ? and _primary_term = ?)",
473             new Object[]{response.rows()[0][0], response.rows()[0][1], response.rows()[0][2],
474                 response.rows()[1][0], wrongSeqNoForSecondRow, response.rows()[1][2]});
475         assertThat(response.rowCount(), is(1L));
476     }
477     @Test
478     public void testMultiUpdateWithVersionAndConflict() throws Exception {
479         execute("create table test (id int primary key, c int)");
480         execute("insert into test (id, c) values (1, 1), (2, 1)");
481         refresh();
482         execute("update test set c = 2 where id = 2");
483         refresh();
484         execute("update test set c = 3 where (id = 1 and _version = 1) or (id = 2 and _version = 1)");
485         assertThat(response.rowCount(), is(1L));
486         refresh();
487         execute("select _version from test order by id");
488         assertThat((Long) response.rows()[0][0], is(2L));
489         assertThat((Long) response.rows()[1][0], is(2L));
490     }
491     @Test
492     public void testUpdateVersionOrOperator() throws Exception {
493         execute("create table test (id int primary key, c int) with (number_of_replicas=0, refresh_interval=0)");
494         execute("insert into test (id, c) values (1, 1)");
495         execute("refresh table test");
496         assertThrowsMatches(() -&gt; execute(
497             "update test set c = 4 where _version = 2 or _version=1"),
498                      isSQLError(Matchers.is(VersioningValidationException.VERSION_COLUMN_USAGE_MSG),
499                                 INTERNAL_ERROR,
500                                 BAD_REQUEST,
501                                 4000));
502     }
503     @Test
504     public void testUpdateVersionInOperator() throws Exception {
505         execute("create table test (id int primary key, c int) with (number_of_replicas=0, refresh_interval=0)");
506         ensureGreen();
507         execute("insert into test (id, c) values (1, 1)");
508         execute("refresh table test");
509         assertThrowsMatches(() -&gt; execute(
510             "update test set c = 4 where _version in (1,2)"),
511                      isSQLError(Matchers.is(VersioningValidationException.VERSION_COLUMN_USAGE_MSG),
512                                 INTERNAL_ERROR,
513                                 BAD_REQUEST,
514                                 4000));
515     }
516     @Test
517     public void testUpdateRetryOnVersionConflict() throws Exception {
518         execute("create table test (a string, b int) with (number_of_replicas=0)");
519         execute("insert into test (a, b) values ('foo', 1)");
520         assertThat(response.rowCount(), is(1L));
521         refresh();
522         long[] rowCounts = execute("update test set a = ? where b = ?",
523             new Object[][]{
524                 new Object[]{"bar", 1},
525                 new Object[]{"baz", 1},
526                 new Object[]{"foobar", 1}});
527         assertThat(rowCounts, is(new long[] { 1L, 1L, 1L }));
528         refresh();
529         execute("select _version from test where b = 1");
530         assertThat(response.rows()[0][0], is(4L));
531     }
532     @Test
533     public void testUpdateByIdPartitionColumnPartOfPrimaryKey() throws Exception {
534         execute("create table party (" +
535                 "  id int primary key, " +
536                 "  type byte primary key, " +
537                 "  value string" +
538                 ") partitioned by (type) with (number_of_replicas=0)");
539         execute("insert into party (id, type, value) values (?, ?, ?)", new Object[][]{
540             {1, 2, "foo"},
541             {2, 3, "bar"},
542             {2, 4, "baz"}
543         });
544         execute("refresh table party");
545         execute("update party set value='updated' where (id=1 and type=2) or (id=2 and type=4)");
546         assertThat(response.rowCount(), is(2L));
547         execute("refresh table party");
548         execute("select id, type, value from party order by id, value");
549         assertThat(TestingHelpers.printedTable(response.rows()), is(
550             "1| 2| updated\n" +
551             "2| 3| bar\n" +
552             "2| 4| updated\n"));
553     }
554     @Test
555     public void testBulkUpdateWithOnlyOneBulkArgIsProducingRowCountResult() throws Exception {
556         execute("create table t (name string) with (number_of_replicas = 0)");
557         long[] rowCounts  = execute("update t set name = 'Trillian' where name = ?", $$($("Arthur")));
558         assertThat(rowCounts.length, is(1));
559     }
560 <a name="8"></a>
561     @Test
562     public void testBulkUpdateWithPKAndMultipleHits() throws Exception {
563         <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>execute("create table t (id integer primary key, name string) with (number_of_replicas = 0)");
564         execute("insert into t values (?, ?)", $$($(1, "foo"), $(2, "bar"), $(3, "hoschi"), $(4, "crate")));
565         refresh();
566         long[] rowCounts = execute</b></font>("update t set name = 'updated' where id = ? or id = ?", $$($(1, 2), $(3, 4)));
567         assertThat(rowCounts, is(new long[] { 2L, 2L }));
568     }
569     @Test
570     public void testUpdateWithGeneratedColumn() {
571         execute("create table generated_column (" +
572                 " id int primary key," +
573                 " ts timestamp with time zone," +
574                 " day as date_trunc('day', ts)," +
575                 " \"user\" object as (name string)," +
576                 " name as concat(\"user\"['name'], 'bar')" +
577                 ") with (number_of_replicas=0)");
578         execute("insert into generated_column (id, ts, \"user\") values (?, ?, ?)", new Object[]{
579             1, "2015-11-18T11:11:00", MapBuilder.newMapBuilder().put("name", "foo").map()});
580         refresh();
581         execute("update generated_column set ts = ?, \"user\" = ? where id = ?", new Object[]{
582             "2015-11-19T17:06:00", MapBuilder.newMapBuilder().put("name", "zoo").map(), 1});
583         refresh();
584         execute("select day, name from generated_column");
585         assertThat((Long) response.rows()[0][0], is(1447891200000L));
586         assertThat((String) response.rows()[0][1], is("zoobar"));
587     }
588     @Test
589     public void testGeneratedColumnWithoutRefsToOtherColumnsComputedOnUpdate() {
590         execute("create table generated_column (" +
591                 " \"inserted\" TIMESTAMP WITH TIME ZONE GENERATED ALWAYS AS current_timestamp(3), " +
592                 " \"message\" STRING" +
593                 ")");
594         execute("insert into generated_column (message) values (?)", new Object[]{"str"});
595         refresh();
596         execute("select inserted from generated_column");
597         long ts = (long) response.rows()[0][0];
598         execute("update generated_column set message = ?", new Object[]{"test"});
599         refresh();
600         execute("select inserted from generated_column");
601         assertThat(response.rows()[0][0], not(ts));
602     }
603     @Test
604     public void testUpdateSetInvalidGeneratedColumnOnly() {
605         execute("create table computed (" +
606                 " ts timestamp with time zone," +
607                 " gen_col as extract(year from ts)" +
608                 ") with (number_of_replicas=0)");
609         execute("insert into computed (ts) values (1)");
610         refresh();
611         assertThrowsMatches(() -&gt; execute(
612             "update computed set gen_col=1745"),
613                      isSQLError(Matchers.is("Given value 1745 for generated column gen_col does not match calculation extract(YEAR FROM ts) = 1970"),
614                                 INTERNAL_ERROR,
615                                 BAD_REQUEST,
616                                 4000));
617     }
618     @Test
619     public void testUpdateNotNullSourceGeneratedColumn() {
620         execute("create table generated_column (" +
621                 " id int primary key," +
622                 " ts timestamp with time zone," +
623                 " gen_col as extract(year from ts) not null" +
624                 ") with (number_of_replicas=0)");
625         execute("insert into generated_column (id, ts) values (1, '2015-11-18T11:11:00')");
626         assertEquals(1, response.rowCount());
627         refresh();
628         assertThrowsMatches(() -&gt; execute(
629             "update generated_column set ts=null where id=1"),
630                      isSQLError(Matchers.is("\"gen_col\" must not be null"), INTERNAL_ERROR, INTERNAL_SERVER_ERROR, 5000));
631     }
632     @Test
633     public void testUpdateNotNullTargetGeneratedColumn() {
634         execute("create table generated_column (" +
635                 " id int primary key," +
636                 " ts timestamp with time zone," +
637                 " gen_col as extract(year from ts) not null" +
638                 ") with (number_of_replicas=0)");
639         execute("insert into generated_column (id, ts) values (1, '2015-11-18T11:11:00')");
640         assertEquals(1, response.rowCount());
641         refresh();
642         assertThrowsMatches(() -&gt; execute(
643             "update generated_column set gen_col=null where id=1"),
644                      isSQLError(Matchers.is("\"gen_col\" must not be null"),
645                                 INTERNAL_ERROR,
646                                 BAD_REQUEST,
647                                 4000));
648     }
649     @Test
650     public void testUpdateWithGeneratedColumnSomeReferencesUpdated() throws Exception {
651         execute("create table computed (" +
652                 " firstname string," +
653                 " surname string," +
654                 " name as concat(surname, ', ', firstname)" +
655                 ") with (number_of_replicas=0)");
656         execute("insert into computed (firstname, surname) values ('Douglas', 'Adams')");
657         refresh();
658         execute("update computed set firstname = 'Ford'");
659         refresh();
660         execute("select name from computed");
661         assertThat((String) response.rows()[0][0], is("Adams, Ford"));
662     }
663     @Test
664     public void testUpdateExpressionReferenceGeneratedColumn() throws Exception {
665         execute("create table computed (" +
666                 " a int," +
667                 " b int," +
668                 " c as (b + 1)" +
669                 ") with (number_of_replicas=0)");
670         execute("insert into computed (a, b) values (1, 2)");
671         refresh();
672         execute("update computed set a = c + 1");
673         refresh();
674         execute("select a from computed");
675         assertThat((Integer) response.rows()[0][0], is(4));
676     }
677     @Test
678     public void testUpdateReferencedByGeneratedColumnWithExpressionReferenceGeneratedColumn() throws Exception {
679         execute("create table computed (" +
680                 " a int," +
681                 " b as (a + 1)" +
682                 ") with (number_of_replicas=0)");
683         execute("insert into computed (a) values (1)");
684         refresh();
685         execute("update computed set a = b + 1");
686         refresh();
687         execute("select a from computed");
688         assertThat((Integer) response.rows()[0][0], is(3));
689     }
690     @Test
691     public void testFailingUpdateBulkOperation() throws Exception {
692         execute("create table t (x string) clustered into 1 shards with (number_of_replicas = 0)");
693         execute("insert into t (x) values ('1')");
694         execute("refresh table t");
695         Object[][] bulkArgs = new Object[][] {
696             new Object[] { 1, "+123" },
697             new Object[] { 2, "+123" },
698         };
699         long[] rowCounts = execute("update t set x = ? where x ~* ?", bulkArgs);
700         assertThat(rowCounts, is(new long[] { -2L, -2L }));
701     }
702     @Test
703     public void testUpdateByQueryWithSubQuery() throws Exception {
704         execute("create table t1 (x int)");
705         execute("insert into t1 (x) values (1), (2)");
706         execute("refresh table t1");
707         execute("update t1 set x = (select 3) where x = (select 1)");
708         assertThat(response.rowCount(), is(1L));
709         execute("refresh table t1");
710         execute("select x from t1 order by x asc");
711         assertThat(printedTable(response.rows()), is("2\n" +
712                                                      "3\n"));
713     }
714     @Test
715     public void testUpdateByIdWithSubQuery() throws Exception {
716         execute("create table t1 (id int primary key, name string)");
717         execute("insert into t1 (id, name) values (1, 'Arthur'), (2, 'Trillian')");
718         execute("refresh table t1");
719         execute("update t1 set name = (select 'Slartibartfast') where id = (select 1)");
720         assertThat(response.rowCount(), is(1L));
721         execute("refresh table t1");
722         execute("select id, name from t1 order by id asc");
723         assertThat(printedTable(response.rows()), is("1| Slartibartfast\n" +
724                                                      "2| Trillian\n"));
725     }
726     @Test
727     public void test_update_by_id_returning_id() throws Exception {
728         execute("create table test (id int primary key, message string) clustered into 2 shards");
729         execute("insert into test values(1, 'msg');");
730         assertEquals(1, response.rowCount());
731         refresh();
732         execute("update test set message='msg' where id = 1 returning id");
733         assertThat((response.cols()[0]), is("id" ));
734         assertThat(printedTable(response.rows()), is("1\n" ));
735     }
736     @Test
737     public void test_update_by_id_returning_id_with_outputname() throws Exception {
738         execute("create table test (id int primary key, message string) clustered into 2 shards");
739         execute("insert into test values(1, 'msg');");
740         assertEquals(1, response.rowCount());
741         refresh();
742         execute("update test set message='msg' where id = 1 returning id as renamed");
743         assertThat((response.cols()[0]), is("renamed" ));
744         assertThat(printedTable(response.rows()), is("1\n" ));
745     }
746     @Test
747     public void test_update_by_id_with_subquery_returning_id() throws Exception {
748         execute("create table test (id int primary key, message string) clustered into 2 shards");
749         execute("insert into test values(1, 'msg');");
750         assertEquals(1, response.rowCount());
751         refresh();
752         execute("update test set message='updated' where id = (select 1) returning id");
753         assertThat(printedTable(response.rows()), is("1\n" ));
754     }
755     @Test
756     public void test_update_by_id_where_no_row_is_matching() throws Exception {
757         execute("create table test (id int primary key, message string) clustered into 2 shards");
758         execute("insert into test values(1, 'msg');");
759         assertEquals(1, response.rowCount());
760         refresh();
761         execute("update test set message='updated' where id = 99 returning id");
762         assertThat(response.cols()[0], is("id"));
763         assertThat(response.rowCount(), is(0L));
764     }
765     @Test
766     public void test_update_by_query_returning_single_field_with_outputputname() throws Exception {
767         execute("create table test (id int primary key, message string) clustered into 2 shards");
768         execute("insert into test values(1, 'msg');");
769         assertEquals(1, response.rowCount());
770         refresh();
771         execute("update test set message='updated' where message='msg' returning message as message_renamed");
772         assertThat((response.rowCount()), is(1L));
773         assertThat((response.cols()[0]), is("message_renamed"));
774         assertThat(response.rows()[0][0], is("updated"));
775     }
776     @Test
777     public void test_update_by_query_with_subquery_returning_multiple_fields() throws Exception {
778         execute("create table test (id int primary key, message string) clustered into 2 shards");
779         execute("insert into test values(1, 'msg');");
780         assertEquals(1, response.rowCount());
781         refresh();
782         execute("update test set message='updated' where message= (select 'msg') returning id, message");
783         assertThat((response.rowCount()), is(1L));
784         assertThat((response.cols()[0]), is("id"));
785         assertThat((response.cols()[1]), is("message"));
786         assertThat(response.rows()[0][0], is(1));
787         assertThat(response.rows()[0][1], is("updated"));
788     }
789     @Test
790 <a name="1"></a>    public void test_update_by_query_returning_multiple_results() throws Exception {
791         execute("create table test (id int primary key, x int, message string) clustered into 2 shards");
792         execute("insert into test values(1, 1, 'msg') returning _seq_no;");
793         long fstSeqNo = (long) <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>response.rows()[0][0];
794         execute("insert into test values(2, 1, 'msg') returning _seq_no;");
795         long sndSeqNo = (long) response.rows()[0][0];
796         assertEquals(1, response.rowCount());
797         refresh();
798         execute("update test set message='updated' where message='msg' and x &gt; 0 " +
799                 "returning id, _seq_no as seq, message as message_renamed");
800         assertThat((response.rowCount()), is(2L));
801         assertThat</b></font>((response.cols()[0]), is("id"));
802 <a name="12"></a>        assertThat((response.cols()[1]), is("seq"));
803         assertThat((response.cols()[2]), is("message_renamed"));
804         <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int fstRowIndex = response.rows()[0][0].equals(1) ? 0 : 1;
805         assertThat((long) response.rows()[fstRowIndex][1], Matchers.greaterThan(fstSeqNo));
806         assertThat(response.rows</b></font>()[fstRowIndex][2], is("updated"));
807         int sndRowIndex = fstRowIndex == 0 ? 1 : 0;
808         assertThat((long) response.rows()[sndRowIndex][1], Matchers.greaterThan(sndSeqNo));
809         assertThat(response.rows()[sndRowIndex][2], is("updated"));
810 <a name="11"></a>    }
811     @Test
812     public void test_update_sys_tables_returning_values_with_expressions_and_outputnames() throws Exception <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
813         execute("update sys.node_checks set acknowledged = true where id = 1 " +
814                 "returning id, UPPER(description) as description, acknowledged as ack");
815         long numberOfNodes = this.clusterService().state().getNodes().getSize();
816 <a name="10"></a>
817         assertThat((response.rowCount</b></font>()), is(numberOfNodes));
818         assertThat((response.cols()[0]), is("id"));
819 <a name="3"></a>        assertThat((response.cols()[1]), <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>is("description"));
820         assertThat((response.cols()[2]), is("ack"));
821         for (int i = 0; i &lt; numberOfNodes; i++) {
822             assertThat(response.rows</b></font>()[i][0], <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>is(1));
823             assertThat(response.rows()[i][1], is(IsNull.notNullValue()));
824             assertThat(response.rows()[i][2], is(true));
825         }
826     }</b></font>
827 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>InternalTestCluster.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.test;
2 import static io.crate.common.unit.TimeValue.timeValueSeconds;
3 import static org.apache.lucene.util.LuceneTestCase.TEST_NIGHTLY;
4 import static org.apache.lucene.util.LuceneTestCase.rarely;
5 import static org.elasticsearch.cluster.coordination.ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING;
6 import static org.elasticsearch.discovery.DiscoveryModule.DISCOVERY_TYPE_SETTING;
7 import static org.elasticsearch.discovery.DiscoveryModule.ZEN2_DISCOVERY_TYPE;
8 import static org.elasticsearch.node.Node.INITIAL_STATE_TIMEOUT_SETTING;
9 import static org.elasticsearch.discovery.FileBasedSeedHostsProvider.UNICAST_HOSTS_FILE;
10 import static org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING;
11 import static org.elasticsearch.test.ESTestCase.assertBusy;
12 import static org.elasticsearch.test.ESTestCase.randomFrom;
13 import static org.hamcrest.Matchers.equalTo;
14 import static org.hamcrest.Matchers.greaterThan;
15 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
16 import static org.hamcrest.Matchers.not;
17 import static org.hamcrest.Matchers.nullValue;
18 import static org.junit.Assert.assertThat;
19 import static org.junit.Assert.assertTrue;
20 import static org.junit.Assert.fail;
21 import java.io.Closeable;
22 import java.io.IOException;
23 import java.net.InetSocketAddress;
24 import java.nio.file.Files;
25 import java.nio.file.Path;
26 import java.util.ArrayList;
27 import java.util.Arrays;
28 import java.util.Collection;
29 import java.util.Collections;
30 import java.util.HashMap;
31 import java.util.HashSet;
32 import java.util.Iterator;
33 import java.util.List;
34 import java.util.Map;
35 import java.util.NavigableMap;
36 import java.util.Objects;
37 import java.util.Random;
38 import java.util.Set;
39 import java.util.TreeMap;
40 import java.util.concurrent.ExecutionException;
41 import java.util.concurrent.ExecutorService;
42 import java.util.concurrent.Future;
43 import java.util.concurrent.TimeUnit;
44 import java.util.concurrent.atomic.AtomicBoolean;
45 import java.util.concurrent.atomic.AtomicInteger;
46 import java.util.function.Predicate;
47 import java.util.stream.Collectors;
48 import java.util.stream.IntStream;
49 import java.util.stream.Stream;
50 import javax.annotation.Nullable;
51 import com.carrotsearch.hppc.ObjectLongMap;
52 import com.carrotsearch.hppc.cursors.IntObjectCursor;
53 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
54 import com.carrotsearch.randomizedtesting.RandomizedTest;
55 import com.carrotsearch.randomizedtesting.SeedUtils;
56 import com.carrotsearch.randomizedtesting.generators.RandomNumbers;
57 import com.carrotsearch.randomizedtesting.generators.RandomPicks;
58 import com.carrotsearch.randomizedtesting.generators.RandomStrings;
59 import org.apache.logging.log4j.LogManager;
60 import org.apache.logging.log4j.Logger;
61 import org.apache.lucene.store.AlreadyClosedException;
62 import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;
63 import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsRequest;
64 import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;
65 import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;
66 import org.elasticsearch.client.Client;
67 import org.elasticsearch.cluster.ClusterName;
68 import org.elasticsearch.cluster.ClusterState;
69 import org.elasticsearch.cluster.action.index.MappingUpdatedAction;
70 import org.elasticsearch.cluster.coordination.ClusterBootstrapService;
71 import org.elasticsearch.cluster.metadata.IndexMetadata;
72 import org.elasticsearch.cluster.node.DiscoveryNode;
73 import org.elasticsearch.cluster.node.DiscoveryNodeRole;
74 import org.elasticsearch.cluster.node.DiscoveryNodes;
75 import org.elasticsearch.cluster.routing.IndexRoutingTable;
76 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
77 import org.elasticsearch.cluster.routing.OperationRouting;
78 import org.elasticsearch.cluster.routing.ShardRouting;
79 import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;
80 import org.elasticsearch.cluster.routing.allocation.decider.ThrottlingAllocationDecider;
81 import org.elasticsearch.cluster.service.ClusterService;
82 import org.elasticsearch.common.Randomness;
83 import org.elasticsearch.common.Strings;
84 import org.elasticsearch.common.breaker.CircuitBreaker;
85 import org.elasticsearch.common.component.LifecycleListener;
86 import org.elasticsearch.common.io.FileSystemUtils;
87 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
88 import org.elasticsearch.common.lease.Releasables;
89 import org.elasticsearch.common.settings.Settings;
90 import org.elasticsearch.common.settings.Settings.Builder;
91 import org.elasticsearch.common.unit.ByteSizeUnit;
92 import org.elasticsearch.common.unit.ByteSizeValue;
93 import org.elasticsearch.common.util.PageCacheRecycler;
94 import org.elasticsearch.common.util.concurrent.EsExecutors;
95 import org.elasticsearch.common.util.concurrent.FutureUtils;
96 import org.elasticsearch.env.Environment;
97 import org.elasticsearch.env.NodeEnvironment;
98 import org.elasticsearch.env.ShardLockObtainFailedException;
99 import org.elasticsearch.http.HttpServerTransport;
100 import org.elasticsearch.index.Index;
101 import org.elasticsearch.index.IndexService;
102 <a name="0"></a>import org.elasticsearch.index.engine.CommitStats;
103 import org.elasticsearch.index.engine.DocIdSeqNoAndSource;
104 import org.elasticsearch.index.engine.Engine;
105 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.index.engine.InternalEngine;
106 import org.elasticsearch.index.seqno.SeqNoStats;
107 import org.elasticsearch.index.seqno.SequenceNumbers;
108 import org.elasticsearch.index.shard.IndexShard;
109 import org.elasticsearch.index.shard.IndexShardTestCase;
110 import org.elasticsearch.index.shard.ShardId;
111 import org.elasticsearch.indices.IndicesService;
112 import org.elasticsearch.indices.breaker.CircuitBreakerService;
113 import org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService;
114 import org.elasticsearch.indices.recovery.RecoverySettings;
115 import org.elasticsearch.node.MockNode;
116 import org.elasticsearch.node.Node;
117 import org.elasticsearch.node.NodeValidationException;
118 import org.elasticsearch.plugins.Plugin;
119 import org.elasticsearch.test.disruption.ServiceDisruptionScheme;
120 import org.elasticsearch.test.transport.MockTransportService;
121 import org.elasticsearch.transport.TransportService;
122 import org.elasticsearch.transport.TransportSettings;
123 import io.crate.common.io.IOUtils;
124 import io.crate.common.unit.TimeValue;
125 import static org.junit.Assert.assertEquals;
126 public final class InternalTestCluster extends TestCluster {
127     private final Logger logger = LogManager.getLogger(getClass())</b></font>;
128     private static final Predicate&lt;NodeAndClient&gt; DATA_NODE_PREDICATE =
129         nodeAndClient -&gt; DiscoveryNode.isDataNode(nodeAndClient.node.settings());
130     private static final Predicate&lt;NodeAndClient&gt; NO_DATA_NO_MASTER_PREDICATE = nodeAndClient -&gt;
131         DiscoveryNode.isMasterEligibleNode(nodeAndClient.node.settings()) == false
132             &amp;&amp; DiscoveryNode.isDataNode(nodeAndClient.node.settings()) == false;
133     private static final Predicate&lt;NodeAndClient&gt; MASTER_NODE_PREDICATE =
134         nodeAndClient -&gt; DiscoveryNode.isMasterEligibleNode(nodeAndClient.node.settings());
135     public static final int DEFAULT_LOW_NUM_MASTER_NODES = 1;
136     public static final int DEFAULT_HIGH_NUM_MASTER_NODES = 3;
137     static final int DEFAULT_MIN_NUM_DATA_NODES = 1;
138     static final int DEFAULT_MAX_NUM_DATA_NODES = TEST_NIGHTLY ? 6 : 3;
139     static final int DEFAULT_NUM_CLIENT_NODES = -1;
140     static final int DEFAULT_MIN_NUM_CLIENT_NODES = 0;
141     static final int DEFAULT_MAX_NUM_CLIENT_NODES = 1;
142     private volatile NavigableMap&lt;String, NodeAndClient&gt; nodes = Collections.emptyNavigableMap();
143     private final Set&lt;Path&gt; dataDirToClean = new HashSet&lt;&gt;();
144     private final String clusterName;
145     private final AtomicBoolean open = new AtomicBoolean(true);
146     private final Settings defaultSettings;
147     private final AtomicInteger nextNodeId = new AtomicInteger(0);
148     private final long[] sharedNodesSeeds;
149     private final int numSharedDedicatedMasterNodes;
150     private final int numSharedDataNodes;
151     private final int numSharedCoordOnlyNodes;
152     private final NodeConfigurationSource nodeConfigurationSource;
153     private final ExecutorService executor;
154     private final boolean autoManageMasterNodes;
155     private final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins;
156     private final boolean forbidPrivateIndexSettings;
157     private final int numDataPaths;
158     private final String nodePrefix;
159     private final Path baseDir;
160     private ServiceDisruptionScheme activeDisruptionScheme;
161     private int bootstrapMasterNodeIndex = -1;
162     public InternalTestCluster(
163             final long clusterSeed,
164             final Path baseDir,
165             final boolean randomlyAddDedicatedMasters,
166             final boolean autoManageMasterNodes,
167             final int minNumDataNodes,
168             final int maxNumDataNodes,
169             final String clusterName,
170             final NodeConfigurationSource nodeConfigurationSource,
171             final int numClientNodes,
172             final String nodePrefix,
173             final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins) {
174         this(
175                 clusterSeed,
176                 baseDir,
177                 randomlyAddDedicatedMasters,
178                 autoManageMasterNodes,
179                 minNumDataNodes,
180                 maxNumDataNodes,
181                 clusterName,
182                 nodeConfigurationSource,
183                 numClientNodes,
184                 nodePrefix,
185                 mockPlugins,
186                 true);
187     }
188     public InternalTestCluster(
189             final long clusterSeed,
190             final Path baseDir,
191             final boolean randomlyAddDedicatedMasters,
192             final boolean autoManageMasterNodes,
193             final int minNumDataNodes,
194             final int maxNumDataNodes,
195             final String clusterName,
196             final NodeConfigurationSource nodeConfigurationSource,
197             final int numClientNodes,
198             final String nodePrefix,
199             final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins,
200             final boolean forbidPrivateIndexSettings) {
201         super(clusterSeed);
202         this.autoManageMasterNodes = autoManageMasterNodes;
203         this.forbidPrivateIndexSettings = forbidPrivateIndexSettings;
204         this.baseDir = baseDir;
205         this.clusterName = clusterName;
206         if (minNumDataNodes &lt; 0 || maxNumDataNodes &lt; 0) {
207             throw new IllegalArgumentException("minimum and maximum number of data nodes must be &gt;= 0");
208         }
209         if (maxNumDataNodes &lt; minNumDataNodes) {
210             throw new IllegalArgumentException("maximum number of data nodes must be &gt;= minimum number of  data nodes");
211         }
212         Random random = new Random(clusterSeed);
213         boolean useDedicatedMasterNodes = randomlyAddDedicatedMasters &amp;&amp; random.nextBoolean();
214         this.numSharedDataNodes = RandomNumbers.randomIntBetween(random, minNumDataNodes, maxNumDataNodes);
215         assert this.numSharedDataNodes &gt;= 0;
216         if (numSharedDataNodes == 0) {
217             this.numSharedCoordOnlyNodes = 0;
218             this.numSharedDedicatedMasterNodes = 0;
219         } else {
220             if (useDedicatedMasterNodes) {
221                 if (random.nextBoolean()) {
222                     this.numSharedDedicatedMasterNodes = DEFAULT_LOW_NUM_MASTER_NODES;
223                 } else {
224                     this.numSharedDedicatedMasterNodes = DEFAULT_HIGH_NUM_MASTER_NODES;
225                 }
226             } else {
227                 this.numSharedDedicatedMasterNodes = 0;
228             }
229             if (numClientNodes &lt; 0) {
230                 this.numSharedCoordOnlyNodes =  RandomNumbers.randomIntBetween(random,
231                         DEFAULT_MIN_NUM_CLIENT_NODES, DEFAULT_MAX_NUM_CLIENT_NODES);
232             } else {
233                 this.numSharedCoordOnlyNodes = numClientNodes;
234             }
235         }
236         assert this.numSharedCoordOnlyNodes &gt;= 0;
237         this.nodePrefix = nodePrefix;
238         assert nodePrefix != null;
239         this.mockPlugins = mockPlugins;
240         sharedNodesSeeds = new long[numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes];
241         for (int i = 0; i &lt; sharedNodesSeeds.length; i++) {
242             sharedNodesSeeds[i] = random.nextLong();
243         }
244         logger.info("Setup InternalTestCluster [{}] with seed [{}] using [{}] dedicated masters, " +
245                 "[{}] (data) nodes and [{}] coord only nodes (master nodes are [{}])",
246             clusterName, SeedUtils.formatSeed(clusterSeed),
247 <a name="1"></a>            numSharedDedicatedMasterNodes, numSharedDataNodes, numSharedCoordOnlyNodes,
248             autoManageMasterNodes ? "auto-managed" : "manual");
249         this.nodeConfigurationSource = nodeConfigurationSource;
250         numDataPaths = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>random.nextInt(5) == 0 ? 2 + random.nextInt(3) : 1;
251         Builder builder = Settings.builder();
252         builder.put(Environment.PATH_HOME_SETTING.getKey(), baseDir);
253         builder.put(Environment.PATH_REPO_SETTING.getKey(), baseDir.resolve("repos"));
254         builder.put(TransportSettings.PORT.getKey(), 0);
255         builder.put</b></font>("http.port", 0);
256         if (Strings.hasLength(System.getProperty("tests.es.logger.level"))) {
257             builder.put("logger.level", System.getProperty("tests.es.logger.level"));
258         }
259         if (Strings.hasLength(System.getProperty("es.logger.prefix"))) {
260             builder.put("logger.prefix", System.getProperty("es.logger.prefix"));
261         }
262         builder.put(TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(), "100%");
263         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), "1b");
264         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), "1b");
265         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), "1b");
266         if (TEST_NIGHTLY) {
267             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(),
268                     RandomNumbers.randomIntBetween(random, 5, 10));
269             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(),
270                     RandomNumbers.randomIntBetween(random, 5, 10));
271         } else if (random.nextInt(100) &lt;= 90) {
272             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(),
273                     RandomNumbers.randomIntBetween(random, 2, 5));
274             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(),
275                     RandomNumbers.randomIntBetween(random, 2, 5));
276         }
277         builder.put(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC_SETTING.getKey(), TimeValue.timeValueMillis(
278                 RandomNumbers.randomIntBetween(random, 20, 50)));
279         builder.put(RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING.getKey(),
280                     RandomNumbers.randomIntBetween(random, 1, 5));
281         defaultSettings = builder.build();
282         executor = EsExecutors.newScaling(
283             "internal_test_cluster_executor",
284             0,
285             Integer.MAX_VALUE,
286             0,
287             TimeUnit.SECONDS,
288             EsExecutors.daemonThreadFactory("test_" + clusterName));
289     }
290     public void setBootstrapMasterNodeIndex(int bootstrapMasterNodeIndex) {
291         assert autoManageMasterNodes == false || bootstrapMasterNodeIndex == -1
292             : "bootstrapMasterNodeIndex should be -1 if autoManageMasterNodes is true, but was " + bootstrapMasterNodeIndex;
293         this.bootstrapMasterNodeIndex = bootstrapMasterNodeIndex;
294     }
295     @Override
296     public String getClusterName() {
297         return clusterName;
298     }
299     public String[] getNodeNames() {
300         return nodes.keySet().toArray(Strings.EMPTY_ARRAY);
301     }
302     private Settings getSettings(int nodeOrdinal, long nodeSeed, Settings others) {
303         Builder builder = Settings.builder().put(defaultSettings)
304             .put(getRandomNodeSettings(nodeSeed));
305         Settings settings = nodeConfigurationSource.nodeSettings(nodeOrdinal);
306         if (settings != null) {
307             if (settings.get(ClusterName.CLUSTER_NAME_SETTING.getKey()) != null) {
308                 throw new IllegalStateException("Tests must not set a '" + ClusterName.CLUSTER_NAME_SETTING.getKey()
309                         + "' as a node setting set '" + ClusterName.CLUSTER_NAME_SETTING.getKey() + "': ["
310                         + settings.get(ClusterName.CLUSTER_NAME_SETTING.getKey()) + "]");
311             }
312             builder.put(settings);
313         }
314         if (others != null) {
315             builder.put(others);
316         }
317         builder.put(ClusterName.CLUSTER_NAME_SETTING.getKey(), clusterName);
318         return builder.build();
319     }
320     public Collection&lt;Class&lt;? extends Plugin&gt;&gt; getPlugins() {
321         Set&lt;Class&lt;? extends Plugin&gt;&gt; plugins = new HashSet&lt;&gt;(nodeConfigurationSource.nodePlugins());
322         plugins.addAll(mockPlugins);
323         return plugins;
324     }
325     private static Settings getRandomNodeSettings(long seed) {
326         Random random = new Random(seed);
327         Builder builder = Settings.builder();
328         builder.put(TransportSettings.TRANSPORT_COMPRESS.getKey(), rarely(random));
329         if (random.nextBoolean()) {
330             builder.put("cache.recycler.page.type", RandomPicks.randomFrom(random, PageCacheRecycler.Type.values()));
331         }
332 <a name="6"></a>        builder.put(EsExecutors.PROCESSORS_SETTING.getKey(), 1 + random.nextInt(3));
333         if (random.nextBoolean()) <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
334             builder.put(TransportSettings.CONNECTIONS_PER_NODE_RECOVERY.getKey(), random.nextInt(2) + 1);
335             builder.put(TransportSettings.CONNECTIONS_PER_NODE_BULK.getKey(), random.nextInt(3) + 1);
336             builder.put(TransportSettings.CONNECTIONS_PER_NODE_REG.getKey(), random.nextInt(6) + 1);
337         }</b></font>
338         if (random.nextBoolean()) {
339             builder.put(MappingUpdatedAction.INDICES_MAPPING_DYNAMIC_TIMEOUT_SETTING.getKey(),
340                     timeValueSeconds(RandomNumbers.randomIntBetween(random, 10, 30)).getStringRep());
341         }
342         if (random.nextInt(10) == 0) {
343             builder.put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_TYPE_SETTING.getKey(), "noop");
344         }
345         if (random.nextBoolean()) {
346             if (random.nextInt(10) == 0) {                 builder.put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey(),
347                         new ByteSizeValue(RandomNumbers.randomIntBetween(random, 1, 10), ByteSizeUnit.MB));
348             } else {
349                 builder.put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey(),
350                         new ByteSizeValue(RandomNumbers.randomIntBetween(random, 10, 200), ByteSizeUnit.MB));
351             }
352         }
353         if (random.nextBoolean()) {
354             builder.put(TransportSettings.PING_SCHEDULE.getKey(), RandomNumbers.randomIntBetween(random, 100, 2000) + "ms");
355         }
356         return builder.build();
357     }
358 <a name="7"></a>
359     public static String clusterName(String prefix, long clusterSeed) {
360         StringBuilder builder = new StringBuilder(prefix);
361         <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>builder.append("-TEST_WORKER_VM=[").append(ESTestCase.TEST_WORKER_VM_ID).append(']');
362         builder.append("-CLUSTER_SEED=[").append(clusterSeed).append(']');
363         builder.append("-HASH=[").append(SeedUtils.formatSeed(System.nanoTime</b></font>())).append(']');
364         return builder.toString();
365     }
366     private void ensureOpen() {
367         if (!open.get()) {
368             throw new RuntimeException("Cluster is already closed");
369         }
370     }
371     private NodeAndClient getOrBuildRandomNode() {
372         assert Thread.holdsLock(this);
373         final NodeAndClient randomNodeAndClient = getRandomNodeAndClient();
374         if (randomNodeAndClient != null) {
375             return randomNodeAndClient;
376         }
377         final Runnable onTransportServiceStarted = () -&gt; {}; 
378         final int nodeId = nextNodeId.getAndIncrement();
379         final Settings settings = getNodeSettings(nodeId, random.nextLong(), Settings.EMPTY);
380         final Settings nodeSettings = Settings.builder()
381                 .putList(INITIAL_MASTER_NODES_SETTING.getKey(), Node.NODE_NAME_SETTING.get(settings))
382                 .put(settings)
383                 .build();
384         final NodeAndClient buildNode = buildNode(nodeId, nodeSettings, false, onTransportServiceStarted);
385         assert nodes.isEmpty();
386         buildNode.startNode();
387         publishNode(buildNode);
388         return buildNode;
389     }
390     private NodeAndClient getRandomNodeAndClient() {
391         return getRandomNodeAndClient(nc -&gt; true);
392     }
393     private synchronized NodeAndClient getRandomNodeAndClient(Predicate&lt;NodeAndClient&gt; predicate) {
394         ensureOpen();
395         List&lt;NodeAndClient&gt; values = nodes.values().stream().filter(predicate).collect(Collectors.toList());
396         if (values.isEmpty() == false) {
397             return randomFrom(random, values);
398         }
399         return null;
400     }
401     public synchronized void ensureAtLeastNumDataNodes(int n) {
402         int size = numDataNodes();
403         if (size &lt; n) {
404             logger.info("increasing cluster size from {} to {}", size, n);
405             if (numSharedDedicatedMasterNodes &gt; 0) {
406                 startDataOnlyNodes(n - size);
407             } else {
408                 startNodes(n - size);
409             }
410             validateClusterFormed();
411         }
412     }
413     public synchronized void ensureAtMostNumDataNodes(int n) throws IOException {
414         int size = numDataNodes();
415         if (size &lt;= n) {
416 <a name="12"></a>            return;
417         }
418         <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Stream&lt;NodeAndClient&gt; collection = n == 0
419                 ? nodes.values().stream()
420                 : nodes.values().stream()
421                         .filter(DATA_NODE_PREDICATE.and(new NodeNamePredicate(getMasterName()).negate</b></font>()));
422         final Iterator&lt;NodeAndClient&gt; values = collection.iterator();
423         logger.info("changing cluster size from {} data nodes to {}", size, n);
424         Set&lt;NodeAndClient&gt; nodesToRemove = new HashSet&lt;&gt;();
425         int numNodesAndClients = 0;
426         while (values.hasNext() &amp;&amp; numNodesAndClients++ &lt; size - n) {
427             NodeAndClient next = values.next();
428             nodesToRemove.add(next);
429         }
430         stopNodesAndClients(nodesToRemove);
431         if (!nodesToRemove.isEmpty() &amp;&amp; size() &gt; 0) {
432             validateClusterFormed();
433         }
434     }
435     private Settings getNodeSettings(final int nodeId, final long seed, final Settings extraSettings) {
436         final Settings settings = getSettings(nodeId, seed, extraSettings);
437         final String name = buildNodeName(nodeId, settings);
438         final Settings.Builder updatedSettings = Settings.builder();
439         updatedSettings.put(Environment.PATH_HOME_SETTING.getKey(), baseDir);
440         if (numDataPaths &gt; 1) {
441             updatedSettings.putList(Environment.PATH_DATA_SETTING.getKey(), IntStream.range(0, numDataPaths).mapToObj(i -&gt;
442                 baseDir.resolve(name).resolve("d" + i).toString()).collect(Collectors.toList()));
443         } else {
444             updatedSettings.put(Environment.PATH_DATA_SETTING.getKey(), baseDir.resolve(name));
445         }
446         updatedSettings.put(Environment.PATH_SHARED_DATA_SETTING.getKey(), baseDir.resolve(name + "-shared"));
447         updatedSettings.put(settings);
448         updatedSettings.put("node.name", name);
449         updatedSettings.put(NodeEnvironment.NODE_ID_SEED_SETTING.getKey(), seed);
450         if (autoManageMasterNodes) {
451             assertThat("if master nodes are automatically managed then nodes must complete a join cycle when starting",
452                 updatedSettings.get(INITIAL_STATE_TIMEOUT_SETTING.getKey()), nullValue());
453         }
454         return updatedSettings.build();
455     }
456     private synchronized NodeAndClient buildNode(int nodeId, Settings settings,
457                                     boolean reuseExisting, Runnable onTransportServiceStarted) {
458         assert Thread.holdsLock(this);
459         ensureOpen();
460         Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins = getPlugins();
461         String name = settings.get("node.name");
462         final NodeAndClient nodeAndClient = nodes.get(name);
463         if (reuseExisting &amp;&amp; nodeAndClient != null) {
464             onTransportServiceStarted.run();             return nodeAndClient;
465         }
466         assert reuseExisting || nodeAndClient == null : "node name [" + name + "] already exists but not allowed to use it";
467         MockNode node = new MockNode(
468                 settings,
469                 plugins,
470                 nodeConfigurationSource.nodeConfigPath(nodeId),
471                 forbidPrivateIndexSettings);
472         node.injector().getInstance(TransportService.class).addLifecycleListener(new LifecycleListener() {
473             @Override
474             public void afterStart() {
475                 onTransportServiceStarted.run();
476             }
477         });
478         return new NodeAndClient(name, node, settings, nodeId);
479     }
480     private String getNodePrefix(Settings settings) {
481         return nodePrefix + getRoleSuffix(settings);
482     }
483     private String buildNodeName(int id, Settings settings) {
484         return getNodePrefix(settings) + id;
485     }
486     private static String getRoleSuffix(Settings settings) {
487         String suffix = "";
488         if (Node.NODE_MASTER_SETTING.exists(settings) &amp;&amp; Node.NODE_MASTER_SETTING.get(settings)) {
489             suffix = suffix + DiscoveryNodeRole.MASTER_ROLE.roleNameAbbreviation();
490         }
491         if (Node.NODE_DATA_SETTING.exists(settings) &amp;&amp; Node.NODE_DATA_SETTING.get(settings)) {
492             suffix = suffix + DiscoveryNodeRole.DATA_ROLE.roleNameAbbreviation();
493         }
494         if (Node.NODE_MASTER_SETTING.exists(settings) &amp;&amp; Node.NODE_MASTER_SETTING.get(settings) == false &amp;&amp;
495             Node.NODE_DATA_SETTING.exists(settings) &amp;&amp; Node.NODE_DATA_SETTING.get(settings) == false
496             ) {
497             suffix = suffix + "c";
498         }
499         return suffix;
500     }
501     @Override
502     public synchronized Client client() {
503         ensureOpen();
504         return getOrBuildRandomNode().client();
505     }
506     public Client dataNodeClient() {
507         return getRandomNodeAndClient(DATA_NODE_PREDICATE).client();
508     }
509     public Client masterClient() {
510         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()));
511         if (randomNodeAndClient != null) {
512             return randomNodeAndClient.nodeClient();         }
513         throw new AssertionError("No master client found");
514     }
515     public Client nonMasterClient() {
516         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()).negate());
517         if (randomNodeAndClient != null) {
518             return randomNodeAndClient.nodeClient();         }
519         throw new AssertionError("No non-master client found");
520     }
521     public synchronized Client coordOnlyNodeClient() {
522         ensureOpen();
523         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE);
524         if (randomNodeAndClient != null) {
525             return randomNodeAndClient.client();
526         }
527         int nodeId = nextNodeId.getAndIncrement();
528         Settings settings = getSettings(nodeId, random.nextLong(), Settings.EMPTY);
529         startCoordinatingOnlyNode(settings);
530 <a name="11"></a>        return getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE).client();
531     }
532     public synchronized String startCoordinatingOnlyNode(Settings settings) <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
533         ensureOpen();         Builder builder = Settings.builder().put(settings).put(Node.NODE_MASTER_SETTING.getKey(), false)
534             .put(Node.NODE_DATA_SETTING.getKey</b></font>(), false);
535         return startNode(builder);
536     }
537     public Client client(String nodeName) {
538         NodeAndClient nodeAndClient = nodes.get(nodeName);
539         if (nodeAndClient != null) {
540             return nodeAndClient.client();
541         }
542         throw new AssertionError("No node found with name: [" + nodeName + "]");
543     }
544     public Client smartClient() {
545         NodeAndClient randomNodeAndClient = getRandomNodeAndClient();
546         if (randomNodeAndClient != null) {
547             return randomNodeAndClient.nodeClient();
548         }
549         throw new AssertionError("No smart client found");
550     }
551     @Override
552     public synchronized void close() throws IOException {
553         if (this.open.compareAndSet(true, false)) {
554             if (activeDisruptionScheme != null) {
555                 activeDisruptionScheme.testClusterClosed();
556                 activeDisruptionScheme = null;
557             }
558             try {
559                 IOUtils.close(nodes.values());
560             } finally {
561                 nodes = Collections.emptyNavigableMap();
562                 executor.shutdownNow();
563             }
564         }
565     }
566     private final class NodeAndClient implements Closeable {
567         private MockNode node;
568         private final Settings originalNodeSettings;
569         private Client nodeClient;
570         private final AtomicBoolean closed = new AtomicBoolean(false);
571         private final String name;
572         private final int nodeAndClientId;
573         NodeAndClient(String name, MockNode node, Settings originalNodeSettings, int nodeAndClientId) {
574             this.node = node;
575             this.name = name;
576             this.originalNodeSettings = originalNodeSettings;
577             this.nodeAndClientId = nodeAndClientId;
578             markNodeDataDirsAsNotEligibleForWipe(node);
579         }
580         Node node() {
581             if (closed.get()) {
582                 throw new RuntimeException("already closed");
583             }
584             return node;
585         }
586         public int nodeAndClientId() {
587             return nodeAndClientId;
588         }
589         public String getName() {
590             return name;
591         }
592         public boolean isMasterEligible() {
593             return Node.NODE_MASTER_SETTING.get(node.settings());
594         }
595         Client client() {
596             return getOrBuildNodeClient();
597         }
598         Client nodeClient() {
599             if (closed.get()) {
600                 throw new RuntimeException("already closed");
601             }
602             return getOrBuildNodeClient();
603         }
604         private Client getOrBuildNodeClient() {
605             synchronized (InternalTestCluster.this) {
606                 if (closed.get()) {
607                     throw new RuntimeException("already closed");
608                 }
609                 if (nodeClient == null) {
610                     nodeClient = node.client();
611                 }
612                 return nodeClient;
613             }
614         }
615         void resetClient() {
616             if (closed.get() == false) {
617                 Releasables.close(nodeClient);
618                 nodeClient = null;
619             }
620         }
621         void startNode() {
622             boolean success = false;
623             try {
624                 node.start();
625                 success = true;
626             } catch (NodeValidationException e) {
627                 throw new RuntimeException(e);
628             } finally {
629                 if (success == false) {
630                     IOUtils.closeWhileHandlingException(node);
631                 }
632             }
633         }
634         Settings closeForRestart(RestartCallback callback) throws Exception {
635             assert callback != null;
636             close();
637             removeNode(this);
638             Settings callbackSettings = callback.onNodeStopped(name);
639             assert callbackSettings != null;
640             Settings.Builder newSettings = Settings.builder();
641             if (autoManageMasterNodes) {
642                 newSettings.putList(INITIAL_MASTER_NODES_SETTING.getKey());
643             }
644             newSettings.put(callbackSettings);
645             clearDataIfNeeded(callback);
646             return newSettings.build();
647         }
648         private void clearDataIfNeeded(RestartCallback callback) throws IOException {
649             if (callback.clearData(name)) {
650                 NodeEnvironment nodeEnv = node.getNodeEnvironment();
651                 if (nodeEnv.hasNodeFile()) {
652                     final Path[] locations = nodeEnv.nodeDataPaths();
653                     logger.debug("removing node data paths: [{}]", Arrays.toString(locations));
654                     IOUtils.rm(locations);
655                 }
656             }
657         }
658         private void recreateNode(final Settings newSettings, final Runnable onTransportServiceStarted) {
659             if (closed.get() == false) {
660                 throw new IllegalStateException("node " + name + " should be closed before recreating it");
661             }
662             final long newIdSeed = NodeEnvironment.NODE_ID_SEED_SETTING.get(node.settings()) + 1;
663             Settings finalSettings = Settings.builder()
664                     .put(originalNodeSettings)
665                     .put(newSettings)
666                     .put(NodeEnvironment.NODE_ID_SEED_SETTING.getKey(), newIdSeed)
667                     .build();
668             Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins = node.getClasspathPlugins();
669             node = new MockNode(finalSettings, plugins);
670             node.injector().getInstance(TransportService.class).addLifecycleListener(new LifecycleListener() {
671                 @Override
672                 public void afterStart() {
673                     onTransportServiceStarted.run();
674                 }
675             });
676             closed.set(false);
677             markNodeDataDirsAsNotEligibleForWipe(node);
678         }
679         @Override
680         public void close() throws IOException {
681             assert Thread.holdsLock(InternalTestCluster.this);
682             try {
683                 resetClient();
684             } finally {
685                 closed.set(true);
686                 markNodeDataDirsAsPendingForWipe(node);
687                 node.close();
688                 try {
689                     if (node.awaitClose(10, TimeUnit.SECONDS) == false) {
690                         throw new IOException("Node didn't close within 10 seconds.");
691                     }
692                 } catch (InterruptedException e) {
693                     throw new AssertionError("Interruption while waiting for the node to close", e);
694                 }
695             }
696         }
697         private void markNodeDataDirsAsPendingForWipe(Node node) {
698             assert Thread.holdsLock(InternalTestCluster.this);
699             NodeEnvironment nodeEnv = node.getNodeEnvironment();
700             if (nodeEnv.hasNodeFile()) {
701                 dataDirToClean.addAll(Arrays.asList(nodeEnv.nodeDataPaths()));
702             }
703         }
704         private void markNodeDataDirsAsNotEligibleForWipe(Node node) {
705             assert Thread.holdsLock(InternalTestCluster.this);
706             NodeEnvironment nodeEnv = node.getNodeEnvironment();
707             if (nodeEnv.hasNodeFile()) {
708                 dataDirToClean.removeAll(Arrays.asList(nodeEnv.nodeDataPaths()));
709             }
710         }
711     }
712     @Override
713     public synchronized void beforeTest(Random random) throws IOException, InterruptedException {
714         super.beforeTest(random);
715         reset(true);
716     }
717     private synchronized void reset(boolean wipeData) throws IOException {
718         for (NodeAndClient nodeAndClient : nodes.values()) {
719             TransportService transportService = nodeAndClient.node.injector().getInstance(TransportService.class);
720             if (transportService instanceof MockTransportService) {
721                 final MockTransportService mockTransportService = (MockTransportService) transportService;
722                 mockTransportService.clearAllRules();
723             }
724         }
725         randomlyResetClients();
726         final int newSize = sharedNodesSeeds.length;
727         if (nextNodeId.get() == newSize &amp;&amp; nodes.size() == newSize) {
728             if (wipeData) {
729                 wipePendingDataDirectories();
730             }
731             logger.debug("Cluster hasn't changed - moving out - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
732                     nodes.keySet(), nextNodeId.get(), newSize);
733             return;
734         }
735         logger.debug("Cluster is NOT consistent - restarting shared nodes - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
736                 nodes.keySet(), nextNodeId.get(), newSize);
737         final List&lt;NodeAndClient&gt; toClose = new ArrayList&lt;&gt;();
738         for (NodeAndClient nodeAndClient : nodes.values()) {
739             if (nodeAndClient.nodeAndClientId() &gt;= sharedNodesSeeds.length) {
740                 logger.debug("Close Node [{}] not shared", nodeAndClient.name);
741                 toClose.add(nodeAndClient);
742             }
743         }
744         stopNodesAndClients(toClose);
745         if (wipeData) {
746             wipePendingDataDirectories();
747         }
748         assertTrue("expected at least one master-eligible node left in " + nodes,
749             nodes.isEmpty() || nodes.values().stream().anyMatch(NodeAndClient::isMasterEligible));
750         final int prevNodeCount = nodes.size();
751         assert newSize == numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes;
752         final List&lt;NodeAndClient&gt; toStartAndPublish = new ArrayList&lt;&gt;();         final Runnable onTransportServiceStarted = () -&gt; rebuildUnicastHostFiles(toStartAndPublish);
753 <a name="16"></a>        final List&lt;Settings&gt; settings = new ArrayList&lt;&gt;();
754         for (int i = 0; i &lt; numSharedDedicatedMasterNodes; i++) {
755             final Settings.Builder extraSettings = <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder();
756             extraSettings.put(Node.NODE_MASTER_SETTING.getKey(), true);
757             extraSettings.put(Node.NODE_DATA_SETTING.getKey(), false);
758             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
759         }</b></font>
760         for (int i = numSharedDedicatedMasterNodes; i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes; i++) {
761             final Settings.Builder extraSettings = Settings.builder();
762             if (numSharedDedicatedMasterNodes &gt; 0) {
763                 extraSettings.put(Node.NODE_MASTER_SETTING.getKey(), false).build();
764                 extraSettings.put(Node.NODE_DATA_SETTING.getKey(), true).build();
765             }
766             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
767 <a name="14"></a>        }
768         for (int i = numSharedDedicatedMasterNodes + numSharedDataNodes;
769              i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes; i++) {
770             final Builder extraSettings = <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder().put(Node.NODE_MASTER_SETTING.getKey(), false)
771                 .put(Node.NODE_DATA_SETTING.getKey(), false);
772             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
773         }</b></font>
774         int autoBootstrapMasterNodeIndex = -1;
775         final List&lt;String&gt; masterNodeNames = settings.stream()
776                 .filter(Node.NODE_MASTER_SETTING::get)
777                 .map(Node.NODE_NAME_SETTING::get)
778                 .collect(Collectors.toList());
779         if (prevNodeCount == 0 &amp;&amp; autoManageMasterNodes) {
780             if (numSharedDedicatedMasterNodes &gt; 0) {
781                 autoBootstrapMasterNodeIndex = RandomNumbers.randomIntBetween(random, 0, numSharedDedicatedMasterNodes - 1);
782             } else if (numSharedDataNodes &gt; 0) {
783                 autoBootstrapMasterNodeIndex = RandomNumbers.randomIntBetween(random, 0, numSharedDataNodes - 1);
784             }
785         }
786         final List&lt;Settings&gt; updatedSettings = bootstrapMasterNodeWithSpecifiedIndex(settings);
787         for (int i = 0; i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes; i++) {
788             Settings nodeSettings = updatedSettings.get(i);
789             if (i == autoBootstrapMasterNodeIndex) {
790                 nodeSettings = Settings.builder().putList(INITIAL_MASTER_NODES_SETTING.getKey(), masterNodeNames).put(nodeSettings).build();
791             }
792             final NodeAndClient nodeAndClient = buildNode(i, nodeSettings, true, onTransportServiceStarted);
793             toStartAndPublish.add(nodeAndClient);
794         }
795         startAndPublishNodesAndClients(toStartAndPublish);
796         nextNodeId.set(newSize);
797         assert size() == newSize;
798         if (autoManageMasterNodes &amp;&amp; newSize &gt; 0) {
799             validateClusterFormed();
800         }
801         logger.debug("Cluster is consistent again - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
802                 nodes.keySet(), nextNodeId.get(), newSize);
803     }
804     public synchronized void validateClusterFormed() {
805         final Set&lt;DiscoveryNode&gt; expectedNodes = new HashSet&lt;&gt;();
806         for (NodeAndClient nodeAndClient : nodes.values()) {
807             expectedNodes.add(getInstanceFromNode(ClusterService.class, nodeAndClient.node()).localNode());
808         }
809         logger.trace("validating cluster formed, expecting {}", expectedNodes);
810         try {
811             assertBusy(() -&gt; {
812                 final List&lt;ClusterState&gt; states = nodes.values().stream()
813                     .map(node -&gt; getInstanceFromNode(ClusterService.class, node.node()))
814                     .map(ClusterService::state)
815 <a name="2"></a>                    .collect(Collectors.toList());
816                 final String debugString = ", expected nodes: " + expectedNodes + " and actual cluster states " + states;
817                 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue("Missing master" + debugString, states.stream().allMatch(cs -&gt; cs.nodes().getMasterNodeId() != null));
818                 assertEquals("Not all masters in same term" + debugString, 1,
819 <a name="10"></a>                    states.stream().mapToLong(ClusterState::term).distinct().count());
820                 states.forEach</b></font>(cs -&gt; {
821                     DiscoveryNodes discoveryNodes = <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cs.nodes();
822                     assertEquals("Node size mismatch" + debugString, expectedNodes.size(), discoveryNodes.getSize());
823                     for (DiscoveryNode expectedNode : expectedNodes) {
824                         assertTrue("Expected node to exist: " + expectedNode + debugString, discoveryNodes.nodeExists</b></font>(expectedNode));
825                     }
826                 });
827             }, 30, TimeUnit.SECONDS);
828         } catch (AssertionError ae) {
829             throw new IllegalStateException("cluster failed to form", ae);
830         } catch (Exception e) {
831             throw new IllegalStateException(e);
832         }
833     }
834 <a name="9"></a>
835     @Override
836     public synchronized void afterTest() {
837         <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>wipePendingDataDirectories();
838         randomlyResetClients();     }
839     @Override
840     public void beforeIndexDeletion() throws Exception {
841         assertNoPendingIndexOperations();
842         //check that shards that have same sync id also contain same number of documents
843         assertSameSyncIdSameDocs();
844         assertOpenTranslogReferences</b></font>();
845     }
846     private void assertSameSyncIdSameDocs() {
847         Map&lt;String, Long&gt; docsOnShards = new HashMap&lt;&gt;();
848         final Collection&lt;NodeAndClient&gt; nodesAndClients = nodes.values();
849         for (NodeAndClient nodeAndClient : nodesAndClients) {
850             IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
851             for (IndexService indexService : indexServices) {
852                 for (IndexShard indexShard : indexService) {
853                     try {
854                         CommitStats commitStats = indexShard.commitStats();
855                         String syncId = commitStats.getUserData().get(Engine.SYNC_COMMIT_ID);
856                         if (syncId != null) {
857                             long liveDocsOnShard = commitStats.getNumDocs();
858                             if (docsOnShards.get(syncId) != null) {
859                                 assertThat("sync id is equal but number of docs does not match on node "
860                                     + nodeAndClient.name + ". expected " + docsOnShards.get(syncId) + " but got "
861                                     + liveDocsOnShard, docsOnShards.get(syncId), equalTo(liveDocsOnShard));
862                             } else {
863                                 docsOnShards.put(syncId, liveDocsOnShard);
864                             }
865                         }
866                     } catch (AlreadyClosedException e) {
867                     }
868                 }
869             }
870         }
871     }
872     private void assertNoPendingIndexOperations() throws Exception {
873         assertBusy(() -&gt; {
874             for (NodeAndClient nodeAndClient : nodes.values()) {
875                 IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
876                 for (IndexService indexService : indexServices) {
877                     for (IndexShard indexShard : indexService) {
878                         List&lt;String&gt; operations = indexShard.getActiveOperations();
879                         if (operations.size() &gt; 0) {
880                             throw new AssertionError(
881                                 "shard " + indexShard.shardId() + " on node [" + nodeAndClient.name + "] has pending operations:\n --&gt; " +
882                                     String.join("\n --&gt; ", operations)
883                             );
884                         }
885                     }
886                 }
887             }
888         }, 60, TimeUnit.SECONDS);
889     }
890     private void assertOpenTranslogReferences() throws Exception {
891         assertBusy(() -&gt; {
892             for (NodeAndClient nodeAndClient : nodes.values()) {
893                 IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
894                 for (IndexService indexService : indexServices) {
895                     for (IndexShard indexShard : indexService) {
896                         try {
897                             if (IndexShardTestCase.getEngine(indexShard) instanceof InternalEngine) {
898                                 IndexShardTestCase.getTranslog(indexShard).getDeletionPolicy().assertNoOpenTranslogRefs();
899                             }
900                         } catch (AlreadyClosedException ok) {
901                         }
902                     }
903                 }
904             }
905         }, 60, TimeUnit.SECONDS);
906     }
907     public void assertConsistentHistoryBetweenTranslogAndLuceneIndex() throws IOException {
908         for (NodeAndClient nodeAndClient : nodes.values()) {
909             IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
910             for (IndexService indexService : indexServices) {
911                 for (IndexShard indexShard : indexService) {
912                     try {
913                         IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard);
914                     } catch (AlreadyClosedException ignored) {
915                     }
916                 }
917             }
918         }
919     }
920     private IndexShard getShardOrNull(ClusterState clusterState, ShardRouting shardRouting) {
921         if (shardRouting == null || shardRouting.assignedToNode() == false) {
922             return null;
923         }
924         final DiscoveryNode assignedNode = clusterState.nodes().get(shardRouting.currentNodeId());
925         if (assignedNode == null) {
926             return null;
927         }
928         return getInstance(IndicesService.class, assignedNode.getName()).getShardOrNull(shardRouting.shardId());
929     }
930     public void assertSeqNos() throws Exception {
931         assertBusy(() -&gt; {
932             final ClusterState state = clusterService().state();
933             for (ObjectObjectCursor&lt;String, IndexRoutingTable&gt; indexRoutingTable : state.routingTable().indicesRouting()) {
934                 for (IntObjectCursor&lt;IndexShardRoutingTable&gt; indexShardRoutingTable : indexRoutingTable.value.shards()) {
935                     ShardRouting primaryShardRouting = indexShardRoutingTable.value.primaryShard();
936                     final IndexShard primaryShard = getShardOrNull(state, primaryShardRouting);
937                     if (primaryShard == null) {
938                         continue; //just ignore - shard movement
939                     }
940                     final SeqNoStats primarySeqNoStats;
941                     final ObjectLongMap&lt;String&gt; syncGlobalCheckpoints;
942                     try {
943                         primarySeqNoStats = primaryShard.seqNoStats();
944                         syncGlobalCheckpoints = primaryShard.getInSyncGlobalCheckpoints();
945                     } catch (AlreadyClosedException ex) {
946                         continue;                     }
947                     assertThat(primaryShardRouting + " should have set the global checkpoint",
948                         primarySeqNoStats.getGlobalCheckpoint(), not(equalTo(SequenceNumbers.UNASSIGNED_SEQ_NO)));
949                     for (ShardRouting replicaShardRouting : indexShardRoutingTable.value.replicaShards()) {
950                         final IndexShard replicaShard = getShardOrNull(state, replicaShardRouting);
951                         if (replicaShard == null) {
952                             continue; //just ignore - shard movement
953                         }
954                         final SeqNoStats seqNoStats;
955                         try {
956                             seqNoStats = replicaShard.seqNoStats();
957 <a name="3"></a>                        } catch (AlreadyClosedException e) {
958                             continue;                         }
959                         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(replicaShardRouting + " seq_no_stats mismatch", seqNoStats, equalTo(primarySeqNoStats));
960                         assertThat(replicaShardRouting + " global checkpoint syncs mismatch", seqNoStats.getGlobalCheckpoint(),
961                             equalTo(syncGlobalCheckpoints.get(replicaShardRouting.allocationId().getId())));
962                     }
963                 }</b></font>
964             }
965         }, 60, TimeUnit.SECONDS);
966     }
967     public void assertSameDocIdsOnShards() throws Exception {
968         assertBusy(() -&gt; {
969             ClusterState state = client().admin().cluster().prepareState().get().getState();
970             for (ObjectObjectCursor&lt;String, IndexRoutingTable&gt; indexRoutingTable : state.routingTable().indicesRouting()) {
971                 for (IntObjectCursor&lt;IndexShardRoutingTable&gt; indexShardRoutingTable : indexRoutingTable.value.shards()) {
972                     ShardRouting primaryShardRouting = indexShardRoutingTable.value.primaryShard();
973                     IndexShard primaryShard = getShardOrNull(state, primaryShardRouting);
974                     if (primaryShard == null) {
975                         continue;
976                     }
977                     final List&lt;DocIdSeqNoAndSource&gt; docsOnPrimary;
978                     try {
979                         docsOnPrimary = IndexShardTestCase.getDocIdAndSeqNos(primaryShard);
980                     } catch (AlreadyClosedException ex) {
981                         continue;
982                     }
983                     for (ShardRouting replicaShardRouting : indexShardRoutingTable.value.replicaShards()) {
984                         IndexShard replicaShard = getShardOrNull(state, replicaShardRouting);
985                         if (replicaShard == null) {
986                             continue;
987                         }
988                         final List&lt;DocIdSeqNoAndSource&gt; docsOnReplica;
989                         try {
990                             docsOnReplica = IndexShardTestCase.getDocIdAndSeqNos(replicaShard);
991                         } catch (AlreadyClosedException ex) {
992                             continue;
993                         }
994                         assertThat("out of sync shards: primary=[" + primaryShardRouting + "] num_docs_on_primary=[" + docsOnPrimary.size()
995                                 + "] vs replica=[" + replicaShardRouting + "] num_docs_on_replica=[" + docsOnReplica.size() + "]",
996                             docsOnReplica, equalTo(docsOnPrimary));
997                     }
998                 }
999             }
1000         });
1001     }
1002     private void randomlyResetClients() {
1003         assert Thread.holdsLock(this);
1004         if (RandomizedTest.isNightly() &amp;&amp; rarely(random)) {
1005             final Collection&lt;NodeAndClient&gt; nodesAndClients = nodes.values();
1006             for (NodeAndClient nodeAndClient : nodesAndClients) {
1007                 nodeAndClient.resetClient();
1008             }
1009         }
1010     }
1011     public synchronized void wipePendingDataDirectories() {
1012         if (!dataDirToClean.isEmpty()) {
1013             try {
1014                 for (Path path : dataDirToClean) {
1015                     try {
1016                         FileSystemUtils.deleteSubDirectories(path);
1017                         logger.info("Successfully wiped data directory for node location: {}", path);
1018                     } catch (IOException e) {
1019                         logger.info("Failed to wipe data directory for node location: {}", path);
1020                     }
1021                 }
1022             } finally {
1023                 dataDirToClean.clear();
1024             }
1025         }
1026     }
1027     public ClusterService clusterService() {
1028         return clusterService(null);
1029     }
1030     public ClusterService clusterService(@Nullable String node) {
1031         return getInstance(ClusterService.class, node);
1032     }
1033     public &lt;T&gt; Iterable&lt;T&gt; getInstances(Class&lt;T&gt; clazz) {
1034         return nodes.values().stream().map(node -&gt; getInstanceFromNode(clazz, node.node)).collect(Collectors.toList());
1035     }
1036     public &lt;T&gt; Iterable&lt;T&gt; getDataNodeInstances(Class&lt;T&gt; clazz) {
1037         return getInstances(clazz, DATA_NODE_PREDICATE);
1038     }
1039     public synchronized &lt;T&gt; T getCurrentMasterNodeInstance(Class&lt;T&gt; clazz) {
1040         return getInstance(clazz, new NodeNamePredicate(getMasterName()));
1041     }
1042     public &lt;T&gt; Iterable&lt;T&gt; getDataOrMasterNodeInstances(Class&lt;T&gt; clazz) {
1043         return getInstances(clazz, DATA_NODE_PREDICATE.or(MASTER_NODE_PREDICATE));
1044     }
1045     private &lt;T&gt; Iterable&lt;T&gt; getInstances(Class&lt;T&gt; clazz, Predicate&lt;NodeAndClient&gt; predicate) {
1046         Iterable&lt;NodeAndClient&gt; filteredNodes = nodes.values().stream().filter(predicate)::iterator;
1047         List&lt;T&gt; instances = new ArrayList&lt;&gt;();
1048         for (NodeAndClient nodeAndClient : filteredNodes) {
1049             instances.add(getInstanceFromNode(clazz, nodeAndClient.node));
1050         }
1051         return instances;
1052     }
1053     public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, final String node) {
1054         return getInstance(clazz, nc -&gt; node == null || node.equals(nc.name));
1055     }
1056     public &lt;T&gt; T getDataNodeInstance(Class&lt;T&gt; clazz) {
1057         return getInstance(clazz, DATA_NODE_PREDICATE);
1058     }
1059     public &lt;T&gt; T getMasterNodeInstance(Class&lt;T&gt; clazz) {
1060         return getInstance(clazz, MASTER_NODE_PREDICATE);
1061     }
1062     private synchronized &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, Predicate&lt;NodeAndClient&gt; predicate) {
1063         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(predicate);
1064         assert randomNodeAndClient != null;
1065         return getInstanceFromNode(clazz, randomNodeAndClient.node);
1066     }
1067     public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) {
1068         return getInstance(clazz, nc -&gt; true);
1069     }
1070     private static &lt;T&gt; T getInstanceFromNode(Class&lt;T&gt; clazz, Node node) {
1071         return node.injector().getInstance(clazz);
1072 <a name="8"></a>    }
1073     public Settings dataPathSettings(String node) {
1074         return <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>nodes.values()
1075 <a name="15"></a>            .stream()
1076             .filter(nc -&gt; nc.name.equals</b></font>(node))
1077             .findFirst().get().node().settings()
1078             .filter(key -&gt; <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>key.equals(Environment.PATH_DATA_SETTING.getKey()) ||  key.equals(Environment.PATH_SHARED_DATA_SETTING.getKey()));
1079     }
1080     @Override
1081     public int size() {</b></font>
1082         return nodes.size();
1083     }
1084     @Override
1085     public InetSocketAddress[] httpAddresses() {
1086         List&lt;InetSocketAddress&gt; addresses = new ArrayList&lt;&gt;();
1087         for (HttpServerTransport httpServerTransport : getInstances(HttpServerTransport.class)) {
1088             addresses.add(httpServerTransport.boundAddress().publishAddress().address());
1089         }
1090         return addresses.toArray(new InetSocketAddress[0]);
1091     }
1092     public synchronized boolean stopRandomDataNode() throws IOException {
1093         ensureOpen();
1094         NodeAndClient nodeAndClient = getRandomNodeAndClient(DATA_NODE_PREDICATE);
1095         if (nodeAndClient != null) {
1096             logger.info("Closing random node [{}] ", nodeAndClient.name);
1097             stopNodesAndClient(nodeAndClient);
1098             return true;
1099         }
1100         return false;
1101     }
1102     public synchronized void stopRandomNode(final Predicate&lt;Settings&gt; filter) throws IOException {
1103         ensureOpen();
1104         NodeAndClient nodeAndClient = getRandomNodeAndClient(nc -&gt; filter.test(nc.node.settings()));
1105         if (nodeAndClient != null) {
1106             if (nodeAndClient.nodeAndClientId() &lt; sharedNodesSeeds.length &amp;&amp; nodeAndClient.isMasterEligible() &amp;&amp; autoManageMasterNodes
1107                 &amp;&amp; nodes.values().stream()
1108                         .filter(NodeAndClient::isMasterEligible)
1109                         .filter(n -&gt; n.nodeAndClientId() &lt; sharedNodesSeeds.length)
1110                         .count() == 1) {
1111                 throw new AssertionError("Tried to stop the only master eligible shared node");
1112             }
1113             logger.info("Closing filtered random node [{}] ", nodeAndClient.name);
1114             stopNodesAndClient(nodeAndClient);
1115         }
1116     }
1117     public synchronized void stopCurrentMasterNode() throws IOException {
1118         ensureOpen();
1119         assert size() &gt; 0;
1120         String masterNodeName = getMasterName();
1121         final NodeAndClient masterNode = nodes.get(masterNodeName);
1122         assert masterNode != null;
1123         logger.info("Closing master node [{}] ", masterNodeName);
1124         stopNodesAndClient(masterNode);
1125     }
1126     public synchronized void stopRandomNonMasterNode() throws IOException {
1127         NodeAndClient nodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()).negate());
1128         if (nodeAndClient != null) {
1129             logger.info("Closing random non master node [{}] current master [{}] ", nodeAndClient.name, getMasterName());
1130             stopNodesAndClient(nodeAndClient);
1131         }
1132     }
1133     private synchronized void startAndPublishNodesAndClients(List&lt;NodeAndClient&gt; nodeAndClients) {
1134         if (nodeAndClients.size() &gt; 0) {
1135             final int newMasters = (int) nodeAndClients.stream().filter(NodeAndClient::isMasterEligible)
1136                 .filter(nac -&gt; nodes.containsKey(nac.name) == false)                 .count();
1137             rebuildUnicastHostFiles(nodeAndClients);             List&lt;Future&lt;?&gt;&gt; futures = nodeAndClients.stream().map(node -&gt; executor.submit(node::startNode)).collect(Collectors.toList());
1138             try {
1139                 for (Future&lt;?&gt; future : futures) {
1140                     future.get();
1141                 }
1142             } catch (InterruptedException e) {
1143                 throw new AssertionError("interrupted while starting nodes", e);
1144             } catch (ExecutionException e) {
1145                 RuntimeException re = FutureUtils.rethrowExecutionException(e);
1146                 re.addSuppressed(new RuntimeException("failed to start nodes"));
1147                 throw re;
1148             }
1149             nodeAndClients.forEach(this::publishNode);
1150             if (autoManageMasterNodes &amp;&amp; newMasters &gt; 0) {
1151                 validateClusterFormed();
1152             }
1153         }
1154     }
1155     private final Object discoveryFileMutex = new Object();
1156     private void rebuildUnicastHostFiles(List&lt;NodeAndClient&gt; newNodes) {
1157         synchronized (discoveryFileMutex) {
1158 <a name="4"></a>            try {
1159                 final Collection&lt;NodeAndClient&gt; currentNodes = nodes.values();
1160                 Stream&lt;NodeAndClient&gt; unicastHosts = Stream.concat(currentNodes.stream(), newNodes.stream());
1161                 List&lt;String&gt; discoveryFileContents = <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>unicastHosts.map(
1162                     nac -&gt; nac.node.injector</b></font>().getInstance(TransportService.class)
1163                 ).filter(Objects::nonNull)
1164                     .map(TransportService::getLocalNode).filter(Objects::nonNull).filter(DiscoveryNode::isMasterEligibleNode)
1165                     .map(n -&gt; n.getAddress().toString())
1166                     .distinct().collect(Collectors.toList());
1167                 Set&lt;Path&gt; configPaths = Stream.concat(currentNodes.stream(), newNodes.stream())
1168                     .map(nac -&gt; nac.node.getEnvironment().configFile()).collect(Collectors.toSet());
1169                 logger.debug("configuring discovery with {} at {}", discoveryFileContents, configPaths);
1170                 for (final Path configPath : configPaths) {
1171                     Files.createDirectories(configPath);
1172                     Files.write(configPath.resolve(UNICAST_HOSTS_FILE), discoveryFileContents);
1173                 }
1174             } catch (IOException e) {
1175                 throw new AssertionError("failed to configure file-based discovery", e);
1176             }
1177         }
1178     }
1179     private void stopNodesAndClient(NodeAndClient nodeAndClient) throws IOException {
1180         stopNodesAndClients(Collections.singleton(nodeAndClient));
1181     }
1182     private synchronized void stopNodesAndClients(Collection&lt;NodeAndClient&gt; nodeAndClients) throws IOException {
1183         final Set&lt;String&gt; excludedNodeIds = excludeMasters(nodeAndClients);
1184         for (NodeAndClient nodeAndClient: nodeAndClients) {
1185             removeDisruptionSchemeFromNode(nodeAndClient);
1186             final NodeAndClient previous = removeNode(nodeAndClient);
1187             assert previous == nodeAndClient;
1188             nodeAndClient.close();
1189         }
1190         removeExclusions(excludedNodeIds);
1191     }
1192     public void restartRandomDataNode() throws Exception {
1193         restartRandomDataNode(EMPTY_CALLBACK);
1194     }
1195     public synchronized void restartRandomDataNode(RestartCallback callback) throws Exception {
1196         ensureOpen();
1197         NodeAndClient nodeAndClient = getRandomNodeAndClient(InternalTestCluster.DATA_NODE_PREDICATE);
1198         if (nodeAndClient != null) {
1199             restartNode(nodeAndClient, callback);
1200         }
1201     }
1202     public synchronized void restartNode(String nodeName, RestartCallback callback) throws Exception {
1203         ensureOpen();
1204         NodeAndClient nodeAndClient = nodes.get(nodeName);
1205         if (nodeAndClient != null) {
1206             restartNode(nodeAndClient, callback);
1207         }
1208     }
1209     public static final RestartCallback EMPTY_CALLBACK = new RestartCallback();
1210     public void fullRestart() throws Exception {
1211         fullRestart(EMPTY_CALLBACK);
1212     }
1213     public synchronized void rollingRestart(RestartCallback callback) throws Exception {
1214         int numNodesRestarted = 0;
1215         for (NodeAndClient nodeAndClient : nodes.values()) {
1216             callback.doAfterNodes(numNodesRestarted++, nodeAndClient.nodeClient());
1217             restartNode(nodeAndClient, callback);
1218         }
1219     }
1220     private void restartNode(NodeAndClient nodeAndClient, RestartCallback callback) throws Exception {
1221         assert Thread.holdsLock(this);
1222         logger.info("Restarting node [{}] ", nodeAndClient.name);
1223         if (activeDisruptionScheme != null) {
1224             activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1225         }
1226         final Set&lt;String&gt; excludedNodeIds = excludeMasters(Collections.singleton(nodeAndClient));
1227         final Settings newSettings = nodeAndClient.closeForRestart(callback);
1228         removeExclusions(excludedNodeIds);
1229         nodeAndClient.recreateNode(newSettings, () -&gt; rebuildUnicastHostFiles(Collections.singletonList(nodeAndClient)));
1230         nodeAndClient.startNode();
1231         publishNode(nodeAndClient);
1232         if (callback.validateClusterForming() || excludedNodeIds.isEmpty() == false) {
1233             validateClusterFormed();
1234         }
1235     }
1236     private NodeAndClient removeNode(NodeAndClient nodeAndClient) {
1237         assert Thread.holdsLock(this);
1238         final NavigableMap&lt;String, NodeAndClient&gt; newNodes = new TreeMap&lt;&gt;(nodes);
1239         final NodeAndClient previous = newNodes.remove(nodeAndClient.name);
1240         nodes = Collections.unmodifiableNavigableMap(newNodes);
1241         return previous;
1242     }
1243     private Set&lt;String&gt; excludeMasters(Collection&lt;NodeAndClient&gt; nodeAndClients) {
1244         assert Thread.holdsLock(this);
1245         final Set&lt;String&gt; excludedNodeIds = new HashSet&lt;&gt;();
1246         if (autoManageMasterNodes &amp;&amp; nodeAndClients.size() &gt; 0) {
1247             final long currentMasters = nodes.values().stream().filter(NodeAndClient::isMasterEligible).count();
1248             final long stoppingMasters = nodeAndClients.stream().filter(NodeAndClient::isMasterEligible).count();
1249             assert stoppingMasters &lt;= currentMasters : currentMasters + " &lt; " + stoppingMasters;
1250             if (stoppingMasters != currentMasters &amp;&amp; stoppingMasters &gt; 0) {
1251                 nodeAndClients.stream().filter(NodeAndClient::isMasterEligible).map(NodeAndClient::getName).forEach(excludedNodeIds::add);
1252                 assert excludedNodeIds.size() == stoppingMasters;
1253                 logger.info("adding voting config exclusions {} prior to restart/shutdown", excludedNodeIds);
1254                 try {
1255                     client().execute(AddVotingConfigExclusionsAction.INSTANCE,
1256                             new AddVotingConfigExclusionsRequest(excludedNodeIds.toArray(Strings.EMPTY_ARRAY))).get();
1257                 } catch (InterruptedException | ExecutionException e) {
1258                     throw new AssertionError("unexpected", e);
1259                 }
1260             }
1261         }
1262         return excludedNodeIds;
1263     }
1264     private void removeExclusions(Set&lt;String&gt; excludedNodeIds) {
1265         assert Thread.holdsLock(this);
1266         if (excludedNodeIds.isEmpty() == false) {
1267             logger.info("removing voting config exclusions for {} after restart/shutdown", excludedNodeIds);
1268             try {
1269                 Client client = getRandomNodeAndClient(node -&gt; excludedNodeIds.contains(node.name) == false).client();
1270                 client.execute(ClearVotingConfigExclusionsAction.INSTANCE, new ClearVotingConfigExclusionsRequest()).get();
1271             } catch (InterruptedException | ExecutionException e) {
1272                 throw new AssertionError("unexpected", e);
1273             }
1274         }
1275     }
1276     public synchronized void fullRestart(RestartCallback callback) throws Exception {
1277         int numNodesRestarted = 0;
1278         final Settings[] newNodeSettings = new Settings[nextNodeId.get()];
1279         final List&lt;NodeAndClient&gt; toStartAndPublish = new ArrayList&lt;&gt;();         for (NodeAndClient nodeAndClient : nodes.values()) {
1280             callback.doAfterNodes(numNodesRestarted++, nodeAndClient.nodeClient());
1281             logger.info("Stopping and resetting node [{}] ", nodeAndClient.name);
1282             if (activeDisruptionScheme != null) {
1283                 activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1284             }
1285             final Settings newSettings = nodeAndClient.closeForRestart(callback);
1286             newNodeSettings[nodeAndClient.nodeAndClientId()] = newSettings;
1287             toStartAndPublish.add(nodeAndClient);
1288         }
1289         callback.onAllNodesStopped();
1290         Randomness.shuffle(toStartAndPublish);
1291         for (NodeAndClient nodeAndClient : toStartAndPublish) {
1292             logger.info("recreating node [{}] ", nodeAndClient.name);
1293             nodeAndClient.recreateNode(newNodeSettings[nodeAndClient.nodeAndClientId()], () -&gt; rebuildUnicastHostFiles(toStartAndPublish));
1294         }
1295         startAndPublishNodesAndClients(toStartAndPublish);
1296         if (callback.validateClusterForming()) {
1297             validateClusterFormed();
1298         }
1299     }
1300     public String getMasterName() {
1301         return getMasterName(null);
1302     }
1303 <a name="13"></a>    public String getMasterName(@Nullable String viaNode) {
1304         try {
1305             Client client = viaNode != null ? client(viaNode) : client();
1306             return <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>client.admin().cluster().prepareState().get().getState().nodes().getMasterNode().getName();
1307         }</b></font> catch (Exception e) {
1308             logger.warn("Can't fetch cluster state", e);
1309             throw new RuntimeException("Can't get master node " + e.getMessage(), e);
1310         }
1311     }
1312     synchronized Set&lt;String&gt; allDataNodesButN(int count) {
1313         final int numNodes = numDataNodes() - count;
1314         assert size() &gt;= numNodes;
1315         Map&lt;String, NodeAndClient&gt; dataNodes =
1316             nodes
1317                 .entrySet()
1318                 .stream()
1319                 .filter(entry -&gt; DATA_NODE_PREDICATE.test(entry.getValue()))
1320                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
1321         final HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
1322         final Iterator&lt;String&gt; iterator = dataNodes.keySet().iterator();
1323         for (int i = 0; i &lt; numNodes; i++) {
1324             assert iterator.hasNext();
1325             set.add(iterator.next());
1326         }
1327         return set;
1328     }
1329     public synchronized Set&lt;String&gt; nodesInclude(String index) {
1330         if (clusterService().state().routingTable().hasIndex(index)) {
1331             List&lt;ShardRouting&gt; allShards = clusterService().state().routingTable().allShards(index);
1332             DiscoveryNodes discoveryNodes = clusterService().state().getNodes();
1333             Set&lt;String&gt; nodes = new HashSet&lt;&gt;();
1334             for (ShardRouting shardRouting : allShards) {
1335                 if (shardRouting.assignedToNode()) {
1336                     DiscoveryNode discoveryNode = discoveryNodes.get(shardRouting.currentNodeId());
1337                     nodes.add(discoveryNode.getName());
1338                 }
1339             }
1340             return nodes;
1341         }
1342         return Collections.emptySet();
1343     }
1344     private List&lt;Settings&gt; bootstrapMasterNodeWithSpecifiedIndex(List&lt;Settings&gt; allNodesSettings) {
1345         assert Thread.holdsLock(this);
1346         if (bootstrapMasterNodeIndex == -1) {             return allNodesSettings;
1347         }
1348         int currentNodeId = numMasterNodes() - 1;
1349         List&lt;Settings&gt; newSettings = new ArrayList&lt;&gt;();
1350         for (Settings settings : allNodesSettings) {
1351             if (Node.NODE_MASTER_SETTING.get(settings) == false) {
1352                 newSettings.add(settings);
1353             } else {
1354                 currentNodeId++;
1355                 if (currentNodeId != bootstrapMasterNodeIndex) {
1356                     newSettings.add(settings);
1357                 } else {
1358                     List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;();
1359                     for (Settings nodeSettings : getDataOrMasterNodeInstances(Settings.class)) {
1360                         if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1361                             nodeNames.add(Node.NODE_NAME_SETTING.get(nodeSettings));
1362                         }
1363                     }
1364                     for (Settings nodeSettings : allNodesSettings) {
1365                         if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1366                             nodeNames.add(Node.NODE_NAME_SETTING.get(nodeSettings));
1367                         }
1368                     }
1369                     newSettings.add(Settings.builder().put(settings)
1370                             .putList(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey(), nodeNames)
1371                             .build());
1372                     setBootstrapMasterNodeIndex(-1);
1373                 }
1374             }
1375         }
1376         return newSettings;
1377     }
1378     public String startNode() {
1379         return startNode(Settings.EMPTY);
1380     }
1381     public String startNode(Settings.Builder settings) {
1382         return startNode(settings.build());
1383     }
1384     public String startNode(Settings settings) {
1385         return startNodes(settings).get(0);
1386     }
1387     public List&lt;String&gt; startNodes(int numOfNodes) {
1388         return startNodes(numOfNodes, Settings.EMPTY);
1389     }
1390     public List&lt;String&gt; startNodes(int numOfNodes, Settings settings) {
1391         return startNodes(Collections.nCopies(numOfNodes, settings).toArray(new Settings[0]));
1392     }
1393     public synchronized List&lt;String&gt; startNodes(Settings... extraSettings) {
1394         final int newMasterCount = Math.toIntExact(Stream.of(extraSettings).filter(Node.NODE_MASTER_SETTING::get).count());
1395         final List&lt;NodeAndClient&gt; nodes = new ArrayList&lt;&gt;();
1396         final int prevMasterCount = getMasterNodesCount();
1397         int autoBootstrapMasterNodeIndex = autoManageMasterNodes &amp;&amp; prevMasterCount == 0 &amp;&amp; newMasterCount &gt; 0
1398             &amp;&amp; Arrays.stream(extraSettings)
1399                     .allMatch(s -&gt; Node.NODE_MASTER_SETTING.get(s) == false || ZEN2_DISCOVERY_TYPE.equals(DISCOVERY_TYPE_SETTING.get(s)))
1400             ? RandomNumbers.randomIntBetween(random, 0, newMasterCount - 1) : -1;
1401         final int numOfNodes = extraSettings.length;
1402         final int firstNodeId = nextNodeId.getAndIncrement();
1403         final List&lt;Settings&gt; settings = new ArrayList&lt;&gt;();
1404         for (int i = 0; i &lt; numOfNodes; i++) {
1405             settings.add(getNodeSettings(firstNodeId + i, random.nextLong(), extraSettings[i]));
1406         }
1407         nextNodeId.set(firstNodeId + numOfNodes);
1408         final List&lt;String&gt; initialMasterNodes = settings.stream()
1409                 .filter(Node.NODE_MASTER_SETTING::get)
1410                 .map(Node.NODE_NAME_SETTING::get)
1411                 .collect(Collectors.toList());
1412         final List&lt;Settings&gt; updatedSettings = bootstrapMasterNodeWithSpecifiedIndex(settings);
1413         for (int i = 0; i &lt; numOfNodes; i++) {
1414             final Settings nodeSettings = updatedSettings.get(i);
1415             final Builder builder = Settings.builder();
1416             if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1417                 if (autoBootstrapMasterNodeIndex == 0) {
1418                     builder.putList(INITIAL_MASTER_NODES_SETTING.getKey(), initialMasterNodes);
1419                 }
1420                 autoBootstrapMasterNodeIndex -= 1;
1421             }
1422             final NodeAndClient nodeAndClient =
1423                     buildNode(firstNodeId + i, builder.put(nodeSettings).build(), false, () -&gt; rebuildUnicastHostFiles(nodes));
1424             nodes.add(nodeAndClient);
1425         }
1426         startAndPublishNodesAndClients(nodes);
1427         if (autoManageMasterNodes) {
1428             validateClusterFormed();
1429         }
1430         return nodes.stream().map(NodeAndClient::getName).collect(Collectors.toList());
1431     }
1432     public List&lt;String&gt; startMasterOnlyNodes(int numNodes) {
1433         return startMasterOnlyNodes(numNodes, Settings.EMPTY);
1434     }
1435     public List&lt;String&gt; startMasterOnlyNodes(int numNodes, Settings settings) {
1436         Settings settings1 = Settings.builder()
1437                 .put(settings)
1438                 .put(Node.NODE_MASTER_SETTING.getKey(), true)
1439                 .put(Node.NODE_DATA_SETTING.getKey(), false)
1440                 .build();
1441         return startNodes(numNodes, settings1);
1442     }
1443     public List&lt;String&gt; startDataOnlyNodes(int numNodes) {
1444         return startDataOnlyNodes(numNodes, Settings.EMPTY);
1445 <a name="5"></a>    }
1446     public List&lt;String&gt; startDataOnlyNodes(int numNodes, Settings settings) {
1447         return <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>startNodes(
1448             numNodes,
1449             Settings.builder().put(settings).put(Node.NODE_MASTER_SETTING.getKey(), false)
1450                 .put(Node.NODE_DATA_SETTING.getKey(), true).build());
1451     }
1452     private int getMast</b></font>erNodesCount() {
1453         return (int) nodes.values().stream().filter(n -&gt; Node.NODE_MASTER_SETTING.get(n.node().settings())).count();
1454     }
1455     public String startMasterOnlyNode() {
1456         return startMasterOnlyNode(Settings.EMPTY);
1457     }
1458     public String startMasterOnlyNode(Settings settings) {
1459         Settings settings1 = Settings.builder()
1460                 .put(settings)
1461                 .put(Node.NODE_MASTER_SETTING.getKey(), true)
1462                 .put(Node.NODE_DATA_SETTING.getKey(), false)
1463                 .build();
1464         return startNode(settings1);
1465     }
1466     public String startDataOnlyNode() {
1467         return startDataOnlyNode(Settings.EMPTY);
1468     }
1469     public String startDataOnlyNode(Settings settings) {
1470         Settings settings1 = Settings.builder()
1471                 .put(settings)
1472                 .put(Node.NODE_MASTER_SETTING.getKey(), false)
1473                 .put(Node.NODE_DATA_SETTING.getKey(), true)
1474                 .build();
1475         return startNode(settings1);
1476     }
1477     private synchronized void publishNode(NodeAndClient nodeAndClient) {
1478         assert !nodeAndClient.node().isClosed();
1479         final NavigableMap&lt;String, NodeAndClient&gt; newNodes = new TreeMap&lt;&gt;(nodes);
1480         newNodes.put(nodeAndClient.name, nodeAndClient);
1481         nodes = Collections.unmodifiableNavigableMap(newNodes);
1482         applyDisruptionSchemeToNode(nodeAndClient);
1483     }
1484     public void closeNonSharedNodes(boolean wipeData) throws IOException {
1485         reset(wipeData);
1486     }
1487     @Override
1488     public int numDataNodes() {
1489         return dataNodeAndClients().size();
1490     }
1491     @Override
1492     public int numDataAndMasterNodes() {
1493         return filterNodes(nodes, DATA_NODE_PREDICATE.or(MASTER_NODE_PREDICATE)).size();
1494     }
1495     public int numMasterNodes() {
1496       return filterNodes(nodes, NodeAndClient::isMasterEligible).size();
1497     }
1498     public void setDisruptionScheme(ServiceDisruptionScheme scheme) {
1499         assert activeDisruptionScheme == null :
1500             "there is already and active disruption [" + activeDisruptionScheme + "]. call clearDisruptionScheme first";
1501         scheme.applyToCluster(this);
1502         activeDisruptionScheme = scheme;
1503     }
1504     public void clearDisruptionScheme() {
1505         clearDisruptionScheme(true);
1506     }
1507     public synchronized void clearDisruptionScheme(boolean ensureHealthyCluster) {
1508         if (activeDisruptionScheme != null) {
1509             TimeValue expectedHealingTime = activeDisruptionScheme.expectedTimeToHeal();
1510             logger.info("Clearing active scheme {}, expected healing time {}", activeDisruptionScheme, expectedHealingTime);
1511             if (ensureHealthyCluster) {
1512                 activeDisruptionScheme.removeAndEnsureHealthy(this);
1513             } else {
1514                 activeDisruptionScheme.removeFromCluster(this);
1515             }
1516         }
1517         activeDisruptionScheme = null;
1518     }
1519     private void applyDisruptionSchemeToNode(NodeAndClient nodeAndClient) {
1520         if (activeDisruptionScheme != null) {
1521             assert nodes.containsKey(nodeAndClient.name);
1522             activeDisruptionScheme.applyToNode(nodeAndClient.name, this);
1523         }
1524     }
1525     private void removeDisruptionSchemeFromNode(NodeAndClient nodeAndClient) {
1526         if (activeDisruptionScheme != null) {
1527             assert nodes.containsKey(nodeAndClient.name);
1528             activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1529         }
1530     }
1531     private Collection&lt;NodeAndClient&gt; dataNodeAndClients() {
1532         return filterNodes(nodes, DATA_NODE_PREDICATE);
1533     }
1534     private static Collection&lt;NodeAndClient&gt; filterNodes(Map&lt;String, InternalTestCluster.NodeAndClient&gt; map,
1535             Predicate&lt;NodeAndClient&gt; predicate) {
1536         return map
1537             .values()
1538             .stream()
1539             .filter(predicate)
1540             .collect(Collectors.toCollection(ArrayList::new));
1541     }
1542     private static final class NodeNamePredicate implements Predicate&lt;NodeAndClient&gt; {
1543         private final String nodeName;
1544         NodeNamePredicate(String nodeName) {
1545             this.nodeName = nodeName;
1546         }
1547         @Override
1548         public boolean test(NodeAndClient nodeAndClient) {
1549             return nodeName.equals(nodeAndClient.getName());
1550         }
1551     }
1552     synchronized String routingKeyForShard(Index index, int shard, Random random) {
1553         assertThat(shard, greaterThanOrEqualTo(0));
1554         assertThat(shard, greaterThanOrEqualTo(0));
1555         for (NodeAndClient n : nodes.values()) {
1556             Node node = n.node;
1557             IndicesService indicesService = getInstanceFromNode(IndicesService.class, node);
1558             ClusterService clusterService = getInstanceFromNode(ClusterService.class, node);
1559             IndexService indexService = indicesService.indexService(index);
1560             if (indexService != null) {
1561                 assertThat(indexService.getIndexSettings().getSettings().getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS, -1),
1562                         greaterThan(shard));
1563                 OperationRouting operationRouting = clusterService.operationRouting();
1564                 while (true) {
1565                     String routing = RandomStrings.randomAsciiLettersOfLength(random, 10);
1566                     final int targetShard = operationRouting
1567                             .indexShards(clusterService.state(), index.getName(), null, routing)
1568                             .shardId().getId();
1569                     if (shard == targetShard) {
1570                         return routing;
1571                     }
1572                 }
1573             }
1574         }
1575         fail("Could not find a node that holds " + index);
1576         return null;
1577     }
1578     @Override
1579     public Iterable&lt;Client&gt; getClients() {
1580         return () -&gt; {
1581             ensureOpen();
1582             final Iterator&lt;NodeAndClient&gt; iterator = nodes.values().iterator();
1583             return new Iterator&lt;Client&gt;() {
1584                 @Override
1585                 public boolean hasNext() {
1586                     return iterator.hasNext();
1587                 }
1588                 @Override
1589                 public Client next() {
1590                     return iterator.next().client();
1591                 }
1592                 @Override
1593                 public void remove() {
1594                     throw new UnsupportedOperationException("");
1595                 }
1596             };
1597         };
1598     }
1599     @Override
1600     public NamedWriteableRegistry getNamedWriteableRegistry() {
1601         return getInstance(NamedWriteableRegistry.class);
1602     }
1603     public static Predicate&lt;Settings&gt; nameFilter(String... nodeNames) {
1604         final Set&lt;String&gt; nodes = Set.of(nodeNames);
1605         return settings -&gt; nodes.contains(settings.get("node.name"));
1606     }
1607     public static class RestartCallback {
1608         public Settings onNodeStopped(String nodeName) throws Exception {
1609             return Settings.EMPTY;
1610         }
1611         public void doAfterNodes(int n, Client client) throws Exception {
1612         }
1613         public void onAllNodesStopped() throws Exception {
1614         }
1615         public boolean clearData(String nodeName) {
1616             return false;
1617         }
1618         public boolean validateClusterForming() { return true; }
1619     }
1620     public Settings getDefaultSettings() {
1621         return defaultSettings;
1622     }
1623     @Override
1624     public void ensureEstimatedStats() {
1625         for (NodeAndClient nodeAndClient : nodes.values()) {
1626             final String name = nodeAndClient.name;
1627             final CircuitBreakerService breakerService = getInstanceFromNode(CircuitBreakerService.class, nodeAndClient.node);
1628             try {
1629                 assertBusy(() -&gt; {
1630                     CircuitBreaker acctBreaker = breakerService.getBreaker(CircuitBreaker.ACCOUNTING);
1631                     assertThat("Accounting breaker not reset to 0 on node: " + name + ", are there still Lucene indices around?",
1632                         acctBreaker.getUsed(), equalTo(0L));
1633                 });
1634             } catch (Exception e) {
1635                 throw new AssertionError("Exception during check for accounting breaker reset to 0", e);
1636             }
1637             try {
1638                 assertBusy(() -&gt; {
1639                     CircuitBreaker reqBreaker = breakerService.getBreaker(CircuitBreaker.REQUEST);
1640                     assertThat("Request breaker not reset to 0 on node: " + name, reqBreaker.getUsed(), equalTo(0L));
1641                 });
1642             } catch (Exception e) {
1643                 throw new AssertionError("Exception during check for request breaker reset to 0", e);
1644             }
1645             try {
1646                 assertBusy(() -&gt; {
1647                     CircuitBreaker crateQueryBreaker = breakerService.getBreaker("query");
1648                     if (crateQueryBreaker != null) {
1649                         assertThat("Query breaker not reset to 0 on node: " + name,
1650                                     crateQueryBreaker.getUsed(),
1651                                     equalTo(0L));
1652                     }
1653                 });
1654             } catch (Exception e) {
1655                 throw new AssertionError("Exception during check for query breaker reset to 0", e);
1656             }
1657         }
1658     }
1659     @Override
1660     public synchronized void assertAfterTest() throws IOException {
1661         super.assertAfterTest();
1662         assertRequestsFinished();
1663         for (NodeAndClient nodeAndClient : nodes.values()) {
1664             NodeEnvironment env = nodeAndClient.node().getNodeEnvironment();
1665             Set&lt;ShardId&gt; shardIds = env.lockedShards();
1666             for (ShardId id : shardIds) {
1667                 try {
1668                     env.shardLock(id, "InternalTestCluster assert after test", TimeUnit.SECONDS.toMillis(5)).close();
1669                 } catch (ShardLockObtainFailedException ex) {
1670                     throw new AssertionError("Shard " + id + " is still locked after 5 sec waiting", ex);
1671                 }
1672             }
1673         }
1674     }
1675     private void assertRequestsFinished() {
1676         assert Thread.holdsLock(this);
1677         for (NodeAndClient nodeAndClient : nodes.values()) {
1678             CircuitBreaker inFlightRequestsBreaker = getInstance(CircuitBreakerService.class, nodeAndClient.name)
1679                 .getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);
1680             try {
1681                 assertBusy(() -&gt; {
1682                     long bytesUsed = inFlightRequestsBreaker.getUsed();
1683                     assertThat("All incoming requests on node [" + nodeAndClient.name + "] should have finished. Expected 0 but got " +
1684                         bytesUsed, bytesUsed, equalTo(0L));
1685                 });
1686             } catch (Exception e) {
1687                 logger.error("Could not assert finished requests within timeout", e);
1688                 fail("Could not assert finished requests within timeout on node [" + nodeAndClient.name + "]");
1689             }
1690         }
1691     }
1692     public int numNodes() {
1693         return nodes.size();
1694     }
1695 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
