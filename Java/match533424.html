<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RxtxChannel.java &amp; DefaultHeaders.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RxtxChannel.java &amp; DefaultHeaders.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RxtxChannel.java (34.136547%)<th>DefaultHeaders.java (4.3500514%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(106-119)<td><a href="#" name="0">(1182-1195)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(16-42)<td><a href="#" name="1">(15-43)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(57-70)<td><a href="#" name="2">(267-280)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(140-148)<td><a href="#" name="3">(1090-1098)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(93-100)<td><a href="#" name="4">(1214-1219)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(156-159)<td><a href="#" name="5">(914-917)</a><td align="center"><font color="#8d0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RxtxChannel.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.channel.rxtx;
import gnu.io.CommPort;
import gnu.io.CommPortIdentifier;
import gnu.io.SerialPort;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelPromise;
import io.netty.channel.oio.OioByteStreamChannel;
import java.net.SocketAddress;
import java.util.concurrent.TimeUnit;
import static io.netty.channel.rxtx.RxtxChannelOption.BAUD_RATE;
import static io.netty.channel.rxtx.RxtxChannelOption.DATA_BITS;
import static io.netty.channel.rxtx.RxtxChannelOption.DTR;
import static io.netty.channel.rxtx.RxtxChannelOption.PARITY_BIT;
import static io.netty.channel.rxtx.RxtxChannelOption.READ_TIMEOUT;
import static io.netty.channel.rxtx.RxtxChannelOption.RTS;
import static io.netty.channel.rxtx.RxtxChannelOption.STOP_BITS;
import static io.netty.channel.rxtx.RxtxChannelOption.WAIT_TIME;
@Depr</b></font>ecated
public class RxtxChannel extends OioByteStreamChannel {
    private static final RxtxDeviceAddress LOCAL_ADDRESS = new RxtxDeviceAddress("localhost");
    private final RxtxChannelConfig config;
    private boolean open = true;
    private RxtxDeviceAddress deviceAddress;
    private SerialPort serialPort;
    public RxtxChannel() {
<a name="2"></a>        super(null);
        config = new DefaultRxtxChannelConfig(this);
    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    public RxtxChannelConfig config() {
        return config;
    }
    @Override
    public boolean isOpen() {
        return open;
    }
    @Override
    protected AbstractUnsafe newUnsafe() {</b></font>
        return new RxtxUnsafe();
    }
    @Override
    protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
        RxtxDeviceAddress remote = (RxtxDeviceAddress) remoteAddress;
        final CommPortIdentifier cpi = CommPortIdentifier.getPortIdentifier(remote.value());
        final CommPort commPort = cpi.open(getClass().getName(), 1000);
        commPort.enableReceiveTimeout(config().getOption(READ_TIMEOUT));
        deviceAddress = remote;
        serialPort = (SerialPort) commPort;
    }
    protected void doInit() throws Exception {
        serialPort.setSerialPortParams(
            config().getOption(BAUD_RATE),
            config().getOption(DATA_BITS).value(),
            config().getOption(STOP_BITS).value(),
<a name="4"></a>            config().getOption(PARITY_BIT).value()
        );
        serialPort.setDTR(config().getOption(DTR));
        serialPort.setRTS(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>config().getOption(RTS));
        activate(serialPort.getInputStream(), serialPort.getOutputStream());
    }
    @Override
    public RxtxDeviceAddress localAddress() {
        return</b></font> (RxtxDeviceAddress) super.localAddress();
    }
<a name="0"></a>    @Override
    public RxtxDeviceAddress remoteAddress() {
        return (RxtxDeviceAddress) super.remoteAddress();
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    protected RxtxDeviceAddress localAddress0() {
        return LOCAL_ADDRESS;
    }
    @Override
    protected RxtxDeviceAddress remoteAddress0() {
        return deviceAddress;
    }
    @Override
    protected void doBind(SocketAddress localAddress) throws Exception {</b></font>
        throw new UnsupportedOperationException();
    }
    @Override
    protected void doDisconnect() throws Exception {
        doClose();
    }
    @Override
    protected void doClose() throws Exception {
        open = false;
        try {
           super.doClose();
        } finally {
            if (serialPort != null) {
                serialPort.removeEventListener();
                serialPort.close();
<a name="3"></a>                serialPort = null;
            }
        }
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Override
    protected boolean isInputShutdown() {
        return !open;
    }
    @Override
    protected ChannelFuture shutdownInput() {</b></font>
        return newFailedFuture(new UnsupportedOperationException("shutdownInput"));
    }
    private final class RxtxUnsafe extends AbstractUnsafe {
<a name="5"></a>        @Override
        public void connect(
                final SocketAddress remoteAddress,
                <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final SocketAddress localAddress, final ChannelPromise promise) {
            if (!promise.setUncancellable() || !ensureOpen(promise)) {
                return;
            }</b></font>
            try {
                final boolean wasActive = isActive();
                doConnect(remoteAddress, localAddress);
                int waitTime = config().getOption(WAIT_TIME);
                if (waitTime &gt; 0) {
                    eventLoop().schedule(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                doInit();
                                safeSetSuccess(promise);
                                if (!wasActive &amp;&amp; isActive()) {
                                    pipeline().fireChannelActive();
                                }
                            } catch (Throwable t) {
                                safeSetFailure(promise, t);
                                closeIfClosed();
                            }
                        }
                   }, waitTime, TimeUnit.MILLISECONDS);
                } else {
                    doInit();
                    safeSetSuccess(promise);
                    if (!wasActive &amp;&amp; isActive()) {
                        pipeline().fireChannelActive();
                    }
                }
            } catch (Throwable t) {
                safeSetFailure(promise, t);
                closeIfClosed();
            }
        }
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultHeaders.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec;
import io.netty.util.HashingStrategy;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;
import static io.netty.util.HashingStrategy.JAVA_HASHER;
import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;
import static io.netty.util.internal.ObjectUtil.checkNotNull;
import static java.lang.Math.max;
import static java.lang.Math.min;
publi</b></font>c class DefaultHeaders&lt;K, V, T extends Headers&lt;K, V, T&gt;&gt; implements Headers&lt;K, V, T&gt; {
    static final int HASH_CODE_SEED = 0xc2b2ae35;
    private final HeaderEntry&lt;K, V&gt;[] entries;
    protected final HeaderEntry&lt;K, V&gt; head;
    private final byte hashMask;
    private final ValueConverter&lt;V&gt; valueConverter;
    private final NameValidator&lt;K&gt; nameValidator;
    private final HashingStrategy&lt;K&gt; hashingStrategy;
    int size;
    public interface NameValidator&lt;K&gt; {
        void validateName(K name);
        @SuppressWarnings("rawtypes")
        NameValidator NOT_NULL = new NameValidator() {
            @Override
            public void validateName(Object name) {
                checkNotNull(name, "name");
            }
        };
    }
    @SuppressWarnings("unchecked")
    public DefaultHeaders(ValueConverter&lt;V&gt; valueConverter) {
        this(JAVA_HASHER, valueConverter);
    }
    @SuppressWarnings("unchecked")
    public DefaultHeaders(ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator) {
        this(JAVA_HASHER, valueConverter, nameValidator);
    }
    @SuppressWarnings("unchecked")
    public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy, ValueConverter&lt;V&gt; valueConverter) {
        this(nameHashingStrategy, valueConverter, NameValidator.NOT_NULL);
    }
    public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy,
            ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator) {
        this(nameHashingStrategy, valueConverter, nameValidator, 16);
    }
    @SuppressWarnings("unchecked")
    public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy,
            ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator, int arraySizeHint) {
        this.valueConverter = checkNotNull(valueConverter, "valueConverter");
        this.nameValidator = checkNotNull(nameValidator, "nameValidator");
        this.hashingStrategy = checkNotNull(nameHashingStrategy, "nameHashingStrategy");
        entries = new DefaultHeaders.HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];
        hashMask = (byte) (entries.length - 1);
        head = new HeaderEntry&lt;K, V&gt;();
    }
    @Override
    public V get(K name) {
        checkNotNull(name, "name");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        HeaderEntry&lt;K, V&gt; e = entries[i];
        V value = null;
        while (e != null) {
            if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
                value = e.value;
            }
            e = e.next;
        }
        return value;
    }
    @Override
    public V get(K name, V defaultValue) {
        V value = get(name);
        if (value == null) {
            return defaultValue;
        }
        return value;
    }
    @Override
    public V getAndRemove(K name) {
        int h = hashingStrategy.hashCode(name);
        return remove0(h, index(h), checkNotNull(name, "name"));
    }
    @Override
    public V getAndRemove(K name, V defaultValue) {
        V value = getAndRemove(name);
        if (value == null) {
            return defaultValue;
        }
        return value;
    }
    @Override
    public List&lt;V&gt; getAll(K name) {
        checkNotNull(name, "name");
        LinkedList&lt;V&gt; values = new LinkedList&lt;V&gt;();
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        HeaderEntry&lt;K, V&gt; e = entries[i];
        while (e != null) {
            if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
                values.addFirst(e.getValue());
            }
            e = e.next;
        }
        return values;
    }
    public Iterator&lt;V&gt; valueIterator(K name) {
        return new ValueIterator(name);
    }
    @Override
    public List&lt;V&gt; getAllAndRemove(K name) {
        List&lt;V&gt; all = getAll(name);
        remove(name);
        return all;
    }
    @Override
    public boolean contains(K name) {
        return get(name) != null;
    }
    @Override
    public boolean containsObject(K name, Object value) {
        return contains(name, valueConverter.convertObject(checkNotNull(value, "value")));
    }
    @Override
    public boolean containsBoolean(K name, boolean value) {
        return contains(name, valueConverter.convertBoolean(value));
    }
    @Override
    public boolean containsByte(K name, byte value) {
        return contains(name, valueConverter.convertByte(value));
    }
    @Override
    public boolean containsChar(K name, char value) {
        return contains(name, valueConverter.convertChar(value));
    }
    @Override
    public boolean containsShort(K name, short value) {
        return contains(name, valueConverter.convertShort(value));
    }
    @Override
    public boolean containsInt(K name, int value) {
        return contains(name, valueConverter.convertInt(value));
    }
    @Override
    public boolean containsLong(K name, long value) {
        return contains(name, valueConverter.convertLong(value));
    }
    @Override
    public boolean containsFloat(K name, float value) {
        return contains(name, valueConverter.convertFloat(value));
    }
    @Override
    public boolean containsDouble(K name, double value) {
        return contains(name, valueConverter.convertDouble(value));
    }
    @Override
    public boolean containsTimeMillis(K name, long value) {
        return contains(name, valueConverter.convertTimeMillis(value));
    }
    @SuppressWarnings("unchecked")
    @Override
    public boolean contains(K name, V value) {
        return contains(name, value, JAVA_HASHER);
    }
    public final boolean contains(K name, V value, HashingStrategy&lt;? super V&gt; valueHashingStrategy) {
        checkNotNull(name, "name");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        HeaderEntry&lt;K, V&gt; e = entries[i];
        while (e != null) {
            if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key) &amp;&amp; valueHashingStrategy.equals(value, e.value)) {
                return true;
            }
<a name="2"></a>            e = e.next;
        }
        return false;
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Override
    public int size() {
        return size;
    }
    @Override
    public boolean isEmpty() {
        return head == head.after;
    }
    @Override
    public Set&lt;K&gt; names() {</b></font>
        if (isEmpty()) {
            return Collections.emptySet();
        }
        Set&lt;K&gt; names = new LinkedHashSet&lt;K&gt;(size());
        HeaderEntry&lt;K, V&gt; e = head.after;
        while (e != head) {
            names.add(e.getKey());
            e = e.after;
        }
        return names;
    }
    @Override
    public T add(K name, V value) {
        nameValidator.validateName(name);
        checkNotNull(value, "value");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        add0(h, i, name, value);
        return thisT();
    }
    @Override
    public T add(K name, Iterable&lt;? extends V&gt; values) {
        nameValidator.validateName(name);
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        for (V v: values) {
            add0(h, i, name, v);
        }
        return thisT();
    }
    @Override
    public T add(K name, V... values) {
        nameValidator.validateName(name);
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        for (V v: values) {
            add0(h, i, name, v);
        }
        return thisT();
    }
    @Override
    public T addObject(K name, Object value) {
        return add(name, valueConverter.convertObject(checkNotNull(value, "value")));
    }
    @Override
    public T addObject(K name, Iterable&lt;?&gt; values) {
        for (Object value : values) {
            addObject(name, value);
        }
        return thisT();
    }
    @Override
    public T addObject(K name, Object... values) {
        for (Object value: values) {
            addObject(name, value);
        }
        return thisT();
    }
    @Override
    public T addInt(K name, int value) {
        return add(name, valueConverter.convertInt(value));
    }
    @Override
    public T addLong(K name, long value) {
        return add(name, valueConverter.convertLong(value));
    }
    @Override
    public T addDouble(K name, double value) {
        return add(name, valueConverter.convertDouble(value));
    }
    @Override
    public T addTimeMillis(K name, long value) {
        return add(name, valueConverter.convertTimeMillis(value));
    }
    @Override
    public T addChar(K name, char value) {
        return add(name, valueConverter.convertChar(value));
    }
    @Override
    public T addBoolean(K name, boolean value) {
        return add(name, valueConverter.convertBoolean(value));
    }
    @Override
    public T addFloat(K name, float value) {
        return add(name, valueConverter.convertFloat(value));
    }
    @Override
    public T addByte(K name, byte value) {
        return add(name, valueConverter.convertByte(value));
    }
    @Override
    public T addShort(K name, short value) {
        return add(name, valueConverter.convertShort(value));
    }
    @Override
    public T add(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        if (headers == this) {
            throw new IllegalArgumentException("can't add to itself.");
        }
        addImpl(headers);
        return thisT();
    }
    protected void addImpl(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        if (headers instanceof DefaultHeaders) {
            @SuppressWarnings("unchecked")
            final DefaultHeaders&lt;? extends K, ? extends V, T&gt; defaultHeaders =
                    (DefaultHeaders&lt;? extends K, ? extends V, T&gt;) headers;
            HeaderEntry&lt;? extends K, ? extends V&gt; e = defaultHeaders.head.after;
            if (defaultHeaders.hashingStrategy == hashingStrategy &amp;&amp;
                    defaultHeaders.nameValidator == nameValidator) {
                while (e != defaultHeaders.head) {
                    add0(e.hash, index(e.hash), e.key, e.value);
                    e = e.after;
                }
            } else {
                while (e != defaultHeaders.head) {
                    add(e.key, e.value);
                    e = e.after;
                }
            }
        } else {
            for (Entry&lt;? extends K, ? extends V&gt; header : headers) {
                add(header.getKey(), header.getValue());
            }
        }
    }
    @Override
    public T set(K name, V value) {
        nameValidator.validateName(name);
        checkNotNull(value, "value");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        remove0(h, i, name);
        add0(h, i, name, value);
        return thisT();
    }
    @Override
    public T set(K name, Iterable&lt;? extends V&gt; values) {
        nameValidator.validateName(name);
        checkNotNull(values, "values");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        remove0(h, i, name);
        for (V v: values) {
            if (v == null) {
                break;
            }
            add0(h, i, name, v);
        }
        return thisT();
    }
    @Override
    public T set(K name, V... values) {
        nameValidator.validateName(name);
        checkNotNull(values, "values");
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        remove0(h, i, name);
        for (V v: values) {
            if (v == null) {
                break;
            }
            add0(h, i, name, v);
        }
        return thisT();
    }
    @Override
    public T setObject(K name, Object value) {
        checkNotNull(value, "value");
        V convertedValue = checkNotNull(valueConverter.convertObject(value), "convertedValue");
        return set(name, convertedValue);
    }
    @Override
    public T setObject(K name, Iterable&lt;?&gt; values) {
        nameValidator.validateName(name);
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        remove0(h, i, name);
        for (Object v: values) {
            if (v == null) {
                break;
            }
            add0(h, i, name, valueConverter.convertObject(v));
        }
        return thisT();
    }
    @Override
    public T setObject(K name, Object... values) {
        nameValidator.validateName(name);
        int h = hashingStrategy.hashCode(name);
        int i = index(h);
        remove0(h, i, name);
        for (Object v: values) {
            if (v == null) {
                break;
            }
            add0(h, i, name, valueConverter.convertObject(v));
        }
        return thisT();
    }
    @Override
    public T setInt(K name, int value) {
        return set(name, valueConverter.convertInt(value));
    }
    @Override
    public T setLong(K name, long value) {
        return set(name, valueConverter.convertLong(value));
    }
    @Override
    public T setDouble(K name, double value) {
        return set(name, valueConverter.convertDouble(value));
    }
    @Override
    public T setTimeMillis(K name, long value) {
        return set(name, valueConverter.convertTimeMillis(value));
    }
    @Override
    public T setFloat(K name, float value) {
        return set(name, valueConverter.convertFloat(value));
    }
    @Override
    public T setChar(K name, char value) {
        return set(name, valueConverter.convertChar(value));
    }
    @Override
    public T setBoolean(K name, boolean value) {
        return set(name, valueConverter.convertBoolean(value));
    }
    @Override
    public T setByte(K name, byte value) {
        return set(name, valueConverter.convertByte(value));
    }
    @Override
    public T setShort(K name, short value) {
        return set(name, valueConverter.convertShort(value));
    }
    @Override
    public T set(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        if (headers != this) {
            clear();
            addImpl(headers);
        }
        return thisT();
    }
    @Override
    public T setAll(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
        if (headers != this) {
            for (K key : headers.names()) {
                remove(key);
            }
            addImpl(headers);
        }
        return thisT();
    }
    @Override
    public boolean remove(K name) {
        return getAndRemove(name) != null;
    }
    @Override
    public T clear() {
        Arrays.fill(entries, null);
        head.before = head.after = head;
        size = 0;
        return thisT();
    }
    @Override
    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
        return new HeaderIterator();
    }
    @Override
    public Boolean getBoolean(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToBoolean(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public boolean getBoolean(K name, boolean defaultValue) {
        Boolean v = getBoolean(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Byte getByte(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToByte(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public byte getByte(K name, byte defaultValue) {
        Byte v = getByte(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Character getChar(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToChar(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public char getChar(K name, char defaultValue) {
        Character v = getChar(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Short getShort(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToShort(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public short getShort(K name, short defaultValue) {
        Short v = getShort(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Integer getInt(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToInt(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public int getInt(K name, int defaultValue) {
        Integer v = getInt(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Long getLong(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToLong(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public long getLong(K name, long defaultValue) {
        Long v = getLong(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Float getFloat(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToFloat(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public float getFloat(K name, float defaultValue) {
        Float v = getFloat(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Double getDouble(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToDouble(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public double getDouble(K name, double defaultValue) {
        Double v = getDouble(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Long getTimeMillis(K name) {
        V v = get(name);
        try {
            return v != null ? valueConverter.convertToTimeMillis(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public long getTimeMillis(K name, long defaultValue) {
        Long v = getTimeMillis(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Boolean getBooleanAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToBoolean(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public boolean getBooleanAndRemove(K name, boolean defaultValue) {
        Boolean v = getBooleanAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Byte getByteAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToByte(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public byte getByteAndRemove(K name, byte defaultValue) {
        Byte v = getByteAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Character getCharAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToChar(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public char getCharAndRemove(K name, char defaultValue) {
        Character v = getCharAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Short getShortAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToShort(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public short getShortAndRemove(K name, short defaultValue) {
        Short v = getShortAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Integer getIntAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToInt(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public int getIntAndRemove(K name, int defaultValue) {
        Integer v = getIntAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Long getLongAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToLong(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public long getLongAndRemove(K name, long defaultValue) {
        Long v = getLongAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Float getFloatAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToFloat(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public float getFloatAndRemove(K name, float defaultValue) {
        Float v = getFloatAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Double getDoubleAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToDouble(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public double getDoubleAndRemove(K name, double defaultValue) {
        Double v = getDoubleAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @Override
    public Long getTimeMillisAndRemove(K name) {
        V v = getAndRemove(name);
        try {
            return v != null ? valueConverter.convertToTimeMillis(v) : null;
        } catch (RuntimeException ignore) {
            return null;
        }
    }
    @Override
    public long getTimeMillisAndRemove(K name, long defaultValue) {
        Long v = getTimeMillisAndRemove(name);
        return v != null ? v : defaultValue;
    }
    @SuppressWarnings("unchecked")
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Headers)) {
            return false;
        }
        return equals((Headers&lt;K, V, ?&gt;) o, JAVA_HASHER);
    }
    @SuppressWarnings("unchecked")
    @Override
    public int hashCode() {
        return hashCode(JAVA_HASHER);
    }
    public final boolean equals(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Headers&lt;K, V, ?&gt; h2, HashingStrategy&lt;V&gt; valueHashingStrategy) {
        if (h2.size() != size()) {
            return false;
        }</b></font>
        if (this == h2) {
            return true;
        }
        for (K name : names()) {
            List&lt;V&gt; otherValues = h2.getAll(name);
            List&lt;V&gt; values = getAll(name);
            if (otherValues.size() != values.size()) {
                return false;
            }
            for (int i = 0; i &lt; otherValues.size(); i++) {
                if (!valueHashingStrategy.equals(otherValues.get(i), values.get(i))) {
                    return false;
                }
            }
        }
        return true;
    }
    public final int hashCode(HashingStrategy&lt;V&gt; valueHashingStrategy) {
        int result = HASH_CODE_SEED;
        for (K name : names()) {
            result = 31 * result + hashingStrategy.hashCode(name);
            List&lt;V&gt; values = getAll(name);
            for (int i = 0; i &lt; values.size(); ++i) {
                result = 31 * result + valueHashingStrategy.hashCode(values.get(i));
            }
        }
        return result;
    }
    @Override
    public String toString() {
        return HeadersUtils.toString(getClass(), iterator(), size());
    }
    protected HeaderEntry&lt;K, V&gt; newHeaderEntry(int h, K name, V value, HeaderEntry&lt;K, V&gt; next) {
        return new HeaderEntry&lt;K, V&gt;(h, name, value, next, head);
    }
    protected ValueConverter&lt;V&gt; valueConverter() {
        return valueConverter;
    }
    private int index(int hash) {
        return hash &amp; hashMask;
    }
    private void add0(int h, int i, K name, V value) {
        entries[i] = newHeaderEntry(h, name, value, entries[i]);
        ++size;
    }
    private V remove0(int h, int i, K name) {
        HeaderEntry&lt;K, V&gt; e = entries[i];
        if (e == null) {
            return null;
        }
        V value = null;
        HeaderEntry&lt;K, V&gt; next = e.next;
        while (next != null) {
            if (next.hash == h &amp;&amp; hashingStrategy.equals(name, next.key)) {
                value = next.value;
                e.next = next.next;
                next.remove();
                --size;
            } else {
                e = next;
            }
            next = e.next;
        }
        e = entries[i];
        if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
            if (value == null) {
                value = e.value;
            }
            entries[i] = e.next;
            e.remove();
            --size;
        }
        return value;
    }
    HeaderEntry&lt;K, V&gt; remove0(HeaderEntry&lt;K, V&gt; entry, HeaderEntry&lt;K, V&gt; previous) {
        int i = index(entry.hash);
        HeaderEntry&lt;K, V&gt; firstEntry = entries[i];
        if (firstEntry == entry) {
            entries[i] = entry.next;
            previous = entries[i];
        } else if (previous == null) {
            previous = firstEntry;
            HeaderEntry&lt;K, V&gt; next = firstEntry.next;
            while (next != null &amp;&amp; next != entry) {
                previous = next;
                next = next.next;
            }
            assert next != null: "Entry not found in its hash bucket: " + entry;
            previous.next = entry.next;
        } else {
            previous.next = entry.next;
        }
        entry.remove();
        --size;
        return previous;
    }
    @SuppressWarnings("unchecked")
    private T thisT() {
        return (T) this;
    }
    public DefaultHeaders&lt;K, V, T&gt; copy() {
        DefaultHeaders&lt;K, V, T&gt; copy = new DefaultHeaders&lt;K, V, T&gt;(
                hashingStrategy, valueConverter, nameValidator, entries.length);
        copy.addImpl(this);
        return copy;
    }
    private final class HeaderIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {
        private HeaderEntry&lt;K, V&gt; current = head;
        @Override
        public boolean hasNext() {
            return current.after != head;
        }
        @Override
        public Entry&lt;K, V&gt; next() {
            current = current.after;
            if (current == head) {
                throw new NoSuchElementException();
            }
            return current;
        }
        @Override
        public void remove() {
            throw new UnsupportedOperationException("read only");
        }
    }
    private final class ValueIterator implements Iterator&lt;V&gt; {
        private final K name;
        private final int hash;
        private HeaderEntry&lt;K, V&gt; removalPrevious;
        private HeaderEntry&lt;K, V&gt; previous;
        private HeaderEntry&lt;K, V&gt; next;
        ValueIterator(K name) {
<a name="3"></a>            this.name = checkNotNull(name, "name");
            hash = hashingStrategy.hashCode(name);
            calculateNext(entries[index(hash)]);
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
        @Override
        public boolean hasNext() {
            return next != null;
        }
        @Override
        public V next() {</b></font>
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            if (previous != null) {
                removalPrevious = previous;
            }
            previous = next;
            calculateNext(next.next);
            return previous.value;
        }
        @Override
        public void remove() {
            if (previous == null) {
                throw new IllegalStateException();
            }
            removalPrevious = remove0(previous, removalPrevious);
            previous = null;
        }
        private void calculateNext(HeaderEntry&lt;K, V&gt; entry) {
            while (entry != null) {
                if (entry.hash == hash &amp;&amp; hashingStrategy.equals(name, entry.key)) {
                    next = entry;
                    return;
                }
                entry = entry.next;
            }
            next = null;
        }
    }
    protected static class HeaderEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
        protected final int hash;
        protected final K key;
        protected V value;
        protected HeaderEntry&lt;K, V&gt; next;
        protected HeaderEntry&lt;K, V&gt; before, after;
        protected HeaderEntry(int hash, K key) {
            this.hash = hash;
            this.key = key;
        }
        HeaderEntry(int hash, K key, V value, HeaderEntry&lt;K, V&gt; next, HeaderEntry&lt;K, V&gt; head) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
            after = head;
            before = head.before;
            pointNeighborsToThis();
        }
        HeaderEntry() {
            hash = -1;
            key = null;
            before = after = this;
        }
        protected final void pointNeighborsToThis() {
            before.after = this;
            after.before = this;
        }
        public final HeaderEntry&lt;K, V&gt; before() {
            return before;
        }
        public final HeaderEntry&lt;K, V&gt; after() {
            return after;
        }
<a name="0"></a>        protected void remove() {
            before.after = after;
            after.before = before;
        <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
        @Override
        public final K getKey() {
            return key;
        }
        @Override
        public final V getValue() {
            return value;
        }
        @Override
        public final V setValue(V value) {</b></font>
            checkNotNull(value, "value");
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }
        @Override
        public final String toString() {
            return key.toString() + '=' + value.toString();
        }
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
<a name="4"></a>            }
            Map.Entry&lt;?, ?&gt; other = (Map.Entry&lt;?, ?&gt;) o;
            return (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))  &amp;&amp;
                   (<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));
        }
        @Override
        public int hashCode() {
            return</b></font> (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());
        }
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
