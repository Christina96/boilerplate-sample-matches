<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RxtxChannel.java &amp; DefaultHeaders.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RxtxChannel.java &amp; DefaultHeaders.java
      </h3>
<h1 align="center">
        7.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RxtxChannel.java (34.136547%)<th>DefaultHeaders.java (4.3500514%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(106-119)<td><a href="#" name="0">(1182-1195)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(16-42)<td><a href="#" name="1">(15-43)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(57-70)<td><a href="#" name="2">(267-280)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(140-148)<td><a href="#" name="3">(1090-1098)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(93-100)<td><a href="#" name="4">(1214-1219)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(156-159)<td><a href="#" name="5">(914-917)</a><td align="center"><font color="#8d0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RxtxChannel.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.channel.rxtx;
2 import gnu.io.CommPort;
3 import gnu.io.CommPortIdentifier;
4 import gnu.io.SerialPort;
5 import io.netty.channel.ChannelFuture;
6 import io.netty.channel.ChannelPromise;
7 import io.netty.channel.oio.OioByteStreamChannel;
8 import java.net.SocketAddress;
9 import java.util.concurrent.TimeUnit;
10 import static io.netty.channel.rxtx.RxtxChannelOption.BAUD_RATE;
11 import static io.netty.channel.rxtx.RxtxChannelOption.DATA_BITS;
12 import static io.netty.channel.rxtx.RxtxChannelOption.DTR;
13 import static io.netty.channel.rxtx.RxtxChannelOption.PARITY_BIT;
14 import static io.netty.channel.rxtx.RxtxChannelOption.READ_TIMEOUT;
15 import static io.netty.channel.rxtx.RxtxChannelOption.RTS;
16 import static io.netty.channel.rxtx.RxtxChannelOption.STOP_BITS;
17 import static io.netty.channel.rxtx.RxtxChannelOption.WAIT_TIME;
18 @Depr</b></font>ecated
19 public class RxtxChannel extends OioByteStreamChannel {
20     private static final RxtxDeviceAddress LOCAL_ADDRESS = new RxtxDeviceAddress("localhost");
21     private final RxtxChannelConfig config;
22     private boolean open = true;
23     private RxtxDeviceAddress deviceAddress;
24     private SerialPort serialPort;
25     public RxtxChannel() {
26 <a name="2"></a>        super(null);
27         config = new DefaultRxtxChannelConfig(this);
28     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
29     @Override
30     public RxtxChannelConfig config() {
31         return config;
32     }
33     @Override
34     public boolean isOpen() {
35         return open;
36     }
37     @Override
38     protected AbstractUnsafe newUnsafe() {</b></font>
39         return new RxtxUnsafe();
40     }
41     @Override
42     protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
43         RxtxDeviceAddress remote = (RxtxDeviceAddress) remoteAddress;
44         final CommPortIdentifier cpi = CommPortIdentifier.getPortIdentifier(remote.value());
45         final CommPort commPort = cpi.open(getClass().getName(), 1000);
46         commPort.enableReceiveTimeout(config().getOption(READ_TIMEOUT));
47         deviceAddress = remote;
48         serialPort = (SerialPort) commPort;
49     }
50     protected void doInit() throws Exception {
51         serialPort.setSerialPortParams(
52             config().getOption(BAUD_RATE),
53             config().getOption(DATA_BITS).value(),
54             config().getOption(STOP_BITS).value(),
55 <a name="4"></a>            config().getOption(PARITY_BIT).value()
56         );
57         serialPort.setDTR(config().getOption(DTR));
58         serialPort.setRTS(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>config().getOption(RTS));
59         activate(serialPort.getInputStream(), serialPort.getOutputStream());
60     }
61     @Override
62     public RxtxDeviceAddress localAddress() {
63         return</b></font> (RxtxDeviceAddress) super.localAddress();
64     }
65 <a name="0"></a>    @Override
66     public RxtxDeviceAddress remoteAddress() {
67         return (RxtxDeviceAddress) super.remoteAddress();
68     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
69     @Override
70     protected RxtxDeviceAddress localAddress0() {
71         return LOCAL_ADDRESS;
72     }
73     @Override
74     protected RxtxDeviceAddress remoteAddress0() {
75         return deviceAddress;
76     }
77     @Override
78     protected void doBind(SocketAddress localAddress) throws Exception {</b></font>
79         throw new UnsupportedOperationException();
80     }
81     @Override
82     protected void doDisconnect() throws Exception {
83         doClose();
84     }
85     @Override
86     protected void doClose() throws Exception {
87         open = false;
88         try {
89            super.doClose();
90         } finally {
91             if (serialPort != null) {
92                 serialPort.removeEventListener();
93                 serialPort.close();
94 <a name="3"></a>                serialPort = null;
95             }
96         }
97     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
98     @Override
99     protected boolean isInputShutdown() {
100         return !open;
101     }
102     @Override
103     protected ChannelFuture shutdownInput() {</b></font>
104         return newFailedFuture(new UnsupportedOperationException("shutdownInput"));
105     }
106     private final class RxtxUnsafe extends AbstractUnsafe {
107 <a name="5"></a>        @Override
108         public void connect(
109                 final SocketAddress remoteAddress,
110                 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final SocketAddress localAddress, final ChannelPromise promise) {
111             if (!promise.setUncancellable() || !ensureOpen(promise)) {
112                 return;
113             }</b></font>
114             try {
115                 final boolean wasActive = isActive();
116                 doConnect(remoteAddress, localAddress);
117                 int waitTime = config().getOption(WAIT_TIME);
118                 if (waitTime &gt; 0) {
119                     eventLoop().schedule(new Runnable() {
120                         @Override
121                         public void run() {
122                             try {
123                                 doInit();
124                                 safeSetSuccess(promise);
125                                 if (!wasActive &amp;&amp; isActive()) {
126                                     pipeline().fireChannelActive();
127                                 }
128                             } catch (Throwable t) {
129                                 safeSetFailure(promise, t);
130                                 closeIfClosed();
131                             }
132                         }
133                    }, waitTime, TimeUnit.MILLISECONDS);
134                 } else {
135                     doInit();
136                     safeSetSuccess(promise);
137                     if (!wasActive &amp;&amp; isActive()) {
138                         pipeline().fireChannelActive();
139                     }
140                 }
141             } catch (Throwable t) {
142                 safeSetFailure(promise, t);
143                 closeIfClosed();
144             }
145         }
146     }
147 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultHeaders.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec;
2 import io.netty.util.HashingStrategy;
3 import java.util.Arrays;
4 import java.util.Collections;
5 import java.util.Iterator;
6 import java.util.LinkedHashSet;
7 import java.util.LinkedList;
8 import java.util.List;
9 import java.util.Map;
10 import java.util.Map.Entry;
11 import java.util.NoSuchElementException;
12 import java.util.Set;
13 import static io.netty.util.HashingStrategy.JAVA_HASHER;
14 import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;
15 import static io.netty.util.internal.ObjectUtil.checkNotNull;
16 import static java.lang.Math.max;
17 import static java.lang.Math.min;
18 publi</b></font>c class DefaultHeaders&lt;K, V, T extends Headers&lt;K, V, T&gt;&gt; implements Headers&lt;K, V, T&gt; {
19     static final int HASH_CODE_SEED = 0xc2b2ae35;
20     private final HeaderEntry&lt;K, V&gt;[] entries;
21     protected final HeaderEntry&lt;K, V&gt; head;
22     private final byte hashMask;
23     private final ValueConverter&lt;V&gt; valueConverter;
24     private final NameValidator&lt;K&gt; nameValidator;
25     private final HashingStrategy&lt;K&gt; hashingStrategy;
26     int size;
27     public interface NameValidator&lt;K&gt; {
28         void validateName(K name);
29         @SuppressWarnings("rawtypes")
30         NameValidator NOT_NULL = new NameValidator() {
31             @Override
32             public void validateName(Object name) {
33                 checkNotNull(name, "name");
34             }
35         };
36     }
37     @SuppressWarnings("unchecked")
38     public DefaultHeaders(ValueConverter&lt;V&gt; valueConverter) {
39         this(JAVA_HASHER, valueConverter);
40     }
41     @SuppressWarnings("unchecked")
42     public DefaultHeaders(ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator) {
43         this(JAVA_HASHER, valueConverter, nameValidator);
44     }
45     @SuppressWarnings("unchecked")
46     public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy, ValueConverter&lt;V&gt; valueConverter) {
47         this(nameHashingStrategy, valueConverter, NameValidator.NOT_NULL);
48     }
49     public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy,
50             ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator) {
51         this(nameHashingStrategy, valueConverter, nameValidator, 16);
52     }
53     @SuppressWarnings("unchecked")
54     public DefaultHeaders(HashingStrategy&lt;K&gt; nameHashingStrategy,
55             ValueConverter&lt;V&gt; valueConverter, NameValidator&lt;K&gt; nameValidator, int arraySizeHint) {
56         this.valueConverter = checkNotNull(valueConverter, "valueConverter");
57         this.nameValidator = checkNotNull(nameValidator, "nameValidator");
58         this.hashingStrategy = checkNotNull(nameHashingStrategy, "nameHashingStrategy");
59         entries = new DefaultHeaders.HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];
60         hashMask = (byte) (entries.length - 1);
61         head = new HeaderEntry&lt;K, V&gt;();
62     }
63     @Override
64     public V get(K name) {
65         checkNotNull(name, "name");
66         int h = hashingStrategy.hashCode(name);
67         int i = index(h);
68         HeaderEntry&lt;K, V&gt; e = entries[i];
69         V value = null;
70         while (e != null) {
71             if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
72                 value = e.value;
73             }
74             e = e.next;
75         }
76         return value;
77     }
78     @Override
79     public V get(K name, V defaultValue) {
80         V value = get(name);
81         if (value == null) {
82             return defaultValue;
83         }
84         return value;
85     }
86     @Override
87     public V getAndRemove(K name) {
88         int h = hashingStrategy.hashCode(name);
89         return remove0(h, index(h), checkNotNull(name, "name"));
90     }
91     @Override
92     public V getAndRemove(K name, V defaultValue) {
93         V value = getAndRemove(name);
94         if (value == null) {
95             return defaultValue;
96         }
97         return value;
98     }
99     @Override
100     public List&lt;V&gt; getAll(K name) {
101         checkNotNull(name, "name");
102         LinkedList&lt;V&gt; values = new LinkedList&lt;V&gt;();
103         int h = hashingStrategy.hashCode(name);
104         int i = index(h);
105         HeaderEntry&lt;K, V&gt; e = entries[i];
106         while (e != null) {
107             if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
108                 values.addFirst(e.getValue());
109             }
110             e = e.next;
111         }
112         return values;
113     }
114     public Iterator&lt;V&gt; valueIterator(K name) {
115         return new ValueIterator(name);
116     }
117     @Override
118     public List&lt;V&gt; getAllAndRemove(K name) {
119         List&lt;V&gt; all = getAll(name);
120         remove(name);
121         return all;
122     }
123     @Override
124     public boolean contains(K name) {
125         return get(name) != null;
126     }
127     @Override
128     public boolean containsObject(K name, Object value) {
129         return contains(name, valueConverter.convertObject(checkNotNull(value, "value")));
130     }
131     @Override
132     public boolean containsBoolean(K name, boolean value) {
133         return contains(name, valueConverter.convertBoolean(value));
134     }
135     @Override
136     public boolean containsByte(K name, byte value) {
137         return contains(name, valueConverter.convertByte(value));
138     }
139     @Override
140     public boolean containsChar(K name, char value) {
141         return contains(name, valueConverter.convertChar(value));
142     }
143     @Override
144     public boolean containsShort(K name, short value) {
145         return contains(name, valueConverter.convertShort(value));
146     }
147     @Override
148     public boolean containsInt(K name, int value) {
149         return contains(name, valueConverter.convertInt(value));
150     }
151     @Override
152     public boolean containsLong(K name, long value) {
153         return contains(name, valueConverter.convertLong(value));
154     }
155     @Override
156     public boolean containsFloat(K name, float value) {
157         return contains(name, valueConverter.convertFloat(value));
158     }
159     @Override
160     public boolean containsDouble(K name, double value) {
161         return contains(name, valueConverter.convertDouble(value));
162     }
163     @Override
164     public boolean containsTimeMillis(K name, long value) {
165         return contains(name, valueConverter.convertTimeMillis(value));
166     }
167     @SuppressWarnings("unchecked")
168     @Override
169     public boolean contains(K name, V value) {
170         return contains(name, value, JAVA_HASHER);
171     }
172     public final boolean contains(K name, V value, HashingStrategy&lt;? super V&gt; valueHashingStrategy) {
173         checkNotNull(name, "name");
174         int h = hashingStrategy.hashCode(name);
175         int i = index(h);
176         HeaderEntry&lt;K, V&gt; e = entries[i];
177         while (e != null) {
178             if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key) &amp;&amp; valueHashingStrategy.equals(value, e.value)) {
179                 return true;
180             }
181 <a name="2"></a>            e = e.next;
182         }
183         return false;
184     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
185     @Override
186     public int size() {
187         return size;
188     }
189     @Override
190     public boolean isEmpty() {
191         return head == head.after;
192     }
193     @Override
194     public Set&lt;K&gt; names() {</b></font>
195         if (isEmpty()) {
196             return Collections.emptySet();
197         }
198         Set&lt;K&gt; names = new LinkedHashSet&lt;K&gt;(size());
199         HeaderEntry&lt;K, V&gt; e = head.after;
200         while (e != head) {
201             names.add(e.getKey());
202             e = e.after;
203         }
204         return names;
205     }
206     @Override
207     public T add(K name, V value) {
208         nameValidator.validateName(name);
209         checkNotNull(value, "value");
210         int h = hashingStrategy.hashCode(name);
211         int i = index(h);
212         add0(h, i, name, value);
213         return thisT();
214     }
215     @Override
216     public T add(K name, Iterable&lt;? extends V&gt; values) {
217         nameValidator.validateName(name);
218         int h = hashingStrategy.hashCode(name);
219         int i = index(h);
220         for (V v: values) {
221             add0(h, i, name, v);
222         }
223         return thisT();
224     }
225     @Override
226     public T add(K name, V... values) {
227         nameValidator.validateName(name);
228         int h = hashingStrategy.hashCode(name);
229         int i = index(h);
230         for (V v: values) {
231             add0(h, i, name, v);
232         }
233         return thisT();
234     }
235     @Override
236     public T addObject(K name, Object value) {
237         return add(name, valueConverter.convertObject(checkNotNull(value, "value")));
238     }
239     @Override
240     public T addObject(K name, Iterable&lt;?&gt; values) {
241         for (Object value : values) {
242             addObject(name, value);
243         }
244         return thisT();
245     }
246     @Override
247     public T addObject(K name, Object... values) {
248         for (Object value: values) {
249             addObject(name, value);
250         }
251         return thisT();
252     }
253     @Override
254     public T addInt(K name, int value) {
255         return add(name, valueConverter.convertInt(value));
256     }
257     @Override
258     public T addLong(K name, long value) {
259         return add(name, valueConverter.convertLong(value));
260     }
261     @Override
262     public T addDouble(K name, double value) {
263         return add(name, valueConverter.convertDouble(value));
264     }
265     @Override
266     public T addTimeMillis(K name, long value) {
267         return add(name, valueConverter.convertTimeMillis(value));
268     }
269     @Override
270     public T addChar(K name, char value) {
271         return add(name, valueConverter.convertChar(value));
272     }
273     @Override
274     public T addBoolean(K name, boolean value) {
275         return add(name, valueConverter.convertBoolean(value));
276     }
277     @Override
278     public T addFloat(K name, float value) {
279         return add(name, valueConverter.convertFloat(value));
280     }
281     @Override
282     public T addByte(K name, byte value) {
283         return add(name, valueConverter.convertByte(value));
284     }
285     @Override
286     public T addShort(K name, short value) {
287         return add(name, valueConverter.convertShort(value));
288     }
289     @Override
290     public T add(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
291         if (headers == this) {
292             throw new IllegalArgumentException("can't add to itself.");
293         }
294         addImpl(headers);
295         return thisT();
296     }
297     protected void addImpl(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
298         if (headers instanceof DefaultHeaders) {
299             @SuppressWarnings("unchecked")
300             final DefaultHeaders&lt;? extends K, ? extends V, T&gt; defaultHeaders =
301                     (DefaultHeaders&lt;? extends K, ? extends V, T&gt;) headers;
302             HeaderEntry&lt;? extends K, ? extends V&gt; e = defaultHeaders.head.after;
303             if (defaultHeaders.hashingStrategy == hashingStrategy &amp;&amp;
304                     defaultHeaders.nameValidator == nameValidator) {
305                 while (e != defaultHeaders.head) {
306                     add0(e.hash, index(e.hash), e.key, e.value);
307                     e = e.after;
308                 }
309             } else {
310                 while (e != defaultHeaders.head) {
311                     add(e.key, e.value);
312                     e = e.after;
313                 }
314             }
315         } else {
316             for (Entry&lt;? extends K, ? extends V&gt; header : headers) {
317                 add(header.getKey(), header.getValue());
318             }
319         }
320     }
321     @Override
322     public T set(K name, V value) {
323         nameValidator.validateName(name);
324         checkNotNull(value, "value");
325         int h = hashingStrategy.hashCode(name);
326         int i = index(h);
327         remove0(h, i, name);
328         add0(h, i, name, value);
329         return thisT();
330     }
331     @Override
332     public T set(K name, Iterable&lt;? extends V&gt; values) {
333         nameValidator.validateName(name);
334         checkNotNull(values, "values");
335         int h = hashingStrategy.hashCode(name);
336         int i = index(h);
337         remove0(h, i, name);
338         for (V v: values) {
339             if (v == null) {
340                 break;
341             }
342             add0(h, i, name, v);
343         }
344         return thisT();
345     }
346     @Override
347     public T set(K name, V... values) {
348         nameValidator.validateName(name);
349         checkNotNull(values, "values");
350         int h = hashingStrategy.hashCode(name);
351         int i = index(h);
352         remove0(h, i, name);
353         for (V v: values) {
354             if (v == null) {
355                 break;
356             }
357             add0(h, i, name, v);
358         }
359         return thisT();
360     }
361     @Override
362     public T setObject(K name, Object value) {
363         checkNotNull(value, "value");
364         V convertedValue = checkNotNull(valueConverter.convertObject(value), "convertedValue");
365         return set(name, convertedValue);
366     }
367     @Override
368     public T setObject(K name, Iterable&lt;?&gt; values) {
369         nameValidator.validateName(name);
370         int h = hashingStrategy.hashCode(name);
371         int i = index(h);
372         remove0(h, i, name);
373         for (Object v: values) {
374             if (v == null) {
375                 break;
376             }
377             add0(h, i, name, valueConverter.convertObject(v));
378         }
379         return thisT();
380     }
381     @Override
382     public T setObject(K name, Object... values) {
383         nameValidator.validateName(name);
384         int h = hashingStrategy.hashCode(name);
385         int i = index(h);
386         remove0(h, i, name);
387         for (Object v: values) {
388             if (v == null) {
389                 break;
390             }
391             add0(h, i, name, valueConverter.convertObject(v));
392         }
393         return thisT();
394     }
395     @Override
396     public T setInt(K name, int value) {
397         return set(name, valueConverter.convertInt(value));
398     }
399     @Override
400     public T setLong(K name, long value) {
401         return set(name, valueConverter.convertLong(value));
402     }
403     @Override
404     public T setDouble(K name, double value) {
405         return set(name, valueConverter.convertDouble(value));
406     }
407     @Override
408     public T setTimeMillis(K name, long value) {
409         return set(name, valueConverter.convertTimeMillis(value));
410     }
411     @Override
412     public T setFloat(K name, float value) {
413         return set(name, valueConverter.convertFloat(value));
414     }
415     @Override
416     public T setChar(K name, char value) {
417         return set(name, valueConverter.convertChar(value));
418     }
419     @Override
420     public T setBoolean(K name, boolean value) {
421         return set(name, valueConverter.convertBoolean(value));
422     }
423     @Override
424     public T setByte(K name, byte value) {
425         return set(name, valueConverter.convertByte(value));
426     }
427     @Override
428     public T setShort(K name, short value) {
429         return set(name, valueConverter.convertShort(value));
430     }
431     @Override
432     public T set(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
433         if (headers != this) {
434             clear();
435             addImpl(headers);
436         }
437         return thisT();
438     }
439     @Override
440     public T setAll(Headers&lt;? extends K, ? extends V, ?&gt; headers) {
441         if (headers != this) {
442             for (K key : headers.names()) {
443                 remove(key);
444             }
445             addImpl(headers);
446         }
447         return thisT();
448     }
449     @Override
450     public boolean remove(K name) {
451         return getAndRemove(name) != null;
452     }
453     @Override
454     public T clear() {
455         Arrays.fill(entries, null);
456         head.before = head.after = head;
457         size = 0;
458         return thisT();
459     }
460     @Override
461     public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
462         return new HeaderIterator();
463     }
464     @Override
465     public Boolean getBoolean(K name) {
466         V v = get(name);
467         try {
468             return v != null ? valueConverter.convertToBoolean(v) : null;
469         } catch (RuntimeException ignore) {
470             return null;
471         }
472     }
473     @Override
474     public boolean getBoolean(K name, boolean defaultValue) {
475         Boolean v = getBoolean(name);
476         return v != null ? v : defaultValue;
477     }
478     @Override
479     public Byte getByte(K name) {
480         V v = get(name);
481         try {
482             return v != null ? valueConverter.convertToByte(v) : null;
483         } catch (RuntimeException ignore) {
484             return null;
485         }
486     }
487     @Override
488     public byte getByte(K name, byte defaultValue) {
489         Byte v = getByte(name);
490         return v != null ? v : defaultValue;
491     }
492     @Override
493     public Character getChar(K name) {
494         V v = get(name);
495         try {
496             return v != null ? valueConverter.convertToChar(v) : null;
497         } catch (RuntimeException ignore) {
498             return null;
499         }
500     }
501     @Override
502     public char getChar(K name, char defaultValue) {
503         Character v = getChar(name);
504         return v != null ? v : defaultValue;
505     }
506     @Override
507     public Short getShort(K name) {
508         V v = get(name);
509         try {
510             return v != null ? valueConverter.convertToShort(v) : null;
511         } catch (RuntimeException ignore) {
512             return null;
513         }
514     }
515     @Override
516     public short getShort(K name, short defaultValue) {
517         Short v = getShort(name);
518         return v != null ? v : defaultValue;
519     }
520     @Override
521     public Integer getInt(K name) {
522         V v = get(name);
523         try {
524             return v != null ? valueConverter.convertToInt(v) : null;
525         } catch (RuntimeException ignore) {
526             return null;
527         }
528     }
529     @Override
530     public int getInt(K name, int defaultValue) {
531         Integer v = getInt(name);
532         return v != null ? v : defaultValue;
533     }
534     @Override
535     public Long getLong(K name) {
536         V v = get(name);
537         try {
538             return v != null ? valueConverter.convertToLong(v) : null;
539         } catch (RuntimeException ignore) {
540             return null;
541         }
542     }
543     @Override
544     public long getLong(K name, long defaultValue) {
545         Long v = getLong(name);
546         return v != null ? v : defaultValue;
547     }
548     @Override
549     public Float getFloat(K name) {
550         V v = get(name);
551         try {
552             return v != null ? valueConverter.convertToFloat(v) : null;
553         } catch (RuntimeException ignore) {
554             return null;
555         }
556     }
557     @Override
558     public float getFloat(K name, float defaultValue) {
559         Float v = getFloat(name);
560         return v != null ? v : defaultValue;
561     }
562     @Override
563     public Double getDouble(K name) {
564         V v = get(name);
565         try {
566             return v != null ? valueConverter.convertToDouble(v) : null;
567         } catch (RuntimeException ignore) {
568             return null;
569         }
570     }
571     @Override
572     public double getDouble(K name, double defaultValue) {
573         Double v = getDouble(name);
574         return v != null ? v : defaultValue;
575     }
576     @Override
577     public Long getTimeMillis(K name) {
578         V v = get(name);
579         try {
580             return v != null ? valueConverter.convertToTimeMillis(v) : null;
581         } catch (RuntimeException ignore) {
582             return null;
583         }
584     }
585     @Override
586     public long getTimeMillis(K name, long defaultValue) {
587         Long v = getTimeMillis(name);
588         return v != null ? v : defaultValue;
589     }
590     @Override
591     public Boolean getBooleanAndRemove(K name) {
592         V v = getAndRemove(name);
593         try {
594             return v != null ? valueConverter.convertToBoolean(v) : null;
595         } catch (RuntimeException ignore) {
596             return null;
597         }
598     }
599     @Override
600     public boolean getBooleanAndRemove(K name, boolean defaultValue) {
601         Boolean v = getBooleanAndRemove(name);
602         return v != null ? v : defaultValue;
603     }
604     @Override
605     public Byte getByteAndRemove(K name) {
606         V v = getAndRemove(name);
607         try {
608             return v != null ? valueConverter.convertToByte(v) : null;
609         } catch (RuntimeException ignore) {
610             return null;
611         }
612     }
613     @Override
614     public byte getByteAndRemove(K name, byte defaultValue) {
615         Byte v = getByteAndRemove(name);
616         return v != null ? v : defaultValue;
617     }
618     @Override
619     public Character getCharAndRemove(K name) {
620         V v = getAndRemove(name);
621         try {
622             return v != null ? valueConverter.convertToChar(v) : null;
623         } catch (RuntimeException ignore) {
624             return null;
625         }
626     }
627     @Override
628     public char getCharAndRemove(K name, char defaultValue) {
629         Character v = getCharAndRemove(name);
630         return v != null ? v : defaultValue;
631     }
632     @Override
633     public Short getShortAndRemove(K name) {
634         V v = getAndRemove(name);
635         try {
636             return v != null ? valueConverter.convertToShort(v) : null;
637         } catch (RuntimeException ignore) {
638             return null;
639         }
640     }
641     @Override
642     public short getShortAndRemove(K name, short defaultValue) {
643         Short v = getShortAndRemove(name);
644         return v != null ? v : defaultValue;
645     }
646     @Override
647     public Integer getIntAndRemove(K name) {
648         V v = getAndRemove(name);
649         try {
650             return v != null ? valueConverter.convertToInt(v) : null;
651         } catch (RuntimeException ignore) {
652             return null;
653         }
654     }
655     @Override
656     public int getIntAndRemove(K name, int defaultValue) {
657         Integer v = getIntAndRemove(name);
658         return v != null ? v : defaultValue;
659     }
660     @Override
661     public Long getLongAndRemove(K name) {
662         V v = getAndRemove(name);
663         try {
664             return v != null ? valueConverter.convertToLong(v) : null;
665         } catch (RuntimeException ignore) {
666             return null;
667         }
668     }
669     @Override
670     public long getLongAndRemove(K name, long defaultValue) {
671         Long v = getLongAndRemove(name);
672         return v != null ? v : defaultValue;
673     }
674     @Override
675     public Float getFloatAndRemove(K name) {
676         V v = getAndRemove(name);
677         try {
678             return v != null ? valueConverter.convertToFloat(v) : null;
679         } catch (RuntimeException ignore) {
680             return null;
681         }
682     }
683     @Override
684     public float getFloatAndRemove(K name, float defaultValue) {
685         Float v = getFloatAndRemove(name);
686         return v != null ? v : defaultValue;
687     }
688     @Override
689     public Double getDoubleAndRemove(K name) {
690         V v = getAndRemove(name);
691         try {
692             return v != null ? valueConverter.convertToDouble(v) : null;
693         } catch (RuntimeException ignore) {
694             return null;
695         }
696     }
697     @Override
698     public double getDoubleAndRemove(K name, double defaultValue) {
699         Double v = getDoubleAndRemove(name);
700         return v != null ? v : defaultValue;
701     }
702     @Override
703     public Long getTimeMillisAndRemove(K name) {
704         V v = getAndRemove(name);
705         try {
706             return v != null ? valueConverter.convertToTimeMillis(v) : null;
707         } catch (RuntimeException ignore) {
708             return null;
709         }
710     }
711     @Override
712     public long getTimeMillisAndRemove(K name, long defaultValue) {
713         Long v = getTimeMillisAndRemove(name);
714         return v != null ? v : defaultValue;
715     }
716     @SuppressWarnings("unchecked")
717     @Override
718     public boolean equals(Object o) {
719         if (!(o instanceof Headers)) {
720             return false;
721         }
722         return equals((Headers&lt;K, V, ?&gt;) o, JAVA_HASHER);
723     }
724     @SuppressWarnings("unchecked")
725     @Override
726     public int hashCode() {
727         return hashCode(JAVA_HASHER);
728     }
729     public final boolean equals(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Headers&lt;K, V, ?&gt; h2, HashingStrategy&lt;V&gt; valueHashingStrategy) {
730         if (h2.size() != size()) {
731             return false;
732         }</b></font>
733         if (this == h2) {
734             return true;
735         }
736         for (K name : names()) {
737             List&lt;V&gt; otherValues = h2.getAll(name);
738             List&lt;V&gt; values = getAll(name);
739             if (otherValues.size() != values.size()) {
740                 return false;
741             }
742             for (int i = 0; i &lt; otherValues.size(); i++) {
743                 if (!valueHashingStrategy.equals(otherValues.get(i), values.get(i))) {
744                     return false;
745                 }
746             }
747         }
748         return true;
749     }
750     public final int hashCode(HashingStrategy&lt;V&gt; valueHashingStrategy) {
751         int result = HASH_CODE_SEED;
752         for (K name : names()) {
753             result = 31 * result + hashingStrategy.hashCode(name);
754             List&lt;V&gt; values = getAll(name);
755             for (int i = 0; i &lt; values.size(); ++i) {
756                 result = 31 * result + valueHashingStrategy.hashCode(values.get(i));
757             }
758         }
759         return result;
760     }
761     @Override
762     public String toString() {
763         return HeadersUtils.toString(getClass(), iterator(), size());
764     }
765     protected HeaderEntry&lt;K, V&gt; newHeaderEntry(int h, K name, V value, HeaderEntry&lt;K, V&gt; next) {
766         return new HeaderEntry&lt;K, V&gt;(h, name, value, next, head);
767     }
768     protected ValueConverter&lt;V&gt; valueConverter() {
769         return valueConverter;
770     }
771     private int index(int hash) {
772         return hash &amp; hashMask;
773     }
774     private void add0(int h, int i, K name, V value) {
775         entries[i] = newHeaderEntry(h, name, value, entries[i]);
776         ++size;
777     }
778     private V remove0(int h, int i, K name) {
779         HeaderEntry&lt;K, V&gt; e = entries[i];
780         if (e == null) {
781             return null;
782         }
783         V value = null;
784         HeaderEntry&lt;K, V&gt; next = e.next;
785         while (next != null) {
786             if (next.hash == h &amp;&amp; hashingStrategy.equals(name, next.key)) {
787                 value = next.value;
788                 e.next = next.next;
789                 next.remove();
790                 --size;
791             } else {
792                 e = next;
793             }
794             next = e.next;
795         }
796         e = entries[i];
797         if (e.hash == h &amp;&amp; hashingStrategy.equals(name, e.key)) {
798             if (value == null) {
799                 value = e.value;
800             }
801             entries[i] = e.next;
802             e.remove();
803             --size;
804         }
805         return value;
806     }
807     HeaderEntry&lt;K, V&gt; remove0(HeaderEntry&lt;K, V&gt; entry, HeaderEntry&lt;K, V&gt; previous) {
808         int i = index(entry.hash);
809         HeaderEntry&lt;K, V&gt; firstEntry = entries[i];
810         if (firstEntry == entry) {
811             entries[i] = entry.next;
812             previous = entries[i];
813         } else if (previous == null) {
814             previous = firstEntry;
815             HeaderEntry&lt;K, V&gt; next = firstEntry.next;
816             while (next != null &amp;&amp; next != entry) {
817                 previous = next;
818                 next = next.next;
819             }
820             assert next != null: "Entry not found in its hash bucket: " + entry;
821             previous.next = entry.next;
822         } else {
823             previous.next = entry.next;
824         }
825         entry.remove();
826         --size;
827         return previous;
828     }
829     @SuppressWarnings("unchecked")
830     private T thisT() {
831         return (T) this;
832     }
833     public DefaultHeaders&lt;K, V, T&gt; copy() {
834         DefaultHeaders&lt;K, V, T&gt; copy = new DefaultHeaders&lt;K, V, T&gt;(
835                 hashingStrategy, valueConverter, nameValidator, entries.length);
836         copy.addImpl(this);
837         return copy;
838     }
839     private final class HeaderIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {
840         private HeaderEntry&lt;K, V&gt; current = head;
841         @Override
842         public boolean hasNext() {
843             return current.after != head;
844         }
845         @Override
846         public Entry&lt;K, V&gt; next() {
847             current = current.after;
848             if (current == head) {
849                 throw new NoSuchElementException();
850             }
851             return current;
852         }
853         @Override
854         public void remove() {
855             throw new UnsupportedOperationException("read only");
856         }
857     }
858     private final class ValueIterator implements Iterator&lt;V&gt; {
859         private final K name;
860         private final int hash;
861         private HeaderEntry&lt;K, V&gt; removalPrevious;
862         private HeaderEntry&lt;K, V&gt; previous;
863         private HeaderEntry&lt;K, V&gt; next;
864         ValueIterator(K name) {
865 <a name="3"></a>            this.name = checkNotNull(name, "name");
866             hash = hashingStrategy.hashCode(name);
867             calculateNext(entries[index(hash)]);
868         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
869         @Override
870         public boolean hasNext() {
871             return next != null;
872         }
873         @Override
874         public V next() {</b></font>
875             if (!hasNext()) {
876                 throw new NoSuchElementException();
877             }
878             if (previous != null) {
879                 removalPrevious = previous;
880             }
881             previous = next;
882             calculateNext(next.next);
883             return previous.value;
884         }
885         @Override
886         public void remove() {
887             if (previous == null) {
888                 throw new IllegalStateException();
889             }
890             removalPrevious = remove0(previous, removalPrevious);
891             previous = null;
892         }
893         private void calculateNext(HeaderEntry&lt;K, V&gt; entry) {
894             while (entry != null) {
895                 if (entry.hash == hash &amp;&amp; hashingStrategy.equals(name, entry.key)) {
896                     next = entry;
897                     return;
898                 }
899                 entry = entry.next;
900             }
901             next = null;
902         }
903     }
904     protected static class HeaderEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
905         protected final int hash;
906         protected final K key;
907         protected V value;
908         protected HeaderEntry&lt;K, V&gt; next;
909         protected HeaderEntry&lt;K, V&gt; before, after;
910         protected HeaderEntry(int hash, K key) {
911             this.hash = hash;
912             this.key = key;
913         }
914         HeaderEntry(int hash, K key, V value, HeaderEntry&lt;K, V&gt; next, HeaderEntry&lt;K, V&gt; head) {
915             this.hash = hash;
916             this.key = key;
917             this.value = value;
918             this.next = next;
919             after = head;
920             before = head.before;
921             pointNeighborsToThis();
922         }
923         HeaderEntry() {
924             hash = -1;
925             key = null;
926             before = after = this;
927         }
928         protected final void pointNeighborsToThis() {
929             before.after = this;
930             after.before = this;
931         }
932         public final HeaderEntry&lt;K, V&gt; before() {
933             return before;
934         }
935         public final HeaderEntry&lt;K, V&gt; after() {
936             return after;
937         }
938 <a name="0"></a>        protected void remove() {
939             before.after = after;
940             after.before = before;
941         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
942         @Override
943         public final K getKey() {
944             return key;
945         }
946         @Override
947         public final V getValue() {
948             return value;
949         }
950         @Override
951         public final V setValue(V value) {</b></font>
952             checkNotNull(value, "value");
953             V oldValue = this.value;
954             this.value = value;
955             return oldValue;
956         }
957         @Override
958         public final String toString() {
959             return key.toString() + '=' + value.toString();
960         }
961         @Override
962         public boolean equals(Object o) {
963             if (!(o instanceof Map.Entry)) {
964                 return false;
965 <a name="4"></a>            }
966             Map.Entry&lt;?, ?&gt; other = (Map.Entry&lt;?, ?&gt;) o;
967             return (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))  &amp;&amp;
968                    (<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));
969         }
970         @Override
971         public int hashCode() {
972             return</b></font> (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());
973         }
974     }
975 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
