
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.647160068846816%, Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTransport.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty;
<span onclick='openModal()' class='match'>2  import com.google.common.util.concurrent.ThreadFactoryBuilder;
3  import com.netflix.client.DefaultLoadBalancerRetryHandler;
4  import com.netflix.loadbalancer.reactive.ExecutionListener;
5  import com.netflix.client.RetryHandler;
6  import com.netflix.client.config.DefaultClientConfigImpl;
7  import com.netflix.client.config.IClientConfig;
8  import com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient;
9  import com.netflix.ribbon.transport.netty.http.NettyHttpLoadBalancerErrorHandler;
10  import com.netflix.ribbon.transport.netty.http.SSEClient;
11  import com.netflix.ribbon.transport.netty.tcp.LoadBalancingTcpClient;
12  import com.netflix.ribbon.transport.netty.udp.LoadBalancingUdpClient;
13  import com.netflix.config.DynamicIntProperty;
14  import com.netflix.loadbalancer.ILoadBalancer;
15  import com.netflix.utils.ScheduledThreadPoolExectuorWithDynamicSize;
16  import io.netty.buffer.ByteBuf;
17  import io.netty.channel.socket.DatagramPacket;
18  import io.reactivex.netty.client.RxClient;
19  import io.reactivex.netty.pipeline.PipelineConfigurator;
20  import io.reactivex.netty.pipeline.PipelineConfigurators;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import io.reactivex.netty.protocol.text.sse.ServerSentEvent;
24  import java.util.List;
25  import java.util.concurrent.ScheduledExecutorService;
26  import java.util.concurrent.ThreadFactory;
27  public final class RibbonTransport {
28      public static final PipelineConfigurator<HttpClientResponse<ServerSentEvent>, HttpClientRequest<ByteBuf>> DEFAULT_SSE_PIPELINE_CONFIGURATOR  = 
</span>29              PipelineConfigurators.sseClientConfigurator();
30      public static final PipelineConfigurator<HttpClientResponse<ByteBuf>, HttpClientRequest<ByteBuf>> DEFAULT_HTTP_PIPELINE_CONFIGURATOR = 
31              PipelineConfigurators.httpClientConfigurator();
32      public static final DynamicIntProperty POOL_CLEANER_CORE_SIZE = new DynamicIntProperty("rxNetty.poolCleaner.coreSize", 2);
33      public static final ScheduledExecutorService poolCleanerScheduler;
34      static {
35          ThreadFactory factory = (new ThreadFactoryBuilder()).setDaemon(true)
36                  .setNameFormat("RxClient_Connection_Pool_Clean_Up")
37                  .build();
38          poolCleanerScheduler = new ScheduledThreadPoolExectuorWithDynamicSize(POOL_CLEANER_CORE_SIZE, factory);
39      }
40      private RibbonTransport() {
41      }
42      private static RetryHandler getDefaultHttpRetryHandlerWithConfig(IClientConfig config) {
43          return new NettyHttpLoadBalancerErrorHandler(config);
44      }
45      private static RetryHandler getDefaultRetryHandlerWithConfig(IClientConfig config) {
46          return new DefaultLoadBalancerRetryHandler(config);
47      }
48      public static RxClient<ByteBuf, ByteBuf> newTcpClient(ILoadBalancer loadBalancer, IClientConfig config) {
49          return new LoadBalancingTcpClient<ByteBuf, ByteBuf>(loadBalancer, config, getDefaultRetryHandlerWithConfig(config), null, poolCleanerScheduler);
50      }
51      public static <I, O> RxClient<I, O> newTcpClient(ILoadBalancer loadBalancer, PipelineConfigurator<O, I> pipelineConfigurator, 
52              IClientConfig config, RetryHandler retryHandler) {
53          return new LoadBalancingTcpClient<I, O>(loadBalancer, config, retryHandler, pipelineConfigurator, poolCleanerScheduler);
54      }
55      public static <I, O> RxClient<I, O> newTcpClient(PipelineConfigurator<O, I> pipelineConfigurator, 
56              IClientConfig config) {
57          return new LoadBalancingTcpClient<I, O>(config, getDefaultRetryHandlerWithConfig(config), pipelineConfigurator, poolCleanerScheduler);    
58      }
59      public static RxClient<ByteBuf, ByteBuf> newTcpClient(IClientConfig config) {
60          return new LoadBalancingTcpClient<ByteBuf, ByteBuf>(config, getDefaultRetryHandlerWithConfig(config), null, poolCleanerScheduler);    
61      }
62      public static RxClient<DatagramPacket, DatagramPacket> newUdpClient(ILoadBalancer loadBalancer, IClientConfig config) {
63          return new LoadBalancingUdpClient<DatagramPacket, DatagramPacket>(loadBalancer, config, getDefaultRetryHandlerWithConfig(config), null);
64      }
65      public static RxClient<DatagramPacket, DatagramPacket> newUdpClient(IClientConfig config) {
66          return new LoadBalancingUdpClient<DatagramPacket, DatagramPacket>(config, getDefaultRetryHandlerWithConfig(config), null);
67      }
68      public static <I, O> RxClient<I, O> newUdpClient(ILoadBalancer loadBalancer, PipelineConfigurator<O, I> pipelineConfigurator, 
69              IClientConfig config, RetryHandler retryHandler) {
70          return new LoadBalancingUdpClient<I, O>(loadBalancer, config, retryHandler, pipelineConfigurator);
71      }
72      public static <I, O> RxClient<I, O> newUdpClient(PipelineConfigurator<O, I> pipelineConfigurator, IClientConfig config) {
73          return new LoadBalancingUdpClient<I, O>(config, getDefaultRetryHandlerWithConfig(config), pipelineConfigurator);
74      }
75      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient() {
76          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
77          return newHttpClient(config);
78      }
79      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient(ILoadBalancer loadBalancer, IClientConfig config) {
80          return LoadBalancingHttpClient.<ByteBuf, ByteBuf>builder()
81                  .withLoadBalancer(loadBalancer)
82                  .withClientConfig(config)
83                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
84                  .withPipelineConfigurator(DEFAULT_HTTP_PIPELINE_CONFIGURATOR)
85                  .withPoolCleanerScheduler(poolCleanerScheduler)
86                  .build();
87      }
88      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient(ILoadBalancer loadBalancer, IClientConfig config, RetryHandler retryHandler) {
89          return LoadBalancingHttpClient.<ByteBuf, ByteBuf>builder()
90                  .withLoadBalancer(loadBalancer)
91                  .withClientConfig(config)
92                  .withRetryHandler(retryHandler)
93                  .withPipelineConfigurator(DEFAULT_HTTP_PIPELINE_CONFIGURATOR)
94                  .withPoolCleanerScheduler(poolCleanerScheduler)
95                  .build();
96      }
97      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient(ILoadBalancer loadBalancer, IClientConfig config, RetryHandler retryHandler,
98                                                                    List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners) {
99          return LoadBalancingHttpClient.<ByteBuf, ByteBuf>builder()
100                  .withLoadBalancer(loadBalancer)
101                  .withClientConfig(config)
102                  .withRetryHandler(retryHandler)
103                  .withPipelineConfigurator(DEFAULT_HTTP_PIPELINE_CONFIGURATOR)
104                  .withPoolCleanerScheduler(poolCleanerScheduler)
105                  .withExecutorListeners(listeners)
106                  .build();
107      }
108      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient(IClientConfig config) {
109          return LoadBalancingHttpClient.<ByteBuf, ByteBuf>builder()
110                  .withClientConfig(config)
111                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
112                  .withPipelineConfigurator(DEFAULT_HTTP_PIPELINE_CONFIGURATOR)
113                  .withPoolCleanerScheduler(poolCleanerScheduler)
114                  .build();
115      }
116      public static LoadBalancingHttpClient<ByteBuf, ByteBuf> newHttpClient(ILoadBalancer loadBalancer) {
117          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
118          return newHttpClient(loadBalancer, config);
119      }
120      public static <I, O> LoadBalancingHttpClient<I, O> newHttpClient(PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator,
121              ILoadBalancer loadBalancer, IClientConfig config) {
122          return LoadBalancingHttpClient.<I, O>builder()
123                  .withLoadBalancer(loadBalancer)
124                  .withClientConfig(config)
125                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
126                  .withPipelineConfigurator(pipelineConfigurator)
127                  .withPoolCleanerScheduler(poolCleanerScheduler)
128                  .build();
129      }
130      public static <I, O> LoadBalancingHttpClient<I, O> newHttpClient(PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator,
131              IClientConfig config) {
132          return LoadBalancingHttpClient.<I, O>builder()
133                  .withClientConfig(config)
134                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
135                  .withPipelineConfigurator(pipelineConfigurator)
136                  .withPoolCleanerScheduler(poolCleanerScheduler)
137                  .build();
138      }
139      public static <I, O> LoadBalancingHttpClient<I, O> newHttpClient(PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator,
140              IClientConfig config, RetryHandler retryHandler) {
141          return LoadBalancingHttpClient.<I, O>builder()
142                  .withClientConfig(config)
143                  .withRetryHandler(retryHandler)
144                  .withPipelineConfigurator(pipelineConfigurator)
145                  .withPoolCleanerScheduler(poolCleanerScheduler)
146                  .build();
147      }
148      public static <I, O> LoadBalancingHttpClient<I, O> newHttpClient(PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator,
149                                                               ILoadBalancer loadBalancer, IClientConfig config, RetryHandler retryHandler,
150                                                                    List<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>> listeners) {
151          return LoadBalancingHttpClient.<I, O>builder()
152                  .withLoadBalancer(loadBalancer)
153                  .withClientConfig(config)
154                  .withRetryHandler(retryHandler)
155                  .withPipelineConfigurator(pipelineConfigurator)
156                  .withPoolCleanerScheduler(poolCleanerScheduler)
157                  .withExecutorListeners(listeners)
158                  .build();
159      }
160      public static LoadBalancingHttpClient<ByteBuf, ServerSentEvent> newSSEClient(ILoadBalancer loadBalancer, IClientConfig config) {
161          return SSEClient.<ByteBuf>sseClientBuilder()
162                  .withLoadBalancer(loadBalancer)
163                  .withClientConfig(config)
164                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
165                  .withPipelineConfigurator(DEFAULT_SSE_PIPELINE_CONFIGURATOR)
166                  .build();
167      }
168      public static LoadBalancingHttpClient<ByteBuf, ServerSentEvent> newSSEClient(IClientConfig config) {
169          return SSEClient.<ByteBuf>sseClientBuilder()
170                  .withClientConfig(config)
171                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
172                  .withPipelineConfigurator(DEFAULT_SSE_PIPELINE_CONFIGURATOR)
173                  .build();
174      }
175      public static <I> LoadBalancingHttpClient<I, ServerSentEvent> newSSEClient(PipelineConfigurator<HttpClientResponse<ServerSentEvent>, HttpClientRequest<I>> pipelineConfigurator,
176              ILoadBalancer loadBalancer, IClientConfig config) {
177          return SSEClient.<I>sseClientBuilder()
178                  .withLoadBalancer(loadBalancer)
179                  .withClientConfig(config)
180                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
181                  .withPipelineConfigurator(pipelineConfigurator)
182                  .build();
183      }
184      public static <I> LoadBalancingHttpClient<I, ServerSentEvent> newSSEClient(PipelineConfigurator<HttpClientResponse<ServerSentEvent>, HttpClientRequest<I>> pipelineConfigurator,
185              IClientConfig config) {
186          return SSEClient.<I>sseClientBuilder()
187                  .withClientConfig(config)
188                  .withRetryHandler(getDefaultHttpRetryHandlerWithConfig(config))
189                  .withPipelineConfigurator(pipelineConfigurator)
190                  .build();
191      }
192      public static LoadBalancingHttpClient<ByteBuf, ServerSentEvent> newSSEClient() {
193          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
194          return newSSEClient(config);
195      }
196  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-BungeeCord.java</h3>
            <pre><code>1  package net.md_5.bungee;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import com.google.common.base.Predicate;
5  import com.google.common.collect.Iterables;
6  import com.google.common.collect.Lists;
7  import com.google.common.collect.Sets;
8  import com.google.common.util.concurrent.ThreadFactoryBuilder;
9  import com.google.gson.Gson;
10  import com.google.gson.GsonBuilder;
11  import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
12  import io.netty.bootstrap.ServerBootstrap;
13  import io.netty.channel.Channel;
14  import io.netty.channel.ChannelException;
15  import io.netty.channel.ChannelFuture;
16  import io.netty.channel.ChannelFutureListener;
17  import io.netty.channel.ChannelOption;
18  import io.netty.channel.EventLoopGroup;
19  import io.netty.util.ResourceLeakDetector;
20  import java.io.File;
21  import java.io.FileReader;
22  import java.io.IOException;
23  import java.io.PrintStream;
24  import java.net.InetSocketAddress;
25  import java.net.SocketAddress;
26  import java.text.Format;
27  import java.text.MessageFormat;
28  import java.util.ArrayList;
29  import java.util.Collection;
30  import java.util.Collections;
31  import java.util.Enumeration;
32  import java.util.HashMap;
33  import java.util.HashSet;
34  import java.util.Locale;
35  import java.util.Map;
36  import java.util.MissingResourceException;
37  import java.util.PropertyResourceBundle;
38  import java.util.ResourceBundle;
39  import java.util.Timer;
40  import java.util.TimerTask;
41  import java.util.UUID;
42  import java.util.concurrent.TimeUnit;
43  import java.util.concurrent.locks.ReadWriteLock;
44  import java.util.concurrent.locks.ReentrantLock;
45  import java.util.concurrent.locks.ReentrantReadWriteLock;
46  import java.util.logging.Handler;
47  import java.util.logging.Level;
48  import java.util.logging.Logger;
49  import jline.console.ConsoleReader;
50  import lombok.Getter;
51  import lombok.Setter;
52  import lombok.Synchronized;
53  import net.md_5.bungee.api.CommandSender;
54  import net.md_5.bungee.api.Favicon;
55  import net.md_5.bungee.api.ProxyServer;
56  import net.md_5.bungee.api.ReconnectHandler;
57  import net.md_5.bungee.api.ServerPing;
58  import net.md_5.bungee.api.Title;
59  import net.md_5.bungee.api.chat.BaseComponent;
60  import net.md_5.bungee.api.chat.KeybindComponent;
61  import net.md_5.bungee.api.chat.ScoreComponent;
62  import net.md_5.bungee.api.chat.SelectorComponent;
63  import net.md_5.bungee.api.chat.TextComponent;
64  import net.md_5.bungee.api.chat.TranslatableComponent;
65  import net.md_5.bungee.api.config.ConfigurationAdapter;
66  import net.md_5.bungee.api.config.ListenerInfo;
67  import net.md_5.bungee.api.config.ServerInfo;
68  import net.md_5.bungee.api.connection.ProxiedPlayer;
69  import net.md_5.bungee.api.plugin.Plugin;
70  import net.md_5.bungee.api.plugin.PluginManager;
71  import net.md_5.bungee.chat.ComponentSerializer;
72  import net.md_5.bungee.chat.KeybindComponentSerializer;
73  import net.md_5.bungee.chat.ScoreComponentSerializer;
74  import net.md_5.bungee.chat.SelectorComponentSerializer;
75  import net.md_5.bungee.chat.TextComponentSerializer;
<span onclick='openModal()' class='match'>76  import net.md_5.bungee.chat.TranslatableComponentSerializer;
77  import net.md_5.bungee.command.CommandBungee;
78  import net.md_5.bungee.command.CommandEnd;
79  import net.md_5.bungee.command.CommandIP;
80  import net.md_5.bungee.command.CommandPerms;
81  import net.md_5.bungee.command.CommandReload;
82  import net.md_5.bungee.command.ConsoleCommandCompleter;
83  import net.md_5.bungee.command.ConsoleCommandSender;
84  import net.md_5.bungee.compress.CompressFactory;
85  import net.md_5.bungee.conf.Configuration;
86  import net.md_5.bungee.conf.YamlConfig;
87  import net.md_5.bungee.forge.ForgeConstants;
88  import net.md_5.bungee.log.BungeeLogger;
89  import net.md_5.bungee.log.LoggingForwardHandler;
90  import net.md_5.bungee.log.LoggingOutputStream;
91  import net.md_5.bungee.module.ModuleManager;
92  import net.md_5.bungee.netty.PipelineUtils;
93  import net.md_5.bungee.protocol.DefinedPacket;
94  import net.md_5.bungee.protocol.ProtocolConstants;
95  import net.md_5.bungee.protocol.packet.PluginMessage;
96  import net.md_5.bungee.query.RemoteQuery;
97  import net.md_5.bungee.scheduler.BungeeScheduler;
98  import net.md_5.bungee.util.CaseInsensitiveMap;
99  import org.fusesource.jansi.AnsiConsole;
100  import org.slf4j.impl.JDK14LoggerFactory;
101  public class BungeeCord extends ProxyServer
102  {
103      public volatile boolean isRunning;
</span>104      @Getter
105      public final Configuration config = new Configuration();
106      private Map<String, Format> messageFormats;
107      public EventLoopGroup eventLoops;
108      private final Timer saveThread = new Timer( "Reconnect Saver" );
109      private final Timer metricsThread = new Timer( "Metrics Thread" );
110      private final Collection<Channel> listeners = new HashSet<>();
111      private final Map<String, UserConnection> connections = new CaseInsensitiveMap<>();
112      private final Map<UUID, UserConnection> connectionsByOfflineUUID = new HashMap<>();
113      private final Map<UUID, UserConnection> connectionsByUUID = new HashMap<>();
114      private final ReadWriteLock connectionLock = new ReentrantReadWriteLock();
115      private final ReentrantLock shutdownLock = new ReentrantLock();
116      @Getter
117      public final PluginManager pluginManager;
118      @Getter
119      @Setter
120      private ReconnectHandler reconnectHandler;
121      @Getter
122      @Setter
123      private ConfigurationAdapter configurationAdapter = new YamlConfig();
124      private final Collection<String> pluginChannels = new HashSet<>();
125      @Getter
126      private final File pluginsFolder = new File( "plugins" );
127      @Getter
128      private final BungeeScheduler scheduler = new BungeeScheduler();
129      @Getter
130      private final ConsoleReader consoleReader;
131      @Getter
132      private final Logger logger;
133      public final Gson gson = new GsonBuilder()
134              .registerTypeAdapter( BaseComponent.class, new ComponentSerializer() )
135              .registerTypeAdapter( TextComponent.class, new TextComponentSerializer() )
136              .registerTypeAdapter( TranslatableComponent.class, new TranslatableComponentSerializer() )
137              .registerTypeAdapter( KeybindComponent.class, new KeybindComponentSerializer() )
138              .registerTypeAdapter( ScoreComponent.class, new ScoreComponentSerializer() )
139              .registerTypeAdapter( SelectorComponent.class, new SelectorComponentSerializer() )
140              .registerTypeAdapter( ServerPing.PlayerInfo.class, new PlayerInfoSerializer() )
141              .registerTypeAdapter( Favicon.class, Favicon.getFaviconTypeAdapter() ).create();
142      @Getter
143      private ConnectionThrottle connectionThrottle;
144      private final ModuleManager moduleManager = new ModuleManager();
145      {
146          registerChannel( "BungeeCord" );
147      }
148      public static BungeeCord getInstance()
149      {
150          return (BungeeCord) ProxyServer.getInstance();
151      }
152      @SuppressFBWarnings("DM_DEFAULT_ENCODING")
153      public BungeeCord() throws IOException
154      {
155          Preconditions.checkState( new File( "." ).getAbsolutePath().indexOf( '!' ) == -1, "Cannot use BungeeCord in directory with ! in path." );
156          reloadMessages();
157          System.setProperty( "library.jansi.version", "BungeeCord" );
158          AnsiConsole.systemInstall();
159          consoleReader = new ConsoleReader();
160          consoleReader.setExpandEvents( false );
161          consoleReader.addCompleter( new ConsoleCommandCompleter( this ) );
162          logger = new BungeeLogger( "BungeeCord", "proxy.log", consoleReader );
163          JDK14LoggerFactory.LOGGER = logger;
164          Logger rootLogger = Logger.getLogger( "" );
165          for ( Handler handler : rootLogger.getHandlers() )
166          {
167              rootLogger.removeHandler( handler );
168          }
169          rootLogger.addHandler( new LoggingForwardHandler( logger ) );
170          System.setErr( new PrintStream( new LoggingOutputStream( logger, Level.SEVERE ), true ) );
171          System.setOut( new PrintStream( new LoggingOutputStream( logger, Level.INFO ), true ) );
172          pluginManager = new PluginManager( this );
173          getPluginManager().registerCommand( null, new CommandReload() );
174          getPluginManager().registerCommand( null, new CommandEnd() );
175          getPluginManager().registerCommand( null, new CommandIP() );
176          getPluginManager().registerCommand( null, new CommandBungee() );
177          getPluginManager().registerCommand( null, new CommandPerms() );
178          if ( !Boolean.getBoolean( "net.md_5.bungee.native.disable" ) )
179          {
180              if ( EncryptionUtil.nativeFactory.load() )
181              {
182                  logger.info( "Using mbed TLS based native cipher." );
183              } else
184              {
185                  logger.info( "Using standard Java JCE cipher." );
186              }
187              if ( CompressFactory.zlib.load() )
188              {
189                  logger.info( "Using zlib based native compressor." );
190              } else
191              {
192                  logger.info( "Using standard Java compressor." );
193              }
194          }
195      }
196      @SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_BAD_PRACTICE")
197      public void start() throws Exception
198      {
199          System.setProperty( "io.netty.selectorAutoRebuildThreshold", "0" ); 
200          if ( System.getProperty( "io.netty.leakDetectionLevel" ) == null && System.getProperty( "io.netty.leakDetection.level" ) == null )
201          {
202              ResourceLeakDetector.setLevel( ResourceLeakDetector.Level.DISABLED ); 
203          }
204          eventLoops = PipelineUtils.newEventLoopGroup( 0, new ThreadFactoryBuilder().setNameFormat( "Netty IO Thread #%1$d" ).build() );
205          File moduleDirectory = new File( "modules" );
206          moduleManager.load( this, moduleDirectory );
207          pluginManager.detectPlugins( moduleDirectory );
208          pluginsFolder.mkdir();
209          pluginManager.detectPlugins( pluginsFolder );
210          pluginManager.loadPlugins();
211          config.load();
212          if ( config.isForgeSupport() )
213          {
214              registerChannel( ForgeConstants.FML_TAG );
215              registerChannel( ForgeConstants.FML_HANDSHAKE_TAG );
216              registerChannel( ForgeConstants.FORGE_REGISTER );
217              getLogger().warning( "MinecraftForge support is currently unmaintained and may have unresolved issues. Please use at your own risk." );
218          }
219          isRunning = true;
220          pluginManager.enablePlugins();
221          if ( config.getThrottle() > 0 )
222          {
223              connectionThrottle = new ConnectionThrottle( config.getThrottle(), config.getThrottleLimit() );
224          }
225          startListeners();
226          saveThread.scheduleAtFixedRate( new TimerTask()
227          {
228              @Override
229              public void run()
230              {
231                  if ( getReconnectHandler() != null )
232                  {
233                      getReconnectHandler().save();
234                  }
235              }
236          }, 0, TimeUnit.MINUTES.toMillis( 5 ) );
237          metricsThread.scheduleAtFixedRate( new Metrics(), 0, TimeUnit.MINUTES.toMillis( Metrics.PING_INTERVAL ) );
238          Runtime.getRuntime().addShutdownHook( new Thread()
239          {
240              @Override
241              public void run()
242              {
243                  independentThreadStop( getTranslation( "restart" ), false );
244              }
245          } );
246      }
247      public void startListeners()
248      {
249          for ( final ListenerInfo info : config.getListeners() )
250          {
251              if ( info.isProxyProtocol() )
252              {
253                  getLogger().log( Level.WARNING, "Using PROXY protocol for listener {0}, please ensure this listener is adequately firewalled.", info.getSocketAddress() );
254                  if ( connectionThrottle != null )
255                  {
256                      connectionThrottle = null;
257                      getLogger().log( Level.WARNING, "Since PROXY protocol is in use, internal connection throttle has been disabled." );
258                  }
259              }
260              ChannelFutureListener listener = new ChannelFutureListener()
261              {
262                  @Override
263                  public void operationComplete(ChannelFuture future) throws Exception
264                  {
265                      if ( future.isSuccess() )
266                      {
267                          listeners.add( future.channel() );
268                          getLogger().log( Level.INFO, "Listening on {0}", info.getSocketAddress() );
269                      } else
270                      {
271                          getLogger().log( Level.WARNING, "Could not bind to host " + info.getSocketAddress(), future.cause() );
272                      }
273                  }
274              };
275              new ServerBootstrap()
276                      .channel( PipelineUtils.getServerChannel( info.getSocketAddress() ) )
277                      .option( ChannelOption.SO_REUSEADDR, true ) 
278                      .childAttr( PipelineUtils.LISTENER, info )
279                      .childHandler( PipelineUtils.SERVER_CHILD )
280                      .group( eventLoops )
281                      .localAddress( info.getSocketAddress() )
282                      .bind().addListener( listener );
283              if ( info.isQueryEnabled() )
284              {
285                  Preconditions.checkArgument( info.getSocketAddress() instanceof InetSocketAddress, "Can only create query listener on UDP address" );
286                  ChannelFutureListener bindListener = new ChannelFutureListener()
287                  {
288                      @Override
289                      public void operationComplete(ChannelFuture future) throws Exception
290                      {
291                          if ( future.isSuccess() )
292                          {
293                              listeners.add( future.channel() );
294                              getLogger().log( Level.INFO, "Started query on {0}", future.channel().localAddress() );
295                          } else
296                          {
297                              getLogger().log( Level.WARNING, "Could not bind to host " + info.getSocketAddress(), future.cause() );
298                          }
299                      }
300                  };
301                  new RemoteQuery( this, info ).start( PipelineUtils.getDatagramChannel(), new InetSocketAddress( info.getHost().getAddress(), info.getQueryPort() ), eventLoops, bindListener );
302              }
303          }
304      }
305      public void stopListeners()
306      {
307          for ( Channel listener : listeners )
308          {
309              getLogger().log( Level.INFO, "Closing listener {0}", listener );
310              try
311              {
312                  listener.close().syncUninterruptibly();
313              } catch ( ChannelException ex )
314              {
315                  getLogger().severe( "Could not close listen thread" );
316              }
317          }
318          listeners.clear();
319      }
320      @Override
321      public void stop()
322      {
323          stop( getTranslation( "restart" ) );
324      }
325      @Override
326      public void stop(final String reason)
327      {
328          new Thread( "Shutdown Thread" )
329          {
330              @Override
331              public void run()
332              {
333                  independentThreadStop( reason, true );
334              }
335          }.start();
336      }
337      @SuppressFBWarnings("DM_EXIT")
338      @SuppressWarnings("TooBroadCatch")
339      private void independentThreadStop(final String reason, boolean callSystemExit)
340      {
341          shutdownLock.lock();
342          if ( !isRunning )
343          {
344              shutdownLock.unlock();
345              return;
346          }
347          isRunning = false;
348          stopListeners();
349          getLogger().info( "Closing pending connections" );
350          connectionLock.readLock().lock();
351          try
352          {
353              getLogger().log( Level.INFO, "Disconnecting {0} connections", connections.size() );
354              for ( UserConnection user : connections.values() )
355              {
356                  user.disconnect( reason );
357              }
358          } finally
359          {
360              connectionLock.readLock().unlock();
361          }
362          try
363          {
364              Thread.sleep( 500 );
365          } catch ( InterruptedException ex )
366          {
367          }
368          if ( reconnectHandler != null )
369          {
370              getLogger().info( "Saving reconnect locations" );
371              reconnectHandler.save();
372              reconnectHandler.close();
373          }
374          saveThread.cancel();
375          metricsThread.cancel();
376          getLogger().info( "Disabling plugins" );
377          for ( Plugin plugin : Lists.reverse( new ArrayList<>( pluginManager.getPlugins() ) ) )
378          {
379              try
380              {
381                  plugin.onDisable();
382                  for ( Handler handler : plugin.getLogger().getHandlers() )
383                  {
384                      handler.close();
385                  }
386              } catch ( Throwable t )
387              {
388                  getLogger().log( Level.SEVERE, "Exception disabling plugin " + plugin.getDescription().getName(), t );
389              }
390              getScheduler().cancel( plugin );
391              plugin.getExecutorService().shutdownNow();
392          }
393          getLogger().info( "Closing IO threads" );
394          eventLoops.shutdownGracefully();
395          try
396          {
397              eventLoops.awaitTermination( Long.MAX_VALUE, TimeUnit.NANOSECONDS );
398          } catch ( InterruptedException ex )
399          {
400          }
401          getLogger().info( "Thank you and goodbye" );
402          for ( Handler handler : getLogger().getHandlers() )
403          {
404              handler.close();
405          }
406          shutdownLock.unlock();
407          if ( callSystemExit )
408          {
409              System.exit( 0 );
410          }
411      }
412      public void broadcast(DefinedPacket packet)
413      {
414          connectionLock.readLock().lock();
415          try
416          {
417              for ( UserConnection con : connections.values() )
418              {
419                  con.unsafe().sendPacket( packet );
420              }
421          } finally
422          {
423              connectionLock.readLock().unlock();
424          }
425      }
426      @Override
427      public String getName()
428      {
429          return "BungeeCord";
430      }
431      @Override
432      public String getVersion()
433      {
434          return ( BungeeCord.class.getPackage().getImplementationVersion() == null ) ? "unknown" : BungeeCord.class.getPackage().getImplementationVersion();
435      }
436      public final void reloadMessages()
437      {
438          Map<String, Format> cachedFormats = new HashMap<>();
439          File file = new File( "messages.properties" );
440          if ( file.isFile() )
441          {
442              try ( FileReader rd = new FileReader( file ) )
443              {
444                  cacheResourceBundle( cachedFormats, new PropertyResourceBundle( rd ) );
445              } catch ( IOException ex )
446              {
447                  getLogger().log( Level.SEVERE, "Could not load custom messages.properties", ex );
448              }
449          }
450          ResourceBundle baseBundle;
451          try
452          {
453              baseBundle = ResourceBundle.getBundle( "messages" );
454          } catch ( MissingResourceException ex )
455          {
456              baseBundle = ResourceBundle.getBundle( "messages", Locale.ENGLISH );
457          }
458          cacheResourceBundle( cachedFormats, baseBundle );
459          messageFormats = Collections.unmodifiableMap( cachedFormats );
460      }
461      private void cacheResourceBundle(Map<String, Format> map, ResourceBundle resourceBundle)
462      {
463          Enumeration<String> keys = resourceBundle.getKeys();
464          while ( keys.hasMoreElements() )
465          {
466              map.computeIfAbsent( keys.nextElement(), (key) -> new MessageFormat( resourceBundle.getString( key ) ) );
467          }
468      }
469      @Override
470      public String getTranslation(String name, Object... args)
471      {
472          Format format = messageFormats.get( name );
473          return ( format != null ) ? format.format( args ) : "<translation '" + name + "' missing>";
474      }
475      @Override
476      @SuppressWarnings("unchecked")
477      public Collection<ProxiedPlayer> getPlayers()
478      {
479          connectionLock.readLock().lock();
480          try
481          {
482              return Collections.unmodifiableCollection( new HashSet( connections.values() ) );
483          } finally
484          {
485              connectionLock.readLock().unlock();
486          }
487      }
488      @Override
489      public int getOnlineCount()
490      {
491          return connections.size();
492      }
493      @Override
494      public ProxiedPlayer getPlayer(String name)
495      {
496          connectionLock.readLock().lock();
497          try
498          {
499              return connections.get( name );
500          } finally
501          {
502              connectionLock.readLock().unlock();
503          }
504      }
505      public UserConnection getPlayerByOfflineUUID(UUID uuid)
506      {
507          if ( uuid.version() != 3 )
508          {
509              return null;
510          }
511          connectionLock.readLock().lock();
512          try
513          {
514              return connectionsByOfflineUUID.get( uuid );
515          } finally
516          {
517              connectionLock.readLock().unlock();
518          }
519      }
520      @Override
521      public ProxiedPlayer getPlayer(UUID uuid)
522      {
523          connectionLock.readLock().lock();
524          try
525          {
526              return connectionsByUUID.get( uuid );
527          } finally
528          {
529              connectionLock.readLock().unlock();
530          }
531      }
532      @Override
533      public Map<String, ServerInfo> getServers()
534      {
535          return config.getServers();
536      }
537      @Override
538      public ServerInfo getServerInfo(String name)
539      {
540          return getServers().get( name );
541      }
542      @Override
543      @Synchronized("pluginChannels")
544      public void registerChannel(String channel)
545      {
546          pluginChannels.add( channel );
547      }
548      @Override
549      @Synchronized("pluginChannels")
550      public void unregisterChannel(String channel)
551      {
552          pluginChannels.remove( channel );
553      }
554      @Override
555      @Synchronized("pluginChannels")
556      public Collection<String> getChannels()
557      {
558          return Collections.unmodifiableCollection( pluginChannels );
559      }
560      public PluginMessage registerChannels(int protocolVersion)
561      {
562          if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 )
563          {
564              return new PluginMessage( "minecraft:register", String.join( "\00", Iterables.transform( pluginChannels, PluginMessage.MODERNISE ) ).getBytes( Charsets.UTF_8 ), false );
565          }
566          return new PluginMessage( "REGISTER", String.join( "\00", pluginChannels ).getBytes( Charsets.UTF_8 ), false );
567      }
568      @Override
569      public int getProtocolVersion()
570      {
571          return ProtocolConstants.SUPPORTED_VERSION_IDS.get( ProtocolConstants.SUPPORTED_VERSION_IDS.size() - 1 );
572      }
573      @Override
574      public String getGameVersion()
575      {
576          return ProtocolConstants.SUPPORTED_VERSIONS.get( 0 ) + "-" + ProtocolConstants.SUPPORTED_VERSIONS.get( ProtocolConstants.SUPPORTED_VERSIONS.size() - 1 );
577      }
578      @Override
579      public ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted)
580      {
581          return constructServerInfo( name, (SocketAddress) address, motd, restricted );
582      }
583      @Override
584      public ServerInfo constructServerInfo(String name, SocketAddress address, String motd, boolean restricted)
585      {
586          return new BungeeServerInfo( name, address, motd, restricted );
587      }
588      @Override
589      public CommandSender getConsole()
590      {
591          return ConsoleCommandSender.getInstance();
592      }
593      @Override
594      public void broadcast(String message)
595      {
596          broadcast( TextComponent.fromLegacyText( message ) );
597      }
598      @Override
599      public void broadcast(BaseComponent... message)
600      {
601          getConsole().sendMessage( BaseComponent.toLegacyText( message ) );
602          for ( ProxiedPlayer player : getPlayers() )
603          {
604              player.sendMessage( message );
605          }
606      }
607      @Override
608      public void broadcast(BaseComponent message)
609      {
610          getConsole().sendMessage( message.toLegacyText() );
611          for ( ProxiedPlayer player : getPlayers() )
612          {
613              player.sendMessage( message );
614          }
615      }
616      public void addConnection(UserConnection con)
617      {
618          UUID offlineId = con.getPendingConnection().getOfflineId();
619          if ( offlineId != null && offlineId.version() != 3 )
620          {
621              throw new IllegalArgumentException( "Offline UUID must be a name-based UUID" );
622          }
623          connectionLock.writeLock().lock();
624          try
625          {
626              connections.put( con.getName(), con );
627              connectionsByUUID.put( con.getUniqueId(), con );
628              connectionsByOfflineUUID.put( offlineId, con );
629          } finally
630          {
631              connectionLock.writeLock().unlock();
632          }
633      }
634      public void removeConnection(UserConnection con)
635      {
636          connectionLock.writeLock().lock();
637          try
638          {
639              if ( connections.get( con.getName() ) == con )
640              {
641                  connections.remove( con.getName() );
642                  connectionsByUUID.remove( con.getUniqueId() );
643                  connectionsByOfflineUUID.remove( con.getPendingConnection().getOfflineId() );
644              }
645          } finally
646          {
647              connectionLock.writeLock().unlock();
648          }
649      }
650      @Override
651      public Collection<String> getDisabledCommands()
652      {
653          return config.getDisabledCommands();
654      }
655      @Override
656      public Collection<ProxiedPlayer> matchPlayer(final String partialName)
657      {
658          Preconditions.checkNotNull( partialName, "partialName" );
659          ProxiedPlayer exactMatch = getPlayer( partialName );
660          if ( exactMatch != null )
661          {
662              return Collections.singleton( exactMatch );
663          }
664          return Sets.newHashSet( Iterables.filter( getPlayers(), new Predicate<ProxiedPlayer>()
665          {
666              @Override
667              public boolean apply(ProxiedPlayer input)
668              {
669                  return ( input == null ) ? false : input.getName().toLowerCase( Locale.ROOT ).startsWith( partialName.toLowerCase( Locale.ROOT ) );
670              }
671          } ) );
672      }
673      @Override
674      public Title createTitle()
675      {
676          return new BungeeTitle();
677      }
678  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTransport.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-BungeeCord.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import com.google.common.util.concurrent.ThreadFactoryBuilder;
3  import com.netflix.client.DefaultLoadBalancerRetryHandler;
4  import com.netflix.loadbalancer.reactive.ExecutionListener;
5  import com.netflix.client.RetryHandler;
6  import com.netflix.client.config.DefaultClientConfigImpl;
7  import com.netflix.client.config.IClientConfig;
8  import com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient;
9  import com.netflix.ribbon.transport.netty.http.NettyHttpLoadBalancerErrorHandler;
10  import com.netflix.ribbon.transport.netty.http.SSEClient;
11  import com.netflix.ribbon.transport.netty.tcp.LoadBalancingTcpClient;
12  import com.netflix.ribbon.transport.netty.udp.LoadBalancingUdpClient;
13  import com.netflix.config.DynamicIntProperty;
14  import com.netflix.loadbalancer.ILoadBalancer;
15  import com.netflix.utils.ScheduledThreadPoolExectuorWithDynamicSize;
16  import io.netty.buffer.ByteBuf;
17  import io.netty.channel.socket.DatagramPacket;
18  import io.reactivex.netty.client.RxClient;
19  import io.reactivex.netty.pipeline.PipelineConfigurator;
20  import io.reactivex.netty.pipeline.PipelineConfigurators;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import io.reactivex.netty.protocol.text.sse.ServerSentEvent;
24  import java.util.List;
25  import java.util.concurrent.ScheduledExecutorService;
26  import java.util.concurrent.ThreadFactory;
27  public final class RibbonTransport {
28      public static final PipelineConfigurator<HttpClientResponse<ServerSentEvent>, HttpClientRequest<ByteBuf>> DEFAULT_SSE_PIPELINE_CONFIGURATOR  = 
</pre></code></div>
                <div class="column column_space"><pre><code>76  import net.md_5.bungee.chat.TranslatableComponentSerializer;
77  import net.md_5.bungee.command.CommandBungee;
78  import net.md_5.bungee.command.CommandEnd;
79  import net.md_5.bungee.command.CommandIP;
80  import net.md_5.bungee.command.CommandPerms;
81  import net.md_5.bungee.command.CommandReload;
82  import net.md_5.bungee.command.ConsoleCommandCompleter;
83  import net.md_5.bungee.command.ConsoleCommandSender;
84  import net.md_5.bungee.compress.CompressFactory;
85  import net.md_5.bungee.conf.Configuration;
86  import net.md_5.bungee.conf.YamlConfig;
87  import net.md_5.bungee.forge.ForgeConstants;
88  import net.md_5.bungee.log.BungeeLogger;
89  import net.md_5.bungee.log.LoggingForwardHandler;
90  import net.md_5.bungee.log.LoggingOutputStream;
91  import net.md_5.bungee.module.ModuleManager;
92  import net.md_5.bungee.netty.PipelineUtils;
93  import net.md_5.bungee.protocol.DefinedPacket;
94  import net.md_5.bungee.protocol.ProtocolConstants;
95  import net.md_5.bungee.protocol.packet.PluginMessage;
96  import net.md_5.bungee.query.RemoteQuery;
97  import net.md_5.bungee.scheduler.BungeeScheduler;
98  import net.md_5.bungee.util.CaseInsensitiveMap;
99  import org.fusesource.jansi.AnsiConsole;
100  import org.slf4j.impl.JDK14LoggerFactory;
101  public class BungeeCord extends ProxyServer
102  {
103      public volatile boolean isRunning;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    