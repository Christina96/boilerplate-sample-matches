<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RepositoriesMetadataSerializationTests.java &amp; Session.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RepositoriesMetadataSerializationTests.java &amp; Session.java
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RepositoriesMetadataSerializationTests.java (8.241758%)<th>Session.java (1.4851485%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-36)<td><a href="#" name="0">(22-40)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RepositoriesMetadataSerializationTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.snapshots;
2 import org.elasticsearch.cluster.ClusterModule;
3 import org.elasticsearch.cluster.Diff;
4 import org.elasticsearch.cluster.metadata.Metadata.Custom;
5 import org.elasticsearch.cluster.metadata.RepositoriesMetadata;
6 import org.elasticsearch.cluster.metadata.RepositoryMetadata;
7 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
8 import org.elasticsearch.common.io.stream.Writeable;
9 import org.elasticsearch.common.settings.Settings;
10 import org.elasticsearch.common.xcontent.XContentParser;
11 import org.elasticsearch.test.AbstractDiffableSerializationTestCase;
12 import java.io.IOException;
13 import java.util.ArrayList;
14 import java.util.Comparator;
15 import</b></font> java.util.List;
16 public class RepositoriesMetadataSerializationTests extends AbstractDiffableSerializationTestCase&lt;Custom&gt; {
17     @Override
18     protected Custom createTestInstance() {
19         int numberOfRepositories = randomInt(10);
20         List&lt;RepositoryMetadata&gt; entries = new ArrayList&lt;&gt;();
21         for (int i = 0; i &lt; numberOfRepositories; i++) {
22             final long generation = randomNonNegativeLong() / 2L;
23             entries.add(new RepositoryMetadata(randomAlphaOfLength(10), randomAlphaOfLength(10), randomSettings(), generation,
24                 generation + randomLongBetween(0, generation)));
25         }
26         entries.sort(Comparator.comparing(RepositoryMetadata::name));
27         return new RepositoriesMetadata(entries);
28     }
29     @Override
30     protected Writeable.Reader&lt;Custom&gt; instanceReader() {
31         return RepositoriesMetadata::new;
32     }
33     @Override
34     protected Custom mutateInstance(Custom instance) {
35         List&lt;RepositoryMetadata&gt; entries = new ArrayList&lt;&gt;(((RepositoriesMetadata) instance).repositories());
36         boolean addEntry = entries.isEmpty() ? true : randomBoolean();
37         if (addEntry) {
38             entries.add(new RepositoryMetadata(randomAlphaOfLength(10), randomAlphaOfLength(10), randomSettings()));
39         } else {
40             entries.remove(randomIntBetween(0, entries.size() - 1));
41         }
42         return new RepositoriesMetadata(entries);
43     }
44     public Settings randomSettings() {
45         if (randomBoolean()) {
46             return Settings.EMPTY;
47         } else {
48             int numberOfSettings = randomInt(10);
49             Settings.Builder builder = Settings.builder();
50             for (int i = 0; i &lt; numberOfSettings; i++) {
51                 builder.put(randomAlphaOfLength(10), randomAlphaOfLength(20));
52             }
53             return builder.build();
54         }
55     }
56     @Override
57     protected Custom makeTestChanges(Custom testInstance) {
58         RepositoriesMetadata repositoriesMetadata = (RepositoriesMetadata) testInstance;
59         List&lt;RepositoryMetadata&gt; repos = new ArrayList&lt;&gt;(repositoriesMetadata.repositories());
60         if (randomBoolean() &amp;&amp; repos.size() &gt; 1) {
61             int leaveElements = randomIntBetween(0, repositoriesMetadata.repositories().size() - 1);
62             repos = randomSubsetOf(leaveElements, repos.toArray(new RepositoryMetadata[leaveElements]));
63         }
64         if (randomBoolean()) {
65             int addElements = randomInt(10);
66             for (int i = 0; i &lt; addElements; i++) {
67                 repos.add(new RepositoryMetadata(randomAlphaOfLength(10), randomAlphaOfLength(10), randomSettings()));
68             }
69         }
70         return new RepositoriesMetadata(repos);
71     }
72     @Override
73     protected Writeable.Reader&lt;Diff&lt;Custom&gt;&gt; diffReader() {
74         return RepositoriesMetadata::readDiffFrom;
75     }
76     @Override
77     protected NamedWriteableRegistry getNamedWriteableRegistry() {
78         return new NamedWriteableRegistry(ClusterModule.getNamedWriteables());
79     }
80     @Override
81     protected Custom doParseInstance(XContentParser parser) throws IOException {
82         assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());
83         RepositoriesMetadata repositoriesMetadata = RepositoriesMetadata.fromXContent(parser);
84         assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken());
85         List&lt;RepositoryMetadata&gt; repos = new ArrayList&lt;&gt;(repositoriesMetadata.repositories());
86         repos.sort(Comparator.comparing(RepositoryMetadata::name));
87         return new RepositoriesMetadata(repos);
88     }
89 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Session.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.action.sql;
2 import java.util.ArrayList;
3 import java.util.HashMap;
4 import java.util.Iterator;
5 import java.util.LinkedHashMap;
6 import java.util.List;
7 import java.util.Map;
8 import java.util.UUID;
9 import java.util.concurrent.CompletableFuture;
10 import java.util.function.Function;
11 import javax.annotation.Nullable;
12 import io.crate.metadata.NodeContext;
13 import io.crate.metadata.RelationInfo;
14 import org.apache.logging.log4j.LogManager;
15 import</b></font> org.apache.logging.log4j.Logger;
16 import org.elasticsearch.cluster.ClusterState;
17 import org.elasticsearch.common.Randomness;
18 import org.elasticsearch.common.UUIDs;
19 import io.crate.analyze.AnalyzedBegin;
20 import io.crate.analyze.AnalyzedCommit;
21 import io.crate.analyze.AnalyzedDeallocate;
22 import io.crate.analyze.AnalyzedDiscard;
23 import io.crate.analyze.AnalyzedStatement;
24 import io.crate.analyze.Analyzer;
25 import io.crate.analyze.ParamTypeHints;
26 import io.crate.analyze.QueriedSelectRelation;
27 import io.crate.analyze.Relations;
28 import io.crate.analyze.relations.AbstractTableRelation;
29 import io.crate.analyze.relations.AnalyzedRelation;
30 import io.crate.auth.AccessControl;
31 import io.crate.common.annotations.VisibleForTesting;
32 import io.crate.common.collections.Lists2;
33 import io.crate.data.Row;
34 import io.crate.data.Row1;
35 import io.crate.data.RowConsumer;
36 import io.crate.data.RowN;
37 import io.crate.exceptions.ReadOnlyException;
38 import io.crate.exceptions.SQLExceptions;
39 import io.crate.execution.engine.collect.stats.JobsLogs;
40 import io.crate.expression.symbol.Symbol;
41 import io.crate.expression.symbol.Symbols;
42 import io.crate.metadata.CoordinatorTxnCtx;
43 import io.crate.metadata.RoutingProvider;
44 import io.crate.metadata.table.TableInfo;
45 import io.crate.planner.DependencyCarrier;
46 import io.crate.planner.Plan;
47 import io.crate.planner.Planner;
48 import io.crate.planner.PlannerContext;
49 import io.crate.planner.operators.StatementClassifier;
50 import io.crate.planner.operators.SubQueryResults;
51 import io.crate.protocols.postgres.FormatCodes;
52 import io.crate.protocols.postgres.JobsLogsUpdateListener;
53 import io.crate.protocols.postgres.Portal;
54 import io.crate.protocols.postgres.RetryOnFailureResultReceiver;
55 import io.crate.protocols.postgres.TransactionState;
56 import io.crate.sql.parser.SqlParser;
57 import io.crate.sql.tree.DiscardStatement.Target;
58 import io.crate.sql.tree.Statement;
59 import io.crate.types.DataType;
60 public class Session implements AutoCloseable {
61     private static final Logger LOGGER = LogManager.getLogger(SQLOperations.class);
62     private static final Statement EMPTY_STMT = SqlParser.createStatement("select '' from sys.cluster limit 0");
63     public static final String UNNAMED = "";
64     private final DependencyCarrier executor;
65     private final AccessControl accessControl;
66     private final SessionContext sessionContext;
67     @VisibleForTesting
68     final Map&lt;String, PreparedStmt&gt; preparedStatements = new HashMap&lt;&gt;();
69     @VisibleForTesting
70     final Map&lt;String, Portal&gt; portals = new HashMap&lt;&gt;();
71     @VisibleForTesting
72     final Map&lt;Statement, List&lt;DeferredExecution&gt;&gt; deferredExecutionsByStmt = new LinkedHashMap&lt;&gt;();
73     @VisibleForTesting
74     @Nullable
75     CompletableFuture&lt;?&gt; activeExecution;
76     private final NodeContext nodeCtx;
77     private final Analyzer analyzer;
78     private final Planner planner;
79     private final JobsLogs jobsLogs;
80     private final boolean isReadOnly;
81     private final ParameterTypeExtractor parameterTypeExtractor;
82     private TransactionState currentTransactionState = TransactionState.IDLE;
83     public Session(NodeContext nodeCtx,
84                    Analyzer analyzer,
85                    Planner planner,
86                    JobsLogs jobsLogs,
87                    boolean isReadOnly,
88                    DependencyCarrier executor,
89                    AccessControl accessControl,
90                    SessionContext sessionContext) {
91         this.nodeCtx = nodeCtx;
92         this.analyzer = analyzer;
93         this.planner = planner;
94         this.jobsLogs = jobsLogs;
95         this.isReadOnly = isReadOnly;
96         this.executor = executor;
97         this.accessControl = accessControl;
98         this.sessionContext = sessionContext;
99         this.parameterTypeExtractor = new ParameterTypeExtractor();
100     }
101     public void quickExec(String statement, ResultReceiver&lt;?&gt; resultReceiver, Row params) {
102         quickExec(statement, SqlParser::createStatement, resultReceiver, params);
103     }
104     public void quickExec(String statement, Function&lt;String, Statement&gt; parse, ResultReceiver&lt;?&gt; resultReceiver, Row params) {
105         CoordinatorTxnCtx txnCtx = new CoordinatorTxnCtx(sessionContext);
106         Statement parsedStmt = parse.apply(statement);
107         AnalyzedStatement analyzedStatement = analyzer.analyze(parsedStmt, sessionContext, ParamTypeHints.EMPTY);
108         RoutingProvider routingProvider = new RoutingProvider(Randomness.get().nextInt(), planner.getAwarenessAttributes());
109         UUID jobId = UUIDs.dirtyUUID();
110         ClusterState clusterState = planner.currentClusterState();
111         PlannerContext plannerContext = new PlannerContext(
112             clusterState,
113             routingProvider,
114             jobId,
115             txnCtx,
116             nodeCtx,
117             0,
118             params
119         );
120         Plan plan;
121         try {
122             plan = planner.plan(analyzedStatement, plannerContext);
123         } catch (Throwable t) {
124             jobsLogs.logPreExecutionFailure(jobId, statement, SQLExceptions.messageOf(t), sessionContext.sessionUser());
125             throw t;
126         }
127         StatementClassifier.Classification classification = StatementClassifier.classify(plan);
128         jobsLogs.logExecutionStart(jobId, statement, sessionContext.sessionUser(), classification);
129         JobsLogsUpdateListener jobsLogsUpdateListener = new JobsLogsUpdateListener(jobId, jobsLogs);
130         if (!analyzedStatement.isWriteOperation()) {
131             resultReceiver = new RetryOnFailureResultReceiver(
132                 executor.clusterService(),
133                 clusterState,
134                 indexName -&gt; clusterState.metadata().hasIndex(indexName),
135                 resultReceiver,
136                 jobId,
137                 (newJobId, retryResultReceiver) -&gt; retryQuery(
138                     newJobId,
139                     analyzedStatement,
140                     routingProvider,
141                     new RowConsumerToResultReceiver(retryResultReceiver, 0, jobsLogsUpdateListener),
142                     params,
143                     txnCtx,
144                     nodeCtx
145                 )
146             );
147         }
148         RowConsumerToResultReceiver consumer = new RowConsumerToResultReceiver(resultReceiver, 0, jobsLogsUpdateListener);
149         plan.execute(executor, plannerContext, consumer, params, SubQueryResults.EMPTY);
150     }
151     private void retryQuery(UUID jobId,
152                             AnalyzedStatement stmt,
153                             RoutingProvider routingProvider,
154                             RowConsumer consumer,
155                             Row params,
156                             CoordinatorTxnCtx txnCtx,
157                             NodeContext nodeCtx) {
158         PlannerContext plannerContext = new PlannerContext(
159             planner.currentClusterState(),
160             routingProvider,
161             jobId,
162             txnCtx,
163             nodeCtx,
164             0,
165             params
166         );
167         Plan plan = planner.plan(stmt, plannerContext);
168         plan.execute(executor, plannerContext, consumer, params, SubQueryResults.EMPTY);
169     }
170     private Portal getSafePortal(String portalName) {
171         Portal portal = portals.get(portalName);
172         if (portal == null) {
173             throw new IllegalArgumentException("Cannot find portal: " + portalName);
174         }
175         return portal;
176     }
177     public SessionContext sessionContext() {
178         return sessionContext;
179     }
180     public void parse(String statementName, String query, List&lt;DataType&gt; paramTypes) {
181         if (LOGGER.isDebugEnabled()) {
182             LOGGER.debug("method=parse stmtName={} query={} paramTypes={}", statementName, query, paramTypes);
183         }
184         Statement statement;
185         try {
186             statement = SqlParser.createStatement(query);
187         } catch (Throwable t) {
188             if ("".equals(query)) {
189                 statement = EMPTY_STMT;
190             } else {
191                 jobsLogs.logPreExecutionFailure(UUIDs.dirtyUUID(), query, SQLExceptions.messageOf(t), sessionContext.sessionUser());
192                 throw t;
193             }
194         }
195         analyze(statementName, statement, paramTypes, query);
196     }
197     public void analyze(String statementName,
198                         Statement statement,
199                         List&lt;DataType&gt; paramTypes,
200                         @Nullable String query) {
201         AnalyzedStatement analyzedStatement;
202         DataType[] parameterTypes;
203         try {
204             analyzedStatement = analyzer.analyze(
205                 statement,
206                 sessionContext,
207                 new ParamTypeHints(paramTypes));
208             parameterTypes = parameterTypeExtractor.getParameterTypes(
209                 x -&gt; Relations.traverseDeepSymbols(analyzedStatement, x)
210             );
211         } catch (Throwable t) {
212             jobsLogs.logPreExecutionFailure(
213                 UUIDs.dirtyUUID(),
214                 query == null ? statementName : query,
215                 SQLExceptions.messageOf(t),
216                 sessionContext.sessionUser());
217             throw t;
218         }
219         preparedStatements.put(
220             statementName,
221             new PreparedStmt(statement, analyzedStatement, query, parameterTypes));
222     }
223     public void bind(String portalName,
224                      String statementName,
225                      List&lt;Object&gt; params,
226                      @Nullable FormatCodes.FormatCode[] resultFormatCodes) {
227         if (LOGGER.isDebugEnabled()) {
228             LOGGER.debug("method=bind portalName={} statementName={} params={}", portalName, statementName, params);
229         }
230         PreparedStmt preparedStmt;
231         try {
232             preparedStmt = getSafeStmt(statementName);
233         } catch (Throwable t) {
234             jobsLogs.logPreExecutionFailure(UUIDs.dirtyUUID(), null, SQLExceptions.messageOf(t), sessionContext.sessionUser());
235             throw t;
236         }
237         Portal portal = new Portal(
238             portalName,
239             preparedStmt,
240             params,
241             preparedStmt.analyzedStatement(),
242             resultFormatCodes);
243         Portal oldPortal = portals.put(portalName, portal);
244         if (oldPortal != null) {
245             oldPortal.closeActiveConsumer();
246         }
247     }
248     public DescribeResult describe(char type, String portalOrStatement) {
249         if (LOGGER.isDebugEnabled()) {
250             LOGGER.debug("method=describe type={} portalOrStatement={}", type, portalOrStatement);
251         }
252         switch (type) {
253             case 'P':
254                 Portal portal = getSafePortal(portalOrStatement);
255                 var analyzedStmt = portal.analyzedStatement();
256                 return new DescribeResult(
257                     portal.preparedStmt().parameterTypes(),
258                     analyzedStmt.outputs(),
259                     resolveTableFromSelect(analyzedStmt)
260                 );
261             case 'S':
262                 PreparedStmt preparedStmt = preparedStatements.get(portalOrStatement);
263                 AnalyzedStatement analyzedStatement = preparedStmt.analyzedStatement();
264                 return new DescribeResult(
265                     preparedStmt.parameterTypes(),
266                     analyzedStatement.outputs(),
267                     resolveTableFromSelect(analyzedStatement)
268                 );
269             default:
270                 throw new AssertionError("Unsupported type: " + type);
271         }
272     }
273     @Nullable
274     @SuppressWarnings("unchecked")
275     private RelationInfo resolveTableFromSelect(AnalyzedStatement stmt) {
276         if (stmt instanceof QueriedSelectRelation) {
277             var relation = ((QueriedSelectRelation) stmt);
278             List&lt;AnalyzedRelation&gt; from = relation.from();
279             if (from.size() == 1 &amp;&amp; from.get(0) instanceof AbstractTableRelation) {
280                 return ((AbstractTableRelation&lt;? extends TableInfo&gt;) from.get(0)).tableInfo();
281             }
282         }
283         return null;
284     }
285     @Nullable
286     public CompletableFuture&lt;?&gt; execute(String portalName, int maxRows, ResultReceiver&lt;?&gt; resultReceiver) {
287         if (LOGGER.isDebugEnabled()) {
288             LOGGER.debug("method=execute portalName={} maxRows={}", portalName, maxRows);
289         }
290         Portal portal = getSafePortal(portalName);
291         var analyzedStmt = portal.analyzedStatement();
292         if (isReadOnly &amp;&amp; analyzedStmt.isWriteOperation()) {
293             throw new ReadOnlyException(portal.preparedStmt().rawStatement());
294         }
295         if (analyzedStmt instanceof AnalyzedBegin) {
296             currentTransactionState = TransactionState.IN_TRANSACTION;
297             resultReceiver.allFinished(false);
298         } else if (analyzedStmt instanceof AnalyzedCommit) {
299             currentTransactionState = TransactionState.IDLE;
300             resultReceiver.allFinished(false);
301             return resultReceiver.completionFuture();
302         } else if (analyzedStmt instanceof AnalyzedDeallocate) {
303             String stmtToDeallocate = ((AnalyzedDeallocate) analyzedStmt).preparedStmtName();
304             if (stmtToDeallocate != null) {
305                 close((byte) 'S', stmtToDeallocate);
306             } else {
307                 if (LOGGER.isDebugEnabled()) {
308                     LOGGER.debug("deallocating all prepared statements");
309                 }
310                 preparedStatements.clear();
311             }
312             resultReceiver.allFinished(false);
313         } else if (analyzedStmt instanceof AnalyzedDiscard) {
314             AnalyzedDiscard discard = (AnalyzedDiscard) analyzedStmt;
315             if (discard.target() == Target.ALL) {
316                 close();
317             }
318             resultReceiver.allFinished(false);
319         } else if (analyzedStmt.isWriteOperation()) {
320             deferredExecutionsByStmt.compute(
321                 portal.preparedStmt().parsedStatement(), (key, oldValue) -&gt; {
322                     DeferredExecution deferredExecution = new DeferredExecution(portal, maxRows, resultReceiver);
323                     if (oldValue == null) {
324                         ArrayList&lt;DeferredExecution&gt; deferredExecutions = new ArrayList&lt;&gt;();
325                         deferredExecutions.add(deferredExecution);
326                         return deferredExecutions;
327                     } else {
328                         oldValue.add(deferredExecution);
329                         return oldValue;
330                     }
331                 }
332             );
333             return resultReceiver.completionFuture();
334         } else {
335             if (!deferredExecutionsByStmt.isEmpty()) {
336                 throw new UnsupportedOperationException(
337                     "Only write operations are allowed in Batch statements");
338             }
339             if (activeExecution == null) {
340                 activeExecution = singleExec(portal, resultReceiver, maxRows);
341             } else {
342                 activeExecution = activeExecution
343                     .thenCompose(ignored -&gt; singleExec(portal, resultReceiver, maxRows));
344             }
345             return activeExecution;
346         }
347         return null;
348     }
349     public void flush() {
350         assert !deferredExecutionsByStmt.isEmpty()
351             : "Session.flush() must only be called if there are deferred executions";
352         //
353         activeExecution = triggerDeferredExecutions();
354     }
355     public CompletableFuture&lt;?&gt; sync() {
356         if (activeExecution == null) {
357             return triggerDeferredExecutions();
358         } else {
359             var result = activeExecution;
360             activeExecution = null;
361             return result;
362         }
363     }
364     private CompletableFuture&lt;?&gt; triggerDeferredExecutions() {
365         switch (deferredExecutionsByStmt.size()) {
366             case 0:
367                 LOGGER.debug("method=sync deferredExecutions=0");
368                 return CompletableFuture.completedFuture(null);
369             case 1: {
370                 var entry = deferredExecutionsByStmt.entrySet().iterator().next();
371                 deferredExecutionsByStmt.clear();
372                 return exec(entry.getKey(), entry.getValue());
373             }
374             default: {
375                 CompletableFuture&lt;?&gt; allCompleted = null;
376                 for (var entry : deferredExecutionsByStmt.entrySet()) {
377                     var statement = entry.getKey();
378                     var deferredExecutions = entry.getValue();
379                     if (allCompleted == null) {
380                         allCompleted = exec(statement, deferredExecutions);
381                     } else {
382                         allCompleted = allCompleted
383                             .exceptionally(swallowException -&gt; null)
384                             .thenCompose(ignored -&gt; exec(statement, deferredExecutions));
385                     }
386                 }
387                 deferredExecutionsByStmt.clear();
388                 return allCompleted;
389             }
390         }
391     }
392     private CompletableFuture&lt;?&gt; exec(Statement statement, List&lt;DeferredExecution&gt; executions) {
393         if (executions.size() == 1) {
394             var toExec = executions.get(0);
395             return singleExec(toExec.portal(), toExec.resultReceiver(), toExec.maxRows());
396         } else {
397             return bulkExec(statement, executions);
398         }
399     }
400     private CompletableFuture&lt;?&gt; bulkExec(Statement statement, List&lt;DeferredExecution&gt; toExec) {
401         assert toExec.size() &gt;= 1 : "Must have at least 1 deferred execution for bulk exec";
402         var jobId = UUIDs.dirtyUUID();
403         var routingProvider = new RoutingProvider(Randomness.get().nextInt(), planner.getAwarenessAttributes());
404         var clusterState = executor.clusterService().state();
405         var txnCtx = new CoordinatorTxnCtx(sessionContext);
406         var plannerContext = new PlannerContext(
407             clusterState,
408             routingProvider,
409             jobId,
410             txnCtx,
411             nodeCtx,
412             0,
413             null);
414         PreparedStmt firstPreparedStatement = toExec.get(0).portal().preparedStmt();
415         AnalyzedStatement analyzedStatement = firstPreparedStatement.analyzedStatement();
416         Plan plan;
417         try {
418             plan = planner.plan(analyzedStatement, plannerContext);
419         } catch (Throwable t) {
420             jobsLogs.logPreExecutionFailure(
421                 jobId,
422                 firstPreparedStatement.rawStatement(),
423                 SQLExceptions.messageOf(t),
424                 sessionContext.sessionUser());
425             throw t;
426         }
427         jobsLogs.logExecutionStart(
428             jobId,
429             firstPreparedStatement.rawStatement(),
430             sessionContext.sessionUser(),
431             StatementClassifier.classify(plan)
432         );
433         var bulkArgs = Lists2.map(toExec, x -&gt; (Row) new RowN(x.portal().params().toArray()));
434         List&lt;CompletableFuture&lt;Long&gt;&gt; rowCounts = plan.executeBulk(
435             executor,
436             plannerContext,
437             bulkArgs,
438             SubQueryResults.EMPTY
439         );
440         CompletableFuture&lt;Void&gt; allRowCounts = CompletableFuture.allOf(rowCounts.toArray(new CompletableFuture[0]));
441         List&lt;CompletableFuture&lt;?&gt;&gt; resultReceiverFutures = Lists2.map(toExec, x -&gt; x.resultReceiver().completionFuture());
442         CompletableFuture&lt;Void&gt; allResultReceivers = CompletableFuture.allOf(resultReceiverFutures.toArray(new CompletableFuture[0]));
443         return allRowCounts
444             .exceptionally(t -&gt; null)             .thenAccept(ignored -&gt; emitRowCountsToResultReceivers(jobId, jobsLogs, toExec, rowCounts))
445             .runAfterBoth(allResultReceivers, () -&gt; {});
446     }
447     private static void emitRowCountsToResultReceivers(UUID jobId,
448                                                        JobsLogs jobsLogs,
449                                                        List&lt;DeferredExecution&gt; executions,
450                                                        List&lt;CompletableFuture&lt;Long&gt;&gt; completedRowCounts) {
451         Long[] cells = new Long[1];
452         RowN row = new RowN(cells);
453         for (int i = 0; i &lt; completedRowCounts.size(); i++) {
454             CompletableFuture&lt;Long&gt; completedRowCount = completedRowCounts.get(i);
455             ResultReceiver&lt;?&gt; resultReceiver = executions.get(i).resultReceiver();
456             try {
457                 Long rowCount = completedRowCount.join();
458                 cells[0] = rowCount == null ? Row1.ERROR : rowCount;
459             } catch (Throwable t) {
460                 cells[0] = Row1.ERROR;
461             }
462             resultReceiver.setNextRow(row);
463             resultReceiver.allFinished(false);
464         }
465         jobsLogs.logExecutionEnd(jobId, null);
466     }
467     @VisibleForTesting
468     CompletableFuture&lt;?&gt; singleExec(Portal portal, ResultReceiver&lt;?&gt; resultReceiver, int maxRows) {
469         var activeConsumer = portal.activeConsumer();
470         if (activeConsumer != null &amp;&amp; activeConsumer.suspended()) {
471             activeConsumer.replaceResultReceiver(resultReceiver, maxRows);
472             activeConsumer.resume();
473             return resultReceiver.completionFuture();
474         }
475         var jobId = UUIDs.dirtyUUID();
476         var routingProvider = new RoutingProvider(Randomness.get().nextInt(), planner.getAwarenessAttributes());
477         var clusterState = executor.clusterService().state();
478         var txnCtx = new CoordinatorTxnCtx(sessionContext);
479         var nodeCtx = executor.nodeContext();
480         var params = new RowN(portal.params().toArray());
481         var plannerContext = new PlannerContext(
482             clusterState, routingProvider, jobId, txnCtx, nodeCtx, maxRows, params);
483         var analyzedStmt = portal.analyzedStatement();
484         String rawStatement = portal.preparedStmt().rawStatement();
485         if (analyzedStmt == null) {
486             String errorMsg = "Statement must have been analyzed: " + rawStatement;
487             jobsLogs.logPreExecutionFailure(jobId, rawStatement, errorMsg, sessionContext.sessionUser());
488             throw new IllegalStateException(errorMsg);
489         }
490         Plan plan;
491         try {
492             plan = planner.plan(analyzedStmt, plannerContext);
493         } catch (Throwable t) {
494             jobsLogs.logPreExecutionFailure(jobId, rawStatement, SQLExceptions.messageOf(t), sessionContext.sessionUser());
495             throw t;
496         }
497         if (!analyzedStmt.isWriteOperation()) {
498             resultReceiver = new RetryOnFailureResultReceiver(
499                 executor.clusterService(),
500                 clusterState,
501                 indexName -&gt; executor.clusterService().state().metadata().hasIndex(indexName),
502                 resultReceiver,
503                 jobId,
504                 (newJobId, resultRec) -&gt; retryQuery(
505                     newJobId,
506                     analyzedStmt,
507                     routingProvider,
508                     new RowConsumerToResultReceiver(
509                         resultRec,
510                         maxRows,
511                         new JobsLogsUpdateListener(newJobId, jobsLogs)),
512                     params,
513                     txnCtx,
514                     nodeCtx
515                 )
516             );
517         }
518         jobsLogs.logExecutionStart(
519             jobId, rawStatement, sessionContext.sessionUser(), StatementClassifier.classify(plan));
520         RowConsumerToResultReceiver consumer = new RowConsumerToResultReceiver(
521             resultReceiver, maxRows, new JobsLogsUpdateListener(jobId, jobsLogs));
522         portal.setActiveConsumer(consumer);
523         plan.execute(executor, plannerContext, consumer, params, SubQueryResults.EMPTY);
524         return resultReceiver.completionFuture();
525     }
526     @Nullable
527     public List&lt;? extends DataType&gt; getOutputTypes(String portalName) {
528         Portal portal = getSafePortal(portalName);
529         var analyzedStatement = portal.analyzedStatement();
530         List&lt;Symbol&gt; fields = analyzedStatement.outputs();
531         if (fields != null) {
532             return Symbols.typeView(fields);
533         }
534         return null;
535     }
536     public String getQuery(String portalName) {
537         return getSafePortal(portalName).preparedStmt().rawStatement();
538     }
539     public DataType&lt;?&gt; getParamType(String statementName, int idx) {
540         PreparedStmt stmt = getSafeStmt(statementName);
541         return stmt.getEffectiveParameterType(idx);
542     }
543     private PreparedStmt getSafeStmt(String statementName) {
544         PreparedStmt preparedStmt = preparedStatements.get(statementName);
545         if (preparedStmt == null) {
546             throw new IllegalArgumentException("No statement found with name: " + statementName);
547         }
548         return preparedStmt;
549     }
550     @Nullable
551     public FormatCodes.FormatCode[] getResultFormatCodes(String portal) {
552         return getSafePortal(portal).resultFormatCodes();
553     }
554     public void close(byte type, String name) {
555         if (LOGGER.isDebugEnabled()) {
556             LOGGER.debug("method=close type={} name={}", (char) type, name);
557         }
558         switch (type) {
559             case 'P': {
560                 Portal portal = portals.remove(name);
561                 if (portal != null) {
562                     portal.closeActiveConsumer();
563                 }
564                 return;
565             }
566             case 'S': {
567                 PreparedStmt preparedStmt = preparedStatements.remove(name);
568                 if (preparedStmt != null) {
569                     Iterator&lt;Map.Entry&lt;String, Portal&gt;&gt; it = portals.entrySet().iterator();
570                     while (it.hasNext()) {
571                         var entry = it.next();
572                         var portal = entry.getValue();
573                         if (portal.preparedStmt().equals(preparedStmt)) {
574                             portal.closeActiveConsumer();
575                             it.remove();
576                         }
577                     }
578                 }
579                 return;
580             }
581             default:
582                 throw new IllegalArgumentException("Invalid type: " + type + ", valid types are: [P, S]");
583         }
584     }
585     @Override
586     public void close() {
587         currentTransactionState = TransactionState.IDLE;
588         resetDeferredExecutions();
589         activeExecution = null;
590         for (Portal portal : portals.values()) {
591             portal.closeActiveConsumer();
592         }
593         portals.clear();
594         preparedStatements.clear();
595     }
596     public boolean hasDeferredExecutions() {
597         return !deferredExecutionsByStmt.isEmpty();
598     }
599     public void resetDeferredExecutions() {
600         for (var deferredExecutions : deferredExecutionsByStmt.values()) {
601             for (DeferredExecution deferredExecution : deferredExecutions) {
602                 deferredExecution.portal().closeActiveConsumer();
603                 portals.remove(deferredExecution.portal().name());
604             }
605         }
606         deferredExecutionsByStmt.clear();
607     }
608     public TransactionState transactionState() {
609         return currentTransactionState;
610     }
611 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
