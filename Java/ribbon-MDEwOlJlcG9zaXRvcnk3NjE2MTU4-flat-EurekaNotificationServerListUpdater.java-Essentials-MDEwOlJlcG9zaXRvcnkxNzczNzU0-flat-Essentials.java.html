
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.144193296960249%, Tokens: 19</h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-EurekaNotificationServerListUpdater.java</h3>
            <pre><code>1  package com.netflix.niws.loadbalancer;
<span onclick='openModal()' class='match'>2  import com.google.common.util.concurrent.ThreadFactoryBuilder;
3  import com.netflix.config.DynamicIntProperty;
4  import com.netflix.discovery.CacheRefreshedEvent;
5  import com.netflix.discovery.EurekaClient;
6  import com.netflix.discovery.EurekaEvent;
7  import com.netflix.discovery.EurekaEventListener;
8  import com.netflix.loadbalancer.*;
9  import org.slf4j.Logger;
10  import org.slf4j.LoggerFactory;
11  import javax.inject.Provider;
12  import java.util.Date;
13  import java.util.concurrent.ArrayBlockingQueue;
14  import java.util.concurrent.ExecutorService;
15  import java.util.concurrent.ThreadPoolExecutor;
16  import java.util.concurrent.TimeUnit;
17  import java.util.concurrent.atomic.AtomicBoolean;
18  import java.util.concurrent.atomic.AtomicLong;
19  public class EurekaNotificationServerListUpdater implements ServerListUpdater {
20      private static final Logger logger = LoggerFactory.getLogger(EurekaNotificationServerListUpdater.class);
</span>21      private static class LazyHolder {
22          private final static String CORE_THREAD = "EurekaNotificationServerListUpdater.ThreadPoolSize";
23          private final static String QUEUE_SIZE = "EurekaNotificationServerListUpdater.queueSize";
24          private final static LazyHolder SINGLETON = new LazyHolder();
25          private final DynamicIntProperty poolSizeProp = new DynamicIntProperty(CORE_THREAD, 2);
26          private final DynamicIntProperty queueSizeProp = new DynamicIntProperty(QUEUE_SIZE, 1000);
27          private final ThreadPoolExecutor defaultServerListUpdateExecutor;
28          private final Thread shutdownThread;
29          private LazyHolder() {
30              int corePoolSize = getCorePoolSize();
31              defaultServerListUpdateExecutor = new ThreadPoolExecutor(
32                      corePoolSize,
33                      corePoolSize * 5,
34                      0,
35                      TimeUnit.NANOSECONDS,
36                      new ArrayBlockingQueue<Runnable>(queueSizeProp.get()),
37                      new ThreadFactoryBuilder()
38                              .setNameFormat("EurekaNotificationServerListUpdater-%d")
39                              .setDaemon(true)
40                              .build()
41              );
42              poolSizeProp.addCallback(new Runnable() {
43                  @Override
44                  public void run() {
45                      int corePoolSize = getCorePoolSize();
46                      defaultServerListUpdateExecutor.setCorePoolSize(corePoolSize);
47                      defaultServerListUpdateExecutor.setMaximumPoolSize(corePoolSize * 5);
48                  }
49              });
50              shutdownThread = new Thread(new Runnable() {
51                  @Override
52                  public void run() {
53                      logger.info("Shutting down the Executor for EurekaNotificationServerListUpdater");
54                      try {
55                          defaultServerListUpdateExecutor.shutdown();
56                          Runtime.getRuntime().removeShutdownHook(shutdownThread);
57                      } catch (Exception e) {
58                      }
59                  }
60              });
61              Runtime.getRuntime().addShutdownHook(shutdownThread);
62          }
63          private int getCorePoolSize() {
64              int propSize = poolSizeProp.get();
65              if (propSize > 0) {
66                  return propSize;
67              }
68              return 2; 
69          }        
70      }
71      public static ExecutorService getDefaultRefreshExecutor() {
72          return LazyHolder.SINGLETON.defaultServerListUpdateExecutor;
73      }
74       final AtomicBoolean updateQueued = new AtomicBoolean(false);
75      private final AtomicBoolean isActive = new AtomicBoolean(false);
76      private final AtomicLong lastUpdated = new AtomicLong(System.currentTimeMillis());
77      private final Provider<EurekaClient> eurekaClientProvider;
78      private final ExecutorService refreshExecutor;
79      private volatile EurekaEventListener updateListener;
80      private volatile EurekaClient eurekaClient;
81      public EurekaNotificationServerListUpdater() {
82          this(new LegacyEurekaClientProvider());
83      }
84      public EurekaNotificationServerListUpdater(final Provider<EurekaClient> eurekaClientProvider) {
85          this(eurekaClientProvider, getDefaultRefreshExecutor());
86      }
87      public EurekaNotificationServerListUpdater(final Provider<EurekaClient> eurekaClientProvider, ExecutorService refreshExecutor) {
88          this.eurekaClientProvider = eurekaClientProvider;
89          this.refreshExecutor = refreshExecutor;
90      }
91      @Override
92      public synchronized void start(final UpdateAction updateAction) {
93          if (isActive.compareAndSet(false, true)) {
94              this.updateListener = new EurekaEventListener() {
95                  @Override
96                  public void onEvent(EurekaEvent event) {
97                      if (event instanceof CacheRefreshedEvent) {
98                          if (!updateQueued.compareAndSet(false, true)) {  
99                              logger.info("an update action is already queued, returning as no-op");
100                              return;
101                          }
102                          if (!refreshExecutor.isShutdown()) {
103                              try {
104                                  refreshExecutor.submit(new Runnable() {
105                                      @Override
106                                      public void run() {
107                                          try {
108                                              updateAction.doUpdate();
109                                              lastUpdated.set(System.currentTimeMillis());
110                                          } catch (Exception e) {
111                                              logger.warn("Failed to update serverList", e);
112                                          } finally {
113                                              updateQueued.set(false);
114                                          }
115                                      }
116                                  });  
117                              } catch (Exception e) {
118                                  logger.warn("Error submitting update task to executor, skipping one round of updates", e);
119                                  updateQueued.set(false);  
120                              }
121                          }
122                          else {
123                              logger.debug("stopping EurekaNotificationServerListUpdater, as refreshExecutor has been shut down");
124                              stop();
125                          }
126                      }
127                  }
128              };
129              if (eurekaClient == null) {
130                  eurekaClient = eurekaClientProvider.get();
131              }
132              if (eurekaClient != null) {
133                  eurekaClient.registerEventListener(updateListener);
134              } else {
135                  logger.error("Failed to register an updateListener to eureka client, eureka client is null");
136                  throw new IllegalStateException("Failed to start the updater, unable to register the update listener due to eureka client being null.");
137              }
138          } else {
139              logger.info("Update listener already registered, no-op");
140          }
141      }
142      @Override
143      public synchronized void stop() {
144          if (isActive.compareAndSet(true, false)) {
145              if (eurekaClient != null) {
146                  eurekaClient.unregisterEventListener(updateListener);
147              }
148          } else {
149              logger.info("Not currently active, no-op");
150          }
151      }
152      @Override
153      public String getLastUpdate() {
154          return new Date(lastUpdated.get()).toString();
155      }
156      @Override
157      public long getDurationSinceLastUpdateMs() {
158          return System.currentTimeMillis() - lastUpdated.get();
159      }
160      @Override
161      public int getNumberMissedCycles() {
162          return 0;
163      }
164      @Override
165      public int getCoreThreads() {
166          if (isActive.get()) {
167              if (refreshExecutor != null && refreshExecutor instanceof ThreadPoolExecutor) {
168                  return ((ThreadPoolExecutor) refreshExecutor).getCorePoolSize();
169              }
170          }
171          return 0;
172      }
173  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Essentials.java</h3>
            <pre><code>1  package com.earth2me.essentials;
2  import static com.earth2me.essentials.I18n.tl;
3  import com.earth2me.essentials.commands.EssentialsCommand;
4  import com.earth2me.essentials.commands.IEssentialsCommand;
5  import com.earth2me.essentials.commands.NoChargeException;
6  import com.earth2me.essentials.commands.NotEnoughArgumentsException;
7  import com.earth2me.essentials.commands.QuietAbortException;
8  import com.earth2me.essentials.metrics.Metrics;
9  import com.earth2me.essentials.metrics.MetricsListener;
10  import com.earth2me.essentials.metrics.MetricsStarter;
11  import com.earth2me.essentials.perm.PermissionsHandler;
12  import com.earth2me.essentials.register.payment.Methods;
13  import com.earth2me.essentials.signs.SignBlockListener;
14  import com.earth2me.essentials.signs.SignEntityListener;
15  import com.earth2me.essentials.signs.SignPlayerListener;
16  import com.earth2me.essentials.textreader.IText;
17  import com.earth2me.essentials.textreader.KeywordReplacer;
18  import com.earth2me.essentials.textreader.SimpleTextInput;
19  import com.earth2me.essentials.utils.DateUtil;
20  import com.google.common.base.Function;
21  import com.google.common.base.Throwables;
22  import com.google.common.collect.Iterables;
23  import java.io.File;
24  import java.io.FileReader;
25  import java.io.IOException;
26  import java.lang.reflect.InvocationTargetException;
27  import java.lang.reflect.Method;
28  import java.util.ArrayList;
29  import java.util.Arrays;
30  import java.util.Collection;
31  import java.util.List;
32  import java.util.UUID;
33  import java.util.logging.Level;
34  import java.util.logging.Logger;
35  import java.util.regex.Matcher;
36  import java.util.regex.Pattern;
37  import net.ess3.api.Economy;
38  import net.ess3.api.IEssentials;
39  import net.ess3.api.IItemDb;
40  import net.ess3.api.IJails;
41  import net.ess3.api.ISettings;
42  import org.bukkit.Bukkit;
43  import org.bukkit.ChatColor;
44  import org.bukkit.Server;
45  import org.bukkit.World;
46  import org.bukkit.block.Block;
47  import org.bukkit.command.BlockCommandSender;
48  import org.bukkit.command.Command;
49  import org.bukkit.command.CommandSender;
50  import org.bukkit.command.PluginCommand;
51  import org.bukkit.command.TabCompleter;
<span onclick='openModal()' class='match'>52  import org.bukkit.entity.Player;
53  import org.bukkit.event.EventHandler;
54  import org.bukkit.event.EventPriority;
55  import org.bukkit.event.HandlerList;
56  import org.bukkit.event.Listener;
57  import org.bukkit.event.player.PlayerJoinEvent;
58  import org.bukkit.event.world.WorldLoadEvent;
59  import org.bukkit.event.world.WorldUnloadEvent;
60  import org.bukkit.plugin.InvalidDescriptionException;
61  import org.bukkit.plugin.Plugin;
62  import org.bukkit.plugin.PluginDescriptionFile;
63  import org.bukkit.plugin.PluginManager;
64  import org.bukkit.plugin.java.JavaPlugin;
65  import org.bukkit.plugin.java.JavaPluginLoader;
66  import org.bukkit.scheduler.BukkitScheduler;
67  import org.bukkit.scheduler.BukkitTask;
68  import org.yaml.snakeyaml.error.YAMLException;
69  public class Essentials extends JavaPlugin implements net.ess3.api.IEssentials
70  {
71  	public static final int BUKKIT_VERSION = 3050;
</span>72  	private static final Logger LOGGER = Logger.getLogger("Essentials");
73  	private transient ISettings settings;
74  	private final transient TNTExplodeListener tntListener = new TNTExplodeListener(this);
75  	private transient Jails jails;
76  	private transient Warps warps;
77  	private transient Worth worth;
78  	private transient List<IConf> confList;
79  	private transient Backup backup;
80  	private transient ItemDb itemDb;
81  	private transient final Methods paymentMethod = new Methods();
82  	private transient PermissionsHandler permissionsHandler;
83  	private transient AlternativeCommandsHandler alternativeCommandsHandler;
84  	private transient UserMap userMap;
85  	private transient ExecuteTimer execTimer;
86  	private transient I18n i18n;
87  	private transient Metrics metrics;
88  	private transient EssentialsTimer timer;
89  	private final transient List<String> vanishedPlayers = new ArrayList<String>();
90  	private transient Method oldGetOnlinePlayers;
91  	public Essentials()
92  	{
93  	}
94  	public Essentials(final Server server)
95  	{
96  		super(new JavaPluginLoader(server), new PluginDescriptionFile("Essentials", "", "com.earth2me.essentials.Essentials"), null, null);
97  	}
98  	@Override
99  	public ISettings getSettings()
100  	{
101  		return settings;
102  	}
103  	public void setupForTesting(final Server server) throws IOException, InvalidDescriptionException
104  	{
105  		final File dataFolder = File.createTempFile("essentialstest", "");
106  		if (!dataFolder.delete())
107  		{
108  			throw new IOException();
109  		}
110  		if (!dataFolder.mkdir())
111  		{
112  			throw new IOException();
113  		}
114  		i18n = new I18n(this);
115  		i18n.onEnable();
116  		i18n.updateLocale("en");
117  		LOGGER.log(Level.INFO, tl("usingTempFolderForTesting"));
118  		LOGGER.log(Level.INFO, dataFolder.toString());
119  		this.initialize(null, server, new PluginDescriptionFile(new FileReader(new File("src" + File.separator + "plugin.yml"))), dataFolder, null, null);
120  		settings = new Settings(this);
121  		userMap = new UserMap(this);
122  		permissionsHandler = new PermissionsHandler(this, false);
123  		Economy.setEss(this);
124  		confList = new ArrayList<IConf>();
125  		jails = new Jails(this);
126  		registerListeners(server.getPluginManager());
127  	}
128  	@Override
129  	public void onEnable()
130  	{
131  		try
132  		{
133  			LOGGER.setParent(this.getLogger());
134  			execTimer = new ExecuteTimer();
135  			execTimer.start();
136  			i18n = new I18n(this);
137  			i18n.onEnable();
138  			execTimer.mark("I18n1");
139  			final PluginManager pm = getServer().getPluginManager();
140  			for (Plugin plugin : pm.getPlugins())
141  			{
142  				if (plugin.getDescription().getName().startsWith("Essentials")
143  					&& !plugin.getDescription().getVersion().equals(this.getDescription().getVersion())
144  					&& !plugin.getDescription().getName().equals("EssentialsAntiCheat"))
145  				{
146  					LOGGER.log(Level.WARNING, tl("versionMismatch", plugin.getDescription().getName()));
147  				}
148  			}
149  			final Matcher versionMatch = Pattern.compile("git-Bukkit-(?:(?:[0-9]+)\\.)+[0-9]+-R[\\.0-9]+-(?:[0-9]+-g[0-9a-f]+-)?b([0-9]+)jnks.*").matcher(getServer().getVersion());
150  			if (versionMatch.matches())
151  			{
152  				final int versionNumber = Integer.parseInt(versionMatch.group(1));
153  				if (versionNumber < BUKKIT_VERSION && versionNumber > 100)
154  				{
155  					wrongVersion();
156  					this.setEnabled(false);
157  					return;
158  				}
159  			}
160  			else
161  			{
162  				LOGGER.log(Level.INFO, tl("bukkitFormatChanged"));
163  				LOGGER.log(Level.INFO, getServer().getVersion());
164  				LOGGER.log(Level.INFO, getServer().getBukkitVersion());
165  			}
166  			execTimer.mark("BukkitCheck");
167  			for (Method method : Server.class.getDeclaredMethods())
168  			{
169  				if (method.getName().endsWith("getOnlinePlayers") && method.getReturnType() == Player[].class)
170  				{
171  					oldGetOnlinePlayers = method;
172  					break;
173  				}
174  			}
175  			try
176  			{
177  				final EssentialsUpgrade upgrade = new EssentialsUpgrade(this);
178  				upgrade.beforeSettings();
179  				execTimer.mark("Upgrade");
180  				confList = new ArrayList<IConf>();
181  				settings = new Settings(this);
182  				confList.add(settings);
183  				execTimer.mark("Settings");
184  				userMap = new UserMap(this);
185  				confList.add(userMap);
186  				execTimer.mark("Init(Usermap)");
187  				upgrade.afterSettings();
188  				execTimer.mark("Upgrade2");
189  				i18n.updateLocale(settings.getLocale());
190  				warps = new Warps(getServer(), this.getDataFolder());
191  				confList.add(warps);
192  				execTimer.mark("Init(Spawn/Warp)");
193  				worth = new Worth(this.getDataFolder());
194  				confList.add(worth);
195  				itemDb = new ItemDb(this);
196  				confList.add(itemDb);
197  				execTimer.mark("Init(Worth/ItemDB)");
198  				jails = new Jails(this);
199  				confList.add(jails);
200  				reload();
201  			}
202  			catch (YAMLException exception)
203  			{
204  				if (pm.getPlugin("EssentialsUpdate") != null)
205  				{
206  					LOGGER.log(Level.SEVERE, tl("essentialsHelp2"));
207  				}
208  				else
209  				{
210  					LOGGER.log(Level.SEVERE, tl("essentialsHelp1"));
211  				}
212  				handleCrash(exception);
213  				return;
214  			}
215  			backup = new Backup(this);
216  			permissionsHandler = new PermissionsHandler(this, settings.useBukkitPermissions());
217  			alternativeCommandsHandler = new AlternativeCommandsHandler(this);
218  			timer = new EssentialsTimer(this);
219  			scheduleSyncRepeatingTask(timer, 1000, 50);
220  			Economy.setEss(this);
221  			execTimer.mark("RegHandler");
222  			final MetricsStarter metricsStarter = new MetricsStarter(this);
223  			if (metricsStarter.getStart() != null && metricsStarter.getStart() == true)
224  			{
225  				runTaskLaterAsynchronously(metricsStarter, 1);
226  			}
227  			else if (metricsStarter.getStart() != null && metricsStarter.getStart() == false)
228  			{
229  				final MetricsListener metricsListener = new MetricsListener(this, metricsStarter);
230  				pm.registerEvents(metricsListener, this);
231  			}
232  			final String timeroutput = execTimer.end();
233  			if (getSettings().isDebug())
234  			{
235  				LOGGER.log(Level.INFO, "Essentials load {0}", timeroutput);
236  			}
237  		}
238  		catch (NumberFormatException ex)
239  		{
240  			handleCrash(ex);
241  		}
242  		catch (Error ex)
243  		{
244  			handleCrash(ex);
245  			throw ex;
246  		}
247  	}
248  	@Override
249  	public void saveConfig()
250  	{
251  	}
252  	private void registerListeners(PluginManager pm)
253  	{
254  		HandlerList.unregisterAll(this);
255  		if (getSettings().isDebug())
256  		{
257  			LOGGER.log(Level.INFO, "Registering Listeners");
258  		}
259  		final EssentialsPluginListener serverListener = new EssentialsPluginListener(this);
260  		pm.registerEvents(serverListener, this);
261  		confList.add(serverListener);
262  		final EssentialsPlayerListener playerListener = new EssentialsPlayerListener(this);
263  		pm.registerEvents(playerListener, this);
264  		final EssentialsBlockListener blockListener = new EssentialsBlockListener(this);
265  		pm.registerEvents(blockListener, this);
266  		final SignBlockListener signBlockListener = new SignBlockListener(this);
267  		pm.registerEvents(signBlockListener, this);
268  		final SignPlayerListener signPlayerListener = new SignPlayerListener(this);
269  		pm.registerEvents(signPlayerListener, this);
270  		final SignEntityListener signEntityListener = new SignEntityListener(this);
271  		pm.registerEvents(signEntityListener, this);
272  		final EssentialsEntityListener entityListener = new EssentialsEntityListener(this);
273  		pm.registerEvents(entityListener, this);
274  		final EssentialsWorldListener worldListener = new EssentialsWorldListener(this);
275  		pm.registerEvents(worldListener, this);
276  		pm.registerEvents(tntListener, this);
277  		jails.resetListener();
278  	}
279  	@Override
280  	public void onDisable()
281  	{
282  		for (User user : getOnlineUsers())
283  		{
284  			if (user.isVanished())
285  			{
286  				user.setVanished(false);
287  				user.sendMessage(tl("unvanishedReload"));
288  			}
289  			user.stopTransaction();
290  		}
291  		cleanupOpenInventories();
292  		if (i18n != null)
293  		{
294  			i18n.onDisable();
295  		}
296  		if (backup != null)
297  		{
298  			backup.stopTask();
299  		}
300  		Economy.setEss(null);
301  		Trade.closeLog();
302  		getUserMap().getUUIDMap().forceWriteUUIDMap();
303  		HandlerList.unregisterAll(this);
304  	}
305  	@Override
306  	public void reload()
307  	{
308  		Trade.closeLog();
309  		for (IConf iConf : confList)
310  		{
311  			iConf.reloadConfig();
312  			execTimer.mark("Reload(" + iConf.getClass().getSimpleName() + ")");
313  		}
314  		i18n.updateLocale(settings.getLocale());
315  		final PluginManager pm = getServer().getPluginManager();
316  		registerListeners(pm);
317  	}
318  	@Override
319  	public List<String> onTabComplete(CommandSender sender,
320  									  Command command,
321  									  String commandLabel,
322  									  String[] args)
323  	{
324  		if (!getSettings().isCommandOverridden(command.getName()) && (!commandLabel.startsWith("e") || commandLabel.equalsIgnoreCase(command.getName())))
325  		{
326  			final PluginCommand pc = alternativeCommandsHandler.getAlternative(commandLabel);
327  			if (pc != null)
328  			{
329  				try
330  				{
331  					TabCompleter completer = pc.getTabCompleter();
332  					if (completer != null)
333  					{
334  						return completer.onTabComplete(sender, command, commandLabel, args);
335  					}
336  				}
337  				catch (final Exception ex)
338  				{
339  					Bukkit.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
340  				}
341  			}
342  		}
343  		return null;
344  	}
345  	@Override
346  	public boolean onCommand(final CommandSender sender, final Command command, final String commandLabel, final String[] args)
347  	{
348  		return onCommandEssentials(sender, command, commandLabel, args, Essentials.class.getClassLoader(), "com.earth2me.essentials.commands.Command", "essentials.", null);
349  	}
350  	@Override
351  	public boolean onCommandEssentials(final CommandSender cSender, final Command command, final String commandLabel, final String[] args, final ClassLoader classLoader, final String commandPath, final String permissionPrefix, final IEssentialsModule module)
352  	{
353  		if (!getSettings().isCommandOverridden(command.getName()) && (!commandLabel.startsWith("e") || commandLabel.equalsIgnoreCase(command.getName())))
354  		{
355  			final PluginCommand pc = alternativeCommandsHandler.getAlternative(commandLabel);
356  			if (pc != null)
357  			{
358  				alternativeCommandsHandler.executed(commandLabel, pc);
359  				try
360  				{
361  					return pc.execute(cSender, commandLabel, args);
362  				}
363  				catch (final Exception ex)
364  				{
365  					Bukkit.getLogger().log(Level.SEVERE, ex.getMessage(), ex);
366  					cSender.sendMessage(ChatColor.RED + "An internal error occurred while attempting to perform this command");
367  					return true;
368  				}
369  			}
370  		}
371  		try
372  		{
373  			User user = null;
374  			Block bSenderBlock = null;
375  			if (cSender instanceof Player)
376  			{
377  				user = getUser((Player)cSender);
378  			}
379  			else if (cSender instanceof BlockCommandSender)
380  			{
381  				BlockCommandSender bsender = (BlockCommandSender)cSender;
382  				bSenderBlock = bsender.getBlock();
383  			}
384  			if (bSenderBlock != null)
385  			{
386  				Bukkit.getLogger().log(Level.INFO, "CommandBlock at {0},{1},{2} issued server command: /{3} {4}", new Object[]
387  				{
388  					bSenderBlock.getX(), bSenderBlock.getY(), bSenderBlock.getZ(), commandLabel, EssentialsCommand.getFinalArg(args, 0)
389  				});
390  			}
391  			else if (user == null)
392  			{
393  				Bukkit.getLogger().log(Level.INFO, "{0} issued server command: /{1} {2}", new Object[]
394  				{
395  					cSender.getName(), commandLabel, EssentialsCommand.getFinalArg(args, 0)
396  				});
397  			}
398  			CommandSource sender = new CommandSource(cSender);
399  			if (user != null && !getSettings().isCommandDisabled("mail") && !command.getName().equals("mail") && user.isAuthorized("essentials.mail"))
400  			{
401  				final List<String> mail = user.getMails();
402  				if (mail != null && !mail.isEmpty())
403  				{
404  					user.sendMessage(tl("youHaveNewMail", mail.size()));
405  				}
406  			}
407  			if (commandLabel.equalsIgnoreCase("essversion"))
408  			{
409  				sender.sendMessage("This server is running Essentials " + getDescription().getVersion());
410  				return true;
411  			}
412  			if (getSettings().isCommandDisabled(commandLabel))
413  			{
414  				return true;
415  			}
416  			IEssentialsCommand cmd;
417  			try
418  			{
419  				cmd = (IEssentialsCommand)classLoader.loadClass(commandPath + command.getName()).newInstance();
420  				cmd.setEssentials(this);
421  				cmd.setEssentialsModule(module);
422  			}
423  			catch (Exception ex)
424  			{
425  				sender.sendMessage(tl("commandNotLoaded", commandLabel));
426  				LOGGER.log(Level.SEVERE, tl("commandNotLoaded", commandLabel), ex);
427  				return true;
428  			}
429  			if (user != null && !user.isAuthorized(cmd, permissionPrefix))
430  			{
431  				LOGGER.log(Level.INFO, tl("deniedAccessCommand", user.getName()));
432  				user.sendMessage(tl("noAccessCommand"));
433  				return true;
434  			}
435  			if (user != null && user.isJailed() && !user.isAuthorized(cmd, "essentials.jail.allow."))
436  			{
437  				if (user.getJailTimeout() > 0)
438  				{
439  					user.sendMessage(tl("playerJailedFor", user.getName(), DateUtil.formatDateDiff(user.getJailTimeout())));
440  				}
441  				else
442  				{
443  					user.sendMessage(tl("jailMessage"));
444  				}
445  				return true;
446  			}
447  			try
448  			{
449  				if (user == null)
450  				{
451  					cmd.run(getServer(), sender, commandLabel, command, args);
452  				}
453  				else
454  				{
455  					cmd.run(getServer(), user, commandLabel, command, args);
456  				}
457  				return true;
458  			}
459  			catch (NoChargeException ex)
460  			{
461  				return true;
462  			}
463  			catch (QuietAbortException ex)
464  			{
465  				return true;
466  			}
467  			catch (NotEnoughArgumentsException ex)
468  			{
469  				sender.sendMessage(command.getDescription());
470  				sender.sendMessage(command.getUsage().replaceAll("<command>", commandLabel));
471  				if (!ex.getMessage().isEmpty())
472  				{
473  					sender.sendMessage(ex.getMessage());
474  				}
475  				return true;
476  			}
477  			catch (Exception ex)
478  			{
479  				showError(sender, ex, commandLabel);
480  				return true;
481  			}
482  		}
483  		catch (Throwable ex)
484  		{
485  			LOGGER.log(Level.SEVERE, tl("commandFailed", commandLabel), ex);
486  			return true;
487  		}
488  	}
489  	public void cleanupOpenInventories()
490  	{
491  		for (User user : getOnlineUsers())
492  		{
493  			if (user.isRecipeSee())
494  			{
495  				user.getBase().getOpenInventory().getTopInventory().clear();
496  				user.getBase().getOpenInventory().close();
497  				user.setRecipeSee(false);
498  			}
499  			if (user.isInvSee() || user.isEnderSee())
500  			{
501  				user.getBase().getOpenInventory().close();
502  				user.setInvSee(false);
503  				user.setEnderSee(false);
504  			}
505  		}
506  	}
507  	@Override
508  	public void showError(final CommandSource sender, final Throwable exception, final String commandLabel)
509  	{
510  		sender.sendMessage(tl("errorWithMessage", exception.getMessage()));
511  		if (getSettings().isDebug())
512  		{
513  			LOGGER.log(Level.INFO, tl("errorCallingCommand", commandLabel), exception);
514  		}
515  	}
516  	public static void wrongVersion()
517  	{
518  		LOGGER.log(Level.SEVERE, " * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! *");
519  		LOGGER.log(Level.SEVERE, tl("notRecommendedBukkit"));
520  		LOGGER.log(Level.SEVERE, tl("requiredBukkit", Integer.toString(BUKKIT_VERSION)));
521  		LOGGER.log(Level.SEVERE, " * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! * ! *");
522  	}
523  	@Override
524  	public BukkitScheduler getScheduler()
525  	{
526  		return this.getServer().getScheduler();
527  	}
528  	@Override
529  	public IJails getJails()
530  	{
531  		return jails;
532  	}
533  	@Override
534  	public Warps getWarps()
535  	{
536  		return warps;
537  	}
538  	@Override
539  	public Worth getWorth()
540  	{
541  		return worth;
542  	}
543  	@Override
544  	public Backup getBackup()
545  	{
546  		return backup;
547  	}
548  	@Override
549  	public Metrics getMetrics()
550  	{
551  		return metrics;
552  	}
553  	@Override
554  	public void setMetrics(Metrics metrics)
555  	{
556  		this.metrics = metrics;
557  	}
558  	@Deprecated
559  	@Override
560  	public User getUser(final Object base)
561  	{
562  		if (base instanceof Player)
563  		{
564  			return getUser((Player)base);
565  		}
566  		if (base instanceof org.bukkit.OfflinePlayer)
567  		{
568  			return getUser(((org.bukkit.OfflinePlayer)base).getUniqueId());
569  		}
570  		if (base instanceof UUID)
571  		{
572  			return getUser((UUID)base);
573  		}
574  		if (base instanceof String)
575  		{
576  			return getOfflineUser((String)base);
577  		}
578  		return null;
579  	}
580  	@Override
581  	public User getUser(final String base)
582  	{
583  		return getOfflineUser(base);
584  	}
585  	@Override
586  	public User getUser(final UUID base)
587  	{
588  		return userMap.getUser(base);
589  	}
590  	@Override
591  	public User getOfflineUser(final String name)
592  	{
593  		final User user = userMap.getUser(name);
594  		if (user != null && user.getBase() instanceof OfflinePlayer)
595  		{
596  			final String lastName = user.getLastAccountName();
597  			if (lastName != null)
598  			{
599  				((OfflinePlayer)user.getBase()).setName(lastName);
600  			}
601  			else
602  			{
603  				((OfflinePlayer)user.getBase()).setName(name);
604  			}
605  		}
606  		return user;
607  	}
608  	@Override
609  	public User getUser(final Player base)
610  	{
611  		if (base == null)
612  		{
613  			return null;
614  		}
615  		if (userMap == null)
616  		{
617  			LOGGER.log(Level.WARNING, "Essentials userMap not initialized");
618  			return null;
619  		}
620  		User user = userMap.getUser(base.getUniqueId());
621  		if (user == null)
622  		{
623  			if (getSettings().isDebug())
624  			{
625  				LOGGER.log(Level.INFO, "Constructing new userfile from base player {0}", base.getName());
626  			}
627  			user = new User(base, this);
628  		}
629  		else
630  		{
631  			user.update(base);
632  		}
633  		return user;
634  	}
635  	private void handleCrash(Throwable exception)
636  	{
637  		final PluginManager pm = getServer().getPluginManager();
638  		LOGGER.log(Level.SEVERE, exception.toString());
639  		pm.registerEvents(new Listener()
640  		{
641  			@EventHandler(priority = EventPriority.LOW)
642  			public void onPlayerJoin(final PlayerJoinEvent event)
643  			{
644  				event.getPlayer().sendMessage("Essentials failed to load, read the log file.");
645  			}
646  		}, this);
647  		for (Player player : getOnlinePlayers())
648  		{
649  			player.sendMessage("Essentials failed to load, read the log file.");
650  		}
651  		this.setEnabled(false);
652  	}
653  	@Override
654  	public World getWorld(final String name)
655  	{
656  		if (name.matches("[0-9]+"))
657  		{
658  			final int worldId = Integer.parseInt(name);
659  			if (worldId < getServer().getWorlds().size())
660  			{
661  				return getServer().getWorlds().get(worldId);
662  			}
663  		}
664  		return getServer().getWorld(name);
665  	}
666  	@Override
667  	public void addReloadListener(final IConf listener)
668  	{
669  		confList.add(listener);
670  	}
671  	@Override
672  	public Methods getPaymentMethod()
673  	{
674  		return paymentMethod;
675  	}
676  	@Override
677  	public int broadcastMessage(final String message)
678  	{
679  		return broadcastMessage(null, null, message, true);
680  	}
681  	@Override
682  	public int broadcastMessage(final IUser sender, final String message)
683  	{
684  		return broadcastMessage(sender, null, message, false);
685  	}
686  	@Override
687  	public int broadcastMessage(final String permission, final String message)
688  	{
689  		return broadcastMessage(null, permission, message, false);
690  	}
691  	private int broadcastMessage(final IUser sender, final String permission, final String message, final boolean keywords)
692  	{
693  		if (sender != null && sender.isHidden())
694  		{
695  			return 0;
696  		}
697  		IText broadcast = new SimpleTextInput(message);
698  		final Collection<Player> players = getOnlinePlayers();
699  		for (Player player : players)
700  		{
701  			final User user = getUser(player);
702  			if ((permission == null && (sender == null || !user.isIgnoredPlayer(sender)))
703  				|| (permission != null && user.isAuthorized(permission)))
704  			{
705  				if (keywords)
706  				{
707  					broadcast = new KeywordReplacer(broadcast, new CommandSource(player), this, false);
708  				}
709  				for (String messageText : broadcast.getLines())
710  				{
711  					user.sendMessage(messageText);
712  				}
713  			}
714  		}
715  		return players.size();
716  	}
717  	@Override
718  	public BukkitTask runTaskAsynchronously(final Runnable run)
719  	{
720  		return this.getScheduler().runTaskAsynchronously(this, run);
721  	}
722  	@Override
723  	public BukkitTask runTaskLaterAsynchronously(final Runnable run, final long delay)
724  	{
725  		return this.getScheduler().runTaskLaterAsynchronously(this, run, delay);
726  	}
727  	@Override
728  	public BukkitTask runTaskTimerAsynchronously(final Runnable run, final long delay, final long period)
729  	{
730  		return this.getScheduler().runTaskTimerAsynchronously(this, run, delay, period);
731  	}
732  	@Override
733  	public int scheduleSyncDelayedTask(final Runnable run)
734  	{
735  		return this.getScheduler().scheduleSyncDelayedTask(this, run);
736  	}
737  	@Override
738  	public int scheduleSyncDelayedTask(final Runnable run, final long delay)
739  	{
740  		return this.getScheduler().scheduleSyncDelayedTask(this, run, delay);
741  	}
742  	@Override
743  	public int scheduleSyncRepeatingTask(final Runnable run, final long delay, final long period)
744  	{
745  		return this.getScheduler().scheduleSyncRepeatingTask(this, run, delay, period);
746  	}
747  	@Override
748  	public TNTExplodeListener getTNTListener()
749  	{
750  		return tntListener;
751  	}
752  	@Override
753  	public PermissionsHandler getPermissionsHandler()
754  	{
755  		return permissionsHandler;
756  	}
757  	@Override
758  	public AlternativeCommandsHandler getAlternativeCommandsHandler()
759  	{
760  		return alternativeCommandsHandler;
761  	}
762  	@Override
763  	public IItemDb getItemDb()
764  	{
765  		return itemDb;
766  	}
767  	@Override
768  	public UserMap getUserMap()
769  	{
770  		return userMap;
771  	}
772  	@Override
773  	public I18n getI18n()
774  	{
775  		return i18n;
776  	}
777  	@Override
778  	public EssentialsTimer getTimer()
779  	{
780  		return timer;
781  	}
782  	@Override
783  	public List<String> getVanishedPlayers()
784  	{
785  		return vanishedPlayers;
786  	}
787  	@Override
788  	public Collection<Player> getOnlinePlayers()
789  	{
790  		try
791  		{
792  			return (Collection<Player>)getServer().getOnlinePlayers(); 
793  		}
794  		catch (NoSuchMethodError ex)
795  		{
796  			try
797  			{
798  				return Arrays.asList((Player[])oldGetOnlinePlayers.invoke(getServer()));
799  			}
800  			catch (InvocationTargetException ex1)
801  			{
802  				throw Throwables.propagate(ex.getCause());
803  			}
804  			catch (IllegalAccessException ex1)
805  			{
806  				throw new RuntimeException("Error invoking oldGetOnlinePlayers", ex1);
807  			}
808  		}
809  	}
810  	@Override
811  	public Iterable<User> getOnlineUsers()
812  	{
813  		return Iterables.transform(getOnlinePlayers(), new Function<Player, User>()
814  		{
815  			@Override
816  			public User apply(Player player)
817  			{
818  				return getUser(player);
819  			}
820  		});
821  	}
822  	private static class EssentialsWorldListener implements Listener, Runnable
823  	{
824  		private transient final IEssentials ess;
825  		public EssentialsWorldListener(final IEssentials ess)
826  		{
827  			this.ess = ess;
828  		}
829  		@EventHandler(priority = EventPriority.LOW)
830  		public void onWorldLoad(final WorldLoadEvent event)
831  		{
832  			ess.getJails().onReload();
833  			ess.getWarps().reloadConfig();
834  			for (IConf iConf : ((Essentials)ess).confList)
835  			{
836  				if (iConf instanceof IEssentialsModule)
837  				{
838  					iConf.reloadConfig();
839  				}
840  			}
841  		}
842  		@EventHandler(priority = EventPriority.LOW)
843  		public void onWorldUnload(final WorldUnloadEvent event)
844  		{
845  			ess.getJails().onReload();
846  			ess.getWarps().reloadConfig();
847  			for (IConf iConf : ((Essentials)ess).confList)
848  			{
849  				if (iConf instanceof IEssentialsModule)
850  				{
851  					iConf.reloadConfig();
852  				}
853  			}
854  		}
855  		@Override
856  		public void run()
857  		{
858  			ess.reload();
859  		}
860  	}
861  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-EurekaNotificationServerListUpdater.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Essentials.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import com.google.common.util.concurrent.ThreadFactoryBuilder;
3  import com.netflix.config.DynamicIntProperty;
4  import com.netflix.discovery.CacheRefreshedEvent;
5  import com.netflix.discovery.EurekaClient;
6  import com.netflix.discovery.EurekaEvent;
7  import com.netflix.discovery.EurekaEventListener;
8  import com.netflix.loadbalancer.*;
9  import org.slf4j.Logger;
10  import org.slf4j.LoggerFactory;
11  import javax.inject.Provider;
12  import java.util.Date;
13  import java.util.concurrent.ArrayBlockingQueue;
14  import java.util.concurrent.ExecutorService;
15  import java.util.concurrent.ThreadPoolExecutor;
16  import java.util.concurrent.TimeUnit;
17  import java.util.concurrent.atomic.AtomicBoolean;
18  import java.util.concurrent.atomic.AtomicLong;
19  public class EurekaNotificationServerListUpdater implements ServerListUpdater {
20      private static final Logger logger = LoggerFactory.getLogger(EurekaNotificationServerListUpdater.class);
</pre></code></div>
                <div class="column column_space"><pre><code>52  import org.bukkit.entity.Player;
53  import org.bukkit.event.EventHandler;
54  import org.bukkit.event.EventPriority;
55  import org.bukkit.event.HandlerList;
56  import org.bukkit.event.Listener;
57  import org.bukkit.event.player.PlayerJoinEvent;
58  import org.bukkit.event.world.WorldLoadEvent;
59  import org.bukkit.event.world.WorldUnloadEvent;
60  import org.bukkit.plugin.InvalidDescriptionException;
61  import org.bukkit.plugin.Plugin;
62  import org.bukkit.plugin.PluginDescriptionFile;
63  import org.bukkit.plugin.PluginManager;
64  import org.bukkit.plugin.java.JavaPlugin;
65  import org.bukkit.plugin.java.JavaPluginLoader;
66  import org.bukkit.scheduler.BukkitScheduler;
67  import org.bukkit.scheduler.BukkitTask;
68  import org.yaml.snakeyaml.error.YAMLException;
69  public class Essentials extends JavaPlugin implements net.ess3.api.IEssentials
70  {
71  	public static final int BUKKIT_VERSION = 3050;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    