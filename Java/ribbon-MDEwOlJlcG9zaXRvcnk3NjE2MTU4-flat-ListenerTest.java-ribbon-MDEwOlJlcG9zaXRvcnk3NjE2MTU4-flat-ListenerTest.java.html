
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 115, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import com.google.common.collect.Lists;
3  import com.google.mockwebserver.MockResponse;
4  import com.google.mockwebserver.MockWebServer;
5  import com.netflix.client.ClientException;
6  import com.netflix.client.config.CommonClientConfigKey;
7  import com.netflix.client.config.DefaultClientConfigImpl;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.config.ConfigurationManager;
10  import com.netflix.loadbalancer.AvailabilityFilteringRule;
11  import com.netflix.loadbalancer.BaseLoadBalancer;
12  import com.netflix.loadbalancer.DummyPing;
13  import com.netflix.loadbalancer.LoadBalancerBuilder;
14  import com.netflix.loadbalancer.Server;
15  import com.netflix.loadbalancer.reactive.ExecutionContext;
16  import com.netflix.loadbalancer.reactive.ExecutionInfo;
17  import com.netflix.loadbalancer.reactive.ExecutionListener;
18  import com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException;
19  import com.netflix.ribbon.transport.netty.RibbonTransport;
20  import io.netty.buffer.ByteBuf;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import org.junit.Ignore;
24  import org.junit.Test;
25  import rx.functions.Action1;
26  import java.io.IOException;
27  import java.util.Arrays;
28  import java.util.List;
29  import java.util.concurrent.CountDownLatch;
30  import java.util.concurrent.TimeUnit;
31  import java.util.concurrent.atomic.AtomicReference;
32  import static org.junit.Assert.*;
33  public class ListenerTest {
34      @Test
35      public void testFailedExecution() {
36          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
37                  .withProperty(CommonClientConfigKey.ConnectTimeout, "100")
38                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
39                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
40          System.out.println(config);
41          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
42          Server badServer  = new Server("localhost:12345");
43          Server badServer2 = new Server("localhost:34567");
44          List<Server> servers = Lists.newArrayList(badServer, badServer2);
45          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
46                  .withRule(new AvailabilityFilteringRule())
47                  .withPing(new DummyPing())
48                  .buildFixedServerListLoadBalancer(servers);
49          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
50          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
51          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
52          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
53          try {
54              client.submit(request, null, overrideConfig).toBlocking().last();
55              fail("Exception expected");
56          } catch(Exception e) {
57              assertNotNull(e);
58          }
59          assertEquals(1, listener.executionStartCounter.get());
60          assertEquals(4, listener.startWithServerCounter.get());
61          assertEquals(4, listener.exceptionWithServerCounter.get());
62          assertEquals(1, listener.executionFailedCounter.get());
63          assertTrue(listener.isContextChecked());
64          assertTrue(listener.isCheckExecutionInfo());
65          assertNotNull(listener.getFinalThrowable());
66          listener.getFinalThrowable().printStackTrace();
67          assertTrue(listener.getFinalThrowable() instanceof ClientException);
68          assertEquals(100, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
69      }
70      @Test
71      public void testFailedExecutionForAbsoluteURI() {
72          IClientConfig config = DefaultClientConfigImpl
73                  .getClientConfigWithDefaultValues()
74                  .withProperty(CommonClientConfigKey.ConnectTimeout, "100")
75                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
76                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
77          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;xyz.unknowhost.xyz/testAsync/person");
78          Server badServer = new Server("localhost:12345");
79          Server badServer2 = new Server("localhost:34567");
80          List<Server> servers = Lists.newArrayList(badServer, badServer2);
81          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
82                  .withRule(new AvailabilityFilteringRule())
83                  .withPing(new DummyPing())
84                  .buildFixedServerListLoadBalancer(servers);
85          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
86          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
87          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
88          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
89          try {
90              client.submit(request, null, overrideConfig).toBlocking().last();
91              fail("Exception expected");
92          } catch(Exception e) {
93              assertNotNull(e);
94          }
95          assertEquals(1, listener.executionStartCounter.get());
96          assertEquals(2, listener.startWithServerCounter.get());
97          assertEquals(2, listener.exceptionWithServerCounter.get());
98          assertEquals(1, listener.executionFailedCounter.get());
99          assertTrue(listener.isContextChecked());
100          assertTrue(listener.isCheckExecutionInfo());
101          assertTrue(listener.getFinalThrowable() instanceof ClientException);
102      }
103      @Test
104      public void testSuccessExecution() throws IOException {
105          MockWebServer server = new MockWebServer();
106          String content = "OK";
107          server.enqueue(new MockResponse()
108                  .setResponseCode(200)
109                  .setHeader("Content-type", "application/json")
110                  .setBody(content));
111          server.play();
112          IClientConfig config = DefaultClientConfigImpl
113                  .getClientConfigWithDefaultValues()
114                  .withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
115                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
116                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
117          System.out.println(config);
118          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
119          Server badServer  = new Server("localhost:12345");
120          Server goodServer = new Server("localhost:" + server.getPort());
121          List<Server> servers = Lists.newArrayList(goodServer, badServer);
122          BaseLoadBalancer lb = LoadBalancerBuilder.newBuilder()
123                  .withRule(new AvailabilityFilteringRule())
124                  .withPing(new DummyPing())
125                  .buildFixedServerListLoadBalancer(servers);
126          IClientConfig overrideConfig = DefaultClientConfigImpl
127                  .getEmptyConfig()
128                  .set(CommonClientConfigKey.ConnectTimeout, 500);
129          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<>(request, overrideConfig);
130          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.newArrayList(listener);
131          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
132          HttpClientResponse<ByteBuf> response = client.submit(request, null, overrideConfig).toBlocking().last();
133          System.out.println(listener);
134          assertEquals(200, response.getStatus().code());
135          assertEquals(1, listener.executionStartCounter.get());
136          assertEquals(3, listener.startWithServerCounter.get());
137          assertEquals(2, listener.exceptionWithServerCounter.get());
138          assertEquals(0, listener.executionFailedCounter.get());
139          assertEquals(1, listener.executionSuccessCounter.get());
140          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
141          assertTrue(listener.isContextChecked());
142          assertTrue(listener.isCheckExecutionInfo());
143          assertSame(response, listener.getResponse());
144      }
145      @Test
146      public void testSuccessExecutionOnAbosoluteURI() throws IOException {
147          MockWebServer server = new MockWebServer();
148          String content = "OK";
149          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
150                  .setBody(content));
151          server.play();
152          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
153                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
154                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
155          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;localhost:" + server.getPort() + "/testAsync/person");
156          Server badServer = new Server("localhost:12345");
157          Server goodServer = new Server("localhost:" + server.getPort());
158          List<Server> servers = Lists.newArrayList(goodServer, badServer);
159          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
160                  .withRule(new AvailabilityFilteringRule())
161                  .withPing(new DummyPing())
162                  .buildFixedServerListLoadBalancer(servers);
163          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
164          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
165          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
166          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
167          HttpClientResponse<ByteBuf> response = client.submit(request, null, overrideConfig).toBlocking().last();
168          assertEquals(200, response.getStatus().code());
169          assertEquals(1, listener.executionStartCounter.get());
170          assertEquals(1, listener.startWithServerCounter.get());
171          assertEquals(0, listener.exceptionWithServerCounter.get());
172          assertEquals(0, listener.executionFailedCounter.get());
173          assertEquals(1, listener.executionSuccessCounter.get());
174          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
175          assertTrue(listener.isContextChecked());
176          assertTrue(listener.isCheckExecutionInfo());
177          assertSame(response, listener.getResponse());
178      }
179      @Test
180      public void testAbortedExecution() {
181          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "100")
182                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
183                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
184          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
185          Server badServer = new Server("localhost:12345");
186          Server badServer2 = new Server("localhost:34567");
187          List<Server> servers = Lists.newArrayList(badServer, badServer2);
188          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
189                  .withRule(new AvailabilityFilteringRule())
190                  .withPing(new DummyPing())
191                  .buildFixedServerListLoadBalancer(servers);
192          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
193          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
194              @Override
195              public void onExecutionStart(ExecutionContext context) {
196                  throw new AbortExecutionException("exit now");
197              }
198          };
199          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
200          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
201          final CountDownLatch latch = new CountDownLatch(1);
202          final AtomicReference<Throwable> ref = new AtomicReference<Throwable>();
<span onclick='openModal()' class='match'>203          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
204              @Override
205              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
206              }
207          }, new Action1<Throwable>() {
208              @Override
209              public void call(Throwable throwable) {
210                  ref.set(throwable);
211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
</span>223          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "100")
224                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
225                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
226          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
227          Server badServer = new Server("localhost:12345");
228          Server badServer2 = new Server("localhost:34567");
229          List<Server> servers = Lists.newArrayList(badServer, badServer2);
230          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
231                  .withRule(new AvailabilityFilteringRule())
232                  .withPing(new DummyPing())
233                  .buildFixedServerListLoadBalancer(servers);
234          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
235          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
236              @Override
237              public void onStartWithServer(ExecutionContext context, ExecutionInfo info) {
238                  throw new AbortExecutionException("exit now");
239              }
240          };
241          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
242          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
243          final CountDownLatch latch = new CountDownLatch(1);
244          final AtomicReference<Throwable> ref = new AtomicReference<Throwable>();
245          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
246              @Override
247              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
248              }
249          }, new Action1<Throwable>() {
250              @Override
251              public void call(Throwable throwable) {
252                  ref.set(throwable);
253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
265          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues("myClient").withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
266                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
267                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
268          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
269          Server badServer = new Server("localhost:12345");
270          List<Server> servers = Lists.newArrayList(badServer);
271          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
272                  .withRule(new AvailabilityFilteringRule())
273                  .withPing(new DummyPing())
274                  .buildFixedServerListLoadBalancer(servers);
275          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
276          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
277          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
278          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
279          ConfigurationManager.getConfigInstance().setProperty("ribbon.listener." + TestExecutionListener.class.getName() + ".disabled", "true");
280          try {
281              client.submit(request, null, overrideConfig).toBlocking().last();
282          } catch (Exception e) {
283              assertNotNull(e);
284          }
285          assertEquals(0, listener.executionStartCounter.get());
286          assertEquals(0, listener.startWithServerCounter.get());
287          assertEquals(0, listener.exceptionWithServerCounter.get());
288          assertEquals(0, listener.executionFailedCounter.get());
289          assertEquals(0, listener.executionSuccessCounter.get());
290          try {
291              client.submit(request, null, overrideConfig).toBlocking().last();
292          } catch (Exception e) {
293              assertNotNull(e);
294          }
295          assertEquals(0, listener.executionStartCounter.get());
296          assertEquals(0, listener.startWithServerCounter.get());
297          assertEquals(0, listener.exceptionWithServerCounter.get());
298          assertEquals(0, listener.executionFailedCounter.get());
299          assertEquals(0, listener.executionSuccessCounter.get());
300      }
301  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import com.google.common.collect.Lists;
3  import com.google.mockwebserver.MockResponse;
4  import com.google.mockwebserver.MockWebServer;
5  import com.netflix.client.ClientException;
6  import com.netflix.client.config.CommonClientConfigKey;
7  import com.netflix.client.config.DefaultClientConfigImpl;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.config.ConfigurationManager;
10  import com.netflix.loadbalancer.AvailabilityFilteringRule;
11  import com.netflix.loadbalancer.BaseLoadBalancer;
12  import com.netflix.loadbalancer.DummyPing;
13  import com.netflix.loadbalancer.LoadBalancerBuilder;
14  import com.netflix.loadbalancer.Server;
15  import com.netflix.loadbalancer.reactive.ExecutionContext;
16  import com.netflix.loadbalancer.reactive.ExecutionInfo;
17  import com.netflix.loadbalancer.reactive.ExecutionListener;
18  import com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException;
19  import com.netflix.ribbon.transport.netty.RibbonTransport;
20  import io.netty.buffer.ByteBuf;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import org.junit.Ignore;
24  import org.junit.Test;
25  import rx.functions.Action1;
26  import java.io.IOException;
27  import java.util.Arrays;
28  import java.util.List;
29  import java.util.concurrent.CountDownLatch;
30  import java.util.concurrent.TimeUnit;
31  import java.util.concurrent.atomic.AtomicReference;
32  import static org.junit.Assert.*;
33  public class ListenerTest {
34      @Test
35      public void testFailedExecution() {
36          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
37                  .withProperty(CommonClientConfigKey.ConnectTimeout, "100")
38                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
39                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
40          System.out.println(config);
41          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
42          Server badServer  = new Server("localhost:12345");
43          Server badServer2 = new Server("localhost:34567");
44          List<Server> servers = Lists.newArrayList(badServer, badServer2);
45          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
46                  .withRule(new AvailabilityFilteringRule())
47                  .withPing(new DummyPing())
48                  .buildFixedServerListLoadBalancer(servers);
49          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
50          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
51          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
52          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
53          try {
54              client.submit(request, null, overrideConfig).toBlocking().last();
55              fail("Exception expected");
56          } catch(Exception e) {
57              assertNotNull(e);
58          }
59          assertEquals(1, listener.executionStartCounter.get());
60          assertEquals(4, listener.startWithServerCounter.get());
61          assertEquals(4, listener.exceptionWithServerCounter.get());
62          assertEquals(1, listener.executionFailedCounter.get());
63          assertTrue(listener.isContextChecked());
64          assertTrue(listener.isCheckExecutionInfo());
65          assertNotNull(listener.getFinalThrowable());
66          listener.getFinalThrowable().printStackTrace();
67          assertTrue(listener.getFinalThrowable() instanceof ClientException);
68          assertEquals(100, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
69      }
70      @Test
71      public void testFailedExecutionForAbsoluteURI() {
72          IClientConfig config = DefaultClientConfigImpl
73                  .getClientConfigWithDefaultValues()
74                  .withProperty(CommonClientConfigKey.ConnectTimeout, "100")
75                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
76                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
77          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;xyz.unknowhost.xyz/testAsync/person");
78          Server badServer = new Server("localhost:12345");
79          Server badServer2 = new Server("localhost:34567");
80          List<Server> servers = Lists.newArrayList(badServer, badServer2);
81          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
82                  .withRule(new AvailabilityFilteringRule())
83                  .withPing(new DummyPing())
84                  .buildFixedServerListLoadBalancer(servers);
85          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
86          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
87          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
88          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
89          try {
90              client.submit(request, null, overrideConfig).toBlocking().last();
91              fail("Exception expected");
92          } catch(Exception e) {
93              assertNotNull(e);
94          }
95          assertEquals(1, listener.executionStartCounter.get());
96          assertEquals(2, listener.startWithServerCounter.get());
97          assertEquals(2, listener.exceptionWithServerCounter.get());
98          assertEquals(1, listener.executionFailedCounter.get());
99          assertTrue(listener.isContextChecked());
100          assertTrue(listener.isCheckExecutionInfo());
101          assertTrue(listener.getFinalThrowable() instanceof ClientException);
102      }
103      @Test
104      public void testSuccessExecution() throws IOException {
105          MockWebServer server = new MockWebServer();
106          String content = "OK";
107          server.enqueue(new MockResponse()
108                  .setResponseCode(200)
109                  .setHeader("Content-type", "application/json")
110                  .setBody(content));
111          server.play();
112          IClientConfig config = DefaultClientConfigImpl
113                  .getClientConfigWithDefaultValues()
114                  .withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
115                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
116                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
117          System.out.println(config);
118          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
119          Server badServer  = new Server("localhost:12345");
120          Server goodServer = new Server("localhost:" + server.getPort());
121          List<Server> servers = Lists.newArrayList(goodServer, badServer);
122          BaseLoadBalancer lb = LoadBalancerBuilder.newBuilder()
123                  .withRule(new AvailabilityFilteringRule())
124                  .withPing(new DummyPing())
125                  .buildFixedServerListLoadBalancer(servers);
126          IClientConfig overrideConfig = DefaultClientConfigImpl
127                  .getEmptyConfig()
128                  .set(CommonClientConfigKey.ConnectTimeout, 500);
129          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<>(request, overrideConfig);
130          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.newArrayList(listener);
131          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
132          HttpClientResponse<ByteBuf> response = client.submit(request, null, overrideConfig).toBlocking().last();
133          System.out.println(listener);
134          assertEquals(200, response.getStatus().code());
135          assertEquals(1, listener.executionStartCounter.get());
136          assertEquals(3, listener.startWithServerCounter.get());
137          assertEquals(2, listener.exceptionWithServerCounter.get());
138          assertEquals(0, listener.executionFailedCounter.get());
139          assertEquals(1, listener.executionSuccessCounter.get());
140          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
141          assertTrue(listener.isContextChecked());
142          assertTrue(listener.isCheckExecutionInfo());
143          assertSame(response, listener.getResponse());
144      }
145      @Test
146      public void testSuccessExecutionOnAbosoluteURI() throws IOException {
147          MockWebServer server = new MockWebServer();
148          String content = "OK";
149          server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "application/json")
150                  .setBody(content));
151          server.play();
152          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
153                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
154                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
155          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("http:&bsol;&bsol;localhost:" + server.getPort() + "/testAsync/person");
156          Server badServer = new Server("localhost:12345");
157          Server goodServer = new Server("localhost:" + server.getPort());
158          List<Server> servers = Lists.newArrayList(goodServer, badServer);
159          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
160                  .withRule(new AvailabilityFilteringRule())
161                  .withPing(new DummyPing())
162                  .buildFixedServerListLoadBalancer(servers);
163          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
164          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
165          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
166          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
167          HttpClientResponse<ByteBuf> response = client.submit(request, null, overrideConfig).toBlocking().last();
168          assertEquals(200, response.getStatus().code());
169          assertEquals(1, listener.executionStartCounter.get());
170          assertEquals(1, listener.startWithServerCounter.get());
171          assertEquals(0, listener.exceptionWithServerCounter.get());
172          assertEquals(0, listener.executionFailedCounter.get());
173          assertEquals(1, listener.executionSuccessCounter.get());
174          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
175          assertTrue(listener.isContextChecked());
176          assertTrue(listener.isCheckExecutionInfo());
177          assertSame(response, listener.getResponse());
178      }
179      @Test
180      public void testAbortedExecution() {
181          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "100")
182                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
183                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
184          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
185          Server badServer = new Server("localhost:12345");
186          Server badServer2 = new Server("localhost:34567");
187          List<Server> servers = Lists.newArrayList(badServer, badServer2);
188          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
189                  .withRule(new AvailabilityFilteringRule())
190                  .withPing(new DummyPing())
191                  .buildFixedServerListLoadBalancer(servers);
192          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
193          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
194              @Override
195              public void onExecutionStart(ExecutionContext context) {
196                  throw new AbortExecutionException("exit now");
197              }
198          };
199          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
200          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
201          final CountDownLatch latch = new CountDownLatch(1);
202          final AtomicReference<Throwable> ref = new AtomicReference<Throwable>();
203          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
204              @Override
205              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
206              }
207          }, new Action1<Throwable>() {
208              @Override
209              public void call(Throwable throwable) {
210                  ref.set(throwable);
211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
223          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, "100")
224                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
225                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
226          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
227          Server badServer = new Server("localhost:12345");
228          Server badServer2 = new Server("localhost:34567");
229          List<Server> servers = Lists.newArrayList(badServer, badServer2);
230          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
231                  .withRule(new AvailabilityFilteringRule())
232                  .withPing(new DummyPing())
233                  .buildFixedServerListLoadBalancer(servers);
234          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
235          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
236              @Override
237              public void onStartWithServer(ExecutionContext context, ExecutionInfo info) {
238                  throw new AbortExecutionException("exit now");
239              }
240          };
241          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
242          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
243          final CountDownLatch latch = new CountDownLatch(1);
244          final AtomicReference<Throwable> ref = new AtomicReference<Throwable>();
<span onclick='openModal()' class='match'>245          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
246              @Override
247              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
248              }
249          }, new Action1<Throwable>() {
250              @Override
251              public void call(Throwable throwable) {
252                  ref.set(throwable);
253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
</span>265          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues("myClient").withProperty(CommonClientConfigKey.ConnectTimeout, "2000")
266                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
267                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
268          HttpClientRequest<ByteBuf> request = HttpClientRequest.createGet("/testAsync/person");
269          Server badServer = new Server("localhost:12345");
270          List<Server> servers = Lists.newArrayList(badServer);
271          BaseLoadBalancer lb = LoadBalancerBuilder.<Server>newBuilder()
272                  .withRule(new AvailabilityFilteringRule())
273                  .withPing(new DummyPing())
274                  .buildFixedServerListLoadBalancer(servers);
275          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
276          TestExecutionListener<ByteBuf, ByteBuf> listener = new TestExecutionListener<ByteBuf, ByteBuf>(request, overrideConfig);
277          List<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>> listeners = Lists.<ExecutionListener<HttpClientRequest<ByteBuf>, HttpClientResponse<ByteBuf>>>newArrayList(listener);
278          LoadBalancingHttpClient<ByteBuf, ByteBuf> client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
279          ConfigurationManager.getConfigInstance().setProperty("ribbon.listener." + TestExecutionListener.class.getName() + ".disabled", "true");
280          try {
281              client.submit(request, null, overrideConfig).toBlocking().last();
282          } catch (Exception e) {
283              assertNotNull(e);
284          }
285          assertEquals(0, listener.executionStartCounter.get());
286          assertEquals(0, listener.startWithServerCounter.get());
287          assertEquals(0, listener.exceptionWithServerCounter.get());
288          assertEquals(0, listener.executionFailedCounter.get());
289          assertEquals(0, listener.executionSuccessCounter.get());
290          try {
291              client.submit(request, null, overrideConfig).toBlocking().last();
292          } catch (Exception e) {
293              assertNotNull(e);
294          }
295          assertEquals(0, listener.executionStartCounter.get());
296          assertEquals(0, listener.startWithServerCounter.get());
297          assertEquals(0, listener.exceptionWithServerCounter.get());
298          assertEquals(0, listener.executionFailedCounter.get());
299          assertEquals(0, listener.executionSuccessCounter.get());
300      }
301  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</div>
                </div>
                <div class="column column_space"><pre><code>203          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
204              @Override
205              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
206              }
207          }, new Action1<Throwable>() {
208              @Override
209              public void call(Throwable throwable) {
210                  ref.set(throwable);
211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
</pre></code></div>
                <div class="column column_space"><pre><code>245          client.submit(request, null, overrideConfig).subscribe(new Action1<HttpClientResponse<ByteBuf>>() {
246              @Override
247              public void call(HttpClientResponse<ByteBuf> byteBufHttpClientResponse) {
248              }
249          }, new Action1<Throwable>() {
250              @Override
251              public void call(Throwable throwable) {
252                  ref.set(throwable);
253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    