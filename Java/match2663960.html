<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MoveLimitBeneathEval.java &amp; XContentHelper.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MoveLimitBeneathEval.java &amp; XContentHelper.java
      </h3>
<h1 align="center">
        8.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MoveLimitBeneathEval.java (46.0%)<th>XContentHelper.java (4.6938777%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-37)<td><a href="#" name="0">(20-35)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(60-64)<td><a href="#" name="1">(317-321)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoveLimitBeneathEval.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner.optimizer.rule;
import static io.crate.planner.optimizer.matcher.Pattern.typeOf;
import static io.crate.planner.optimizer.matcher.Patterns.source;
import static io.crate.planner.optimizer.rule.Util.transpose;
import io.crate.metadata.NodeContext;
import io.crate.metadata.TransactionContext;
import io.crate.planner.operators.Eval;
import io.crate.planner.operators.Limit;
import io.crate.planner.operators.LogicalPlan;
import io.crate.planner.optimizer.Rule;
import io.crate.planner.optimizer.matcher.Capture;
import io.crate.planner.optimizer.matcher.Captures;
import io.crate.planner.optimizer.matcher.Pattern;
import</b></font> io.crate.statistics.TableStats;
public class MoveLimitBeneathEval implements Rule&lt;Limit&gt; {
    private final Capture&lt;Eval&gt; evalCapture;
    private final Pattern&lt;Limit&gt; pattern;
    public MoveLimitBeneathEval() {
        this.evalCapture = new Capture&lt;&gt;();
        this.pattern = typeOf(Limit.class)
            .with(source(), typeOf(Eval.class).capturedAs(evalCapture));
    }
    @Override
    public Pattern&lt;Limit&gt; pattern() {
        return pattern;
    }
    @Override
    public LogicalPlan apply(Limit limit,
<a name="1"></a>                             Captures captures,
                             TableStats tableStats,
                             TransactionContext txnCtx,
                             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>NodeContext nodeCtx) {
        Eval eval = captures.get(evalCapture);
        return transpose(limit, eval);
    }
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>XContentHelper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.common.xcontent;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.ElasticsearchParseException;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.bytes.BytesReference;
import io.crate.common.collections.Tuple;
import org.elasticsearch.common.compress.Compressor;
import org.elasticsearch.common.compress.CompressorFactory;
import org.elasticsearch.common.xcontent.ToXContent.Params;
import javax.annotation.Nullable;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import</b></font> java.io.UncheckedIOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
@SuppressWarnings("unchecked")
public class XContentHelper {
    @Deprecated
    public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler,
                                              BytesReference bytes) throws IOException {
        Compressor compressor = CompressorFactory.compressor(bytes);
        if (compressor != null) {
            InputStream compressedInput = compressor.streamInput(bytes.streamInput());
            if (compressedInput.markSupported() == false) {
                compressedInput = new BufferedInputStream(compressedInput);
            }
            final XContentType contentType = XContentFactory.xContentType(compressedInput);
            return XContentFactory.xContent(contentType).createParser(xContentRegistry, deprecationHandler, compressedInput);
        } else {
            return XContentFactory.xContent(xContentType(bytes)).createParser(xContentRegistry, deprecationHandler, bytes.streamInput());
        }
    }
    public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler,
                                              BytesReference bytes, XContentType xContentType) throws IOException {
        Objects.requireNonNull(xContentType);
        Compressor compressor = CompressorFactory.compressor(bytes);
        if (compressor != null) {
            InputStream compressedInput = compressor.streamInput(bytes.streamInput());
            if (compressedInput.markSupported() == false) {
                compressedInput = new BufferedInputStream(compressedInput);
            }
            return XContentFactory.xContent(xContentType).createParser(xContentRegistry, deprecationHandler, compressedInput);
        } else {
            return xContentType.xContent().createParser(xContentRegistry, deprecationHandler, bytes.streamInput());
        }
    }
    @Deprecated
    public static Tuple&lt;XContentType, Map&lt;String, Object&gt;&gt; convertToMap(BytesReference bytes, boolean ordered)
            throws ElasticsearchParseException {
        return convertToMap(bytes, ordered, null);
    }
    public static Map&lt;String, Object&gt; toMap(BytesReference bytes, XContentType xContentType) {
        try (InputStream inputStream = getUncompressedInputStream(bytes)) {
            XContentParser parser = xContentType.xContent().createParser(
                NamedXContentRegistry.EMPTY,
                DeprecationHandler.THROW_UNSUPPORTED_OPERATION,
                inputStream
            );
            return parser.map();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    public static InputStream getUncompressedInputStream(BytesReference bytes) throws IOException {
        Compressor compressor = CompressorFactory.compressor(bytes);
        if (compressor == null) {
            return bytes.streamInput();
        }
        InputStream compressedStreamInput = compressor.streamInput(bytes.streamInput());
        if (compressedStreamInput.markSupported()) {
            return compressedStreamInput;
        } else {
            return new BufferedInputStream(compressedStreamInput);
        }
    }
    public static Tuple&lt;XContentType, Map&lt;String, Object&gt;&gt; convertToMap(BytesReference bytes, boolean ordered, @Nullable XContentType xContentType)
        throws ElasticsearchParseException {
        try {
            final XContentType contentType;
            try (InputStream input = getUncompressedInputStream(bytes)) {
                contentType = xContentType != null ? xContentType : XContentFactory.xContentType(input);
                return new Tuple&lt;&gt;(Objects.requireNonNull(contentType), convertToMap(XContentFactory.xContent(contentType), input, ordered));
            }
        } catch (IOException e) {
            throw new ElasticsearchParseException("Failed to parse content to map", e);
        }
    }
    public static Map&lt;String, Object&gt; convertToMap(XContent xContent, String string, boolean ordered) throws ElasticsearchParseException {
        try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY,
                DeprecationHandler.THROW_UNSUPPORTED_OPERATION, string)) {
            return ordered ? parser.mapOrdered() : parser.map();
        } catch (IOException e) {
            throw new ElasticsearchParseException("Failed to parse content to map", e);
        }
    }
    public static Map&lt;String, Object&gt; convertToMap(XContent xContent, InputStream input, boolean ordered)
            throws ElasticsearchParseException {
        try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY,
                DeprecationHandler.THROW_UNSUPPORTED_OPERATION, input)) {
            return ordered ? parser.mapOrdered() : parser.map();
        } catch (IOException e) {
            throw new ElasticsearchParseException("Failed to parse content to map", e);
        }
    }
    public static String convertToJson(BytesReference bytes, XContentType xContentType) throws IOException {
        Objects.requireNonNull(xContentType);
        if (xContentType == XContentType.JSON) {
            return bytes.utf8ToString();
        }
        try (InputStream stream = bytes.streamInput();
             XContentParser parser = XContentFactory.xContent(xContentType).createParser(
                 NamedXContentRegistry.EMPTY,
                 DeprecationHandler.THROW_UNSUPPORTED_OPERATION,
                 stream)) {
            parser.nextToken();
            XContentBuilder builder = XContentFactory.jsonBuilder();
            builder.copyCurrentStructure(parser);
            return Strings.toString(builder);
        }
    }
    public static boolean update(Map&lt;String, Object&gt; source, Map&lt;String, Object&gt; changes, boolean checkUpdatesAreUnequal) {
        boolean modified = false;
        for (Map.Entry&lt;String, Object&gt; changesEntry : changes.entrySet()) {
            if (!source.containsKey(changesEntry.getKey())) {
                source.put(changesEntry.getKey(), changesEntry.getValue());
                modified = true;
                continue;
            }
            Object old = source.get(changesEntry.getKey());
            if (old instanceof Map &amp;&amp; changesEntry.getValue() instanceof Map) {
                modified |= update((Map&lt;String, Object&gt;) source.get(changesEntry.getKey()),
                        (Map&lt;String, Object&gt;) changesEntry.getValue(), checkUpdatesAreUnequal &amp;&amp; !modified);
                continue;
            }
            source.put(changesEntry.getKey(), changesEntry.getValue());
            if (modified) {
                continue;
            }
            if (!checkUpdatesAreUnequal) {
                modified = true;
                continue;
            }
            modified = !Objects.equals(old, changesEntry.getValue());
        }
        return modified;
    }
    public static void mergeDefaults(Map&lt;String, Object&gt; content, Map&lt;String, Object&gt; defaults) {
        for (Map.Entry&lt;String, Object&gt; defaultEntry : defaults.entrySet()) {
            if (!content.containsKey(defaultEntry.getKey())) {
                content.put(defaultEntry.getKey(), defaultEntry.getValue());
            } else {
                if (content.get(defaultEntry.getKey()) instanceof Map &amp;&amp; defaultEntry.getValue() instanceof Map) {
                    mergeDefaults((Map&lt;String, Object&gt;) content.get(defaultEntry.getKey()), (Map&lt;String, Object&gt;) defaultEntry.getValue());
                } else if (content.get(defaultEntry.getKey()) instanceof List &amp;&amp; defaultEntry.getValue() instanceof List) {
                    List&lt;Object&gt; defaultList = (List&lt;Object&gt;) defaultEntry.getValue();
                    List&lt;Object&gt; contentList = (List&lt;Object&gt;) content.get(defaultEntry.getKey());
                    if (allListValuesAreMapsOfOne(defaultList) &amp;&amp; allListValuesAreMapsOfOne(contentList)) {
                        Map&lt;String, Map&lt;String, Object&gt;&gt; processed = new LinkedHashMap&lt;&gt;();
                        for (Object o : contentList) {
                            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;
                            Map.Entry&lt;String, Object&gt; entry = map.entrySet().iterator().next();
                            processed.put(entry.getKey(), map);
                        }
                        for (Object o : defaultList) {
                            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;
                            Map.Entry&lt;String, Object&gt; entry = map.entrySet().iterator().next();
                            if (processed.containsKey(entry.getKey())) {
                                mergeDefaults(processed.get(entry.getKey()), map);
                            } else {
                                processed.put(entry.getKey(), map);
                            }
                        }
                        content.put(defaultEntry.getKey(), new ArrayList&lt;&gt;(processed.values()));
                    } else {
                        List&lt;Object&gt; mergedList = new ArrayList&lt;&gt;(defaultList);
                        for (Object o : contentList) {
                            if (!mergedList.contains(o)) {
                                mergedList.add(o);
                            }
                        }
                        content.put(defaultEntry.getKey(), mergedList);
                    }
                }
            }
        }
    }
    private static boolean allListValuesAreMapsOfOne(List&lt;Object&gt; list) {
        for (Object o : list) {
            if (!(o instanceof Map)) {
                return false;
            }
            if (((Map) o).size() != 1) {
                return false;
            }
        }
        return true;
    }
    public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {
        try (XContentBuilder builder = XContentBuilder.builder(xContentType.xContent())) {
            builder.humanReadable(humanReadable);
            if (toXContent.isFragment()) {
                builder.startObject();
            }
            toXContent.toXContent(builder, params);
            if (toXContent.isFragment()) {
                builder.endObject();
            }
            return BytesReference.bytes(builder);
        }
    }
    @Deprecated
    public static XContentType xContentType(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BytesReference bytes) {
        BytesRef br = bytes.toBytesRef();
        return XContentFactory.xContentType(br.bytes, br.offset, br.length);
    }
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
