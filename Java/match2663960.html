<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MoveLimitBeneathEval.java &amp; XContentHelper.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MoveLimitBeneathEval.java &amp; XContentHelper.java
      </h3>
<h1 align="center">
        8.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MoveLimitBeneathEval.java (46.0%)<th>XContentHelper.java (4.6938777%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-37)<td><a href="#" name="0">(20-35)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(60-64)<td><a href="#" name="1">(317-321)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MoveLimitBeneathEval.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner.optimizer.rule;
2 import static io.crate.planner.optimizer.matcher.Pattern.typeOf;
3 import static io.crate.planner.optimizer.matcher.Patterns.source;
4 import static io.crate.planner.optimizer.rule.Util.transpose;
5 import io.crate.metadata.NodeContext;
6 import io.crate.metadata.TransactionContext;
7 import io.crate.planner.operators.Eval;
8 import io.crate.planner.operators.Limit;
9 import io.crate.planner.operators.LogicalPlan;
10 import io.crate.planner.optimizer.Rule;
11 import io.crate.planner.optimizer.matcher.Capture;
12 import io.crate.planner.optimizer.matcher.Captures;
13 import io.crate.planner.optimizer.matcher.Pattern;
14 import</b></font> io.crate.statistics.TableStats;
15 public class MoveLimitBeneathEval implements Rule&lt;Limit&gt; {
16     private final Capture&lt;Eval&gt; evalCapture;
17     private final Pattern&lt;Limit&gt; pattern;
18     public MoveLimitBeneathEval() {
19         this.evalCapture = new Capture&lt;&gt;();
20         this.pattern = typeOf(Limit.class)
21             .with(source(), typeOf(Eval.class).capturedAs(evalCapture));
22     }
23     @Override
24     public Pattern&lt;Limit&gt; pattern() {
25         return pattern;
26     }
27     @Override
28     public LogicalPlan apply(Limit limit,
29 <a name="1"></a>                             Captures captures,
30                              TableStats tableStats,
31                              TransactionContext txnCtx,
32                              <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>NodeContext nodeCtx) {
33         Eval eval = captures.get(evalCapture);
34         return transpose(limit, eval);
35     }
36 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>XContentHelper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.common.xcontent;
2 import org.apache.lucene.util.BytesRef;
3 import org.elasticsearch.ElasticsearchParseException;
4 import org.elasticsearch.common.Strings;
5 import org.elasticsearch.common.bytes.BytesReference;
6 import io.crate.common.collections.Tuple;
7 import org.elasticsearch.common.compress.Compressor;
8 import org.elasticsearch.common.compress.CompressorFactory;
9 import org.elasticsearch.common.xcontent.ToXContent.Params;
10 import javax.annotation.Nullable;
11 import java.io.BufferedInputStream;
12 import java.io.IOException;
13 import java.io.InputStream;
14 import</b></font> java.io.UncheckedIOException;
15 import java.util.ArrayList;
16 import java.util.LinkedHashMap;
17 import java.util.List;
18 import java.util.Map;
19 import java.util.Objects;
20 @SuppressWarnings("unchecked")
21 public class XContentHelper {
22     @Deprecated
23     public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler,
24                                               BytesReference bytes) throws IOException {
25         Compressor compressor = CompressorFactory.compressor(bytes);
26         if (compressor != null) {
27             InputStream compressedInput = compressor.streamInput(bytes.streamInput());
28             if (compressedInput.markSupported() == false) {
29                 compressedInput = new BufferedInputStream(compressedInput);
30             }
31             final XContentType contentType = XContentFactory.xContentType(compressedInput);
32             return XContentFactory.xContent(contentType).createParser(xContentRegistry, deprecationHandler, compressedInput);
33         } else {
34             return XContentFactory.xContent(xContentType(bytes)).createParser(xContentRegistry, deprecationHandler, bytes.streamInput());
35         }
36     }
37     public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler,
38                                               BytesReference bytes, XContentType xContentType) throws IOException {
39         Objects.requireNonNull(xContentType);
40         Compressor compressor = CompressorFactory.compressor(bytes);
41         if (compressor != null) {
42             InputStream compressedInput = compressor.streamInput(bytes.streamInput());
43             if (compressedInput.markSupported() == false) {
44                 compressedInput = new BufferedInputStream(compressedInput);
45             }
46             return XContentFactory.xContent(xContentType).createParser(xContentRegistry, deprecationHandler, compressedInput);
47         } else {
48             return xContentType.xContent().createParser(xContentRegistry, deprecationHandler, bytes.streamInput());
49         }
50     }
51     @Deprecated
52     public static Tuple&lt;XContentType, Map&lt;String, Object&gt;&gt; convertToMap(BytesReference bytes, boolean ordered)
53             throws ElasticsearchParseException {
54         return convertToMap(bytes, ordered, null);
55     }
56     public static Map&lt;String, Object&gt; toMap(BytesReference bytes, XContentType xContentType) {
57         try (InputStream inputStream = getUncompressedInputStream(bytes)) {
58             XContentParser parser = xContentType.xContent().createParser(
59                 NamedXContentRegistry.EMPTY,
60                 DeprecationHandler.THROW_UNSUPPORTED_OPERATION,
61                 inputStream
62             );
63             return parser.map();
64         } catch (IOException e) {
65             throw new UncheckedIOException(e);
66         }
67     }
68     public static InputStream getUncompressedInputStream(BytesReference bytes) throws IOException {
69         Compressor compressor = CompressorFactory.compressor(bytes);
70         if (compressor == null) {
71             return bytes.streamInput();
72         }
73         InputStream compressedStreamInput = compressor.streamInput(bytes.streamInput());
74         if (compressedStreamInput.markSupported()) {
75             return compressedStreamInput;
76         } else {
77             return new BufferedInputStream(compressedStreamInput);
78         }
79     }
80     public static Tuple&lt;XContentType, Map&lt;String, Object&gt;&gt; convertToMap(BytesReference bytes, boolean ordered, @Nullable XContentType xContentType)
81         throws ElasticsearchParseException {
82         try {
83             final XContentType contentType;
84             try (InputStream input = getUncompressedInputStream(bytes)) {
85                 contentType = xContentType != null ? xContentType : XContentFactory.xContentType(input);
86                 return new Tuple&lt;&gt;(Objects.requireNonNull(contentType), convertToMap(XContentFactory.xContent(contentType), input, ordered));
87             }
88         } catch (IOException e) {
89             throw new ElasticsearchParseException("Failed to parse content to map", e);
90         }
91     }
92     public static Map&lt;String, Object&gt; convertToMap(XContent xContent, String string, boolean ordered) throws ElasticsearchParseException {
93         try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY,
94                 DeprecationHandler.THROW_UNSUPPORTED_OPERATION, string)) {
95             return ordered ? parser.mapOrdered() : parser.map();
96         } catch (IOException e) {
97             throw new ElasticsearchParseException("Failed to parse content to map", e);
98         }
99     }
100     public static Map&lt;String, Object&gt; convertToMap(XContent xContent, InputStream input, boolean ordered)
101             throws ElasticsearchParseException {
102         try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY,
103                 DeprecationHandler.THROW_UNSUPPORTED_OPERATION, input)) {
104             return ordered ? parser.mapOrdered() : parser.map();
105         } catch (IOException e) {
106             throw new ElasticsearchParseException("Failed to parse content to map", e);
107         }
108     }
109     public static String convertToJson(BytesReference bytes, XContentType xContentType) throws IOException {
110         Objects.requireNonNull(xContentType);
111         if (xContentType == XContentType.JSON) {
112             return bytes.utf8ToString();
113         }
114         try (InputStream stream = bytes.streamInput();
115              XContentParser parser = XContentFactory.xContent(xContentType).createParser(
116                  NamedXContentRegistry.EMPTY,
117                  DeprecationHandler.THROW_UNSUPPORTED_OPERATION,
118                  stream)) {
119             parser.nextToken();
120             XContentBuilder builder = XContentFactory.jsonBuilder();
121             builder.copyCurrentStructure(parser);
122             return Strings.toString(builder);
123         }
124     }
125     public static boolean update(Map&lt;String, Object&gt; source, Map&lt;String, Object&gt; changes, boolean checkUpdatesAreUnequal) {
126         boolean modified = false;
127         for (Map.Entry&lt;String, Object&gt; changesEntry : changes.entrySet()) {
128             if (!source.containsKey(changesEntry.getKey())) {
129                 source.put(changesEntry.getKey(), changesEntry.getValue());
130                 modified = true;
131                 continue;
132             }
133             Object old = source.get(changesEntry.getKey());
134             if (old instanceof Map &amp;&amp; changesEntry.getValue() instanceof Map) {
135                 modified |= update((Map&lt;String, Object&gt;) source.get(changesEntry.getKey()),
136                         (Map&lt;String, Object&gt;) changesEntry.getValue(), checkUpdatesAreUnequal &amp;&amp; !modified);
137                 continue;
138             }
139             source.put(changesEntry.getKey(), changesEntry.getValue());
140             if (modified) {
141                 continue;
142             }
143             if (!checkUpdatesAreUnequal) {
144                 modified = true;
145                 continue;
146             }
147             modified = !Objects.equals(old, changesEntry.getValue());
148         }
149         return modified;
150     }
151     public static void mergeDefaults(Map&lt;String, Object&gt; content, Map&lt;String, Object&gt; defaults) {
152         for (Map.Entry&lt;String, Object&gt; defaultEntry : defaults.entrySet()) {
153             if (!content.containsKey(defaultEntry.getKey())) {
154                 content.put(defaultEntry.getKey(), defaultEntry.getValue());
155             } else {
156                 if (content.get(defaultEntry.getKey()) instanceof Map &amp;&amp; defaultEntry.getValue() instanceof Map) {
157                     mergeDefaults((Map&lt;String, Object&gt;) content.get(defaultEntry.getKey()), (Map&lt;String, Object&gt;) defaultEntry.getValue());
158                 } else if (content.get(defaultEntry.getKey()) instanceof List &amp;&amp; defaultEntry.getValue() instanceof List) {
159                     List&lt;Object&gt; defaultList = (List&lt;Object&gt;) defaultEntry.getValue();
160                     List&lt;Object&gt; contentList = (List&lt;Object&gt;) content.get(defaultEntry.getKey());
161                     if (allListValuesAreMapsOfOne(defaultList) &amp;&amp; allListValuesAreMapsOfOne(contentList)) {
162                         Map&lt;String, Map&lt;String, Object&gt;&gt; processed = new LinkedHashMap&lt;&gt;();
163                         for (Object o : contentList) {
164                             Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;
165                             Map.Entry&lt;String, Object&gt; entry = map.entrySet().iterator().next();
166                             processed.put(entry.getKey(), map);
167                         }
168                         for (Object o : defaultList) {
169                             Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;
170                             Map.Entry&lt;String, Object&gt; entry = map.entrySet().iterator().next();
171                             if (processed.containsKey(entry.getKey())) {
172                                 mergeDefaults(processed.get(entry.getKey()), map);
173                             } else {
174                                 processed.put(entry.getKey(), map);
175                             }
176                         }
177                         content.put(defaultEntry.getKey(), new ArrayList&lt;&gt;(processed.values()));
178                     } else {
179                         List&lt;Object&gt; mergedList = new ArrayList&lt;&gt;(defaultList);
180                         for (Object o : contentList) {
181                             if (!mergedList.contains(o)) {
182                                 mergedList.add(o);
183                             }
184                         }
185                         content.put(defaultEntry.getKey(), mergedList);
186                     }
187                 }
188             }
189         }
190     }
191     private static boolean allListValuesAreMapsOfOne(List&lt;Object&gt; list) {
192         for (Object o : list) {
193             if (!(o instanceof Map)) {
194                 return false;
195             }
196             if (((Map) o).size() != 1) {
197                 return false;
198             }
199         }
200         return true;
201     }
202     public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {
203         try (XContentBuilder builder = XContentBuilder.builder(xContentType.xContent())) {
204             builder.humanReadable(humanReadable);
205             if (toXContent.isFragment()) {
206                 builder.startObject();
207             }
208             toXContent.toXContent(builder, params);
209             if (toXContent.isFragment()) {
210                 builder.endObject();
211             }
212             return BytesReference.bytes(builder);
213         }
214     }
215     @Deprecated
216     public static XContentType xContentType(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BytesReference bytes) {
217         BytesRef br = bytes.toBytesRef();
218         return XContentFactory.xContentType(br.bytes, br.offset, br.length);
219     }
220 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
