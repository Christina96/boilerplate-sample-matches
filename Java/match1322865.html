<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for IterablesTest.java &amp; Multimaps_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for IterablesTest.java &amp; Multimaps_1.java
      </h3>
<h1 align="center">
        5.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>IterablesTest.java (5.456133%)<th>Multimaps_1.java (5.263158%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-57)<td><a href="#" name="0">(31-75)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1302-1311)<td><a href="#" name="1">(1242-1251)</a><td align="center"><font color="#640000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(296-303)<td><a href="#" name="2">(687-693)</a><td align="center"><font color="#5c0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1406-1411)<td><a href="#" name="3">(1805-1810)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(697-701)<td><a href="#" name="4">(1596-1601)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(686-689)<td><a href="#" name="5">(1533-1537)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(97-104)<td><a href="#" name="6">(1901-1907)</a><td align="center"><font color="#4d0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1266-1269)<td><a href="#" name="7">(828-831)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1215-1221)<td><a href="#" name="8">(1512-1518)</a><td align="center"><font color="#450000">9</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(73-77)<td><a href="#" name="9">(1743-1747)</a><td align="center"><font color="#450000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IterablesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.collect.Iterables.skip;
4 import static com.google.common.collect.Lists.newArrayList;
5 import static com.google.common.collect.Sets.newLinkedHashSet;
6 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
7 import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;
8 import static com.google.common.truth.Truth.assertThat;
9 import static java.util.Arrays.asList;
10 import static java.util.Collections.emptyList;
11 import com.google.common.annotations.GwtCompatible;
12 import com.google.common.annotations.GwtIncompatible;
13 import com.google.common.base.Function;
14 import com.google.common.base.Predicate;
15 import com.google.common.base.Predicates;
16 import com.google.common.collect.testing.IteratorTester;
17 import com.google.common.testing.ClassSanityTester;
18 import com.google.common.testing.NullPointerTester;
19 import java.util.ArrayList;
20 import java.util.Arrays;
21 import java.util.Collection;
22 import java.util.Collections;
23 import java.util.ConcurrentModificationException;
24 import java.util.Iterator;
25 import java.util.List;
26 import java.util.NoSuchElementException;
27 import java.util.Queue;
28 import java.util.RandomAccess;
29 import java.util.Set;
30 import java.util.SortedSet;
31 import junit.framework.AssertionFailedError;
32 import junit.framework.TestCase;
33 @GwtCompatible(e</b></font>mulated = true)
34 public class IterablesTest extends TestCase {
35   public void testSize0() {
36     Iterable&lt;String&gt; iterable = Collections.emptySet();
37     assertEquals(0, Iterables.size(iterable));
38   }
39   public void testSize1Collection() {
40     Iterable&lt;String&gt; iterable = Collections.singleton("a");
41     assertEquals(1, Iterables.size(iterable));
42   }
43 <a name="9"></a>  public void testSize2NonCollection() {
44     Iterable&lt;Integer&gt; iterable =
45         new Iterable&lt;Integer&gt;() {
46           <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
47           public Iterator&lt;Integer&gt; iterator() {
48             return asList(0, 1).iterator();
49           }
50         }</b></font>;
51     assertEquals(2, Iterables.size(iterable));
52   }
53   @SuppressWarnings("serial")
54   public void testSize_collection_doesntIterate() {
55     List&lt;Integer&gt; nums = asList(1, 2, 3, 4, 5);
56     List&lt;Integer&gt; collection =
57         new ArrayList&lt;Integer&gt;(nums) {
58           @Override
59           public Iterator&lt;Integer&gt; iterator() {
60             throw new AssertionFailedError("Don't iterate me!");
61           }
62         };
63     assertEquals(5, Iterables.size(collection));
64   }
65 <a name="6"></a>  private static Iterable&lt;String&gt; iterable(String... elements) {
66     final List&lt;String&gt; list = asList(elements);
67     return new Iterable&lt;String&gt;() {
68       <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
69       public Iterator&lt;String&gt; iterator() {
70         return list.iterator();
71       }
72     };
73   }
74   public void test_contains_</b></font>null_set_yes() {
75     Iterable&lt;String&gt; set = Sets.newHashSet("a", null, "b");
76     assertTrue(Iterables.contains(set, null));
77   }
78   public void test_contains_null_set_no() {
79     Iterable&lt;String&gt; set = Sets.newHashSet("a", "b");
80     assertFalse(Iterables.contains(set, null));
81   }
82   public void test_contains_null_iterable_yes() {
83     Iterable&lt;String&gt; set = iterable("a", null, "b");
84     assertTrue(Iterables.contains(set, null));
85   }
86   public void test_contains_null_iterable_no() {
87     Iterable&lt;String&gt; set = iterable("a", "b");
88     assertFalse(Iterables.contains(set, null));
89   }
90   public void test_contains_nonnull_set_yes() {
91     Iterable&lt;String&gt; set = Sets.newHashSet("a", null, "b");
92     assertTrue(Iterables.contains(set, "b"));
93   }
94   public void test_contains_nonnull_set_no() {
95     Iterable&lt;String&gt; set = Sets.newHashSet("a", "b");
96     assertFalse(Iterables.contains(set, "c"));
97   }
98   public void test_contains_nonnull_iterable_yes() {
99     Iterable&lt;String&gt; set = iterable("a", null, "b");
100     assertTrue(Iterables.contains(set, "b"));
101   }
102   public void test_contains_nonnull_iterable_no() {
103     Iterable&lt;String&gt; set = iterable("a", "b");
104     assertFalse(Iterables.contains(set, "c"));
105   }
106   public void testGetOnlyElement_noDefault_valid() {
107     Iterable&lt;String&gt; iterable = Collections.singletonList("foo");
108     assertEquals("foo", Iterables.getOnlyElement(iterable));
109   }
110   public void testGetOnlyElement_noDefault_empty() {
111     Iterable&lt;String&gt; iterable = Collections.emptyList();
112     try {
113       Iterables.getOnlyElement(iterable);
114       fail();
115     } catch (NoSuchElementException expected) {
116     }
117   }
118   public void testGetOnlyElement_noDefault_multiple() {
119     Iterable&lt;String&gt; iterable = asList("foo", "bar");
120     try {
121       Iterables.getOnlyElement(iterable);
122       fail();
123     } catch (IllegalArgumentException expected) {
124     }
125   }
126   public void testGetOnlyElement_withDefault_singleton() {
127     Iterable&lt;String&gt; iterable = Collections.singletonList("foo");
128     assertEquals("foo", Iterables.getOnlyElement(iterable, "bar"));
129   }
130   public void testGetOnlyElement_withDefault_empty() {
131     Iterable&lt;String&gt; iterable = Collections.emptyList();
132     assertEquals("bar", Iterables.getOnlyElement(iterable, "bar"));
133   }
134   public void testGetOnlyElement_withDefault_empty_null() {
135     Iterable&lt;String&gt; iterable = Collections.emptyList();
136     assertNull(Iterables.getOnlyElement(iterable, null));
137   }
138   public void testGetOnlyElement_withDefault_multiple() {
139     Iterable&lt;String&gt; iterable = asList("foo", "bar");
140     try {
141       Iterables.getOnlyElement(iterable, "x");
142       fail();
143     } catch (IllegalArgumentException expected) {
144     }
145   }
146   @GwtIncompatible   public void testToArrayEmpty() {
147     Iterable&lt;String&gt; iterable = Collections.emptyList();
148     String[] array = Iterables.toArray(iterable, String.class);
149     assertTrue(Arrays.equals(new String[0], array));
150   }
151   @GwtIncompatible   public void testToArraySingleton() {
152     Iterable&lt;String&gt; iterable = Collections.singletonList("a");
153     String[] array = Iterables.toArray(iterable, String.class);
154     assertTrue(Arrays.equals(new String[] {"a"}, array));
155   }
156   @GwtIncompatible   public void testToArray() {
157     String[] sourceArray = new String[] {"a", "b", "c"};
158     Iterable&lt;String&gt; iterable = asList(sourceArray);
159     String[] newArray = Iterables.toArray(iterable, String.class);
160     assertTrue(Arrays.equals(sourceArray, newArray));
161   }
162   public void testAny() {
163     List&lt;String&gt; list = newArrayList();
164     Predicate&lt;String&gt; predicate = Predicates.equalTo("pants");
165     assertFalse(Iterables.any(list, predicate));
166     list.add("cool");
167     assertFalse(Iterables.any(list, predicate));
168     list.add("pants");
169     assertTrue(Iterables.any(list, predicate));
170   }
171   public void testAll() {
172     List&lt;String&gt; list = newArrayList();
173     Predicate&lt;String&gt; predicate = Predicates.equalTo("cool");
174     assertTrue(Iterables.all(list, predicate));
175     list.add("cool");
176     assertTrue(Iterables.all(list, predicate));
177     list.add("pants");
178     assertFalse(Iterables.all(list, predicate));
179   }
180   public void testFind() {
181     Iterable&lt;String&gt; list = newArrayList("cool", "pants");
182     assertEquals("cool", Iterables.find(list, Predicates.equalTo("cool")));
183     assertEquals("pants", Iterables.find(list, Predicates.equalTo("pants")));
184     try {
185       Iterables.find(list, Predicates.alwaysFalse());
186       fail();
187     } catch (NoSuchElementException e) {
188     }
189     assertEquals("cool", Iterables.find(list, Predicates.alwaysTrue()));
190     assertCanIterateAgain(list);
191   }
192   public void testFind_withDefault() {
193     Iterable&lt;String&gt; list = Lists.newArrayList("cool", "pants");
194     assertEquals("cool", Iterables.find(list, Predicates.equalTo("cool"), "woot"));
195     assertEquals("pants", Iterables.find(list, Predicates.equalTo("pants"), "woot"));
196     assertEquals("woot", Iterables.find(list, Predicates.alwaysFalse(), "woot"));
197     assertNull(Iterables.find(list, Predicates.alwaysFalse(), null));
198     assertEquals("cool", Iterables.find(list, Predicates.alwaysTrue(), "woot"));
199     assertCanIterateAgain(list);
200   }
201   public void testTryFind() {
202     Iterable&lt;String&gt; list = newArrayList("cool", "pants");
203     assertThat(Iterables.tryFind(list, Predicates.equalTo("cool"))).hasValue("cool");
204     assertThat(Iterables.tryFind(list, Predicates.equalTo("pants"))).hasValue("pants");
205     assertThat(Iterables.tryFind(list, Predicates.alwaysTrue())).hasValue("cool");
206     assertThat(Iterables.tryFind(list, Predicates.alwaysFalse())).isAbsent();
207     assertCanIterateAgain(list);
208   }
209   private static class TypeA {}
210   private interface TypeB {}
211   private static class HasBoth extends TypeA implements TypeB {}
212   @GwtIncompatible   public void testFilterByType_iterator() throws Exception {
213     HasBoth hasBoth = new HasBoth();
214     Iterable&lt;TypeA&gt; alist = Lists.newArrayList(new TypeA(), new TypeA(), hasBoth, new TypeA());
215     Iterable&lt;TypeB&gt; blist = Iterables.filter(alist, TypeB.class);
216     assertThat(blist).containsExactly(hasBoth).inOrder();
217   }
218   @GwtIncompatible   public void testFilterByType_forEach() throws Exception {
219     HasBoth hasBoth1 = new HasBoth();
220     HasBoth hasBoth2 = new HasBoth();
221     Iterable&lt;TypeA&gt; alist = Lists.newArrayList(hasBoth1, new TypeA(), hasBoth2, new TypeA());
222     Iterable&lt;TypeB&gt; blist = Iterables.filter(alist, TypeB.class);
223     Iterator&lt;TypeB&gt; expectedIterator = Arrays.&lt;TypeB&gt;asList(hasBoth1, hasBoth2).iterator();
224     blist.forEach(b -&gt; assertThat(b).isEqualTo(expectedIterator.next()));
225     assertThat(expectedIterator.hasNext()).isFalse();
226   }
227 <a name="2"></a>  public void testTransform_iterator() {
228     List&lt;String&gt; input = asList("1", "2", "3");
229     Iterable&lt;Integer&gt; result =
230         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Iterables.transform(
231             input,
232             new Function&lt;String, Integer&gt;() {
233               @Override
234               public Integer apply(String from) {
235                 return Integer.valueOf(from);
236               }
237             }</b></font>);
238     List&lt;Integer&gt; actual = newArrayList(result);
239     List&lt;Integer&gt; expected = asList(1, 2, 3);
240     assertEquals(expected, actual);
241     assertCanIterateAgain(result);
242     assertEquals("[1, 2, 3]", result.toString());
243   }
244   public void testTransform_forEach() {
245     List&lt;Integer&gt; input = asList(1, 2, 3, 4);
246     Iterable&lt;String&gt; result =
247         Iterables.transform(
248             input,
249             new Function&lt;Integer, String&gt;() {
250               @Override
251               public String apply(Integer from) {
252                 return Integer.toBinaryString(from);
253               }
254             });
255     Iterator&lt;String&gt; expectedIterator = asList("1", "10", "11", "100").iterator();
256     result.forEach(s -&gt; assertEquals(expectedIterator.next(), s));
257     assertFalse(expectedIterator.hasNext());
258   }
259   public void testPoorlyBehavedTransform() {
260     List&lt;String&gt; input = asList("1", null, "3");
261     Iterable&lt;Integer&gt; result =
262         Iterables.transform(
263             input,
264             new Function&lt;String, Integer&gt;() {
265               @Override
266               public Integer apply(String from) {
267                 return Integer.valueOf(from);
268               }
269             });
270     Iterator&lt;Integer&gt; resultIterator = result.iterator();
271     resultIterator.next();
272     try {
273       resultIterator.next();
274       fail("Expected NFE");
275     } catch (NumberFormatException expected) {
276     }
277   }
278   public void testNullFriendlyTransform() {
279     List&lt;Integer&gt; input = asList(1, 2, null, 3);
280     Iterable&lt;String&gt; result =
281         Iterables.transform(
282             input,
283             new Function&lt;Integer, String&gt;() {
284               @Override
285               public String apply(Integer from) {
286                 return String.valueOf(from);
287               }
288             });
289     List&lt;String&gt; actual = newArrayList(result);
290     List&lt;String&gt; expected = asList("1", "2", "null", "3");
291     assertEquals(expected, actual);
292   }
293   public void testCycle() {
294     Iterable&lt;String&gt; cycle = Iterables.cycle("a", "b");
295     int howManyChecked = 0;
296     for (String string : cycle) {
297       String expected = (howManyChecked % 2 == 0) ? "a" : "b";
298       assertEquals(expected, string);
299       if (howManyChecked++ == 5) {
300         break;
301       }
302     }
303     for (String string : cycle) {
304       assertEquals("a", string);
305       break;
306     }
307     assertEquals("[a, b] (cycled)", cycle.toString());
308   }
309   public void testConcatIterable() {
310     List&lt;Integer&gt; list1 = newArrayList(1);
311     List&lt;Integer&gt; list2 = newArrayList(4);
312     @SuppressWarnings("unchecked")
313     List&lt;List&lt;Integer&gt;&gt; input = newArrayList(list1, list2);
314     Iterable&lt;Integer&gt; result = Iterables.concat(input);
315     assertEquals(asList(1, 4), newArrayList(result));
316     list1.add(2);
317     List&lt;Integer&gt; list3 = newArrayList(3);
318     input.add(1, list3);
319     assertEquals(asList(1, 2, 3, 4), newArrayList(result));
320     assertEquals("[1, 2, 3, 4]", result.toString());
321   }
322   public void testConcatVarargs() {
323     List&lt;Integer&gt; list1 = newArrayList(1);
324     List&lt;Integer&gt; list2 = newArrayList(4);
325     List&lt;Integer&gt; list3 = newArrayList(7, 8);
326     List&lt;Integer&gt; list4 = newArrayList(9);
327     List&lt;Integer&gt; list5 = newArrayList(10);
328     @SuppressWarnings("unchecked")
329     Iterable&lt;Integer&gt; result = Iterables.concat(list1, list2, list3, list4, list5);
330     assertEquals(asList(1, 4, 7, 8, 9, 10), newArrayList(result));
331     assertEquals("[1, 4, 7, 8, 9, 10]", result.toString());
332   }
333   public void testConcatNullPointerException() {
334     List&lt;Integer&gt; list1 = newArrayList(1);
335     List&lt;Integer&gt; list2 = newArrayList(4);
336     try {
337       Iterables.concat(list1, null, list2);
338       fail();
339     } catch (NullPointerException expected) {
340     }
341   }
342   public void testConcatPeformingFiniteCycle() {
343     Iterable&lt;Integer&gt; iterable = asList(1, 2, 3);
344     int n = 4;
345     Iterable&lt;Integer&gt; repeated = Iterables.concat(Collections.nCopies(n, iterable));
346     assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();
347   }
348   public void testPartition_badSize() {
349     Iterable&lt;Integer&gt; source = Collections.singleton(1);
350     try {
351       Iterables.partition(source, 0);
352       fail();
353     } catch (IllegalArgumentException expected) {
354     }
355   }
356   public void testPartition_empty() {
357     Iterable&lt;Integer&gt; source = Collections.emptySet();
358     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.partition(source, 1);
359     assertTrue(Iterables.isEmpty(partitions));
360   }
361   public void testPartition_singleton1() {
362     Iterable&lt;Integer&gt; source = Collections.singleton(1);
363     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.partition(source, 1);
364     assertEquals(1, Iterables.size(partitions));
365     assertEquals(Collections.singletonList(1), partitions.iterator().next());
366   }
367   public void testPartition_view() {
368     List&lt;Integer&gt; list = asList(1, 2);
369     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.partition(list, 2);
370     list.set(0, 3);
371     Iterator&lt;List&lt;Integer&gt;&gt; iterator = partitions.iterator();
372     list.set(1, 4);
373     List&lt;Integer&gt; first = iterator.next();
374     list.set(0, 5);
375     assertEquals(ImmutableList.of(3, 4), first);
376   }
377   @GwtIncompatible   public void testPartitionRandomAccessInput() {
378     Iterable&lt;Integer&gt; source = asList(1, 2, 3);
379     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.partition(source, 2);
380     Iterator&lt;List&lt;Integer&gt;&gt; iterator = partitions.iterator();
381     assertTrue(iterator.next() instanceof RandomAccess);
382     assertTrue(iterator.next() instanceof RandomAccess);
383   }
384   @GwtIncompatible   public void testPartitionNonRandomAccessInput() {
385     Iterable&lt;Integer&gt; source = Lists.newLinkedList(asList(1, 2, 3));
386     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.partition(source, 2);
387     Iterator&lt;List&lt;Integer&gt;&gt; iterator = partitions.iterator();
388     assertTrue(iterator.next() instanceof RandomAccess);
389     assertTrue(iterator.next() instanceof RandomAccess);
390   }
391   public void testPaddedPartition_basic() {
392     List&lt;Integer&gt; list = asList(1, 2, 3, 4, 5);
393     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.paddedPartition(list, 2);
394     assertEquals(3, Iterables.size(partitions));
395     assertEquals(asList(5, null), Iterables.getLast(partitions));
396   }
397   public void testPaddedPartitionRandomAccessInput() {
398     Iterable&lt;Integer&gt; source = asList(1, 2, 3);
399     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.paddedPartition(source, 2);
400     Iterator&lt;List&lt;Integer&gt;&gt; iterator = partitions.iterator();
401     assertTrue(iterator.next() instanceof RandomAccess);
402     assertTrue(iterator.next() instanceof RandomAccess);
403   }
404   public void testPaddedPartitionNonRandomAccessInput() {
405     Iterable&lt;Integer&gt; source = Lists.newLinkedList(asList(1, 2, 3));
406     Iterable&lt;List&lt;Integer&gt;&gt; partitions = Iterables.paddedPartition(source, 2);
407     Iterator&lt;List&lt;Integer&gt;&gt; iterator = partitions.iterator();
408     assertTrue(iterator.next() instanceof RandomAccess);
409     assertTrue(iterator.next() instanceof RandomAccess);
410   }
411   public void testAddAllToList() {
412     List&lt;String&gt; alreadyThere = newArrayList("already", "there");
413     List&lt;String&gt; freshlyAdded = newArrayList("freshly", "added");
414     boolean changed = Iterables.addAll(alreadyThere, freshlyAdded);
415     assertThat(alreadyThere).containsExactly("already", "there", "freshly", "added").inOrder();
416     assertTrue(changed);
417   }
418   private static void assertCanIterateAgain(Iterable&lt;?&gt; iterable) {
419     for (@SuppressWarnings("unused") Object obj : iterable) {}
420   }
421   @GwtIncompatible   public void testNullPointerExceptions() {
422     NullPointerTester tester = new NullPointerTester();
423     tester.testAllPublicStaticMethods(Iterables.class);
424   }
425   public void testElementsEqual() throws Exception {
426     Iterable&lt;?&gt; a;
427     Iterable&lt;?&gt; b;
428     a = asList(4, 8, 15, 16, 23, 42);
429     b = asList(4, 8, 15, 16, 23, 42);
430     assertTrue(Iterables.elementsEqual(a, b));
431     a = asList(4, 8, 15, 12, 23, 42);
432     b = asList(4, 8, 15, 16, 23, 42);
433     assertFalse(Iterables.elementsEqual(a, b));
434     a = asList(4, 8, 15, null, 23, 42);
435     b = asList(4, 8, 15, 16, 23, 42);
436     assertFalse(Iterables.elementsEqual(a, b));
437     assertFalse(Iterables.elementsEqual(b, a));
438     a = asList(4, 8, 15, 16, 23);
439     b = asList(4, 8, 15, 16, 23, 42);
440     assertFalse(Iterables.elementsEqual(a, b));
441     assertFalse(Iterables.elementsEqual(b, a));
442   }
443   public void testToString() {
444     List&lt;String&gt; list = Collections.emptyList();
445     assertEquals("[]", Iterables.toString(list));
446     list = newArrayList("yam", "bam", "jam", "ham");
447     assertEquals("[yam, bam, jam, ham]", Iterables.toString(list));
448   }
449   public void testLimit() {
450     Iterable&lt;String&gt; iterable = newArrayList("foo", "bar", "baz");
451     Iterable&lt;String&gt; limited = Iterables.limit(iterable, 2);
452     List&lt;String&gt; expected = ImmutableList.of("foo", "bar");
453     List&lt;String&gt; actual = newArrayList(limited);
454     assertEquals(expected, actual);
455     assertCanIterateAgain(limited);
456     assertEquals("[foo, bar]", limited.toString());
457   }
458   public void testLimit_illegalArgument() {
459     List&lt;String&gt; list = newArrayList("a", "b", "c");
460     try {
461       Iterables.limit(list, -1);
462       fail();
463     } catch (IllegalArgumentException expected) {
464     }
465   }
466   public void testIsEmpty() {
467     Iterable&lt;String&gt; emptyList = Collections.emptyList();
468     assertTrue(Iterables.isEmpty(emptyList));
469     Iterable&lt;String&gt; singletonList = Collections.singletonList("foo");
470     assertFalse(Iterables.isEmpty(singletonList));
471   }
472   public void testSkip_simple() {
473     Collection&lt;String&gt; set = ImmutableSet.of("a", "b", "c", "d", "e");
474     assertEquals(newArrayList("c", "d", "e"), newArrayList(skip(set, 2)));
475     assertEquals("[c, d, e]", skip(set, 2).toString());
476   }
477   public void testSkip_simpleList() {
478     Collection&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
479     assertEquals(newArrayList("c", "d", "e"), newArrayList(skip(list, 2)));
480     assertEquals("[c, d, e]", skip(list, 2).toString());
481   }
482   public void testSkip_pastEnd() {
483     Collection&lt;String&gt; set = ImmutableSet.of("a", "b");
484     assertEquals(emptyList(), newArrayList(skip(set, 20)));
485   }
486   public void testSkip_pastEndList() {
487     Collection&lt;String&gt; list = newArrayList("a", "b");
488     assertEquals(emptyList(), newArrayList(skip(list, 20)));
489   }
490   public void testSkip_skipNone() {
491     Collection&lt;String&gt; set = ImmutableSet.of("a", "b");
492     assertEquals(newArrayList("a", "b"), newArrayList(skip(set, 0)));
493   }
494   public void testSkip_skipNoneList() {
495     Collection&lt;String&gt; list = newArrayList("a", "b");
496     assertEquals(newArrayList("a", "b"), newArrayList(skip(list, 0)));
497   }
498   public void testSkip_removal() {
499     Collection&lt;String&gt; set = Sets.newHashSet("a", "b");
500     Iterator&lt;String&gt; iterator = skip(set, 2).iterator();
501     try {
502       iterator.next();
503     } catch (NoSuchElementException suppressed) {
504     }
505     try {
506       iterator.remove();
507       fail("Expected IllegalStateException");
508     } catch (IllegalStateException expected) {
509     }
510   }
511   public void testSkip_allOfMutableList_modifiable() {
512     List&lt;String&gt; list = newArrayList("a", "b");
513     Iterator&lt;String&gt; iterator = skip(list, 2).iterator();
514     try {
515       iterator.remove();
516       fail("Expected IllegalStateException");
517     } catch (IllegalStateException expected) {
518     }
519   }
520   public void testSkip_allOfImmutableList_modifiable() {
521     List&lt;String&gt; list = ImmutableList.of("a", "b");
522     Iterator&lt;String&gt; iterator = skip(list, 2).iterator();
523     try {
524       iterator.remove();
525       fail("Expected UnsupportedOperationException");
526     } catch (UnsupportedOperationException expected) {
527     }
528   }
529   @GwtIncompatible <a name="5"></a>  public void testSkip_iterator() {
530     new IteratorTester&lt;Integer&gt;(
531         5, MODIFIABLE, newArrayList(2, 3), IteratorTester.KnownOrder.KNOWN_ORDER) {
532       <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
533       protected Iterator&lt;Integer&gt; newTargetIterator() {
534         return skip(newLinkedHashSet(asList(1, 2, 3)), 1).iterator();
535       }</b></font>
536     }.test();
537   }
538   @GwtIncompatible <a name="4"></a>  public void testSkip_iteratorList() {
539     new IteratorTester&lt;Integer&gt;(
540         5, MODIFIABLE, newArrayList(2, 3), IteratorTester.KnownOrder.KNOWN_ORDER) {
541       <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
542       protected Iterator&lt;Integer&gt; newTargetIterator() {
543         return skip(newArrayList(1, 2, 3), 1).iterator();
544       }
545     }</b></font>.test();
546   }
547   public void testSkip_nonStructurallyModifiedList() throws Exception {
548     List&lt;String&gt; list = newArrayList("a", "b", "c");
549     Iterable&lt;String&gt; tail = skip(list, 1);
550     Iterator&lt;String&gt; tailIterator = tail.iterator();
551     list.set(2, "C");
552     assertEquals("b", tailIterator.next());
553     assertEquals("C", tailIterator.next());
554     assertFalse(tailIterator.hasNext());
555   }
556   public void testSkip_structurallyModifiedSkipSome() throws Exception {
557     Collection&lt;String&gt; set = newLinkedHashSet(asList("a", "b", "c"));
558     Iterable&lt;String&gt; tail = skip(set, 1);
559     set.remove("b");
560     set.addAll(newArrayList("A", "B", "C"));
561     assertThat(tail).containsExactly("c", "A", "B", "C").inOrder();
562   }
563   public void testSkip_structurallyModifiedSkipSomeList() throws Exception {
564     List&lt;String&gt; list = newArrayList("a", "b", "c");
565     Iterable&lt;String&gt; tail = skip(list, 1);
566     list.subList(1, 3).clear();
567     list.addAll(0, newArrayList("A", "B", "C"));
568     assertThat(tail).containsExactly("B", "C", "a").inOrder();
569   }
570   public void testSkip_structurallyModifiedSkipAll() throws Exception {
571     Collection&lt;String&gt; set = newLinkedHashSet(asList("a", "b", "c"));
572     Iterable&lt;String&gt; tail = skip(set, 2);
573     set.remove("a");
574     set.remove("b");
575     assertFalse(tail.iterator().hasNext());
576   }
577   public void testSkip_structurallyModifiedSkipAllList() throws Exception {
578     List&lt;String&gt; list = newArrayList("a", "b", "c");
579     Iterable&lt;String&gt; tail = skip(list, 2);
580     list.subList(0, 2).clear();
581     assertTrue(Iterables.isEmpty(tail));
582   }
583   public void testSkip_illegalArgument() {
584     List&lt;String&gt; list = newArrayList("a", "b", "c");
585     try {
586       skip(list, -1);
587       fail();
588     } catch (IllegalArgumentException expected) {
589     }
590   }
591   private void testGetOnAbc(Iterable&lt;String&gt; iterable) {
592     try {
593       Iterables.get(iterable, -1);
594       fail();
595     } catch (IndexOutOfBoundsException expected) {
596     }
597     assertEquals("a", Iterables.get(iterable, 0));
598     assertEquals("b", Iterables.get(iterable, 1));
599     assertEquals("c", Iterables.get(iterable, 2));
600     try {
601       Iterables.get(iterable, 3);
602       fail();
603     } catch (IndexOutOfBoundsException nsee) {
604     }
605     try {
606       Iterables.get(iterable, 4);
607       fail();
608     } catch (IndexOutOfBoundsException nsee) {
609     }
610   }
611   private void testGetOnEmpty(Iterable&lt;String&gt; iterable) {
612     try {
613       Iterables.get(iterable, 0);
614       fail();
615     } catch (IndexOutOfBoundsException expected) {
616     }
617   }
618   public void testGet_list() {
619     testGetOnAbc(newArrayList("a", "b", "c"));
620   }
621   public void testGet_emptyList() {
622     testGetOnEmpty(Collections.&lt;String&gt;emptyList());
623   }
624   public void testGet_sortedSet() {
625     testGetOnAbc(ImmutableSortedSet.of("b", "c", "a"));
626   }
627   public void testGet_emptySortedSet() {
628     testGetOnEmpty(ImmutableSortedSet.&lt;String&gt;of());
629   }
630   public void testGet_iterable() {
631     testGetOnAbc(ImmutableSet.of("a", "b", "c"));
632   }
633   public void testGet_emptyIterable() {
634     testGetOnEmpty(Sets.&lt;String&gt;newHashSet());
635   }
636   public void testGet_withDefault_negativePosition() {
637     try {
638       Iterables.get(newArrayList("a", "b", "c"), -1, "d");
639       fail();
640     } catch (IndexOutOfBoundsException expected) {
641     }
642   }
643   public void testGet_withDefault_simple() {
644     ArrayList&lt;String&gt; list = newArrayList("a", "b", "c");
645     assertEquals("b", Iterables.get(list, 1, "d"));
646   }
647   public void testGet_withDefault_iterable() {
648     Set&lt;String&gt; set = ImmutableSet.of("a", "b", "c");
649     assertEquals("b", Iterables.get(set, 1, "d"));
650   }
651   public void testGet_withDefault_last() {
652     ArrayList&lt;String&gt; list = newArrayList("a", "b", "c");
653     assertEquals("c", Iterables.get(list, 2, "d"));
654   }
655   public void testGet_withDefault_lastPlusOne() {
656     ArrayList&lt;String&gt; list = newArrayList("a", "b", "c");
657     assertEquals("d", Iterables.get(list, 3, "d"));
658   }
659   public void testGet_withDefault_doesntIterate() {
660     List&lt;String&gt; list = new DiesOnIteratorArrayList();
661     list.add("a");
662     assertEquals("a", Iterables.get(list, 0, "b"));
663   }
664   public void testGetFirst_withDefault_singleton() {
665     Iterable&lt;String&gt; iterable = Collections.singletonList("foo");
666     assertEquals("foo", Iterables.getFirst(iterable, "bar"));
667   }
668   public void testGetFirst_withDefault_empty() {
669     Iterable&lt;String&gt; iterable = Collections.emptyList();
670     assertEquals("bar", Iterables.getFirst(iterable, "bar"));
671   }
672   public void testGetFirst_withDefault_empty_null() {
673     Iterable&lt;String&gt; iterable = Collections.emptyList();
674     assertNull(Iterables.getFirst(iterable, null));
675   }
676   public void testGetFirst_withDefault_multiple() {
677     Iterable&lt;String&gt; iterable = asList("foo", "bar");
678     assertEquals("foo", Iterables.getFirst(iterable, "qux"));
679   }
680   public void testGetLast_list() {
681     List&lt;String&gt; list = newArrayList("a", "b", "c");
682     assertEquals("c", Iterables.getLast(list));
683   }
684   public void testGetLast_emptyList() {
685     List&lt;String&gt; list = Collections.emptyList();
686     try {
687       Iterables.getLast(list);
688       fail();
689     } catch (NoSuchElementException e) {
690     }
691   }
692   public void testGetLast_sortedSet() {
693     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of("b", "c", "a");
694     assertEquals("c", Iterables.getLast(sortedSet));
695   }
696   public void testGetLast_withDefault_singleton() {
697     Iterable&lt;String&gt; iterable = Collections.singletonList("foo");
698     assertEquals("foo", Iterables.getLast(iterable, "bar"));
699   }
700   public void testGetLast_withDefault_empty() {
701     Iterable&lt;String&gt; iterable = Collections.emptyList();
702     assertEquals("bar", Iterables.getLast(iterable, "bar"));
703   }
704   public void testGetLast_withDefault_empty_null() {
705     Iterable&lt;String&gt; iterable = Collections.emptyList();
706     assertNull(Iterables.getLast(iterable, null));
707   }
708   public void testGetLast_withDefault_multiple() {
709     Iterable&lt;String&gt; iterable = asList("foo", "bar");
710     assertEquals("bar", Iterables.getLast(iterable, "qux"));
711   }
712   private static class DiesOnIteratorArrayList extends ArrayList&lt;String&gt; {
713     @Override
714     public Iterator&lt;String&gt; iterator() {
715       throw new UnsupportedOperationException();
716     }
717   }
718   public void testGetLast_withDefault_not_empty_list() {
719     List&lt;String&gt; diesOnIteratorList = new DiesOnIteratorArrayList();
720     diesOnIteratorList.add("bar");
721     assertEquals("bar", Iterables.getLast(diesOnIteratorList, "qux"));
722   }
723   public void testGetLast_emptySortedSet() {
724     SortedSet&lt;String&gt; sortedSet = ImmutableSortedSet.of();
725     try {
726       Iterables.getLast(sortedSet);
727       fail();
728     } catch (NoSuchElementException e) {
729     }
730   }
731   public void testGetLast_iterable() {
732     Set&lt;String&gt; set = ImmutableSet.of("a", "b", "c");
733     assertEquals("c", Iterables.getLast(set));
734   }
735   public void testGetLast_emptyIterable() {
736     Set&lt;String&gt; set = Sets.newHashSet();
737     try {
738       Iterables.getLast(set);
739       fail();
740     } catch (NoSuchElementException e) {
741     }
742   }
743   public void testUnmodifiableIterable() {
744     List&lt;String&gt; list = newArrayList("a", "b", "c");
745     Iterable&lt;String&gt; iterable = Iterables.unmodifiableIterable(list);
746     Iterator&lt;String&gt; iterator = iterable.iterator();
747     iterator.next();
748     try {
749       iterator.remove();
750       fail();
751     } catch (UnsupportedOperationException expected) {
752     }
753     assertEquals("[a, b, c]", iterable.toString());
754   }
755   public void testUnmodifiableIterable_forEach() {
756     List&lt;String&gt; list = newArrayList("a", "b", "c", "d");
757     Iterable&lt;String&gt; iterable = Iterables.unmodifiableIterable(list);
758     Iterator&lt;String&gt; expectedIterator = list.iterator();
759     iterable.forEach(s -&gt; assertEquals(expectedIterator.next(), s));
760     assertFalse(expectedIterator.hasNext());
761   }
762   @SuppressWarnings("deprecation")   public void testUnmodifiableIterableShortCircuit() {
763     List&lt;String&gt; list = newArrayList("a", "b", "c");
764     Iterable&lt;String&gt; iterable = Iterables.unmodifiableIterable(list);
765     Iterable&lt;String&gt; iterable2 = Iterables.unmodifiableIterable(iterable);
766     assertSame(iterable, iterable2);
767     ImmutableList&lt;String&gt; immutableList = ImmutableList.of("a", "b", "c");
768     assertSame(immutableList, Iterables.unmodifiableIterable(immutableList));
769     assertSame(immutableList, Iterables.unmodifiableIterable((List&lt;String&gt;) immutableList));
770   }
771   public void testFrequency_multiset() {
772     Multiset&lt;String&gt; multiset = ImmutableMultiset.of("a", "b", "a", "c", "b", "a");
773     assertEquals(3, Iterables.frequency(multiset, "a"));
774     assertEquals(2, Iterables.frequency(multiset, "b"));
775     assertEquals(1, Iterables.frequency(multiset, "c"));
776     assertEquals(0, Iterables.frequency(multiset, "d"));
777     assertEquals(0, Iterables.frequency(multiset, 4.2));
778     assertEquals(0, Iterables.frequency(multiset, null));
779   }
780   public void testFrequency_set() {
781     Set&lt;String&gt; set = Sets.newHashSet("a", "b", "c");
782     assertEquals(1, Iterables.frequency(set, "a"));
783     assertEquals(1, Iterables.frequency(set, "b"));
784     assertEquals(1, Iterables.frequency(set, "c"));
785     assertEquals(0, Iterables.frequency(set, "d"));
786     assertEquals(0, Iterables.frequency(set, 4.2));
787     assertEquals(0, Iterables.frequency(set, null));
788   }
789   public void testFrequency_list() {
790     List&lt;String&gt; list = newArrayList("a", "b", "a", "c", "b", "a");
791     assertEquals(3, Iterables.frequency(list, "a"));
792     assertEquals(2, Iterables.frequency(list, "b"));
793     assertEquals(1, Iterables.frequency(list, "c"));
794     assertEquals(0, Iterables.frequency(list, "d"));
795     assertEquals(0, Iterables.frequency(list, 4.2));
796     assertEquals(0, Iterables.frequency(list, null));
797   }
798   public void testRemoveAll_collection() {
799     List&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
800     assertTrue(Iterables.removeAll(list, newArrayList("b", "d", "f")));
801     assertEquals(newArrayList("a", "c", "e"), list);
802     assertFalse(Iterables.removeAll(list, newArrayList("x", "y", "z")));
803     assertEquals(newArrayList("a", "c", "e"), list);
804   }
805   public void testRemoveAll_iterable() {
806     final List&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
807     Iterable&lt;String&gt; iterable =
808         new Iterable&lt;String&gt;() {
809           @Override
810           public Iterator&lt;String&gt; iterator() {
811             return list.iterator();
812           }
813         };
814     assertTrue(Iterables.removeAll(iterable, newArrayList("b", "d", "f")));
815     assertEquals(newArrayList("a", "c", "e"), list);
816     assertFalse(Iterables.removeAll(iterable, newArrayList("x", "y", "z")));
817     assertEquals(newArrayList("a", "c", "e"), list);
818   }
819   public void testRetainAll_collection() {
820     List&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
821     assertTrue(Iterables.retainAll(list, newArrayList("b", "d", "f")));
822     assertEquals(newArrayList("b", "d"), list);
823     assertFalse(Iterables.retainAll(list, newArrayList("b", "e", "d")));
824     assertEquals(newArrayList("b", "d"), list);
825   }
826   public void testRetainAll_iterable() {
827     final List&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
828     Iterable&lt;String&gt; iterable =
829         new Iterable&lt;String&gt;() {
830           @Override
831           public Iterator&lt;String&gt; iterator() {
832             return list.iterator();
833           }
834         };
835     assertTrue(Iterables.retainAll(iterable, newArrayList("b", "d", "f")));
836     assertEquals(newArrayList("b", "d"), list);
837     assertFalse(Iterables.retainAll(iterable, newArrayList("b", "e", "d")));
838     assertEquals(newArrayList("b", "d"), list);
839   }
840   public void testRemoveIf_randomAccess() {
841     List&lt;String&gt; list = newArrayList("a", "b", "c", "d", "e");
842     assertTrue(
843         Iterables.removeIf(
844             list,
845             new Predicate&lt;String&gt;() {
846               @Override
847               public boolean apply(String s) {
848                 return s.equals("b") || s.equals("d") || s.equals("f");
849               }
850             }));
851     assertEquals(newArrayList("a", "c", "e"), list);
852     assertFalse(
853         Iterables.removeIf(
854             list,
855             new Predicate&lt;String&gt;() {
856               @Override
857               public boolean apply(String s) {
858                 return s.equals("x") || s.equals("y") || s.equals("z");
859               }
860             }));
861     assertEquals(newArrayList("a", "c", "e"), list);
862   }
863   public void testRemoveIf_randomAccess_notPermittingDuplicates() {
864     List&lt;String&gt; uniqueList = newArrayList("a", "b", "c", "d", "e");
865     assertThat(uniqueList).containsNoDuplicates();
866     assertTrue(uniqueList instanceof RandomAccess);
867     assertTrue(
868         Iterables.removeIf(
869             uniqueList,
870             new Predicate&lt;String&gt;() {
871               @Override
872               public boolean apply(String s) {
873                 return s.equals("b") || s.equals("d") || s.equals("f");
874               }
875             }));
876     assertEquals(newArrayList("a", "c", "e"), uniqueList);
877     assertFalse(
878         Iterables.removeIf(
879             uniqueList,
880             new Predicate&lt;String&gt;() {
881               @Override
882               public boolean apply(String s) {
883                 return s.equals("x") || s.equals("y") || s.equals("z");
884               }
885             }));
886     assertEquals(newArrayList("a", "c", "e"), uniqueList);
887   }
888   public void testRemoveIf_transformedList() {
889     List&lt;String&gt; list = newArrayList("1", "2", "3", "4", "5");
890     List&lt;Integer&gt; transformed =
891         Lists.transform(
892             list,
893             new Function&lt;String, Integer&gt;() {
894               @Override
895               public Integer apply(String s) {
896                 return Integer.valueOf(s);
897               }
898             });
899     assertTrue(
900         Iterables.removeIf(
901             transformed,
902             new Predicate&lt;Integer&gt;() {
903               @Override
904               public boolean apply(Integer n) {
905                 return (n &amp; 1) == 0;               }
906             }));
907     assertEquals(newArrayList("1", "3", "5"), list);
908     assertFalse(
909         Iterables.removeIf(
910             transformed,
911             new Predicate&lt;Integer&gt;() {
912               @Override
913               public boolean apply(Integer n) {
914                 return (n &amp; 1) == 0;               }
915             }));
916     assertEquals(newArrayList("1", "3", "5"), list);
917   }
918   public void testRemoveIf_noRandomAccess() {
919     List&lt;String&gt; list = Lists.newLinkedList(asList("a", "b", "c", "d", "e"));
920     assertTrue(
921         Iterables.removeIf(
922             list,
923             new Predicate&lt;String&gt;() {
924               @Override
925               public boolean apply(String s) {
926                 return s.equals("b") || s.equals("d") || s.equals("f");
927               }
928             }));
929     assertEquals(newArrayList("a", "c", "e"), list);
930     assertFalse(
931         Iterables.removeIf(
932             list,
933             new Predicate&lt;String&gt;() {
934               @Override
935               public boolean apply(String s) {
936                 return s.equals("x") || s.equals("y") || s.equals("z");
937               }
938             }));
939     assertEquals(newArrayList("a", "c", "e"), list);
940   }
941   public void testRemoveIf_iterable() {
942     final List&lt;String&gt; list = Lists.newLinkedList(asList("a", "b", "c", "d", "e"));
943     Iterable&lt;String&gt; iterable =
944         new Iterable&lt;String&gt;() {
945           @Override
946           public Iterator&lt;String&gt; iterator() {
947             return list.iterator();
948           }
949         };
950     assertTrue(
951         Iterables.removeIf(
952             iterable,
953             new Predicate&lt;String&gt;() {
954               @Override
955               public boolean apply(String s) {
956                 return s.equals("b") || s.equals("d") || s.equals("f");
957               }
958             }));
959     assertEquals(newArrayList("a", "c", "e"), list);
960     assertFalse(
961         Iterables.removeIf(
962             iterable,
963             new Predicate&lt;String&gt;() {
964               @Override
965               public boolean apply(String s) {
966                 return s.equals("x") || s.equals("y") || s.equals("z");
967               }
968             }));
969     assertEquals(newArrayList("a", "c", "e"), list);
970   }
971   public void testIterableWithToString() {
972     assertEquals("[]", create().toString());
973     assertEquals("[a]", create("a").toString());
974     assertEquals("[a, b, c]", create("a", "b", "c").toString());
975     assertEquals("[c, a, a]", create("c", "a", "a").toString());
976   }
977   public void testIterableWithToStringNull() {
978     assertEquals("[null]", create((String) null).toString());
979     assertEquals("[null, null]", create(null, null).toString());
980     assertEquals("[, null, a]", create("", null, "a").toString());
981   }
982   private static Iterable&lt;String&gt; create(String... strings) {
983 <a name="8"></a>    final List&lt;String&gt; list = asList(strings);
984     return new FluentIterable&lt;String&gt;() {
985       @Override
986       public Iterator&lt;String&gt; iterator() <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
987         return list.iterator();
988       }
989     };
990   }
991   public void testConsu</b></font>mingIterable() {
992     List&lt;String&gt; list = Lists.newArrayList(asList("a", "b"));
993     Iterable&lt;String&gt; consumingIterable = Iterables.consumingIterable(list);
994     assertEquals("Iterables.consumingIterable(...)", consumingIterable.toString());
995     Iterator&lt;String&gt; consumingIterator = consumingIterable.iterator();
996     assertThat(list).containsExactly("a", "b").inOrder();
997     assertTrue(consumingIterator.hasNext());
998     assertThat(list).containsExactly("a", "b").inOrder();
999     assertEquals("a", consumingIterator.next());
1000     assertThat(list).contains("b");
1001     assertTrue(consumingIterator.hasNext());
1002     assertEquals("b", consumingIterator.next());
1003     assertThat(list).isEmpty();
1004     assertFalse(consumingIterator.hasNext());
1005   }
1006   @GwtIncompatible   public void testConsumingIterable_duelingIterators() {
1007     List&lt;String&gt; list = Lists.newArrayList(asList("a", "b"));
1008     Iterator&lt;String&gt; i1 = Iterables.consumingIterable(list).iterator();
1009     Iterator&lt;String&gt; i2 = Iterables.consumingIterable(list).iterator();
1010     i1.next();
1011     try {
1012       i2.next();
1013       fail("Concurrent modification should throw an exception.");
1014     } catch (ConcurrentModificationException cme) {
1015     }
1016   }
1017 <a name="7"></a>  public void testConsumingIterable_queue_iterator() {
1018     final List&lt;Integer&gt; items = ImmutableList.of(4, 8, 15, 16, 23, 42);
1019     new IteratorTester&lt;Integer&gt;(3, UNMODIFIABLE, items, IteratorTester.KnownOrder.KNOWN_ORDER) {
1020       <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
1021       protected Iterator&lt;Integer&gt; newTargetIterator() {
1022         return Iterables.consumingIterable(Lists.newLinkedList(items)).iterator();
1023       }</b></font>
1024     }.test();
1025   }
1026   public void testConsumingIterable_queue_removesFromQueue() {
1027     Queue&lt;Integer&gt; queue = Lists.newLinkedList(asList(5, 14));
1028     Iterator&lt;Integer&gt; consumingIterator = Iterables.consumingIterable(queue).iterator();
1029     assertEquals(5, queue.peek().intValue());
1030     assertEquals(5, consumingIterator.next().intValue());
1031     assertEquals(14, queue.peek().intValue());
1032     assertTrue(consumingIterator.hasNext());
1033     assertTrue(queue.isEmpty());
1034   }
1035   public void testConsumingIterable_noIteratorCall() {
1036     Queue&lt;Integer&gt; queue = new UnIterableQueue&lt;&gt;(Lists.newLinkedList(asList(5, 14)));
1037     Iterator&lt;Integer&gt; consumingIterator = Iterables.consumingIterable(queue).iterator();
1038     assertEquals(5, consumingIterator.next().intValue());
1039   }
1040   private static class UnIterableQueue&lt;T&gt; extends ForwardingQueue&lt;T&gt; {
1041     private final Queue&lt;T&gt; queue;
1042 <a name="1"></a>
1043     UnIterableQueue(Queue&lt;T&gt; queue) {
1044       this.queue = queue;
1045     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
1046     @Override
1047     public Iterator&lt;T&gt; iterator() {
1048       throw new UnsupportedOperationException();
1049     }
1050     @Override
1051     protected Queue&lt;T&gt; delegate() {
1052       return</b></font> queue;
1053     }
1054   }
1055   public void testIndexOf_empty() {
1056     List&lt;String&gt; list = new ArrayList&lt;&gt;();
1057     assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("")));
1058   }
1059   public void testIndexOf_oneElement() {
1060     List&lt;String&gt; list = Lists.newArrayList("bob");
1061     assertEquals(0, Iterables.indexOf(list, Predicates.equalTo("bob")));
1062     assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("jack")));
1063   }
1064   public void testIndexOf_twoElements() {
1065     List&lt;String&gt; list = Lists.newArrayList("mary", "bob");
1066     assertEquals(0, Iterables.indexOf(list, Predicates.equalTo("mary")));
1067     assertEquals(1, Iterables.indexOf(list, Predicates.equalTo("bob")));
1068     assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("jack")));
1069   }
1070   public void testIndexOf_withDuplicates() {
1071     List&lt;String&gt; list = Lists.newArrayList("mary", "bob", "bob", "bob", "sam");
1072     assertEquals(0, Iterables.indexOf(list, Predicates.equalTo("mary")));
1073     assertEquals(1, Iterables.indexOf(list, Predicates.equalTo("bob")));
1074     assertEquals(4, Iterables.indexOf(list, Predicates.equalTo("sam")));
1075     assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("jack")));
1076   }
1077   private static final Predicate&lt;CharSequence&gt; STARTSWITH_A =
1078       new Predicate&lt;CharSequence&gt;() {
1079         @Override
1080         public boolean apply(CharSequence input) {
1081           return (input.length() &gt; 0) &amp;&amp; (input.charAt(0) == 'a');
1082         }
1083       };
1084   public void testIndexOf_genericPredicate() {
1085     List&lt;CharSequence&gt; sequences = Lists.newArrayList();
1086     sequences.add("bob");
1087     sequences.add(new StringBuilder("charlie"));
1088     sequences.add(new StringBuffer("henry"));
1089     sequences.add(new StringBuilder("apple"));
1090     sequences.add("lemon");
1091     assertEquals(3, Iterables.indexOf(sequences, STARTSWITH_A));
1092   }
1093   public void testIndexOf_genericPredicate2() {
1094     List&lt;String&gt; sequences = Lists.newArrayList("bob", "charlie", "henry", "apple", "lemon");
1095     assertEquals(3, Iterables.indexOf(sequences, STARTSWITH_A));
1096   }
1097   public void testMergeSorted_empty() {
1098     Iterable&lt;Iterable&lt;Integer&gt;&gt; elements = ImmutableList.of();
1099     Iterable&lt;Integer&gt; iterable = Iterables.mergeSorted(elements, Ordering.natural());
1100     Iterator&lt;Integer&gt; iterator = iterable.iterator();
1101     assertFalse(iterator.hasNext());
1102     try {
1103       iterator.next();
1104       fail("next() on empty iterator should throw NoSuchElementException");
1105     } catch (NoSuchElementException e) {
1106     }
1107   }
1108   public void testMergeSorted_single_empty() {
1109     Iterable&lt;Integer&gt; iterable0 = ImmutableList.of();
1110     Iterable&lt;Iterable&lt;Integer&gt;&gt; iterables = ImmutableList.of(iterable0);
1111     verifyMergeSorted(iterables, ImmutableList.&lt;Integer&gt;of());
1112   }
1113   public void testMergeSorted_single() {
1114     Iterable&lt;Integer&gt; iterable0 = ImmutableList.of(1, 2, 3);
1115     Iterable&lt;Iterable&lt;Integer&gt;&gt; iterables = ImmutableList.of(iterable0);
1116     verifyMergeSorted(iterables, iterable0);
1117   }
1118   public void testMergeSorted_pyramid() {
1119     List&lt;Iterable&lt;Integer&gt;&gt; iterables = Lists.newLinkedList();
1120 <a name="3"></a>    List&lt;Integer&gt; allIntegers = Lists.newArrayList();
1121     for (int i = 0; i &lt; 10; i++) <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
1122       List&lt;Integer&gt; list = Lists.newLinkedList();
1123       for (int j = 0; j &lt; i; j++) {
1124         list.add(j);
1125         allIntegers.add(j);
1126       }</b></font>
1127       iterables.add(Ordering.natural().sortedCopy(list));
1128     }
1129     verifyMergeSorted(iterables, allIntegers);
1130   }
1131   public void testMergeSorted_skipping_pyramid() {
1132     List&lt;Iterable&lt;Integer&gt;&gt; iterables = Lists.newLinkedList();
1133     List&lt;Integer&gt; allIntegers = Lists.newArrayList();
1134     for (int i = 0; i &lt; 20; i++) {
1135       List&lt;Integer&gt; list = Lists.newLinkedList();
1136       for (int j = 0; j &lt; i; j++) {
1137         list.add(j * i);
1138         allIntegers.add(j * i);
1139       }
1140       iterables.add(Ordering.natural().sortedCopy(list));
1141     }
1142     verifyMergeSorted(iterables, allIntegers);
1143   }
1144   @GwtIncompatible   public void testIterables_nullCheck() throws Exception {
1145     new ClassSanityTester()
1146         .forAllPublicStaticMethods(Iterables.class)
1147         .thatReturn(Iterable.class)
1148         .testNulls();
1149   }
1150   private static void verifyMergeSorted(
1151       Iterable&lt;Iterable&lt;Integer&gt;&gt; iterables, Iterable&lt;Integer&gt; unsortedExpected) {
1152     Iterable&lt;Integer&gt; expected = Ordering.natural().sortedCopy(unsortedExpected);
1153     Iterable&lt;Integer&gt; mergedIterator = Iterables.mergeSorted(iterables, Ordering.natural());
1154     assertEquals(Lists.newLinkedList(expected), Lists.newLinkedList(mergedIterator));
1155   }
1156 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Multimaps_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkNotNull;
3 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
4 import static com.google.common.collect.CollectPreconditions.checkRemove;
5 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
6 import static java.util.Objects.requireNonNull;
7 import com.google.common.annotations.Beta;
8 import com.google.common.annotations.GwtCompatible;
9 import com.google.common.annotations.GwtIncompatible;
10 <a name="0"></a>import com.google.common.base.Function;
11 import com.google.common.base.Predicate;
12 import com.google.common.base.Predicates;
13 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.base.Supplier;
14 import com.google.common.collect.Maps.EntryTransformer;
15 import com.google.errorprone.annotations.CanIgnoreReturnValue;
16 import com.google.errorprone.annotations.concurrent.LazyInit;
17 import com.google.j2objc.annotations.Weak;
18 import com.google.j2objc.annotations.WeakOuter;
19 import java.io.IOException;
20 import java.io.ObjectInputStream;
21 import java.io.ObjectOutputStream;
22 import java.io.Serializable;
23 import java.util.AbstractCollection;
24 import java.util.Collection;
25 import java.util.Collections;
26 import java.util.Comparator;
27 import java.util.HashSet;
28 import java.util.Iterator;
29 import java.util.List;
30 import java.util.Map;
31 import java.util.Map.Entry;
32 import java.util.NavigableSet;
33 import java.util.NoSuchElementException;
34 import java.util.Set;
35 import java.util.SortedSet;
36 import java.util.Spliterator;
37 import java.util.function.BiConsumer;
38 import java.util.function.Consumer;
39 import java.util.stream.Collector;
40 import java.util.stream.Stream;
41 import javax.annotation.CheckForNull;
42 import org.checkerframework.checker.nullness.qual.Nullable;
43 @GwtCompatible(e</b></font>mulated = true)
44 @ElementTypesAreNonnullByDefault
45 public final class Multimaps {
46   private Multimaps() {}
47   public static &lt;
48           T extends @Nullable Object,
49           K extends @Nullable Object,
50           V extends @Nullable Object,
51           M extends Multimap&lt;K, V&gt;&gt;
52       Collector&lt;T, ?, M&gt; toMultimap(
53           java.util.function.Function&lt;? super T, ? extends K&gt; keyFunction,
54           java.util.function.Function&lt;? super T, ? extends V&gt; valueFunction,
55           java.util.function.Supplier&lt;M&gt; multimapSupplier) {
56     return CollectCollectors.toMultimap(keyFunction, valueFunction, multimapSupplier);
57   }
58   @Beta
59   public static &lt;
60           T extends @Nullable Object,
61           K extends @Nullable Object,
62           V extends @Nullable Object,
63           M extends Multimap&lt;K, V&gt;&gt;
64       Collector&lt;T, ?, M&gt; flatteningToMultimap(
65           java.util.function.Function&lt;? super T, ? extends K&gt; keyFunction,
66           java.util.function.Function&lt;? super T, ? extends Stream&lt;? extends V&gt;&gt; valueFunction,
67           java.util.function.Supplier&lt;M&gt; multimapSupplier) {
68     return CollectCollectors.flatteningToMultimap(keyFunction, valueFunction, multimapSupplier);
69   }
70   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Multimap&lt;K, V&gt; newMultimap(
71       Map&lt;K, Collection&lt;V&gt;&gt; map, final Supplier&lt;? extends Collection&lt;V&gt;&gt; factory) {
72     return new CustomMultimap&lt;&gt;(map, factory);
73   }
74   private static class CustomMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
75       extends AbstractMapBasedMultimap&lt;K, V&gt; {
76     transient Supplier&lt;? extends Collection&lt;V&gt;&gt; factory;
77     CustomMultimap(Map&lt;K, Collection&lt;V&gt;&gt; map, Supplier&lt;? extends Collection&lt;V&gt;&gt; factory) {
78       super(map);
79       this.factory = checkNotNull(factory);
80     }
81     @Override
82     Set&lt;K&gt; createKeySet() {
83       return createMaybeNavigableKeySet();
84     }
85     @Override
86     Map&lt;K, Collection&lt;V&gt;&gt; createAsMap() {
87       return createMaybeNavigableAsMap();
88     }
89     @Override
90     protected Collection&lt;V&gt; createCollection() {
91       return factory.get();
92     }
93     @Override
94     &lt;E extends @Nullable Object&gt; Collection&lt;E&gt; unmodifiableCollectionSubclass(
95         Collection&lt;E&gt; collection) {
96       if (collection instanceof NavigableSet) {
97         return Sets.unmodifiableNavigableSet((NavigableSet&lt;E&gt;) collection);
98       } else if (collection instanceof SortedSet) {
99         return Collections.unmodifiableSortedSet((SortedSet&lt;E&gt;) collection);
100       } else if (collection instanceof Set) {
101         return Collections.unmodifiableSet((Set&lt;E&gt;) collection);
102       } else if (collection instanceof List) {
103         return Collections.unmodifiableList((List&lt;E&gt;) collection);
104       } else {
105         return Collections.unmodifiableCollection(collection);
106       }
107     }
108     @Override
109     Collection&lt;V&gt; wrapCollection(@ParametricNullness K key, Collection&lt;V&gt; collection) {
110       if (collection instanceof List) {
111         return wrapList(key, (List&lt;V&gt;) collection, null);
112       } else if (collection instanceof NavigableSet) {
113         return new WrappedNavigableSet(key, (NavigableSet&lt;V&gt;) collection, null);
114       } else if (collection instanceof SortedSet) {
115         return new WrappedSortedSet(key, (SortedSet&lt;V&gt;) collection, null);
116       } else if (collection instanceof Set) {
117         return new WrappedSet(key, (Set&lt;V&gt;) collection);
118       } else {
119         return new WrappedCollection(key, collection, null);
120       }
121     }
122     @GwtIncompatible     private void writeObject(ObjectOutputStream stream) throws IOException {
123       stream.defaultWriteObject();
124       stream.writeObject(factory);
125       stream.writeObject(backingMap());
126     }
127     @GwtIncompatible     @SuppressWarnings("unchecked")     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
128       stream.defaultReadObject();
129       factory = (Supplier&lt;? extends Collection&lt;V&gt;&gt;) stream.readObject();
130       Map&lt;K, Collection&lt;V&gt;&gt; map = (Map&lt;K, Collection&lt;V&gt;&gt;) stream.readObject();
131       setMap(map);
132     }
133     @GwtIncompatible     private static final long serialVersionUID = 0;
134   }
135   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
136       ListMultimap&lt;K, V&gt; newListMultimap(
137           Map&lt;K, Collection&lt;V&gt;&gt; map, final Supplier&lt;? extends List&lt;V&gt;&gt; factory) {
138     return new CustomListMultimap&lt;&gt;(map, factory);
139   }
140   private static class CustomListMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
141       extends AbstractListMultimap&lt;K, V&gt; {
142     transient Supplier&lt;? extends List&lt;V&gt;&gt; factory;
143     CustomListMultimap(Map&lt;K, Collection&lt;V&gt;&gt; map, Supplier&lt;? extends List&lt;V&gt;&gt; factory) {
144       super(map);
145       this.factory = checkNotNull(factory);
146     }
147     @Override
148     Set&lt;K&gt; createKeySet() {
149       return createMaybeNavigableKeySet();
150     }
151     @Override
152     Map&lt;K, Collection&lt;V&gt;&gt; createAsMap() {
153       return createMaybeNavigableAsMap();
154     }
155     @Override
156     protected List&lt;V&gt; createCollection() {
157       return factory.get();
158     }
159     @GwtIncompatible     private void writeObject(ObjectOutputStream stream) throws IOException {
160       stream.defaultWriteObject();
161       stream.writeObject(factory);
162       stream.writeObject(backingMap());
163     }
164     @GwtIncompatible     @SuppressWarnings("unchecked")     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
165       stream.defaultReadObject();
166       factory = (Supplier&lt;? extends List&lt;V&gt;&gt;) stream.readObject();
167       Map&lt;K, Collection&lt;V&gt;&gt; map = (Map&lt;K, Collection&lt;V&gt;&gt;) stream.readObject();
168       setMap(map);
169     }
170     @GwtIncompatible     private static final long serialVersionUID = 0;
171   }
172   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
173       SetMultimap&lt;K, V&gt; newSetMultimap(
174           Map&lt;K, Collection&lt;V&gt;&gt; map, final Supplier&lt;? extends Set&lt;V&gt;&gt; factory) {
175     return new CustomSetMultimap&lt;&gt;(map, factory);
176   }
177   private static class CustomSetMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
178       extends AbstractSetMultimap&lt;K, V&gt; {
179     transient Supplier&lt;? extends Set&lt;V&gt;&gt; factory;
180     CustomSetMultimap(Map&lt;K, Collection&lt;V&gt;&gt; map, Supplier&lt;? extends Set&lt;V&gt;&gt; factory) {
181       super(map);
182       this.factory = checkNotNull(factory);
183     }
184     @Override
185     Set&lt;K&gt; createKeySet() {
186       return createMaybeNavigableKeySet();
187     }
188     @Override
189     Map&lt;K, Collection&lt;V&gt;&gt; createAsMap() {
190       return createMaybeNavigableAsMap();
191     }
192     @Override
193     protected Set&lt;V&gt; createCollection() {
194       return factory.get();
195     }
196     @Override
197     &lt;E extends @Nullable Object&gt; Collection&lt;E&gt; unmodifiableCollectionSubclass(
198         Collection&lt;E&gt; collection) {
199       if (collection instanceof NavigableSet) {
200         return Sets.unmodifiableNavigableSet((NavigableSet&lt;E&gt;) collection);
201       } else if (collection instanceof SortedSet) {
202         return Collections.unmodifiableSortedSet((SortedSet&lt;E&gt;) collection);
203       } else {
204         return Collections.unmodifiableSet((Set&lt;E&gt;) collection);
205       }
206     }
207     @Override
208     Collection&lt;V&gt; wrapCollection(@ParametricNullness K key, Collection&lt;V&gt; collection) {
209       if (collection instanceof NavigableSet) {
210         return new WrappedNavigableSet(key, (NavigableSet&lt;V&gt;) collection, null);
211       } else if (collection instanceof SortedSet) {
212         return new WrappedSortedSet(key, (SortedSet&lt;V&gt;) collection, null);
213       } else {
214         return new WrappedSet(key, (Set&lt;V&gt;) collection);
215       }
216     }
217     @GwtIncompatible     private void writeObject(ObjectOutputStream stream) throws IOException {
218       stream.defaultWriteObject();
219       stream.writeObject(factory);
220       stream.writeObject(backingMap());
221     }
222     @GwtIncompatible     @SuppressWarnings("unchecked")     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
223       stream.defaultReadObject();
224       factory = (Supplier&lt;? extends Set&lt;V&gt;&gt;) stream.readObject();
225       Map&lt;K, Collection&lt;V&gt;&gt; map = (Map&lt;K, Collection&lt;V&gt;&gt;) stream.readObject();
226       setMap(map);
227     }
228     @GwtIncompatible     private static final long serialVersionUID = 0;
229   }
230   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
231       SortedSetMultimap&lt;K, V&gt; newSortedSetMultimap(
232           Map&lt;K, Collection&lt;V&gt;&gt; map, final Supplier&lt;? extends SortedSet&lt;V&gt;&gt; factory) {
233     return new CustomSortedSetMultimap&lt;&gt;(map, factory);
234   }
235   private static class CustomSortedSetMultimap&lt;
236           K extends @Nullable Object, V extends @Nullable Object&gt;
237       extends AbstractSortedSetMultimap&lt;K, V&gt; {
238     transient Supplier&lt;? extends SortedSet&lt;V&gt;&gt; factory;
239     @CheckForNull transient Comparator&lt;? super V&gt; valueComparator;
240     CustomSortedSetMultimap(Map&lt;K, Collection&lt;V&gt;&gt; map, Supplier&lt;? extends SortedSet&lt;V&gt;&gt; factory) {
241       super(map);
242       this.factory = checkNotNull(factory);
243       valueComparator = factory.get().comparator();
244     }
245     @Override
246     Set&lt;K&gt; createKeySet() {
247       return createMaybeNavigableKeySet();
248     }
249     @Override
250     Map&lt;K, Collection&lt;V&gt;&gt; createAsMap() {
251       return createMaybeNavigableAsMap();
252     }
253     @Override
254     protected SortedSet&lt;V&gt; createCollection() {
255       return factory.get();
256     }
257     @Override
258     @CheckForNull
259     public Comparator&lt;? super V&gt; valueComparator() {
260       return valueComparator;
261     }
262     @GwtIncompatible     private void writeObject(ObjectOutputStream stream) throws IOException {
263       stream.defaultWriteObject();
264       stream.writeObject(factory);
265       stream.writeObject(backingMap());
266     }
267     @GwtIncompatible     @SuppressWarnings("unchecked")     private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
268       stream.defaultReadObject();
269       factory = (Supplier&lt;? extends SortedSet&lt;V&gt;&gt;) stream.readObject();
270       valueComparator = factory.get().comparator();
271       Map&lt;K, Collection&lt;V&gt;&gt; map = (Map&lt;K, Collection&lt;V&gt;&gt;) stream.readObject();
272       setMap(map);
273     }
274     @GwtIncompatible     private static final long serialVersionUID = 0;
275   }
276   @CanIgnoreReturnValue
277   public static &lt;K extends @Nullable Object, V extends @Nullable Object, M extends Multimap&lt;K, V&gt;&gt;
278       M invertFrom(Multimap&lt;? extends V, ? extends K&gt; source, M dest) {
279     checkNotNull(dest);
280     for (Map.Entry&lt;? extends V, ? extends K&gt; entry : source.entries()) {
281       dest.put(entry.getValue(), entry.getKey());
282     }
283     return dest;
284   }
285   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
286       Multimap&lt;K, V&gt; synchronizedMultimap(Multimap&lt;K, V&gt; multimap) {
287     return Synchronized.multimap(multimap, null);
288   }
289   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
290       Multimap&lt;K, V&gt; unmodifiableMultimap(Multimap&lt;K, V&gt; delegate) {
291     if (delegate instanceof UnmodifiableMultimap || delegate instanceof ImmutableMultimap) {
292       return delegate;
293     }
294     return new UnmodifiableMultimap&lt;&gt;(delegate);
295   }
296   @Deprecated
297   public static &lt;K, V&gt; Multimap&lt;K, V&gt; unmodifiableMultimap(ImmutableMultimap&lt;K, V&gt; delegate) {
298     return checkNotNull(delegate);
299   }
300   private static class UnmodifiableMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
301       extends ForwardingMultimap&lt;K, V&gt; implements Serializable {
302     final Multimap&lt;K, V&gt; delegate;
303     @LazyInit @CheckForNull transient Collection&lt;Entry&lt;K, V&gt;&gt; entries;
304     @LazyInit @CheckForNull transient Multiset&lt;K&gt; keys;
305     @LazyInit @CheckForNull transient Set&lt;K&gt; keySet;
306     @LazyInit @CheckForNull transient Collection&lt;V&gt; values;
307     @LazyInit @CheckForNull transient Map&lt;K, Collection&lt;V&gt;&gt; map;
308     UnmodifiableMultimap(final Multimap&lt;K, V&gt; delegate) {
309       this.delegate = checkNotNull(delegate);
310     }
311     @Override
312     protected Multimap&lt;K, V&gt; delegate() {
313       return delegate;
314     }
315     @Override
316     public void clear() {
317       throw new UnsupportedOperationException();
318     }
319     @Override
320     public Map&lt;K, Collection&lt;V&gt;&gt; asMap() {
321       Map&lt;K, Collection&lt;V&gt;&gt; result = map;
322       if (result == null) {
323         result =
324 <a name="2"></a>            map =
325                 Collections.unmodifiableMap(
326                     Maps.transformValues(
327                         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>delegate.asMap(),
328                         new Function&lt;Collection&lt;V&gt;, Collection&lt;V&gt;&gt;() {
329                           @Override
330                           public Collection&lt;V&gt; apply(Collection&lt;V&gt; collection) {
331                             return unmodifiableValueCollection(collection);
332                           }
333                         }</b></font>));
334       }
335       return result;
336     }
337     @Override
338     public Collection&lt;Entry&lt;K, V&gt;&gt; entries() {
339       Collection&lt;Entry&lt;K, V&gt;&gt; result = entries;
340       if (result == null) {
341         entries = result = unmodifiableEntries(delegate.entries());
342       }
343       return result;
344     }
345     @Override
346     public void forEach(BiConsumer&lt;? super K, ? super V&gt; consumer) {
347       delegate.forEach(checkNotNull(consumer));
348     }
349     @Override
350     public Collection&lt;V&gt; get(@ParametricNullness K key) {
351       return unmodifiableValueCollection(delegate.get(key));
352     }
353     @Override
354     public Multiset&lt;K&gt; keys() {
355       Multiset&lt;K&gt; result = keys;
356       if (result == null) {
357         keys = result = Multisets.unmodifiableMultiset(delegate.keys());
358       }
359       return result;
360     }
361     @Override
362     public Set&lt;K&gt; keySet() {
363       Set&lt;K&gt; result = keySet;
364       if (result == null) {
365         keySet = result = Collections.unmodifiableSet(delegate.keySet());
366       }
367       return result;
368     }
369     @Override
370     public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
371       throw new UnsupportedOperationException();
372     }
373     @Override
374     public boolean putAll(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
375       throw new UnsupportedOperationException();
376     }
377     @Override
378     public boolean putAll(Multimap&lt;? extends K, ? extends V&gt; multimap) {
379       throw new UnsupportedOperationException();
380     }
381     @Override
382     public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
383       throw new UnsupportedOperationException();
384     }
385     @Override
386     public Collection&lt;V&gt; removeAll(@CheckForNull Object key) {
387       throw new UnsupportedOperationException();
388     }
389     @Override
390     public Collection&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
391       throw new UnsupportedOperationException();
392     }
393     @Override
394     public Collection&lt;V&gt; values() {
395       Collection&lt;V&gt; result = values;
396       if (result == null) {
397         values = result = Collections.unmodifiableCollection(delegate.values());
398       }
399       return result;
400     }
401     private static final long serialVersionUID = 0;
402   }
403   private static class UnmodifiableListMultimap&lt;
404           K extends @Nullable Object, V extends @Nullable Object&gt;
405       extends UnmodifiableMultimap&lt;K, V&gt; implements ListMultimap&lt;K, V&gt; {
406     UnmodifiableListMultimap(ListMultimap&lt;K, V&gt; delegate) {
407       super(delegate);
408     }
409     @Override
410     public ListMultimap&lt;K, V&gt; delegate() {
411       return (ListMultimap&lt;K, V&gt;) super.delegate();
412     }
413     @Override
414     public List&lt;V&gt; get(@ParametricNullness K key) {
415       return Collections.unmodifiableList(delegate().get(key));
416     }
417     @Override
418     public List&lt;V&gt; removeAll(@CheckForNull Object key) {
419       throw new UnsupportedOperationException();
420     }
421     @Override
422     public List&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
423       throw new UnsupportedOperationException();
424     }
425     private static final long serialVersionUID = 0;
426   }
427   private static class UnmodifiableSetMultimap&lt;
428           K extends @Nullable Object, V extends @Nullable Object&gt;
429       extends UnmodifiableMultimap&lt;K, V&gt; implements SetMultimap&lt;K, V&gt; {
430     UnmodifiableSetMultimap(SetMultimap&lt;K, V&gt; delegate) {
431       super(delegate);
432     }
433     @Override
434     public SetMultimap&lt;K, V&gt; delegate() {
435       return (SetMultimap&lt;K, V&gt;) super.delegate();
436     }
437     @Override
438     public Set&lt;V&gt; get(@ParametricNullness K key) {
439 <a name="7"></a>      return Collections.unmodifiableSet(delegate().get(key));
440     }
441     <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
442     public Set&lt;Map.Entry&lt;K, V&gt;&gt; entries() {
443       return Maps.unmodifiableEntrySet(delegate().entries());
444     }</b></font>
445     @Override
446     public Set&lt;V&gt; removeAll(@CheckForNull Object key) {
447       throw new UnsupportedOperationException();
448     }
449     @Override
450     public Set&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
451       throw new UnsupportedOperationException();
452     }
453     private static final long serialVersionUID = 0;
454   }
455   private static class UnmodifiableSortedSetMultimap&lt;
456           K extends @Nullable Object, V extends @Nullable Object&gt;
457       extends UnmodifiableSetMultimap&lt;K, V&gt; implements SortedSetMultimap&lt;K, V&gt; {
458     UnmodifiableSortedSetMultimap(SortedSetMultimap&lt;K, V&gt; delegate) {
459       super(delegate);
460     }
461     @Override
462     public SortedSetMultimap&lt;K, V&gt; delegate() {
463       return (SortedSetMultimap&lt;K, V&gt;) super.delegate();
464     }
465     @Override
466     public SortedSet&lt;V&gt; get(@ParametricNullness K key) {
467       return Collections.unmodifiableSortedSet(delegate().get(key));
468     }
469     @Override
470     public SortedSet&lt;V&gt; removeAll(@CheckForNull Object key) {
471       throw new UnsupportedOperationException();
472     }
473     @Override
474     public SortedSet&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
475       throw new UnsupportedOperationException();
476     }
477     @Override
478     @CheckForNull
479     public Comparator&lt;? super V&gt; valueComparator() {
480       return delegate().valueComparator();
481     }
482     private static final long serialVersionUID = 0;
483   }
484   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
485       SetMultimap&lt;K, V&gt; synchronizedSetMultimap(SetMultimap&lt;K, V&gt; multimap) {
486     return Synchronized.setMultimap(multimap, null);
487   }
488   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
489       SetMultimap&lt;K, V&gt; unmodifiableSetMultimap(SetMultimap&lt;K, V&gt; delegate) {
490     if (delegate instanceof UnmodifiableSetMultimap || delegate instanceof ImmutableSetMultimap) {
491       return delegate;
492     }
493     return new UnmodifiableSetMultimap&lt;&gt;(delegate);
494   }
495   @Deprecated
496   public static &lt;K, V&gt; SetMultimap&lt;K, V&gt; unmodifiableSetMultimap(
497       ImmutableSetMultimap&lt;K, V&gt; delegate) {
498     return checkNotNull(delegate);
499   }
500   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
501       SortedSetMultimap&lt;K, V&gt; synchronizedSortedSetMultimap(SortedSetMultimap&lt;K, V&gt; multimap) {
502     return Synchronized.sortedSetMultimap(multimap, null);
503   }
504   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
505       SortedSetMultimap&lt;K, V&gt; unmodifiableSortedSetMultimap(SortedSetMultimap&lt;K, V&gt; delegate) {
506     if (delegate instanceof UnmodifiableSortedSetMultimap) {
507       return delegate;
508     }
509     return new UnmodifiableSortedSetMultimap&lt;&gt;(delegate);
510   }
511   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
512       ListMultimap&lt;K, V&gt; synchronizedListMultimap(ListMultimap&lt;K, V&gt; multimap) {
513     return Synchronized.listMultimap(multimap, null);
514   }
515   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
516       ListMultimap&lt;K, V&gt; unmodifiableListMultimap(ListMultimap&lt;K, V&gt; delegate) {
517     if (delegate instanceof UnmodifiableListMultimap || delegate instanceof ImmutableListMultimap) {
518       return delegate;
519     }
520     return new UnmodifiableListMultimap&lt;&gt;(delegate);
521   }
522   @Deprecated
523   public static &lt;K, V&gt; ListMultimap&lt;K, V&gt; unmodifiableListMultimap(
524       ImmutableListMultimap&lt;K, V&gt; delegate) {
525     return checkNotNull(delegate);
526   }
527   private static &lt;V extends @Nullable Object&gt; Collection&lt;V&gt; unmodifiableValueCollection(
528       Collection&lt;V&gt; collection) {
529     if (collection instanceof SortedSet) {
530       return Collections.unmodifiableSortedSet((SortedSet&lt;V&gt;) collection);
531     } else if (collection instanceof Set) {
532       return Collections.unmodifiableSet((Set&lt;V&gt;) collection);
533     } else if (collection instanceof List) {
534       return Collections.unmodifiableList((List&lt;V&gt;) collection);
535     }
536     return Collections.unmodifiableCollection(collection);
537   }
538   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
539       Collection&lt;Entry&lt;K, V&gt;&gt; unmodifiableEntries(Collection&lt;Entry&lt;K, V&gt;&gt; entries) {
540     if (entries instanceof Set) {
541       return Maps.unmodifiableEntrySet((Set&lt;Entry&lt;K, V&gt;&gt;) entries);
542     }
543     return new Maps.UnmodifiableEntries&lt;&gt;(Collections.unmodifiableCollection(entries));
544   }
545   @Beta
546   @SuppressWarnings("unchecked")
547   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, List&lt;V&gt;&gt; asMap(
548       ListMultimap&lt;K, V&gt; multimap) {
549     return (Map&lt;K, List&lt;V&gt;&gt;) (Map&lt;K, ?&gt;) multimap.asMap();
550   }
551   @Beta
552   @SuppressWarnings("unchecked")
553   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, Set&lt;V&gt;&gt; asMap(
554       SetMultimap&lt;K, V&gt; multimap) {
555     return (Map&lt;K, Set&lt;V&gt;&gt;) (Map&lt;K, ?&gt;) multimap.asMap();
556   }
557   @Beta
558   @SuppressWarnings("unchecked")
559   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, SortedSet&lt;V&gt;&gt; asMap(
560       SortedSetMultimap&lt;K, V&gt; multimap) {
561     return (Map&lt;K, SortedSet&lt;V&gt;&gt;) (Map&lt;K, ?&gt;) multimap.asMap();
562   }
563   @Beta
564   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
565       Map&lt;K, Collection&lt;V&gt;&gt; asMap(Multimap&lt;K, V&gt; multimap) {
566     return multimap.asMap();
567   }
568   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; SetMultimap&lt;K, V&gt; forMap(
569       Map&lt;K, V&gt; map) {
570     return new MapMultimap&lt;&gt;(map);
571   }
572   private static class MapMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
573       extends AbstractMultimap&lt;K, V&gt; implements SetMultimap&lt;K, V&gt;, Serializable {
574     final Map&lt;K, V&gt; map;
575     MapMultimap(Map&lt;K, V&gt; map) {
576       this.map = checkNotNull(map);
577     }
578     @Override
579     public int size() {
580       return map.size();
581     }
582     @Override
583     public boolean containsKey(@CheckForNull Object key) {
584       return map.containsKey(key);
585     }
586     @Override
587     public boolean containsValue(@CheckForNull Object value) {
588       return map.containsValue(value);
589     }
590     @Override
591     public boolean containsEntry(@CheckForNull Object key, @CheckForNull Object value) {
592       return map.entrySet().contains(Maps.immutableEntry(key, value));
593     }
594     @Override
595     public Set&lt;V&gt; get(@ParametricNullness final K key) {
596       return new Sets.ImprovedAbstractSet&lt;V&gt;() {
597         @Override
598         public Iterator&lt;V&gt; iterator() {
599           return new Iterator&lt;V&gt;() {
600             int i;
601             @Override
602             public boolean hasNext() {
603               return (i == 0) &amp;&amp; map.containsKey(key);
604             }
605             @Override
606             @ParametricNullness
607             public V next() {
608               if (!hasNext()) {
609                 throw new NoSuchElementException();
610               }
611               i++;
612               return uncheckedCastNullableTToT(map.get(key));
613             }
614             @Override
615             public void remove() {
616               checkRemove(i == 1);
617               i = -1;
618               map.remove(key);
619             }
620           };
621         }
622         @Override
623         public int size() {
624           return map.containsKey(key) ? 1 : 0;
625         }
626       };
627     }
628     @Override
629     public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
630       throw new UnsupportedOperationException();
631     }
632     @Override
633     public boolean putAll(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
634       throw new UnsupportedOperationException();
635     }
636     @Override
637     public boolean putAll(Multimap&lt;? extends K, ? extends V&gt; multimap) {
638       throw new UnsupportedOperationException();
639     }
640     @Override
641     public Set&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
642       throw new UnsupportedOperationException();
643     }
644     @Override
645     public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
646       return map.entrySet().remove(Maps.immutableEntry(key, value));
647     }
648     @Override
649     public Set&lt;V&gt; removeAll(@CheckForNull Object key) {
650       Set&lt;V&gt; values = new HashSet&lt;V&gt;(2);
651       if (!map.containsKey(key)) {
652         return values;
653       }
654       values.add(map.remove(key));
655       return values;
656     }
657     @Override
658     public void clear() {
659       map.clear();
660     }
661     @Override
662     Set&lt;K&gt; createKeySet() {
663       return map.keySet();
664     }
665     @Override
666     Collection&lt;V&gt; createValues() {
667       return map.values();
668     }
669 <a name="1"></a>    @Override
670     public Set&lt;Entry&lt;K, V&gt;&gt; entries() {
671       return map.entrySet();
672     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
673     @Override
674     Collection&lt;Entry&lt;K, V&gt;&gt; createEntries() {
675       throw new AssertionError("unreachable");
676     }
677     @Override
678     Multiset&lt;K&gt; createKeys() {
679       return</b></font> new Multimaps.Keys&lt;K, V&gt;(this);
680     }
681     @Override
682     Iterator&lt;Entry&lt;K, V&gt;&gt; entryIterator() {
683       return map.entrySet().iterator();
684     }
685     @Override
686     Map&lt;K, Collection&lt;V&gt;&gt; createAsMap() {
687       return new AsMap&lt;&gt;(this);
688     }
689     @Override
690     public int hashCode() {
691       return map.hashCode();
692     }
693     private static final long serialVersionUID = 7845222491160860175L;
694   }
695   public static &lt;
696           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
697       Multimap&lt;K, V2&gt; transformValues(
698           Multimap&lt;K, V1&gt; fromMultimap, final Function&lt;? super V1, V2&gt; function) {
699     checkNotNull(function);
700     EntryTransformer&lt;K, V1, V2&gt; transformer = Maps.asEntryTransformer(function);
701     return transformEntries(fromMultimap, transformer);
702   }
703   public static &lt;
704           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
705       ListMultimap&lt;K, V2&gt; transformValues(
706           ListMultimap&lt;K, V1&gt; fromMultimap, final Function&lt;? super V1, V2&gt; function) {
707     checkNotNull(function);
708     EntryTransformer&lt;K, V1, V2&gt; transformer = Maps.asEntryTransformer(function);
709     return transformEntries(fromMultimap, transformer);
710   }
711   public static &lt;
712           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
713       Multimap&lt;K, V2&gt; transformEntries(
714           Multimap&lt;K, V1&gt; fromMap, EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
715     return new TransformedEntriesMultimap&lt;&gt;(fromMap, transformer);
716   }
717   public static &lt;
718           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
719       ListMultimap&lt;K, V2&gt; transformEntries(
720           ListMultimap&lt;K, V1&gt; fromMap, EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
721     return new TransformedEntriesListMultimap&lt;&gt;(fromMap, transformer);
722   }
723   private static class TransformedEntriesMultimap&lt;
724           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
725       extends AbstractMultimap&lt;K, V2&gt; {
726     final Multimap&lt;K, V1&gt; fromMultimap;
727     final EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer;
728     TransformedEntriesMultimap(
729         Multimap&lt;K, V1&gt; fromMultimap,
730         final EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
731       this.fromMultimap = checkNotNull(fromMultimap);
732       this.transformer = checkNotNull(transformer);
733     }
734     Collection&lt;V2&gt; transform(@ParametricNullness K key, Collection&lt;V1&gt; values) {
735       Function&lt;? super V1, V2&gt; function = Maps.asValueToValueFunction(transformer, key);
736       if (values instanceof List) {
737         return Lists.transform((List&lt;V1&gt;) values, function);
738       } else {
739         return Collections2.transform(values, function);
740       }
741     }
742     @Override
743     Map&lt;K, Collection&lt;V2&gt;&gt; createAsMap() {
744       return Maps.transformEntries(
745 <a name="8"></a>          fromMultimap.asMap(),
746           new EntryTransformer&lt;K, Collection&lt;V1&gt;, Collection&lt;V2&gt;&gt;() {
747             @Override
748             public Collection&lt;V2&gt; transformEntry(@ParametricNullness K key, Collection&lt;V1&gt; value) <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
749               return transform(key, value);
750             }
751           });
752     }
753     @Over</b></font>ride
754     public void clear() {
755       fromMultimap.clear();
756     }
757     @Override
758     public boolean containsKey(@CheckForNull Object key) {
759       return fromMultimap.containsKey(key);
760     }
761     @Override
762     Collection&lt;Entry&lt;K, V2&gt;&gt; createEntries() {
763 <a name="5"></a>      return new Entries();
764     }
765     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
766     Iterator&lt;Entry&lt;K, V2&gt;&gt; entryIterator() {
767       return Iterators.transform(
768           fromMultimap.entries().iterator(), Maps.&lt;K, V1, V2&gt;asEntryToEntryFunction(transformer));
769     }</b></font>
770     @Override
771     public Collection&lt;V2&gt; get(@ParametricNullness final K key) {
772       return transform(key, fromMultimap.get(key));
773     }
774     @Override
775     public boolean isEmpty() {
776       return fromMultimap.isEmpty();
777     }
778     @Override
779     Set&lt;K&gt; createKeySet() {
780       return fromMultimap.keySet();
781     }
782     @Override
783     Multiset&lt;K&gt; createKeys() {
784       return fromMultimap.keys();
785     }
786     @Override
787     public boolean put(@ParametricNullness K key, @ParametricNullness V2 value) {
788       throw new UnsupportedOperationException();
789     }
790     @Override
791     public boolean putAll(@ParametricNullness K key, Iterable&lt;? extends V2&gt; values) {
792       throw new UnsupportedOperationException();
793     }
794     @Override
795     public boolean putAll(Multimap&lt;? extends K, ? extends V2&gt; multimap) {
796       throw new UnsupportedOperationException();
797     }
798     @SuppressWarnings("unchecked")
799     @Override
800     public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
801       return get((K) key).remove(value);
802     }
803     @SuppressWarnings("unchecked")
804     @Override
805     public Collection&lt;V2&gt; removeAll(@CheckForNull Object key) {
806       return transform((K) key, fromMultimap.removeAll(key));
807     }
808     @Override
809     public Collection&lt;V2&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V2&gt; values) {
810       throw new UnsupportedOperationException();
811     }
812     @Override
813     public int size() {
814 <a name="4"></a>      return fromMultimap.size();
815     }
816     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
817     Collection&lt;V2&gt; createValues() {
818       return Collections2.transform(
819           fromMultimap.entries(), Maps.&lt;K, V1, V2&gt;asEntryToValueFunction(transformer));
820     }
821   }</b></font>
822   private static final class TransformedEntriesListMultimap&lt;
823           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object&gt;
824       extends TransformedEntriesMultimap&lt;K, V1, V2&gt; implements ListMultimap&lt;K, V2&gt; {
825     TransformedEntriesListMultimap(
826         ListMultimap&lt;K, V1&gt; fromMultimap, EntryTransformer&lt;? super K, ? super V1, V2&gt; transformer) {
827       super(fromMultimap, transformer);
828     }
829     @Override
830     List&lt;V2&gt; transform(@ParametricNullness K key, Collection&lt;V1&gt; values) {
831       return Lists.transform((List&lt;V1&gt;) values, Maps.asValueToValueFunction(transformer, key));
832     }
833     @Override
834     public List&lt;V2&gt; get(@ParametricNullness K key) {
835       return transform(key, fromMultimap.get(key));
836     }
837     @SuppressWarnings("unchecked")
838     @Override
839     public List&lt;V2&gt; removeAll(@CheckForNull Object key) {
840       return transform((K) key, fromMultimap.removeAll(key));
841     }
842     @Override
843     public List&lt;V2&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V2&gt; values) {
844       throw new UnsupportedOperationException();
845     }
846   }
847   public static &lt;K, V&gt; ImmutableListMultimap&lt;K, V&gt; index(
848       Iterable&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction) {
849     return index(values.iterator(), keyFunction);
850   }
851   public static &lt;K, V&gt; ImmutableListMultimap&lt;K, V&gt; index(
852       Iterator&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction) {
853     checkNotNull(keyFunction);
854     ImmutableListMultimap.Builder&lt;K, V&gt; builder = ImmutableListMultimap.builder();
855     while (values.hasNext()) {
856       V value = values.next();
857       checkNotNull(value, values);
858       builder.put(keyFunction.apply(value), value);
859     }
860     return builder.build();
861   }
862   static class Keys&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
863       extends AbstractMultiset&lt;K&gt; {
864     @Weak final Multimap&lt;K, V&gt; multimap;
865     Keys(Multimap&lt;K, V&gt; multimap) {
866       this.multimap = multimap;
867     }
868     @Override
869     Iterator&lt;Multiset.Entry&lt;K&gt;&gt; entryIterator() {
870       return new TransformedIterator&lt;Map.Entry&lt;K, Collection&lt;V&gt;&gt;, Multiset.Entry&lt;K&gt;&gt;(
871           multimap.asMap().entrySet().iterator()) {
872         @Override
873         Multiset.Entry&lt;K&gt; transform(final Map.Entry&lt;K, Collection&lt;V&gt;&gt; backingEntry) {
874           return new Multisets.AbstractEntry&lt;K&gt;() {
875             @Override
876             @ParametricNullness
877             public K getElement() {
878 <a name="9"></a>              return backingEntry.getKey();
879             }
880             <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
881             public int getCount() {
882               return backingEntry.getValue().size();
883             }
884           }</b></font>;
885         }
886       };
887     }
888     @Override
889     public Spliterator&lt;K&gt; spliterator() {
890       return CollectSpliterators.map(multimap.entries().spliterator(), Map.Entry::getKey);
891     }
892     @Override
893     public void forEach(Consumer&lt;? super K&gt; consumer) {
894       checkNotNull(consumer);
895       multimap.entries().forEach(entry -&gt; consumer.accept(entry.getKey()));
896     }
897     @Override
898     int distinctElements() {
899       return multimap.asMap().size();
900     }
901     @Override
902     public int size() {
903       return multimap.size();
904     }
905     @Override
906     public boolean contains(@CheckForNull Object element) {
907       return multimap.containsKey(element);
908     }
909     @Override
910     public Iterator&lt;K&gt; iterator() {
911       return Maps.keyIterator(multimap.entries().iterator());
912     }
913     @Override
914     public int count(@CheckForNull Object element) {
915       Collection&lt;V&gt; values = Maps.safeGet(multimap.asMap(), element);
916       return (values == null) ? 0 : values.size();
917     }
918     @Override
919     public int remove(@CheckForNull Object element, int occurrences) {
920       checkNonnegative(occurrences, "occurrences");
921       if (occurrences == 0) {
922         return count(element);
923       }
924       Collection&lt;V&gt; values = Maps.safeGet(multimap.asMap(), element);
925       if (values == null) {
926         return 0;
927       }
928 <a name="3"></a>      int oldCount = values.size();
929       if (occurrences &gt;= oldCount) {
930         values.clear();
931       } else <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
932         Iterator&lt;V&gt; iterator = values.iterator();
933         for (int i = 0; i &lt; occurrences; i++) {
934           iterator.next();
935           iterator.remove();
936         }</b></font>
937       }
938       return oldCount;
939     }
940     @Override
941     public void clear() {
942       multimap.clear();
943     }
944     @Override
945     public Set&lt;K&gt; elementSet() {
946       return multimap.keySet();
947     }
948     @Override
949     Iterator&lt;K&gt; elementIterator() {
950       throw new AssertionError("should never be called");
951     }
952   }
953   abstract static class Entries&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
954       extends AbstractCollection&lt;Map.Entry&lt;K, V&gt;&gt; {
955     abstract Multimap&lt;K, V&gt; multimap();
956     @Override
957     public int size() {
958       return multimap().size();
959     }
960     @Override
961     public boolean contains(@CheckForNull Object o) {
962       if (o instanceof Map.Entry) {
963         Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) o;
964         return multimap().containsEntry(entry.getKey(), entry.getValue());
965       }
966       return false;
967     }
968     @Override
969     public boolean remove(@CheckForNull Object o) {
970       if (o instanceof Map.Entry) {
971         Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) o;
972         return multimap().remove(entry.getKey(), entry.getValue());
973       }
974       return false;
975     }
976     @Override
977     public void clear() {
978       multimap().clear();
979     }
980   }
981   static final class AsMap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
982       extends Maps.ViewCachingAbstractMap&lt;K, Collection&lt;V&gt;&gt; {
983     @Weak private final Multimap&lt;K, V&gt; multimap;
984     AsMap(Multimap&lt;K, V&gt; multimap) {
985       this.multimap = checkNotNull(multimap);
986     }
987     @Override
988     public int size() {
989       return multimap.keySet().size();
990     }
991     @Override
992     protected Set&lt;Entry&lt;K, Collection&lt;V&gt;&gt;&gt; createEntrySet() {
993       return new EntrySet();
994     }
995     void removeValuesForKey(@CheckForNull Object key) {
996       multimap.keySet().remove(key);
997     }
998     @WeakOuter
999     class EntrySet extends Maps.EntrySet&lt;K, Collection&lt;V&gt;&gt; {
1000       @Override
1001       Map&lt;K, Collection&lt;V&gt;&gt; map() {
1002         return AsMap.this;
1003       }
1004       @Override
1005       public Iterator&lt;Entry&lt;K, Collection&lt;V&gt;&gt;&gt; iterator() {
1006         return Maps.asMapEntryIterator(
1007 <a name="6"></a>            multimap.keySet(),
1008             new Function&lt;K, Collection&lt;V&gt;&gt;() {
1009               @Override
1010               public Collection&lt;V&gt; apply(<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@ParametricNullness K key) {
1011                 return multimap.get(key);
1012               }
1013             });
1014       }
1015       @Overr</b></font>ide
1016       public boolean remove(@CheckForNull Object o) {
1017         if (!contains(o)) {
1018           return false;
1019         }
1020         Map.Entry&lt;?, ?&gt; entry = requireNonNull((Map.Entry&lt;?, ?&gt;) o);
1021         removeValuesForKey(entry.getKey());
1022         return true;
1023       }
1024     }
1025     @SuppressWarnings("unchecked")
1026     @Override
1027     @CheckForNull
1028     public Collection&lt;V&gt; get(@CheckForNull Object key) {
1029       return containsKey(key) ? multimap.get((K) key) : null;
1030     }
1031     @Override
1032     @CheckForNull
1033     public Collection&lt;V&gt; remove(@CheckForNull Object key) {
1034       return containsKey(key) ? multimap.removeAll(key) : null;
1035     }
1036     @Override
1037     public Set&lt;K&gt; keySet() {
1038       return multimap.keySet();
1039     }
1040     @Override
1041     public boolean isEmpty() {
1042       return multimap.isEmpty();
1043     }
1044     @Override
1045     public boolean containsKey(@CheckForNull Object key) {
1046       return multimap.containsKey(key);
1047     }
1048     @Override
1049     public void clear() {
1050       multimap.clear();
1051     }
1052   }
1053   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Multimap&lt;K, V&gt; filterKeys(
1054       Multimap&lt;K, V&gt; unfiltered, final Predicate&lt;? super K&gt; keyPredicate) {
1055     if (unfiltered instanceof SetMultimap) {
1056       return filterKeys((SetMultimap&lt;K, V&gt;) unfiltered, keyPredicate);
1057     } else if (unfiltered instanceof ListMultimap) {
1058       return filterKeys((ListMultimap&lt;K, V&gt;) unfiltered, keyPredicate);
1059     } else if (unfiltered instanceof FilteredKeyMultimap) {
1060       FilteredKeyMultimap&lt;K, V&gt; prev = (FilteredKeyMultimap&lt;K, V&gt;) unfiltered;
1061       return new FilteredKeyMultimap&lt;&gt;(
1062           prev.unfiltered, Predicates.&lt;K&gt;and(prev.keyPredicate, keyPredicate));
1063     } else if (unfiltered instanceof FilteredMultimap) {
1064       FilteredMultimap&lt;K, V&gt; prev = (FilteredMultimap&lt;K, V&gt;) unfiltered;
1065       return filterFiltered(prev, Maps.&lt;K&gt;keyPredicateOnEntries(keyPredicate));
1066     } else {
1067       return new FilteredKeyMultimap&lt;&gt;(unfiltered, keyPredicate);
1068     }
1069   }
1070   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1071       SetMultimap&lt;K, V&gt; filterKeys(
1072           SetMultimap&lt;K, V&gt; unfiltered, final Predicate&lt;? super K&gt; keyPredicate) {
1073     if (unfiltered instanceof FilteredKeySetMultimap) {
1074       FilteredKeySetMultimap&lt;K, V&gt; prev = (FilteredKeySetMultimap&lt;K, V&gt;) unfiltered;
1075       return new FilteredKeySetMultimap&lt;&gt;(
1076           prev.unfiltered(), Predicates.&lt;K&gt;and(prev.keyPredicate, keyPredicate));
1077     } else if (unfiltered instanceof FilteredSetMultimap) {
1078       FilteredSetMultimap&lt;K, V&gt; prev = (FilteredSetMultimap&lt;K, V&gt;) unfiltered;
1079       return filterFiltered(prev, Maps.&lt;K&gt;keyPredicateOnEntries(keyPredicate));
1080     } else {
1081       return new FilteredKeySetMultimap&lt;&gt;(unfiltered, keyPredicate);
1082     }
1083   }
1084   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1085       ListMultimap&lt;K, V&gt; filterKeys(
1086           ListMultimap&lt;K, V&gt; unfiltered, final Predicate&lt;? super K&gt; keyPredicate) {
1087     if (unfiltered instanceof FilteredKeyListMultimap) {
1088       FilteredKeyListMultimap&lt;K, V&gt; prev = (FilteredKeyListMultimap&lt;K, V&gt;) unfiltered;
1089       return new FilteredKeyListMultimap&lt;&gt;(
1090           prev.unfiltered(), Predicates.&lt;K&gt;and(prev.keyPredicate, keyPredicate));
1091     } else {
1092       return new FilteredKeyListMultimap&lt;&gt;(unfiltered, keyPredicate);
1093     }
1094   }
1095   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1096       Multimap&lt;K, V&gt; filterValues(
1097           Multimap&lt;K, V&gt; unfiltered, final Predicate&lt;? super V&gt; valuePredicate) {
1098     return filterEntries(unfiltered, Maps.&lt;V&gt;valuePredicateOnEntries(valuePredicate));
1099   }
1100   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1101       SetMultimap&lt;K, V&gt; filterValues(
1102           SetMultimap&lt;K, V&gt; unfiltered, final Predicate&lt;? super V&gt; valuePredicate) {
1103     return filterEntries(unfiltered, Maps.&lt;V&gt;valuePredicateOnEntries(valuePredicate));
1104   }
1105   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1106       Multimap&lt;K, V&gt; filterEntries(
1107           Multimap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) {
1108     checkNotNull(entryPredicate);
1109     if (unfiltered instanceof SetMultimap) {
1110       return filterEntries((SetMultimap&lt;K, V&gt;) unfiltered, entryPredicate);
1111     }
1112     return (unfiltered instanceof FilteredMultimap)
1113         ? filterFiltered((FilteredMultimap&lt;K, V&gt;) unfiltered, entryPredicate)
1114         : new FilteredEntryMultimap&lt;K, V&gt;(checkNotNull(unfiltered), entryPredicate);
1115   }
1116   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1117       SetMultimap&lt;K, V&gt; filterEntries(
1118           SetMultimap&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) {
1119     checkNotNull(entryPredicate);
1120     return (unfiltered instanceof FilteredSetMultimap)
1121         ? filterFiltered((FilteredSetMultimap&lt;K, V&gt;) unfiltered, entryPredicate)
1122         : new FilteredEntrySetMultimap&lt;K, V&gt;(checkNotNull(unfiltered), entryPredicate);
1123   }
1124   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1125       Multimap&lt;K, V&gt; filterFiltered(
1126           FilteredMultimap&lt;K, V&gt; multimap, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) {
1127     Predicate&lt;Entry&lt;K, V&gt;&gt; predicate =
1128         Predicates.&lt;Entry&lt;K, V&gt;&gt;and(multimap.entryPredicate(), entryPredicate);
1129     return new FilteredEntryMultimap&lt;&gt;(multimap.unfiltered(), predicate);
1130   }
1131   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
1132       SetMultimap&lt;K, V&gt; filterFiltered(
1133           FilteredSetMultimap&lt;K, V&gt; multimap, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) {
1134     Predicate&lt;Entry&lt;K, V&gt;&gt; predicate =
1135         Predicates.&lt;Entry&lt;K, V&gt;&gt;and(multimap.entryPredicate(), entryPredicate);
1136     return new FilteredEntrySetMultimap&lt;&gt;(multimap.unfiltered(), predicate);
1137   }
1138   static boolean equalsImpl(Multimap&lt;?, ?&gt; multimap, @CheckForNull Object object) {
1139     if (object == multimap) {
1140       return true;
1141     }
1142     if (object instanceof Multimap) {
1143       Multimap&lt;?, ?&gt; that = (Multimap&lt;?, ?&gt;) object;
1144       return multimap.asMap().equals(that.asMap());
1145     }
1146     return false;
1147   }
1148 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
