
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.166666666666666%, Tokens: 12</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-CommandController.java</h3>
            <pre><code>1  package com.weibo.controller;
<span onclick='openModal()' class='match'>2  import com.alibaba.fastjson.JSONObject;
3  import com.weibo.api.motan.registry.support.command.RpcCommand.ClientCommand;
4  import com.weibo.model.OperationRecord;
5  import com.weibo.service.CommandService;
6  import org.springframework.http.HttpStatus;
7  import org.springframework.http.ResponseEntity;
8  import org.springframework.util.StringUtils;
9  import org.springframework.web.bind.annotation.*;
10  import javax.annotation.Resource;
11  import java.util.List;
12  @RestController
</span>13  @RequestMapping(value = "/api/commands")
14  public class CommandController {
15      @Resource(name = "${registry.type}" + "CommandService")
16      private CommandService commandService;
17      @RequestMapping(value = "", method = RequestMethod.GET)
18      public ResponseEntity<List<JSONObject>> getAllCommands() {
19          List<JSONObject> result = commandService.getAllCommands();
20          return new ResponseEntity<List<JSONObject>>(result, HttpStatus.OK);
21      }
22      @RequestMapping(value = "/{group}", method = RequestMethod.GET)
23      public ResponseEntity<String> getCommandsByGroup(@PathVariable("group") String group) {
24          if (StringUtils.isEmpty(group)) {
25              return new ResponseEntity<String>(HttpStatus.BAD_REQUEST);
26          }
27          String result = commandService.getCommands(group);
28          return new ResponseEntity<String>(result, HttpStatus.OK);
29      }
30      @RequestMapping(value = "/{group}", method = RequestMethod.POST)
31      public ResponseEntity<Boolean> addCommand(@PathVariable("group") String group, @RequestBody ClientCommand clientCommand) {
32          if (StringUtils.isEmpty(group) || clientCommand == null) {
33              return new ResponseEntity<Boolean>(HttpStatus.BAD_REQUEST);
34          }
35          boolean result = commandService.addCommand(group, clientCommand);
36          HttpStatus status;
37          if (result) {
38              status = HttpStatus.OK;
39          } else {
40              status = HttpStatus.NOT_MODIFIED;
41          }
42          return new ResponseEntity<Boolean>(result, status);
43      }
44      @RequestMapping(value = "/{group}", method = RequestMethod.PUT)
45      public ResponseEntity<Boolean> updateCommand(@PathVariable("group") String group, @RequestBody ClientCommand clientCommand) {
46          if (StringUtils.isEmpty(group) || clientCommand == null) {
47              return new ResponseEntity<Boolean>(HttpStatus.BAD_REQUEST);
48          }
49          boolean result = commandService.updateCommand(group, clientCommand);
50          HttpStatus status;
51          if (result) {
52              status = HttpStatus.OK;
53          } else {
54              status = HttpStatus.NOT_MODIFIED;
55          }
56          return new ResponseEntity<Boolean>(result, status);
57      }
58      @RequestMapping(value = "/{group}/{index}", method = RequestMethod.DELETE)
59      public ResponseEntity<Boolean> deleteCommand(@PathVariable("group") String group, @PathVariable("index") int index) {
60          if (StringUtils.isEmpty(group)) {
61              return new ResponseEntity<Boolean>(HttpStatus.BAD_REQUEST);
62          }
63          boolean result = commandService.deleteCommand(group, index);
64          HttpStatus status;
65          if (result) {
66              status = HttpStatus.OK;
67          } else {
68              status = HttpStatus.NOT_MODIFIED;
69          }
70          return new ResponseEntity<Boolean>(result, status);
71      }
72      @RequestMapping(value = "/{group}/preview", method = RequestMethod.POST)
73      public ResponseEntity<List<JSONObject>> previewCommand(
74              @PathVariable("group") String group,
75              @RequestBody ClientCommand clientCommand,
76              @RequestParam(value = "previewIP", required = false) String previewIP) {
77          if (StringUtils.isEmpty(group) || clientCommand == null) {
78              return new ResponseEntity<List<JSONObject>>(HttpStatus.BAD_REQUEST);
79          }
80          List<JSONObject> results = commandService.previewCommand(group, clientCommand, previewIP);
81          return new ResponseEntity<List<JSONObject>>(results, HttpStatus.OK);
82      }
83      @RequestMapping(value = "/operationRecord", method = RequestMethod.GET)
84      public ResponseEntity<List<OperationRecord>> getAllRecord() {
85          List<OperationRecord> results = commandService.getAllRecord();
86          if (results == null) {
87              return new ResponseEntity<List<OperationRecord>>(HttpStatus.NO_CONTENT);
88          }
89          return new ResponseEntity<List<OperationRecord>>(results, HttpStatus.OK);
90      }
91  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</h3>
            <pre><code>1  package net.md_5.bungee.protocol;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import io.netty.buffer.ByteBuf;
5  import io.netty.buffer.ByteBufInputStream;
6  import io.netty.buffer.ByteBufOutputStream;
7  import java.io.DataInputStream;
8  import java.io.DataOutputStream;
<span onclick='openModal()' class='match'>9  import java.io.IOException;
10  import java.util.ArrayList;
11  import java.util.Arrays;
12  import java.util.BitSet;
13  import java.util.EnumSet;
14  import java.util.List;
15  import java.util.UUID;
16  import lombok.RequiredArgsConstructor;
17  import se.llbit.nbt.NamedTag;
18  import se.llbit.nbt.Tag;
19  @RequiredArgsConstructor
</span>20  public abstract class DefinedPacket
21  {
22      public static void writeString(String s, ByteBuf buf)
23      {
24          writeString( s, buf, Short.MAX_VALUE );
25      }
26      public static void writeString(String s, ByteBuf buf, int maxLength)
27      {
28          if ( s.length() > maxLength )
29          {
30              throw new OverflowPacketException( "Cannot send string longer than " + maxLength + " (got " + s.length() + " characters)" );
31          }
32          byte[] b = s.getBytes( Charsets.UTF_8 );
33          if ( b.length > maxLength * 3 )
34          {
35              throw new OverflowPacketException( "Cannot send string longer than " + ( maxLength * 3 ) + " (got " + b.length + " bytes)" );
36          }
37          writeVarInt( b.length, buf );
38          buf.writeBytes( b );
39      }
40      public static String readString(ByteBuf buf)
41      {
42          return readString( buf, Short.MAX_VALUE );
43      }
44      public static String readString(ByteBuf buf, int maxLen)
45      {
46          int len = readVarInt( buf );
47          if ( len > maxLen * 3 )
48          {
49              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen * 3 + " (got " + len + " bytes)" );
50          }
51          String s = buf.toString( buf.readerIndex(), len, Charsets.UTF_8 );
52          buf.readerIndex( buf.readerIndex() + len );
53          if ( s.length() > maxLen )
54          {
55              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen + " (got " + s.length() + " characters)" );
56          }
57          return s;
58      }
59      public static void writeArray(byte[] b, ByteBuf buf)
60      {
61          if ( b.length > Short.MAX_VALUE )
62          {
63              throw new OverflowPacketException( "Cannot send byte array longer than Short.MAX_VALUE (got " + b.length + " bytes)" );
64          }
65          writeVarInt( b.length, buf );
66          buf.writeBytes( b );
67      }
68      public static byte[] toArray(ByteBuf buf)
69      {
70          byte[] ret = new byte[ buf.readableBytes() ];
71          buf.readBytes( ret );
72          return ret;
73      }
74      public static byte[] readArray(ByteBuf buf)
75      {
76          return readArray( buf, buf.readableBytes() );
77      }
78      public static byte[] readArray(ByteBuf buf, int limit)
79      {
80          int len = readVarInt( buf );
81          if ( len > limit )
82          {
83              throw new OverflowPacketException( "Cannot receive byte array longer than " + limit + " (got " + len + " bytes)" );
84          }
85          byte[] ret = new byte[ len ];
86          buf.readBytes( ret );
87          return ret;
88      }
89      public static int[] readVarIntArray(ByteBuf buf)
90      {
91          int len = readVarInt( buf );
92          int[] ret = new int[ len ];
93          for ( int i = 0; i < len; i++ )
94          {
95              ret[i] = readVarInt( buf );
96          }
97          return ret;
98      }
99      public static void writeStringArray(List<String> s, ByteBuf buf)
100      {
101          writeVarInt( s.size(), buf );
102          for ( String str : s )
103          {
104              writeString( str, buf );
105          }
106      }
107      public static List<String> readStringArray(ByteBuf buf)
108      {
109          int len = readVarInt( buf );
110          List<String> ret = new ArrayList<>( len );
111          for ( int i = 0; i < len; i++ )
112          {
113              ret.add( readString( buf ) );
114          }
115          return ret;
116      }
117      public static int readVarInt(ByteBuf input)
118      {
119          return readVarInt( input, 5 );
120      }
121      public static int readVarInt(ByteBuf input, int maxBytes)
122      {
123          int out = 0;
124          int bytes = 0;
125          byte in;
126          while ( true )
127          {
128              in = input.readByte();
129              out |= ( in & 0x7F ) << ( bytes++ * 7 );
130              if ( bytes > maxBytes )
131              {
132                  throw new RuntimeException( "VarInt too big" );
133              }
134              if ( ( in & 0x80 ) != 0x80 )
135              {
136                  break;
137              }
138          }
139          return out;
140      }
141      public static void writeVarInt(int value, ByteBuf output)
142      {
143          int part;
144          while ( true )
145          {
146              part = value & 0x7F;
147              value >>>= 7;
148              if ( value != 0 )
149              {
150                  part |= 0x80;
151              }
152              output.writeByte( part );
153              if ( value == 0 )
154              {
155                  break;
156              }
157          }
158      }
159      public static int readVarShort(ByteBuf buf)
160      {
161          int low = buf.readUnsignedShort();
162          int high = 0;
163          if ( ( low & 0x8000 ) != 0 )
164          {
165              low = low & 0x7FFF;
166              high = buf.readUnsignedByte();
167          }
168          return ( ( high & 0xFF ) << 15 ) | low;
169      }
170      public static void writeVarShort(ByteBuf buf, int toWrite)
171      {
172          int low = toWrite & 0x7FFF;
173          int high = ( toWrite & 0x7F8000 ) >> 15;
174          if ( high != 0 )
175          {
176              low = low | 0x8000;
177          }
178          buf.writeShort( low );
179          if ( high != 0 )
180          {
181              buf.writeByte( high );
182          }
183      }
184      public static void writeUUID(UUID value, ByteBuf output)
185      {
186          output.writeLong( value.getMostSignificantBits() );
187          output.writeLong( value.getLeastSignificantBits() );
188      }
189      public static UUID readUUID(ByteBuf input)
190      {
191          return new UUID( input.readLong(), input.readLong() );
192      }
193      public static void writeProperties(Property[] properties, ByteBuf buf)
194      {
195          if ( properties == null )
196          {
197              writeVarInt( 0, buf );
198              return;
199          }
200          writeVarInt( properties.length, buf );
201          for ( Property prop : properties )
202          {
203              writeString( prop.getName(), buf );
204              writeString( prop.getValue(), buf );
205              if ( prop.getSignature() != null )
206              {
207                  buf.writeBoolean( true );
208                  writeString( prop.getSignature(), buf );
209              } else
210              {
211                  buf.writeBoolean( false );
212              }
213          }
214      }
215      public static Property[] readProperties(ByteBuf buf)
216      {
217          Property[] properties = new Property[ DefinedPacket.readVarInt( buf ) ];
218          for ( int j = 0; j < properties.length; j++ )
219          {
220              String name = readString( buf );
221              String value = readString( buf );
222              if ( buf.readBoolean() )
223              {
224                  properties[j] = new Property( name, value, DefinedPacket.readString( buf ) );
225              } else
226              {
227                  properties[j] = new Property( name, value );
228              }
229          }
230          return properties;
231      }
232      public static void writePublicKey(PlayerPublicKey publicKey, ByteBuf buf)
233      {
234          if ( publicKey != null )
235          {
236              buf.writeBoolean( true );
237              buf.writeLong( publicKey.getExpiry() );
238              writeArray( publicKey.getKey(), buf );
239              writeArray( publicKey.getSignature(), buf );
240          } else
241          {
242              buf.writeBoolean( false );
243          }
244      }
245      public static PlayerPublicKey readPublicKey(ByteBuf buf)
246      {
247          if ( buf.readBoolean() )
248          {
249              return new PlayerPublicKey( buf.readLong(), readArray( buf, 512 ), readArray( buf, 4096 ) );
250          }
251          return null;
252      }
253      public static Tag readTag(ByteBuf input)
254      {
255          Tag tag = NamedTag.read( new DataInputStream( new ByteBufInputStream( input ) ) );
256          Preconditions.checkArgument( !tag.isError(), "Error reading tag: %s", tag.error() );
257          return tag;
258      }
259      public static void writeTag(Tag tag, ByteBuf output)
260      {
261          try
262          {
263              tag.write( new DataOutputStream( new ByteBufOutputStream( output ) ) );
264          } catch ( IOException ex )
265          {
266              throw new RuntimeException( "Exception writing tag", ex );
267          }
268      }
269      public static <E extends Enum<E>> void writeEnumSet(EnumSet<E> enumset, Class<E> oclass, ByteBuf buf)
270      {
271          E[] enums = oclass.getEnumConstants();
272          BitSet bits = new BitSet( enums.length );
273          for ( int i = 0; i < enums.length; ++i )
274          {
275              bits.set( i, enumset.contains( enums[i] ) );
276          }
277          writeFixedBitSet( bits, enums.length, buf );
278      }
279      public static <E extends Enum<E>> EnumSet<E> readEnumSet(Class<E> oclass, ByteBuf buf)
280      {
281          E[] enums = oclass.getEnumConstants();
282          BitSet bits = readFixedBitSet( enums.length, buf );
283          EnumSet<E> set = EnumSet.noneOf( oclass );
284          for ( int i = 0; i < enums.length; ++i )
285          {
286              if ( bits.get( i ) )
287              {
288                  set.add( enums[i] );
289              }
290          }
291          return set;
292      }
293      public static BitSet readFixedBitSet(int i, ByteBuf buf)
294      {
295          byte[] bits = new byte[ ( i + 8 ) >> 3 ];
296          buf.readBytes( bits );
297          return BitSet.valueOf( bits );
298      }
299      public static void writeFixedBitSet(BitSet bits, int size, ByteBuf buf)
300      {
301          if ( bits.length() > size )
302          {
303              throw new OverflowPacketException( "BitSet too large (expected " + size + " got " + bits.size() + ")" );
304          }
305          buf.writeBytes( Arrays.copyOf( bits.toByteArray(), ( size + 8 ) >> 3 ) );
306      }
307      public void read(ByteBuf buf)
308      {
309          throw new UnsupportedOperationException( "Packet must implement read method" );
310      }
311      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
312      {
313          read( buf );
314      }
315      public void write(ByteBuf buf)
316      {
317          throw new UnsupportedOperationException( "Packet must implement write method" );
318      }
319      public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
320      {
321          write( buf );
322      }
323      public abstract void handle(AbstractPacketHandler handler) throws Exception;
324      @Override
325      public abstract boolean equals(Object obj);
326      @Override
327      public abstract int hashCode();
328      @Override
329      public abstract String toString();
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-CommandController.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import com.alibaba.fastjson.JSONObject;
3  import com.weibo.api.motan.registry.support.command.RpcCommand.ClientCommand;
4  import com.weibo.model.OperationRecord;
5  import com.weibo.service.CommandService;
6  import org.springframework.http.HttpStatus;
7  import org.springframework.http.ResponseEntity;
8  import org.springframework.util.StringUtils;
9  import org.springframework.web.bind.annotation.*;
10  import javax.annotation.Resource;
11  import java.util.List;
12  @RestController
</pre></code></div>
                <div class="column column_space"><pre><code>9  import java.io.IOException;
10  import java.util.ArrayList;
11  import java.util.Arrays;
12  import java.util.BitSet;
13  import java.util.EnumSet;
14  import java.util.List;
15  import java.util.UUID;
16  import lombok.RequiredArgsConstructor;
17  import se.llbit.nbt.NamedTag;
18  import se.llbit.nbt.Tag;
19  @RequiredArgsConstructor
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    