<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DoubleType_1.java & TransportClusterUpdateSettingsAction.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DoubleType_1.java & TransportClusterUpdateSettingsAction.java
      </h3>
      <h1 align="center">
        18.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DoubleType_1.java (18.61472%)<TH>TransportClusterUpdateSettingsAction.java (18.454935%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match755556-0.html#0',2,'match755556-1.html#0',3)" NAME="0">(24-40)<TD><A HREF="javascript:ZweiFrames('match755556-0.html#0',2,'match755556-1.html#0',3)" NAME="0">(32-47)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match755556-0.html#1',2,'match755556-1.html#1',3)" NAME="1">(99-107)<TD><A HREF="javascript:ZweiFrames('match755556-0.html#1',2,'match755556-1.html#1',3)" NAME="1">(69-77)</A><TD ALIGN=center><FONT COLOR="#d70000">11</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match755556-0.html#2',2,'match755556-1.html#2',3)" NAME="2">(149-154)<TD><A HREF="javascript:ZweiFrames('match755556-0.html#2',2,'match755556-1.html#2',3)" NAME="2">(168-175)</A><TD ALIGN=center><FONT COLOR="#c40000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match755556-0.html#3',2,'match755556-1.html#3',3)" NAME="3">(155-161)<TD><A HREF="javascript:ZweiFrames('match755556-0.html#3',2,'match755556-1.html#3',3)" NAME="3">(118-124)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DoubleType_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.types;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match755556-1.html#0',3,'match755556-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import java.io.IOException;
import java.math.BigDecimal;

import org.apache.lucene.document.DoublePoint;
import org.apache.lucene.document.SortedNumericDocValuesField;
import org.apache.lucene.search.IndexOrDocValuesQuery;
import org.apache.lucene.search.Query;
import org.apache.lucene.util.NumericUtils;
import org.apache.lucene.util.RamUsageEstimator;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;

import io.crate.Streamer;

public class DoubleType extends DataType&lt;Double&gt; implements FixedWidthType, Streamer&lt;Double&gt; {

    public static final DoubleType INSTANCE = new DoubleType()</B></FONT>;
    public static final int ID = 6;
    private static final int DOUBLE_SIZE = (int) RamUsageEstimator.shallowSizeOfInstance(Double.class);
    private static final StorageSupport&lt;Double&gt; STORAGE = new StorageSupport&lt;&gt;(
        true,
        true,
        new EqQuery&lt;Double&gt;() {

            @Override
            public Query termQuery(String field, Double value) {
                return DoublePoint.newExactQuery(field, value);
            }

            @Override
            public Query rangeQuery(String field,
                                    Double lowerTerm,
                                    Double upperTerm,
                                    boolean includeLower,
                                    boolean includeUpper) {
                double lower;
                if (lowerTerm == null) {
                    lower = Double.NEGATIVE_INFINITY;
                } else {
                    lower = includeLower ? lowerTerm : DoublePoint.nextUp(lowerTerm);
                }

                double upper;
                if (upperTerm == null) {
                    upper = Double.POSITIVE_INFINITY;
                } else {
                    upper = includeUpper ? upperTerm : DoublePoint.nextDown(upperTerm);
                }
                Query indexQuery = DoublePoint.newRangeQuery(field, lower, upper);
                Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(
                    field,
                    NumericUtils.doubleToSortableLong(lower),
                    NumericUtils.doubleToSortableLong(upper)
                );
                return new IndexOrDocValuesQuery(indexQuery, dvQuery);
            }
        }
    );

    private DoubleType() {
    }

    @Override
    public int id() {
        return ID;
    }

    @Override
    public Precedence precedence() {
        return Precedence.DOUBLE;
    }

<A NAME="1"></A>    @Override
    public String getName() {
        return &quot;double precision&quot;;
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match755556-1.html#1',3,'match755556-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public Streamer&lt;Double&gt; streamer() {
        return this;
    }

    @Override
    public Double implicitCast(Object value</B></FONT>) throws IllegalArgumentException, ClassCastException {
        if (value == null) {
            return null;
        } else if (value instanceof Double) {
            return (Double) value;
        } else if (value instanceof String) {
            return Double.valueOf((String) value);
        } else if (value instanceof BigDecimal) {
            var bigDecimalValue = (BigDecimal) value;

            var DOUBLE_MAX = BigDecimal.valueOf(Double.MAX_VALUE).toBigInteger();
            var DOUBLE_MIN = BigDecimal.valueOf(-Double.MAX_VALUE).toBigInteger();
            if (DOUBLE_MAX.compareTo(bigDecimalValue.toBigInteger()) &lt;= 0
                || DOUBLE_MIN.compareTo(bigDecimalValue.toBigInteger()) &gt;= 0) {
                throw new IllegalArgumentException(getName() + &quot; value out of range: &quot; + value);
            }
            return bigDecimalValue.doubleValue();
        } else if (value instanceof Number) {
            return ((Number) value).doubleValue();
        } else {
            throw new ClassCastException(&quot;Can't cast '&quot; + value + &quot;' to &quot; + getName());
        }
    }

    @Override
    public Double sanitizeValue(Object value) {
        if (value == null) {
            return null;
        } else if (value instanceof Double) {
            return (Double) value;
        } else {
            return ((Number) value).doubleValue();
        }
    }

    @Override
    public int compare(Double val1, Double val2) {
        return Double.compare(val1, val2);
    }
<A NAME="2"></A>
    @Override
    public Double readValueFrom(StreamInput in) throws IOException {
        return <FONT color="#980517"><A HREF="javascript:ZweiFrames('match755556-1.html#2',3,'match755556-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>in.readBoolean() ? null : in.readDouble();
    }

<A NAME="3"></A>    @Override
    public void writeValueTo(StreamOutput out, Double v) throws IOException {
        out.writeBoolean</B></FONT>(v == null);
        if (v != null) <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match755556-1.html#3',3,'match755556-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            out.writeDouble(v);
        }
    }

    @Override
    public int fixedSize() {</B></FONT>
        return DOUBLE_SIZE;
    }

    @Override
    public StorageSupport&lt;Double&gt; storageSupport() {
        return STORAGE;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportClusterUpdateSettingsAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.action.admin.cluster.settings;

import org.apache.logging.log4j.message.ParameterizedMessage;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.support.master.TransportMasterNodeAction;
import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.block.ClusterBlockException;
<A NAME="0"></A>import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.metadata.Metadata;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match755556-0.html#0',2,'match755556-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.routing.allocation.AllocationService;
import org.elasticsearch.cluster.service.ClusterService;
import javax.annotation.Nullable;
import org.elasticsearch.common.Priority;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.settings.ClusterSettings;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.TransportService;

import java.io.IOException;

public class TransportClusterUpdateSettingsAction extends TransportMasterNodeAction&lt;ClusterUpdateSettingsRequest, ClusterUpdateSettingsResponse&gt; {

    private final AllocationService allocationService</B></FONT>;

    private final ClusterSettings clusterSettings;

    @Inject
    public TransportClusterUpdateSettingsAction(TransportService transportService,
                                                ClusterService clusterService,
                                                ThreadPool threadPool,
                                                AllocationService allocationService,
                                                IndexNameExpressionResolver indexNameExpressionResolver,
                                                ClusterSettings clusterSettings) {
        super(
            ClusterUpdateSettingsAction.NAME,
            false,
            transportService,
            clusterService,
            threadPool,
            ClusterUpdateSettingsRequest::new,
            indexNameExpressionResolver
<A NAME="1"></A>        );
        this.allocationService = allocationService;
        this.clusterSettings = clusterSettings;
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match755556-0.html#1',2,'match755556-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    protected String executor() {
        return ThreadPool.Names.SAME;
    }

    @Override
    protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request</B></FONT>, ClusterState state) {
        // allow for dedicated changes to the metadata blocks, so we don't block those to allow to &quot;re-enable&quot; it
        if (request.transientSettings().size() + request.persistentSettings().size() == 1) {
            // only one setting
            if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())
                || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())
                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())
                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {
                // one of the settings above as the only setting in the request means - resetting the block!
                return null;
            }
        }
        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);
    }


    @Override
    protected ClusterUpdateSettingsResponse read(StreamInput in) throws IOException {
        return new ClusterUpdateSettingsResponse(in);
    }

    @Override
    protected void masterOperation(final ClusterUpdateSettingsRequest request,
                                   final ClusterState state,
                                   final ActionListener&lt;ClusterUpdateSettingsResponse&gt; listener) {
        final SettingsUpdater updater = new SettingsUpdater(clusterSettings);
        clusterService.submitStateUpdateTask(
            &quot;cluster_update_settings&quot;,
            new AckedClusterStateUpdateTask&lt;&gt;(Priority.IMMEDIATE, request, listener) {

                private volatile boolean changed = false;

                @Override
                protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {
                    return new ClusterUpdateSettingsResponse(acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate());
                }

                @Override
<A NAME="3"></A>                public void onAllNodesAcked(@Nullable Exception e) {
                    if (changed) {
                        reroute(true);
                    } else <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match755556-0.html#3',2,'match755556-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                        super.onAllNodesAcked(e);
                    }
                }

                @Override
                public void onAckTimeout() {</B></FONT>
                    if (changed) {
                        reroute(false);
                    } else {
                        super.onAckTimeout();
                    }
                }

                private void reroute(final boolean updateSettingsAcked) {
                    // We're about to send a second update task, so we need to check if we're still the elected master
                    // For example the minimum_master_node could have been breached and we're no longer elected master,
                    // so we should *not* execute the reroute.
                    if (!clusterService.state().nodes().isLocalNodeElectedMaster()) {
                        logger.debug(&quot;Skipping reroute after cluster update settings, because node is no longer master&quot;);
                        listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(),
                            updater.getPersistentUpdate()));
                        return;
                    }

                    // The reason the reroute needs to be send as separate update task, is that all the *cluster* settings are encapsulate
                    // in the components (e.g. FilterAllocationDecider), so the changes made by the first call aren't visible
                    // to the components until the ClusterStateListener instances have been invoked, but are visible after
                    // the first update task has been completed.
                    clusterService.submitStateUpdateTask(
                        &quot;reroute_after_cluster_update_settings&quot;,
                        new AckedClusterStateUpdateTask&lt;ClusterUpdateSettingsResponse&gt;(Priority.URGENT, request, listener) {

                            @Override
                            public boolean mustAck(DiscoveryNode discoveryNode) {
                                //we wait for the reroute ack only if the update settings was acknowledged
                                return updateSettingsAcked;
                            }

                            @Override
                            // we return when the cluster reroute is acked or it times out but the acknowledged flag depends on whether the
                            // update settings was acknowledged
                            protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {
                                return new ClusterUpdateSettingsResponse(updateSettingsAcked &amp;&amp; acknowledged, updater.getTransientUpdates(),
                                    updater.getPersistentUpdate());
                            }

<A NAME="2"></A>                            @Override
                            public void onNoLongerMaster(String source) {
                                logger.debug(&quot;failed to preform reroute after cluster settings were updated - current node is no longer a master&quot;);
                                listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match755556-0.html#2',2,'match755556-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>updater.getTransientUpdates(),
                                    updater.getPersistentUpdate()));
                            }

                            @Override
                            public void onFailure(String source, Exception e) {
                                //if the reroute fails we only log
                                logger.debug</B></FONT>(() -&gt; new ParameterizedMessage(&quot;failed to perform [{}]&quot;, source), e);
                                listener.onFailure(new ElasticsearchException(&quot;reroute after update settings failed&quot;, e));
                            }

                            @Override
                            public ClusterState execute(final ClusterState currentState) {
                                // now, reroute in case things that require it changed (e.g. number of replicas)
                                return allocationService.reroute(currentState, &quot;reroute after cluster update settings&quot;);
                            }
                        }
                    );
                }

                @Override
                public void onFailure(String source, Exception e) {
                    logger.debug(() -&gt; new ParameterizedMessage(&quot;failed to perform [{}]&quot;, source), e);
                    super.onFailure(source, e);
                }

                @Override
                public ClusterState execute(final ClusterState currentState) {
                    final ClusterState clusterState =
                            updater.updateSettings(
                                    currentState,
                                    clusterSettings.upgradeSettings(request.transientSettings()),
                                    clusterSettings.upgradeSettings(request.persistentSettings()),
                                    logger);
                    changed = clusterState != currentState;
                    return clusterState;
                }
            }
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
