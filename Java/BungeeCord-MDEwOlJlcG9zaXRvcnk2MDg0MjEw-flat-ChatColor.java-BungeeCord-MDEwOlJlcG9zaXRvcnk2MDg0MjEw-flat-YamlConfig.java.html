
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-ChatColor.java</h3>
            <pre><code>1  package net.md_5.bungee.api;
2  import com.google.common.base.Preconditions;
3  import java.awt.Color;
4  import java.util.HashMap;
5  import java.util.Locale;
6  import java.util.Map;
7  import java.util.Objects;
8  import java.util.regex.Pattern;
9  import lombok.Getter;
10  public final class ChatColor
11  {
12      public static final char COLOR_CHAR = &#x27;\u00A7&#x27;;
13      public static final String ALL_CODES = &quot;0123456789AaBbCcDdEeFfKkLlMmNnOoRrXx&quot;;
14      public static final Pattern STRIP_COLOR_PATTERN = Pattern.compile( &quot;(?i)&quot; + String.valueOf( COLOR_CHAR ) + &quot;[0-9A-FK-ORX]&quot; );
15      private static final Map&lt;Character, ChatColor&gt; BY_CHAR = new HashMap&lt;Character, ChatColor&gt;();
16      private static final Map&lt;String, ChatColor&gt; BY_NAME = new HashMap&lt;String, ChatColor&gt;();
17      public static final ChatColor BLACK = new ChatColor( &#x27;0&#x27;, &quot;black&quot;, new Color( 0x000000 ) );
18      public static final ChatColor DARK_BLUE = new ChatColor( &#x27;1&#x27;, &quot;dark_blue&quot;, new Color( 0x0000AA ) );
19      public static final ChatColor DARK_GREEN = new ChatColor( &#x27;2&#x27;, &quot;dark_green&quot;, new Color( 0x00AA00 ) );
20      public static final ChatColor DARK_AQUA = new ChatColor( &#x27;3&#x27;, &quot;dark_aqua&quot;, new Color( 0x00AAAA ) );
21      public static final ChatColor DARK_RED = new ChatColor( &#x27;4&#x27;, &quot;dark_red&quot;, new Color( 0xAA0000 ) );
22      public static final ChatColor DARK_PURPLE = new ChatColor( &#x27;5&#x27;, &quot;dark_purple&quot;, new Color( 0xAA00AA ) );
23      public static final ChatColor GOLD = new ChatColor( &#x27;6&#x27;, &quot;gold&quot;, new Color( 0xFFAA00 ) );
24      public static final ChatColor GRAY = new ChatColor( &#x27;7&#x27;, &quot;gray&quot;, new Color( 0xAAAAAA ) );
25      public static final ChatColor DARK_GRAY = new ChatColor( &#x27;8&#x27;, &quot;dark_gray&quot;, new Color( 0x555555 ) );
26      public static final ChatColor BLUE = new ChatColor( &#x27;9&#x27;, &quot;blue&quot;, new Color( 0x5555FF ) );
27      public static final ChatColor GREEN = new ChatColor( &#x27;a&#x27;, &quot;green&quot;, new Color( 0x55FF55 ) );
28      public static final ChatColor AQUA = new ChatColor( &#x27;b&#x27;, &quot;aqua&quot;, new Color( 0x55FFFF ) );
29      public static final ChatColor RED = new ChatColor( &#x27;c&#x27;, &quot;red&quot;, new Color( 0xFF5555 ) );
30      public static final ChatColor LIGHT_PURPLE = new ChatColor( &#x27;d&#x27;, &quot;light_purple&quot;, new Color( 0xFF55FF ) );
31      public static final ChatColor YELLOW = new ChatColor( &#x27;e&#x27;, &quot;yellow&quot;, new Color( 0xFFFF55 ) );
32      public static final ChatColor WHITE = new ChatColor( &#x27;f&#x27;, &quot;white&quot;, new Color( 0xFFFFFF ) );
33      public static final ChatColor MAGIC = new ChatColor( &#x27;k&#x27;, &quot;obfuscated&quot; );
34      public static final ChatColor BOLD = new ChatColor( &#x27;l&#x27;, &quot;bold&quot; );
35      public static final ChatColor STRIKETHROUGH = new ChatColor( &#x27;m&#x27;, &quot;strikethrough&quot; );
36      public static final ChatColor UNDERLINE = new ChatColor( &#x27;n&#x27;, &quot;underline&quot; );
37      public static final ChatColor ITALIC = new ChatColor( &#x27;o&#x27;, &quot;italic&quot; );
38      public static final ChatColor RESET = new ChatColor( &#x27;r&#x27;, &quot;reset&quot; );
39      private static int count = 0;
40      private final String toString;
41      @Getter
42      private final String name;
43      private final int ordinal;
44      @Getter
45      private final Color color;
46      private ChatColor(char code, String name)
47      {
48          this( code, name, null );
49      }
50      private ChatColor(char code, String name, Color color)
51      {
52          this.name = name;
53          this.toString = new String( new char[]
54          {
55              COLOR_CHAR, code
56          } );
57          this.ordinal = count++;
58          this.color = color;
59          BY_CHAR.put( code, this );
60          BY_NAME.put( name.toUpperCase( Locale.ROOT ), this );
61      }
62      private ChatColor(String name, String toString, int rgb)
63      {
64          this.name = name;
65          this.toString = toString;
66          this.ordinal = -1;
67          this.color = new Color( rgb );
68      }
69      @Override
70      public int hashCode()
71      {
72          int hash = 7;
73          hash = 53 * hash + Objects.hashCode( this.toString );
74          return hash;
75      }
76      @Override
77      public boolean equals(Object obj)
78      {
79          if ( this == obj )
80          {
81              return true;
82          }
83          if ( obj == null || getClass() != obj.getClass() )
84          {
85              return false;
86          }
87          final ChatColor other = (ChatColor) obj;
88          return Objects.equals( this.toString, other.toString );
89      }
90      @Override
91      public String toString()
92      {
93          return toString;
94      }
95      public static String stripColor(final String input)
96      {
97          if ( input == null )
98          {
99              return null;
100          }
101          return STRIP_COLOR_PATTERN.matcher( input ).replaceAll( &quot;&quot; );
102      }
103      public static String translateAlternateColorCodes(char altColorChar, String textToTranslate)
104      {
105          char[] b = textToTranslate.toCharArray();
106          for ( int i = 0; i &lt; b.length - 1; i++ )
107          {
108              if ( b[i] == altColorChar &amp;&amp; ALL_CODES.indexOf( b[i + 1] ) &gt; -1 )
109              {
110                  b[i] = ChatColor.COLOR_CHAR;
111                  b[i + 1] = Character.toLowerCase( b[i + 1] );
112              }
113          }
114          return new String( b );
115      }
116      public static ChatColor getByChar(char code)
117      {
118          return BY_CHAR.get( code );
119      }
120      public static ChatColor of(Color color)
121      {
122          return of( &quot;#&quot; + String.format( &quot;%08x&quot;, color.getRGB() ).substring( 2 ) );
123      }
124      public static ChatColor of(String string)
125      {
126          Preconditions.checkArgument( string != null, &quot;string cannot be null&quot; );
127          if ( string.startsWith( &quot;#&quot; ) &amp;&amp; string.length() == 7 )
128          {
129              int rgb;
130              try
131              {
132                  rgb = Integer.parseInt( string.substring( 1 ), 16 );
133              } catch ( NumberFormatException ex )
134              {
135                  throw new IllegalArgumentException( &quot;Illegal hex string &quot; + string );
136              }
137              StringBuilder magic = new StringBuilder( COLOR_CHAR + &quot;x&quot; );
138              for ( char c : string.substring( 1 ).toCharArray() )
139              {
140                  magic.append( COLOR_CHAR ).append( c );
141              }
142              return new ChatColor( string, magic.toString(), rgb );
143          }
<span onclick='openModal()' class='match'>144          ChatColor defined = BY_NAME.get( string.toUpperCase( Locale.ROOT ) );
145          if ( defined != null )
</span>146          {
147              return defined;
148          }
149          throw new IllegalArgumentException( &quot;Could not parse ChatColor &quot; + string );
150      }
151      @Deprecated
152      public static ChatColor valueOf(String name)
153      {
154          Preconditions.checkNotNull( name, &quot;Name is null&quot; );
155          ChatColor defined = BY_NAME.get( name );
156          Preconditions.checkArgument( defined != null, &quot;No enum constant &quot; + ChatColor.class.getName() + &quot;.&quot; + name );
157          return defined;
158      }
159      @Deprecated
160      public static ChatColor[] values()
161      {
162          return BY_CHAR.values().toArray( new ChatColor[ 0 ] );
163      }
164      @Deprecated
165      public String name()
166      {
167          return getName().toUpperCase( Locale.ROOT );
168      }
169      @Deprecated
170      public int ordinal()
171      {
172          Preconditions.checkArgument( ordinal &gt;= 0, &quot;Cannot get ordinal of hex color&quot; );
173          return ordinal;
174      }
175  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-YamlConfig.java</h3>
            <pre><code>1  package net.md_5.bungee.conf;
2  import com.google.common.base.Charsets;
3  import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
4  import java.io.File;
5  import java.io.FileInputStream;
6  import java.io.FileOutputStream;
7  import java.io.IOException;
8  import java.io.InputStream;
9  import java.io.OutputStreamWriter;
10  import java.io.Writer;
11  import java.net.SocketAddress;
12  import java.util.ArrayList;
13  import java.util.Arrays;
14  import java.util.Collection;
15  import java.util.Collections;
16  import java.util.HashMap;
17  import java.util.HashSet;
18  import java.util.LinkedHashMap;
19  import java.util.List;
20  import java.util.Locale;
21  import java.util.Map;
22  import java.util.logging.Level;
23  import lombok.RequiredArgsConstructor;
24  import net.md_5.bungee.Util;
25  import net.md_5.bungee.api.ChatColor;
26  import net.md_5.bungee.api.ProxyServer;
27  import net.md_5.bungee.api.config.ConfigurationAdapter;
28  import net.md_5.bungee.api.config.ListenerInfo;
29  import net.md_5.bungee.api.config.ServerInfo;
30  import net.md_5.bungee.util.CaseInsensitiveMap;
31  import org.yaml.snakeyaml.DumperOptions;
32  import org.yaml.snakeyaml.Yaml;
33  import org.yaml.snakeyaml.error.YAMLException;
34  public class YamlConfig implements ConfigurationAdapter
35  {
36      @RequiredArgsConstructor
37      private enum DefaultTabList
38      {
39          GLOBAL(), GLOBAL_PING(), SERVER();
40      }
41      private final Yaml yaml;
42      private Map&lt;String, Object&gt; config;
43      private final File file = new File( &quot;config.yml&quot; );
44      public YamlConfig()
45      {
46          DumperOptions options = new DumperOptions();
47          options.setDefaultFlowStyle( DumperOptions.FlowStyle.BLOCK );
48          yaml = new Yaml( options );
49      }
50      @Override
51      public void load()
52      {
53          try
54          {
55              file.createNewFile();
56              try ( InputStream is = new FileInputStream( file ) )
57              {
58                  try
59                  {
60                      config = (Map) yaml.load( is );
61                  } catch ( YAMLException ex )
62                  {
63                      throw new RuntimeException( &quot;Invalid configuration encountered - this is a configuration error and NOT a bug! Please attempt to fix the error or see https:&amp;bsol;&amp;bsol;www.spigotmc.org/ for help.&quot;, ex );
64                  }
65              }
66              if ( config == null )
67              {
68                  config = new CaseInsensitiveMap&lt;&gt;();
69              } else
70              {
71                  config = new CaseInsensitiveMap&lt;&gt;( config );
72              }
73          } catch ( IOException ex )
74          {
75              throw new RuntimeException( &quot;Could not load configuration!&quot;, ex );
76          }
77          Map&lt;String, Object&gt; permissions = get( &quot;permissions&quot;, null );
78          if ( permissions == null )
79          {
80              set( &quot;permissions.default&quot;, Arrays.asList( new String[]
81              {
82                  &quot;bungeecord.command.server&quot;, &quot;bungeecord.command.list&quot;
83              } ) );
84              set( &quot;permissions.admin&quot;, Arrays.asList( new String[]
85              {
86                  &quot;bungeecord.command.alert&quot;, &quot;bungeecord.command.end&quot;, &quot;bungeecord.command.ip&quot;, &quot;bungeecord.command.reload&quot;, &quot;bungeecord.command.kick&quot;
87              } ) );
88          }
89          Map&lt;String, Object&gt; groups = get( &quot;groups&quot;, null );
90          if ( groups == null )
91          {
92              set( &quot;groups.md_5&quot;, Collections.singletonList( &quot;admin&quot; ) );
93          }
94      }
95      private &lt;T&gt; T get(String path, T def)
96      {
97          return get( path, def, config );
98      }
99      @SuppressWarnings(&quot;unchecked&quot;)
100      private &lt;T&gt; T get(String path, T def, Map submap)
101      {
102          int index = path.indexOf( &#x27;.&#x27; );
103          if ( index == -1 )
104          {
105              Object val = submap.get( path );
106              if ( val == null &amp;&amp; def != null )
107              {
108                  val = def;
109                  submap.put( path, def );
110                  save();
111              }
112              return (T) val;
113          } else
114          {
115              String first = path.substring( 0, index );
116              String second = path.substring( index + 1, path.length() );
117              Map sub = (Map) submap.get( first );
118              if ( sub == null )
119              {
120                  sub = new LinkedHashMap();
121                  submap.put( first, sub );
122              }
123              return get( second, def, sub );
124          }
125      }
126      private void set(String path, Object val)
127      {
128          set( path, val, config );
129      }
130      @SuppressWarnings(&quot;unchecked&quot;)
131      private void set(String path, Object val, Map submap)
132      {
133          int index = path.indexOf( &#x27;.&#x27; );
134          if ( index == -1 )
135          {
136              if ( val == null )
137              {
138                  submap.remove( path );
139              } else
140              {
141                  submap.put( path, val );
142              }
143              save();
144          } else
145          {
146              String first = path.substring( 0, index );
147              String second = path.substring( index + 1, path.length() );
148              Map sub = (Map) submap.get( first );
149              if ( sub == null )
150              {
151                  sub = new LinkedHashMap();
152                  submap.put( first, sub );
153              }
154              set( second, val, sub );
155          }
156      }
157      private void save()
158      {
159          try
160          {
161              try ( Writer wr = new OutputStreamWriter( new FileOutputStream( file ), Charsets.UTF_8 ) )
162              {
163                  yaml.dump( config, wr );
164              }
165          } catch ( IOException ex )
166          {
167              ProxyServer.getInstance().getLogger().log( Level.WARNING, &quot;Could not save config&quot;, ex );
168          }
169      }
170      @Override
171      public int getInt(String path, int def)
172      {
173          return get( path, def );
174      }
175      @Override
176      public String getString(String path, String def)
177      {
178          return get( path, def );
179      }
180      @Override
181      public boolean getBoolean(String path, boolean def)
182      {
183          return get( path, def );
184      }
185      @Override
186      @SuppressWarnings(&quot;unchecked&quot;)
187      public Map&lt;String, ServerInfo&gt; getServers()
188      {
189          Map&lt;String, Map&lt;String, Object&gt;&gt; base = get( &quot;servers&quot;, (Map) Collections.singletonMap( &quot;lobby&quot;, new HashMap&lt;&gt;() ) );
190          Map&lt;String, ServerInfo&gt; ret = new HashMap&lt;&gt;();
191          for ( Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : base.entrySet() )
192          {
193              Map&lt;String, Object&gt; val = entry.getValue();
194              String name = entry.getKey();
195              String addr = get( &quot;address&quot;, &quot;localhost:25565&quot;, val );
196              String motd = ChatColor.translateAlternateColorCodes( &#x27;&amp;&#x27;, get( &quot;motd&quot;, &quot;&amp;1Just another BungeeCord - Forced Host&quot;, val ) );
197              boolean restricted = get( &quot;restricted&quot;, false, val );
198              SocketAddress address = Util.getAddr( addr );
199              ServerInfo info = ProxyServer.getInstance().constructServerInfo( name, address, motd, restricted );
200              ret.put( name, info );
201          }
202          return ret;
203      }
204      @Override
205      @SuppressWarnings(&quot;unchecked&quot;)
206      @SuppressFBWarnings(&quot;RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE&quot;)
207      public Collection&lt;ListenerInfo&gt; getListeners()
208      {
209          Collection&lt;Map&lt;String, Object&gt;&gt; base = get( &quot;listeners&quot;, (Collection) Arrays.asList( new Map[]
210          {
211              new HashMap()
212          } ) );
213          Map&lt;String, String&gt; forcedDef = new HashMap&lt;&gt;();
214          forcedDef.put( &quot;pvp.md-5.net&quot;, &quot;pvp&quot; );
215          Collection&lt;ListenerInfo&gt; ret = new HashSet&lt;&gt;();
216          for ( Map&lt;String, Object&gt; val : base )
217          {
218              String motd = get( &quot;motd&quot;, &quot;&amp;1Another Bungee server&quot;, val );
219              motd = ChatColor.translateAlternateColorCodes( &#x27;&amp;&#x27;, motd );
220              int maxPlayers = get( &quot;max_players&quot;, 1, val );
221              boolean forceDefault = get( &quot;force_default_server&quot;, false, val );
222              String host = get( &quot;host&quot;, &quot;0.0.0.0:25577&quot;, val );
223              int tabListSize = get( &quot;tab_size&quot;, 60, val );
224              SocketAddress address = Util.getAddr( host );
225              Map&lt;String, String&gt; forced = new CaseInsensitiveMap&lt;&gt;( get( &quot;forced_hosts&quot;, forcedDef, val ) );
226              String tabListName = get( &quot;tab_list&quot;, &quot;GLOBAL_PING&quot;, val );
<span onclick='openModal()' class='match'>227              DefaultTabList value = DefaultTabList.valueOf( tabListName.toUpperCase( Locale.ROOT ) );
228              if ( value == null )
</span>229              {
230                  value = DefaultTabList.GLOBAL_PING;
231              }
232              boolean setLocalAddress = get( &quot;bind_local_address&quot;, true, val );
233              boolean pingPassthrough = get( &quot;ping_passthrough&quot;, false, val );
234              boolean query = get( &quot;query_enabled&quot;, false, val );
235              int queryPort = get( &quot;query_port&quot;, 25577, val );
236              boolean proxyProtocol = get( &quot;proxy_protocol&quot;, false, val );
237              List&lt;String&gt; serverPriority = new ArrayList&lt;&gt;( get( &quot;priorities&quot;, Collections.EMPTY_LIST, val ) );
238              String defaultServer = get( &quot;default_server&quot;, null, val );
239              String fallbackServer = get( &quot;fallback_server&quot;, null, val );
240              if ( defaultServer != null )
241              {
242                  serverPriority.add( defaultServer );
243                  set( &quot;default_server&quot;, null, val );
244              }
245              if ( fallbackServer != null )
246              {
247                  serverPriority.add( fallbackServer );
248                  set( &quot;fallback_server&quot;, null, val );
249              }
250              if ( serverPriority.isEmpty() )
251              {
252                  serverPriority.add( &quot;lobby&quot; );
253              }
254              set( &quot;priorities&quot;, serverPriority, val );
255              ListenerInfo info = new ListenerInfo( address, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forced, value.toString(), setLocalAddress, pingPassthrough, queryPort, query, proxyProtocol );
256              ret.add( info );
257          }
258          return ret;
259      }
260      @Override
261      @SuppressWarnings(&quot;unchecked&quot;)
262      public Collection&lt;String&gt; getGroups(String player)
263      {
264          Map&lt;String, Collection&lt;String&gt;&gt; raw = get( &quot;groups&quot;, Collections.emptyMap() );
265          Collection&lt;String&gt; groups = raw.get( player );
266          Collection&lt;String&gt; ret = ( groups == null ) ? new HashSet&lt;String&gt;() : new HashSet&lt;&gt;( groups );
267          ret.add( &quot;default&quot; );
268          return ret;
269      }
270      @Override
271      public Collection&lt;?&gt; getList(String path, Collection&lt;?&gt; def)
272      {
273          return get( path, def );
274      }
275      @Override
276      @SuppressWarnings(&quot;unchecked&quot;)
277      public Collection&lt;String&gt; getPermissions(String group)
278      {
279          Collection&lt;String&gt; permissions = get( &quot;permissions.&quot; + group, null );
280          return ( permissions == null ) ? Collections.EMPTY_SET : permissions;
281      }
282  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-ChatColor.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-YamlConfig.java</div>
                </div>
                <div class="column column_space"><pre><code>144          ChatColor defined = BY_NAME.get( string.toUpperCase( Locale.ROOT ) );
145          if ( defined != null )
</pre></code></div>
                <div class="column column_space"><pre><code>227              DefaultTabList value = DefaultTabList.valueOf( tabListName.toUpperCase( Locale.ROOT ) );
228              if ( value == null )
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    