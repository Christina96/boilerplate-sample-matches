<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for UserDefinedFunctionsTest.java &amp; BalancedShardsAllocator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for UserDefinedFunctionsTest.java &amp; BalancedShardsAllocator.java
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>UserDefinedFunctionsTest.java (25.301205%)<th>BalancedShardsAllocator.java (1.3199246%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-48)<td><a href="#" name="0">(44-83)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UserDefinedFunctionsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.expression.udf;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.analyze.FunctionArgumentDefinition;
4 import io.crate.analyze.TableDefinitions;
5 import io.crate.analyze.relations.DocTableRelation;
6 import io.crate.metadata.FunctionProvider;
7 import io.crate.metadata.FunctionName;
8 import io.crate.metadata.RelationName;
9 import io.crate.metadata.doc.DocTableInfo;
10 import io.crate.testing.SQLExecutor;
11 import io.crate.testing.SqlExpressions;
12 import io.crate.types.DataType;
13 import io.crate.types.DataTypes;
14 import org.junit.Before;
15 import org.junit.Test;
16 import java.util.ArrayList;
17 import java.util.HashMap;
18 import java.util.List;
19 import java.util.Map;
20 import static io.crate.testing.SymbolMatchers.isLiteral;
21 import static java.util.stream.Collectors.toList;
22 public class UserDefinedFunctionsTest extends UdfUnitTest {
23     private SqlExpressions sqlExpressions</b></font>;
24     private Map&lt;FunctionName, List&lt;FunctionProvider&gt;&gt; functionImplementations = new HashMap&lt;&gt;();
25     @Before
26     public void prepare() throws Exception {
27         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
28             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
29             .build();
30         DocTableInfo users = sqlExecutor.schemas().getTableInfo(new RelationName("doc", "users"));
31         sqlExpressions = new SqlExpressions(Map.of(users.ident(), new DocTableRelation(users)));
32         udfService.registerLanguage(DUMMY_LANG);
33     }
34     private void registerUserDefinedFunction(
35         String lang,
36         String schema,
37         String name,
38         DataType returnType,
39         List&lt;DataType&gt; types,
40         String definition) {
41         var udf = new UserDefinedFunctionMetadata(
42             schema,
43             name,
44             types.stream().map(FunctionArgumentDefinition::of).collect(toList()),
45             returnType,
46             lang,
47             definition);
48         var functionName = new FunctionName(udf.schema(), udf.name());
49         var resolvers = functionImplementations.computeIfAbsent(
50             functionName, k -&gt; new ArrayList&lt;&gt;());
51         resolvers.add(udfService.buildFunctionResolver(udf));
52         sqlExpressions.nodeCtx.functions().registerUdfFunctionImplementationsForSchema(
53             schema,
54             functionImplementations);
55     }
56     @Test
57     public void testOverloadingBuiltinFunctions() {
58         registerUserDefinedFunction(
59             DUMMY_LANG.name(),
60             "test",
61             "subtract",
62             DataTypes.INTEGER,
63             List.of(DataTypes.INTEGER, DataTypes.INTEGER),
64             "function subtract(a, b) { return a + b; }");
65         assertThat(
66             sqlExpressions.asSymbol("test.subtract(2::integer, 1::integer)"),
67             isLiteral(DummyFunction.RESULT));
68     }
69 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BalancedShardsAllocator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.cluster.routing.allocation.allocator;
2 import io.crate.common.collections.Tuple;
3 import org.apache.logging.log4j.LogManager;
4 import org.apache.logging.log4j.Logger;
5 import org.apache.lucene.util.ArrayUtil;
6 import org.apache.lucene.util.IntroSorter;
7 import org.elasticsearch.cluster.metadata.IndexMetadata;
8 import org.elasticsearch.cluster.metadata.Metadata;
9 import org.elasticsearch.cluster.routing.RoutingNode;
10 import org.elasticsearch.cluster.routing.RoutingNodes;
11 import org.elasticsearch.cluster.routing.ShardRouting;
12 import org.elasticsearch.cluster.routing.ShardRoutingState;
13 import org.elasticsearch.cluster.routing.UnassignedInfo;
14 import org.elasticsearch.cluster.routing.UnassignedInfo.AllocationStatus;
15 import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;
16 import org.elasticsearch.cluster.routing.allocation.AllocationDecision;
17 import org.elasticsearch.cluster.routing.allocation.MoveDecision;
18 import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;
19 import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;
20 import org.elasticsearch.cluster.routing.allocation.ShardAllocationDecision;
21 <a name="0"></a>import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;
22 import org.elasticsearch.cluster.routing.allocation.decider.Decision;
23 import org.elasticsearch.cluster.routing.allocation.decider.Decision.Type;
24 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.cluster.routing.allocation.decider.DiskThresholdDecider;
25 import org.elasticsearch.common.inject.Inject;
26 import org.elasticsearch.common.settings.ClusterSettings;
27 import org.elasticsearch.common.settings.Setting;
28 import org.elasticsearch.common.settings.Setting.Property;
29 import org.elasticsearch.common.settings.Settings;
30 import org.elasticsearch.gateway.PriorityComparator;
31 import java.util.ArrayList;
32 import java.util.Collections;
33 import java.util.Comparator;
34 import java.util.HashMap;
35 import java.util.HashSet;
36 import java.util.IdentityHashMap;
37 import java.util.Iterator;
38 import java.util.List;
39 import java.util.Map;
40 import java.util.Set;
41 import java.util.stream.StreamSupport;
42 import static org.elasticsearch.cluster.routing.ShardRoutingState.RELOCATING;
43 public class BalancedShardsAllocator implements ShardsAllocator {
44     private static final Logger LOGGER = LogManager.getLogger(BalancedShardsAllocator.class)</b></font>;
45     public static final Setting&lt;Float&gt; INDEX_BALANCE_FACTOR_SETTING =
46         Setting.floatSetting("cluster.routing.allocation.balance.index", 0.55f, 0.0f, Property.Dynamic, Property.NodeScope);
47     public static final Setting&lt;Float&gt; SHARD_BALANCE_FACTOR_SETTING =
48         Setting.floatSetting("cluster.routing.allocation.balance.shard", 0.45f, 0.0f, Property.Dynamic, Property.NodeScope);
49     public static final Setting&lt;Float&gt; THRESHOLD_SETTING =
50         Setting.floatSetting("cluster.routing.allocation.balance.threshold", 1.0f, 0.0f,
51             Property.Dynamic, Property.NodeScope);
52     private volatile WeightFunction weightFunction;
53     private volatile float threshold;
54     public BalancedShardsAllocator(Settings settings) {
55         this(settings, new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS));
56     }
57     @Inject
58     public BalancedShardsAllocator(Settings settings, ClusterSettings clusterSettings) {
59         setWeightFunction(INDEX_BALANCE_FACTOR_SETTING.get(settings), SHARD_BALANCE_FACTOR_SETTING.get(settings));
60         setThreshold(THRESHOLD_SETTING.get(settings));
61         clusterSettings.addSettingsUpdateConsumer(INDEX_BALANCE_FACTOR_SETTING, SHARD_BALANCE_FACTOR_SETTING, this::setWeightFunction);
62         clusterSettings.addSettingsUpdateConsumer(THRESHOLD_SETTING, this::setThreshold);
63     }
64     private void setWeightFunction(float indexBalance, float shardBalanceFactor) {
65         weightFunction = new WeightFunction(indexBalance, shardBalanceFactor);
66     }
67     private void setThreshold(float threshold) {
68         this.threshold = threshold;
69     }
70     @Override
71     public void allocate(RoutingAllocation allocation) {
72         if (allocation.routingNodes().size() == 0) {
73             failAllocationOfNewPrimaries(allocation);
74             return;
75         }
76         final Balancer balancer = new Balancer(LOGGER, allocation, weightFunction, threshold);
77         balancer.allocateUnassigned();
78         balancer.moveShards();
79         balancer.balance();
80     }
81     @Override
82     public ShardAllocationDecision decideShardAllocation(final ShardRouting shard, final RoutingAllocation allocation) {
83         Balancer balancer = new Balancer(LOGGER, allocation, weightFunction, threshold);
84         AllocateUnassignedDecision allocateUnassignedDecision = AllocateUnassignedDecision.NOT_TAKEN;
85         MoveDecision moveDecision = MoveDecision.NOT_TAKEN;
86         if (shard.unassigned()) {
87             allocateUnassignedDecision = balancer.decideAllocateUnassigned(shard, Set.of());
88         } else {
89             moveDecision = balancer.decideMove(shard);
90             if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.canRemain()) {
91                 MoveDecision rebalanceDecision = balancer.decideRebalance(shard);
92                 moveDecision = rebalanceDecision.withRemainDecision(moveDecision.getCanRemainDecision());
93             }
94         }
95         return new ShardAllocationDecision(allocateUnassignedDecision, moveDecision);
96     }
97     private void failAllocationOfNewPrimaries(RoutingAllocation allocation) {
98         RoutingNodes routingNodes = allocation.routingNodes();
99         assert routingNodes.size() == 0 : routingNodes;
100         final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator();
101         while (unassignedIterator.hasNext()) {
102             final ShardRouting shardRouting = unassignedIterator.next();
103             final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();
104             if (shardRouting.primary() &amp;&amp; unassignedInfo.getLastAllocationStatus() == AllocationStatus.NO_ATTEMPT) {
105                 unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),
106                         unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),
107                         unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(), AllocationStatus.DECIDERS_NO,
108                         unassignedInfo.getFailedNodeIds()),
109                     shardRouting.recoverySource(), allocation.changes());
110             }
111         }
112     }
113     private static class WeightFunction {
114         private final float theta0;
115         private final float theta1;
116         WeightFunction(float indexBalance, float shardBalance) {
117             float sum = indexBalance + shardBalance;
118             if (sum &lt;= 0.0f) {
119                 throw new IllegalArgumentException("Balance factors must sum to a value &gt; 0 but was: " + sum);
120             }
121             theta0 = shardBalance / sum;
122             theta1 = indexBalance / sum;
123         }
124         float weight(Balancer balancer, ModelNode node, String index) {
125             final float weightShard = node.numShards() - balancer.avgShardsPerNode();
126             final float weightIndex = node.numShards(index) - balancer.avgShardsPerNode(index);
127             return theta0 * weightShard + theta1 * weightIndex;
128         }
129     }
130     public static class Balancer {
131         private final Logger logger;
132         private final Map&lt;String, ModelNode&gt; nodes;
133         private final RoutingAllocation allocation;
134         private final RoutingNodes routingNodes;
135         private final WeightFunction weight;
136         private final float threshold;
137         private final Metadata metadata;
138         private final float avgShardsPerNode;
139         private final NodeSorter sorter;
140         public Balancer(Logger logger, RoutingAllocation allocation, WeightFunction weight, float threshold) {
141             this.logger = logger;
142             this.allocation = allocation;
143             this.weight = weight;
144             this.threshold = threshold;
145             this.routingNodes = allocation.routingNodes();
146             this.metadata = allocation.metadata();
147             avgShardsPerNode = ((float) metadata.getTotalNumberOfShards()) / routingNodes.size();
148             nodes = Collections.unmodifiableMap(buildModelFromAssigned());
149             sorter = newNodeSorter();
150         }
151         private ModelNode[] nodesArray() {
152             return nodes.values().toArray(new ModelNode[nodes.size()]);
153         }
154         public float avgShardsPerNode(String index) {
155             return ((float) metadata.index(index).getTotalNumberOfShards()) / nodes.size();
156         }
157         public float avgShardsPerNode() {
158             return avgShardsPerNode;
159         }
160         private NodeSorter newNodeSorter() {
161             return new NodeSorter(nodesArray(), weight, this);
162         }
163         private static float absDelta(float lower, float higher) {
164             assert higher &gt;= lower : higher + " lt " + lower + " but was expected to be gte";
165             return Math.abs(higher - lower);
166         }
167         private static boolean lessThan(float delta, float threshold) {
168             return delta &lt;= (threshold + 0.001f);
169         }
170         private void balance() {
171             if (logger.isTraceEnabled()) {
172                 logger.trace("Start balancing cluster");
173             }
174             if (allocation.hasPendingAsyncFetch()) {
175                 logger.debug("skipping rebalance due to in-flight shard/store fetches");
176                 return;
177             }
178             if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {
179                 logger.trace("skipping rebalance as it is disabled");
180                 return;
181             }
182             if (nodes.size() &lt; 2) {                 logger.trace("skipping rebalance as single node only");
183                 return;
184             }
185             balanceByWeights();
186         }
187         private MoveDecision decideRebalance(final ShardRouting shard) {
188             if (shard.started() == false) {
189                 return MoveDecision.NOT_TAKEN;
190             }
191             final Decision canRebalance = allocation.deciders().canRebalance(shard, allocation);
192             sorter.reset(shard.getIndexName());
193             ModelNode[] modelNodes = sorter.modelNodes;
194             final String currentNodeId = shard.currentNodeId();
195             ModelNode currentNode = null;
196             for (ModelNode node : modelNodes) {
197                 if (node.getNodeId().equals(currentNodeId)) {
198                     currentNode = node;
199                     break;
200                 }
201             }
202             assert currentNode != null : "currently assigned node could not be found";
203             final String idxName = shard.getIndexName();
204             final float currentWeight = weight.weight(this, currentNode, idxName);
205             final AllocationDeciders deciders = allocation.deciders();
206             Type rebalanceDecisionType = Type.NO;
207             ModelNode assignedNode = null;
208             List&lt;Tuple&lt;ModelNode, Decision&gt;&gt; betterBalanceNodes = new ArrayList&lt;&gt;();
209             List&lt;Tuple&lt;ModelNode, Decision&gt;&gt; sameBalanceNodes = new ArrayList&lt;&gt;();
210             List&lt;Tuple&lt;ModelNode, Decision&gt;&gt; worseBalanceNodes = new ArrayList&lt;&gt;();
211             for (ModelNode node : modelNodes) {
212                 if (node == currentNode) {
213                     continue;                 }
214                 final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation);
215                 final float nodeWeight = weight.weight(this, node, idxName);
216                 final boolean betterWeightThanCurrent = nodeWeight &lt;= currentWeight;
217                 boolean rebalanceConditionsMet = false;
218                 if (betterWeightThanCurrent) {
219                     float currentDelta = absDelta(nodeWeight, currentWeight);
220                     boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false;
221                     boolean betterWeightWithShardAdded = nodeWeight + 1.0f &lt; currentWeight;
222                     rebalanceConditionsMet = deltaAboveThreshold &amp;&amp; betterWeightWithShardAdded;
223                     if (rebalanceConditionsMet &amp;&amp; canAllocate.type().higherThan(rebalanceDecisionType)) {
224                         rebalanceDecisionType = canAllocate.type();
225                         assignedNode = node;
226                     }
227                 }
228                 Tuple&lt;ModelNode, Decision&gt; nodeResult = Tuple.tuple(node, canAllocate);
229                 if (rebalanceConditionsMet) {
230                     betterBalanceNodes.add(nodeResult);
231                 } else if (betterWeightThanCurrent) {
232                     sameBalanceNodes.add(nodeResult);
233                 } else {
234                     worseBalanceNodes.add(nodeResult);
235                 }
236             }
237             int weightRanking = 0;
238             List&lt;NodeAllocationResult&gt; nodeDecisions = new ArrayList&lt;&gt;(modelNodes.length - 1);
239             for (Tuple&lt;ModelNode, Decision&gt; result : betterBalanceNodes) {
240                 nodeDecisions.add(new NodeAllocationResult(
241                     result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)
242                 );
243             }
244             int currentNodeWeightRanking = ++weightRanking;
245             for (Tuple&lt;ModelNode, Decision&gt; result : sameBalanceNodes) {
246                 AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE;
247                 nodeDecisions.add(new NodeAllocationResult(
248                     result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)
249                 );
250             }
251             for (Tuple&lt;ModelNode, Decision&gt; result : worseBalanceNodes) {
252                 AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE;
253                 nodeDecisions.add(new NodeAllocationResult(
254                     result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)
255                 );
256             }
257             if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {
258                 AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :
259                                                             AllocationDecision.fromDecisionType(canRebalance.type());
260                 return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions);
261             } else {
262                 return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),
263                     assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions);
264             }
265         }
266         private void balanceByWeights() {
267             final AllocationDeciders deciders = allocation.deciders();
268             final ModelNode[] modelNodes = sorter.modelNodes;
269             final float[] weights = sorter.weights;
270             for (String index : buildWeightOrderedIndices()) {
271                 IndexMetadata indexMetadata = metadata.index(index);
272                 int relevantNodes = 0;
273                 for (int i = 0; i &lt; modelNodes.length; i++) {
274                     ModelNode modelNode = modelNodes[i];
275                     if (modelNode.getIndex(index) != null
276                         || deciders.canAllocate(indexMetadata, modelNode.getRoutingNode(), allocation).type() != Type.NO) {
277                         modelNodes[i] = modelNodes[relevantNodes];
278                         modelNodes[relevantNodes] = modelNode;
279                         relevantNodes++;
280                     }
281                 }
282                 if (relevantNodes &lt; 2) {
283                     continue;
284                 }
285                 sorter.reset(index, 0, relevantNodes);
286                 int lowIdx = 0;
287                 int highIdx = relevantNodes - 1;
288                 while (true) {
289                     final ModelNode minNode = modelNodes[lowIdx];
290                     final ModelNode maxNode = modelNodes[highIdx];
291                     advance_range:
292                     if (maxNode.numShards(index) &gt; 0) {
293                         final float delta = absDelta(weights[lowIdx], weights[highIdx]);
294                         if (lessThan(delta, threshold)) {
295                             if (lowIdx &gt; 0 &amp;&amp; highIdx - 1 &gt; 0                                 &amp;&amp; (absDelta(weights[0], weights[highIdx - 1]) &gt; threshold)                                 ) {
296                                 break advance_range;
297                             }
298                             if (logger.isTraceEnabled()) {
299                                 logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",
300                                         index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);
301                             }
302                             break;
303                         }
304                         if (logger.isTraceEnabled()) {
305                             logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",
306                                     maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);
307                         }
308                         if (delta &lt;= 1.0f) {
309                             logger.trace("Couldn't find shard to relocate from node [{}] to node [{}]",
310                                 maxNode.getNodeId(), minNode.getNodeId());
311                         } else if (tryRelocateShard(minNode, maxNode, index)) {
312                             weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);
313                             weights[highIdx] = sorter.weight(modelNodes[highIdx]);
314                             sorter.sort(0, relevantNodes);
315                             lowIdx = 0;
316                             highIdx = relevantNodes - 1;
317                             continue;
318                         }
319                     }
320                     if (lowIdx &lt; highIdx - 1) {
321                         lowIdx++;
322                     } else if (lowIdx &gt; 0) {
323                         lowIdx = 0;
324                         highIdx--;
325                     } else {
326                         break;
327                     }
328                 }
329             }
330         }
331         private String[] buildWeightOrderedIndices() {
332             final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class);
333             final float[] deltas = new float[indices.length];
334             for (int i = 0; i &lt; deltas.length; i++) {
335                 sorter.reset(indices[i]);
336                 deltas[i] = sorter.delta();
337             }
338             new IntroSorter() {
339                 float pivotWeight;
340                 @Override
341                 protected void swap(int i, int j) {
342                     final String tmpIdx = indices[i];
343                     indices[i] = indices[j];
344                     indices[j] = tmpIdx;
345                     final float tmpDelta = deltas[i];
346                     deltas[i] = deltas[j];
347                     deltas[j] = tmpDelta;
348                 }
349                 @Override
350                 protected int compare(int i, int j) {
351                     return Float.compare(deltas[j], deltas[i]);
352                 }
353                 @Override
354                 protected void setPivot(int i) {
355                     pivotWeight = deltas[i];
356                 }
357                 @Override
358                 protected int comparePivot(int j) {
359                     return Float.compare(deltas[j], pivotWeight);
360                 }
361             }.sort(0, deltas.length);
362             return indices;
363         }
364         public void moveShards() {
365             for (Iterator&lt;ShardRouting&gt; it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) {
366                 ShardRouting shardRouting = it.next();
367                 final MoveDecision moveDecision = decideMove(shardRouting);
368                 if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.forceMove()) {
369                     final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());
370                     final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());
371                     sourceNode.removeShard(shardRouting);
372                     Tuple&lt;ShardRouting, ShardRouting&gt; relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),
373                         allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());
374                     targetNode.addShard(relocatingShards.v2());
375                     if (logger.isTraceEnabled()) {
376                         logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode());
377                     }
378                 } else if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.canRemain() == false) {
379                     logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id());
380                 }
381             }
382         }
383         public MoveDecision decideMove(final ShardRouting shardRouting) {
384             if (shardRouting.started() == false) {
385                 return MoveDecision.NOT_TAKEN;
386             }
387             final boolean explain = allocation.debugDecision();
388             final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());
389             assert sourceNode != null &amp;&amp; sourceNode.containsShard(shardRouting);
390             RoutingNode routingNode = sourceNode.getRoutingNode();
391             Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);
392             if (canRemain.type() != Decision.Type.NO) {
393                 return MoveDecision.stay(canRemain);
394             }
395             sorter.reset(shardRouting.getIndexName());
396             Type bestDecision = Type.NO;
397             RoutingNode targetNode = null;
398             final List&lt;NodeAllocationResult&gt; nodeExplanationMap = explain ? new ArrayList&lt;&gt;() : null;
399             int weightRanking = 0;
400             for (ModelNode currentNode : sorter.modelNodes) {
401                 if (currentNode != sourceNode) {
402                     RoutingNode target = currentNode.getRoutingNode();
403                     Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);
404                     if (explain) {
405                         nodeExplanationMap.add(new NodeAllocationResult(
406                             currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));
407                     }
408                     if (allocationDecision.type().higherThan(bestDecision)) {
409                         bestDecision = allocationDecision.type();
410                         if (bestDecision == Type.YES) {
411                             targetNode = target;
412                             if (explain == false) {
413                                 break;
414                             }
415                         }
416                     }
417                 }
418             }
419             return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),
420                 targetNode != null ? targetNode.node() : null, nodeExplanationMap);
421         }
422         private Map&lt;String, ModelNode&gt; buildModelFromAssigned() {
423             Map&lt;String, ModelNode&gt; nodes = new HashMap&lt;&gt;();
424             for (RoutingNode rn : routingNodes) {
425                 ModelNode node = new ModelNode(rn);
426                 nodes.put(rn.nodeId(), node);
427                 for (ShardRouting shard : rn) {
428                     assert rn.nodeId().equals(shard.currentNodeId());
429                     if (shard.state() != RELOCATING) {
430                         node.addShard(shard);
431                         if (logger.isTraceEnabled()) {
432                             logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId());
433                         }
434                     }
435                 }
436             }
437             return nodes;
438         }
439         private void allocateUnassigned() {
440             RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned();
441             assert !nodes.isEmpty();
442             if (logger.isTraceEnabled()) {
443                 logger.trace("Start allocating unassigned shards");
444             }
445             if (unassigned.isEmpty()) {
446                 return;
447             }
448             final AllocationDeciders deciders = allocation.deciders();
449             final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation);
450             final Comparator&lt;ShardRouting&gt; comparator = (o1, o2) -&gt; {
451                 if (o1.primary() ^ o2.primary()) {
452                     return o1.primary() ? -1 : 1;
453                 }
454                 final int indexCmp;
455                 if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {
456                     return o1.getId() - o2.getId();
457                 }
458                 final int secondary = secondaryComparator.compare(o1, o2);
459                 return secondary == 0 ? indexCmp : secondary;
460             };
461             ShardRouting[] primary = unassigned.drain();
462             ShardRouting[] secondary = new ShardRouting[primary.length];
463             int secondaryLength = 0;
464             int primaryLength = primary.length;
465             ArrayUtil.timSort(primary, comparator);
466             final Set&lt;ModelNode&gt; throttledNodes = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());
467             do {
468                 for (int i = 0; i &lt; primaryLength; i++) {
469                     ShardRouting shard = primary[i];
470                     AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes);
471                     final String assignedNodeId = allocationDecision.getTargetNode() != null ?
472                                                       allocationDecision.getTargetNode().getId() : null;
473                     final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null;
474                     if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {
475                         if (logger.isTraceEnabled()) {
476                             logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId());
477                         }
478                         final long shardSize = DiskThresholdDecider.getExpectedShardSize(
479                             shard,
480                             ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE,
481                             allocation.clusterInfo(),
482                             allocation.metadata(),
483                             allocation.routingTable()
484                         );
485                         shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes());
486                         minNode.addShard(shard);
487                         if (!shard.primary()) {
488                             while (i &lt; primaryLength - 1 &amp;&amp; comparator.compare(primary[i], primary[i + 1]) == 0) {
489                                 secondary[secondaryLength++] = primary[++i];
490                             }
491                         }
492                     } else {
493                         if (logger.isTraceEnabled()) {
494                             logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,
495                                 allocationDecision.getAllocationStatus());
496                         }
497                         if (minNode != null) {
498                             assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED;
499                             final long shardSize = DiskThresholdDecider.getExpectedShardSize(
500                                 shard,
501                                 ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE,
502                                 allocation.clusterInfo(),
503                                 allocation.metadata(),
504                                 allocation.routingTable()
505                             );
506                             minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize));
507                             final RoutingNode node = minNode.getRoutingNode();
508                             final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type();
509                             if (nodeLevelDecision != Type.YES) {
510                                 if (logger.isTraceEnabled()) {
511                                     logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,
512                                         allocationDecision.getAllocationStatus());
513                                 }
514                                 assert nodeLevelDecision == Type.NO;
515                                 throttledNodes.add(minNode);
516                             }
517                         } else {
518                             if (logger.isTraceEnabled()) {
519                                 logger.trace("No Node found to assign shard [{}]", shard);
520                             }
521                         }
522                         unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes());
523                         if (!shard.primary()) {                             while (i &lt; primaryLength - 1 &amp;&amp; comparator.compare(primary[i], primary[i + 1]) == 0) {
524                                 unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes());
525                             }
526                         }
527                     }
528                 }
529                 primaryLength = secondaryLength;
530                 ShardRouting[] tmp = primary;
531                 primary = secondary;
532                 secondary = tmp;
533                 secondaryLength = 0;
534             } while (primaryLength &gt; 0);
535         }
536         private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set&lt;ModelNode&gt; throttledNodes) {
537             if (shard.assignedToNode()) {
538                 return AllocateUnassignedDecision.NOT_TAKEN;
539             }
540             final boolean explain = allocation.debugDecision();
541             Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation);
542             if (shardLevelDecision.type() == Type.NO &amp;&amp; explain == false) {
543                 return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null);
544             }
545             float minWeight = Float.POSITIVE_INFINITY;
546             ModelNode minNode = null;
547             Decision decision = null;
548             if (throttledNodes.size() &gt;= nodes.size() &amp;&amp; explain == false) {
549                 return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null);
550             }
551             Map&lt;String, NodeAllocationResult&gt; nodeExplanationMap = explain ? new HashMap&lt;&gt;() : null;
552             List&lt;Tuple&lt;String, Float&gt;&gt; nodeWeights = explain ? new ArrayList&lt;&gt;() : null;
553             for (ModelNode node : nodes.values()) {
554                 if ((throttledNodes.contains(node) || node.containsShard(shard)) &amp;&amp; explain == false) {
555                     continue;
556                 }
557                 float currentWeight = weight.weight(this, node, shard.getIndexName());
558                 if (currentWeight &gt; minWeight &amp;&amp; explain == false) {
559                     continue;
560                 }
561                 Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation);
562                 if (explain) {
563                     nodeExplanationMap.put(node.getNodeId(),
564                         new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0));
565                     nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight));
566                 }
567                 if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {
568                     final boolean updateMinNode;
569                     if (currentWeight == minWeight) {
570                         if (decision != null &amp;&amp; currentDecision.type() == decision.type()) {
571                             final int repId = shard.id();
572                             final int nodeHigh = node.highestPrimary(shard.index().getName());
573                             final int minNodeHigh = minNode.highestPrimary(shard.getIndexName());
574                             updateMinNode = ((((nodeHigh &gt; repId &amp;&amp; minNodeHigh &gt; repId)
575                                                    || (nodeHigh &lt; repId &amp;&amp; minNodeHigh &lt; repId))
576                                                   &amp;&amp; (nodeHigh &lt; minNodeHigh))
577                                                  || (nodeHigh &gt; repId &amp;&amp; minNodeHigh &lt; repId));
578                         } else {
579                             updateMinNode = currentDecision.type() == Type.YES;
580                         }
581                     } else {
582                         updateMinNode = true;
583                     }
584                     if (updateMinNode) {
585                         minNode = node;
586                         minWeight = currentWeight;
587                         decision = currentDecision;
588                     }
589                 }
590             }
591             if (decision == null) {
592                 decision = Decision.NO;
593             }
594             List&lt;NodeAllocationResult&gt; nodeDecisions = null;
595             if (explain) {
596                 nodeDecisions = new ArrayList&lt;&gt;();
597                 nodeWeights.sort((nodeWeight1, nodeWeight2) -&gt; Float.compare(nodeWeight1.v2(), nodeWeight2.v2()));
598                 int weightRanking = 0;
599                 for (Tuple&lt;String, Float&gt; nodeWeight : nodeWeights) {
600                     NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1());
601                     nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking));
602                 }
603             }
604             return AllocateUnassignedDecision.fromDecision(
605                 decision,
606                 minNode != null ? minNode.routingNode.node() : null,
607                 nodeDecisions
608             );
609         }
610         private static final Comparator&lt;ShardRouting&gt; BY_DESCENDING_SHARD_ID = Comparator.comparing(ShardRouting::shardId).reversed();
611         private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx) {
612             final ModelIndex index = maxNode.getIndex(idx);
613             if (index != null) {
614                 logger.trace("Try relocating shard of [{}] from [{}] to [{}]", idx, maxNode.getNodeId(), minNode.getNodeId());
615                 final Iterable&lt;ShardRouting&gt; shardRoutings = StreamSupport.stream(index.spliterator(), false)
616                     .filter(ShardRouting::started)                     .filter(maxNode::containsShard)
617                     .sorted(BY_DESCENDING_SHARD_ID)                     ::iterator;
618                 final AllocationDeciders deciders = allocation.deciders();
619                 for (ShardRouting shard : shardRoutings) {
620                     final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);
621                     if (rebalanceDecision.type() == Type.NO) {
622                         continue;
623                     }
624                     final Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);
625                     if (allocationDecision.type() == Type.NO) {
626                         continue;
627                     }
628                     final Decision decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);
629                     maxNode.removeShard(shard);
630                     long shardSize = allocation.clusterInfo().getShardSize(shard, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);
631                     if (decision.type() == Type.YES) {
632                         logger.debug("Relocate [{}] from [{}] to [{}]", shard, maxNode.getNodeId(), minNode.getNodeId());
633                         minNode.addShard(routingNodes.relocateShard(shard, minNode.getNodeId(), shardSize, allocation.changes()).v1());
634                         return true;
635                     } else {
636                         logger.debug("Simulate relocation of [{}] from [{}] to [{}]", shard, maxNode.getNodeId(), minNode.getNodeId());
637                         assert decision.type() == Type.THROTTLE;
638                         minNode.addShard(shard.relocate(minNode.getNodeId(), shardSize));
639                         return false;
640                     }
641                 }
642             }
643             if (logger.isTraceEnabled()) {
644                 logger.trace("No shards of [{}] can relocate from [{}] to [{}]", idx, maxNode.getNodeId(), minNode.getNodeId());
645             }
646             return false;
647         }
648     }
649     static class ModelNode implements Iterable&lt;ModelIndex&gt; {
650         private final Map&lt;String, ModelIndex&gt; indices = new HashMap&lt;&gt;();
651         private int numShards = 0;
652         private final RoutingNode routingNode;
653         ModelNode(RoutingNode routingNode) {
654             this.routingNode = routingNode;
655         }
656         public ModelIndex getIndex(String indexId) {
657             return indices.get(indexId);
658         }
659         public String getNodeId() {
660             return routingNode.nodeId();
661         }
662         public RoutingNode getRoutingNode() {
663             return routingNode;
664         }
665         public int numShards() {
666             return numShards;
667         }
668         public int numShards(String idx) {
669             ModelIndex index = indices.get(idx);
670             return index == null ? 0 : index.numShards();
671         }
672         public int highestPrimary(String index) {
673             ModelIndex idx = indices.get(index);
674             if (idx != null) {
675                 return idx.highestPrimary();
676             }
677             return -1;
678         }
679         public void addShard(ShardRouting shard) {
680             ModelIndex index = indices.get(shard.getIndexName());
681             if (index == null) {
682                 index = new ModelIndex(shard.getIndexName());
683                 indices.put(index.getIndexId(), index);
684             }
685             index.addShard(shard);
686             numShards++;
687         }
688         public void removeShard(ShardRouting shard) {
689             ModelIndex index = indices.get(shard.getIndexName());
690             if (index != null) {
691                 index.removeShard(shard);
692                 if (index.numShards() == 0) {
693                     indices.remove(shard.getIndexName());
694                 }
695             }
696             numShards--;
697         }
698         @Override
699         public String toString() {
700             StringBuilder sb = new StringBuilder();
701             sb.append("Node(").append(routingNode.nodeId()).append(")");
702             return sb.toString();
703         }
704         @Override
705         public Iterator&lt;ModelIndex&gt; iterator() {
706             return indices.values().iterator();
707         }
708         public boolean containsShard(ShardRouting shard) {
709             ModelIndex index = getIndex(shard.getIndexName());
710             return index == null ? false : index.containsShard(shard);
711         }
712     }
713     static final class ModelIndex implements Iterable&lt;ShardRouting&gt; {
714         private final String id;
715         private final Set&lt;ShardRouting&gt; shards = new HashSet&lt;&gt;(4);         private int highestPrimary = -1;
716         ModelIndex(String id) {
717             this.id = id;
718         }
719         public int highestPrimary() {
720             if (highestPrimary == -1) {
721                 int maxId = -1;
722                 for (ShardRouting shard : shards) {
723                     if (shard.primary()) {
724                         maxId = Math.max(maxId, shard.id());
725                     }
726                 }
727                 return highestPrimary = maxId;
728             }
729             return highestPrimary;
730         }
731         public String getIndexId() {
732             return id;
733         }
734         public int numShards() {
735             return shards.size();
736         }
737         @Override
738         public Iterator&lt;ShardRouting&gt; iterator() {
739             return shards.iterator();
740         }
741         public void removeShard(ShardRouting shard) {
742             highestPrimary = -1;
743             assert shards.contains(shard) : "Shard not allocated on current node: " + shard;
744             shards.remove(shard);
745         }
746         public void addShard(ShardRouting shard) {
747             highestPrimary = -1;
748             assert !shards.contains(shard) : "Shard already allocated on current node: " + shard;
749             shards.add(shard);
750         }
751         public boolean containsShard(ShardRouting shard) {
752             return shards.contains(shard);
753         }
754     }
755     static final class NodeSorter extends IntroSorter {
756         final ModelNode[] modelNodes;
757         final float[] weights;
758         private final WeightFunction function;
759         private String index;
760         private final Balancer balancer;
761         private float pivotWeight;
762         NodeSorter(ModelNode[] modelNodes, WeightFunction function, Balancer balancer) {
763             this.function = function;
764             this.balancer = balancer;
765             this.modelNodes = modelNodes;
766             weights = new float[modelNodes.length];
767         }
768         public void reset(String index, int from, int to) {
769             this.index = index;
770             for (int i = from; i &lt; to; i++) {
771                 weights[i] = weight(modelNodes[i]);
772             }
773             sort(from, to);
774         }
775         public void reset(String index) {
776             reset(index, 0, modelNodes.length);
777         }
778         public float weight(ModelNode node) {
779             return function.weight(balancer, node, index);
780         }
781         @Override
782         protected void swap(int i, int j) {
783             final ModelNode tmpNode = modelNodes[i];
784             modelNodes[i] = modelNodes[j];
785             modelNodes[j] = tmpNode;
786             final float tmpWeight = weights[i];
787             weights[i] = weights[j];
788             weights[j] = tmpWeight;
789         }
790         @Override
791         protected int compare(int i, int j) {
792             return Float.compare(weights[i], weights[j]);
793         }
794         @Override
795         protected void setPivot(int i) {
796             pivotWeight = weights[i];
797         }
798         @Override
799         protected int comparePivot(int j) {
800             return Float.compare(pivotWeight, weights[j]);
801         }
802         public float delta() {
803             return weights[weights.length - 1] - weights[0];
804         }
805     }
806 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
