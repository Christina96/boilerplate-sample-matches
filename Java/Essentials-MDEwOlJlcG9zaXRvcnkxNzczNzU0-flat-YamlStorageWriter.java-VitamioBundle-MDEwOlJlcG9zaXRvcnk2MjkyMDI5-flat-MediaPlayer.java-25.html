
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-YamlStorageWriter.java</h3>
            <pre><code>1  package com.earth2me.essentials.storage;
2  import java.io.PrintWriter;
3  import java.lang.reflect.Field;
4  import java.lang.reflect.Modifier;
5  import java.util.Collection;
6  import java.util.Collections;
7  import java.util.Locale;
8  import java.util.Map;
9  import java.util.Map.Entry;
10  import java.util.logging.Level;
11  import java.util.logging.Logger;
12  import java.util.regex.Pattern;
13  import org.bukkit.Location;
14  import org.bukkit.Material;
15  import org.bukkit.enchantments.Enchantment;
16  import org.bukkit.inventory.ItemStack;
17  import org.bukkit.material.MaterialData;
18  import org.yaml.snakeyaml.Yaml;
19  public class YamlStorageWriter implements IStorageWriter
20  {
21  	private transient static final Pattern NON_WORD_PATTERN = Pattern.compile(&quot;\\W&quot;);
22  	private transient static final Yaml YAML = new Yaml();
23  	private transient final PrintWriter writer;
24  	public YamlStorageWriter(final PrintWriter writer)
25  	{
26  		this.writer = writer;
27  	}
28  	@Override
29  	public void save(final StorageObject object)
30  	{
31  		try
32  		{
33  			writeToFile(object, 0, object.getClass());
34  		}
35  		catch (IllegalArgumentException ex)
36  		{
37  			Logger.getLogger(YamlStorageWriter.class.getName()).log(Level.SEVERE, null, ex);
38  		}
39  		catch (IllegalAccessException ex)
40  		{
41  			Logger.getLogger(YamlStorageWriter.class.getName()).log(Level.SEVERE, null, ex);
42  		}
43  	}
44  	private void writeToFile(final Object object, final int depth, final Class clazz) throws IllegalAccessException
45  	{
46  		for (Field field : clazz.getDeclaredFields())
47  		{
48  			final int modifier = field.getModifiers();
49  			if (Modifier.isPrivate(modifier) &amp;&amp; !Modifier.isTransient(modifier) &amp;&amp; !Modifier.isStatic(modifier))
50  			{
51  				field.setAccessible(true);
52  				final Object data = field.get(object);
53  				if (writeKey(field, depth, data))
54  				{
55  					continue;
56  				}
57  				if (data instanceof StorageObject)
58  				{
59  					writer.println();
60  					writeToFile(data, depth + 1, data.getClass());
61  				}
62  				else if (data instanceof Map)
63  				{
64  					writeMap((Map&lt;Object, Object&gt;)data, depth + 1);
65  				}
66  				else if (data instanceof Collection)
67  				{
68  					writeCollection((Collection&lt;Object&gt;)data, depth + 1);
69  				}
70  				else if (data instanceof Location)
71  				{
72  					writeLocation((Location)data, depth + 1);
73  				}
74  				else
75  				{
76  					writeScalar(data);
77  					writer.println();
78  				}
79  			}
80  		}
81  	}
82  	private boolean writeKey(final Field field, final int depth, final Object data)
83  	{
84  		final boolean commentPresent = writeComment(field, depth);
85  		if (data == null &amp;&amp; !commentPresent)
86  		{
87  			return true;
88  		}
89  		writeIndention(depth);
90  		if (data == null &amp;&amp; commentPresent)
91  		{
92  			writer.print(&#x27;#&#x27;);
93  		}
94  		final String name = field.getName();
95  		writer.print(name);
96  		writer.print(&quot;: &quot;);
97  		if (data == null &amp;&amp; commentPresent)
98  		{
99  			writer.println();
100  			writer.println();
101  			return true;
102  		}
103  		return false;
104  	}
105  	private boolean writeComment(final Field field, final int depth)
106  	{
107  		final boolean commentPresent = field.isAnnotationPresent(Comment.class);
108  		if (commentPresent)
109  		{
110  			final Comment comments = field.getAnnotation(Comment.class);
111  			for (String comment : comments.value())
112  			{
113  				final String trimmed = comment.trim();
114  				if (trimmed.isEmpty())
115  				{
116  					continue;
117  				}
118  				writeIndention(depth);
119  				writer.print(&quot;# &quot;);
120  				writer.print(trimmed);
121  				writer.println();
122  			}
123  		}
124  		return commentPresent;
125  	}
126  	private void writeCollection(final Collection&lt;Object&gt; data, final int depth) throws IllegalAccessException
127  	{
128  		writer.println();
129  		if (data.isEmpty())
130  		{
131  			writer.println();
132  		}
133  		for (Object entry : data)
134  		{
135  			if (entry != null)
136  			{
137  				writeIndention(depth);
138  				writer.print(&quot;- &quot;);
139  				if (entry instanceof StorageObject)
140  				{
141  					writer.println();
142  					writeToFile(entry, depth + 1, entry.getClass());
143  				}
144  				else if (entry instanceof Location)
145  				{
146  					writeLocation((Location)entry, depth + 1);
147  				}
148  				else
149  				{
150  					writeScalar(entry);
151  				}
152  			}
153  		}
154  		writer.println();
155  	}
156  	private void writeMap(final Map&lt;Object, Object&gt; data, final int depth) throws IllegalArgumentException, IllegalAccessException
157  	{
158  		writer.println();
159  		if (data.isEmpty())
160  		{
161  			writer.println();
162  		}
163  		for (Entry&lt;Object, Object&gt; entry : data.entrySet())
164  		{
165  			final Object value = entry.getValue();
166  			if (value != null)
167  			{
168  				writeIndention(depth);
169  				writeKey(entry.getKey());
170  				writer.print(&quot;: &quot;);
171  				if (value instanceof StorageObject)
172  				{
173  					writer.println();
174  					writeToFile(value, depth + 1, value.getClass());
175  				}
176  				else if (value instanceof Collection)
177  				{
178  					writeCollection((Collection&lt;Object&gt;)value, depth + 1);
179  				}
180  				else if (value instanceof Location)
181  				{
182  					writeLocation((Location)value, depth + 1);
183  				}
184  				else
185  				{
186  					writeScalar(value);
187  					writer.println();
188  				}
189  			}
190  		}
191  	}
192  	private void writeIndention(final int depth)
193  	{
194  		for (int i = 0; i &lt; depth; i++)
195  		{
196  			writer.print(&quot;  &quot;);
197  		}
198  	}
199  	private void writeScalar(final Object data)
200  	{
201  		if (data instanceof String || data instanceof Boolean || data instanceof Number)
202  		{
203  			synchronized (YAML)
204  			{
205  				YAML.dumpAll(Collections.singletonList(data).iterator(), writer);
206  			}
207  		}
208  		else if (data instanceof Material)
209  		{
210  			writeMaterial(data);
211  			writer.println();
212  		}
213  		else if (data instanceof MaterialData)
214  		{
215  			writeMaterialData(data);
216  			writer.println();
217  		}
218  		else if (data instanceof ItemStack)
219  		{
220  			writeItemStack(data);
221  			writer.println();
222  		}
223  		else if (data instanceof EnchantmentLevel)
224  		{
<span onclick='openModal()' class='match'>225  			writeEnchantmentLevel(data);
226  			writer.println();
227  		}
228  		else
229  		{
230  			throw new UnsupportedOperationException();
</span>231  		}
232  	}
233  	private void writeKey(final Object data)
234  	{
235  		if (data instanceof String || data instanceof Boolean || data instanceof Number)
236  		{
237  			String output = data.toString();
238  			if (NON_WORD_PATTERN.matcher(output).find())
239  			{
240  				writer.print(&#x27;&quot;&#x27;);
241  				writer.print(output.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));
242  				writer.print(&#x27;&quot;&#x27;);
243  			}
244  			else
245  			{
246  				writer.print(output);
247  			}
248  		}
249  		else if (data instanceof Material)
250  		{
251  			writeMaterial(data);
252  		}
253  		else if (data instanceof MaterialData)
254  		{
255  			writeMaterialData(data);
256  		}
257  		else if (data instanceof EnchantmentLevel)
258  		{
259  			writeEnchantmentLevel(data);
260  		}
261  		else
262  		{
263  			throw new UnsupportedOperationException();
264  		}
265  	}
266  	private void writeMaterial(final Object data)
267  	{
268  		writer.print(data.toString().toLowerCase(Locale.ENGLISH));
269  	}
270  	private void writeMaterialData(final Object data)
271  	{
272  		final MaterialData matData = (MaterialData)data;
273  		writeMaterial(matData.getItemType());
274  		if (matData.getData() &gt; 0)
275  		{
276  			writer.print(&#x27;:&#x27;);
277  			writer.print(matData.getData());
278  		}
279  	}
280  	private void writeItemStack(final Object data)
281  	{
282  		final ItemStack itemStack = (ItemStack)data;
283  		writeMaterialData(itemStack.getData());
284  		writer.print(&#x27; &#x27;);
285  		writer.print(itemStack.getAmount());
286  		for (Entry&lt;Enchantment, Integer&gt; entry : itemStack.getEnchantments().entrySet())
287  		{
288  			writer.print(&#x27; &#x27;);
289  			writeEnchantmentLevel(entry);
290  		}
291  	}
292  	private void writeEnchantmentLevel(Object data)
293  	{
294  		final Entry&lt;Enchantment, Integer&gt; enchLevel = (Entry&lt;Enchantment, Integer&gt;)data;
295  		writer.print(enchLevel.getKey().getName().toLowerCase(Locale.ENGLISH));
296  		writer.print(&#x27;:&#x27;);
297  		writer.print(enchLevel.getValue());
298  	}
299  	private void writeLocation(final Location entry, final int depth)
300  	{
301  		writer.println();
302  		writeIndention(depth);
303  		writer.print(&quot;world: &quot;);
304  		writeScalar(entry.getWorld().getName());
305  		writeIndention(depth);
306  		writer.print(&quot;x: &quot;);
307  		writeScalar(entry.getX());
308  		writeIndention(depth);
309  		writer.print(&quot;y: &quot;);
310  		writeScalar(entry.getY());
311  		writeIndention(depth);
312  		writer.print(&quot;z: &quot;);
313  		writeScalar(entry.getZ());
314  		writeIndention(depth);
315  		writer.print(&quot;yaw: &quot;);
316  		writeScalar(entry.getYaw());
317  		writeIndention(depth);
318  		writer.print(&quot;pitch: &quot;);
319  		writeScalar(entry.getPitch());
320  	}
321  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.annotation.SuppressLint;
3  import android.content.ContentResolver;
4  import android.content.Context;
5  import android.content.res.AssetFileDescriptor;
6  import android.graphics.Bitmap;
7  import android.graphics.Canvas;
8  import android.media.AudioFormat;
9  import android.media.AudioManager;
10  import android.media.AudioTrack;
11  import android.net.Uri;
12  import android.os.Build;
13  import android.os.Bundle;
14  import android.os.Handler;
15  import android.os.Looper;
16  import android.os.Message;
17  import android.os.PowerManager;
18  import android.text.TextUtils;
19  import android.util.SparseArray;
20  import android.view.Surface;
21  import android.view.SurfaceHolder;
22  import io.vov.vitamio.utils.FileUtils;
23  import io.vov.vitamio.utils.Log;
24  import java.io.File;
25  import java.io.FileDescriptor;
26  import java.io.FileInputStream;
27  import java.io.IOException;
28  import java.io.UnsupportedEncodingException;
29  import java.nio.ByteBuffer;
30  import java.nio.charset.Charset;
31  import java.util.HashMap;
32  import java.util.Map;
33  import java.util.concurrent.atomic.AtomicBoolean;
34  public class MediaPlayer {
35    public static final int CACHE_TYPE_NOT_AVAILABLE = 1;
36    public static final int CACHE_TYPE_START = 2;
37    public static final int CACHE_TYPE_UPDATE = 3;
38    public static final int CACHE_TYPE_SPEED = 4;
39    public static final int CACHE_TYPE_COMPLETE = 5;
40    public static final int CACHE_INFO_NO_SPACE = 1;
41    public static final int CACHE_INFO_STREAM_NOT_SUPPORT = 2;
42    public static final int MEDIA_ERROR_UNKNOWN = 1;
43    public static final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;
44    public static final int MEDIA_ERROR_IO = -5;
45    public static final int MEDIA_ERROR_MALFORMED = -1007;
46    public static final int MEDIA_ERROR_UNSUPPORTED = -1010;
47    public static final int MEDIA_ERROR_TIMED_OUT = -110;
48    public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700;
49    public static final int MEDIA_INFO_BUFFERING_START = 701;
50    public static final int MEDIA_INFO_BUFFERING_END = 702;
51    public static final int MEDIA_INFO_NOT_SEEKABLE = 801;
52    public static final int MEDIA_INFO_DOWNLOAD_RATE_CHANGED = 901;
53    public static final int VIDEOQUALITY_LOW = -16;
54    public static final int VIDEOQUALITY_MEDIUM = 0;
55    public static final int VIDEOQUALITY_HIGH = 16;
56    public static final int VIDEOCHROMA_RGB565 = 0;
57    public static final int VIDEOCHROMA_RGBA = 1;
58    public static final int SUBTITLE_INTERNAL = 0;
59    public static final int SUBTITLE_EXTERNAL = 1;
60    public static final String[] SUB_TYPES = {&quot;.srt&quot;, &quot;.ssa&quot;, &quot;.smi&quot;, &quot;.txt&quot;, &quot;.sub&quot;, &quot;.ass&quot;, &quot;.webvtt&quot;};
61    private static final int MEDIA_NOP = 0;
62    private static final int MEDIA_PREPARED = 1;
63    private static final int MEDIA_PLAYBACK_COMPLETE = 2;
64    private static final int MEDIA_BUFFERING_UPDATE = 3;
65    private static final int MEDIA_SEEK_COMPLETE = 4;
66    private static final int MEDIA_SET_VIDEO_SIZE = 5;
67    private static final int MEDIA_ERROR = 100;
68    private static final int MEDIA_INFO = 200;
69    private static final int MEDIA_CACHE = 300;
70    private static final int MEDIA_HW_ERROR = 400;
71    private static final int MEDIA_TIMED_TEXT = 1000;
72    private static final int MEDIA_CACHING_UPDATE = 2000;
73    private static final String MEDIA_CACHING_SEGMENTS = &quot;caching_segment&quot;;
74    private static final String MEDIA_CACHING_TYPE = &quot;caching_type&quot;;
75    private static final String MEDIA_CACHING_INFO = &quot;caching_info&quot;;
76    private static final String MEDIA_SUBTITLE_STRING = &quot;sub_string&quot;;
77    private static final String MEDIA_SUBTITLE_BYTES = &quot;sub_bytes&quot;;
78    private static final String MEDIA_SUBTITLE_TYPE = &quot;sub_type&quot;;
79    private static final int SUBTITLE_TEXT = 0;
80    private static final int SUBTITLE_BITMAP = 1;
81    private static AtomicBoolean NATIVE_OMX_LOADED = new AtomicBoolean(false);
82    private Context mContext;
83    private Surface mSurface;
84    private SurfaceHolder mSurfaceHolder;
85    private EventHandler mEventHandler;
86    private PowerManager.WakeLock mWakeLock = null;
87    private boolean mScreenOnWhilePlaying;
88    private boolean mStayAwake;
89    private Metadata mMeta;
90    private TrackInfo[] mInbandTracks;
91    private TrackInfo mOutOfBandTracks;
92    private AssetFileDescriptor mFD = null;
93    private OnHWRenderFailedListener mOnHWRenderFailedListener;
94    private OnPreparedListener mOnPreparedListener;
95    private OnCompletionListener mOnCompletionListener;
96    private OnBufferingUpdateListener mOnBufferingUpdateListener;
97    private OnCachingUpdateListener mOnCachingUpdateListener;
98    private OnSeekCompleteListener mOnSeekCompleteListener;
99    private OnVideoSizeChangedListener mOnVideoSizeChangedListener;
100    private OnErrorListener mOnErrorListener;
101    private OnInfoListener mOnInfoListener;
102    private OnTimedTextListener mOnTimedTextListener;
103    private AudioTrack mAudioTrack;
104    private int mAudioTrackBufferSize;
105    private Surface mLocalSurface;
106    private Bitmap mBitmap;
107    private ByteBuffer mByteBuffer;
108    public MediaPlayer(Context ctx) {
109      this(ctx, false);
110    }
111    public MediaPlayer(Context ctx, boolean preferHWDecoder) {
112      mContext = ctx;
113      String LIB_ROOT = Vitamio.getLibraryPath();
114      if (preferHWDecoder) {
115        if (!NATIVE_OMX_LOADED.get()) {
116          if (Build.VERSION.SDK_INT &gt; 17)
117            loadOMX_native(LIB_ROOT + &quot;libOMX.18.so&quot;);
118          else if (Build.VERSION.SDK_INT &gt; 13)
119            loadOMX_native(LIB_ROOT + &quot;libOMX.14.so&quot;);
120          else if (Build.VERSION.SDK_INT &gt; 10)
121            loadOMX_native(LIB_ROOT + &quot;libOMX.11.so&quot;);
122          else
123            loadOMX_native(LIB_ROOT + &quot;libOMX.9.so&quot;);
124          NATIVE_OMX_LOADED.set(true);
125        }
126      } else {
127        try {
128          unloadOMX_native();
129        } catch (UnsatisfiedLinkError e) {
130          Log.e(&quot;unloadOMX failed %s&quot;, e.toString());
131        }
132        NATIVE_OMX_LOADED.set(false);
133      }
134      Looper looper;
135      if ((looper = Looper.myLooper()) != null)
136        mEventHandler = new EventHandler(this, looper);
137      else if ((looper = Looper.getMainLooper()) != null)
138        mEventHandler = new EventHandler(this, looper);
139      else
140        mEventHandler = null;
141      native_init();
142    }
143    static {
144      String LIB_ROOT = Vitamio.getLibraryPath();
145      try {
146        Log.i(&quot;LIB ROOT: %s&quot;, LIB_ROOT);
147        System.load(LIB_ROOT + &quot;libstlport_shared.so&quot;);
148        System.load(LIB_ROOT + &quot;libvplayer.so&quot;);
149        loadFFmpeg_native(LIB_ROOT + &quot;libffmpeg.so&quot;);
150        boolean vvo_loaded = false;
151        if (Build.VERSION.SDK_INT &gt; 8)
152          vvo_loaded = loadVVO_native(LIB_ROOT + &quot;libvvo.9.so&quot;);
153        else if (Build.VERSION.SDK_INT &gt; 7)
154          vvo_loaded = loadVVO_native(LIB_ROOT + &quot;libvvo.8.so&quot;);
155        else
156          vvo_loaded = loadVVO_native(LIB_ROOT + &quot;libvvo.7.so&quot;);
157        if (!vvo_loaded) {
158          vvo_loaded = loadVVO_native(LIB_ROOT + &quot;libvvo.j.so&quot;);
159          Log.d(&quot;FALLBACK TO VVO JNI &quot; + vvo_loaded);
160        }
161        loadVAO_native(LIB_ROOT + &quot;libvao.0.so&quot;);
162      } catch (java.lang.UnsatisfiedLinkError e) {
163        Log.e(&quot;Error loading libs&quot;, e);
164      }
165    }
166    private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj) {
167      MediaPlayer mp = (MediaPlayer) (mediaplayer_ref);
168      if (mp == null)
169        return;
170      if (mp.mEventHandler != null) {
171        Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);
172        mp.mEventHandler.sendMessage(m);
173      }
174    }
175    private static native boolean loadVAO_native(String vaoPath);
176    private static native boolean loadVVO_native(String vvoPath);
177    private static native boolean loadOMX_native(String omxPath);
178    private static native void unloadOMX_native();
179    private static native boolean loadFFmpeg_native(String ffmpegPath);
180    private native void _setVideoSurface(Surface surface);
181    public void setDisplay(SurfaceHolder sh) {
182      if (sh == null) {
183        releaseDisplay();
184      } else {
185        mSurfaceHolder = sh;
186        mSurface = sh.getSurface();
187        _setVideoSurface(mSurface);
188        updateSurfaceScreenOn();
189      }
190    }
191    public void setSurface(Surface surface) {
192      if (surface == null) {
193        releaseDisplay();
194      } else {
195        mSurfaceHolder = null;
196        mSurface = surface;
197        _setVideoSurface(mSurface);
198        updateSurfaceScreenOn();
199      }
200    }
201    public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
202      _setDataSource(path, null, null);
203    }
204    public void setDataSource(Context context, Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
205      setDataSource(context, uri, null);
206    }
207    public void setDataSource(Context context, Uri uri, Map&lt;String, String&gt; headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
208      if (context == null || uri == null)
209        throw new IllegalArgumentException();
210      String scheme = uri.getScheme();
211      if (scheme == null || scheme.equals(&quot;file&quot;)) {
212        setDataSource(FileUtils.getPath(uri.toString()));
213        return;
214      }
215      try {
216        ContentResolver resolver = context.getContentResolver();
217        mFD = resolver.openAssetFileDescriptor(uri, &quot;r&quot;);
218        if (mFD == null)
219          return;
220        setDataSource(mFD.getParcelFileDescriptor().getFileDescriptor());
221        return;
222      } catch (Exception e) {
223        closeFD();
224      }
225      setDataSource(uri.toString(), headers);
226    }
227    public void setDataSource(String path, Map&lt;String, String&gt; headers)
228            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
229    {
230        String[] keys = null;
231        String[] values = null;
232        if (headers != null) {
233            keys = new String[headers.size()];
234            values = new String[headers.size()];
235            int i = 0;
236            for (Map.Entry&lt;String, String&gt; entry: headers.entrySet()) {
237                keys[i] = entry.getKey();
238                values[i] = entry.getValue();
239                ++i;
240            }
241        }
242        setDataSource(path, keys, values);
243    }
244  	public void setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
245  		final Uri uri = Uri.parse(path);
246  		if (&quot;file&quot;.equals(uri.getScheme())) {
247  			path = uri.getPath();
248  		}
249  		final File file = new File(path);
250  		if (file.exists()) {
251  			FileInputStream is = new FileInputStream(file);
252  			FileDescriptor fd = is.getFD();
<span onclick='openModal()' class='match'>253  			setDataSource(fd);
254  			is.close();
255  		} else {
256  			_setDataSource(path, keys, values);
</span>257  		}
258  	}
259    public void setDataSegments(String[] uris, String cacheDir) {
260    	_setDataSegmentsSource(uris, cacheDir);
261    }
262    public void setOnHWRenderFailedListener(OnHWRenderFailedListener l) {
263      mOnHWRenderFailedListener = l;
264    }
265    private native void _setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, IllegalStateException;
266    public native void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException;
267    private native void _setDataSegmentsSource(String[] segments, String cacheDir);
268    public native void prepare() throws IOException, IllegalStateException;
269    public native void prepareAsync() throws IllegalStateException;
270    public void start() throws IllegalStateException {
271      stayAwake(true);
272      _start();
273    }
274    private native void _start() throws IllegalStateException;
275    public void stop() throws IllegalStateException {
276      stayAwake(false);
277      _stop();
278    }
279    private native void _stop() throws IllegalStateException;
280    public void pause() throws IllegalStateException {
281      stayAwake(false);
282      _pause();
283    }
284    private native void _pause() throws IllegalStateException;
285    @SuppressLint(&quot;Wakelock&quot;)
286    public void setWakeMode(Context context, int mode) {
287      boolean washeld = false;
288      if (mWakeLock != null) {
289        if (mWakeLock.isHeld()) {
290          washeld = true;
291          mWakeLock.release();
292        }
293        mWakeLock = null;
294      }
295      PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
296      mWakeLock = pm.newWakeLock(mode | PowerManager.ON_AFTER_RELEASE, MediaPlayer.class.getName());
297      mWakeLock.setReferenceCounted(false);
298      if (washeld) {
299        mWakeLock.acquire();
300      }
301    }
302    public void setScreenOnWhilePlaying(boolean screenOn) {
303      if (mScreenOnWhilePlaying != screenOn) {
304        mScreenOnWhilePlaying = screenOn;
305        updateSurfaceScreenOn();
306      }
307    }
308    @SuppressLint(&quot;Wakelock&quot;)
309    private void stayAwake(boolean awake) {
310      if (mWakeLock != null) {
311        if (awake &amp;&amp; !mWakeLock.isHeld()) {
312          mWakeLock.acquire();
313        } else if (!awake &amp;&amp; mWakeLock.isHeld()) {
314          mWakeLock.release();
315        }
316      }
317      mStayAwake = awake;
318      updateSurfaceScreenOn();
319    }
320    private void updateSurfaceScreenOn() {
321      if (mSurfaceHolder != null)
322        mSurfaceHolder.setKeepScreenOn(mScreenOnWhilePlaying &amp;&amp; mStayAwake);
323    }
324    public native int getVideoWidth();
325    private native int getVideoWidth_a();
326    public native int getVideoHeight();
327    private native int getVideoHeight_a();
328    public native boolean isPlaying();
329    public native void setUseCache(boolean cache);
330    public native void setCacheDirectory(String directory);
331    public native void setAdaptiveStream(boolean adaptive);
332    public native void seekTo(long msec) throws IllegalStateException;
333    public native long getCurrentPosition();
334    public native Bitmap getCurrentFrame();
335    public native long getDuration();
336    public Metadata getMetadata() {
337      if (mMeta == null) {
338        mMeta = new Metadata();
339        Map&lt;byte[], byte[]&gt; meta = new HashMap&lt;byte[], byte[]&gt;();
340        if (!native_getMetadata(meta)) {
341          return null;
342        }
343        if (!mMeta.parse(meta, getMetaEncoding())) {
344          return null;
345        }
346      }
347      return mMeta;
348    }
349    public void release() {
350      stayAwake(false);
351      updateSurfaceScreenOn();
352      mOnPreparedListener = null;
353      mOnBufferingUpdateListener = null;
354      mOnCompletionListener = null;
355      mOnSeekCompleteListener = null;
356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
360      mOnHWRenderFailedListener = null;
361      _release();
362      closeFD();
363    }
364    private native void _release();
365    public void reset() {
366      stayAwake(false);
367      _reset();
368      mEventHandler.removeCallbacksAndMessages(null);
369      closeFD();
370    }
371    private native void _reset();
372    private void closeFD() {
373      if (mFD != null) {
374        try {
375          mFD.close();
376        } catch (IOException e) {
377          Log.e(&quot;closeFD&quot;, e);
378        }
379        mFD = null;
380      }
381    }
382    public native void setLooping(boolean looping);
383    public native boolean isLooping();
384    public native void setAudioAmplify(float ratio);
385    public native void setVolume(float leftVolume, float rightVolume);
386    private native final boolean native_getTrackInfo(SparseArray&lt;byte[]&gt; trackSparse);
387    private native final boolean native_getMetadata(Map&lt;byte[], byte[]&gt; meta);
388    private native final void native_init();
389    private native final void native_finalize();
390    public TrackInfo[] getTrackInfo(String encoding) {
391    	TrackInfo[] trackInfo = getInbandTrackInfo(encoding);
392    	String timedTextPath = getTimedTextPath();
393    	if (TextUtils.isEmpty(timedTextPath)) {
394    		return trackInfo;
395    	}
396      TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + 1];
397      System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
398      int i = trackInfo.length;
399      SparseArray&lt;MediaFormat&gt; trackInfoArray = new SparseArray&lt;MediaFormat&gt;();
400      MediaFormat mediaFormat = new MediaFormat();
401      mediaFormat.setString(MediaFormat.KEY_TITLE, timedTextPath.substring(timedTextPath.lastIndexOf(&quot;/&quot;)));
402      mediaFormat.setString(MediaFormat.KEY_PATH, timedTextPath);
403      SparseArray&lt;MediaFormat&gt; timedTextSparse = findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT, trackInfo);
404      if (timedTextSparse == null || timedTextSparse.size() == 0)
405      	trackInfoArray.put(timedTextSparse.keyAt(0), mediaFormat);
406      else 
407      	trackInfoArray.put(timedTextSparse.keyAt(timedTextSparse.size() - 1), mediaFormat);
408      mOutOfBandTracks = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, trackInfoArray);
409      allTrackInfo[i] = mOutOfBandTracks;
410      return allTrackInfo;
411    }
412    private TrackInfo[] getInbandTrackInfo(String encoding) {
413    	if (mInbandTracks == null) {
414    		SparseArray&lt;byte[]&gt; trackSparse = new SparseArray&lt;byte[]&gt;();
415        if (!native_getTrackInfo(trackSparse)) {
416          return null;
417        }
418        int size = trackSparse.size();
419        mInbandTracks = new TrackInfo[size];
420        for (int i = 0; i &lt; size; i++) {
421        	SparseArray&lt;MediaFormat&gt; sparseArray = parseTrackInfo(trackSparse.valueAt(i), encoding);
422          TrackInfo trackInfo = new TrackInfo(trackSparse.keyAt(i), sparseArray);
423          mInbandTracks[i] = trackInfo;
424        }
425    	}
426      return mInbandTracks;
427    }
428    public TrackInfo[] getTrackInfo() {
429      return getTrackInfo(Charset.defaultCharset().name());
430    }
431    private SparseArray&lt;MediaFormat&gt; parseTrackInfo(byte[] tracks, String encoding) {
432      SparseArray&lt;MediaFormat&gt; trackSparse = new SparseArray&lt;MediaFormat&gt;();
433      String trackString;
434      int trackNum;
435      try {
436        trackString = new String(tracks, encoding);
437      } catch (Exception e) {
438        Log.e(&quot;getTrackMap exception&quot;);
439        trackString = new String(tracks);
440      }
441      for (String s : trackString.split(&quot;!#!&quot;)) {
442        try {
443        	MediaFormat mediaFormat = null;
444        	String[] formats = s.split(&quot;\\.&quot;);
445        	if (formats == null)
446        		continue;
447        	trackNum = Integer.parseInt(formats[0]);
448        	if (formats.length == 3) {
449        		mediaFormat = MediaFormat.createSubtitleFormat(formats[2], formats[1]);
450        	} else if (formats.length == 2) {
451        		mediaFormat = MediaFormat.createSubtitleFormat(&quot;&quot;, formats[1]);
452        	}
453          trackSparse.put(trackNum, mediaFormat);
454        } catch (NumberFormatException e) {
455        }
456      }
457      return trackSparse;
458    }
459    public SparseArray&lt;MediaFormat&gt; findTrackFromTrackInfo(int mediaTrackType, TrackInfo[] trackInfo) {
460      for (int i = 0; i &lt; trackInfo.length; i++) {
461        if (trackInfo[i].getTrackType() == mediaTrackType) {
462          return trackInfo[i].getTrackInfoArray();
463        }
464      }
465      return null;
466    }
467    public native void addTimedTextSource(String path);
468    public void selectTrack(int index) {
469    	selectOrDeselectBandTrack(index, true &amp;bsol;* select */);
470    }
471    public void deselectTrack(int index) {
472    	selectOrDeselectBandTrack(index, false &amp;bsol;* select */);
473    }
474    private void selectOrDeselectBandTrack(int index, boolean select) {
475    	if (mOutOfBandTracks != null) {
476    		SparseArray&lt;MediaFormat&gt; mediaSparse = mOutOfBandTracks.getTrackInfoArray();
477    		int trackIndex = mediaSparse.keyAt(0);
478    		MediaFormat mediaFormat = mediaSparse.valueAt(0);
479      	if (index == trackIndex  &amp;&amp; select) {
480      		addTimedTextSource(mediaFormat.getString(MediaFormat.KEY_PATH));
481      		return;
482      	}
483    	}
484    	selectOrDeselectTrack(index, select);
485    }
486    private native void selectOrDeselectTrack(int index, boolean select);
487    @Override
488    protected void finalize() {
489      native_finalize();
490    }
491    public void setOnPreparedListener(OnPreparedListener listener) {
492      mOnPreparedListener = listener;
493    }
494    public void setOnCompletionListener(OnCompletionListener listener) {
495      mOnCompletionListener = listener;
496    }
497    public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener) {
498      mOnBufferingUpdateListener = listener;
499    }
500    public void setOnCachingUpdateListener(OnCachingUpdateListener listener) {
501      mOnCachingUpdateListener = listener;
502    }
503    private void updateCacheStatus(int type, int info, long[] segments) {
504      if (mEventHandler != null) {
505        Message m = mEventHandler.obtainMessage(MEDIA_CACHING_UPDATE);
506        Bundle b = m.getData();
507        b.putInt(MEDIA_CACHING_TYPE, type);
508        b.putInt(MEDIA_CACHING_INFO, info);
509        b.putLongArray(MEDIA_CACHING_SEGMENTS, segments);
510        mEventHandler.sendMessage(m);
511      }
512    }
513    public void setOnSeekCompleteListener(OnSeekCompleteListener listener) {
514      mOnSeekCompleteListener = listener;
515    }
516    public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener) {
517      mOnVideoSizeChangedListener = listener;
518    }
519    public void setOnErrorListener(OnErrorListener listener) {
520      mOnErrorListener = listener;
521    }
522    public void setOnInfoListener(OnInfoListener listener) {
523      mOnInfoListener = listener;
524    }
525    public void setOnTimedTextListener(OnTimedTextListener listener) {
526      mOnTimedTextListener = listener;
527    }
528    private void updateSub(int subType, byte[] bytes, String encoding, int width, int height) {
529      if (mEventHandler != null) {
530        Message m = mEventHandler.obtainMessage(MEDIA_TIMED_TEXT, width, height);
531        Bundle b = m.getData();
532        if (subType == SUBTITLE_TEXT) {
533          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_TEXT);
534          if (encoding == null) {
535            b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
536          } else {
537            try {
538              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes, encoding.trim()));
539            } catch (UnsupportedEncodingException e) {
540              Log.e(&quot;updateSub&quot;, e);
541              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
542            }
543          }
544        } else if (subType == SUBTITLE_BITMAP) {
545          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_BITMAP);
546          b.putByteArray(MEDIA_SUBTITLE_BYTES, bytes);
547        }
548        mEventHandler.sendMessage(m);
549      }
550    }
551    protected native void _releaseVideoSurface();
552    public void releaseDisplay() {
553      _releaseVideoSurface();
554      mSurfaceHolder = null;
555      mSurface = null;
556    }
557    public native float getVideoAspectRatio();
558    public native void setVideoQuality(int quality);
559    public native void setVideoChroma(int chroma);
560    public native void setDeinterlace(boolean deinterlace);
561    public native void setBufferSize(long bufSize);
562    public native void setPlaybackSpeed(float speed);
563    public native boolean isBuffering();
564    public native int getBufferProgress();
565    public native String getMetaEncoding();
566    public native void setMetaEncoding(String encoding);
567  	public native int getAudioTrack();
568  	public native int getVideoTrack();
569    public native void setTimedTextShown(boolean shown);
570    public native void setTimedTextEncoding(String encoding);
571    public native int getTimedTextLocation();
572    public native String getTimedTextPath();
573    public native int getTimedTextTrack();
574    private int audioTrackInit(int sampleRateInHz, int channels) {
575      audioTrackRelease();
576      int channelConfig = channels &gt;= 2 ? AudioFormat.CHANNEL_OUT_STEREO : AudioFormat.CHANNEL_OUT_MONO;
577      try {
578        mAudioTrackBufferSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT);
579        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT, mAudioTrackBufferSize, AudioTrack.MODE_STREAM);
580      } catch (Exception e) {
581        mAudioTrackBufferSize = 0;
582        Log.e(&quot;audioTrackInit&quot;, e);
583      }
584      return mAudioTrackBufferSize;
585    }
586    private void audioTrackSetVolume(float leftVolume, float rightVolume) {
587      if (mAudioTrack != null)
588        mAudioTrack.setStereoVolume(leftVolume, rightVolume);
589    }
590    private void audioTrackWrite(byte[] audioData, int offsetInBytes, int sizeInBytes) {
591      if (mAudioTrack != null &amp;&amp; mAudioTrack.getPlayState() == AudioTrack.PLAYSTATE_PLAYING) {
592        int written;
593        while (sizeInBytes &gt; 0) {
594          written = sizeInBytes &gt; mAudioTrackBufferSize ? mAudioTrackBufferSize : sizeInBytes;
595          mAudioTrack.write(audioData, offsetInBytes, written);
596          sizeInBytes -= written;
597          offsetInBytes += written;
598        }
599      }
600    }
601    private void audioTrackStart() {
602      if (mAudioTrack != null &amp;&amp; mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED &amp;&amp; mAudioTrack.getPlayState() != AudioTrack.PLAYSTATE_PLAYING)
603        mAudioTrack.play();
604    }
605    private void audioTrackPause() {
606      if (mAudioTrack != null &amp;&amp; mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
607        mAudioTrack.pause();
608    }
609    private void audioTrackRelease() {
610      if (mAudioTrack != null) {
611        if (mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
612          mAudioTrack.stop();
613        mAudioTrack.release();
614      }
615      mAudioTrack = null;
616    }
617    public int getAudioSessionId() {
618  	return mAudioTrack.getAudioSessionId();
619    }
620    private ByteBuffer surfaceInit() {
621      synchronized (this) {
622        mLocalSurface = mSurface;
623        int w = getVideoWidth_a();
624        int h = getVideoHeight_a();
625        if (mLocalSurface != null &amp;&amp; w != 0 &amp;&amp; h != 0) {
626          mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
627          mByteBuffer = ByteBuffer.allocateDirect(w * h * 2);
628        } else {
629          mBitmap = null;
630          mByteBuffer = null;
631        }
632        return mByteBuffer;
633      }
634    }
635    private void surfaceRender() {
636      synchronized (this) {
637        if (mLocalSurface == null || !mLocalSurface.isValid() || mBitmap == null || mByteBuffer == null)
638          return;
639        try {
640          Canvas c = mLocalSurface.lockCanvas(null);
641          mBitmap.copyPixelsFromBuffer(mByteBuffer);
642          c.drawBitmap(mBitmap, 0, 0, null);
643          mLocalSurface.unlockCanvasAndPost(c);
644        } catch (Exception e) {
645          Log.e(&quot;surfaceRender&quot;, e);
646        }
647      }
648    }
649    private void surfaceRelease() {
650      synchronized (this) {
651        mLocalSurface = null;
652        mBitmap = null;
653        mByteBuffer = null;
654      }
655    }
656    public interface OnHWRenderFailedListener {
657      public void onFailed();
658    }
659    public interface OnPreparedListener {
660      void onPrepared(MediaPlayer mp);
661    }
662    public interface OnCompletionListener {
663      void onCompletion(MediaPlayer mp);
664    }
665    public interface OnBufferingUpdateListener {
666      void onBufferingUpdate(MediaPlayer mp, int percent);
667    }
668    public interface OnCachingUpdateListener {
669      void onCachingUpdate(MediaPlayer mp, long[] segments);
670      void onCachingSpeed(MediaPlayer mp, int speed);
671      void onCachingStart(MediaPlayer mp);
672     	void onCachingComplete(MediaPlayer mp); 
673      void onCachingNotAvailable(MediaPlayer mp, int info);
674    }
675    public interface OnSeekCompleteListener {
676      public void onSeekComplete(MediaPlayer mp);
677    }
678    public interface OnVideoSizeChangedListener {
679      public void onVideoSizeChanged(MediaPlayer mp, int width, int height);
680    }
681    public interface OnErrorListener {
682      boolean onError(MediaPlayer mp, int what, int extra);
683    }
684    public interface OnInfoListener {
685      boolean onInfo(MediaPlayer mp, int what, int extra);
686    }
687    public interface OnTimedTextListener {
688      public void onTimedText(String text);
689      public void onTimedTextUpdate(byte[] pixels, int width, int height);
690    }
691    static public class TrackInfo {
692      public static final int MEDIA_TRACK_TYPE_UNKNOWN = 0;
693      public static final int MEDIA_TRACK_TYPE_VIDEO = 1;
694      public static final int MEDIA_TRACK_TYPE_AUDIO = 2;
695      public static final int MEDIA_TRACK_TYPE_TIMEDTEXT = 3;
696      public static final int MEDIA_TRACK_TYPE_SUBTITLE = 4;
697      final int mTrackType;
698      final SparseArray&lt;MediaFormat&gt; mTrackInfoArray;
699      TrackInfo(int trackType, SparseArray&lt;MediaFormat&gt; trackInfoArray) {
700        mTrackType = trackType;
701        mTrackInfoArray = trackInfoArray;
702      }
703      public int getTrackType() {
704        return mTrackType;
705      }
706      public SparseArray&lt;MediaFormat&gt; getTrackInfoArray() {
707        return mTrackInfoArray;
708      }
709    }
710    @SuppressLint(&quot;HandlerLeak&quot;)
711    private class EventHandler extends Handler {
712      private MediaPlayer mMediaPlayer;
713      private Bundle mData;
714      public EventHandler(MediaPlayer mp, Looper looper) {
715        super(looper);
716        mMediaPlayer = mp;
717      }
718      @Override
719      public void handleMessage(Message msg) {
720        switch (msg.what) {
721          case MEDIA_PREPARED:
722            if (mOnPreparedListener != null)
723              mOnPreparedListener.onPrepared(mMediaPlayer);
724            return;
725          case MEDIA_PLAYBACK_COMPLETE:
726            if (mOnCompletionListener != null)
727              mOnCompletionListener.onCompletion(mMediaPlayer);
728            stayAwake(false);
729            return;
730          case MEDIA_BUFFERING_UPDATE:
731            if (mOnBufferingUpdateListener != null)
732              mOnBufferingUpdateListener.onBufferingUpdate(mMediaPlayer, msg.arg1);
733            return;
734          case MEDIA_SEEK_COMPLETE:
735            if (isPlaying())
736              stayAwake(true);
737            if (mOnSeekCompleteListener != null)
738              mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
739            return;
740          case MEDIA_SET_VIDEO_SIZE:
741            if (mOnVideoSizeChangedListener != null)
742              mOnVideoSizeChangedListener.onVideoSizeChanged(mMediaPlayer, msg.arg1, msg.arg2);
743            return;
744          case MEDIA_ERROR:
745            Log.e(&quot;Error (%d, %d)&quot;, msg.arg1, msg.arg2);
746            boolean error_was_handled = false;
747            if (mOnErrorListener != null)
748              error_was_handled = mOnErrorListener.onError(mMediaPlayer, msg.arg1, msg.arg2);
749            if (mOnCompletionListener != null &amp;&amp; !error_was_handled)
750              mOnCompletionListener.onCompletion(mMediaPlayer);
751            stayAwake(false);
752            return;
753          case MEDIA_INFO:
754            Log.i(&quot;Info (%d, %d)&quot;, msg.arg1, msg.arg2);
755            if (mOnInfoListener != null)
756              mOnInfoListener.onInfo(mMediaPlayer, msg.arg1, msg.arg2);
757            return;
758          case MEDIA_CACHE:
759            return;
760          case MEDIA_TIMED_TEXT:
761            mData = msg.getData();
762            if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_TEXT) {
763              Log.i(&quot;Subtitle : %s&quot;, mData.getString(MEDIA_SUBTITLE_STRING));
764              if (mOnTimedTextListener != null)
765                mOnTimedTextListener.onTimedText(mData.getString(MEDIA_SUBTITLE_STRING));
766            } else if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_BITMAP) {
767              Log.i(&quot;Subtitle : bitmap&quot;);
768              if (mOnTimedTextListener != null)
769                mOnTimedTextListener.onTimedTextUpdate(mData.getByteArray(MEDIA_SUBTITLE_BYTES), msg.arg1, msg.arg2);
770            }
771            return;
772          case MEDIA_CACHING_UPDATE:
773            if (mOnCachingUpdateListener != null) {
774              int cacheType = msg.getData().getInt(MEDIA_CACHING_TYPE);
775              if (cacheType == CACHE_TYPE_NOT_AVAILABLE) {
776                mOnCachingUpdateListener.onCachingNotAvailable(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
777              } else if (cacheType == CACHE_TYPE_UPDATE) {
778                mOnCachingUpdateListener.onCachingUpdate(mMediaPlayer, msg.getData().getLongArray(MEDIA_CACHING_SEGMENTS));
779              } else if (cacheType == CACHE_TYPE_SPEED) {
780                mOnCachingUpdateListener.onCachingSpeed(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
781              } else if (cacheType == CACHE_TYPE_START) {
782              	mOnCachingUpdateListener.onCachingStart(mMediaPlayer);
783              } else if (cacheType == CACHE_TYPE_COMPLETE) {
784              	mOnCachingUpdateListener.onCachingComplete(mMediaPlayer);
785              }
786            }
787            return;
788          case MEDIA_NOP:
789            return;
790          case MEDIA_HW_ERROR:
791          	if (mOnHWRenderFailedListener != null)
792          		mOnHWRenderFailedListener.onFailed();
793          	return;
794          default:
795            Log.e(&quot;Unknown message type &quot; + msg.what);
796            return;
797        }
798      }
799    }
800  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-YamlStorageWriter.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</div>
                </div>
                <div class="column column_space"><pre><code>225  			writeEnchantmentLevel(data);
226  			writer.println();
227  		}
228  		else
229  		{
230  			throw new UnsupportedOperationException();
</pre></code></div>
                <div class="column column_space"><pre><code>253  			setDataSource(fd);
254  			is.close();
255  		} else {
256  			_setDataSource(path, keys, values);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    