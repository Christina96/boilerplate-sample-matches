<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for TransportSwapRelationsAction.java &amp; SessionTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TransportSwapRelationsAction.java &amp; SessionTest.java
      </h3>
<h1 align="center">
        12.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TransportSwapRelationsAction.java (36.305733%)<th>SessionTest.java (7.6510067%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(22-52)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(128-132)<td><a href="#" name="1">(203-207)</a><td align="center"><font color="#670000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(105-107)<td><a href="#" name="2">(211-216)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(78-84)<td><a href="#" name="3">(526-532)</a><td align="center"><font color="#550000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportSwapRelationsAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.ddl;

import io.crate.execution.support.ActionListeners;
import io.crate.metadata.RelationName;
import io.crate.metadata.cluster.DDLClusterStateService;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.support.ActiveShardsObserver;
import org.elasticsearch.action.support.IndicesOptions;
import org.elasticsearch.action.support.master.AcknowledgedResponse;
import org.elasticsearch.action.support.master.TransportMasterNodeAction;
import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.block.ClusterBlockException;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.routing.allocation.AllocationService;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.Priority;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.TransportService;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import</b></font> java.util.concurrent.atomic.AtomicReference;

public final class TransportSwapRelationsAction extends TransportMasterNodeAction&lt;SwapRelationsRequest, AcknowledgedResponse&gt; {

    private final SwapRelationsOperation swapRelationsOperation;
    private final ActiveShardsObserver activeShardsObserver;

    @Inject
    public TransportSwapRelationsAction(Settings settings,
                                        TransportService transportService,
                                        ClusterService clusterService,
                                        ThreadPool threadPool,
                                        IndexNameExpressionResolver indexNameExpressionResolver,
                                        DDLClusterStateService ddlClusterStateService,
                                        AllocationService allocationService) {
        super(
            "internal:crate:sql/alter/cluster/indices",
            transportService,
            clusterService,
            threadPool,
            SwapRelationsRequest::new,
            indexNameExpressionResolver
        );
        this.activeShardsObserver = new ActiveShardsObserver(clusterService, threadPool);
        this.swapRelationsOperation = new SwapRelationsOperation(
<a name="3"></a>            allocationService, ddlClusterStateService, indexNameExpressionResolver);
    }

    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    protected String executor() {
        return ThreadPool.Names.SAME;
    }

    @Override
    protected AcknowledgedResponse read(StreamInput in</b></font>) throws IOException {
        return new AcknowledgedResponse(in);
    }

    @Override
    protected void masterOperation(SwapRelationsRequest request,
                                   ClusterState state,
                                   ActionListener&lt;AcknowledgedResponse&gt; listener) throws Exception {
        AtomicReference&lt;String[]&gt; indexNamesAfterRelationSwap = new AtomicReference&lt;&gt;(null);
        ActionListener&lt;AcknowledgedResponse&gt; waitForShardsListener = ActionListeners.waitForShards(
            listener,
            activeShardsObserver,
            request.ackTimeout(),
            () -&gt; logger.info("Switched name of relations, but the operation timed out waiting for enough shards to be started"),
            indexNamesAfterRelationSwap::get
        );
        AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt; updateTask =
            new AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt;(Priority.HIGH, request, waitForShardsListener) {
<a name="2"></a>
                @Override
                public ClusterState execute(ClusterState currentState) throws Exception {
                    if (logger.isInfoEnabled()) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
                        Iterable&lt;String&gt; swapActions = request.swapActions().stream()
                            .map(x -&gt; x.source().fqn() + " &lt;-&gt; " + x.target</b></font>().fqn())
                            ::iterator;
                        logger.info("Swapping tables [{}]", String.join(", ", swapActions));
                    }
                    SwapRelationsOperation.UpdatedState newState = swapRelationsOperation.execute(currentState, request);
                    indexNamesAfterRelationSwap.set(newState.newIndices.toArray(new String[0]));
                    return newState.newState;
                }

                @Override
                protected AcknowledgedResponse newResponse(boolean acknowledged) {
                    return new AcknowledgedResponse(acknowledged);
                }
            };
        clusterService.submitStateUpdateTask("swap-relations", updateTask);
    }

    @Override
<a name="1"></a>    protected ClusterBlockException checkBlock(SwapRelationsRequest request, ClusterState state) {
        Set&lt;String&gt; affectedIndices = new HashSet&lt;&gt;();
        for (RelationNameSwap swapAction : request.swapActions()) {
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.source().indexNameOrAlias())));
            affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.target().indexNameOrAlias())));
        }</b></font>
        for (RelationName dropRelation : request.dropRelations()) {
            affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, dropRelation.indexNameOrAlias())));
        }
        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, affectedIndices.toArray(new String[0]));
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SessionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.action.sql;

import static java.util.concurrent.CompletableFuture.completedFuture;
import static org.hamcrest.Matchers.arrayContaining;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.nullValue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import org.elasticsearch.threadpool.ThreadPool;
import org.hamcrest.Matchers;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import org.mockito.Answers;
import org.mockito.Mockito;

import io.crate.analyze.AnalyzedStatement;
import io.crate.analyze.ParamTypeHints;
import</b></font> io.crate.analyze.Relations;
import io.crate.analyze.TableDefinitions;
import io.crate.auth.AccessControl;
import io.crate.data.Row;
import io.crate.data.RowConsumer;
import io.crate.execution.engine.collect.stats.JobsLogs;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.ParameterSymbol;
import io.crate.expression.symbol.Symbol;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.Plan;
import io.crate.planner.Planner;
import io.crate.planner.PlannerContext;
import io.crate.planner.operators.SubQueryResults;
import io.crate.protocols.postgres.Portal;
import io.crate.sql.parser.SqlParser;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.DataType;
import io.crate.types.DataTypes;

public class SessionTest extends CrateDummyClusterServiceUnitTest {

    @Test
    public void testParameterTypeExtractorNotApplicable() {
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        assertThat(typeExtractor.getParameterTypes(s -&gt; {}).length, is(0));
    }

    @Test
    public void testParameterTypeExtractor() {
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        List&lt;Symbol&gt; symbolsToVisit = new ArrayList&lt;&gt;();
        symbolsToVisit.add(Literal.of(1));
        symbolsToVisit.add(Literal.of("foo"));
        symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
        symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
        symbolsToVisit.add(new ParameterSymbol(3, DataTypes.STRING));
        symbolsToVisit.add(Literal.of("bar"));
        symbolsToVisit.add(new ParameterSymbol(2, DataTypes.DOUBLE));
        symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
        symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
        symbolsToVisit.add(Literal.of(1.2));

        Consumer&lt;Consumer&lt;? super Symbol&gt;&gt; symbolVisitor = c -&gt; {
            for (Symbol symbol : symbolsToVisit) {
                c.accept(symbol);
            }
        };
        DataType[] parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
        assertThat(parameterTypes, equalTo(new DataType[] {
            DataTypes.INTEGER,
            DataTypes.LONG,
            DataTypes.DOUBLE,
            DataTypes.STRING,
        }));

        symbolsToVisit.add(new ParameterSymbol(4, DataTypes.BOOLEAN));
        parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
        assertThat(parameterTypes, equalTo(new DataType[] {
            DataTypes.INTEGER,
            DataTypes.LONG,
            DataTypes.DOUBLE,
            DataTypes.STRING,
            DataTypes.BOOLEAN
        }));

        expectedException.expect(IllegalStateException.class);
        expectedException.expectMessage("The assembled list of ParameterSymbols is invalid.");
        // remove the double parameter =&gt; make the input invalid
        symbolsToVisit.remove(6);
        typeExtractor.getParameterTypes(symbolVisitor);
    }

    @Test
    public void test_out_of_bounds_getParamType_fails() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            mock(DependencyCarrier.class),
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "Select 1 + ? + ?;", Collections.emptyList());
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -&gt; session.getParamType("S_1", 3),
            "foo"
        );
    }

    @Test
    public void test_getParamType_returns_types_infered_from_statement() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "Select 1 + ? + ?;", Collections.emptyList());
        assertThat(session.getParamType("S_1", 0), is(DataTypes.INTEGER));
        assertThat(session.getParamType("S_1", 1), is(DataTypes.INTEGER));

        DescribeResult describe = session.describe('S', "S_1");
        assertThat(describe.getParameters(), equalTo(new DataType[] { DataTypes.INTEGER, DataTypes.INTEGER }));

        assertThat(session.getParamType("S_1", 0), is(DataTypes.INTEGER));
        assertThat(session.getParamType("S_1", 1), is(DataTypes.INTEGER));
    }

    @Test
    public void test_select_query_executed_on_session_execute_method() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        Session session = Mockito.spy(new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            mock(DependencyCarrier.class),
            AccessControl.DISABLED,
            SessionContext.systemSessionContext())
        );

        var activeExecutionFuture = CompletableFuture.completedFuture(null);
        doReturn(activeExecutionFuture)
            .when(session)
            .singleExec(any(Portal.class), any(ResultReceiver.class), anyInt());

        session.parse("S_1", "select name from sys.cluster;", List.of());
        session.bind("Portal", "S_1", Collections.emptyList(), null);
        session.describe('S', "S_1");
        session.execute("Portal", 1, new BaseResultReceiver());

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(activeExecutionFuture));
<a name="1"></a>
        session.close();

        assertThat(session.portals.size(), <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>is(0));
        assertThat(session.preparedStatements.size(), is(0));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(nullValue()));
    }</b></font>
<a name="2"></a>

    @Test
    public void test_flush_triggers_deferred_executions_and_sets_active_execution() throws Exception <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
            .addTable("create table users (name text)")
            .build();
        DependencyCarrier dependencies = mock(DependencyCarrier.class);
        when(dependencies.clusterService</b></font>()).thenReturn(clusterService);
        Session session = Mockito.spy(new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            mock(Planner.class, Answers.RETURNS_MOCKS),
            new JobsLogs(() -&gt; false),
            false,
            dependencies,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext())
        );
        session.parse("", "insert into users (name) values (?)", List.of());
        session.bind("", "", List.of("Arthur"), null);
        session.execute("", -1, new BaseResultReceiver());
        assertThat(session.deferredExecutionsByStmt.size(), is(1));
        session.flush();
        var activeExecution = session.activeExecution;
        assertThat(activeExecution, Matchers.notNullValue());

        CompletableFuture&lt;?&gt; sync = session.sync();
        assertThat(sync, Matchers.sameInstance(activeExecution));
    }

    @Test
    public void testExtractTypesFromDelete() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("delete from users where name = ?"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING }));
    }

    @Test
    public void testExtractTypesFromUpdate() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("update users set name = ? || '_updated' where id = ?"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING, DataTypes.LONG }));
    }

    @Test
    public void testExtractTypesFromInsertValues() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("INSERT INTO users (id, name) values (?, ?)"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.LONG, DataTypes.STRING }));
    }

    @Test
    public void testExtractTypesFromInsertFromQuery() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .enableDefaultTables()
            .build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only " +
                                      "WHERE name = ?)"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING}));
    }

    @Test
    public void testExtractTypesFromInsertWithOnDuplicateKey() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .enableDefaultTables()
            .build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("INSERT INTO users (id, name) values (?, ?) " +
                                      "ON CONFLICT (id) DO UPDATE SET name = ?"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.LONG, DataTypes.STRING, DataTypes.STRING}));

        analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement("INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only " +
                                      "WHERE name = ?) ON CONFLICT (id) DO UPDATE SET name = ?"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        typeExtractor = new ParameterTypeExtractor();
        parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING, DataTypes.STRING}));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubRelation() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement("select * from (select $1::int + $2) t"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubRelationOfInsertStatement() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable("create table t (x int)")
            .build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement("insert into t (x) (select * from (select $1::int + $2) t)"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubQueryInDeleteStatement() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable("create table t (x int)")
            .build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement("delete from t where x = (select $1::long)"),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.LONG)));
    }

    @Test
    public void testProperCleanupOnSessionClose() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "select name from sys.cluster;", Collections.emptyList());
        session.bind("Portal", "S_1", Collections.emptyList(), null);
        session.describe('S', "S_1");

        session.parse("S_2", "select id from sys.cluster", Collections.emptyList());
        session.bind("", "S_2", Collections.emptyList(), null);
        session.describe('S', "S_2");

        assertThat(session.portals.size(), is(2));
        assertThat(session.preparedStatements.size(), is(2));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));

        session.close();

        assertThat(session.portals.size(), is(0));
        assertThat(session.preparedStatements.size(), is(0));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(nullValue()));
    }

    @Test
    public void testDeallocateAllClearsAllPortalsAndPreparedStatements() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "select * from sys.cluster;", Collections.emptyList());
        session.bind("Portal", "S_1", Collections.emptyList(), null);
        session.describe('S', "S_1");

        session.parse("S_2", "DEALLOCATE ALL;", Collections.emptyList());
        session.bind("", "S_2", Collections.emptyList(), null);
        session.execute("", 0, new BaseResultReceiver());

        assertThat(session.portals.size(), greaterThan(0));
        assertThat(session.preparedStatements.size(), is(0));
    }

    @Test
    public void testDeallocatePreparedStatementClearsPreparedStatement() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("test_prep_stmt", "select * from sys.cluster;", Collections.emptyList());
        session.bind("Portal", "test_prep_stmt", Collections.emptyList(), null);
        session.describe('S', "test_prep_stmt");

        session.parse("stmt", "DEALLOCATE test_prep_stmt;", Collections.emptyList());
        session.bind("", "stmt", Collections.emptyList(), null);
        session.execute("", 0, new BaseResultReceiver());

        assertThat(session.portals.size(), greaterThan(0));
        assertThat(session.preparedStatements.size(), is(1));
        assertThat(session.preparedStatements.get("stmt").rawStatement(), is("DEALLOCATE test_prep_stmt;"));
    }

    @Test
    public void test_closing_a_statement_closes_related_portals() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "SELECT 1", List.of());
        session.bind("P_1", "S_1", List.of(), null);

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));

        session.close((byte) 'S', "S_1");
        assertThat(session.portals.entrySet(), Matchers.empty());
        assertThat(session.preparedStatements.entrySet(), Matchers.empty());
    }

    @Test
    public void test_discard_all_discards_all_portals_and_prepared_statements() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "SELECT 1", List.of());
        session.bind("P_1", "S_1", List.of(), null);

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));

        session.parse("stmt", "DISCARD ALL", Collections.emptyList());
        session.bind("", "stmt", Collections.emptyList(), null);
        session.execute("", 0, new BaseResultReceiver());

        assertThat(session.portals.entrySet(), Matchers.empty());
        assertThat(session.preparedStatements.entrySet(), Matchers.empty());
    }

    @Test
    public void test_bulk_operations_result_in_jobslog_entries() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
            .addTable("create table t1 (x int)")
            .build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
<a name="3"></a>        Planner planner = mock(Planner.class);
        when(planner.plan(any(AnalyzedStatement.class), any(PlannerContext.class)))
            .thenReturn(new Plan() {
                            <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
                            public StatementType type() {
                                return StatementType.INSERT;
                            }

                            @Override
                            public void executeOrFail(DependencyCarrier dependencies</b></font>, PlannerContext plannerContext, RowConsumer consumer, Row params, SubQueryResults subQueryResults) throws Exception {

                            }

                            @Override
                            public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier executor, PlannerContext plannerContext, List&lt;Row&gt; bulkParams, SubQueryResults subQueryResults) {
                                return List.of(completedFuture(1L), completedFuture(1L));
                            }
                        }
            );
        JobsLogs jobsLogs = new JobsLogs(() -&gt; true);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            planner,
            jobsLogs,
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse("S_1", "INSERT INTO t1 (x) VALUES (1)", List.of());
        session.bind("P_1", "S_1", List.of(), null);
        session.execute("P_1", 0, new BaseResultReceiver());

        session.bind("P_1", "S_1", List.of(), null);
        session.execute("P_1", 0, new BaseResultReceiver());

        session.sync().get(5, TimeUnit.SECONDS);
        assertThat(jobsLogs.metrics().iterator().next().totalCount(), is(1L));
    }


    @Test
    public void test_can_extract_parameters_from_match_predicate() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable("create table users (name text, keywords text)")
            .build();
        AnalyzedStatement statement = e.analyze(
            "select * from users where match(keywords, ?) using best_fields with (fuzziness= ?) and name = ?");
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(statement::visitSymbols);
        assertThat(parameterTypes, arrayContaining(DataTypes.STRING, DataTypes.UNDEFINED, DataTypes.STRING));
    }


    @Test
    public void test_can_extract_parameters_from_join_condition() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable("create table subscriptions (id text primary key, name text not null)")
            .addTable("create table clusters (id text, subscription_id text)")
            .build();

        AnalyzedStatement stmt = e.analyze("""
            select
                *
            from subscriptions
            join clusters on clusters.subscription_id = subscriptions.id
                AND subscriptions.name = ?
        """);
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(stmt::visitSymbols);
        assertThat(parameterTypes, arrayContaining(DataTypes.STRING));
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
